/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(() => {
var exports = {};
exports.id = "app/auth/login/page";
exports.ids = ["app/auth/login/page"];
exports.modules = {

/***/ "(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader/index.js?name=app%2Fauth%2Flogin%2Fpage&page=%2Fauth%2Flogin%2Fpage&appPaths=%2Fauth%2Flogin%2Fpage&pagePath=private-next-app-dir%2Fauth%2Flogin%2Fpage.js&appDir=D%3A%5Cnext%5Corg%5Csrc%5Capp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=D%3A%5Cnext%5Corg&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D&isGlobalNotFoundEnabled=!":
/*!****************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-app-loader/index.js?name=app%2Fauth%2Flogin%2Fpage&page=%2Fauth%2Flogin%2Fpage&appPaths=%2Fauth%2Flogin%2Fpage&pagePath=private-next-app-dir%2Fauth%2Flogin%2Fpage.js&appDir=D%3A%5Cnext%5Corg%5Csrc%5Capp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=D%3A%5Cnext%5Corg&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D&isGlobalNotFoundEnabled=! ***!
  \****************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GlobalError: () => (/* reexport default from dynamic */ next_dist_client_components_builtin_global_error_js__WEBPACK_IMPORTED_MODULE_25___default.a),\n/* harmony export */   __next_app__: () => (/* binding */ __next_app__),\n/* harmony export */   handler: () => (/* binding */ handler),\n/* harmony export */   pages: () => (/* binding */ pages),\n/* harmony export */   routeModule: () => (/* binding */ routeModule),\n/* harmony export */   tree: () => (/* binding */ tree)\n/* harmony export */ });\n/* harmony import */ var next_dist_server_route_modules_app_page_module_compiled__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/server/route-modules/app-page/module.compiled */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/module.compiled.js?6a4d\");\n/* harmony import */ var next_dist_server_route_modules_app_page_module_compiled__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_route_modules_app_page_module_compiled__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_dist_server_route_kind__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/dist/server/route-kind */ \"(rsc)/./node_modules/next/dist/server/route-kind.js\");\n/* harmony import */ var next_dist_server_instrumentation_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/dist/server/instrumentation/utils */ \"(rsc)/./node_modules/next/dist/server/instrumentation/utils.js\");\n/* harmony import */ var next_dist_server_lib_trace_tracer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! next/dist/server/lib/trace/tracer */ \"(rsc)/./node_modules/next/dist/server/lib/trace/tracer.js\");\n/* harmony import */ var next_dist_server_lib_trace_tracer__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_lib_trace_tracer__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var next_dist_server_request_meta__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! next/dist/server/request-meta */ \"(rsc)/./node_modules/next/dist/server/request-meta.js\");\n/* harmony import */ var next_dist_server_request_meta__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_request_meta__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var next_dist_server_lib_trace_constants__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! next/dist/server/lib/trace/constants */ \"(rsc)/./node_modules/next/dist/server/lib/trace/constants.js\");\n/* harmony import */ var next_dist_server_lib_trace_constants__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_lib_trace_constants__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var next_dist_server_app_render_interop_default__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! next/dist/server/app-render/interop-default */ \"(rsc)/./node_modules/next/dist/server/app-render/interop-default.js\");\n/* harmony import */ var next_dist_server_app_render_strip_flight_headers__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! next/dist/server/app-render/strip-flight-headers */ \"(rsc)/./node_modules/next/dist/server/app-render/strip-flight-headers.js\");\n/* harmony import */ var next_dist_server_base_http_node__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! next/dist/server/base-http/node */ \"(rsc)/./node_modules/next/dist/server/base-http/node.js\");\n/* harmony import */ var next_dist_server_base_http_node__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_base_http_node__WEBPACK_IMPORTED_MODULE_8__);\n/* harmony import */ var next_dist_server_lib_experimental_ppr__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! next/dist/server/lib/experimental/ppr */ \"(rsc)/./node_modules/next/dist/server/lib/experimental/ppr.js\");\n/* harmony import */ var next_dist_server_lib_experimental_ppr__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_lib_experimental_ppr__WEBPACK_IMPORTED_MODULE_9__);\n/* harmony import */ var next_dist_server_request_fallback_params__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! next/dist/server/request/fallback-params */ \"(rsc)/./node_modules/next/dist/server/request/fallback-params.js\");\n/* harmony import */ var next_dist_server_app_render_encryption_utils__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! next/dist/server/app-render/encryption-utils */ \"(rsc)/./node_modules/next/dist/server/app-render/encryption-utils.js\");\n/* harmony import */ var next_dist_server_app_render_encryption_utils__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_app_render_encryption_utils__WEBPACK_IMPORTED_MODULE_11__);\n/* harmony import */ var next_dist_server_lib_streaming_metadata__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! next/dist/server/lib/streaming-metadata */ \"(rsc)/./node_modules/next/dist/server/lib/streaming-metadata.js\");\n/* harmony import */ var next_dist_server_lib_streaming_metadata__WEBPACK_IMPORTED_MODULE_12___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_lib_streaming_metadata__WEBPACK_IMPORTED_MODULE_12__);\n/* harmony import */ var next_dist_server_app_render_action_utils__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! next/dist/server/app-render/action-utils */ \"(rsc)/./node_modules/next/dist/server/app-render/action-utils.js\");\n/* harmony import */ var next_dist_server_app_render_action_utils__WEBPACK_IMPORTED_MODULE_13___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_app_render_action_utils__WEBPACK_IMPORTED_MODULE_13__);\n/* harmony import */ var next_dist_shared_lib_router_utils_app_paths__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! next/dist/shared/lib/router/utils/app-paths */ \"next/dist/shared/lib/router/utils/app-paths\");\n/* harmony import */ var next_dist_shared_lib_router_utils_app_paths__WEBPACK_IMPORTED_MODULE_14___default = /*#__PURE__*/__webpack_require__.n(next_dist_shared_lib_router_utils_app_paths__WEBPACK_IMPORTED_MODULE_14__);\n/* harmony import */ var next_dist_server_lib_server_action_request_meta__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! next/dist/server/lib/server-action-request-meta */ \"(rsc)/./node_modules/next/dist/server/lib/server-action-request-meta.js\");\n/* harmony import */ var next_dist_server_lib_server_action_request_meta__WEBPACK_IMPORTED_MODULE_15___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_lib_server_action_request_meta__WEBPACK_IMPORTED_MODULE_15__);\n/* harmony import */ var next_dist_client_components_app_router_headers__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! next/dist/client/components/app-router-headers */ \"(rsc)/./node_modules/next/dist/client/components/app-router-headers.js\");\n/* harmony import */ var next_dist_client_components_app_router_headers__WEBPACK_IMPORTED_MODULE_16___default = /*#__PURE__*/__webpack_require__.n(next_dist_client_components_app_router_headers__WEBPACK_IMPORTED_MODULE_16__);\n/* harmony import */ var next_dist_shared_lib_router_utils_is_bot__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! next/dist/shared/lib/router/utils/is-bot */ \"next/dist/shared/lib/router/utils/is-bot\");\n/* harmony import */ var next_dist_shared_lib_router_utils_is_bot__WEBPACK_IMPORTED_MODULE_17___default = /*#__PURE__*/__webpack_require__.n(next_dist_shared_lib_router_utils_is_bot__WEBPACK_IMPORTED_MODULE_17__);\n/* harmony import */ var next_dist_server_response_cache__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! next/dist/server/response-cache */ \"(rsc)/./node_modules/next/dist/server/response-cache/index.js\");\n/* harmony import */ var next_dist_server_response_cache__WEBPACK_IMPORTED_MODULE_18___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_response_cache__WEBPACK_IMPORTED_MODULE_18__);\n/* harmony import */ var next_dist_lib_fallback__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! next/dist/lib/fallback */ \"(rsc)/./node_modules/next/dist/lib/fallback.js\");\n/* harmony import */ var next_dist_lib_fallback__WEBPACK_IMPORTED_MODULE_19___default = /*#__PURE__*/__webpack_require__.n(next_dist_lib_fallback__WEBPACK_IMPORTED_MODULE_19__);\n/* harmony import */ var next_dist_server_render_result__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! next/dist/server/render-result */ \"(rsc)/./node_modules/next/dist/server/render-result.js\");\n/* harmony import */ var next_dist_lib_constants__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! next/dist/lib/constants */ \"(rsc)/./node_modules/next/dist/lib/constants.js\");\n/* harmony import */ var next_dist_lib_constants__WEBPACK_IMPORTED_MODULE_21___default = /*#__PURE__*/__webpack_require__.n(next_dist_lib_constants__WEBPACK_IMPORTED_MODULE_21__);\n/* harmony import */ var next_dist_server_stream_utils_encoded_tags__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! next/dist/server/stream-utils/encoded-tags */ \"(rsc)/./node_modules/next/dist/server/stream-utils/encoded-tags.js\");\n/* harmony import */ var next_dist_server_send_payload__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! next/dist/server/send-payload */ \"(rsc)/./node_modules/next/dist/server/send-payload.js\");\n/* harmony import */ var next_dist_server_send_payload__WEBPACK_IMPORTED_MODULE_23___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_send_payload__WEBPACK_IMPORTED_MODULE_23__);\n/* harmony import */ var next_dist_shared_lib_no_fallback_error_external__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! next/dist/shared/lib/no-fallback-error.external */ \"next/dist/shared/lib/no-fallback-error.external\");\n/* harmony import */ var next_dist_shared_lib_no_fallback_error_external__WEBPACK_IMPORTED_MODULE_24___default = /*#__PURE__*/__webpack_require__.n(next_dist_shared_lib_no_fallback_error_external__WEBPACK_IMPORTED_MODULE_24__);\n/* harmony import */ var next_dist_client_components_builtin_global_error_js__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! next/dist/client/components/builtin/global-error.js */ \"(rsc)/./node_modules/next/dist/client/components/builtin/global-error.js\");\n/* harmony import */ var next_dist_client_components_builtin_global_error_js__WEBPACK_IMPORTED_MODULE_25___default = /*#__PURE__*/__webpack_require__.n(next_dist_client_components_builtin_global_error_js__WEBPACK_IMPORTED_MODULE_25__);\n/* harmony import */ var next_dist_server_app_render_entry_base__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! next/dist/server/app-render/entry-base */ \"(rsc)/./node_modules/next/dist/server/app-render/entry-base.js\");\n/* harmony import */ var next_dist_server_app_render_entry_base__WEBPACK_IMPORTED_MODULE_26___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_app_render_entry_base__WEBPACK_IMPORTED_MODULE_26__);\n/* harmony import */ var next_dist_client_components_redirect_status_code__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! next/dist/client/components/redirect-status-code */ \"(rsc)/./node_modules/next/dist/client/components/redirect-status-code.js\");\n/* harmony import */ var next_dist_client_components_redirect_status_code__WEBPACK_IMPORTED_MODULE_27___default = /*#__PURE__*/__webpack_require__.n(next_dist_client_components_redirect_status_code__WEBPACK_IMPORTED_MODULE_27__);\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in next_dist_server_app_render_entry_base__WEBPACK_IMPORTED_MODULE_26__) if([\"default\",\"tree\",\"pages\",\"GlobalError\",\"__next_app__\",\"routeModule\",\"handler\"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => next_dist_server_app_render_entry_base__WEBPACK_IMPORTED_MODULE_26__[__WEBPACK_IMPORT_KEY__]\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\nconst module0 = () => Promise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./src/app/layout.js */ \"(rsc)/./src/app/layout.js\"));\nconst module1 = () => Promise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./src/app/loading.js */ \"(rsc)/./src/app/loading.js\"));\nconst module2 = () => Promise.resolve(/*! import() eager */).then(__webpack_require__.t.bind(__webpack_require__, /*! next/dist/client/components/builtin/global-error.js */ \"(rsc)/./node_modules/next/dist/client/components/builtin/global-error.js\", 23));\nconst module3 = () => Promise.resolve(/*! import() eager */).then(__webpack_require__.t.bind(__webpack_require__, /*! next/dist/client/components/builtin/not-found.js */ \"(rsc)/./node_modules/next/dist/client/components/builtin/not-found.js\", 23));\nconst module4 = () => Promise.resolve(/*! import() eager */).then(__webpack_require__.t.bind(__webpack_require__, /*! next/dist/client/components/builtin/forbidden.js */ \"(rsc)/./node_modules/next/dist/client/components/builtin/forbidden.js\", 23));\nconst module5 = () => Promise.resolve(/*! import() eager */).then(__webpack_require__.t.bind(__webpack_require__, /*! next/dist/client/components/builtin/unauthorized.js */ \"(rsc)/./node_modules/next/dist/client/components/builtin/unauthorized.js\", 23));\nconst page6 = () => Promise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./src/app/auth/login/page.js */ \"(rsc)/./src/app/auth/login/page.js\"));\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// We inject the tree and pages here so that we can use them in the route\n// module.\nconst tree = {\n        children: [\n        '',\n        {\n        children: [\n        'auth',\n        {\n        children: [\n        'login',\n        {\n        children: ['__PAGE__', {}, {\n          page: [page6, \"D:\\\\next\\\\org\\\\src\\\\app\\\\auth\\\\login\\\\page.js\"],\n          \n        }]\n      },\n        {\n        \n        \n      }\n      ]\n      },\n        {\n        \n        metadata: {\n    icon: [(async (props) => (await Promise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! next-metadata-image-loader?type=favicon&segment=&basePath=&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js!./src/app/favicon.ico?__next_metadata__ */ \"(rsc)/./node_modules/next/dist/build/webpack/loaders/next-metadata-image-loader.js?type=favicon&segment=&basePath=&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js!./src/app/favicon.ico?__next_metadata__\"))).default(props))],\n    apple: [],\n    openGraph: [],\n    twitter: [],\n    manifest: undefined\n  }\n      }\n      ]\n      },\n        {\n        'layout': [module0, \"D:\\\\next\\\\org\\\\src\\\\app\\\\layout.js\"],\n'loading': [module1, \"D:\\\\next\\\\org\\\\src\\\\app\\\\loading.js\"],\n'global-error': [module2, \"next/dist/client/components/builtin/global-error.js\"],\n'not-found': [module3, \"next/dist/client/components/builtin/not-found.js\"],\n'forbidden': [module4, \"next/dist/client/components/builtin/forbidden.js\"],\n'unauthorized': [module5, \"next/dist/client/components/builtin/unauthorized.js\"],\n        metadata: {\n    icon: [(async (props) => (await Promise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! next-metadata-image-loader?type=favicon&segment=&basePath=&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js!./src/app/favicon.ico?__next_metadata__ */ \"(rsc)/./node_modules/next/dist/build/webpack/loaders/next-metadata-image-loader.js?type=favicon&segment=&basePath=&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js!./src/app/favicon.ico?__next_metadata__\"))).default(props))],\n    apple: [],\n    openGraph: [],\n    twitter: [],\n    manifest: undefined\n  }\n      }\n      ]\n      }.children;\nconst pages = [\"D:\\\\next\\\\org\\\\src\\\\app\\\\auth\\\\login\\\\page.js\"];\n\n\n\nconst __next_app_require__ = __webpack_require__\nconst __next_app_load_chunk__ = () => Promise.resolve()\nconst __next_app__ = {\n    require: __next_app_require__,\n    loadChunk: __next_app_load_chunk__\n};\n\n\n\n// Create and export the route module that will be consumed.\nconst routeModule = new next_dist_server_route_modules_app_page_module_compiled__WEBPACK_IMPORTED_MODULE_0__.AppPageRouteModule({\n    definition: {\n        kind: next_dist_server_route_kind__WEBPACK_IMPORTED_MODULE_1__.RouteKind.APP_PAGE,\n        page: \"/auth/login/page\",\n        pathname: \"/auth/login\",\n        // The following aren't used in production.\n        bundlePath: '',\n        filename: '',\n        appPaths: []\n    },\n    userland: {\n        loaderTree: tree\n    },\n    distDir: \".next\" || 0,\n    relativeProjectDir:  false || ''\n});\nasync function handler(req, res, ctx) {\n    var _this;\n    let srcPage = \"/auth/login/page\";\n    // turbopack doesn't normalize `/index` in the page name\n    // so we need to to process dynamic routes properly\n    // TODO: fix turbopack providing differing value from webpack\n    if (false) {} else if (srcPage === '/index') {\n        // we always normalize /index specifically\n        srcPage = '/';\n    }\n    const multiZoneDraftMode = false;\n    const initialPostponed = (0,next_dist_server_request_meta__WEBPACK_IMPORTED_MODULE_4__.getRequestMeta)(req, 'postponed');\n    // TODO: replace with more specific flags\n    const minimalMode = (0,next_dist_server_request_meta__WEBPACK_IMPORTED_MODULE_4__.getRequestMeta)(req, 'minimalMode');\n    const prepareResult = await routeModule.prepare(req, res, {\n        srcPage,\n        multiZoneDraftMode\n    });\n    if (!prepareResult) {\n        res.statusCode = 400;\n        res.end('Bad Request');\n        ctx.waitUntil == null ? void 0 : ctx.waitUntil.call(ctx, Promise.resolve());\n        return null;\n    }\n    const { buildId, query, params, parsedUrl, pageIsDynamic, buildManifest, nextFontManifest, reactLoadableManifest, serverActionsManifest, clientReferenceManifest, subresourceIntegrityManifest, prerenderManifest, isDraftMode, resolvedPathname, revalidateOnlyGenerated, routerServerContext, nextConfig, interceptionRoutePatterns } = prepareResult;\n    const pathname = parsedUrl.pathname || '/';\n    const normalizedSrcPage = (0,next_dist_shared_lib_router_utils_app_paths__WEBPACK_IMPORTED_MODULE_14__.normalizeAppPath)(srcPage);\n    let { isOnDemandRevalidate } = prepareResult;\n    const prerenderInfo = routeModule.match(pathname, prerenderManifest);\n    const isPrerendered = !!prerenderManifest.routes[resolvedPathname];\n    let isSSG = Boolean(prerenderInfo || isPrerendered || prerenderManifest.routes[normalizedSrcPage]);\n    const userAgent = req.headers['user-agent'] || '';\n    const botType = (0,next_dist_shared_lib_router_utils_is_bot__WEBPACK_IMPORTED_MODULE_17__.getBotType)(userAgent);\n    const isHtmlBot = (0,next_dist_server_lib_streaming_metadata__WEBPACK_IMPORTED_MODULE_12__.isHtmlBotRequest)(req);\n    /**\n   * If true, this indicates that the request being made is for an app\n   * prefetch request.\n   */ const isPrefetchRSCRequest = (0,next_dist_server_request_meta__WEBPACK_IMPORTED_MODULE_4__.getRequestMeta)(req, 'isPrefetchRSCRequest') ?? req.headers[next_dist_client_components_app_router_headers__WEBPACK_IMPORTED_MODULE_16__.NEXT_ROUTER_PREFETCH_HEADER] === '1' // exclude runtime prefetches, which use '2'\n    ;\n    // NOTE: Don't delete headers[RSC] yet, it still needs to be used in renderToHTML later\n    const isRSCRequest = (0,next_dist_server_request_meta__WEBPACK_IMPORTED_MODULE_4__.getRequestMeta)(req, 'isRSCRequest') ?? Boolean(req.headers[next_dist_client_components_app_router_headers__WEBPACK_IMPORTED_MODULE_16__.RSC_HEADER]);\n    const isPossibleServerAction = (0,next_dist_server_lib_server_action_request_meta__WEBPACK_IMPORTED_MODULE_15__.getIsPossibleServerAction)(req);\n    /**\n   * If the route being rendered is an app page, and the ppr feature has been\n   * enabled, then the given route _could_ support PPR.\n   */ const couldSupportPPR = (0,next_dist_server_lib_experimental_ppr__WEBPACK_IMPORTED_MODULE_9__.checkIsAppPPREnabled)(nextConfig.experimental.ppr);\n    // When enabled, this will allow the use of the `?__nextppronly` query to\n    // enable debugging of the static shell.\n    const hasDebugStaticShellQuery =  false && 0;\n    // When enabled, this will allow the use of the `?__nextppronly` query\n    // to enable debugging of the fallback shell.\n    const hasDebugFallbackShellQuery = hasDebugStaticShellQuery && query.__nextppronly === 'fallback';\n    // This page supports PPR if it is marked as being `PARTIALLY_STATIC` in the\n    // prerender manifest and this is an app page.\n    const isRoutePPREnabled = couldSupportPPR && (((_this = prerenderManifest.routes[normalizedSrcPage] ?? prerenderManifest.dynamicRoutes[normalizedSrcPage]) == null ? void 0 : _this.renderingMode) === 'PARTIALLY_STATIC' || // Ideally we'd want to check the appConfig to see if this page has PPR\n    // enabled or not, but that would require plumbing the appConfig through\n    // to the server during development. We assume that the page supports it\n    // but only during development.\n    hasDebugStaticShellQuery && (routeModule.isDev === true || (routerServerContext == null ? void 0 : routerServerContext.experimentalTestProxy) === true));\n    const isDebugStaticShell = hasDebugStaticShellQuery && isRoutePPREnabled;\n    // We should enable debugging dynamic accesses when the static shell\n    // debugging has been enabled and we're also in development mode.\n    const isDebugDynamicAccesses = isDebugStaticShell && routeModule.isDev === true;\n    const isDebugFallbackShell = hasDebugFallbackShellQuery && isRoutePPREnabled;\n    // If we're in minimal mode, then try to get the postponed information from\n    // the request metadata. If available, use it for resuming the postponed\n    // render.\n    const minimalPostponed = isRoutePPREnabled ? initialPostponed : undefined;\n    // If PPR is enabled, and this is a RSC request (but not a prefetch), then\n    // we can use this fact to only generate the flight data for the request\n    // because we can't cache the HTML (as it's also dynamic).\n    const isDynamicRSCRequest = isRoutePPREnabled && isRSCRequest && !isPrefetchRSCRequest;\n    // Need to read this before it's stripped by stripFlightHeaders. We don't\n    // need to transfer it to the request meta because it's only read\n    // within this function; the static segment data should have already been\n    // generated, so we will always either return a static response or a 404.\n    const segmentPrefetchHeader = (0,next_dist_server_request_meta__WEBPACK_IMPORTED_MODULE_4__.getRequestMeta)(req, 'segmentPrefetchRSCRequest');\n    // TODO: investigate existing bug with shouldServeStreamingMetadata always\n    // being true for a revalidate due to modifying the base-server this.renderOpts\n    // when fixing this to correct logic it causes hydration issue since we set\n    // serveStreamingMetadata to true during export\n    let serveStreamingMetadata = !userAgent ? true : (0,next_dist_server_lib_streaming_metadata__WEBPACK_IMPORTED_MODULE_12__.shouldServeStreamingMetadata)(userAgent, nextConfig.htmlLimitedBots);\n    if (isHtmlBot && isRoutePPREnabled) {\n        isSSG = false;\n        serveStreamingMetadata = false;\n    }\n    // In development, we always want to generate dynamic HTML.\n    let supportsDynamicResponse = // If we're in development, we always support dynamic HTML, unless it's\n    // a data request, in which case we only produce static HTML.\n    routeModule.isDev === true || // If this is not SSG or does not have static paths, then it supports\n    // dynamic HTML.\n    !isSSG || // If this request has provided postponed data, it supports dynamic\n    // HTML.\n    typeof initialPostponed === 'string' || // If this is a dynamic RSC request, then this render supports dynamic\n    // HTML (it's dynamic).\n    isDynamicRSCRequest;\n    // When html bots request PPR page, perform the full dynamic rendering.\n    const shouldWaitOnAllReady = isHtmlBot && isRoutePPREnabled;\n    let ssgCacheKey = null;\n    if (!isDraftMode && isSSG && !supportsDynamicResponse && !isPossibleServerAction && !minimalPostponed && !isDynamicRSCRequest) {\n        ssgCacheKey = resolvedPathname;\n    }\n    // the staticPathKey differs from ssgCacheKey since\n    // ssgCacheKey is null in dev since we're always in \"dynamic\"\n    // mode in dev to bypass the cache, but we still need to honor\n    // dynamicParams = false in dev mode\n    let staticPathKey = ssgCacheKey;\n    if (!staticPathKey && routeModule.isDev) {\n        staticPathKey = resolvedPathname;\n    }\n    // If this is a request for an app path that should be statically generated\n    // and we aren't in the edge runtime, strip the flight headers so it will\n    // generate the static response.\n    if (!routeModule.isDev && !isDraftMode && isSSG && isRSCRequest && !isDynamicRSCRequest) {\n        (0,next_dist_server_app_render_strip_flight_headers__WEBPACK_IMPORTED_MODULE_7__.stripFlightHeaders)(req.headers);\n    }\n    const ComponentMod = {\n        ...next_dist_server_app_render_entry_base__WEBPACK_IMPORTED_MODULE_26__,\n        tree,\n        pages,\n        GlobalError: (next_dist_client_components_builtin_global_error_js__WEBPACK_IMPORTED_MODULE_25___default()),\n        handler,\n        routeModule,\n        __next_app__\n    };\n    // Before rendering (which initializes component tree modules), we have to\n    // set the reference manifests to our global store so Server Action's\n    // encryption util can access to them at the top level of the page module.\n    if (serverActionsManifest && clientReferenceManifest) {\n        (0,next_dist_server_app_render_encryption_utils__WEBPACK_IMPORTED_MODULE_11__.setReferenceManifestsSingleton)({\n            page: srcPage,\n            clientReferenceManifest,\n            serverActionsManifest,\n            serverModuleMap: (0,next_dist_server_app_render_action_utils__WEBPACK_IMPORTED_MODULE_13__.createServerModuleMap)({\n                serverActionsManifest\n            })\n        });\n    }\n    const method = req.method || 'GET';\n    const tracer = (0,next_dist_server_lib_trace_tracer__WEBPACK_IMPORTED_MODULE_3__.getTracer)();\n    const activeSpan = tracer.getActiveScopeSpan();\n    try {\n        const varyHeader = routeModule.getVaryHeader(resolvedPathname, interceptionRoutePatterns);\n        res.setHeader('Vary', varyHeader);\n        const invokeRouteModule = async (span, context)=>{\n            const nextReq = new next_dist_server_base_http_node__WEBPACK_IMPORTED_MODULE_8__.NodeNextRequest(req);\n            const nextRes = new next_dist_server_base_http_node__WEBPACK_IMPORTED_MODULE_8__.NodeNextResponse(res);\n            // TODO: adapt for putting the RDC inside the postponed data\n            // If we're in dev, and this isn't a prefetch or a server action,\n            // we should seed the resume data cache.\n            if (true) {\n                if (nextConfig.experimental.cacheComponents && !isPrefetchRSCRequest && !context.renderOpts.isPossibleServerAction) {\n                    const warmup = await routeModule.warmup(nextReq, nextRes, context);\n                    // If the warmup is successful, we should use the resume data\n                    // cache from the warmup.\n                    if (warmup.metadata.renderResumeDataCache) {\n                        context.renderOpts.renderResumeDataCache = warmup.metadata.renderResumeDataCache;\n                    }\n                }\n            }\n            return routeModule.render(nextReq, nextRes, context).finally(()=>{\n                if (!span) return;\n                span.setAttributes({\n                    'http.status_code': res.statusCode,\n                    'next.rsc': false\n                });\n                const rootSpanAttributes = tracer.getRootSpanAttributes();\n                // We were unable to get attributes, probably OTEL is not enabled\n                if (!rootSpanAttributes) {\n                    return;\n                }\n                if (rootSpanAttributes.get('next.span_type') !== next_dist_server_lib_trace_constants__WEBPACK_IMPORTED_MODULE_5__.BaseServerSpan.handleRequest) {\n                    console.warn(`Unexpected root span type '${rootSpanAttributes.get('next.span_type')}'. Please report this Next.js issue https://github.com/vercel/next.js`);\n                    return;\n                }\n                const route = rootSpanAttributes.get('next.route');\n                if (route) {\n                    const name = `${method} ${route}`;\n                    span.setAttributes({\n                        'next.route': route,\n                        'http.route': route,\n                        'next.span_name': name\n                    });\n                    span.updateName(name);\n                } else {\n                    span.updateName(`${method} ${req.url}`);\n                }\n            });\n        };\n        const doRender = async ({ span, postponed, fallbackRouteParams })=>{\n            const context = {\n                query,\n                params,\n                page: normalizedSrcPage,\n                sharedContext: {\n                    buildId\n                },\n                serverComponentsHmrCache: (0,next_dist_server_request_meta__WEBPACK_IMPORTED_MODULE_4__.getRequestMeta)(req, 'serverComponentsHmrCache'),\n                fallbackRouteParams,\n                renderOpts: {\n                    App: ()=>null,\n                    Document: ()=>null,\n                    pageConfig: {},\n                    ComponentMod,\n                    Component: (0,next_dist_server_app_render_interop_default__WEBPACK_IMPORTED_MODULE_6__.interopDefault)(ComponentMod),\n                    params,\n                    routeModule,\n                    page: srcPage,\n                    postponed,\n                    shouldWaitOnAllReady,\n                    serveStreamingMetadata,\n                    supportsDynamicResponse: typeof postponed === 'string' || supportsDynamicResponse,\n                    buildManifest,\n                    nextFontManifest,\n                    reactLoadableManifest,\n                    subresourceIntegrityManifest,\n                    serverActionsManifest,\n                    clientReferenceManifest,\n                    setIsrStatus: routerServerContext == null ? void 0 : routerServerContext.setIsrStatus,\n                    dir:  true ? (__webpack_require__(/*! path */ \"path\").join)(/* turbopackIgnore: true */ process.cwd(), routeModule.relativeProjectDir) : 0,\n                    isDraftMode,\n                    isRevalidate: isSSG && !postponed && !isDynamicRSCRequest,\n                    botType,\n                    isOnDemandRevalidate,\n                    isPossibleServerAction,\n                    assetPrefix: nextConfig.assetPrefix,\n                    nextConfigOutput: nextConfig.output,\n                    crossOrigin: nextConfig.crossOrigin,\n                    trailingSlash: nextConfig.trailingSlash,\n                    previewProps: prerenderManifest.preview,\n                    deploymentId: nextConfig.deploymentId,\n                    enableTainting: nextConfig.experimental.taint,\n                    htmlLimitedBots: nextConfig.htmlLimitedBots,\n                    devtoolSegmentExplorer: nextConfig.experimental.devtoolSegmentExplorer,\n                    reactMaxHeadersLength: nextConfig.reactMaxHeadersLength,\n                    multiZoneDraftMode,\n                    incrementalCache: (0,next_dist_server_request_meta__WEBPACK_IMPORTED_MODULE_4__.getRequestMeta)(req, 'incrementalCache'),\n                    cacheLifeProfiles: nextConfig.experimental.cacheLife,\n                    basePath: nextConfig.basePath,\n                    serverActions: nextConfig.experimental.serverActions,\n                    ...isDebugStaticShell || isDebugDynamicAccesses ? {\n                        nextExport: true,\n                        supportsDynamicResponse: false,\n                        isStaticGeneration: true,\n                        isRevalidate: true,\n                        isDebugDynamicAccesses: isDebugDynamicAccesses\n                    } : {},\n                    experimental: {\n                        isRoutePPREnabled,\n                        expireTime: nextConfig.expireTime,\n                        staleTimes: nextConfig.experimental.staleTimes,\n                        cacheComponents: Boolean(nextConfig.experimental.cacheComponents),\n                        clientSegmentCache: Boolean(nextConfig.experimental.clientSegmentCache),\n                        clientParamParsing: Boolean(nextConfig.experimental.clientParamParsing),\n                        dynamicOnHover: Boolean(nextConfig.experimental.dynamicOnHover),\n                        inlineCss: Boolean(nextConfig.experimental.inlineCss),\n                        authInterrupts: Boolean(nextConfig.experimental.authInterrupts),\n                        clientTraceMetadata: nextConfig.experimental.clientTraceMetadata || []\n                    },\n                    waitUntil: ctx.waitUntil,\n                    onClose: (cb)=>{\n                        res.on('close', cb);\n                    },\n                    onAfterTaskError: ()=>{},\n                    onInstrumentationRequestError: (error, _request, errorContext)=>routeModule.onRequestError(req, error, errorContext, routerServerContext),\n                    err: (0,next_dist_server_request_meta__WEBPACK_IMPORTED_MODULE_4__.getRequestMeta)(req, 'invokeError'),\n                    dev: routeModule.isDev\n                }\n            };\n            const result = await invokeRouteModule(span, context);\n            const { metadata } = result;\n            const { cacheControl, headers = {}, // Add any fetch tags that were on the page to the response headers.\n            fetchTags: cacheTags } = metadata;\n            if (cacheTags) {\n                headers[next_dist_lib_constants__WEBPACK_IMPORTED_MODULE_21__.NEXT_CACHE_TAGS_HEADER] = cacheTags;\n            }\n            // Pull any fetch metrics from the render onto the request.\n            ;\n            req.fetchMetrics = metadata.fetchMetrics;\n            // we don't throw static to dynamic errors in dev as isSSG\n            // is a best guess in dev since we don't have the prerender pass\n            // to know whether the path is actually static or not\n            if (isSSG && (cacheControl == null ? void 0 : cacheControl.revalidate) === 0 && !routeModule.isDev && !isRoutePPREnabled) {\n                const staticBailoutInfo = metadata.staticBailoutInfo;\n                const err = Object.defineProperty(new Error(`Page changed from static to dynamic at runtime ${resolvedPathname}${(staticBailoutInfo == null ? void 0 : staticBailoutInfo.description) ? `, reason: ${staticBailoutInfo.description}` : ``}` + `\\nsee more here https://nextjs.org/docs/messages/app-static-to-dynamic-error`), \"__NEXT_ERROR_CODE\", {\n                    value: \"E132\",\n                    enumerable: false,\n                    configurable: true\n                });\n                if (staticBailoutInfo == null ? void 0 : staticBailoutInfo.stack) {\n                    const stack = staticBailoutInfo.stack;\n                    err.stack = err.message + stack.substring(stack.indexOf('\\n'));\n                }\n                throw err;\n            }\n            return {\n                value: {\n                    kind: next_dist_server_response_cache__WEBPACK_IMPORTED_MODULE_18__.CachedRouteKind.APP_PAGE,\n                    html: result,\n                    headers,\n                    rscData: metadata.flightData,\n                    postponed: metadata.postponed,\n                    status: metadata.statusCode,\n                    segmentData: metadata.segmentData\n                },\n                cacheControl\n            };\n        };\n        const responseGenerator = async ({ hasResolved, previousCacheEntry, isRevalidating, span })=>{\n            const isProduction = routeModule.isDev === false;\n            const didRespond = hasResolved || res.writableEnded;\n            // skip on-demand revalidate if cache is not present and\n            // revalidate-if-generated is set\n            if (isOnDemandRevalidate && revalidateOnlyGenerated && !previousCacheEntry && !minimalMode) {\n                if (routerServerContext == null ? void 0 : routerServerContext.render404) {\n                    await routerServerContext.render404(req, res);\n                } else {\n                    res.statusCode = 404;\n                    res.end('This page could not be found');\n                }\n                return null;\n            }\n            let fallbackMode;\n            if (prerenderInfo) {\n                fallbackMode = (0,next_dist_lib_fallback__WEBPACK_IMPORTED_MODULE_19__.parseFallbackField)(prerenderInfo.fallback);\n            }\n            // When serving a HTML bot request, we want to serve a blocking render and\n            // not the prerendered page. This ensures that the correct content is served\n            // to the bot in the head.\n            if (fallbackMode === next_dist_lib_fallback__WEBPACK_IMPORTED_MODULE_19__.FallbackMode.PRERENDER && (0,next_dist_shared_lib_router_utils_is_bot__WEBPACK_IMPORTED_MODULE_17__.isBot)(userAgent)) {\n                if (!isRoutePPREnabled || isHtmlBot) {\n                    fallbackMode = next_dist_lib_fallback__WEBPACK_IMPORTED_MODULE_19__.FallbackMode.BLOCKING_STATIC_RENDER;\n                }\n            }\n            if ((previousCacheEntry == null ? void 0 : previousCacheEntry.isStale) === -1) {\n                isOnDemandRevalidate = true;\n            }\n            // TODO: adapt for PPR\n            // only allow on-demand revalidate for fallback: true/blocking\n            // or for prerendered fallback: false paths\n            if (isOnDemandRevalidate && (fallbackMode !== next_dist_lib_fallback__WEBPACK_IMPORTED_MODULE_19__.FallbackMode.NOT_FOUND || previousCacheEntry)) {\n                fallbackMode = next_dist_lib_fallback__WEBPACK_IMPORTED_MODULE_19__.FallbackMode.BLOCKING_STATIC_RENDER;\n            }\n            if (!minimalMode && fallbackMode !== next_dist_lib_fallback__WEBPACK_IMPORTED_MODULE_19__.FallbackMode.BLOCKING_STATIC_RENDER && staticPathKey && !didRespond && !isDraftMode && pageIsDynamic && (isProduction || !isPrerendered)) {\n                // if the page has dynamicParams: false and this pathname wasn't\n                // prerendered trigger the no fallback handling\n                if (// In development, fall through to render to handle missing\n                // getStaticPaths.\n                (isProduction || prerenderInfo) && // When fallback isn't present, abort this render so we 404\n                fallbackMode === next_dist_lib_fallback__WEBPACK_IMPORTED_MODULE_19__.FallbackMode.NOT_FOUND) {\n                    throw new next_dist_shared_lib_no_fallback_error_external__WEBPACK_IMPORTED_MODULE_24__.NoFallbackError();\n                }\n                let fallbackResponse;\n                if (isRoutePPREnabled && !isRSCRequest) {\n                    const cacheKey = typeof (prerenderInfo == null ? void 0 : prerenderInfo.fallback) === 'string' ? prerenderInfo.fallback : isProduction ? normalizedSrcPage : null;\n                    // We use the response cache here to handle the revalidation and\n                    // management of the fallback shell.\n                    fallbackResponse = await routeModule.handleResponse({\n                        cacheKey,\n                        req,\n                        nextConfig,\n                        routeKind: next_dist_server_route_kind__WEBPACK_IMPORTED_MODULE_1__.RouteKind.APP_PAGE,\n                        isFallback: true,\n                        prerenderManifest,\n                        isRoutePPREnabled,\n                        responseGenerator: async ()=>doRender({\n                                span,\n                                // We pass `undefined` as rendering a fallback isn't resumed\n                                // here.\n                                postponed: undefined,\n                                fallbackRouteParams: // If we're in production or we're debugging the fallback\n                                // shell then we should postpone when dynamic params are\n                                // accessed.\n                                isProduction || isDebugFallbackShell ? (0,next_dist_server_request_fallback_params__WEBPACK_IMPORTED_MODULE_10__.getFallbackRouteParams)(normalizedSrcPage) : null\n                            }),\n                        waitUntil: ctx.waitUntil\n                    });\n                    // If the fallback response was set to null, then we should return null.\n                    if (fallbackResponse === null) return null;\n                    // Otherwise, if we did get a fallback response, we should return it.\n                    if (fallbackResponse) {\n                        // Remove the cache control from the response to prevent it from being\n                        // used in the surrounding cache.\n                        delete fallbackResponse.cacheControl;\n                        return fallbackResponse;\n                    }\n                }\n            }\n            // Only requests that aren't revalidating can be resumed. If we have the\n            // minimal postponed data, then we should resume the render with it.\n            const postponed = !isOnDemandRevalidate && !isRevalidating && minimalPostponed ? minimalPostponed : undefined;\n            // When we're in minimal mode, if we're trying to debug the static shell,\n            // we should just return nothing instead of resuming the dynamic render.\n            if ((isDebugStaticShell || isDebugDynamicAccesses) && typeof postponed !== 'undefined') {\n                return {\n                    cacheControl: {\n                        revalidate: 1,\n                        expire: undefined\n                    },\n                    value: {\n                        kind: next_dist_server_response_cache__WEBPACK_IMPORTED_MODULE_18__.CachedRouteKind.PAGES,\n                        html: next_dist_server_render_result__WEBPACK_IMPORTED_MODULE_20__[\"default\"].EMPTY,\n                        pageData: {},\n                        headers: undefined,\n                        status: undefined\n                    }\n                };\n            }\n            // If this is a dynamic route with PPR enabled and the default route\n            // matches were set, then we should pass the fallback route params to\n            // the renderer as this is a fallback revalidation request.\n            const fallbackRouteParams = pageIsDynamic && isRoutePPREnabled && ((0,next_dist_server_request_meta__WEBPACK_IMPORTED_MODULE_4__.getRequestMeta)(req, 'renderFallbackShell') || isDebugFallbackShell) ? (0,next_dist_server_request_fallback_params__WEBPACK_IMPORTED_MODULE_10__.getFallbackRouteParams)(pathname) : null;\n            // Perform the render.\n            return doRender({\n                span,\n                postponed,\n                fallbackRouteParams\n            });\n        };\n        const handleResponse = async (span)=>{\n            var _cacheEntry_value, _cachedData_headers;\n            const cacheEntry = await routeModule.handleResponse({\n                cacheKey: ssgCacheKey,\n                responseGenerator: (c)=>responseGenerator({\n                        span,\n                        ...c\n                    }),\n                routeKind: next_dist_server_route_kind__WEBPACK_IMPORTED_MODULE_1__.RouteKind.APP_PAGE,\n                isOnDemandRevalidate,\n                isRoutePPREnabled,\n                req,\n                nextConfig,\n                prerenderManifest,\n                waitUntil: ctx.waitUntil\n            });\n            if (isDraftMode) {\n                res.setHeader('Cache-Control', 'private, no-cache, no-store, max-age=0, must-revalidate');\n            }\n            // In dev, we should not cache pages for any reason.\n            if (routeModule.isDev) {\n                res.setHeader('Cache-Control', 'no-store, must-revalidate');\n            }\n            if (!cacheEntry) {\n                if (ssgCacheKey) {\n                    // A cache entry might not be generated if a response is written\n                    // in `getInitialProps` or `getServerSideProps`, but those shouldn't\n                    // have a cache key. If we do have a cache key but we don't end up\n                    // with a cache entry, then either Next.js or the application has a\n                    // bug that needs fixing.\n                    throw Object.defineProperty(new Error('invariant: cache entry required but not generated'), \"__NEXT_ERROR_CODE\", {\n                        value: \"E62\",\n                        enumerable: false,\n                        configurable: true\n                    });\n                }\n                return null;\n            }\n            if (((_cacheEntry_value = cacheEntry.value) == null ? void 0 : _cacheEntry_value.kind) !== next_dist_server_response_cache__WEBPACK_IMPORTED_MODULE_18__.CachedRouteKind.APP_PAGE) {\n                var _cacheEntry_value1;\n                throw Object.defineProperty(new Error(`Invariant app-page handler received invalid cache entry ${(_cacheEntry_value1 = cacheEntry.value) == null ? void 0 : _cacheEntry_value1.kind}`), \"__NEXT_ERROR_CODE\", {\n                    value: \"E707\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n            const didPostpone = typeof cacheEntry.value.postponed === 'string';\n            if (isSSG && // We don't want to send a cache header for requests that contain dynamic\n            // data. If this is a Dynamic RSC request or wasn't a Prefetch RSC\n            // request, then we should set the cache header.\n            !isDynamicRSCRequest && (!didPostpone || isPrefetchRSCRequest)) {\n                if (!minimalMode) {\n                    // set x-nextjs-cache header to match the header\n                    // we set for the image-optimizer\n                    res.setHeader('x-nextjs-cache', isOnDemandRevalidate ? 'REVALIDATED' : cacheEntry.isMiss ? 'MISS' : cacheEntry.isStale ? 'STALE' : 'HIT');\n                }\n                // Set a header used by the client router to signal the response is static\n                // and should respect the `static` cache staleTime value.\n                res.setHeader(next_dist_client_components_app_router_headers__WEBPACK_IMPORTED_MODULE_16__.NEXT_IS_PRERENDER_HEADER, '1');\n            }\n            const { value: cachedData } = cacheEntry;\n            // Coerce the cache control parameter from the render.\n            let cacheControl;\n            // If this is a resume request in minimal mode it is streamed with dynamic\n            // content and should not be cached.\n            if (minimalPostponed) {\n                cacheControl = {\n                    revalidate: 0,\n                    expire: undefined\n                };\n            } else if (minimalMode && isRSCRequest && !isPrefetchRSCRequest && isRoutePPREnabled) {\n                cacheControl = {\n                    revalidate: 0,\n                    expire: undefined\n                };\n            } else if (!routeModule.isDev) {\n                // If this is a preview mode request, we shouldn't cache it\n                if (isDraftMode) {\n                    cacheControl = {\n                        revalidate: 0,\n                        expire: undefined\n                    };\n                } else if (!isSSG) {\n                    if (!res.getHeader('Cache-Control')) {\n                        cacheControl = {\n                            revalidate: 0,\n                            expire: undefined\n                        };\n                    }\n                } else if (cacheEntry.cacheControl) {\n                    // If the cache entry has a cache control with a revalidate value that's\n                    // a number, use it.\n                    if (typeof cacheEntry.cacheControl.revalidate === 'number') {\n                        var _cacheEntry_cacheControl;\n                        if (cacheEntry.cacheControl.revalidate < 1) {\n                            throw Object.defineProperty(new Error(`Invalid revalidate configuration provided: ${cacheEntry.cacheControl.revalidate} < 1`), \"__NEXT_ERROR_CODE\", {\n                                value: \"E22\",\n                                enumerable: false,\n                                configurable: true\n                            });\n                        }\n                        cacheControl = {\n                            revalidate: cacheEntry.cacheControl.revalidate,\n                            expire: ((_cacheEntry_cacheControl = cacheEntry.cacheControl) == null ? void 0 : _cacheEntry_cacheControl.expire) ?? nextConfig.expireTime\n                        };\n                    } else {\n                        cacheControl = {\n                            revalidate: next_dist_lib_constants__WEBPACK_IMPORTED_MODULE_21__.CACHE_ONE_YEAR,\n                            expire: undefined\n                        };\n                    }\n                }\n            }\n            cacheEntry.cacheControl = cacheControl;\n            if (typeof segmentPrefetchHeader === 'string' && (cachedData == null ? void 0 : cachedData.kind) === next_dist_server_response_cache__WEBPACK_IMPORTED_MODULE_18__.CachedRouteKind.APP_PAGE && cachedData.segmentData) {\n                var _cachedData_headers1;\n                // This is a prefetch request issued by the client Segment Cache. These\n                // should never reach the application layer (lambda). We should either\n                // respond from the cache (HIT) or respond with 204 No Content (MISS).\n                // Set a header to indicate that PPR is enabled for this route. This\n                // lets the client distinguish between a regular cache miss and a cache\n                // miss due to PPR being disabled. In other contexts this header is used\n                // to indicate that the response contains dynamic data, but here we're\n                // only using it to indicate that the feature is enabled  the segment\n                // response itself contains whether the data is dynamic.\n                res.setHeader(next_dist_client_components_app_router_headers__WEBPACK_IMPORTED_MODULE_16__.NEXT_DID_POSTPONE_HEADER, '2');\n                // Add the cache tags header to the response if it exists and we're in\n                // minimal mode while rendering a static page.\n                const tags = (_cachedData_headers1 = cachedData.headers) == null ? void 0 : _cachedData_headers1[next_dist_lib_constants__WEBPACK_IMPORTED_MODULE_21__.NEXT_CACHE_TAGS_HEADER];\n                if (minimalMode && isSSG && tags && typeof tags === 'string') {\n                    res.setHeader(next_dist_lib_constants__WEBPACK_IMPORTED_MODULE_21__.NEXT_CACHE_TAGS_HEADER, tags);\n                }\n                const matchedSegment = cachedData.segmentData.get(segmentPrefetchHeader);\n                if (matchedSegment !== undefined) {\n                    // Cache hit\n                    return (0,next_dist_server_send_payload__WEBPACK_IMPORTED_MODULE_23__.sendRenderResult)({\n                        req,\n                        res,\n                        generateEtags: nextConfig.generateEtags,\n                        poweredByHeader: nextConfig.poweredByHeader,\n                        result: next_dist_server_render_result__WEBPACK_IMPORTED_MODULE_20__[\"default\"].fromStatic(matchedSegment, next_dist_client_components_app_router_headers__WEBPACK_IMPORTED_MODULE_16__.RSC_CONTENT_TYPE_HEADER),\n                        cacheControl: cacheEntry.cacheControl\n                    });\n                }\n                // Cache miss. Either a cache entry for this route has not been generated\n                // (which technically should not be possible when PPR is enabled, because\n                // at a minimum there should always be a fallback entry) or there's no\n                // match for the requested segment. Respond with a 204 No Content. We\n                // don't bother to respond with 404, because these requests are only\n                // issued as part of a prefetch.\n                res.statusCode = 204;\n                return (0,next_dist_server_send_payload__WEBPACK_IMPORTED_MODULE_23__.sendRenderResult)({\n                    req,\n                    res,\n                    generateEtags: nextConfig.generateEtags,\n                    poweredByHeader: nextConfig.poweredByHeader,\n                    result: next_dist_server_render_result__WEBPACK_IMPORTED_MODULE_20__[\"default\"].EMPTY,\n                    cacheControl: cacheEntry.cacheControl\n                });\n            }\n            // If there's a callback for `onCacheEntry`, call it with the cache entry\n            // and the revalidate options.\n            const onCacheEntry = (0,next_dist_server_request_meta__WEBPACK_IMPORTED_MODULE_4__.getRequestMeta)(req, 'onCacheEntry');\n            if (onCacheEntry) {\n                const finished = await onCacheEntry({\n                    ...cacheEntry,\n                    // TODO: remove this when upstream doesn't\n                    // always expect this value to be \"PAGE\"\n                    value: {\n                        ...cacheEntry.value,\n                        kind: 'PAGE'\n                    }\n                }, {\n                    url: (0,next_dist_server_request_meta__WEBPACK_IMPORTED_MODULE_4__.getRequestMeta)(req, 'initURL')\n                });\n                if (finished) {\n                    // TODO: maybe we have to end the request?\n                    return null;\n                }\n            }\n            // If the request has a postponed state and it's a resume request we\n            // should error.\n            if (didPostpone && minimalPostponed) {\n                throw Object.defineProperty(new Error('Invariant: postponed state should not be present on a resume request'), \"__NEXT_ERROR_CODE\", {\n                    value: \"E396\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n            if (cachedData.headers) {\n                const headers = {\n                    ...cachedData.headers\n                };\n                if (!minimalMode || !isSSG) {\n                    delete headers[next_dist_lib_constants__WEBPACK_IMPORTED_MODULE_21__.NEXT_CACHE_TAGS_HEADER];\n                }\n                for (let [key, value] of Object.entries(headers)){\n                    if (typeof value === 'undefined') continue;\n                    if (Array.isArray(value)) {\n                        for (const v of value){\n                            res.appendHeader(key, v);\n                        }\n                    } else if (typeof value === 'number') {\n                        value = value.toString();\n                        res.appendHeader(key, value);\n                    } else {\n                        res.appendHeader(key, value);\n                    }\n                }\n            }\n            // Add the cache tags header to the response if it exists and we're in\n            // minimal mode while rendering a static page.\n            const tags = (_cachedData_headers = cachedData.headers) == null ? void 0 : _cachedData_headers[next_dist_lib_constants__WEBPACK_IMPORTED_MODULE_21__.NEXT_CACHE_TAGS_HEADER];\n            if (minimalMode && isSSG && tags && typeof tags === 'string') {\n                res.setHeader(next_dist_lib_constants__WEBPACK_IMPORTED_MODULE_21__.NEXT_CACHE_TAGS_HEADER, tags);\n            }\n            // If the request is a data request, then we shouldn't set the status code\n            // from the response because it should always be 200. This should be gated\n            // behind the experimental PPR flag.\n            if (cachedData.status && (!isRSCRequest || !isRoutePPREnabled)) {\n                res.statusCode = cachedData.status;\n            }\n            // Redirect information is encoded in RSC payload, so we don't need to use redirect status codes\n            if (!minimalMode && cachedData.status && next_dist_client_components_redirect_status_code__WEBPACK_IMPORTED_MODULE_27__.RedirectStatusCode[cachedData.status] && isRSCRequest) {\n                res.statusCode = 200;\n            }\n            // Mark that the request did postpone.\n            if (didPostpone) {\n                res.setHeader(next_dist_client_components_app_router_headers__WEBPACK_IMPORTED_MODULE_16__.NEXT_DID_POSTPONE_HEADER, '1');\n            }\n            // we don't go through this block when preview mode is true\n            // as preview mode is a dynamic request (bypasses cache) and doesn't\n            // generate both HTML and payloads in the same request so continue to just\n            // return the generated payload\n            if (isRSCRequest && !isDraftMode) {\n                // If this is a dynamic RSC request, then stream the response.\n                if (typeof cachedData.rscData === 'undefined') {\n                    if (cachedData.postponed) {\n                        throw Object.defineProperty(new Error('Invariant: Expected postponed to be undefined'), \"__NEXT_ERROR_CODE\", {\n                            value: \"E372\",\n                            enumerable: false,\n                            configurable: true\n                        });\n                    }\n                    return (0,next_dist_server_send_payload__WEBPACK_IMPORTED_MODULE_23__.sendRenderResult)({\n                        req,\n                        res,\n                        generateEtags: nextConfig.generateEtags,\n                        poweredByHeader: nextConfig.poweredByHeader,\n                        result: cachedData.html,\n                        // Dynamic RSC responses cannot be cached, even if they're\n                        // configured with `force-static` because we have no way of\n                        // distinguishing between `force-static` and pages that have no\n                        // postponed state.\n                        // TODO: distinguish `force-static` from pages with no postponed state (static)\n                        cacheControl: isDynamicRSCRequest ? {\n                            revalidate: 0,\n                            expire: undefined\n                        } : cacheEntry.cacheControl\n                    });\n                }\n                // As this isn't a prefetch request, we should serve the static flight\n                // data.\n                return (0,next_dist_server_send_payload__WEBPACK_IMPORTED_MODULE_23__.sendRenderResult)({\n                    req,\n                    res,\n                    generateEtags: nextConfig.generateEtags,\n                    poweredByHeader: nextConfig.poweredByHeader,\n                    result: next_dist_server_render_result__WEBPACK_IMPORTED_MODULE_20__[\"default\"].fromStatic(cachedData.rscData, next_dist_client_components_app_router_headers__WEBPACK_IMPORTED_MODULE_16__.RSC_CONTENT_TYPE_HEADER),\n                    cacheControl: cacheEntry.cacheControl\n                });\n            }\n            // This is a request for HTML data.\n            let body = cachedData.html;\n            // If there's no postponed state, we should just serve the HTML. This\n            // should also be the case for a resume request because it's completed\n            // as a server render (rather than a static render).\n            if (!didPostpone || minimalMode || isRSCRequest) {\n                // If we're in test mode, we should add a sentinel chunk to the response\n                // that's between the static and dynamic parts so we can compare the\n                // chunks and add assertions.\n                if (false) {}\n                return (0,next_dist_server_send_payload__WEBPACK_IMPORTED_MODULE_23__.sendRenderResult)({\n                    req,\n                    res,\n                    generateEtags: nextConfig.generateEtags,\n                    poweredByHeader: nextConfig.poweredByHeader,\n                    result: body,\n                    cacheControl: cacheEntry.cacheControl\n                });\n            }\n            // If we're debugging the static shell or the dynamic API accesses, we\n            // should just serve the HTML without resuming the render. The returned\n            // HTML will be the static shell so all the Dynamic API's will be used\n            // during static generation.\n            if (isDebugStaticShell || isDebugDynamicAccesses) {\n                // Since we're not resuming the render, we need to at least add the\n                // closing body and html tags to create valid HTML.\n                body.push(new ReadableStream({\n                    start (controller) {\n                        controller.enqueue(next_dist_server_stream_utils_encoded_tags__WEBPACK_IMPORTED_MODULE_22__.ENCODED_TAGS.CLOSED.BODY_AND_HTML);\n                        controller.close();\n                    }\n                }));\n                return (0,next_dist_server_send_payload__WEBPACK_IMPORTED_MODULE_23__.sendRenderResult)({\n                    req,\n                    res,\n                    generateEtags: nextConfig.generateEtags,\n                    poweredByHeader: nextConfig.poweredByHeader,\n                    result: body,\n                    cacheControl: {\n                        revalidate: 0,\n                        expire: undefined\n                    }\n                });\n            }\n            // If we're in test mode, we should add a sentinel chunk to the response\n            // that's between the static and dynamic parts so we can compare the\n            // chunks and add assertions.\n            if (false) {}\n            // This request has postponed, so let's create a new transformer that the\n            // dynamic data can pipe to that will attach the dynamic data to the end\n            // of the response.\n            const transformer = new TransformStream();\n            body.push(transformer.readable);\n            // Perform the render again, but this time, provide the postponed state.\n            // We don't await because we want the result to start streaming now, and\n            // we've already chained the transformer's readable to the render result.\n            doRender({\n                span,\n                postponed: cachedData.postponed,\n                // This is a resume render, not a fallback render, so we don't need to\n                // set this.\n                fallbackRouteParams: null\n            }).then(async (result)=>{\n                var _result_value;\n                if (!result) {\n                    throw Object.defineProperty(new Error('Invariant: expected a result to be returned'), \"__NEXT_ERROR_CODE\", {\n                        value: \"E463\",\n                        enumerable: false,\n                        configurable: true\n                    });\n                }\n                if (((_result_value = result.value) == null ? void 0 : _result_value.kind) !== next_dist_server_response_cache__WEBPACK_IMPORTED_MODULE_18__.CachedRouteKind.APP_PAGE) {\n                    var _result_value1;\n                    throw Object.defineProperty(new Error(`Invariant: expected a page response, got ${(_result_value1 = result.value) == null ? void 0 : _result_value1.kind}`), \"__NEXT_ERROR_CODE\", {\n                        value: \"E305\",\n                        enumerable: false,\n                        configurable: true\n                    });\n                }\n                // Pipe the resume result to the transformer.\n                await result.value.html.pipeTo(transformer.writable);\n            }).catch((err)=>{\n                // An error occurred during piping or preparing the render, abort\n                // the transformers writer so we can terminate the stream.\n                transformer.writable.abort(err).catch((e)=>{\n                    console.error(\"couldn't abort transformer\", e);\n                });\n            });\n            return (0,next_dist_server_send_payload__WEBPACK_IMPORTED_MODULE_23__.sendRenderResult)({\n                req,\n                res,\n                generateEtags: nextConfig.generateEtags,\n                poweredByHeader: nextConfig.poweredByHeader,\n                result: body,\n                // We don't want to cache the response if it has postponed data because\n                // the response being sent to the client it's dynamic parts are streamed\n                // to the client on the same request.\n                cacheControl: {\n                    revalidate: 0,\n                    expire: undefined\n                }\n            });\n        };\n        // TODO: activeSpan code path is for when wrapped by\n        // next-server can be removed when this is no longer used\n        if (activeSpan) {\n            await handleResponse(activeSpan);\n        } else {\n            return await tracer.withPropagatedContext(req.headers, ()=>tracer.trace(next_dist_server_lib_trace_constants__WEBPACK_IMPORTED_MODULE_5__.BaseServerSpan.handleRequest, {\n                    spanName: `${method} ${req.url}`,\n                    kind: next_dist_server_lib_trace_tracer__WEBPACK_IMPORTED_MODULE_3__.SpanKind.SERVER,\n                    attributes: {\n                        'http.method': method,\n                        'http.target': req.url\n                    }\n                }, handleResponse));\n        }\n    } catch (err) {\n        // if we aren't wrapped by base-server handle here\n        if (!activeSpan && !(err instanceof next_dist_shared_lib_no_fallback_error_external__WEBPACK_IMPORTED_MODULE_24__.NoFallbackError)) {\n            await routeModule.onRequestError(req, err, {\n                routerKind: 'App Router',\n                routePath: srcPage,\n                routeType: 'render',\n                revalidateReason: (0,next_dist_server_instrumentation_utils__WEBPACK_IMPORTED_MODULE_2__.getRevalidateReason)({\n                    isRevalidate: isSSG,\n                    isOnDemandRevalidate\n                })\n            }, routerServerContext);\n        }\n        // rethrow so that we can handle serving error page\n        throw err;\n    }\n}\n// TODO: omit this from production builds, only test builds should include it\n/**\n * Creates a readable stream that emits a PPR boundary sentinel.\n *\n * @returns A readable stream that emits a PPR boundary sentinel.\n */ function createPPRBoundarySentinel() {\n    return new ReadableStream({\n        start (controller) {\n            controller.enqueue(new TextEncoder().encode('<!-- PPR_BOUNDARY_SENTINEL -->'));\n            controller.close();\n        }\n    });\n}\n\n//# sourceMappingURL=app-page.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LWFwcC1sb2FkZXIvaW5kZXguanM/bmFtZT1hcHAlMkZhdXRoJTJGbG9naW4lMkZwYWdlJnBhZ2U9JTJGYXV0aCUyRmxvZ2luJTJGcGFnZSZhcHBQYXRocz0lMkZhdXRoJTJGbG9naW4lMkZwYWdlJnBhZ2VQYXRoPXByaXZhdGUtbmV4dC1hcHAtZGlyJTJGYXV0aCUyRmxvZ2luJTJGcGFnZS5qcyZhcHBEaXI9RCUzQSU1Q25leHQlNUNvcmclNUNzcmMlNUNhcHAmcGFnZUV4dGVuc2lvbnM9dHN4JnBhZ2VFeHRlbnNpb25zPXRzJnBhZ2VFeHRlbnNpb25zPWpzeCZwYWdlRXh0ZW5zaW9ucz1qcyZyb290RGlyPUQlM0ElNUNuZXh0JTVDb3JnJmlzRGV2PXRydWUmdHNjb25maWdQYXRoPXRzY29uZmlnLmpzb24mYmFzZVBhdGg9JmFzc2V0UHJlZml4PSZuZXh0Q29uZmlnT3V0cHV0PSZwcmVmZXJyZWRSZWdpb249Jm1pZGRsZXdhcmVDb25maWc9ZTMwJTNEJmlzR2xvYmFsTm90Rm91bmRFbmFibGVkPSEiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLHNCQUFzQixrSkFBdUU7QUFDN0Ysc0JBQXNCLG9KQUF3RTtBQUM5RixzQkFBc0IsdU9BQXdGO0FBQzlHLHNCQUFzQixpT0FBcUY7QUFDM0csc0JBQXNCLGlPQUFxRjtBQUMzRyxzQkFBc0IsdU9BQXdGO0FBQzlHLG9CQUFvQixvS0FBa0Y7QUFHcEc7QUFHQTtBQUMyRTtBQUNMO0FBQ1Q7QUFDTztBQUNPO0FBQ1M7QUFDRjtBQUNQO0FBQ0s7QUFDWTtBQUNXO0FBQ3hCO0FBQ0Y7QUFDYTtBQUMwRjtBQUN6RztBQUNYO0FBQ1E7QUFDaEI7QUFDaUQ7QUFDakM7QUFDVDtBQUNpQjtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLG9GQUFvRixnRkFBYztBQUNsRyxpQ0FBaUMsUUFBUSxFQUFFLFFBQVE7QUFDbkQsMEJBQTBCLHVFQUFRO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsNENBQTRDLDZGQUFlO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLDJGQUFtQjtBQUNyRDtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQSIsInNvdXJjZXMiOlsiIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IG1vZHVsZTAgPSAoKSA9PiBpbXBvcnQoLyogd2VicGFja01vZGU6IFwiZWFnZXJcIiAqLyBcIkQ6XFxcXG5leHRcXFxcb3JnXFxcXHNyY1xcXFxhcHBcXFxcbGF5b3V0LmpzXCIpO1xuY29uc3QgbW9kdWxlMSA9ICgpID0+IGltcG9ydCgvKiB3ZWJwYWNrTW9kZTogXCJlYWdlclwiICovIFwiRDpcXFxcbmV4dFxcXFxvcmdcXFxcc3JjXFxcXGFwcFxcXFxsb2FkaW5nLmpzXCIpO1xuY29uc3QgbW9kdWxlMiA9ICgpID0+IGltcG9ydCgvKiB3ZWJwYWNrTW9kZTogXCJlYWdlclwiICovIFwibmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL2J1aWx0aW4vZ2xvYmFsLWVycm9yLmpzXCIpO1xuY29uc3QgbW9kdWxlMyA9ICgpID0+IGltcG9ydCgvKiB3ZWJwYWNrTW9kZTogXCJlYWdlclwiICovIFwibmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL2J1aWx0aW4vbm90LWZvdW5kLmpzXCIpO1xuY29uc3QgbW9kdWxlNCA9ICgpID0+IGltcG9ydCgvKiB3ZWJwYWNrTW9kZTogXCJlYWdlclwiICovIFwibmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL2J1aWx0aW4vZm9yYmlkZGVuLmpzXCIpO1xuY29uc3QgbW9kdWxlNSA9ICgpID0+IGltcG9ydCgvKiB3ZWJwYWNrTW9kZTogXCJlYWdlclwiICovIFwibmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL2J1aWx0aW4vdW5hdXRob3JpemVkLmpzXCIpO1xuY29uc3QgcGFnZTYgPSAoKSA9PiBpbXBvcnQoLyogd2VicGFja01vZGU6IFwiZWFnZXJcIiAqLyBcIkQ6XFxcXG5leHRcXFxcb3JnXFxcXHNyY1xcXFxhcHBcXFxcYXV0aFxcXFxsb2dpblxcXFxwYWdlLmpzXCIpO1xuaW1wb3J0IHsgQXBwUGFnZVJvdXRlTW9kdWxlIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvcm91dGUtbW9kdWxlcy9hcHAtcGFnZS9tb2R1bGUuY29tcGlsZWRcIiB3aXRoIHtcbiAgICAndHVyYm9wYWNrLXRyYW5zaXRpb24nOiAnbmV4dC1zc3InXG59O1xuaW1wb3J0IHsgUm91dGVLaW5kIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvcm91dGUta2luZFwiIHdpdGgge1xuICAgICd0dXJib3BhY2stdHJhbnNpdGlvbic6ICduZXh0LXNlcnZlci11dGlsaXR5J1xufTtcbmltcG9ydCB7IGdldFJldmFsaWRhdGVSZWFzb24gfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9pbnN0cnVtZW50YXRpb24vdXRpbHNcIjtcbmltcG9ydCB7IGdldFRyYWNlciwgU3BhbktpbmQgfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9saWIvdHJhY2UvdHJhY2VyXCI7XG5pbXBvcnQgeyBnZXRSZXF1ZXN0TWV0YSB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL3JlcXVlc3QtbWV0YVwiO1xuaW1wb3J0IHsgQmFzZVNlcnZlclNwYW4gfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9saWIvdHJhY2UvY29uc3RhbnRzXCI7XG5pbXBvcnQgeyBpbnRlcm9wRGVmYXVsdCB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL2FwcC1yZW5kZXIvaW50ZXJvcC1kZWZhdWx0XCI7XG5pbXBvcnQgeyBzdHJpcEZsaWdodEhlYWRlcnMgfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9hcHAtcmVuZGVyL3N0cmlwLWZsaWdodC1oZWFkZXJzXCI7XG5pbXBvcnQgeyBOb2RlTmV4dFJlcXVlc3QsIE5vZGVOZXh0UmVzcG9uc2UgfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9iYXNlLWh0dHAvbm9kZVwiO1xuaW1wb3J0IHsgY2hlY2tJc0FwcFBQUkVuYWJsZWQgfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9saWIvZXhwZXJpbWVudGFsL3BwclwiO1xuaW1wb3J0IHsgZ2V0RmFsbGJhY2tSb3V0ZVBhcmFtcyB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL3JlcXVlc3QvZmFsbGJhY2stcGFyYW1zXCI7XG5pbXBvcnQgeyBzZXRSZWZlcmVuY2VNYW5pZmVzdHNTaW5nbGV0b24gfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9hcHAtcmVuZGVyL2VuY3J5cHRpb24tdXRpbHNcIjtcbmltcG9ydCB7IGlzSHRtbEJvdFJlcXVlc3QsIHNob3VsZFNlcnZlU3RyZWFtaW5nTWV0YWRhdGEgfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9saWIvc3RyZWFtaW5nLW1ldGFkYXRhXCI7XG5pbXBvcnQgeyBjcmVhdGVTZXJ2ZXJNb2R1bGVNYXAgfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9hcHAtcmVuZGVyL2FjdGlvbi11dGlsc1wiO1xuaW1wb3J0IHsgbm9ybWFsaXplQXBwUGF0aCB9IGZyb20gXCJuZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvYXBwLXBhdGhzXCI7XG5pbXBvcnQgeyBnZXRJc1Bvc3NpYmxlU2VydmVyQWN0aW9uIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvbGliL3NlcnZlci1hY3Rpb24tcmVxdWVzdC1tZXRhXCI7XG5pbXBvcnQgeyBSU0NfSEVBREVSLCBORVhUX1JPVVRFUl9QUkVGRVRDSF9IRUFERVIsIE5FWFRfSVNfUFJFUkVOREVSX0hFQURFUiwgTkVYVF9ESURfUE9TVFBPTkVfSEVBREVSLCBSU0NfQ09OVEVOVF9UWVBFX0hFQURFUiB9IGZyb20gXCJuZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvYXBwLXJvdXRlci1oZWFkZXJzXCI7XG5pbXBvcnQgeyBnZXRCb3RUeXBlLCBpc0JvdCB9IGZyb20gXCJuZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvaXMtYm90XCI7XG5pbXBvcnQgeyBDYWNoZWRSb3V0ZUtpbmQgfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9yZXNwb25zZS1jYWNoZVwiO1xuaW1wb3J0IHsgRmFsbGJhY2tNb2RlLCBwYXJzZUZhbGxiYWNrRmllbGQgfSBmcm9tIFwibmV4dC9kaXN0L2xpYi9mYWxsYmFja1wiO1xuaW1wb3J0IFJlbmRlclJlc3VsdCBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9yZW5kZXItcmVzdWx0XCI7XG5pbXBvcnQgeyBDQUNIRV9PTkVfWUVBUiwgSFRNTF9DT05URU5UX1RZUEVfSEVBREVSLCBORVhUX0NBQ0hFX1RBR1NfSEVBREVSIH0gZnJvbSBcIm5leHQvZGlzdC9saWIvY29uc3RhbnRzXCI7XG5pbXBvcnQgeyBFTkNPREVEX1RBR1MgfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9zdHJlYW0tdXRpbHMvZW5jb2RlZC10YWdzXCI7XG5pbXBvcnQgeyBzZW5kUmVuZGVyUmVzdWx0IH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvc2VuZC1wYXlsb2FkXCI7XG5pbXBvcnQgeyBOb0ZhbGxiYWNrRXJyb3IgfSBmcm9tIFwibmV4dC9kaXN0L3NoYXJlZC9saWIvbm8tZmFsbGJhY2stZXJyb3IuZXh0ZXJuYWxcIjtcbi8vIFdlIGluamVjdCB0aGUgdHJlZSBhbmQgcGFnZXMgaGVyZSBzbyB0aGF0IHdlIGNhbiB1c2UgdGhlbSBpbiB0aGUgcm91dGVcbi8vIG1vZHVsZS5cbmNvbnN0IHRyZWUgPSB7XG4gICAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgICcnLFxuICAgICAgICB7XG4gICAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgICdhdXRoJyxcbiAgICAgICAge1xuICAgICAgICBjaGlsZHJlbjogW1xuICAgICAgICAnbG9naW4nLFxuICAgICAgICB7XG4gICAgICAgIGNoaWxkcmVuOiBbJ19fUEFHRV9fJywge30sIHtcbiAgICAgICAgICBwYWdlOiBbcGFnZTYsIFwiRDpcXFxcbmV4dFxcXFxvcmdcXFxcc3JjXFxcXGFwcFxcXFxhdXRoXFxcXGxvZ2luXFxcXHBhZ2UuanNcIl0sXG4gICAgICAgICAgXG4gICAgICAgIH1dXG4gICAgICB9LFxuICAgICAgICB7XG4gICAgICAgIFxuICAgICAgICBcbiAgICAgIH1cbiAgICAgIF1cbiAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgXG4gICAgICAgIG1ldGFkYXRhOiB7XG4gICAgaWNvbjogWyhhc3luYyAocHJvcHMpID0+IChhd2FpdCBpbXBvcnQoLyogd2VicGFja01vZGU6IFwiZWFnZXJcIiAqLyBcIm5leHQtbWV0YWRhdGEtaW1hZ2UtbG9hZGVyP3R5cGU9ZmF2aWNvbiZzZWdtZW50PSZiYXNlUGF0aD0mcGFnZUV4dGVuc2lvbnM9dHN4JnBhZ2VFeHRlbnNpb25zPXRzJnBhZ2VFeHRlbnNpb25zPWpzeCZwYWdlRXh0ZW5zaW9ucz1qcyFEOlxcXFxuZXh0XFxcXG9yZ1xcXFxzcmNcXFxcYXBwXFxcXGZhdmljb24uaWNvP19fbmV4dF9tZXRhZGF0YV9fXCIpKS5kZWZhdWx0KHByb3BzKSldLFxuICAgIGFwcGxlOiBbXSxcbiAgICBvcGVuR3JhcGg6IFtdLFxuICAgIHR3aXR0ZXI6IFtdLFxuICAgIG1hbmlmZXN0OiB1bmRlZmluZWRcbiAgfVxuICAgICAgfVxuICAgICAgXVxuICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAnbGF5b3V0JzogW21vZHVsZTAsIFwiRDpcXFxcbmV4dFxcXFxvcmdcXFxcc3JjXFxcXGFwcFxcXFxsYXlvdXQuanNcIl0sXG4nbG9hZGluZyc6IFttb2R1bGUxLCBcIkQ6XFxcXG5leHRcXFxcb3JnXFxcXHNyY1xcXFxhcHBcXFxcbG9hZGluZy5qc1wiXSxcbidnbG9iYWwtZXJyb3InOiBbbW9kdWxlMiwgXCJuZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvYnVpbHRpbi9nbG9iYWwtZXJyb3IuanNcIl0sXG4nbm90LWZvdW5kJzogW21vZHVsZTMsIFwibmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL2J1aWx0aW4vbm90LWZvdW5kLmpzXCJdLFxuJ2ZvcmJpZGRlbic6IFttb2R1bGU0LCBcIm5leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9idWlsdGluL2ZvcmJpZGRlbi5qc1wiXSxcbid1bmF1dGhvcml6ZWQnOiBbbW9kdWxlNSwgXCJuZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvYnVpbHRpbi91bmF1dGhvcml6ZWQuanNcIl0sXG4gICAgICAgIG1ldGFkYXRhOiB7XG4gICAgaWNvbjogWyhhc3luYyAocHJvcHMpID0+IChhd2FpdCBpbXBvcnQoLyogd2VicGFja01vZGU6IFwiZWFnZXJcIiAqLyBcIm5leHQtbWV0YWRhdGEtaW1hZ2UtbG9hZGVyP3R5cGU9ZmF2aWNvbiZzZWdtZW50PSZiYXNlUGF0aD0mcGFnZUV4dGVuc2lvbnM9dHN4JnBhZ2VFeHRlbnNpb25zPXRzJnBhZ2VFeHRlbnNpb25zPWpzeCZwYWdlRXh0ZW5zaW9ucz1qcyFEOlxcXFxuZXh0XFxcXG9yZ1xcXFxzcmNcXFxcYXBwXFxcXGZhdmljb24uaWNvP19fbmV4dF9tZXRhZGF0YV9fXCIpKS5kZWZhdWx0KHByb3BzKSldLFxuICAgIGFwcGxlOiBbXSxcbiAgICBvcGVuR3JhcGg6IFtdLFxuICAgIHR3aXR0ZXI6IFtdLFxuICAgIG1hbmlmZXN0OiB1bmRlZmluZWRcbiAgfVxuICAgICAgfVxuICAgICAgXVxuICAgICAgfS5jaGlsZHJlbjtcbmNvbnN0IHBhZ2VzID0gW1wiRDpcXFxcbmV4dFxcXFxvcmdcXFxcc3JjXFxcXGFwcFxcXFxhdXRoXFxcXGxvZ2luXFxcXHBhZ2UuanNcIl07XG5leHBvcnQgeyB0cmVlLCBwYWdlcyB9O1xuaW1wb3J0IEdsb2JhbEVycm9yIGZyb20gXCJuZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvYnVpbHRpbi9nbG9iYWwtZXJyb3IuanNcIiB3aXRoIHtcbiAgICAndHVyYm9wYWNrLXRyYW5zaXRpb24nOiAnbmV4dC1zZXJ2ZXItdXRpbGl0eSdcbn07XG5leHBvcnQgeyBHbG9iYWxFcnJvciB9O1xuY29uc3QgX19uZXh0X2FwcF9yZXF1aXJlX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fXG5jb25zdCBfX25leHRfYXBwX2xvYWRfY2h1bmtfXyA9ICgpID0+IFByb21pc2UucmVzb2x2ZSgpXG5leHBvcnQgY29uc3QgX19uZXh0X2FwcF9fID0ge1xuICAgIHJlcXVpcmU6IF9fbmV4dF9hcHBfcmVxdWlyZV9fLFxuICAgIGxvYWRDaHVuazogX19uZXh0X2FwcF9sb2FkX2NodW5rX19cbn07XG5pbXBvcnQgKiBhcyBlbnRyeUJhc2UgZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvYXBwLXJlbmRlci9lbnRyeS1iYXNlXCIgd2l0aCB7XG4gICAgJ3R1cmJvcGFjay10cmFuc2l0aW9uJzogJ25leHQtc2VydmVyLXV0aWxpdHknXG59O1xuaW1wb3J0IHsgUmVkaXJlY3RTdGF0dXNDb2RlIH0gZnJvbSBcIm5leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yZWRpcmVjdC1zdGF0dXMtY29kZVwiO1xuZXhwb3J0ICogZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvYXBwLXJlbmRlci9lbnRyeS1iYXNlXCIgd2l0aCB7XG4gICAgJ3R1cmJvcGFjay10cmFuc2l0aW9uJzogJ25leHQtc2VydmVyLXV0aWxpdHknXG59O1xuLy8gQ3JlYXRlIGFuZCBleHBvcnQgdGhlIHJvdXRlIG1vZHVsZSB0aGF0IHdpbGwgYmUgY29uc3VtZWQuXG5leHBvcnQgY29uc3Qgcm91dGVNb2R1bGUgPSBuZXcgQXBwUGFnZVJvdXRlTW9kdWxlKHtcbiAgICBkZWZpbml0aW9uOiB7XG4gICAgICAgIGtpbmQ6IFJvdXRlS2luZC5BUFBfUEFHRSxcbiAgICAgICAgcGFnZTogXCIvYXV0aC9sb2dpbi9wYWdlXCIsXG4gICAgICAgIHBhdGhuYW1lOiBcIi9hdXRoL2xvZ2luXCIsXG4gICAgICAgIC8vIFRoZSBmb2xsb3dpbmcgYXJlbid0IHVzZWQgaW4gcHJvZHVjdGlvbi5cbiAgICAgICAgYnVuZGxlUGF0aDogJycsXG4gICAgICAgIGZpbGVuYW1lOiAnJyxcbiAgICAgICAgYXBwUGF0aHM6IFtdXG4gICAgfSxcbiAgICB1c2VybGFuZDoge1xuICAgICAgICBsb2FkZXJUcmVlOiB0cmVlXG4gICAgfSxcbiAgICBkaXN0RGlyOiBwcm9jZXNzLmVudi5fX05FWFRfUkVMQVRJVkVfRElTVF9ESVIgfHwgJycsXG4gICAgcmVsYXRpdmVQcm9qZWN0RGlyOiBwcm9jZXNzLmVudi5fX05FWFRfUkVMQVRJVkVfUFJPSkVDVF9ESVIgfHwgJydcbn0pO1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGhhbmRsZXIocmVxLCByZXMsIGN0eCkge1xuICAgIHZhciBfdGhpcztcbiAgICBsZXQgc3JjUGFnZSA9IFwiL2F1dGgvbG9naW4vcGFnZVwiO1xuICAgIC8vIHR1cmJvcGFjayBkb2Vzbid0IG5vcm1hbGl6ZSBgL2luZGV4YCBpbiB0aGUgcGFnZSBuYW1lXG4gICAgLy8gc28gd2UgbmVlZCB0byB0byBwcm9jZXNzIGR5bmFtaWMgcm91dGVzIHByb3Blcmx5XG4gICAgLy8gVE9ETzogZml4IHR1cmJvcGFjayBwcm92aWRpbmcgZGlmZmVyaW5nIHZhbHVlIGZyb20gd2VicGFja1xuICAgIGlmIChwcm9jZXNzLmVudi5UVVJCT1BBQ0spIHtcbiAgICAgICAgc3JjUGFnZSA9IHNyY1BhZ2UucmVwbGFjZSgvXFwvaW5kZXgkLywgJycpIHx8ICcvJztcbiAgICB9IGVsc2UgaWYgKHNyY1BhZ2UgPT09ICcvaW5kZXgnKSB7XG4gICAgICAgIC8vIHdlIGFsd2F5cyBub3JtYWxpemUgL2luZGV4IHNwZWNpZmljYWxseVxuICAgICAgICBzcmNQYWdlID0gJy8nO1xuICAgIH1cbiAgICBjb25zdCBtdWx0aVpvbmVEcmFmdE1vZGUgPSBwcm9jZXNzLmVudi5fX05FWFRfTVVMVElfWk9ORV9EUkFGVF9NT0RFO1xuICAgIGNvbnN0IGluaXRpYWxQb3N0cG9uZWQgPSBnZXRSZXF1ZXN0TWV0YShyZXEsICdwb3N0cG9uZWQnKTtcbiAgICAvLyBUT0RPOiByZXBsYWNlIHdpdGggbW9yZSBzcGVjaWZpYyBmbGFnc1xuICAgIGNvbnN0IG1pbmltYWxNb2RlID0gZ2V0UmVxdWVzdE1ldGEocmVxLCAnbWluaW1hbE1vZGUnKTtcbiAgICBjb25zdCBwcmVwYXJlUmVzdWx0ID0gYXdhaXQgcm91dGVNb2R1bGUucHJlcGFyZShyZXEsIHJlcywge1xuICAgICAgICBzcmNQYWdlLFxuICAgICAgICBtdWx0aVpvbmVEcmFmdE1vZGVcbiAgICB9KTtcbiAgICBpZiAoIXByZXBhcmVSZXN1bHQpIHtcbiAgICAgICAgcmVzLnN0YXR1c0NvZGUgPSA0MDA7XG4gICAgICAgIHJlcy5lbmQoJ0JhZCBSZXF1ZXN0Jyk7XG4gICAgICAgIGN0eC53YWl0VW50aWwgPT0gbnVsbCA/IHZvaWQgMCA6IGN0eC53YWl0VW50aWwuY2FsbChjdHgsIFByb21pc2UucmVzb2x2ZSgpKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHsgYnVpbGRJZCwgcXVlcnksIHBhcmFtcywgcGFyc2VkVXJsLCBwYWdlSXNEeW5hbWljLCBidWlsZE1hbmlmZXN0LCBuZXh0Rm9udE1hbmlmZXN0LCByZWFjdExvYWRhYmxlTWFuaWZlc3QsIHNlcnZlckFjdGlvbnNNYW5pZmVzdCwgY2xpZW50UmVmZXJlbmNlTWFuaWZlc3QsIHN1YnJlc291cmNlSW50ZWdyaXR5TWFuaWZlc3QsIHByZXJlbmRlck1hbmlmZXN0LCBpc0RyYWZ0TW9kZSwgcmVzb2x2ZWRQYXRobmFtZSwgcmV2YWxpZGF0ZU9ubHlHZW5lcmF0ZWQsIHJvdXRlclNlcnZlckNvbnRleHQsIG5leHRDb25maWcsIGludGVyY2VwdGlvblJvdXRlUGF0dGVybnMgfSA9IHByZXBhcmVSZXN1bHQ7XG4gICAgY29uc3QgcGF0aG5hbWUgPSBwYXJzZWRVcmwucGF0aG5hbWUgfHwgJy8nO1xuICAgIGNvbnN0IG5vcm1hbGl6ZWRTcmNQYWdlID0gbm9ybWFsaXplQXBwUGF0aChzcmNQYWdlKTtcbiAgICBsZXQgeyBpc09uRGVtYW5kUmV2YWxpZGF0ZSB9ID0gcHJlcGFyZVJlc3VsdDtcbiAgICBjb25zdCBwcmVyZW5kZXJJbmZvID0gcm91dGVNb2R1bGUubWF0Y2gocGF0aG5hbWUsIHByZXJlbmRlck1hbmlmZXN0KTtcbiAgICBjb25zdCBpc1ByZXJlbmRlcmVkID0gISFwcmVyZW5kZXJNYW5pZmVzdC5yb3V0ZXNbcmVzb2x2ZWRQYXRobmFtZV07XG4gICAgbGV0IGlzU1NHID0gQm9vbGVhbihwcmVyZW5kZXJJbmZvIHx8IGlzUHJlcmVuZGVyZWQgfHwgcHJlcmVuZGVyTWFuaWZlc3Qucm91dGVzW25vcm1hbGl6ZWRTcmNQYWdlXSk7XG4gICAgY29uc3QgdXNlckFnZW50ID0gcmVxLmhlYWRlcnNbJ3VzZXItYWdlbnQnXSB8fCAnJztcbiAgICBjb25zdCBib3RUeXBlID0gZ2V0Qm90VHlwZSh1c2VyQWdlbnQpO1xuICAgIGNvbnN0IGlzSHRtbEJvdCA9IGlzSHRtbEJvdFJlcXVlc3QocmVxKTtcbiAgICAvKipcbiAgICogSWYgdHJ1ZSwgdGhpcyBpbmRpY2F0ZXMgdGhhdCB0aGUgcmVxdWVzdCBiZWluZyBtYWRlIGlzIGZvciBhbiBhcHBcbiAgICogcHJlZmV0Y2ggcmVxdWVzdC5cbiAgICovIGNvbnN0IGlzUHJlZmV0Y2hSU0NSZXF1ZXN0ID0gZ2V0UmVxdWVzdE1ldGEocmVxLCAnaXNQcmVmZXRjaFJTQ1JlcXVlc3QnKSA/PyByZXEuaGVhZGVyc1tORVhUX1JPVVRFUl9QUkVGRVRDSF9IRUFERVJdID09PSAnMScgLy8gZXhjbHVkZSBydW50aW1lIHByZWZldGNoZXMsIHdoaWNoIHVzZSAnMidcbiAgICA7XG4gICAgLy8gTk9URTogRG9uJ3QgZGVsZXRlIGhlYWRlcnNbUlNDXSB5ZXQsIGl0IHN0aWxsIG5lZWRzIHRvIGJlIHVzZWQgaW4gcmVuZGVyVG9IVE1MIGxhdGVyXG4gICAgY29uc3QgaXNSU0NSZXF1ZXN0ID0gZ2V0UmVxdWVzdE1ldGEocmVxLCAnaXNSU0NSZXF1ZXN0JykgPz8gQm9vbGVhbihyZXEuaGVhZGVyc1tSU0NfSEVBREVSXSk7XG4gICAgY29uc3QgaXNQb3NzaWJsZVNlcnZlckFjdGlvbiA9IGdldElzUG9zc2libGVTZXJ2ZXJBY3Rpb24ocmVxKTtcbiAgICAvKipcbiAgICogSWYgdGhlIHJvdXRlIGJlaW5nIHJlbmRlcmVkIGlzIGFuIGFwcCBwYWdlLCBhbmQgdGhlIHBwciBmZWF0dXJlIGhhcyBiZWVuXG4gICAqIGVuYWJsZWQsIHRoZW4gdGhlIGdpdmVuIHJvdXRlIF9jb3VsZF8gc3VwcG9ydCBQUFIuXG4gICAqLyBjb25zdCBjb3VsZFN1cHBvcnRQUFIgPSBjaGVja0lzQXBwUFBSRW5hYmxlZChuZXh0Q29uZmlnLmV4cGVyaW1lbnRhbC5wcHIpO1xuICAgIC8vIFdoZW4gZW5hYmxlZCwgdGhpcyB3aWxsIGFsbG93IHRoZSB1c2Ugb2YgdGhlIGA/X19uZXh0cHByb25seWAgcXVlcnkgdG9cbiAgICAvLyBlbmFibGUgZGVidWdnaW5nIG9mIHRoZSBzdGF0aWMgc2hlbGwuXG4gICAgY29uc3QgaGFzRGVidWdTdGF0aWNTaGVsbFF1ZXJ5ID0gcHJvY2Vzcy5lbnYuX19ORVhUX0VYUEVSSU1FTlRBTF9TVEFUSUNfU0hFTExfREVCVUdHSU5HID09PSAnMScgJiYgdHlwZW9mIHF1ZXJ5Ll9fbmV4dHBwcm9ubHkgIT09ICd1bmRlZmluZWQnICYmIGNvdWxkU3VwcG9ydFBQUjtcbiAgICAvLyBXaGVuIGVuYWJsZWQsIHRoaXMgd2lsbCBhbGxvdyB0aGUgdXNlIG9mIHRoZSBgP19fbmV4dHBwcm9ubHlgIHF1ZXJ5XG4gICAgLy8gdG8gZW5hYmxlIGRlYnVnZ2luZyBvZiB0aGUgZmFsbGJhY2sgc2hlbGwuXG4gICAgY29uc3QgaGFzRGVidWdGYWxsYmFja1NoZWxsUXVlcnkgPSBoYXNEZWJ1Z1N0YXRpY1NoZWxsUXVlcnkgJiYgcXVlcnkuX19uZXh0cHByb25seSA9PT0gJ2ZhbGxiYWNrJztcbiAgICAvLyBUaGlzIHBhZ2Ugc3VwcG9ydHMgUFBSIGlmIGl0IGlzIG1hcmtlZCBhcyBiZWluZyBgUEFSVElBTExZX1NUQVRJQ2AgaW4gdGhlXG4gICAgLy8gcHJlcmVuZGVyIG1hbmlmZXN0IGFuZCB0aGlzIGlzIGFuIGFwcCBwYWdlLlxuICAgIGNvbnN0IGlzUm91dGVQUFJFbmFibGVkID0gY291bGRTdXBwb3J0UFBSICYmICgoKF90aGlzID0gcHJlcmVuZGVyTWFuaWZlc3Qucm91dGVzW25vcm1hbGl6ZWRTcmNQYWdlXSA/PyBwcmVyZW5kZXJNYW5pZmVzdC5keW5hbWljUm91dGVzW25vcm1hbGl6ZWRTcmNQYWdlXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzLnJlbmRlcmluZ01vZGUpID09PSAnUEFSVElBTExZX1NUQVRJQycgfHwgLy8gSWRlYWxseSB3ZSdkIHdhbnQgdG8gY2hlY2sgdGhlIGFwcENvbmZpZyB0byBzZWUgaWYgdGhpcyBwYWdlIGhhcyBQUFJcbiAgICAvLyBlbmFibGVkIG9yIG5vdCwgYnV0IHRoYXQgd291bGQgcmVxdWlyZSBwbHVtYmluZyB0aGUgYXBwQ29uZmlnIHRocm91Z2hcbiAgICAvLyB0byB0aGUgc2VydmVyIGR1cmluZyBkZXZlbG9wbWVudC4gV2UgYXNzdW1lIHRoYXQgdGhlIHBhZ2Ugc3VwcG9ydHMgaXRcbiAgICAvLyBidXQgb25seSBkdXJpbmcgZGV2ZWxvcG1lbnQuXG4gICAgaGFzRGVidWdTdGF0aWNTaGVsbFF1ZXJ5ICYmIChyb3V0ZU1vZHVsZS5pc0RldiA9PT0gdHJ1ZSB8fCAocm91dGVyU2VydmVyQ29udGV4dCA9PSBudWxsID8gdm9pZCAwIDogcm91dGVyU2VydmVyQ29udGV4dC5leHBlcmltZW50YWxUZXN0UHJveHkpID09PSB0cnVlKSk7XG4gICAgY29uc3QgaXNEZWJ1Z1N0YXRpY1NoZWxsID0gaGFzRGVidWdTdGF0aWNTaGVsbFF1ZXJ5ICYmIGlzUm91dGVQUFJFbmFibGVkO1xuICAgIC8vIFdlIHNob3VsZCBlbmFibGUgZGVidWdnaW5nIGR5bmFtaWMgYWNjZXNzZXMgd2hlbiB0aGUgc3RhdGljIHNoZWxsXG4gICAgLy8gZGVidWdnaW5nIGhhcyBiZWVuIGVuYWJsZWQgYW5kIHdlJ3JlIGFsc28gaW4gZGV2ZWxvcG1lbnQgbW9kZS5cbiAgICBjb25zdCBpc0RlYnVnRHluYW1pY0FjY2Vzc2VzID0gaXNEZWJ1Z1N0YXRpY1NoZWxsICYmIHJvdXRlTW9kdWxlLmlzRGV2ID09PSB0cnVlO1xuICAgIGNvbnN0IGlzRGVidWdGYWxsYmFja1NoZWxsID0gaGFzRGVidWdGYWxsYmFja1NoZWxsUXVlcnkgJiYgaXNSb3V0ZVBQUkVuYWJsZWQ7XG4gICAgLy8gSWYgd2UncmUgaW4gbWluaW1hbCBtb2RlLCB0aGVuIHRyeSB0byBnZXQgdGhlIHBvc3Rwb25lZCBpbmZvcm1hdGlvbiBmcm9tXG4gICAgLy8gdGhlIHJlcXVlc3QgbWV0YWRhdGEuIElmIGF2YWlsYWJsZSwgdXNlIGl0IGZvciByZXN1bWluZyB0aGUgcG9zdHBvbmVkXG4gICAgLy8gcmVuZGVyLlxuICAgIGNvbnN0IG1pbmltYWxQb3N0cG9uZWQgPSBpc1JvdXRlUFBSRW5hYmxlZCA/IGluaXRpYWxQb3N0cG9uZWQgOiB1bmRlZmluZWQ7XG4gICAgLy8gSWYgUFBSIGlzIGVuYWJsZWQsIGFuZCB0aGlzIGlzIGEgUlNDIHJlcXVlc3QgKGJ1dCBub3QgYSBwcmVmZXRjaCksIHRoZW5cbiAgICAvLyB3ZSBjYW4gdXNlIHRoaXMgZmFjdCB0byBvbmx5IGdlbmVyYXRlIHRoZSBmbGlnaHQgZGF0YSBmb3IgdGhlIHJlcXVlc3RcbiAgICAvLyBiZWNhdXNlIHdlIGNhbid0IGNhY2hlIHRoZSBIVE1MIChhcyBpdCdzIGFsc28gZHluYW1pYykuXG4gICAgY29uc3QgaXNEeW5hbWljUlNDUmVxdWVzdCA9IGlzUm91dGVQUFJFbmFibGVkICYmIGlzUlNDUmVxdWVzdCAmJiAhaXNQcmVmZXRjaFJTQ1JlcXVlc3Q7XG4gICAgLy8gTmVlZCB0byByZWFkIHRoaXMgYmVmb3JlIGl0J3Mgc3RyaXBwZWQgYnkgc3RyaXBGbGlnaHRIZWFkZXJzLiBXZSBkb24ndFxuICAgIC8vIG5lZWQgdG8gdHJhbnNmZXIgaXQgdG8gdGhlIHJlcXVlc3QgbWV0YSBiZWNhdXNlIGl0J3Mgb25seSByZWFkXG4gICAgLy8gd2l0aGluIHRoaXMgZnVuY3Rpb247IHRoZSBzdGF0aWMgc2VnbWVudCBkYXRhIHNob3VsZCBoYXZlIGFscmVhZHkgYmVlblxuICAgIC8vIGdlbmVyYXRlZCwgc28gd2Ugd2lsbCBhbHdheXMgZWl0aGVyIHJldHVybiBhIHN0YXRpYyByZXNwb25zZSBvciBhIDQwNC5cbiAgICBjb25zdCBzZWdtZW50UHJlZmV0Y2hIZWFkZXIgPSBnZXRSZXF1ZXN0TWV0YShyZXEsICdzZWdtZW50UHJlZmV0Y2hSU0NSZXF1ZXN0Jyk7XG4gICAgLy8gVE9ETzogaW52ZXN0aWdhdGUgZXhpc3RpbmcgYnVnIHdpdGggc2hvdWxkU2VydmVTdHJlYW1pbmdNZXRhZGF0YSBhbHdheXNcbiAgICAvLyBiZWluZyB0cnVlIGZvciBhIHJldmFsaWRhdGUgZHVlIHRvIG1vZGlmeWluZyB0aGUgYmFzZS1zZXJ2ZXIgdGhpcy5yZW5kZXJPcHRzXG4gICAgLy8gd2hlbiBmaXhpbmcgdGhpcyB0byBjb3JyZWN0IGxvZ2ljIGl0IGNhdXNlcyBoeWRyYXRpb24gaXNzdWUgc2luY2Ugd2Ugc2V0XG4gICAgLy8gc2VydmVTdHJlYW1pbmdNZXRhZGF0YSB0byB0cnVlIGR1cmluZyBleHBvcnRcbiAgICBsZXQgc2VydmVTdHJlYW1pbmdNZXRhZGF0YSA9ICF1c2VyQWdlbnQgPyB0cnVlIDogc2hvdWxkU2VydmVTdHJlYW1pbmdNZXRhZGF0YSh1c2VyQWdlbnQsIG5leHRDb25maWcuaHRtbExpbWl0ZWRCb3RzKTtcbiAgICBpZiAoaXNIdG1sQm90ICYmIGlzUm91dGVQUFJFbmFibGVkKSB7XG4gICAgICAgIGlzU1NHID0gZmFsc2U7XG4gICAgICAgIHNlcnZlU3RyZWFtaW5nTWV0YWRhdGEgPSBmYWxzZTtcbiAgICB9XG4gICAgLy8gSW4gZGV2ZWxvcG1lbnQsIHdlIGFsd2F5cyB3YW50IHRvIGdlbmVyYXRlIGR5bmFtaWMgSFRNTC5cbiAgICBsZXQgc3VwcG9ydHNEeW5hbWljUmVzcG9uc2UgPSAvLyBJZiB3ZSdyZSBpbiBkZXZlbG9wbWVudCwgd2UgYWx3YXlzIHN1cHBvcnQgZHluYW1pYyBIVE1MLCB1bmxlc3MgaXQnc1xuICAgIC8vIGEgZGF0YSByZXF1ZXN0LCBpbiB3aGljaCBjYXNlIHdlIG9ubHkgcHJvZHVjZSBzdGF0aWMgSFRNTC5cbiAgICByb3V0ZU1vZHVsZS5pc0RldiA9PT0gdHJ1ZSB8fCAvLyBJZiB0aGlzIGlzIG5vdCBTU0cgb3IgZG9lcyBub3QgaGF2ZSBzdGF0aWMgcGF0aHMsIHRoZW4gaXQgc3VwcG9ydHNcbiAgICAvLyBkeW5hbWljIEhUTUwuXG4gICAgIWlzU1NHIHx8IC8vIElmIHRoaXMgcmVxdWVzdCBoYXMgcHJvdmlkZWQgcG9zdHBvbmVkIGRhdGEsIGl0IHN1cHBvcnRzIGR5bmFtaWNcbiAgICAvLyBIVE1MLlxuICAgIHR5cGVvZiBpbml0aWFsUG9zdHBvbmVkID09PSAnc3RyaW5nJyB8fCAvLyBJZiB0aGlzIGlzIGEgZHluYW1pYyBSU0MgcmVxdWVzdCwgdGhlbiB0aGlzIHJlbmRlciBzdXBwb3J0cyBkeW5hbWljXG4gICAgLy8gSFRNTCAoaXQncyBkeW5hbWljKS5cbiAgICBpc0R5bmFtaWNSU0NSZXF1ZXN0O1xuICAgIC8vIFdoZW4gaHRtbCBib3RzIHJlcXVlc3QgUFBSIHBhZ2UsIHBlcmZvcm0gdGhlIGZ1bGwgZHluYW1pYyByZW5kZXJpbmcuXG4gICAgY29uc3Qgc2hvdWxkV2FpdE9uQWxsUmVhZHkgPSBpc0h0bWxCb3QgJiYgaXNSb3V0ZVBQUkVuYWJsZWQ7XG4gICAgbGV0IHNzZ0NhY2hlS2V5ID0gbnVsbDtcbiAgICBpZiAoIWlzRHJhZnRNb2RlICYmIGlzU1NHICYmICFzdXBwb3J0c0R5bmFtaWNSZXNwb25zZSAmJiAhaXNQb3NzaWJsZVNlcnZlckFjdGlvbiAmJiAhbWluaW1hbFBvc3Rwb25lZCAmJiAhaXNEeW5hbWljUlNDUmVxdWVzdCkge1xuICAgICAgICBzc2dDYWNoZUtleSA9IHJlc29sdmVkUGF0aG5hbWU7XG4gICAgfVxuICAgIC8vIHRoZSBzdGF0aWNQYXRoS2V5IGRpZmZlcnMgZnJvbSBzc2dDYWNoZUtleSBzaW5jZVxuICAgIC8vIHNzZ0NhY2hlS2V5IGlzIG51bGwgaW4gZGV2IHNpbmNlIHdlJ3JlIGFsd2F5cyBpbiBcImR5bmFtaWNcIlxuICAgIC8vIG1vZGUgaW4gZGV2IHRvIGJ5cGFzcyB0aGUgY2FjaGUsIGJ1dCB3ZSBzdGlsbCBuZWVkIHRvIGhvbm9yXG4gICAgLy8gZHluYW1pY1BhcmFtcyA9IGZhbHNlIGluIGRldiBtb2RlXG4gICAgbGV0IHN0YXRpY1BhdGhLZXkgPSBzc2dDYWNoZUtleTtcbiAgICBpZiAoIXN0YXRpY1BhdGhLZXkgJiYgcm91dGVNb2R1bGUuaXNEZXYpIHtcbiAgICAgICAgc3RhdGljUGF0aEtleSA9IHJlc29sdmVkUGF0aG5hbWU7XG4gICAgfVxuICAgIC8vIElmIHRoaXMgaXMgYSByZXF1ZXN0IGZvciBhbiBhcHAgcGF0aCB0aGF0IHNob3VsZCBiZSBzdGF0aWNhbGx5IGdlbmVyYXRlZFxuICAgIC8vIGFuZCB3ZSBhcmVuJ3QgaW4gdGhlIGVkZ2UgcnVudGltZSwgc3RyaXAgdGhlIGZsaWdodCBoZWFkZXJzIHNvIGl0IHdpbGxcbiAgICAvLyBnZW5lcmF0ZSB0aGUgc3RhdGljIHJlc3BvbnNlLlxuICAgIGlmICghcm91dGVNb2R1bGUuaXNEZXYgJiYgIWlzRHJhZnRNb2RlICYmIGlzU1NHICYmIGlzUlNDUmVxdWVzdCAmJiAhaXNEeW5hbWljUlNDUmVxdWVzdCkge1xuICAgICAgICBzdHJpcEZsaWdodEhlYWRlcnMocmVxLmhlYWRlcnMpO1xuICAgIH1cbiAgICBjb25zdCBDb21wb25lbnRNb2QgPSB7XG4gICAgICAgIC4uLmVudHJ5QmFzZSxcbiAgICAgICAgdHJlZSxcbiAgICAgICAgcGFnZXMsXG4gICAgICAgIEdsb2JhbEVycm9yLFxuICAgICAgICBoYW5kbGVyLFxuICAgICAgICByb3V0ZU1vZHVsZSxcbiAgICAgICAgX19uZXh0X2FwcF9fXG4gICAgfTtcbiAgICAvLyBCZWZvcmUgcmVuZGVyaW5nICh3aGljaCBpbml0aWFsaXplcyBjb21wb25lbnQgdHJlZSBtb2R1bGVzKSwgd2UgaGF2ZSB0b1xuICAgIC8vIHNldCB0aGUgcmVmZXJlbmNlIG1hbmlmZXN0cyB0byBvdXIgZ2xvYmFsIHN0b3JlIHNvIFNlcnZlciBBY3Rpb24nc1xuICAgIC8vIGVuY3J5cHRpb24gdXRpbCBjYW4gYWNjZXNzIHRvIHRoZW0gYXQgdGhlIHRvcCBsZXZlbCBvZiB0aGUgcGFnZSBtb2R1bGUuXG4gICAgaWYgKHNlcnZlckFjdGlvbnNNYW5pZmVzdCAmJiBjbGllbnRSZWZlcmVuY2VNYW5pZmVzdCkge1xuICAgICAgICBzZXRSZWZlcmVuY2VNYW5pZmVzdHNTaW5nbGV0b24oe1xuICAgICAgICAgICAgcGFnZTogc3JjUGFnZSxcbiAgICAgICAgICAgIGNsaWVudFJlZmVyZW5jZU1hbmlmZXN0LFxuICAgICAgICAgICAgc2VydmVyQWN0aW9uc01hbmlmZXN0LFxuICAgICAgICAgICAgc2VydmVyTW9kdWxlTWFwOiBjcmVhdGVTZXJ2ZXJNb2R1bGVNYXAoe1xuICAgICAgICAgICAgICAgIHNlcnZlckFjdGlvbnNNYW5pZmVzdFxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IG1ldGhvZCA9IHJlcS5tZXRob2QgfHwgJ0dFVCc7XG4gICAgY29uc3QgdHJhY2VyID0gZ2V0VHJhY2VyKCk7XG4gICAgY29uc3QgYWN0aXZlU3BhbiA9IHRyYWNlci5nZXRBY3RpdmVTY29wZVNwYW4oKTtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCB2YXJ5SGVhZGVyID0gcm91dGVNb2R1bGUuZ2V0VmFyeUhlYWRlcihyZXNvbHZlZFBhdGhuYW1lLCBpbnRlcmNlcHRpb25Sb3V0ZVBhdHRlcm5zKTtcbiAgICAgICAgcmVzLnNldEhlYWRlcignVmFyeScsIHZhcnlIZWFkZXIpO1xuICAgICAgICBjb25zdCBpbnZva2VSb3V0ZU1vZHVsZSA9IGFzeW5jIChzcGFuLCBjb250ZXh0KT0+e1xuICAgICAgICAgICAgY29uc3QgbmV4dFJlcSA9IG5ldyBOb2RlTmV4dFJlcXVlc3QocmVxKTtcbiAgICAgICAgICAgIGNvbnN0IG5leHRSZXMgPSBuZXcgTm9kZU5leHRSZXNwb25zZShyZXMpO1xuICAgICAgICAgICAgLy8gVE9ETzogYWRhcHQgZm9yIHB1dHRpbmcgdGhlIFJEQyBpbnNpZGUgdGhlIHBvc3Rwb25lZCBkYXRhXG4gICAgICAgICAgICAvLyBJZiB3ZSdyZSBpbiBkZXYsIGFuZCB0aGlzIGlzbid0IGEgcHJlZmV0Y2ggb3IgYSBzZXJ2ZXIgYWN0aW9uLFxuICAgICAgICAgICAgLy8gd2Ugc2hvdWxkIHNlZWQgdGhlIHJlc3VtZSBkYXRhIGNhY2hlLlxuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5leHRDb25maWcuZXhwZXJpbWVudGFsLmNhY2hlQ29tcG9uZW50cyAmJiAhaXNQcmVmZXRjaFJTQ1JlcXVlc3QgJiYgIWNvbnRleHQucmVuZGVyT3B0cy5pc1Bvc3NpYmxlU2VydmVyQWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHdhcm11cCA9IGF3YWl0IHJvdXRlTW9kdWxlLndhcm11cChuZXh0UmVxLCBuZXh0UmVzLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIHdhcm11cCBpcyBzdWNjZXNzZnVsLCB3ZSBzaG91bGQgdXNlIHRoZSByZXN1bWUgZGF0YVxuICAgICAgICAgICAgICAgICAgICAvLyBjYWNoZSBmcm9tIHRoZSB3YXJtdXAuXG4gICAgICAgICAgICAgICAgICAgIGlmICh3YXJtdXAubWV0YWRhdGEucmVuZGVyUmVzdW1lRGF0YUNhY2hlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnJlbmRlck9wdHMucmVuZGVyUmVzdW1lRGF0YUNhY2hlID0gd2FybXVwLm1ldGFkYXRhLnJlbmRlclJlc3VtZURhdGFDYWNoZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByb3V0ZU1vZHVsZS5yZW5kZXIobmV4dFJlcSwgbmV4dFJlcywgY29udGV4dCkuZmluYWxseSgoKT0+e1xuICAgICAgICAgICAgICAgIGlmICghc3BhbikgcmV0dXJuO1xuICAgICAgICAgICAgICAgIHNwYW4uc2V0QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgICAgICAgICdodHRwLnN0YXR1c19jb2RlJzogcmVzLnN0YXR1c0NvZGUsXG4gICAgICAgICAgICAgICAgICAgICduZXh0LnJzYyc6IGZhbHNlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29uc3Qgcm9vdFNwYW5BdHRyaWJ1dGVzID0gdHJhY2VyLmdldFJvb3RTcGFuQXR0cmlidXRlcygpO1xuICAgICAgICAgICAgICAgIC8vIFdlIHdlcmUgdW5hYmxlIHRvIGdldCBhdHRyaWJ1dGVzLCBwcm9iYWJseSBPVEVMIGlzIG5vdCBlbmFibGVkXG4gICAgICAgICAgICAgICAgaWYgKCFyb290U3BhbkF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocm9vdFNwYW5BdHRyaWJ1dGVzLmdldCgnbmV4dC5zcGFuX3R5cGUnKSAhPT0gQmFzZVNlcnZlclNwYW4uaGFuZGxlUmVxdWVzdCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYFVuZXhwZWN0ZWQgcm9vdCBzcGFuIHR5cGUgJyR7cm9vdFNwYW5BdHRyaWJ1dGVzLmdldCgnbmV4dC5zcGFuX3R5cGUnKX0nLiBQbGVhc2UgcmVwb3J0IHRoaXMgTmV4dC5qcyBpc3N1ZSBodHRwczovL2dpdGh1Yi5jb20vdmVyY2VsL25leHQuanNgKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCByb3V0ZSA9IHJvb3RTcGFuQXR0cmlidXRlcy5nZXQoJ25leHQucm91dGUnKTtcbiAgICAgICAgICAgICAgICBpZiAocm91dGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmFtZSA9IGAke21ldGhvZH0gJHtyb3V0ZX1gO1xuICAgICAgICAgICAgICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgJ25leHQucm91dGUnOiByb3V0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdodHRwLnJvdXRlJzogcm91dGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbmV4dC5zcGFuX25hbWUnOiBuYW1lXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzcGFuLnVwZGF0ZU5hbWUobmFtZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3Bhbi51cGRhdGVOYW1lKGAke21ldGhvZH0gJHtyZXEudXJsfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBkb1JlbmRlciA9IGFzeW5jICh7IHNwYW4sIHBvc3Rwb25lZCwgZmFsbGJhY2tSb3V0ZVBhcmFtcyB9KT0+e1xuICAgICAgICAgICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgICAgICAgICAgICBxdWVyeSxcbiAgICAgICAgICAgICAgICBwYXJhbXMsXG4gICAgICAgICAgICAgICAgcGFnZTogbm9ybWFsaXplZFNyY1BhZ2UsXG4gICAgICAgICAgICAgICAgc2hhcmVkQ29udGV4dDoge1xuICAgICAgICAgICAgICAgICAgICBidWlsZElkXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzZXJ2ZXJDb21wb25lbnRzSG1yQ2FjaGU6IGdldFJlcXVlc3RNZXRhKHJlcSwgJ3NlcnZlckNvbXBvbmVudHNIbXJDYWNoZScpLFxuICAgICAgICAgICAgICAgIGZhbGxiYWNrUm91dGVQYXJhbXMsXG4gICAgICAgICAgICAgICAgcmVuZGVyT3B0czoge1xuICAgICAgICAgICAgICAgICAgICBBcHA6ICgpPT5udWxsLFxuICAgICAgICAgICAgICAgICAgICBEb2N1bWVudDogKCk9Pm51bGwsXG4gICAgICAgICAgICAgICAgICAgIHBhZ2VDb25maWc6IHt9LFxuICAgICAgICAgICAgICAgICAgICBDb21wb25lbnRNb2QsXG4gICAgICAgICAgICAgICAgICAgIENvbXBvbmVudDogaW50ZXJvcERlZmF1bHQoQ29tcG9uZW50TW9kKSxcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zLFxuICAgICAgICAgICAgICAgICAgICByb3V0ZU1vZHVsZSxcbiAgICAgICAgICAgICAgICAgICAgcGFnZTogc3JjUGFnZSxcbiAgICAgICAgICAgICAgICAgICAgcG9zdHBvbmVkLFxuICAgICAgICAgICAgICAgICAgICBzaG91bGRXYWl0T25BbGxSZWFkeSxcbiAgICAgICAgICAgICAgICAgICAgc2VydmVTdHJlYW1pbmdNZXRhZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgc3VwcG9ydHNEeW5hbWljUmVzcG9uc2U6IHR5cGVvZiBwb3N0cG9uZWQgPT09ICdzdHJpbmcnIHx8IHN1cHBvcnRzRHluYW1pY1Jlc3BvbnNlLFxuICAgICAgICAgICAgICAgICAgICBidWlsZE1hbmlmZXN0LFxuICAgICAgICAgICAgICAgICAgICBuZXh0Rm9udE1hbmlmZXN0LFxuICAgICAgICAgICAgICAgICAgICByZWFjdExvYWRhYmxlTWFuaWZlc3QsXG4gICAgICAgICAgICAgICAgICAgIHN1YnJlc291cmNlSW50ZWdyaXR5TWFuaWZlc3QsXG4gICAgICAgICAgICAgICAgICAgIHNlcnZlckFjdGlvbnNNYW5pZmVzdCxcbiAgICAgICAgICAgICAgICAgICAgY2xpZW50UmVmZXJlbmNlTWFuaWZlc3QsXG4gICAgICAgICAgICAgICAgICAgIHNldElzclN0YXR1czogcm91dGVyU2VydmVyQ29udGV4dCA9PSBudWxsID8gdm9pZCAwIDogcm91dGVyU2VydmVyQ29udGV4dC5zZXRJc3JTdGF0dXMsXG4gICAgICAgICAgICAgICAgICAgIGRpcjogcHJvY2Vzcy5lbnYuTkVYVF9SVU5USU1FID09PSAnbm9kZWpzJyA/IHJlcXVpcmUoJ3BhdGgnKS5qb2luKC8qIHR1cmJvcGFja0lnbm9yZTogdHJ1ZSAqLyBwcm9jZXNzLmN3ZCgpLCByb3V0ZU1vZHVsZS5yZWxhdGl2ZVByb2plY3REaXIpIDogYCR7cHJvY2Vzcy5jd2QoKX0vJHtyb3V0ZU1vZHVsZS5yZWxhdGl2ZVByb2plY3REaXJ9YCxcbiAgICAgICAgICAgICAgICAgICAgaXNEcmFmdE1vZGUsXG4gICAgICAgICAgICAgICAgICAgIGlzUmV2YWxpZGF0ZTogaXNTU0cgJiYgIXBvc3Rwb25lZCAmJiAhaXNEeW5hbWljUlNDUmVxdWVzdCxcbiAgICAgICAgICAgICAgICAgICAgYm90VHlwZSxcbiAgICAgICAgICAgICAgICAgICAgaXNPbkRlbWFuZFJldmFsaWRhdGUsXG4gICAgICAgICAgICAgICAgICAgIGlzUG9zc2libGVTZXJ2ZXJBY3Rpb24sXG4gICAgICAgICAgICAgICAgICAgIGFzc2V0UHJlZml4OiBuZXh0Q29uZmlnLmFzc2V0UHJlZml4LFxuICAgICAgICAgICAgICAgICAgICBuZXh0Q29uZmlnT3V0cHV0OiBuZXh0Q29uZmlnLm91dHB1dCxcbiAgICAgICAgICAgICAgICAgICAgY3Jvc3NPcmlnaW46IG5leHRDb25maWcuY3Jvc3NPcmlnaW4sXG4gICAgICAgICAgICAgICAgICAgIHRyYWlsaW5nU2xhc2g6IG5leHRDb25maWcudHJhaWxpbmdTbGFzaCxcbiAgICAgICAgICAgICAgICAgICAgcHJldmlld1Byb3BzOiBwcmVyZW5kZXJNYW5pZmVzdC5wcmV2aWV3LFxuICAgICAgICAgICAgICAgICAgICBkZXBsb3ltZW50SWQ6IG5leHRDb25maWcuZGVwbG95bWVudElkLFxuICAgICAgICAgICAgICAgICAgICBlbmFibGVUYWludGluZzogbmV4dENvbmZpZy5leHBlcmltZW50YWwudGFpbnQsXG4gICAgICAgICAgICAgICAgICAgIGh0bWxMaW1pdGVkQm90czogbmV4dENvbmZpZy5odG1sTGltaXRlZEJvdHMsXG4gICAgICAgICAgICAgICAgICAgIGRldnRvb2xTZWdtZW50RXhwbG9yZXI6IG5leHRDb25maWcuZXhwZXJpbWVudGFsLmRldnRvb2xTZWdtZW50RXhwbG9yZXIsXG4gICAgICAgICAgICAgICAgICAgIHJlYWN0TWF4SGVhZGVyc0xlbmd0aDogbmV4dENvbmZpZy5yZWFjdE1heEhlYWRlcnNMZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgIG11bHRpWm9uZURyYWZ0TW9kZSxcbiAgICAgICAgICAgICAgICAgICAgaW5jcmVtZW50YWxDYWNoZTogZ2V0UmVxdWVzdE1ldGEocmVxLCAnaW5jcmVtZW50YWxDYWNoZScpLFxuICAgICAgICAgICAgICAgICAgICBjYWNoZUxpZmVQcm9maWxlczogbmV4dENvbmZpZy5leHBlcmltZW50YWwuY2FjaGVMaWZlLFxuICAgICAgICAgICAgICAgICAgICBiYXNlUGF0aDogbmV4dENvbmZpZy5iYXNlUGF0aCxcbiAgICAgICAgICAgICAgICAgICAgc2VydmVyQWN0aW9uczogbmV4dENvbmZpZy5leHBlcmltZW50YWwuc2VydmVyQWN0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgLi4uaXNEZWJ1Z1N0YXRpY1NoZWxsIHx8IGlzRGVidWdEeW5hbWljQWNjZXNzZXMgPyB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0RXhwb3J0OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3VwcG9ydHNEeW5hbWljUmVzcG9uc2U6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNTdGF0aWNHZW5lcmF0aW9uOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNSZXZhbGlkYXRlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNEZWJ1Z0R5bmFtaWNBY2Nlc3NlczogaXNEZWJ1Z0R5bmFtaWNBY2Nlc3Nlc1xuICAgICAgICAgICAgICAgICAgICB9IDoge30sXG4gICAgICAgICAgICAgICAgICAgIGV4cGVyaW1lbnRhbDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNSb3V0ZVBQUkVuYWJsZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBleHBpcmVUaW1lOiBuZXh0Q29uZmlnLmV4cGlyZVRpbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFsZVRpbWVzOiBuZXh0Q29uZmlnLmV4cGVyaW1lbnRhbC5zdGFsZVRpbWVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGVDb21wb25lbnRzOiBCb29sZWFuKG5leHRDb25maWcuZXhwZXJpbWVudGFsLmNhY2hlQ29tcG9uZW50cyksXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGllbnRTZWdtZW50Q2FjaGU6IEJvb2xlYW4obmV4dENvbmZpZy5leHBlcmltZW50YWwuY2xpZW50U2VnbWVudENhY2hlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsaWVudFBhcmFtUGFyc2luZzogQm9vbGVhbihuZXh0Q29uZmlnLmV4cGVyaW1lbnRhbC5jbGllbnRQYXJhbVBhcnNpbmcpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZHluYW1pY09uSG92ZXI6IEJvb2xlYW4obmV4dENvbmZpZy5leHBlcmltZW50YWwuZHluYW1pY09uSG92ZXIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5saW5lQ3NzOiBCb29sZWFuKG5leHRDb25maWcuZXhwZXJpbWVudGFsLmlubGluZUNzcyksXG4gICAgICAgICAgICAgICAgICAgICAgICBhdXRoSW50ZXJydXB0czogQm9vbGVhbihuZXh0Q29uZmlnLmV4cGVyaW1lbnRhbC5hdXRoSW50ZXJydXB0cyksXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGllbnRUcmFjZU1ldGFkYXRhOiBuZXh0Q29uZmlnLmV4cGVyaW1lbnRhbC5jbGllbnRUcmFjZU1ldGFkYXRhIHx8IFtdXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHdhaXRVbnRpbDogY3R4LndhaXRVbnRpbCxcbiAgICAgICAgICAgICAgICAgICAgb25DbG9zZTogKGNiKT0+e1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzLm9uKCdjbG9zZScsIGNiKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgb25BZnRlclRhc2tFcnJvcjogKCk9Pnt9LFxuICAgICAgICAgICAgICAgICAgICBvbkluc3RydW1lbnRhdGlvblJlcXVlc3RFcnJvcjogKGVycm9yLCBfcmVxdWVzdCwgZXJyb3JDb250ZXh0KT0+cm91dGVNb2R1bGUub25SZXF1ZXN0RXJyb3IocmVxLCBlcnJvciwgZXJyb3JDb250ZXh0LCByb3V0ZXJTZXJ2ZXJDb250ZXh0KSxcbiAgICAgICAgICAgICAgICAgICAgZXJyOiBnZXRSZXF1ZXN0TWV0YShyZXEsICdpbnZva2VFcnJvcicpLFxuICAgICAgICAgICAgICAgICAgICBkZXY6IHJvdXRlTW9kdWxlLmlzRGV2XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGludm9rZVJvdXRlTW9kdWxlKHNwYW4sIGNvbnRleHQpO1xuICAgICAgICAgICAgY29uc3QgeyBtZXRhZGF0YSB9ID0gcmVzdWx0O1xuICAgICAgICAgICAgY29uc3QgeyBjYWNoZUNvbnRyb2wsIGhlYWRlcnMgPSB7fSwgLy8gQWRkIGFueSBmZXRjaCB0YWdzIHRoYXQgd2VyZSBvbiB0aGUgcGFnZSB0byB0aGUgcmVzcG9uc2UgaGVhZGVycy5cbiAgICAgICAgICAgIGZldGNoVGFnczogY2FjaGVUYWdzIH0gPSBtZXRhZGF0YTtcbiAgICAgICAgICAgIGlmIChjYWNoZVRhZ3MpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzW05FWFRfQ0FDSEVfVEFHU19IRUFERVJdID0gY2FjaGVUYWdzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUHVsbCBhbnkgZmV0Y2ggbWV0cmljcyBmcm9tIHRoZSByZW5kZXIgb250byB0aGUgcmVxdWVzdC5cbiAgICAgICAgICAgIDtcbiAgICAgICAgICAgIHJlcS5mZXRjaE1ldHJpY3MgPSBtZXRhZGF0YS5mZXRjaE1ldHJpY3M7XG4gICAgICAgICAgICAvLyB3ZSBkb24ndCB0aHJvdyBzdGF0aWMgdG8gZHluYW1pYyBlcnJvcnMgaW4gZGV2IGFzIGlzU1NHXG4gICAgICAgICAgICAvLyBpcyBhIGJlc3QgZ3Vlc3MgaW4gZGV2IHNpbmNlIHdlIGRvbid0IGhhdmUgdGhlIHByZXJlbmRlciBwYXNzXG4gICAgICAgICAgICAvLyB0byBrbm93IHdoZXRoZXIgdGhlIHBhdGggaXMgYWN0dWFsbHkgc3RhdGljIG9yIG5vdFxuICAgICAgICAgICAgaWYgKGlzU1NHICYmIChjYWNoZUNvbnRyb2wgPT0gbnVsbCA/IHZvaWQgMCA6IGNhY2hlQ29udHJvbC5yZXZhbGlkYXRlKSA9PT0gMCAmJiAhcm91dGVNb2R1bGUuaXNEZXYgJiYgIWlzUm91dGVQUFJFbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhdGljQmFpbG91dEluZm8gPSBtZXRhZGF0YS5zdGF0aWNCYWlsb3V0SW5mbztcbiAgICAgICAgICAgICAgICBjb25zdCBlcnIgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3IEVycm9yKGBQYWdlIGNoYW5nZWQgZnJvbSBzdGF0aWMgdG8gZHluYW1pYyBhdCBydW50aW1lICR7cmVzb2x2ZWRQYXRobmFtZX0keyhzdGF0aWNCYWlsb3V0SW5mbyA9PSBudWxsID8gdm9pZCAwIDogc3RhdGljQmFpbG91dEluZm8uZGVzY3JpcHRpb24pID8gYCwgcmVhc29uOiAke3N0YXRpY0JhaWxvdXRJbmZvLmRlc2NyaXB0aW9ufWAgOiBgYH1gICsgYFxcbnNlZSBtb3JlIGhlcmUgaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvYXBwLXN0YXRpYy10by1keW5hbWljLWVycm9yYCksIFwiX19ORVhUX0VSUk9SX0NPREVcIiwge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogXCJFMTMyXCIsXG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGljQmFpbG91dEluZm8gPT0gbnVsbCA/IHZvaWQgMCA6IHN0YXRpY0JhaWxvdXRJbmZvLnN0YWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0YWNrID0gc3RhdGljQmFpbG91dEluZm8uc3RhY2s7XG4gICAgICAgICAgICAgICAgICAgIGVyci5zdGFjayA9IGVyci5tZXNzYWdlICsgc3RhY2suc3Vic3RyaW5nKHN0YWNrLmluZGV4T2YoJ1xcbicpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgICAgICBraW5kOiBDYWNoZWRSb3V0ZUtpbmQuQVBQX1BBR0UsXG4gICAgICAgICAgICAgICAgICAgIGh0bWw6IHJlc3VsdCxcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgcnNjRGF0YTogbWV0YWRhdGEuZmxpZ2h0RGF0YSxcbiAgICAgICAgICAgICAgICAgICAgcG9zdHBvbmVkOiBtZXRhZGF0YS5wb3N0cG9uZWQsXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1czogbWV0YWRhdGEuc3RhdHVzQ29kZSxcbiAgICAgICAgICAgICAgICAgICAgc2VnbWVudERhdGE6IG1ldGFkYXRhLnNlZ21lbnREYXRhXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBjYWNoZUNvbnRyb2xcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlR2VuZXJhdG9yID0gYXN5bmMgKHsgaGFzUmVzb2x2ZWQsIHByZXZpb3VzQ2FjaGVFbnRyeSwgaXNSZXZhbGlkYXRpbmcsIHNwYW4gfSk9PntcbiAgICAgICAgICAgIGNvbnN0IGlzUHJvZHVjdGlvbiA9IHJvdXRlTW9kdWxlLmlzRGV2ID09PSBmYWxzZTtcbiAgICAgICAgICAgIGNvbnN0IGRpZFJlc3BvbmQgPSBoYXNSZXNvbHZlZCB8fCByZXMud3JpdGFibGVFbmRlZDtcbiAgICAgICAgICAgIC8vIHNraXAgb24tZGVtYW5kIHJldmFsaWRhdGUgaWYgY2FjaGUgaXMgbm90IHByZXNlbnQgYW5kXG4gICAgICAgICAgICAvLyByZXZhbGlkYXRlLWlmLWdlbmVyYXRlZCBpcyBzZXRcbiAgICAgICAgICAgIGlmIChpc09uRGVtYW5kUmV2YWxpZGF0ZSAmJiByZXZhbGlkYXRlT25seUdlbmVyYXRlZCAmJiAhcHJldmlvdXNDYWNoZUVudHJ5ICYmICFtaW5pbWFsTW9kZSkge1xuICAgICAgICAgICAgICAgIGlmIChyb3V0ZXJTZXJ2ZXJDb250ZXh0ID09IG51bGwgPyB2b2lkIDAgOiByb3V0ZXJTZXJ2ZXJDb250ZXh0LnJlbmRlcjQwNCkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCByb3V0ZXJTZXJ2ZXJDb250ZXh0LnJlbmRlcjQwNChyZXEsIHJlcyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzLnN0YXR1c0NvZGUgPSA0MDQ7XG4gICAgICAgICAgICAgICAgICAgIHJlcy5lbmQoJ1RoaXMgcGFnZSBjb3VsZCBub3QgYmUgZm91bmQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZmFsbGJhY2tNb2RlO1xuICAgICAgICAgICAgaWYgKHByZXJlbmRlckluZm8pIHtcbiAgICAgICAgICAgICAgICBmYWxsYmFja01vZGUgPSBwYXJzZUZhbGxiYWNrRmllbGQocHJlcmVuZGVySW5mby5mYWxsYmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBXaGVuIHNlcnZpbmcgYSBIVE1MIGJvdCByZXF1ZXN0LCB3ZSB3YW50IHRvIHNlcnZlIGEgYmxvY2tpbmcgcmVuZGVyIGFuZFxuICAgICAgICAgICAgLy8gbm90IHRoZSBwcmVyZW5kZXJlZCBwYWdlLiBUaGlzIGVuc3VyZXMgdGhhdCB0aGUgY29ycmVjdCBjb250ZW50IGlzIHNlcnZlZFxuICAgICAgICAgICAgLy8gdG8gdGhlIGJvdCBpbiB0aGUgaGVhZC5cbiAgICAgICAgICAgIGlmIChmYWxsYmFja01vZGUgPT09IEZhbGxiYWNrTW9kZS5QUkVSRU5ERVIgJiYgaXNCb3QodXNlckFnZW50KSkge1xuICAgICAgICAgICAgICAgIGlmICghaXNSb3V0ZVBQUkVuYWJsZWQgfHwgaXNIdG1sQm90KSB7XG4gICAgICAgICAgICAgICAgICAgIGZhbGxiYWNrTW9kZSA9IEZhbGxiYWNrTW9kZS5CTE9DS0lOR19TVEFUSUNfUkVOREVSO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgocHJldmlvdXNDYWNoZUVudHJ5ID09IG51bGwgPyB2b2lkIDAgOiBwcmV2aW91c0NhY2hlRW50cnkuaXNTdGFsZSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgaXNPbkRlbWFuZFJldmFsaWRhdGUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVE9ETzogYWRhcHQgZm9yIFBQUlxuICAgICAgICAgICAgLy8gb25seSBhbGxvdyBvbi1kZW1hbmQgcmV2YWxpZGF0ZSBmb3IgZmFsbGJhY2s6IHRydWUvYmxvY2tpbmdcbiAgICAgICAgICAgIC8vIG9yIGZvciBwcmVyZW5kZXJlZCBmYWxsYmFjazogZmFsc2UgcGF0aHNcbiAgICAgICAgICAgIGlmIChpc09uRGVtYW5kUmV2YWxpZGF0ZSAmJiAoZmFsbGJhY2tNb2RlICE9PSBGYWxsYmFja01vZGUuTk9UX0ZPVU5EIHx8IHByZXZpb3VzQ2FjaGVFbnRyeSkpIHtcbiAgICAgICAgICAgICAgICBmYWxsYmFja01vZGUgPSBGYWxsYmFja01vZGUuQkxPQ0tJTkdfU1RBVElDX1JFTkRFUjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghbWluaW1hbE1vZGUgJiYgZmFsbGJhY2tNb2RlICE9PSBGYWxsYmFja01vZGUuQkxPQ0tJTkdfU1RBVElDX1JFTkRFUiAmJiBzdGF0aWNQYXRoS2V5ICYmICFkaWRSZXNwb25kICYmICFpc0RyYWZ0TW9kZSAmJiBwYWdlSXNEeW5hbWljICYmIChpc1Byb2R1Y3Rpb24gfHwgIWlzUHJlcmVuZGVyZWQpKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIHBhZ2UgaGFzIGR5bmFtaWNQYXJhbXM6IGZhbHNlIGFuZCB0aGlzIHBhdGhuYW1lIHdhc24ndFxuICAgICAgICAgICAgICAgIC8vIHByZXJlbmRlcmVkIHRyaWdnZXIgdGhlIG5vIGZhbGxiYWNrIGhhbmRsaW5nXG4gICAgICAgICAgICAgICAgaWYgKC8vIEluIGRldmVsb3BtZW50LCBmYWxsIHRocm91Z2ggdG8gcmVuZGVyIHRvIGhhbmRsZSBtaXNzaW5nXG4gICAgICAgICAgICAgICAgLy8gZ2V0U3RhdGljUGF0aHMuXG4gICAgICAgICAgICAgICAgKGlzUHJvZHVjdGlvbiB8fCBwcmVyZW5kZXJJbmZvKSAmJiAvLyBXaGVuIGZhbGxiYWNrIGlzbid0IHByZXNlbnQsIGFib3J0IHRoaXMgcmVuZGVyIHNvIHdlIDQwNFxuICAgICAgICAgICAgICAgIGZhbGxiYWNrTW9kZSA9PT0gRmFsbGJhY2tNb2RlLk5PVF9GT1VORCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm9GYWxsYmFja0Vycm9yKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBmYWxsYmFja1Jlc3BvbnNlO1xuICAgICAgICAgICAgICAgIGlmIChpc1JvdXRlUFBSRW5hYmxlZCAmJiAhaXNSU0NSZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhY2hlS2V5ID0gdHlwZW9mIChwcmVyZW5kZXJJbmZvID09IG51bGwgPyB2b2lkIDAgOiBwcmVyZW5kZXJJbmZvLmZhbGxiYWNrKSA9PT0gJ3N0cmluZycgPyBwcmVyZW5kZXJJbmZvLmZhbGxiYWNrIDogaXNQcm9kdWN0aW9uID8gbm9ybWFsaXplZFNyY1BhZ2UgOiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSB1c2UgdGhlIHJlc3BvbnNlIGNhY2hlIGhlcmUgdG8gaGFuZGxlIHRoZSByZXZhbGlkYXRpb24gYW5kXG4gICAgICAgICAgICAgICAgICAgIC8vIG1hbmFnZW1lbnQgb2YgdGhlIGZhbGxiYWNrIHNoZWxsLlxuICAgICAgICAgICAgICAgICAgICBmYWxsYmFja1Jlc3BvbnNlID0gYXdhaXQgcm91dGVNb2R1bGUuaGFuZGxlUmVzcG9uc2Uoe1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGVLZXksXG4gICAgICAgICAgICAgICAgICAgICAgICByZXEsXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0Q29uZmlnLFxuICAgICAgICAgICAgICAgICAgICAgICAgcm91dGVLaW5kOiBSb3V0ZUtpbmQuQVBQX1BBR0UsXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0ZhbGxiYWNrOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJlcmVuZGVyTWFuaWZlc3QsXG4gICAgICAgICAgICAgICAgICAgICAgICBpc1JvdXRlUFBSRW5hYmxlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlR2VuZXJhdG9yOiBhc3luYyAoKT0+ZG9SZW5kZXIoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcGFuLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBwYXNzIGB1bmRlZmluZWRgIGFzIHJlbmRlcmluZyBhIGZhbGxiYWNrIGlzbid0IHJlc3VtZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaGVyZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zdHBvbmVkOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhbGxiYWNrUm91dGVQYXJhbXM6IC8vIElmIHdlJ3JlIGluIHByb2R1Y3Rpb24gb3Igd2UncmUgZGVidWdnaW5nIHRoZSBmYWxsYmFja1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzaGVsbCB0aGVuIHdlIHNob3VsZCBwb3N0cG9uZSB3aGVuIGR5bmFtaWMgcGFyYW1zIGFyZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhY2Nlc3NlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNQcm9kdWN0aW9uIHx8IGlzRGVidWdGYWxsYmFja1NoZWxsID8gZ2V0RmFsbGJhY2tSb3V0ZVBhcmFtcyhub3JtYWxpemVkU3JjUGFnZSkgOiBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICB3YWl0VW50aWw6IGN0eC53YWl0VW50aWxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBmYWxsYmFjayByZXNwb25zZSB3YXMgc2V0IHRvIG51bGwsIHRoZW4gd2Ugc2hvdWxkIHJldHVybiBudWxsLlxuICAgICAgICAgICAgICAgICAgICBpZiAoZmFsbGJhY2tSZXNwb25zZSA9PT0gbnVsbCkgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgaWYgd2UgZGlkIGdldCBhIGZhbGxiYWNrIHJlc3BvbnNlLCB3ZSBzaG91bGQgcmV0dXJuIGl0LlxuICAgICAgICAgICAgICAgICAgICBpZiAoZmFsbGJhY2tSZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBjYWNoZSBjb250cm9sIGZyb20gdGhlIHJlc3BvbnNlIHRvIHByZXZlbnQgaXQgZnJvbSBiZWluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdXNlZCBpbiB0aGUgc3Vycm91bmRpbmcgY2FjaGUuXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgZmFsbGJhY2tSZXNwb25zZS5jYWNoZUNvbnRyb2w7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsbGJhY2tSZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE9ubHkgcmVxdWVzdHMgdGhhdCBhcmVuJ3QgcmV2YWxpZGF0aW5nIGNhbiBiZSByZXN1bWVkLiBJZiB3ZSBoYXZlIHRoZVxuICAgICAgICAgICAgLy8gbWluaW1hbCBwb3N0cG9uZWQgZGF0YSwgdGhlbiB3ZSBzaG91bGQgcmVzdW1lIHRoZSByZW5kZXIgd2l0aCBpdC5cbiAgICAgICAgICAgIGNvbnN0IHBvc3Rwb25lZCA9ICFpc09uRGVtYW5kUmV2YWxpZGF0ZSAmJiAhaXNSZXZhbGlkYXRpbmcgJiYgbWluaW1hbFBvc3Rwb25lZCA/IG1pbmltYWxQb3N0cG9uZWQgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAvLyBXaGVuIHdlJ3JlIGluIG1pbmltYWwgbW9kZSwgaWYgd2UncmUgdHJ5aW5nIHRvIGRlYnVnIHRoZSBzdGF0aWMgc2hlbGwsXG4gICAgICAgICAgICAvLyB3ZSBzaG91bGQganVzdCByZXR1cm4gbm90aGluZyBpbnN0ZWFkIG9mIHJlc3VtaW5nIHRoZSBkeW5hbWljIHJlbmRlci5cbiAgICAgICAgICAgIGlmICgoaXNEZWJ1Z1N0YXRpY1NoZWxsIHx8IGlzRGVidWdEeW5hbWljQWNjZXNzZXMpICYmIHR5cGVvZiBwb3N0cG9uZWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVDb250cm9sOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXZhbGlkYXRlOiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwaXJlOiB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IENhY2hlZFJvdXRlS2luZC5QQUdFUyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IFJlbmRlclJlc3VsdC5FTVBUWSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2VEYXRhOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czogdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgdGhpcyBpcyBhIGR5bmFtaWMgcm91dGUgd2l0aCBQUFIgZW5hYmxlZCBhbmQgdGhlIGRlZmF1bHQgcm91dGVcbiAgICAgICAgICAgIC8vIG1hdGNoZXMgd2VyZSBzZXQsIHRoZW4gd2Ugc2hvdWxkIHBhc3MgdGhlIGZhbGxiYWNrIHJvdXRlIHBhcmFtcyB0b1xuICAgICAgICAgICAgLy8gdGhlIHJlbmRlcmVyIGFzIHRoaXMgaXMgYSBmYWxsYmFjayByZXZhbGlkYXRpb24gcmVxdWVzdC5cbiAgICAgICAgICAgIGNvbnN0IGZhbGxiYWNrUm91dGVQYXJhbXMgPSBwYWdlSXNEeW5hbWljICYmIGlzUm91dGVQUFJFbmFibGVkICYmIChnZXRSZXF1ZXN0TWV0YShyZXEsICdyZW5kZXJGYWxsYmFja1NoZWxsJykgfHwgaXNEZWJ1Z0ZhbGxiYWNrU2hlbGwpID8gZ2V0RmFsbGJhY2tSb3V0ZVBhcmFtcyhwYXRobmFtZSkgOiBudWxsO1xuICAgICAgICAgICAgLy8gUGVyZm9ybSB0aGUgcmVuZGVyLlxuICAgICAgICAgICAgcmV0dXJuIGRvUmVuZGVyKHtcbiAgICAgICAgICAgICAgICBzcGFuLFxuICAgICAgICAgICAgICAgIHBvc3Rwb25lZCxcbiAgICAgICAgICAgICAgICBmYWxsYmFja1JvdXRlUGFyYW1zXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgaGFuZGxlUmVzcG9uc2UgPSBhc3luYyAoc3Bhbik9PntcbiAgICAgICAgICAgIHZhciBfY2FjaGVFbnRyeV92YWx1ZSwgX2NhY2hlZERhdGFfaGVhZGVycztcbiAgICAgICAgICAgIGNvbnN0IGNhY2hlRW50cnkgPSBhd2FpdCByb3V0ZU1vZHVsZS5oYW5kbGVSZXNwb25zZSh7XG4gICAgICAgICAgICAgICAgY2FjaGVLZXk6IHNzZ0NhY2hlS2V5LFxuICAgICAgICAgICAgICAgIHJlc3BvbnNlR2VuZXJhdG9yOiAoYyk9PnJlc3BvbnNlR2VuZXJhdG9yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwYW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5jXG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIHJvdXRlS2luZDogUm91dGVLaW5kLkFQUF9QQUdFLFxuICAgICAgICAgICAgICAgIGlzT25EZW1hbmRSZXZhbGlkYXRlLFxuICAgICAgICAgICAgICAgIGlzUm91dGVQUFJFbmFibGVkLFxuICAgICAgICAgICAgICAgIHJlcSxcbiAgICAgICAgICAgICAgICBuZXh0Q29uZmlnLFxuICAgICAgICAgICAgICAgIHByZXJlbmRlck1hbmlmZXN0LFxuICAgICAgICAgICAgICAgIHdhaXRVbnRpbDogY3R4LndhaXRVbnRpbFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoaXNEcmFmdE1vZGUpIHtcbiAgICAgICAgICAgICAgICByZXMuc2V0SGVhZGVyKCdDYWNoZS1Db250cm9sJywgJ3ByaXZhdGUsIG5vLWNhY2hlLCBuby1zdG9yZSwgbWF4LWFnZT0wLCBtdXN0LXJldmFsaWRhdGUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEluIGRldiwgd2Ugc2hvdWxkIG5vdCBjYWNoZSBwYWdlcyBmb3IgYW55IHJlYXNvbi5cbiAgICAgICAgICAgIGlmIChyb3V0ZU1vZHVsZS5pc0Rldikge1xuICAgICAgICAgICAgICAgIHJlcy5zZXRIZWFkZXIoJ0NhY2hlLUNvbnRyb2wnLCAnbm8tc3RvcmUsIG11c3QtcmV2YWxpZGF0ZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFjYWNoZUVudHJ5KSB7XG4gICAgICAgICAgICAgICAgaWYgKHNzZ0NhY2hlS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEEgY2FjaGUgZW50cnkgbWlnaHQgbm90IGJlIGdlbmVyYXRlZCBpZiBhIHJlc3BvbnNlIGlzIHdyaXR0ZW5cbiAgICAgICAgICAgICAgICAgICAgLy8gaW4gYGdldEluaXRpYWxQcm9wc2Agb3IgYGdldFNlcnZlclNpZGVQcm9wc2AsIGJ1dCB0aG9zZSBzaG91bGRuJ3RcbiAgICAgICAgICAgICAgICAgICAgLy8gaGF2ZSBhIGNhY2hlIGtleS4gSWYgd2UgZG8gaGF2ZSBhIGNhY2hlIGtleSBidXQgd2UgZG9uJ3QgZW5kIHVwXG4gICAgICAgICAgICAgICAgICAgIC8vIHdpdGggYSBjYWNoZSBlbnRyeSwgdGhlbiBlaXRoZXIgTmV4dC5qcyBvciB0aGUgYXBwbGljYXRpb24gaGFzIGFcbiAgICAgICAgICAgICAgICAgICAgLy8gYnVnIHRoYXQgbmVlZHMgZml4aW5nLlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3IEVycm9yKCdpbnZhcmlhbnQ6IGNhY2hlIGVudHJ5IHJlcXVpcmVkIGJ1dCBub3QgZ2VuZXJhdGVkJyksIFwiX19ORVhUX0VSUk9SX0NPREVcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IFwiRTYyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKChfY2FjaGVFbnRyeV92YWx1ZSA9IGNhY2hlRW50cnkudmFsdWUpID09IG51bGwgPyB2b2lkIDAgOiBfY2FjaGVFbnRyeV92YWx1ZS5raW5kKSAhPT0gQ2FjaGVkUm91dGVLaW5kLkFQUF9QQUdFKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9jYWNoZUVudHJ5X3ZhbHVlMTtcbiAgICAgICAgICAgICAgICB0aHJvdyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3IEVycm9yKGBJbnZhcmlhbnQgYXBwLXBhZ2UgaGFuZGxlciByZWNlaXZlZCBpbnZhbGlkIGNhY2hlIGVudHJ5ICR7KF9jYWNoZUVudHJ5X3ZhbHVlMSA9IGNhY2hlRW50cnkudmFsdWUpID09IG51bGwgPyB2b2lkIDAgOiBfY2FjaGVFbnRyeV92YWx1ZTEua2luZH1gKSwgXCJfX05FWFRfRVJST1JfQ09ERVwiLCB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBcIkU3MDdcIixcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZGlkUG9zdHBvbmUgPSB0eXBlb2YgY2FjaGVFbnRyeS52YWx1ZS5wb3N0cG9uZWQgPT09ICdzdHJpbmcnO1xuICAgICAgICAgICAgaWYgKGlzU1NHICYmIC8vIFdlIGRvbid0IHdhbnQgdG8gc2VuZCBhIGNhY2hlIGhlYWRlciBmb3IgcmVxdWVzdHMgdGhhdCBjb250YWluIGR5bmFtaWNcbiAgICAgICAgICAgIC8vIGRhdGEuIElmIHRoaXMgaXMgYSBEeW5hbWljIFJTQyByZXF1ZXN0IG9yIHdhc24ndCBhIFByZWZldGNoIFJTQ1xuICAgICAgICAgICAgLy8gcmVxdWVzdCwgdGhlbiB3ZSBzaG91bGQgc2V0IHRoZSBjYWNoZSBoZWFkZXIuXG4gICAgICAgICAgICAhaXNEeW5hbWljUlNDUmVxdWVzdCAmJiAoIWRpZFBvc3Rwb25lIHx8IGlzUHJlZmV0Y2hSU0NSZXF1ZXN0KSkge1xuICAgICAgICAgICAgICAgIGlmICghbWluaW1hbE1vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gc2V0IHgtbmV4dGpzLWNhY2hlIGhlYWRlciB0byBtYXRjaCB0aGUgaGVhZGVyXG4gICAgICAgICAgICAgICAgICAgIC8vIHdlIHNldCBmb3IgdGhlIGltYWdlLW9wdGltaXplclxuICAgICAgICAgICAgICAgICAgICByZXMuc2V0SGVhZGVyKCd4LW5leHRqcy1jYWNoZScsIGlzT25EZW1hbmRSZXZhbGlkYXRlID8gJ1JFVkFMSURBVEVEJyA6IGNhY2hlRW50cnkuaXNNaXNzID8gJ01JU1MnIDogY2FjaGVFbnRyeS5pc1N0YWxlID8gJ1NUQUxFJyA6ICdISVQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gU2V0IGEgaGVhZGVyIHVzZWQgYnkgdGhlIGNsaWVudCByb3V0ZXIgdG8gc2lnbmFsIHRoZSByZXNwb25zZSBpcyBzdGF0aWNcbiAgICAgICAgICAgICAgICAvLyBhbmQgc2hvdWxkIHJlc3BlY3QgdGhlIGBzdGF0aWNgIGNhY2hlIHN0YWxlVGltZSB2YWx1ZS5cbiAgICAgICAgICAgICAgICByZXMuc2V0SGVhZGVyKE5FWFRfSVNfUFJFUkVOREVSX0hFQURFUiwgJzEnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgdmFsdWU6IGNhY2hlZERhdGEgfSA9IGNhY2hlRW50cnk7XG4gICAgICAgICAgICAvLyBDb2VyY2UgdGhlIGNhY2hlIGNvbnRyb2wgcGFyYW1ldGVyIGZyb20gdGhlIHJlbmRlci5cbiAgICAgICAgICAgIGxldCBjYWNoZUNvbnRyb2w7XG4gICAgICAgICAgICAvLyBJZiB0aGlzIGlzIGEgcmVzdW1lIHJlcXVlc3QgaW4gbWluaW1hbCBtb2RlIGl0IGlzIHN0cmVhbWVkIHdpdGggZHluYW1pY1xuICAgICAgICAgICAgLy8gY29udGVudCBhbmQgc2hvdWxkIG5vdCBiZSBjYWNoZWQuXG4gICAgICAgICAgICBpZiAobWluaW1hbFBvc3Rwb25lZCkge1xuICAgICAgICAgICAgICAgIGNhY2hlQ29udHJvbCA9IHtcbiAgICAgICAgICAgICAgICAgICAgcmV2YWxpZGF0ZTogMCxcbiAgICAgICAgICAgICAgICAgICAgZXhwaXJlOiB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChtaW5pbWFsTW9kZSAmJiBpc1JTQ1JlcXVlc3QgJiYgIWlzUHJlZmV0Y2hSU0NSZXF1ZXN0ICYmIGlzUm91dGVQUFJFbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgY2FjaGVDb250cm9sID0ge1xuICAgICAgICAgICAgICAgICAgICByZXZhbGlkYXRlOiAwLFxuICAgICAgICAgICAgICAgICAgICBleHBpcmU6IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFyb3V0ZU1vZHVsZS5pc0Rldikge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoaXMgaXMgYSBwcmV2aWV3IG1vZGUgcmVxdWVzdCwgd2Ugc2hvdWxkbid0IGNhY2hlIGl0XG4gICAgICAgICAgICAgICAgaWYgKGlzRHJhZnRNb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhY2hlQ29udHJvbCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldmFsaWRhdGU6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBleHBpcmU6IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIWlzU1NHKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcmVzLmdldEhlYWRlcignQ2FjaGUtQ29udHJvbCcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWNoZUNvbnRyb2wgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV2YWxpZGF0ZTogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBpcmU6IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2FjaGVFbnRyeS5jYWNoZUNvbnRyb2wpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIGNhY2hlIGVudHJ5IGhhcyBhIGNhY2hlIGNvbnRyb2wgd2l0aCBhIHJldmFsaWRhdGUgdmFsdWUgdGhhdCdzXG4gICAgICAgICAgICAgICAgICAgIC8vIGEgbnVtYmVyLCB1c2UgaXQuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY2FjaGVFbnRyeS5jYWNoZUNvbnRyb2wucmV2YWxpZGF0ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfY2FjaGVFbnRyeV9jYWNoZUNvbnRyb2w7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2FjaGVFbnRyeS5jYWNoZUNvbnRyb2wucmV2YWxpZGF0ZSA8IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3IEVycm9yKGBJbnZhbGlkIHJldmFsaWRhdGUgY29uZmlndXJhdGlvbiBwcm92aWRlZDogJHtjYWNoZUVudHJ5LmNhY2hlQ29udHJvbC5yZXZhbGlkYXRlfSA8IDFgKSwgXCJfX05FWFRfRVJST1JfQ09ERVwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBcIkUyMlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWNoZUNvbnRyb2wgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV2YWxpZGF0ZTogY2FjaGVFbnRyeS5jYWNoZUNvbnRyb2wucmV2YWxpZGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBpcmU6ICgoX2NhY2hlRW50cnlfY2FjaGVDb250cm9sID0gY2FjaGVFbnRyeS5jYWNoZUNvbnRyb2wpID09IG51bGwgPyB2b2lkIDAgOiBfY2FjaGVFbnRyeV9jYWNoZUNvbnRyb2wuZXhwaXJlKSA/PyBuZXh0Q29uZmlnLmV4cGlyZVRpbWVcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWNoZUNvbnRyb2wgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV2YWxpZGF0ZTogQ0FDSEVfT05FX1lFQVIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwaXJlOiB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYWNoZUVudHJ5LmNhY2hlQ29udHJvbCA9IGNhY2hlQ29udHJvbDtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2VnbWVudFByZWZldGNoSGVhZGVyID09PSAnc3RyaW5nJyAmJiAoY2FjaGVkRGF0YSA9PSBudWxsID8gdm9pZCAwIDogY2FjaGVkRGF0YS5raW5kKSA9PT0gQ2FjaGVkUm91dGVLaW5kLkFQUF9QQUdFICYmIGNhY2hlZERhdGEuc2VnbWVudERhdGEpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2NhY2hlZERhdGFfaGVhZGVyczE7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBhIHByZWZldGNoIHJlcXVlc3QgaXNzdWVkIGJ5IHRoZSBjbGllbnQgU2VnbWVudCBDYWNoZS4gVGhlc2VcbiAgICAgICAgICAgICAgICAvLyBzaG91bGQgbmV2ZXIgcmVhY2ggdGhlIGFwcGxpY2F0aW9uIGxheWVyIChsYW1iZGEpLiBXZSBzaG91bGQgZWl0aGVyXG4gICAgICAgICAgICAgICAgLy8gcmVzcG9uZCBmcm9tIHRoZSBjYWNoZSAoSElUKSBvciByZXNwb25kIHdpdGggMjA0IE5vIENvbnRlbnQgKE1JU1MpLlxuICAgICAgICAgICAgICAgIC8vIFNldCBhIGhlYWRlciB0byBpbmRpY2F0ZSB0aGF0IFBQUiBpcyBlbmFibGVkIGZvciB0aGlzIHJvdXRlLiBUaGlzXG4gICAgICAgICAgICAgICAgLy8gbGV0cyB0aGUgY2xpZW50IGRpc3Rpbmd1aXNoIGJldHdlZW4gYSByZWd1bGFyIGNhY2hlIG1pc3MgYW5kIGEgY2FjaGVcbiAgICAgICAgICAgICAgICAvLyBtaXNzIGR1ZSB0byBQUFIgYmVpbmcgZGlzYWJsZWQuIEluIG90aGVyIGNvbnRleHRzIHRoaXMgaGVhZGVyIGlzIHVzZWRcbiAgICAgICAgICAgICAgICAvLyB0byBpbmRpY2F0ZSB0aGF0IHRoZSByZXNwb25zZSBjb250YWlucyBkeW5hbWljIGRhdGEsIGJ1dCBoZXJlIHdlJ3JlXG4gICAgICAgICAgICAgICAgLy8gb25seSB1c2luZyBpdCB0byBpbmRpY2F0ZSB0aGF0IHRoZSBmZWF0dXJlIGlzIGVuYWJsZWQg4oCUIHRoZSBzZWdtZW50XG4gICAgICAgICAgICAgICAgLy8gcmVzcG9uc2UgaXRzZWxmIGNvbnRhaW5zIHdoZXRoZXIgdGhlIGRhdGEgaXMgZHluYW1pYy5cbiAgICAgICAgICAgICAgICByZXMuc2V0SGVhZGVyKE5FWFRfRElEX1BPU1RQT05FX0hFQURFUiwgJzInKTtcbiAgICAgICAgICAgICAgICAvLyBBZGQgdGhlIGNhY2hlIHRhZ3MgaGVhZGVyIHRvIHRoZSByZXNwb25zZSBpZiBpdCBleGlzdHMgYW5kIHdlJ3JlIGluXG4gICAgICAgICAgICAgICAgLy8gbWluaW1hbCBtb2RlIHdoaWxlIHJlbmRlcmluZyBhIHN0YXRpYyBwYWdlLlxuICAgICAgICAgICAgICAgIGNvbnN0IHRhZ3MgPSAoX2NhY2hlZERhdGFfaGVhZGVyczEgPSBjYWNoZWREYXRhLmhlYWRlcnMpID09IG51bGwgPyB2b2lkIDAgOiBfY2FjaGVkRGF0YV9oZWFkZXJzMVtORVhUX0NBQ0hFX1RBR1NfSEVBREVSXTtcbiAgICAgICAgICAgICAgICBpZiAobWluaW1hbE1vZGUgJiYgaXNTU0cgJiYgdGFncyAmJiB0eXBlb2YgdGFncyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzLnNldEhlYWRlcihORVhUX0NBQ0hFX1RBR1NfSEVBREVSLCB0YWdzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgbWF0Y2hlZFNlZ21lbnQgPSBjYWNoZWREYXRhLnNlZ21lbnREYXRhLmdldChzZWdtZW50UHJlZmV0Y2hIZWFkZXIpO1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaGVkU2VnbWVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENhY2hlIGhpdFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VuZFJlbmRlclJlc3VsdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXEsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBnZW5lcmF0ZUV0YWdzOiBuZXh0Q29uZmlnLmdlbmVyYXRlRXRhZ3MsXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3dlcmVkQnlIZWFkZXI6IG5leHRDb25maWcucG93ZXJlZEJ5SGVhZGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiBSZW5kZXJSZXN1bHQuZnJvbVN0YXRpYyhtYXRjaGVkU2VnbWVudCwgUlNDX0NPTlRFTlRfVFlQRV9IRUFERVIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGVDb250cm9sOiBjYWNoZUVudHJ5LmNhY2hlQ29udHJvbFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQ2FjaGUgbWlzcy4gRWl0aGVyIGEgY2FjaGUgZW50cnkgZm9yIHRoaXMgcm91dGUgaGFzIG5vdCBiZWVuIGdlbmVyYXRlZFxuICAgICAgICAgICAgICAgIC8vICh3aGljaCB0ZWNobmljYWxseSBzaG91bGQgbm90IGJlIHBvc3NpYmxlIHdoZW4gUFBSIGlzIGVuYWJsZWQsIGJlY2F1c2VcbiAgICAgICAgICAgICAgICAvLyBhdCBhIG1pbmltdW0gdGhlcmUgc2hvdWxkIGFsd2F5cyBiZSBhIGZhbGxiYWNrIGVudHJ5KSBvciB0aGVyZSdzIG5vXG4gICAgICAgICAgICAgICAgLy8gbWF0Y2ggZm9yIHRoZSByZXF1ZXN0ZWQgc2VnbWVudC4gUmVzcG9uZCB3aXRoIGEgMjA0IE5vIENvbnRlbnQuIFdlXG4gICAgICAgICAgICAgICAgLy8gZG9uJ3QgYm90aGVyIHRvIHJlc3BvbmQgd2l0aCA0MDQsIGJlY2F1c2UgdGhlc2UgcmVxdWVzdHMgYXJlIG9ubHlcbiAgICAgICAgICAgICAgICAvLyBpc3N1ZWQgYXMgcGFydCBvZiBhIHByZWZldGNoLlxuICAgICAgICAgICAgICAgIHJlcy5zdGF0dXNDb2RlID0gMjA0O1xuICAgICAgICAgICAgICAgIHJldHVybiBzZW5kUmVuZGVyUmVzdWx0KHtcbiAgICAgICAgICAgICAgICAgICAgcmVxLFxuICAgICAgICAgICAgICAgICAgICByZXMsXG4gICAgICAgICAgICAgICAgICAgIGdlbmVyYXRlRXRhZ3M6IG5leHRDb25maWcuZ2VuZXJhdGVFdGFncyxcbiAgICAgICAgICAgICAgICAgICAgcG93ZXJlZEJ5SGVhZGVyOiBuZXh0Q29uZmlnLnBvd2VyZWRCeUhlYWRlcixcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiBSZW5kZXJSZXN1bHQuRU1QVFksXG4gICAgICAgICAgICAgICAgICAgIGNhY2hlQ29udHJvbDogY2FjaGVFbnRyeS5jYWNoZUNvbnRyb2xcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHRoZXJlJ3MgYSBjYWxsYmFjayBmb3IgYG9uQ2FjaGVFbnRyeWAsIGNhbGwgaXQgd2l0aCB0aGUgY2FjaGUgZW50cnlcbiAgICAgICAgICAgIC8vIGFuZCB0aGUgcmV2YWxpZGF0ZSBvcHRpb25zLlxuICAgICAgICAgICAgY29uc3Qgb25DYWNoZUVudHJ5ID0gZ2V0UmVxdWVzdE1ldGEocmVxLCAnb25DYWNoZUVudHJ5Jyk7XG4gICAgICAgICAgICBpZiAob25DYWNoZUVudHJ5KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmluaXNoZWQgPSBhd2FpdCBvbkNhY2hlRW50cnkoe1xuICAgICAgICAgICAgICAgICAgICAuLi5jYWNoZUVudHJ5LFxuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiByZW1vdmUgdGhpcyB3aGVuIHVwc3RyZWFtIGRvZXNuJ3RcbiAgICAgICAgICAgICAgICAgICAgLy8gYWx3YXlzIGV4cGVjdCB0aGlzIHZhbHVlIHRvIGJlIFwiUEFHRVwiXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5jYWNoZUVudHJ5LnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAga2luZDogJ1BBR0UnXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIHVybDogZ2V0UmVxdWVzdE1ldGEocmVxLCAnaW5pdFVSTCcpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKGZpbmlzaGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IG1heWJlIHdlIGhhdmUgdG8gZW5kIHRoZSByZXF1ZXN0P1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiB0aGUgcmVxdWVzdCBoYXMgYSBwb3N0cG9uZWQgc3RhdGUgYW5kIGl0J3MgYSByZXN1bWUgcmVxdWVzdCB3ZVxuICAgICAgICAgICAgLy8gc2hvdWxkIGVycm9yLlxuICAgICAgICAgICAgaWYgKGRpZFBvc3Rwb25lICYmIG1pbmltYWxQb3N0cG9uZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3IEVycm9yKCdJbnZhcmlhbnQ6IHBvc3Rwb25lZCBzdGF0ZSBzaG91bGQgbm90IGJlIHByZXNlbnQgb24gYSByZXN1bWUgcmVxdWVzdCcpLCBcIl9fTkVYVF9FUlJPUl9DT0RFXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IFwiRTM5NlwiLFxuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2FjaGVkRGF0YS5oZWFkZXJzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaGVhZGVycyA9IHtcbiAgICAgICAgICAgICAgICAgICAgLi4uY2FjaGVkRGF0YS5oZWFkZXJzXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAoIW1pbmltYWxNb2RlIHx8ICFpc1NTRykge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgaGVhZGVyc1tORVhUX0NBQ0hFX1RBR1NfSEVBREVSXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGhlYWRlcnMpKXtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcpIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdiBvZiB2YWx1ZSl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzLmFwcGVuZEhlYWRlcihrZXksIHYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcy5hcHBlbmRIZWFkZXIoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXMuYXBwZW5kSGVhZGVyKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQWRkIHRoZSBjYWNoZSB0YWdzIGhlYWRlciB0byB0aGUgcmVzcG9uc2UgaWYgaXQgZXhpc3RzIGFuZCB3ZSdyZSBpblxuICAgICAgICAgICAgLy8gbWluaW1hbCBtb2RlIHdoaWxlIHJlbmRlcmluZyBhIHN0YXRpYyBwYWdlLlxuICAgICAgICAgICAgY29uc3QgdGFncyA9IChfY2FjaGVkRGF0YV9oZWFkZXJzID0gY2FjaGVkRGF0YS5oZWFkZXJzKSA9PSBudWxsID8gdm9pZCAwIDogX2NhY2hlZERhdGFfaGVhZGVyc1tORVhUX0NBQ0hFX1RBR1NfSEVBREVSXTtcbiAgICAgICAgICAgIGlmIChtaW5pbWFsTW9kZSAmJiBpc1NTRyAmJiB0YWdzICYmIHR5cGVvZiB0YWdzID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHJlcy5zZXRIZWFkZXIoTkVYVF9DQUNIRV9UQUdTX0hFQURFUiwgdGFncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiB0aGUgcmVxdWVzdCBpcyBhIGRhdGEgcmVxdWVzdCwgdGhlbiB3ZSBzaG91bGRuJ3Qgc2V0IHRoZSBzdGF0dXMgY29kZVxuICAgICAgICAgICAgLy8gZnJvbSB0aGUgcmVzcG9uc2UgYmVjYXVzZSBpdCBzaG91bGQgYWx3YXlzIGJlIDIwMC4gVGhpcyBzaG91bGQgYmUgZ2F0ZWRcbiAgICAgICAgICAgIC8vIGJlaGluZCB0aGUgZXhwZXJpbWVudGFsIFBQUiBmbGFnLlxuICAgICAgICAgICAgaWYgKGNhY2hlZERhdGEuc3RhdHVzICYmICghaXNSU0NSZXF1ZXN0IHx8ICFpc1JvdXRlUFBSRW5hYmxlZCkpIHtcbiAgICAgICAgICAgICAgICByZXMuc3RhdHVzQ29kZSA9IGNhY2hlZERhdGEuc3RhdHVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUmVkaXJlY3QgaW5mb3JtYXRpb24gaXMgZW5jb2RlZCBpbiBSU0MgcGF5bG9hZCwgc28gd2UgZG9uJ3QgbmVlZCB0byB1c2UgcmVkaXJlY3Qgc3RhdHVzIGNvZGVzXG4gICAgICAgICAgICBpZiAoIW1pbmltYWxNb2RlICYmIGNhY2hlZERhdGEuc3RhdHVzICYmIFJlZGlyZWN0U3RhdHVzQ29kZVtjYWNoZWREYXRhLnN0YXR1c10gJiYgaXNSU0NSZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgcmVzLnN0YXR1c0NvZGUgPSAyMDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBNYXJrIHRoYXQgdGhlIHJlcXVlc3QgZGlkIHBvc3Rwb25lLlxuICAgICAgICAgICAgaWYgKGRpZFBvc3Rwb25lKSB7XG4gICAgICAgICAgICAgICAgcmVzLnNldEhlYWRlcihORVhUX0RJRF9QT1NUUE9ORV9IRUFERVIsICcxJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB3ZSBkb24ndCBnbyB0aHJvdWdoIHRoaXMgYmxvY2sgd2hlbiBwcmV2aWV3IG1vZGUgaXMgdHJ1ZVxuICAgICAgICAgICAgLy8gYXMgcHJldmlldyBtb2RlIGlzIGEgZHluYW1pYyByZXF1ZXN0IChieXBhc3NlcyBjYWNoZSkgYW5kIGRvZXNuJ3RcbiAgICAgICAgICAgIC8vIGdlbmVyYXRlIGJvdGggSFRNTCBhbmQgcGF5bG9hZHMgaW4gdGhlIHNhbWUgcmVxdWVzdCBzbyBjb250aW51ZSB0byBqdXN0XG4gICAgICAgICAgICAvLyByZXR1cm4gdGhlIGdlbmVyYXRlZCBwYXlsb2FkXG4gICAgICAgICAgICBpZiAoaXNSU0NSZXF1ZXN0ICYmICFpc0RyYWZ0TW9kZSkge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoaXMgaXMgYSBkeW5hbWljIFJTQyByZXF1ZXN0LCB0aGVuIHN0cmVhbSB0aGUgcmVzcG9uc2UuXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjYWNoZWREYXRhLnJzY0RhdGEgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjYWNoZWREYXRhLnBvc3Rwb25lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ldyBFcnJvcignSW52YXJpYW50OiBFeHBlY3RlZCBwb3N0cG9uZWQgdG8gYmUgdW5kZWZpbmVkJyksIFwiX19ORVhUX0VSUk9SX0NPREVcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBcIkUzNzJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZW5kUmVuZGVyUmVzdWx0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdlbmVyYXRlRXRhZ3M6IG5leHRDb25maWcuZ2VuZXJhdGVFdGFncyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvd2VyZWRCeUhlYWRlcjogbmV4dENvbmZpZy5wb3dlcmVkQnlIZWFkZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IGNhY2hlZERhdGEuaHRtbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIER5bmFtaWMgUlNDIHJlc3BvbnNlcyBjYW5ub3QgYmUgY2FjaGVkLCBldmVuIGlmIHRoZXkncmVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbmZpZ3VyZWQgd2l0aCBgZm9yY2Utc3RhdGljYCBiZWNhdXNlIHdlIGhhdmUgbm8gd2F5IG9mXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBkaXN0aW5ndWlzaGluZyBiZXR3ZWVuIGBmb3JjZS1zdGF0aWNgIGFuZCBwYWdlcyB0aGF0IGhhdmUgbm9cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHBvc3Rwb25lZCBzdGF0ZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IGRpc3Rpbmd1aXNoIGBmb3JjZS1zdGF0aWNgIGZyb20gcGFnZXMgd2l0aCBubyBwb3N0cG9uZWQgc3RhdGUgKHN0YXRpYylcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlQ29udHJvbDogaXNEeW5hbWljUlNDUmVxdWVzdCA/IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXZhbGlkYXRlOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cGlyZTogdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgICAgICB9IDogY2FjaGVFbnRyeS5jYWNoZUNvbnRyb2xcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEFzIHRoaXMgaXNuJ3QgYSBwcmVmZXRjaCByZXF1ZXN0LCB3ZSBzaG91bGQgc2VydmUgdGhlIHN0YXRpYyBmbGlnaHRcbiAgICAgICAgICAgICAgICAvLyBkYXRhLlxuICAgICAgICAgICAgICAgIHJldHVybiBzZW5kUmVuZGVyUmVzdWx0KHtcbiAgICAgICAgICAgICAgICAgICAgcmVxLFxuICAgICAgICAgICAgICAgICAgICByZXMsXG4gICAgICAgICAgICAgICAgICAgIGdlbmVyYXRlRXRhZ3M6IG5leHRDb25maWcuZ2VuZXJhdGVFdGFncyxcbiAgICAgICAgICAgICAgICAgICAgcG93ZXJlZEJ5SGVhZGVyOiBuZXh0Q29uZmlnLnBvd2VyZWRCeUhlYWRlcixcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiBSZW5kZXJSZXN1bHQuZnJvbVN0YXRpYyhjYWNoZWREYXRhLnJzY0RhdGEsIFJTQ19DT05URU5UX1RZUEVfSEVBREVSKSxcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVDb250cm9sOiBjYWNoZUVudHJ5LmNhY2hlQ29udHJvbFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVGhpcyBpcyBhIHJlcXVlc3QgZm9yIEhUTUwgZGF0YS5cbiAgICAgICAgICAgIGxldCBib2R5ID0gY2FjaGVkRGF0YS5odG1sO1xuICAgICAgICAgICAgLy8gSWYgdGhlcmUncyBubyBwb3N0cG9uZWQgc3RhdGUsIHdlIHNob3VsZCBqdXN0IHNlcnZlIHRoZSBIVE1MLiBUaGlzXG4gICAgICAgICAgICAvLyBzaG91bGQgYWxzbyBiZSB0aGUgY2FzZSBmb3IgYSByZXN1bWUgcmVxdWVzdCBiZWNhdXNlIGl0J3MgY29tcGxldGVkXG4gICAgICAgICAgICAvLyBhcyBhIHNlcnZlciByZW5kZXIgKHJhdGhlciB0aGFuIGEgc3RhdGljIHJlbmRlcikuXG4gICAgICAgICAgICBpZiAoIWRpZFBvc3Rwb25lIHx8IG1pbmltYWxNb2RlIHx8IGlzUlNDUmVxdWVzdCkge1xuICAgICAgICAgICAgICAgIC8vIElmIHdlJ3JlIGluIHRlc3QgbW9kZSwgd2Ugc2hvdWxkIGFkZCBhIHNlbnRpbmVsIGNodW5rIHRvIHRoZSByZXNwb25zZVxuICAgICAgICAgICAgICAgIC8vIHRoYXQncyBiZXR3ZWVuIHRoZSBzdGF0aWMgYW5kIGR5bmFtaWMgcGFydHMgc28gd2UgY2FuIGNvbXBhcmUgdGhlXG4gICAgICAgICAgICAgICAgLy8gY2h1bmtzIGFuZCBhZGQgYXNzZXJ0aW9ucy5cbiAgICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX1RFU1RfTU9ERSAmJiBtaW5pbWFsTW9kZSAmJiBpc1JvdXRlUFBSRW5hYmxlZCAmJiBib2R5LmNvbnRlbnRUeXBlID09PSBIVE1MX0NPTlRFTlRfVFlQRV9IRUFERVIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQXMgd2UncmUgaW4gbWluaW1hbCBtb2RlLCB0aGUgc3RhdGljIHBhcnQgd291bGQgaGF2ZSBhbHJlYWR5IGJlZW5cbiAgICAgICAgICAgICAgICAgICAgLy8gc3RyZWFtZWQgZmlyc3QuIFRoZSBvbmx5IHBhcnQgdGhhdCB0aGlzIHN0cmVhbXMgaXMgdGhlIGR5bmFtaWMgcGFydFxuICAgICAgICAgICAgICAgICAgICAvLyBzbyB3ZSBzaG91bGQgRklSU1Qgc3RyZWFtIHRoZSBzZW50aW5lbCBhbmQgVEhFTiB0aGUgZHluYW1pYyBwYXJ0LlxuICAgICAgICAgICAgICAgICAgICBib2R5LnVuc2hpZnQoY3JlYXRlUFBSQm91bmRhcnlTZW50aW5lbCgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbmRSZW5kZXJSZXN1bHQoe1xuICAgICAgICAgICAgICAgICAgICByZXEsXG4gICAgICAgICAgICAgICAgICAgIHJlcyxcbiAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGVFdGFnczogbmV4dENvbmZpZy5nZW5lcmF0ZUV0YWdzLFxuICAgICAgICAgICAgICAgICAgICBwb3dlcmVkQnlIZWFkZXI6IG5leHRDb25maWcucG93ZXJlZEJ5SGVhZGVyLFxuICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IGJvZHksXG4gICAgICAgICAgICAgICAgICAgIGNhY2hlQ29udHJvbDogY2FjaGVFbnRyeS5jYWNoZUNvbnRyb2xcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHdlJ3JlIGRlYnVnZ2luZyB0aGUgc3RhdGljIHNoZWxsIG9yIHRoZSBkeW5hbWljIEFQSSBhY2Nlc3Nlcywgd2VcbiAgICAgICAgICAgIC8vIHNob3VsZCBqdXN0IHNlcnZlIHRoZSBIVE1MIHdpdGhvdXQgcmVzdW1pbmcgdGhlIHJlbmRlci4gVGhlIHJldHVybmVkXG4gICAgICAgICAgICAvLyBIVE1MIHdpbGwgYmUgdGhlIHN0YXRpYyBzaGVsbCBzbyBhbGwgdGhlIER5bmFtaWMgQVBJJ3Mgd2lsbCBiZSB1c2VkXG4gICAgICAgICAgICAvLyBkdXJpbmcgc3RhdGljIGdlbmVyYXRpb24uXG4gICAgICAgICAgICBpZiAoaXNEZWJ1Z1N0YXRpY1NoZWxsIHx8IGlzRGVidWdEeW5hbWljQWNjZXNzZXMpIHtcbiAgICAgICAgICAgICAgICAvLyBTaW5jZSB3ZSdyZSBub3QgcmVzdW1pbmcgdGhlIHJlbmRlciwgd2UgbmVlZCB0byBhdCBsZWFzdCBhZGQgdGhlXG4gICAgICAgICAgICAgICAgLy8gY2xvc2luZyBib2R5IGFuZCBodG1sIHRhZ3MgdG8gY3JlYXRlIHZhbGlkIEhUTUwuXG4gICAgICAgICAgICAgICAgYm9keS5wdXNoKG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0IChjb250cm9sbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoRU5DT0RFRF9UQUdTLkNMT1NFRC5CT0RZX0FORF9IVE1MKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VuZFJlbmRlclJlc3VsdCh7XG4gICAgICAgICAgICAgICAgICAgIHJlcSxcbiAgICAgICAgICAgICAgICAgICAgcmVzLFxuICAgICAgICAgICAgICAgICAgICBnZW5lcmF0ZUV0YWdzOiBuZXh0Q29uZmlnLmdlbmVyYXRlRXRhZ3MsXG4gICAgICAgICAgICAgICAgICAgIHBvd2VyZWRCeUhlYWRlcjogbmV4dENvbmZpZy5wb3dlcmVkQnlIZWFkZXIsXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDogYm9keSxcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVDb250cm9sOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXZhbGlkYXRlOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwaXJlOiB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgd2UncmUgaW4gdGVzdCBtb2RlLCB3ZSBzaG91bGQgYWRkIGEgc2VudGluZWwgY2h1bmsgdG8gdGhlIHJlc3BvbnNlXG4gICAgICAgICAgICAvLyB0aGF0J3MgYmV0d2VlbiB0aGUgc3RhdGljIGFuZCBkeW5hbWljIHBhcnRzIHNvIHdlIGNhbiBjb21wYXJlIHRoZVxuICAgICAgICAgICAgLy8gY2h1bmtzIGFuZCBhZGQgYXNzZXJ0aW9ucy5cbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfVEVTVF9NT0RFKSB7XG4gICAgICAgICAgICAgICAgYm9keS5wdXNoKGNyZWF0ZVBQUkJvdW5kYXJ5U2VudGluZWwoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUaGlzIHJlcXVlc3QgaGFzIHBvc3Rwb25lZCwgc28gbGV0J3MgY3JlYXRlIGEgbmV3IHRyYW5zZm9ybWVyIHRoYXQgdGhlXG4gICAgICAgICAgICAvLyBkeW5hbWljIGRhdGEgY2FuIHBpcGUgdG8gdGhhdCB3aWxsIGF0dGFjaCB0aGUgZHluYW1pYyBkYXRhIHRvIHRoZSBlbmRcbiAgICAgICAgICAgIC8vIG9mIHRoZSByZXNwb25zZS5cbiAgICAgICAgICAgIGNvbnN0IHRyYW5zZm9ybWVyID0gbmV3IFRyYW5zZm9ybVN0cmVhbSgpO1xuICAgICAgICAgICAgYm9keS5wdXNoKHRyYW5zZm9ybWVyLnJlYWRhYmxlKTtcbiAgICAgICAgICAgIC8vIFBlcmZvcm0gdGhlIHJlbmRlciBhZ2FpbiwgYnV0IHRoaXMgdGltZSwgcHJvdmlkZSB0aGUgcG9zdHBvbmVkIHN0YXRlLlxuICAgICAgICAgICAgLy8gV2UgZG9uJ3QgYXdhaXQgYmVjYXVzZSB3ZSB3YW50IHRoZSByZXN1bHQgdG8gc3RhcnQgc3RyZWFtaW5nIG5vdywgYW5kXG4gICAgICAgICAgICAvLyB3ZSd2ZSBhbHJlYWR5IGNoYWluZWQgdGhlIHRyYW5zZm9ybWVyJ3MgcmVhZGFibGUgdG8gdGhlIHJlbmRlciByZXN1bHQuXG4gICAgICAgICAgICBkb1JlbmRlcih7XG4gICAgICAgICAgICAgICAgc3BhbixcbiAgICAgICAgICAgICAgICBwb3N0cG9uZWQ6IGNhY2hlZERhdGEucG9zdHBvbmVkLFxuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgYSByZXN1bWUgcmVuZGVyLCBub3QgYSBmYWxsYmFjayByZW5kZXIsIHNvIHdlIGRvbid0IG5lZWQgdG9cbiAgICAgICAgICAgICAgICAvLyBzZXQgdGhpcy5cbiAgICAgICAgICAgICAgICBmYWxsYmFja1JvdXRlUGFyYW1zOiBudWxsXG4gICAgICAgICAgICB9KS50aGVuKGFzeW5jIChyZXN1bHQpPT57XG4gICAgICAgICAgICAgICAgdmFyIF9yZXN1bHRfdmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ldyBFcnJvcignSW52YXJpYW50OiBleHBlY3RlZCBhIHJlc3VsdCB0byBiZSByZXR1cm5lZCcpLCBcIl9fTkVYVF9FUlJPUl9DT0RFXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBcIkU0NjNcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoKChfcmVzdWx0X3ZhbHVlID0gcmVzdWx0LnZhbHVlKSA9PSBudWxsID8gdm9pZCAwIDogX3Jlc3VsdF92YWx1ZS5raW5kKSAhPT0gQ2FjaGVkUm91dGVLaW5kLkFQUF9QQUdFKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfcmVzdWx0X3ZhbHVlMTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ldyBFcnJvcihgSW52YXJpYW50OiBleHBlY3RlZCBhIHBhZ2UgcmVzcG9uc2UsIGdvdCAkeyhfcmVzdWx0X3ZhbHVlMSA9IHJlc3VsdC52YWx1ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9yZXN1bHRfdmFsdWUxLmtpbmR9YCksIFwiX19ORVhUX0VSUk9SX0NPREVcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IFwiRTMwNVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFBpcGUgdGhlIHJlc3VtZSByZXN1bHQgdG8gdGhlIHRyYW5zZm9ybWVyLlxuICAgICAgICAgICAgICAgIGF3YWl0IHJlc3VsdC52YWx1ZS5odG1sLnBpcGVUbyh0cmFuc2Zvcm1lci53cml0YWJsZSk7XG4gICAgICAgICAgICB9KS5jYXRjaCgoZXJyKT0+e1xuICAgICAgICAgICAgICAgIC8vIEFuIGVycm9yIG9jY3VycmVkIGR1cmluZyBwaXBpbmcgb3IgcHJlcGFyaW5nIHRoZSByZW5kZXIsIGFib3J0XG4gICAgICAgICAgICAgICAgLy8gdGhlIHRyYW5zZm9ybWVycyB3cml0ZXIgc28gd2UgY2FuIHRlcm1pbmF0ZSB0aGUgc3RyZWFtLlxuICAgICAgICAgICAgICAgIHRyYW5zZm9ybWVyLndyaXRhYmxlLmFib3J0KGVycikuY2F0Y2goKGUpPT57XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJjb3VsZG4ndCBhYm9ydCB0cmFuc2Zvcm1lclwiLCBlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHNlbmRSZW5kZXJSZXN1bHQoe1xuICAgICAgICAgICAgICAgIHJlcSxcbiAgICAgICAgICAgICAgICByZXMsXG4gICAgICAgICAgICAgICAgZ2VuZXJhdGVFdGFnczogbmV4dENvbmZpZy5nZW5lcmF0ZUV0YWdzLFxuICAgICAgICAgICAgICAgIHBvd2VyZWRCeUhlYWRlcjogbmV4dENvbmZpZy5wb3dlcmVkQnlIZWFkZXIsXG4gICAgICAgICAgICAgICAgcmVzdWx0OiBib2R5LFxuICAgICAgICAgICAgICAgIC8vIFdlIGRvbid0IHdhbnQgdG8gY2FjaGUgdGhlIHJlc3BvbnNlIGlmIGl0IGhhcyBwb3N0cG9uZWQgZGF0YSBiZWNhdXNlXG4gICAgICAgICAgICAgICAgLy8gdGhlIHJlc3BvbnNlIGJlaW5nIHNlbnQgdG8gdGhlIGNsaWVudCBpdCdzIGR5bmFtaWMgcGFydHMgYXJlIHN0cmVhbWVkXG4gICAgICAgICAgICAgICAgLy8gdG8gdGhlIGNsaWVudCBvbiB0aGUgc2FtZSByZXF1ZXN0LlxuICAgICAgICAgICAgICAgIGNhY2hlQ29udHJvbDoge1xuICAgICAgICAgICAgICAgICAgICByZXZhbGlkYXRlOiAwLFxuICAgICAgICAgICAgICAgICAgICBleHBpcmU6IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICAvLyBUT0RPOiBhY3RpdmVTcGFuIGNvZGUgcGF0aCBpcyBmb3Igd2hlbiB3cmFwcGVkIGJ5XG4gICAgICAgIC8vIG5leHQtc2VydmVyIGNhbiBiZSByZW1vdmVkIHdoZW4gdGhpcyBpcyBubyBsb25nZXIgdXNlZFxuICAgICAgICBpZiAoYWN0aXZlU3Bhbikge1xuICAgICAgICAgICAgYXdhaXQgaGFuZGxlUmVzcG9uc2UoYWN0aXZlU3Bhbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdHJhY2VyLndpdGhQcm9wYWdhdGVkQ29udGV4dChyZXEuaGVhZGVycywgKCk9PnRyYWNlci50cmFjZShCYXNlU2VydmVyU3Bhbi5oYW5kbGVSZXF1ZXN0LCB7XG4gICAgICAgICAgICAgICAgICAgIHNwYW5OYW1lOiBgJHttZXRob2R9ICR7cmVxLnVybH1gLFxuICAgICAgICAgICAgICAgICAgICBraW5kOiBTcGFuS2luZC5TRVJWRVIsXG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdodHRwLm1ldGhvZCc6IG1ldGhvZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdodHRwLnRhcmdldCc6IHJlcS51cmxcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIGhhbmRsZVJlc3BvbnNlKSk7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgLy8gaWYgd2UgYXJlbid0IHdyYXBwZWQgYnkgYmFzZS1zZXJ2ZXIgaGFuZGxlIGhlcmVcbiAgICAgICAgaWYgKCFhY3RpdmVTcGFuICYmICEoZXJyIGluc3RhbmNlb2YgTm9GYWxsYmFja0Vycm9yKSkge1xuICAgICAgICAgICAgYXdhaXQgcm91dGVNb2R1bGUub25SZXF1ZXN0RXJyb3IocmVxLCBlcnIsIHtcbiAgICAgICAgICAgICAgICByb3V0ZXJLaW5kOiAnQXBwIFJvdXRlcicsXG4gICAgICAgICAgICAgICAgcm91dGVQYXRoOiBzcmNQYWdlLFxuICAgICAgICAgICAgICAgIHJvdXRlVHlwZTogJ3JlbmRlcicsXG4gICAgICAgICAgICAgICAgcmV2YWxpZGF0ZVJlYXNvbjogZ2V0UmV2YWxpZGF0ZVJlYXNvbih7XG4gICAgICAgICAgICAgICAgICAgIGlzUmV2YWxpZGF0ZTogaXNTU0csXG4gICAgICAgICAgICAgICAgICAgIGlzT25EZW1hbmRSZXZhbGlkYXRlXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0sIHJvdXRlclNlcnZlckNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJldGhyb3cgc28gdGhhdCB3ZSBjYW4gaGFuZGxlIHNlcnZpbmcgZXJyb3IgcGFnZVxuICAgICAgICB0aHJvdyBlcnI7XG4gICAgfVxufVxuLy8gVE9ETzogb21pdCB0aGlzIGZyb20gcHJvZHVjdGlvbiBidWlsZHMsIG9ubHkgdGVzdCBidWlsZHMgc2hvdWxkIGluY2x1ZGUgaXRcbi8qKlxuICogQ3JlYXRlcyBhIHJlYWRhYmxlIHN0cmVhbSB0aGF0IGVtaXRzIGEgUFBSIGJvdW5kYXJ5IHNlbnRpbmVsLlxuICpcbiAqIEByZXR1cm5zIEEgcmVhZGFibGUgc3RyZWFtIHRoYXQgZW1pdHMgYSBQUFIgYm91bmRhcnkgc2VudGluZWwuXG4gKi8gZnVuY3Rpb24gY3JlYXRlUFBSQm91bmRhcnlTZW50aW5lbCgpIHtcbiAgICByZXR1cm4gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICAgICAgc3RhcnQgKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoJzwhLS0gUFBSX0JPVU5EQVJZX1NFTlRJTkVMIC0tPicpKTtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcHAtcGFnZS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader/index.js?name=app%2Fauth%2Flogin%2Fpage&page=%2Fauth%2Flogin%2Fpage&appPaths=%2Fauth%2Flogin%2Fpage&pagePath=private-next-app-dir%2Fauth%2Flogin%2Fpage.js&appDir=D%3A%5Cnext%5Corg%5Csrc%5Capp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=D%3A%5Cnext%5Corg&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D&isGlobalNotFoundEnabled=!\n");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22D%3A%5C%5Cnext%5C%5Corg%5C%5Cnode_modules%5C%5Cnext%5C%5Cdist%5C%5Cclient%5C%5Ccomponents%5C%5Cbuiltin%5C%5Cglobal-error.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22D%3A%5C%5Cnext%5C%5Corg%5C%5Cnode_modules%5C%5Cnext%5C%5Cdist%5C%5Cclient%5C%5Ccomponents%5C%5Cclient-page.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22D%3A%5C%5Cnext%5C%5Corg%5C%5Cnode_modules%5C%5Cnext%5C%5Cdist%5C%5Cclient%5C%5Ccomponents%5C%5Cclient-segment.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22D%3A%5C%5Cnext%5C%5Corg%5C%5Cnode_modules%5C%5Cnext%5C%5Cdist%5C%5Cclient%5C%5Ccomponents%5C%5Chttp-access-fallback%5C%5Cerror-boundary.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22D%3A%5C%5Cnext%5C%5Corg%5C%5Cnode_modules%5C%5Cnext%5C%5Cdist%5C%5Cclient%5C%5Ccomponents%5C%5Clayout-router.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22D%3A%5C%5Cnext%5C%5Corg%5C%5Cnode_modules%5C%5Cnext%5C%5Cdist%5C%5Cclient%5C%5Ccomponents%5C%5Cmetadata%5C%5Casync-metadata.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22D%3A%5C%5Cnext%5C%5Corg%5C%5Cnode_modules%5C%5Cnext%5C%5Cdist%5C%5Cclient%5C%5Ccomponents%5C%5Crender-from-template-context.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22D%3A%5C%5Cnext%5C%5Corg%5C%5Cnode_modules%5C%5Cnext%5C%5Cdist%5C%5Clib%5C%5Cframework%5C%5Cboundary-components.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22D%3A%5C%5Cnext%5C%5Corg%5C%5Cnode_modules%5C%5Cnext%5C%5Cdist%5C%5Clib%5C%5Cmetadata%5C%5Cgenerate%5C%5Cicon-mark.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22D%3A%5C%5Cnext%5C%5Corg%5C%5Cnode_modules%5C%5Cnext%5C%5Cdist%5C%5Cnext-devtools%5C%5Cuserspace%5C%5Capp%5C%5Csegment-explorer-node.js%22%2C%22ids%22%3A%5B%5D%7D&server=true!":
/*!******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22D%3A%5C%5Cnext%5C%5Corg%5C%5Cnode_modules%5C%5Cnext%5C%5Cdist%5C%5Cclient%5C%5Ccomponents%5C%5Cbuiltin%5C%5Cglobal-error.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22D%3A%5C%5Cnext%5C%5Corg%5C%5Cnode_modules%5C%5Cnext%5C%5Cdist%5C%5Cclient%5C%5Ccomponents%5C%5Cclient-page.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22D%3A%5C%5Cnext%5C%5Corg%5C%5Cnode_modules%5C%5Cnext%5C%5Cdist%5C%5Cclient%5C%5Ccomponents%5C%5Cclient-segment.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22D%3A%5C%5Cnext%5C%5Corg%5C%5Cnode_modules%5C%5Cnext%5C%5Cdist%5C%5Cclient%5C%5Ccomponents%5C%5Chttp-access-fallback%5C%5Cerror-boundary.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22D%3A%5C%5Cnext%5C%5Corg%5C%5Cnode_modules%5C%5Cnext%5C%5Cdist%5C%5Cclient%5C%5Ccomponents%5C%5Clayout-router.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22D%3A%5C%5Cnext%5C%5Corg%5C%5Cnode_modules%5C%5Cnext%5C%5Cdist%5C%5Cclient%5C%5Ccomponents%5C%5Cmetadata%5C%5Casync-metadata.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22D%3A%5C%5Cnext%5C%5Corg%5C%5Cnode_modules%5C%5Cnext%5C%5Cdist%5C%5Cclient%5C%5Ccomponents%5C%5Crender-from-template-context.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22D%3A%5C%5Cnext%5C%5Corg%5C%5Cnode_modules%5C%5Cnext%5C%5Cdist%5C%5Clib%5C%5Cframework%5C%5Cboundary-components.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22D%3A%5C%5Cnext%5C%5Corg%5C%5Cnode_modules%5C%5Cnext%5C%5Cdist%5C%5Clib%5C%5Cmetadata%5C%5Cgenerate%5C%5Cicon-mark.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22D%3A%5C%5Cnext%5C%5Corg%5C%5Cnode_modules%5C%5Cnext%5C%5Cdist%5C%5Cnext-devtools%5C%5Cuserspace%5C%5Capp%5C%5Csegment-explorer-node.js%22%2C%22ids%22%3A%5B%5D%7D&server=true! ***!
  \******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("Promise.resolve(/*! import() eager */).then(__webpack_require__.t.bind(__webpack_require__, /*! ./node_modules/next/dist/client/components/builtin/global-error.js */ \"(rsc)/./node_modules/next/dist/client/components/builtin/global-error.js\", 23));\n;\nPromise.resolve(/*! import() eager */).then(__webpack_require__.t.bind(__webpack_require__, /*! ./node_modules/next/dist/client/components/client-page.js */ \"(rsc)/./node_modules/next/dist/client/components/client-page.js\", 23));\n;\nPromise.resolve(/*! import() eager */).then(__webpack_require__.t.bind(__webpack_require__, /*! ./node_modules/next/dist/client/components/client-segment.js */ \"(rsc)/./node_modules/next/dist/client/components/client-segment.js\", 23));\n;\nPromise.resolve(/*! import() eager */).then(__webpack_require__.t.bind(__webpack_require__, /*! ./node_modules/next/dist/client/components/http-access-fallback/error-boundary.js */ \"(rsc)/./node_modules/next/dist/client/components/http-access-fallback/error-boundary.js\", 23));\n;\nPromise.resolve(/*! import() eager */).then(__webpack_require__.t.bind(__webpack_require__, /*! ./node_modules/next/dist/client/components/layout-router.js */ \"(rsc)/./node_modules/next/dist/client/components/layout-router.js\", 23));\n;\nPromise.resolve(/*! import() eager */).then(__webpack_require__.t.bind(__webpack_require__, /*! ./node_modules/next/dist/client/components/metadata/async-metadata.js */ \"(rsc)/./node_modules/next/dist/client/components/metadata/async-metadata.js\", 23));\n;\nPromise.resolve(/*! import() eager */).then(__webpack_require__.t.bind(__webpack_require__, /*! ./node_modules/next/dist/client/components/render-from-template-context.js */ \"(rsc)/./node_modules/next/dist/client/components/render-from-template-context.js\", 23));\n;\nPromise.resolve(/*! import() eager */).then(__webpack_require__.t.bind(__webpack_require__, /*! ./node_modules/next/dist/lib/framework/boundary-components.js */ \"(rsc)/./node_modules/next/dist/lib/framework/boundary-components.js\", 23));\n;\nPromise.resolve(/*! import() eager */).then(__webpack_require__.t.bind(__webpack_require__, /*! ./node_modules/next/dist/lib/metadata/generate/icon-mark.js */ \"(rsc)/./node_modules/next/dist/lib/metadata/generate/icon-mark.js\", 23));\n;\nPromise.resolve(/*! import() eager */).then(__webpack_require__.t.bind(__webpack_require__, /*! ./node_modules/next/dist/next-devtools/userspace/app/segment-explorer-node.js */ \"(rsc)/./node_modules/next/dist/next-devtools/userspace/app/segment-explorer-node.js\", 23));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LWZsaWdodC1jbGllbnQtZW50cnktbG9hZGVyLmpzP21vZHVsZXM9JTdCJTIycmVxdWVzdCUyMiUzQSUyMkQlM0ElNUMlNUNuZXh0JTVDJTVDb3JnJTVDJTVDbm9kZV9tb2R1bGVzJTVDJTVDbmV4dCU1QyU1Q2Rpc3QlNUMlNUNjbGllbnQlNUMlNUNjb21wb25lbnRzJTVDJTVDYnVpbHRpbiU1QyU1Q2dsb2JhbC1lcnJvci5qcyUyMiUyQyUyMmlkcyUyMiUzQSU1QiU1RCU3RCZtb2R1bGVzPSU3QiUyMnJlcXVlc3QlMjIlM0ElMjJEJTNBJTVDJTVDbmV4dCU1QyU1Q29yZyU1QyU1Q25vZGVfbW9kdWxlcyU1QyU1Q25leHQlNUMlNUNkaXN0JTVDJTVDY2xpZW50JTVDJTVDY29tcG9uZW50cyU1QyU1Q2NsaWVudC1wYWdlLmpzJTIyJTJDJTIyaWRzJTIyJTNBJTVCJTVEJTdEJm1vZHVsZXM9JTdCJTIycmVxdWVzdCUyMiUzQSUyMkQlM0ElNUMlNUNuZXh0JTVDJTVDb3JnJTVDJTVDbm9kZV9tb2R1bGVzJTVDJTVDbmV4dCU1QyU1Q2Rpc3QlNUMlNUNjbGllbnQlNUMlNUNjb21wb25lbnRzJTVDJTVDY2xpZW50LXNlZ21lbnQuanMlMjIlMkMlMjJpZHMlMjIlM0ElNUIlNUQlN0QmbW9kdWxlcz0lN0IlMjJyZXF1ZXN0JTIyJTNBJTIyRCUzQSU1QyU1Q25leHQlNUMlNUNvcmclNUMlNUNub2RlX21vZHVsZXMlNUMlNUNuZXh0JTVDJTVDZGlzdCU1QyU1Q2NsaWVudCU1QyU1Q2NvbXBvbmVudHMlNUMlNUNodHRwLWFjY2Vzcy1mYWxsYmFjayU1QyU1Q2Vycm9yLWJvdW5kYXJ5LmpzJTIyJTJDJTIyaWRzJTIyJTNBJTVCJTVEJTdEJm1vZHVsZXM9JTdCJTIycmVxdWVzdCUyMiUzQSUyMkQlM0ElNUMlNUNuZXh0JTVDJTVDb3JnJTVDJTVDbm9kZV9tb2R1bGVzJTVDJTVDbmV4dCU1QyU1Q2Rpc3QlNUMlNUNjbGllbnQlNUMlNUNjb21wb25lbnRzJTVDJTVDbGF5b3V0LXJvdXRlci5qcyUyMiUyQyUyMmlkcyUyMiUzQSU1QiU1RCU3RCZtb2R1bGVzPSU3QiUyMnJlcXVlc3QlMjIlM0ElMjJEJTNBJTVDJTVDbmV4dCU1QyU1Q29yZyU1QyU1Q25vZGVfbW9kdWxlcyU1QyU1Q25leHQlNUMlNUNkaXN0JTVDJTVDY2xpZW50JTVDJTVDY29tcG9uZW50cyU1QyU1Q21ldGFkYXRhJTVDJTVDYXN5bmMtbWV0YWRhdGEuanMlMjIlMkMlMjJpZHMlMjIlM0ElNUIlNUQlN0QmbW9kdWxlcz0lN0IlMjJyZXF1ZXN0JTIyJTNBJTIyRCUzQSU1QyU1Q25leHQlNUMlNUNvcmclNUMlNUNub2RlX21vZHVsZXMlNUMlNUNuZXh0JTVDJTVDZGlzdCU1QyU1Q2NsaWVudCU1QyU1Q2NvbXBvbmVudHMlNUMlNUNyZW5kZXItZnJvbS10ZW1wbGF0ZS1jb250ZXh0LmpzJTIyJTJDJTIyaWRzJTIyJTNBJTVCJTVEJTdEJm1vZHVsZXM9JTdCJTIycmVxdWVzdCUyMiUzQSUyMkQlM0ElNUMlNUNuZXh0JTVDJTVDb3JnJTVDJTVDbm9kZV9tb2R1bGVzJTVDJTVDbmV4dCU1QyU1Q2Rpc3QlNUMlNUNsaWIlNUMlNUNmcmFtZXdvcmslNUMlNUNib3VuZGFyeS1jb21wb25lbnRzLmpzJTIyJTJDJTIyaWRzJTIyJTNBJTVCJTVEJTdEJm1vZHVsZXM9JTdCJTIycmVxdWVzdCUyMiUzQSUyMkQlM0ElNUMlNUNuZXh0JTVDJTVDb3JnJTVDJTVDbm9kZV9tb2R1bGVzJTVDJTVDbmV4dCU1QyU1Q2Rpc3QlNUMlNUNsaWIlNUMlNUNtZXRhZGF0YSU1QyU1Q2dlbmVyYXRlJTVDJTVDaWNvbi1tYXJrLmpzJTIyJTJDJTIyaWRzJTIyJTNBJTVCJTVEJTdEJm1vZHVsZXM9JTdCJTIycmVxdWVzdCUyMiUzQSUyMkQlM0ElNUMlNUNuZXh0JTVDJTVDb3JnJTVDJTVDbm9kZV9tb2R1bGVzJTVDJTVDbmV4dCU1QyU1Q2Rpc3QlNUMlNUNuZXh0LWRldnRvb2xzJTVDJTVDdXNlcnNwYWNlJTVDJTVDYXBwJTVDJTVDc2VnbWVudC1leHBsb3Jlci1ub2RlLmpzJTIyJTJDJTIyaWRzJTIyJTNBJTVCJTVEJTdEJnNlcnZlcj10cnVlISIsIm1hcHBpbmdzIjoiQUFBQSxzUEFBMEg7QUFDMUg7QUFDQSxvT0FBZ0g7QUFDaEg7QUFDQSwwT0FBbUg7QUFDbkg7QUFDQSxvUkFBeUk7QUFDekk7QUFDQSx3T0FBa0g7QUFDbEg7QUFDQSw0UEFBNkg7QUFDN0g7QUFDQSxzUUFBaUk7QUFDakk7QUFDQSw0T0FBb0g7QUFDcEg7QUFDQSx3T0FBbUg7QUFDbkg7QUFDQSw0UUFBcUkiLCJzb3VyY2VzIjpbIiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQoLyogd2VicGFja01vZGU6IFwiZWFnZXJcIiAqLyBcIkQ6XFxcXG5leHRcXFxcb3JnXFxcXG5vZGVfbW9kdWxlc1xcXFxuZXh0XFxcXGRpc3RcXFxcY2xpZW50XFxcXGNvbXBvbmVudHNcXFxcYnVpbHRpblxcXFxnbG9iYWwtZXJyb3IuanNcIik7XG47XG5pbXBvcnQoLyogd2VicGFja01vZGU6IFwiZWFnZXJcIiAqLyBcIkQ6XFxcXG5leHRcXFxcb3JnXFxcXG5vZGVfbW9kdWxlc1xcXFxuZXh0XFxcXGRpc3RcXFxcY2xpZW50XFxcXGNvbXBvbmVudHNcXFxcY2xpZW50LXBhZ2UuanNcIik7XG47XG5pbXBvcnQoLyogd2VicGFja01vZGU6IFwiZWFnZXJcIiAqLyBcIkQ6XFxcXG5leHRcXFxcb3JnXFxcXG5vZGVfbW9kdWxlc1xcXFxuZXh0XFxcXGRpc3RcXFxcY2xpZW50XFxcXGNvbXBvbmVudHNcXFxcY2xpZW50LXNlZ21lbnQuanNcIik7XG47XG5pbXBvcnQoLyogd2VicGFja01vZGU6IFwiZWFnZXJcIiAqLyBcIkQ6XFxcXG5leHRcXFxcb3JnXFxcXG5vZGVfbW9kdWxlc1xcXFxuZXh0XFxcXGRpc3RcXFxcY2xpZW50XFxcXGNvbXBvbmVudHNcXFxcaHR0cC1hY2Nlc3MtZmFsbGJhY2tcXFxcZXJyb3ItYm91bmRhcnkuanNcIik7XG47XG5pbXBvcnQoLyogd2VicGFja01vZGU6IFwiZWFnZXJcIiAqLyBcIkQ6XFxcXG5leHRcXFxcb3JnXFxcXG5vZGVfbW9kdWxlc1xcXFxuZXh0XFxcXGRpc3RcXFxcY2xpZW50XFxcXGNvbXBvbmVudHNcXFxcbGF5b3V0LXJvdXRlci5qc1wiKTtcbjtcbmltcG9ydCgvKiB3ZWJwYWNrTW9kZTogXCJlYWdlclwiICovIFwiRDpcXFxcbmV4dFxcXFxvcmdcXFxcbm9kZV9tb2R1bGVzXFxcXG5leHRcXFxcZGlzdFxcXFxjbGllbnRcXFxcY29tcG9uZW50c1xcXFxtZXRhZGF0YVxcXFxhc3luYy1tZXRhZGF0YS5qc1wiKTtcbjtcbmltcG9ydCgvKiB3ZWJwYWNrTW9kZTogXCJlYWdlclwiICovIFwiRDpcXFxcbmV4dFxcXFxvcmdcXFxcbm9kZV9tb2R1bGVzXFxcXG5leHRcXFxcZGlzdFxcXFxjbGllbnRcXFxcY29tcG9uZW50c1xcXFxyZW5kZXItZnJvbS10ZW1wbGF0ZS1jb250ZXh0LmpzXCIpO1xuO1xuaW1wb3J0KC8qIHdlYnBhY2tNb2RlOiBcImVhZ2VyXCIgKi8gXCJEOlxcXFxuZXh0XFxcXG9yZ1xcXFxub2RlX21vZHVsZXNcXFxcbmV4dFxcXFxkaXN0XFxcXGxpYlxcXFxmcmFtZXdvcmtcXFxcYm91bmRhcnktY29tcG9uZW50cy5qc1wiKTtcbjtcbmltcG9ydCgvKiB3ZWJwYWNrTW9kZTogXCJlYWdlclwiICovIFwiRDpcXFxcbmV4dFxcXFxvcmdcXFxcbm9kZV9tb2R1bGVzXFxcXG5leHRcXFxcZGlzdFxcXFxsaWJcXFxcbWV0YWRhdGFcXFxcZ2VuZXJhdGVcXFxcaWNvbi1tYXJrLmpzXCIpO1xuO1xuaW1wb3J0KC8qIHdlYnBhY2tNb2RlOiBcImVhZ2VyXCIgKi8gXCJEOlxcXFxuZXh0XFxcXG9yZ1xcXFxub2RlX21vZHVsZXNcXFxcbmV4dFxcXFxkaXN0XFxcXG5leHQtZGV2dG9vbHNcXFxcdXNlcnNwYWNlXFxcXGFwcFxcXFxzZWdtZW50LWV4cGxvcmVyLW5vZGUuanNcIik7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22D%3A%5C%5Cnext%5C%5Corg%5C%5Cnode_modules%5C%5Cnext%5C%5Cdist%5C%5Cclient%5C%5Ccomponents%5C%5Cbuiltin%5C%5Cglobal-error.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22D%3A%5C%5Cnext%5C%5Corg%5C%5Cnode_modules%5C%5Cnext%5C%5Cdist%5C%5Cclient%5C%5Ccomponents%5C%5Cclient-page.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22D%3A%5C%5Cnext%5C%5Corg%5C%5Cnode_modules%5C%5Cnext%5C%5Cdist%5C%5Cclient%5C%5Ccomponents%5C%5Cclient-segment.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22D%3A%5C%5Cnext%5C%5Corg%5C%5Cnode_modules%5C%5Cnext%5C%5Cdist%5C%5Cclient%5C%5Ccomponents%5C%5Chttp-access-fallback%5C%5Cerror-boundary.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22D%3A%5C%5Cnext%5C%5Corg%5C%5Cnode_modules%5C%5Cnext%5C%5Cdist%5C%5Cclient%5C%5Ccomponents%5C%5Clayout-router.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22D%3A%5C%5Cnext%5C%5Corg%5C%5Cnode_modules%5C%5Cnext%5C%5Cdist%5C%5Cclient%5C%5Ccomponents%5C%5Cmetadata%5C%5Casync-metadata.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22D%3A%5C%5Cnext%5C%5Corg%5C%5Cnode_modules%5C%5Cnext%5C%5Cdist%5C%5Cclient%5C%5Ccomponents%5C%5Crender-from-template-context.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22D%3A%5C%5Cnext%5C%5Corg%5C%5Cnode_modules%5C%5Cnext%5C%5Cdist%5C%5Clib%5C%5Cframework%5C%5Cboundary-components.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22D%3A%5C%5Cnext%5C%5Corg%5C%5Cnode_modules%5C%5Cnext%5C%5Cdist%5C%5Clib%5C%5Cmetadata%5C%5Cgenerate%5C%5Cicon-mark.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22D%3A%5C%5Cnext%5C%5Corg%5C%5Cnode_modules%5C%5Cnext%5C%5Cdist%5C%5Cnext-devtools%5C%5Cuserspace%5C%5Capp%5C%5Csegment-explorer-node.js%22%2C%22ids%22%3A%5B%5D%7D&server=true!\n");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22D%3A%5C%5Cnext%5C%5Corg%5C%5Csrc%5C%5Capp%5C%5Clayout.js%22%2C%22ids%22%3A%5B%5D%7D&server=true!":
/*!************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22D%3A%5C%5Cnext%5C%5Corg%5C%5Csrc%5C%5Capp%5C%5Clayout.js%22%2C%22ids%22%3A%5B%5D%7D&server=true! ***!
  \************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("Promise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./src/app/layout.js */ \"(rsc)/./src/app/layout.js\"));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LWZsaWdodC1jbGllbnQtZW50cnktbG9hZGVyLmpzP21vZHVsZXM9JTdCJTIycmVxdWVzdCUyMiUzQSUyMkQlM0ElNUMlNUNuZXh0JTVDJTVDb3JnJTVDJTVDc3JjJTVDJTVDYXBwJTVDJTVDbGF5b3V0LmpzJTIyJTJDJTIyaWRzJTIyJTNBJTVCJTVEJTdEJnNlcnZlcj10cnVlISIsIm1hcHBpbmdzIjoiQUFBQSxrSkFBdUUiLCJzb3VyY2VzIjpbIiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQoLyogd2VicGFja01vZGU6IFwiZWFnZXJcIiAqLyBcIkQ6XFxcXG5leHRcXFxcb3JnXFxcXHNyY1xcXFxhcHBcXFxcbGF5b3V0LmpzXCIpO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22D%3A%5C%5Cnext%5C%5Corg%5C%5Csrc%5C%5Capp%5C%5Clayout.js%22%2C%22ids%22%3A%5B%5D%7D&server=true!\n");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22D%3A%5C%5Cnext%5C%5Corg%5C%5Csrc%5C%5Ccomponents%5C%5CCommonElements%5C%5CLoader%5C%5Cindex.js%22%2C%22ids%22%3A%5B%22default%22%5D%7D&server=true!":
/*!***************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22D%3A%5C%5Cnext%5C%5Corg%5C%5Csrc%5C%5Ccomponents%5C%5CCommonElements%5C%5CLoader%5C%5Cindex.js%22%2C%22ids%22%3A%5B%22default%22%5D%7D&server=true! ***!
  \***************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("Promise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./src/components/CommonElements/Loader/index.js */ \"(rsc)/./src/components/CommonElements/Loader/index.js\"));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LWZsaWdodC1jbGllbnQtZW50cnktbG9hZGVyLmpzP21vZHVsZXM9JTdCJTIycmVxdWVzdCUyMiUzQSUyMkQlM0ElNUMlNUNuZXh0JTVDJTVDb3JnJTVDJTVDc3JjJTVDJTVDY29tcG9uZW50cyU1QyU1Q0NvbW1vbkVsZW1lbnRzJTVDJTVDTG9hZGVyJTVDJTVDaW5kZXguanMlMjIlMkMlMjJpZHMlMjIlM0ElNUIlMjJkZWZhdWx0JTIyJTVEJTdEJnNlcnZlcj10cnVlISIsIm1hcHBpbmdzIjoiQUFBQSwwTUFBa0kiLCJzb3VyY2VzIjpbIiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQoLyogd2VicGFja01vZGU6IFwiZWFnZXJcIiwgd2VicGFja0V4cG9ydHM6IFtcImRlZmF1bHRcIl0gKi8gXCJEOlxcXFxuZXh0XFxcXG9yZ1xcXFxzcmNcXFxcY29tcG9uZW50c1xcXFxDb21tb25FbGVtZW50c1xcXFxMb2FkZXJcXFxcaW5kZXguanNcIik7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22D%3A%5C%5Cnext%5C%5Corg%5C%5Csrc%5C%5Ccomponents%5C%5CCommonElements%5C%5CLoader%5C%5Cindex.js%22%2C%22ids%22%3A%5B%22default%22%5D%7D&server=true!\n");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22D%3A%5C%5Cnext%5C%5Corg%5C%5Csrc%5C%5Ccomponents%5C%5CPages%5C%5CAuth_Pages%5C%5CSign_In_with_Bg_image%5C%5Cindex.js%22%2C%22ids%22%3A%5B%22default%22%5D%7D&server=true!":
/*!*************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22D%3A%5C%5Cnext%5C%5Corg%5C%5Csrc%5C%5Ccomponents%5C%5CPages%5C%5CAuth_Pages%5C%5CSign_In_with_Bg_image%5C%5Cindex.js%22%2C%22ids%22%3A%5B%22default%22%5D%7D&server=true! ***!
  \*************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("Promise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./src/components/Pages/Auth_Pages/Sign_In_with_Bg_image/index.js */ \"(rsc)/./src/components/Pages/Auth_Pages/Sign_In_with_Bg_image/index.js\"));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LWZsaWdodC1jbGllbnQtZW50cnktbG9hZGVyLmpzP21vZHVsZXM9JTdCJTIycmVxdWVzdCUyMiUzQSUyMkQlM0ElNUMlNUNuZXh0JTVDJTVDb3JnJTVDJTVDc3JjJTVDJTVDY29tcG9uZW50cyU1QyU1Q1BhZ2VzJTVDJTVDQXV0aF9QYWdlcyU1QyU1Q1NpZ25fSW5fd2l0aF9CZ19pbWFnZSU1QyU1Q2luZGV4LmpzJTIyJTJDJTIyaWRzJTIyJTNBJTVCJTIyZGVmYXVsdCUyMiU1RCU3RCZzZXJ2ZXI9dHJ1ZSEiLCJtYXBwaW5ncyI6IkFBQUEsNE9BQW9KIiwic291cmNlcyI6WyIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0KC8qIHdlYnBhY2tNb2RlOiBcImVhZ2VyXCIsIHdlYnBhY2tFeHBvcnRzOiBbXCJkZWZhdWx0XCJdICovIFwiRDpcXFxcbmV4dFxcXFxvcmdcXFxcc3JjXFxcXGNvbXBvbmVudHNcXFxcUGFnZXNcXFxcQXV0aF9QYWdlc1xcXFxTaWduX0luX3dpdGhfQmdfaW1hZ2VcXFxcaW5kZXguanNcIik7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22D%3A%5C%5Cnext%5C%5Corg%5C%5Csrc%5C%5Ccomponents%5C%5CPages%5C%5CAuth_Pages%5C%5CSign_In_with_Bg_image%5C%5Cindex.js%22%2C%22ids%22%3A%5B%22default%22%5D%7D&server=true!\n");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/build/webpack/loaders/next-metadata-image-loader.js?type=favicon&segment=&basePath=&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js!./src/app/favicon.ico?__next_metadata__":
/*!**************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-metadata-image-loader.js?type=favicon&segment=&basePath=&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js!./src/app/favicon.ico?__next_metadata__ ***!
  \**************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var next_dist_lib_metadata_get_metadata_route__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/lib/metadata/get-metadata-route */ \"(rsc)/./node_modules/next/dist/lib/metadata/get-metadata-route.js\");\n/* harmony import */ var next_dist_lib_metadata_get_metadata_route__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_dist_lib_metadata_get_metadata_route__WEBPACK_IMPORTED_MODULE_0__);\n  \n\n  /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (async (props) => {\n    const imageData = {\"type\":\"image/x-icon\",\"sizes\":\"32x32\"}\n    const imageUrl = (0,next_dist_lib_metadata_get_metadata_route__WEBPACK_IMPORTED_MODULE_0__.fillMetadataSegment)(\".\", await props.params, \"favicon.ico\")\n\n    return [{\n      ...imageData,\n      url: imageUrl + \"\",\n    }]\n  });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LW1ldGFkYXRhLWltYWdlLWxvYWRlci5qcz90eXBlPWZhdmljb24mc2VnbWVudD0mYmFzZVBhdGg9JnBhZ2VFeHRlbnNpb25zPXRzeCZwYWdlRXh0ZW5zaW9ucz10cyZwYWdlRXh0ZW5zaW9ucz1qc3gmcGFnZUV4dGVuc2lvbnM9anMhLi9zcmMvYXBwL2Zhdmljb24uaWNvP19fbmV4dF9tZXRhZGF0YV9fIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLEVBQWlGOztBQUVqRixFQUFFLGlFQUFlO0FBQ2pCLHVCQUF1QjtBQUN2QixxQkFBcUIsOEZBQW1COztBQUV4QztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wiLCJzb3VyY2VzIjpbIkQ6XFxuZXh0XFxvcmdcXHNyY1xcYXBwXFxmYXZpY29uLmljbz9fX25leHRfbWV0YWRhdGFfXyJdLCJzb3VyY2VzQ29udGVudCI6WyIgIGltcG9ydCB7IGZpbGxNZXRhZGF0YVNlZ21lbnQgfSBmcm9tICduZXh0L2Rpc3QvbGliL21ldGFkYXRhL2dldC1tZXRhZGF0YS1yb3V0ZSdcblxuICBleHBvcnQgZGVmYXVsdCBhc3luYyAocHJvcHMpID0+IHtcbiAgICBjb25zdCBpbWFnZURhdGEgPSB7XCJ0eXBlXCI6XCJpbWFnZS94LWljb25cIixcInNpemVzXCI6XCIzMngzMlwifVxuICAgIGNvbnN0IGltYWdlVXJsID0gZmlsbE1ldGFkYXRhU2VnbWVudChcIi5cIiwgYXdhaXQgcHJvcHMucGFyYW1zLCBcImZhdmljb24uaWNvXCIpXG5cbiAgICByZXR1cm4gW3tcbiAgICAgIC4uLmltYWdlRGF0YSxcbiAgICAgIHVybDogaW1hZ2VVcmwgKyBcIlwiLFxuICAgIH1dXG4gIH0iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/build/webpack/loaders/next-metadata-image-loader.js?type=favicon&segment=&basePath=&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js!./src/app/favicon.ico?__next_metadata__\n");

/***/ }),

/***/ "(rsc)/./src/app/auth/login/page.js":
/*!************************************!*\
  !*** ./src/app/auth/login/page.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(rsc)/./node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react-jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _components_Pages_Auth_Pages_Sign_In_with_Bg_image__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/components/Pages/Auth_Pages/Sign_In_with_Bg_image */ \"(rsc)/./src/components/Pages/Auth_Pages/Sign_In_with_Bg_image/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"(rsc)/./node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);\n\n\n\nconst page = ()=>{\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_Pages_Auth_Pages_Sign_In_with_Bg_image__WEBPACK_IMPORTED_MODULE_1__[\"default\"], {}, void 0, false, {\n        fileName: \"D:\\\\next\\\\org\\\\src\\\\app\\\\auth\\\\login\\\\page.js\",\n        lineNumber: 6,\n        columnNumber: 9\n    }, undefined);\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (page);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9zcmMvYXBwL2F1dGgvbG9naW4vcGFnZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQXdGO0FBQzlEO0FBRTFCLE1BQU1FLE9BQU87SUFDVCxxQkFDSSw4REFBQ0YsMEZBQXFCQTs7Ozs7QUFFOUI7QUFFQSxpRUFBZUUsSUFBSUEsRUFBQyIsInNvdXJjZXMiOlsiRDpcXG5leHRcXG9yZ1xcc3JjXFxhcHBcXGF1dGhcXGxvZ2luXFxwYWdlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBTaWduX0luX3dpdGhfQmdfaW1hZ2UgZnJvbSAnQC9jb21wb25lbnRzL1BhZ2VzL0F1dGhfUGFnZXMvU2lnbl9Jbl93aXRoX0JnX2ltYWdlJztcclxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcclxuXHJcbmNvbnN0IHBhZ2UgPSAoKSA9PiB7XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxTaWduX0luX3dpdGhfQmdfaW1hZ2UgLz5cclxuICAgICk7XHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBwYWdlOyJdLCJuYW1lcyI6WyJTaWduX0luX3dpdGhfQmdfaW1hZ2UiLCJSZWFjdCIsInBhZ2UiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./src/app/auth/login/page.js\n");

/***/ }),

/***/ "(rsc)/./src/app/layout.js":
/*!***************************!*\
  !*** ./src/app/layout.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react_server_dom_webpack_server__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react-server-dom-webpack/server */ \"(rsc)/./node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react-server-dom-webpack-server.js\");\n/* harmony import */ var react_server_dom_webpack_server__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_server_dom_webpack_server__WEBPACK_IMPORTED_MODULE_0__);\n// This file is generated by the Webpack next-flight-loader.\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,react_server_dom_webpack_server__WEBPACK_IMPORTED_MODULE_0__.registerClientReference)(\nfunction() { throw new Error(\"Attempted to call the default export of \\\"D:\\\\\\\\next\\\\\\\\org\\\\\\\\src\\\\\\\\app\\\\\\\\layout.js\\\" from the server, but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n\"D:\\\\next\\\\org\\\\src\\\\app\\\\layout.js\",\n\"default\",\n));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9zcmMvYXBwL2xheW91dC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSIsInNvdXJjZXMiOlsiX05fRS8uL3NyYy9hcHAvbGF5b3V0LmpzL19fbmV4dGpzLWludGVybmFsLXByb3h5Lm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBUaGlzIGZpbGUgaXMgZ2VuZXJhdGVkIGJ5IHRoZSBXZWJwYWNrIG5leHQtZmxpZ2h0LWxvYWRlci5cbmltcG9ydCB7IHJlZ2lzdGVyQ2xpZW50UmVmZXJlbmNlIH0gZnJvbSBcInJlYWN0LXNlcnZlci1kb20td2VicGFjay9zZXJ2ZXJcIjtcbmV4cG9ydCBkZWZhdWx0IHJlZ2lzdGVyQ2xpZW50UmVmZXJlbmNlKFxuZnVuY3Rpb24oKSB7IHRocm93IG5ldyBFcnJvcihcIkF0dGVtcHRlZCB0byBjYWxsIHRoZSBkZWZhdWx0IGV4cG9ydCBvZiBcXFwiRDpcXFxcXFxcXG5leHRcXFxcXFxcXG9yZ1xcXFxcXFxcc3JjXFxcXFxcXFxhcHBcXFxcXFxcXGxheW91dC5qc1xcXCIgZnJvbSB0aGUgc2VydmVyLCBidXQgaXQncyBvbiB0aGUgY2xpZW50LiBJdCdzIG5vdCBwb3NzaWJsZSB0byBpbnZva2UgYSBjbGllbnQgZnVuY3Rpb24gZnJvbSB0aGUgc2VydmVyLCBpdCBjYW4gb25seSBiZSByZW5kZXJlZCBhcyBhIENvbXBvbmVudCBvciBwYXNzZWQgdG8gcHJvcHMgb2YgYSBDbGllbnQgQ29tcG9uZW50LlwiKTsgfSxcblwiRDpcXFxcbmV4dFxcXFxvcmdcXFxcc3JjXFxcXGFwcFxcXFxsYXlvdXQuanNcIixcblwiZGVmYXVsdFwiLFxuKTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./src/app/layout.js\n");

/***/ }),

/***/ "(rsc)/./src/app/loading.js":
/*!****************************!*\
  !*** ./src/app/loading.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Loading)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(rsc)/./node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react-jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _components_CommonElements_Loader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/components/CommonElements/Loader */ \"(rsc)/./src/components/CommonElements/Loader/index.js\");\n\n\nfunction Loading() {\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_CommonElements_Loader__WEBPACK_IMPORTED_MODULE_1__[\"default\"], {}, void 0, false, {\n        fileName: \"D:\\\\next\\\\org\\\\src\\\\app\\\\loading.js\",\n        lineNumber: 4,\n        columnNumber: 12\n    }, this);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9zcmMvYXBwL2xvYWRpbmcuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBd0Q7QUFFekMsU0FBU0M7SUFDcEIscUJBQU8sOERBQUNELHlFQUFNQTs7Ozs7QUFDaEIiLCJzb3VyY2VzIjpbIkQ6XFxuZXh0XFxvcmdcXHNyY1xcYXBwXFxsb2FkaW5nLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBMb2FkZXIgZnJvbSBcIkAvY29tcG9uZW50cy9Db21tb25FbGVtZW50cy9Mb2FkZXJcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIExvYWRpbmcoKSB7XHJcbiAgICByZXR1cm4gPExvYWRlciAvPlxyXG4gIH0iXSwibmFtZXMiOlsiTG9hZGVyIiwiTG9hZGluZyJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./src/app/loading.js\n");

/***/ }),

/***/ "(rsc)/./src/components/CommonElements/Loader/index.js":
/*!*******************************************************!*\
  !*** ./src/components/CommonElements/Loader/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react_server_dom_webpack_server__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react-server-dom-webpack/server */ \"(rsc)/./node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react-server-dom-webpack-server.js\");\n/* harmony import */ var react_server_dom_webpack_server__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_server_dom_webpack_server__WEBPACK_IMPORTED_MODULE_0__);\n// This file is generated by the Webpack next-flight-loader.\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,react_server_dom_webpack_server__WEBPACK_IMPORTED_MODULE_0__.registerClientReference)(\nfunction() { throw new Error(\"Attempted to call the default export of \\\"D:\\\\\\\\next\\\\\\\\org\\\\\\\\src\\\\\\\\components\\\\\\\\CommonElements\\\\\\\\Loader\\\\\\\\index.js\\\" from the server, but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n\"D:\\\\next\\\\org\\\\src\\\\components\\\\CommonElements\\\\Loader\\\\index.js\",\n\"default\",\n));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9zcmMvY29tcG9uZW50cy9Db21tb25FbGVtZW50cy9Mb2FkZXIvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEiLCJzb3VyY2VzIjpbIl9OX0UvLi9zcmMvY29tcG9uZW50cy9Db21tb25FbGVtZW50cy9Mb2FkZXIvaW5kZXguanMvX19uZXh0anMtaW50ZXJuYWwtcHJveHkubWpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFRoaXMgZmlsZSBpcyBnZW5lcmF0ZWQgYnkgdGhlIFdlYnBhY2sgbmV4dC1mbGlnaHQtbG9hZGVyLlxuaW1wb3J0IHsgcmVnaXN0ZXJDbGllbnRSZWZlcmVuY2UgfSBmcm9tIFwicmVhY3Qtc2VydmVyLWRvbS13ZWJwYWNrL3NlcnZlclwiO1xuZXhwb3J0IGRlZmF1bHQgcmVnaXN0ZXJDbGllbnRSZWZlcmVuY2UoXG5mdW5jdGlvbigpIHsgdGhyb3cgbmV3IEVycm9yKFwiQXR0ZW1wdGVkIHRvIGNhbGwgdGhlIGRlZmF1bHQgZXhwb3J0IG9mIFxcXCJEOlxcXFxcXFxcbmV4dFxcXFxcXFxcb3JnXFxcXFxcXFxzcmNcXFxcXFxcXGNvbXBvbmVudHNcXFxcXFxcXENvbW1vbkVsZW1lbnRzXFxcXFxcXFxMb2FkZXJcXFxcXFxcXGluZGV4LmpzXFxcIiBmcm9tIHRoZSBzZXJ2ZXIsIGJ1dCBpdCdzIG9uIHRoZSBjbGllbnQuIEl0J3Mgbm90IHBvc3NpYmxlIHRvIGludm9rZSBhIGNsaWVudCBmdW5jdGlvbiBmcm9tIHRoZSBzZXJ2ZXIsIGl0IGNhbiBvbmx5IGJlIHJlbmRlcmVkIGFzIGEgQ29tcG9uZW50IG9yIHBhc3NlZCB0byBwcm9wcyBvZiBhIENsaWVudCBDb21wb25lbnQuXCIpOyB9LFxuXCJEOlxcXFxuZXh0XFxcXG9yZ1xcXFxzcmNcXFxcY29tcG9uZW50c1xcXFxDb21tb25FbGVtZW50c1xcXFxMb2FkZXJcXFxcaW5kZXguanNcIixcblwiZGVmYXVsdFwiLFxuKTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./src/components/CommonElements/Loader/index.js\n");

/***/ }),

/***/ "(rsc)/./src/components/Pages/Auth_Pages/Sign_In_with_Bg_image/index.js":
/*!************************************************************************!*\
  !*** ./src/components/Pages/Auth_Pages/Sign_In_with_Bg_image/index.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react_server_dom_webpack_server__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react-server-dom-webpack/server */ \"(rsc)/./node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react-server-dom-webpack-server.js\");\n/* harmony import */ var react_server_dom_webpack_server__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_server_dom_webpack_server__WEBPACK_IMPORTED_MODULE_0__);\n// This file is generated by the Webpack next-flight-loader.\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,react_server_dom_webpack_server__WEBPACK_IMPORTED_MODULE_0__.registerClientReference)(\nfunction() { throw new Error(\"Attempted to call the default export of \\\"D:\\\\\\\\next\\\\\\\\org\\\\\\\\src\\\\\\\\components\\\\\\\\Pages\\\\\\\\Auth_Pages\\\\\\\\Sign_In_with_Bg_image\\\\\\\\index.js\\\" from the server, but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n\"D:\\\\next\\\\org\\\\src\\\\components\\\\Pages\\\\Auth_Pages\\\\Sign_In_with_Bg_image\\\\index.js\",\n\"default\",\n));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9zcmMvY29tcG9uZW50cy9QYWdlcy9BdXRoX1BhZ2VzL1NpZ25fSW5fd2l0aF9CZ19pbWFnZS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSIsInNvdXJjZXMiOlsiX05fRS8uL3NyYy9jb21wb25lbnRzL1BhZ2VzL0F1dGhfUGFnZXMvU2lnbl9Jbl93aXRoX0JnX2ltYWdlL2luZGV4LmpzL19fbmV4dGpzLWludGVybmFsLXByb3h5Lm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBUaGlzIGZpbGUgaXMgZ2VuZXJhdGVkIGJ5IHRoZSBXZWJwYWNrIG5leHQtZmxpZ2h0LWxvYWRlci5cbmltcG9ydCB7IHJlZ2lzdGVyQ2xpZW50UmVmZXJlbmNlIH0gZnJvbSBcInJlYWN0LXNlcnZlci1kb20td2VicGFjay9zZXJ2ZXJcIjtcbmV4cG9ydCBkZWZhdWx0IHJlZ2lzdGVyQ2xpZW50UmVmZXJlbmNlKFxuZnVuY3Rpb24oKSB7IHRocm93IG5ldyBFcnJvcihcIkF0dGVtcHRlZCB0byBjYWxsIHRoZSBkZWZhdWx0IGV4cG9ydCBvZiBcXFwiRDpcXFxcXFxcXG5leHRcXFxcXFxcXG9yZ1xcXFxcXFxcc3JjXFxcXFxcXFxjb21wb25lbnRzXFxcXFxcXFxQYWdlc1xcXFxcXFxcQXV0aF9QYWdlc1xcXFxcXFxcU2lnbl9Jbl93aXRoX0JnX2ltYWdlXFxcXFxcXFxpbmRleC5qc1xcXCIgZnJvbSB0aGUgc2VydmVyLCBidXQgaXQncyBvbiB0aGUgY2xpZW50LiBJdCdzIG5vdCBwb3NzaWJsZSB0byBpbnZva2UgYSBjbGllbnQgZnVuY3Rpb24gZnJvbSB0aGUgc2VydmVyLCBpdCBjYW4gb25seSBiZSByZW5kZXJlZCBhcyBhIENvbXBvbmVudCBvciBwYXNzZWQgdG8gcHJvcHMgb2YgYSBDbGllbnQgQ29tcG9uZW50LlwiKTsgfSxcblwiRDpcXFxcbmV4dFxcXFxvcmdcXFxcc3JjXFxcXGNvbXBvbmVudHNcXFxcUGFnZXNcXFxcQXV0aF9QYWdlc1xcXFxTaWduX0luX3dpdGhfQmdfaW1hZ2VcXFxcaW5kZXguanNcIixcblwiZGVmYXVsdFwiLFxuKTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./src/components/Pages/Auth_Pages/Sign_In_with_Bg_image/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22D%3A%5C%5Cnext%5C%5Corg%5C%5Cnode_modules%5C%5Cnext%5C%5Cdist%5C%5Cclient%5C%5Ccomponents%5C%5Cbuiltin%5C%5Cglobal-error.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22D%3A%5C%5Cnext%5C%5Corg%5C%5Cnode_modules%5C%5Cnext%5C%5Cdist%5C%5Cclient%5C%5Ccomponents%5C%5Cclient-page.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22D%3A%5C%5Cnext%5C%5Corg%5C%5Cnode_modules%5C%5Cnext%5C%5Cdist%5C%5Cclient%5C%5Ccomponents%5C%5Cclient-segment.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22D%3A%5C%5Cnext%5C%5Corg%5C%5Cnode_modules%5C%5Cnext%5C%5Cdist%5C%5Cclient%5C%5Ccomponents%5C%5Chttp-access-fallback%5C%5Cerror-boundary.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22D%3A%5C%5Cnext%5C%5Corg%5C%5Cnode_modules%5C%5Cnext%5C%5Cdist%5C%5Cclient%5C%5Ccomponents%5C%5Clayout-router.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22D%3A%5C%5Cnext%5C%5Corg%5C%5Cnode_modules%5C%5Cnext%5C%5Cdist%5C%5Cclient%5C%5Ccomponents%5C%5Cmetadata%5C%5Casync-metadata.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22D%3A%5C%5Cnext%5C%5Corg%5C%5Cnode_modules%5C%5Cnext%5C%5Cdist%5C%5Cclient%5C%5Ccomponents%5C%5Crender-from-template-context.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22D%3A%5C%5Cnext%5C%5Corg%5C%5Cnode_modules%5C%5Cnext%5C%5Cdist%5C%5Clib%5C%5Cframework%5C%5Cboundary-components.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22D%3A%5C%5Cnext%5C%5Corg%5C%5Cnode_modules%5C%5Cnext%5C%5Cdist%5C%5Clib%5C%5Cmetadata%5C%5Cgenerate%5C%5Cicon-mark.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22D%3A%5C%5Cnext%5C%5Corg%5C%5Cnode_modules%5C%5Cnext%5C%5Cdist%5C%5Cnext-devtools%5C%5Cuserspace%5C%5Capp%5C%5Csegment-explorer-node.js%22%2C%22ids%22%3A%5B%5D%7D&server=true!":
/*!******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22D%3A%5C%5Cnext%5C%5Corg%5C%5Cnode_modules%5C%5Cnext%5C%5Cdist%5C%5Cclient%5C%5Ccomponents%5C%5Cbuiltin%5C%5Cglobal-error.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22D%3A%5C%5Cnext%5C%5Corg%5C%5Cnode_modules%5C%5Cnext%5C%5Cdist%5C%5Cclient%5C%5Ccomponents%5C%5Cclient-page.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22D%3A%5C%5Cnext%5C%5Corg%5C%5Cnode_modules%5C%5Cnext%5C%5Cdist%5C%5Cclient%5C%5Ccomponents%5C%5Cclient-segment.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22D%3A%5C%5Cnext%5C%5Corg%5C%5Cnode_modules%5C%5Cnext%5C%5Cdist%5C%5Cclient%5C%5Ccomponents%5C%5Chttp-access-fallback%5C%5Cerror-boundary.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22D%3A%5C%5Cnext%5C%5Corg%5C%5Cnode_modules%5C%5Cnext%5C%5Cdist%5C%5Cclient%5C%5Ccomponents%5C%5Clayout-router.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22D%3A%5C%5Cnext%5C%5Corg%5C%5Cnode_modules%5C%5Cnext%5C%5Cdist%5C%5Cclient%5C%5Ccomponents%5C%5Cmetadata%5C%5Casync-metadata.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22D%3A%5C%5Cnext%5C%5Corg%5C%5Cnode_modules%5C%5Cnext%5C%5Cdist%5C%5Cclient%5C%5Ccomponents%5C%5Crender-from-template-context.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22D%3A%5C%5Cnext%5C%5Corg%5C%5Cnode_modules%5C%5Cnext%5C%5Cdist%5C%5Clib%5C%5Cframework%5C%5Cboundary-components.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22D%3A%5C%5Cnext%5C%5Corg%5C%5Cnode_modules%5C%5Cnext%5C%5Cdist%5C%5Clib%5C%5Cmetadata%5C%5Cgenerate%5C%5Cicon-mark.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22D%3A%5C%5Cnext%5C%5Corg%5C%5Cnode_modules%5C%5Cnext%5C%5Cdist%5C%5Cnext-devtools%5C%5Cuserspace%5C%5Capp%5C%5Csegment-explorer-node.js%22%2C%22ids%22%3A%5B%5D%7D&server=true! ***!
  \******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("Promise.resolve(/*! import() eager */).then(__webpack_require__.t.bind(__webpack_require__, /*! ./node_modules/next/dist/client/components/builtin/global-error.js */ \"(ssr)/./node_modules/next/dist/client/components/builtin/global-error.js\", 23));\n;\nPromise.resolve(/*! import() eager */).then(__webpack_require__.t.bind(__webpack_require__, /*! ./node_modules/next/dist/client/components/client-page.js */ \"(ssr)/./node_modules/next/dist/client/components/client-page.js\", 23));\n;\nPromise.resolve(/*! import() eager */).then(__webpack_require__.t.bind(__webpack_require__, /*! ./node_modules/next/dist/client/components/client-segment.js */ \"(ssr)/./node_modules/next/dist/client/components/client-segment.js\", 23));\n;\nPromise.resolve(/*! import() eager */).then(__webpack_require__.t.bind(__webpack_require__, /*! ./node_modules/next/dist/client/components/http-access-fallback/error-boundary.js */ \"(ssr)/./node_modules/next/dist/client/components/http-access-fallback/error-boundary.js\", 23));\n;\nPromise.resolve(/*! import() eager */).then(__webpack_require__.t.bind(__webpack_require__, /*! ./node_modules/next/dist/client/components/layout-router.js */ \"(ssr)/./node_modules/next/dist/client/components/layout-router.js\", 23));\n;\nPromise.resolve(/*! import() eager */).then(__webpack_require__.t.bind(__webpack_require__, /*! ./node_modules/next/dist/client/components/metadata/async-metadata.js */ \"(ssr)/./node_modules/next/dist/client/components/metadata/async-metadata.js\", 23));\n;\nPromise.resolve(/*! import() eager */).then(__webpack_require__.t.bind(__webpack_require__, /*! ./node_modules/next/dist/client/components/render-from-template-context.js */ \"(ssr)/./node_modules/next/dist/client/components/render-from-template-context.js\", 23));\n;\nPromise.resolve(/*! import() eager */).then(__webpack_require__.t.bind(__webpack_require__, /*! ./node_modules/next/dist/lib/framework/boundary-components.js */ \"(ssr)/./node_modules/next/dist/lib/framework/boundary-components.js\", 23));\n;\nPromise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./node_modules/next/dist/lib/metadata/generate/icon-mark.js */ \"(ssr)/./node_modules/next/dist/lib/metadata/generate/icon-mark.js\"));\n;\nPromise.resolve(/*! import() eager */).then(__webpack_require__.t.bind(__webpack_require__, /*! ./node_modules/next/dist/next-devtools/userspace/app/segment-explorer-node.js */ \"(ssr)/./node_modules/next/dist/next-devtools/userspace/app/segment-explorer-node.js\", 23));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LWZsaWdodC1jbGllbnQtZW50cnktbG9hZGVyLmpzP21vZHVsZXM9JTdCJTIycmVxdWVzdCUyMiUzQSUyMkQlM0ElNUMlNUNuZXh0JTVDJTVDb3JnJTVDJTVDbm9kZV9tb2R1bGVzJTVDJTVDbmV4dCU1QyU1Q2Rpc3QlNUMlNUNjbGllbnQlNUMlNUNjb21wb25lbnRzJTVDJTVDYnVpbHRpbiU1QyU1Q2dsb2JhbC1lcnJvci5qcyUyMiUyQyUyMmlkcyUyMiUzQSU1QiU1RCU3RCZtb2R1bGVzPSU3QiUyMnJlcXVlc3QlMjIlM0ElMjJEJTNBJTVDJTVDbmV4dCU1QyU1Q29yZyU1QyU1Q25vZGVfbW9kdWxlcyU1QyU1Q25leHQlNUMlNUNkaXN0JTVDJTVDY2xpZW50JTVDJTVDY29tcG9uZW50cyU1QyU1Q2NsaWVudC1wYWdlLmpzJTIyJTJDJTIyaWRzJTIyJTNBJTVCJTVEJTdEJm1vZHVsZXM9JTdCJTIycmVxdWVzdCUyMiUzQSUyMkQlM0ElNUMlNUNuZXh0JTVDJTVDb3JnJTVDJTVDbm9kZV9tb2R1bGVzJTVDJTVDbmV4dCU1QyU1Q2Rpc3QlNUMlNUNjbGllbnQlNUMlNUNjb21wb25lbnRzJTVDJTVDY2xpZW50LXNlZ21lbnQuanMlMjIlMkMlMjJpZHMlMjIlM0ElNUIlNUQlN0QmbW9kdWxlcz0lN0IlMjJyZXF1ZXN0JTIyJTNBJTIyRCUzQSU1QyU1Q25leHQlNUMlNUNvcmclNUMlNUNub2RlX21vZHVsZXMlNUMlNUNuZXh0JTVDJTVDZGlzdCU1QyU1Q2NsaWVudCU1QyU1Q2NvbXBvbmVudHMlNUMlNUNodHRwLWFjY2Vzcy1mYWxsYmFjayU1QyU1Q2Vycm9yLWJvdW5kYXJ5LmpzJTIyJTJDJTIyaWRzJTIyJTNBJTVCJTVEJTdEJm1vZHVsZXM9JTdCJTIycmVxdWVzdCUyMiUzQSUyMkQlM0ElNUMlNUNuZXh0JTVDJTVDb3JnJTVDJTVDbm9kZV9tb2R1bGVzJTVDJTVDbmV4dCU1QyU1Q2Rpc3QlNUMlNUNjbGllbnQlNUMlNUNjb21wb25lbnRzJTVDJTVDbGF5b3V0LXJvdXRlci5qcyUyMiUyQyUyMmlkcyUyMiUzQSU1QiU1RCU3RCZtb2R1bGVzPSU3QiUyMnJlcXVlc3QlMjIlM0ElMjJEJTNBJTVDJTVDbmV4dCU1QyU1Q29yZyU1QyU1Q25vZGVfbW9kdWxlcyU1QyU1Q25leHQlNUMlNUNkaXN0JTVDJTVDY2xpZW50JTVDJTVDY29tcG9uZW50cyU1QyU1Q21ldGFkYXRhJTVDJTVDYXN5bmMtbWV0YWRhdGEuanMlMjIlMkMlMjJpZHMlMjIlM0ElNUIlNUQlN0QmbW9kdWxlcz0lN0IlMjJyZXF1ZXN0JTIyJTNBJTIyRCUzQSU1QyU1Q25leHQlNUMlNUNvcmclNUMlNUNub2RlX21vZHVsZXMlNUMlNUNuZXh0JTVDJTVDZGlzdCU1QyU1Q2NsaWVudCU1QyU1Q2NvbXBvbmVudHMlNUMlNUNyZW5kZXItZnJvbS10ZW1wbGF0ZS1jb250ZXh0LmpzJTIyJTJDJTIyaWRzJTIyJTNBJTVCJTVEJTdEJm1vZHVsZXM9JTdCJTIycmVxdWVzdCUyMiUzQSUyMkQlM0ElNUMlNUNuZXh0JTVDJTVDb3JnJTVDJTVDbm9kZV9tb2R1bGVzJTVDJTVDbmV4dCU1QyU1Q2Rpc3QlNUMlNUNsaWIlNUMlNUNmcmFtZXdvcmslNUMlNUNib3VuZGFyeS1jb21wb25lbnRzLmpzJTIyJTJDJTIyaWRzJTIyJTNBJTVCJTVEJTdEJm1vZHVsZXM9JTdCJTIycmVxdWVzdCUyMiUzQSUyMkQlM0ElNUMlNUNuZXh0JTVDJTVDb3JnJTVDJTVDbm9kZV9tb2R1bGVzJTVDJTVDbmV4dCU1QyU1Q2Rpc3QlNUMlNUNsaWIlNUMlNUNtZXRhZGF0YSU1QyU1Q2dlbmVyYXRlJTVDJTVDaWNvbi1tYXJrLmpzJTIyJTJDJTIyaWRzJTIyJTNBJTVCJTVEJTdEJm1vZHVsZXM9JTdCJTIycmVxdWVzdCUyMiUzQSUyMkQlM0ElNUMlNUNuZXh0JTVDJTVDb3JnJTVDJTVDbm9kZV9tb2R1bGVzJTVDJTVDbmV4dCU1QyU1Q2Rpc3QlNUMlNUNuZXh0LWRldnRvb2xzJTVDJTVDdXNlcnNwYWNlJTVDJTVDYXBwJTVDJTVDc2VnbWVudC1leHBsb3Jlci1ub2RlLmpzJTIyJTJDJTIyaWRzJTIyJTNBJTVCJTVEJTdEJnNlcnZlcj10cnVlISIsIm1hcHBpbmdzIjoiQUFBQSxzUEFBMEg7QUFDMUg7QUFDQSxvT0FBZ0g7QUFDaEg7QUFDQSwwT0FBbUg7QUFDbkg7QUFDQSxvUkFBeUk7QUFDekk7QUFDQSx3T0FBa0g7QUFDbEg7QUFDQSw0UEFBNkg7QUFDN0g7QUFDQSxzUUFBaUk7QUFDakk7QUFDQSw0T0FBb0g7QUFDcEg7QUFDQSxrT0FBbUg7QUFDbkg7QUFDQSw0UUFBcUkiLCJzb3VyY2VzIjpbIiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQoLyogd2VicGFja01vZGU6IFwiZWFnZXJcIiAqLyBcIkQ6XFxcXG5leHRcXFxcb3JnXFxcXG5vZGVfbW9kdWxlc1xcXFxuZXh0XFxcXGRpc3RcXFxcY2xpZW50XFxcXGNvbXBvbmVudHNcXFxcYnVpbHRpblxcXFxnbG9iYWwtZXJyb3IuanNcIik7XG47XG5pbXBvcnQoLyogd2VicGFja01vZGU6IFwiZWFnZXJcIiAqLyBcIkQ6XFxcXG5leHRcXFxcb3JnXFxcXG5vZGVfbW9kdWxlc1xcXFxuZXh0XFxcXGRpc3RcXFxcY2xpZW50XFxcXGNvbXBvbmVudHNcXFxcY2xpZW50LXBhZ2UuanNcIik7XG47XG5pbXBvcnQoLyogd2VicGFja01vZGU6IFwiZWFnZXJcIiAqLyBcIkQ6XFxcXG5leHRcXFxcb3JnXFxcXG5vZGVfbW9kdWxlc1xcXFxuZXh0XFxcXGRpc3RcXFxcY2xpZW50XFxcXGNvbXBvbmVudHNcXFxcY2xpZW50LXNlZ21lbnQuanNcIik7XG47XG5pbXBvcnQoLyogd2VicGFja01vZGU6IFwiZWFnZXJcIiAqLyBcIkQ6XFxcXG5leHRcXFxcb3JnXFxcXG5vZGVfbW9kdWxlc1xcXFxuZXh0XFxcXGRpc3RcXFxcY2xpZW50XFxcXGNvbXBvbmVudHNcXFxcaHR0cC1hY2Nlc3MtZmFsbGJhY2tcXFxcZXJyb3ItYm91bmRhcnkuanNcIik7XG47XG5pbXBvcnQoLyogd2VicGFja01vZGU6IFwiZWFnZXJcIiAqLyBcIkQ6XFxcXG5leHRcXFxcb3JnXFxcXG5vZGVfbW9kdWxlc1xcXFxuZXh0XFxcXGRpc3RcXFxcY2xpZW50XFxcXGNvbXBvbmVudHNcXFxcbGF5b3V0LXJvdXRlci5qc1wiKTtcbjtcbmltcG9ydCgvKiB3ZWJwYWNrTW9kZTogXCJlYWdlclwiICovIFwiRDpcXFxcbmV4dFxcXFxvcmdcXFxcbm9kZV9tb2R1bGVzXFxcXG5leHRcXFxcZGlzdFxcXFxjbGllbnRcXFxcY29tcG9uZW50c1xcXFxtZXRhZGF0YVxcXFxhc3luYy1tZXRhZGF0YS5qc1wiKTtcbjtcbmltcG9ydCgvKiB3ZWJwYWNrTW9kZTogXCJlYWdlclwiICovIFwiRDpcXFxcbmV4dFxcXFxvcmdcXFxcbm9kZV9tb2R1bGVzXFxcXG5leHRcXFxcZGlzdFxcXFxjbGllbnRcXFxcY29tcG9uZW50c1xcXFxyZW5kZXItZnJvbS10ZW1wbGF0ZS1jb250ZXh0LmpzXCIpO1xuO1xuaW1wb3J0KC8qIHdlYnBhY2tNb2RlOiBcImVhZ2VyXCIgKi8gXCJEOlxcXFxuZXh0XFxcXG9yZ1xcXFxub2RlX21vZHVsZXNcXFxcbmV4dFxcXFxkaXN0XFxcXGxpYlxcXFxmcmFtZXdvcmtcXFxcYm91bmRhcnktY29tcG9uZW50cy5qc1wiKTtcbjtcbmltcG9ydCgvKiB3ZWJwYWNrTW9kZTogXCJlYWdlclwiICovIFwiRDpcXFxcbmV4dFxcXFxvcmdcXFxcbm9kZV9tb2R1bGVzXFxcXG5leHRcXFxcZGlzdFxcXFxsaWJcXFxcbWV0YWRhdGFcXFxcZ2VuZXJhdGVcXFxcaWNvbi1tYXJrLmpzXCIpO1xuO1xuaW1wb3J0KC8qIHdlYnBhY2tNb2RlOiBcImVhZ2VyXCIgKi8gXCJEOlxcXFxuZXh0XFxcXG9yZ1xcXFxub2RlX21vZHVsZXNcXFxcbmV4dFxcXFxkaXN0XFxcXG5leHQtZGV2dG9vbHNcXFxcdXNlcnNwYWNlXFxcXGFwcFxcXFxzZWdtZW50LWV4cGxvcmVyLW5vZGUuanNcIik7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22D%3A%5C%5Cnext%5C%5Corg%5C%5Cnode_modules%5C%5Cnext%5C%5Cdist%5C%5Cclient%5C%5Ccomponents%5C%5Cbuiltin%5C%5Cglobal-error.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22D%3A%5C%5Cnext%5C%5Corg%5C%5Cnode_modules%5C%5Cnext%5C%5Cdist%5C%5Cclient%5C%5Ccomponents%5C%5Cclient-page.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22D%3A%5C%5Cnext%5C%5Corg%5C%5Cnode_modules%5C%5Cnext%5C%5Cdist%5C%5Cclient%5C%5Ccomponents%5C%5Cclient-segment.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22D%3A%5C%5Cnext%5C%5Corg%5C%5Cnode_modules%5C%5Cnext%5C%5Cdist%5C%5Cclient%5C%5Ccomponents%5C%5Chttp-access-fallback%5C%5Cerror-boundary.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22D%3A%5C%5Cnext%5C%5Corg%5C%5Cnode_modules%5C%5Cnext%5C%5Cdist%5C%5Cclient%5C%5Ccomponents%5C%5Clayout-router.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22D%3A%5C%5Cnext%5C%5Corg%5C%5Cnode_modules%5C%5Cnext%5C%5Cdist%5C%5Cclient%5C%5Ccomponents%5C%5Cmetadata%5C%5Casync-metadata.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22D%3A%5C%5Cnext%5C%5Corg%5C%5Cnode_modules%5C%5Cnext%5C%5Cdist%5C%5Cclient%5C%5Ccomponents%5C%5Crender-from-template-context.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22D%3A%5C%5Cnext%5C%5Corg%5C%5Cnode_modules%5C%5Cnext%5C%5Cdist%5C%5Clib%5C%5Cframework%5C%5Cboundary-components.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22D%3A%5C%5Cnext%5C%5Corg%5C%5Cnode_modules%5C%5Cnext%5C%5Cdist%5C%5Clib%5C%5Cmetadata%5C%5Cgenerate%5C%5Cicon-mark.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22D%3A%5C%5Cnext%5C%5Corg%5C%5Cnode_modules%5C%5Cnext%5C%5Cdist%5C%5Cnext-devtools%5C%5Cuserspace%5C%5Capp%5C%5Csegment-explorer-node.js%22%2C%22ids%22%3A%5B%5D%7D&server=true!\n");

/***/ }),

/***/ "(ssr)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22D%3A%5C%5Cnext%5C%5Corg%5C%5Csrc%5C%5Capp%5C%5Clayout.js%22%2C%22ids%22%3A%5B%5D%7D&server=true!":
/*!************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22D%3A%5C%5Cnext%5C%5Corg%5C%5Csrc%5C%5Capp%5C%5Clayout.js%22%2C%22ids%22%3A%5B%5D%7D&server=true! ***!
  \************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("Promise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./src/app/layout.js */ \"(ssr)/./src/app/layout.js\"));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LWZsaWdodC1jbGllbnQtZW50cnktbG9hZGVyLmpzP21vZHVsZXM9JTdCJTIycmVxdWVzdCUyMiUzQSUyMkQlM0ElNUMlNUNuZXh0JTVDJTVDb3JnJTVDJTVDc3JjJTVDJTVDYXBwJTVDJTVDbGF5b3V0LmpzJTIyJTJDJTIyaWRzJTIyJTNBJTVCJTVEJTdEJnNlcnZlcj10cnVlISIsIm1hcHBpbmdzIjoiQUFBQSxrSkFBdUUiLCJzb3VyY2VzIjpbIiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQoLyogd2VicGFja01vZGU6IFwiZWFnZXJcIiAqLyBcIkQ6XFxcXG5leHRcXFxcb3JnXFxcXHNyY1xcXFxhcHBcXFxcbGF5b3V0LmpzXCIpO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22D%3A%5C%5Cnext%5C%5Corg%5C%5Csrc%5C%5Capp%5C%5Clayout.js%22%2C%22ids%22%3A%5B%5D%7D&server=true!\n");

/***/ }),

/***/ "(ssr)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22D%3A%5C%5Cnext%5C%5Corg%5C%5Csrc%5C%5Ccomponents%5C%5CCommonElements%5C%5CLoader%5C%5Cindex.js%22%2C%22ids%22%3A%5B%22default%22%5D%7D&server=true!":
/*!***************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22D%3A%5C%5Cnext%5C%5Corg%5C%5Csrc%5C%5Ccomponents%5C%5CCommonElements%5C%5CLoader%5C%5Cindex.js%22%2C%22ids%22%3A%5B%22default%22%5D%7D&server=true! ***!
  \***************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("Promise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./src/components/CommonElements/Loader/index.js */ \"(ssr)/./src/components/CommonElements/Loader/index.js\"));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LWZsaWdodC1jbGllbnQtZW50cnktbG9hZGVyLmpzP21vZHVsZXM9JTdCJTIycmVxdWVzdCUyMiUzQSUyMkQlM0ElNUMlNUNuZXh0JTVDJTVDb3JnJTVDJTVDc3JjJTVDJTVDY29tcG9uZW50cyU1QyU1Q0NvbW1vbkVsZW1lbnRzJTVDJTVDTG9hZGVyJTVDJTVDaW5kZXguanMlMjIlMkMlMjJpZHMlMjIlM0ElNUIlMjJkZWZhdWx0JTIyJTVEJTdEJnNlcnZlcj10cnVlISIsIm1hcHBpbmdzIjoiQUFBQSwwTUFBa0kiLCJzb3VyY2VzIjpbIiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQoLyogd2VicGFja01vZGU6IFwiZWFnZXJcIiwgd2VicGFja0V4cG9ydHM6IFtcImRlZmF1bHRcIl0gKi8gXCJEOlxcXFxuZXh0XFxcXG9yZ1xcXFxzcmNcXFxcY29tcG9uZW50c1xcXFxDb21tb25FbGVtZW50c1xcXFxMb2FkZXJcXFxcaW5kZXguanNcIik7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22D%3A%5C%5Cnext%5C%5Corg%5C%5Csrc%5C%5Ccomponents%5C%5CCommonElements%5C%5CLoader%5C%5Cindex.js%22%2C%22ids%22%3A%5B%22default%22%5D%7D&server=true!\n");

/***/ }),

/***/ "(ssr)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22D%3A%5C%5Cnext%5C%5Corg%5C%5Csrc%5C%5Ccomponents%5C%5CPages%5C%5CAuth_Pages%5C%5CSign_In_with_Bg_image%5C%5Cindex.js%22%2C%22ids%22%3A%5B%22default%22%5D%7D&server=true!":
/*!*************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22D%3A%5C%5Cnext%5C%5Corg%5C%5Csrc%5C%5Ccomponents%5C%5CPages%5C%5CAuth_Pages%5C%5CSign_In_with_Bg_image%5C%5Cindex.js%22%2C%22ids%22%3A%5B%22default%22%5D%7D&server=true! ***!
  \*************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("Promise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./src/components/Pages/Auth_Pages/Sign_In_with_Bg_image/index.js */ \"(ssr)/./src/components/Pages/Auth_Pages/Sign_In_with_Bg_image/index.js\"));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LWZsaWdodC1jbGllbnQtZW50cnktbG9hZGVyLmpzP21vZHVsZXM9JTdCJTIycmVxdWVzdCUyMiUzQSUyMkQlM0ElNUMlNUNuZXh0JTVDJTVDb3JnJTVDJTVDc3JjJTVDJTVDY29tcG9uZW50cyU1QyU1Q1BhZ2VzJTVDJTVDQXV0aF9QYWdlcyU1QyU1Q1NpZ25fSW5fd2l0aF9CZ19pbWFnZSU1QyU1Q2luZGV4LmpzJTIyJTJDJTIyaWRzJTIyJTNBJTVCJTIyZGVmYXVsdCUyMiU1RCU3RCZzZXJ2ZXI9dHJ1ZSEiLCJtYXBwaW5ncyI6IkFBQUEsNE9BQW9KIiwic291cmNlcyI6WyIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0KC8qIHdlYnBhY2tNb2RlOiBcImVhZ2VyXCIsIHdlYnBhY2tFeHBvcnRzOiBbXCJkZWZhdWx0XCJdICovIFwiRDpcXFxcbmV4dFxcXFxvcmdcXFxcc3JjXFxcXGNvbXBvbmVudHNcXFxcUGFnZXNcXFxcQXV0aF9QYWdlc1xcXFxTaWduX0luX3dpdGhfQmdfaW1hZ2VcXFxcaW5kZXguanNcIik7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22D%3A%5C%5Cnext%5C%5Corg%5C%5Csrc%5C%5Ccomponents%5C%5CPages%5C%5CAuth_Pages%5C%5CSign_In_with_Bg_image%5C%5Cindex.js%22%2C%22ids%22%3A%5B%22default%22%5D%7D&server=true!\n");

/***/ }),

/***/ "(ssr)/./src/app/globle.css":
/*!****************************!*\
  !*** ./src/app/globle.css ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"82502ebdba5a\");\nif (false) {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9zcmMvYXBwL2dsb2JsZS5jc3MiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLGlFQUFlLGNBQWM7QUFDN0IsSUFBSSxLQUFVLEVBQUUsRUFBdUIiLCJzb3VyY2VzIjpbIkQ6XFxuZXh0XFxvcmdcXHNyY1xcYXBwXFxnbG9ibGUuY3NzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IFwiODI1MDJlYmRiYTVhXCJcbmlmIChtb2R1bGUuaG90KSB7IG1vZHVsZS5ob3QuYWNjZXB0KCkgfVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./src/app/globle.css\n");

/***/ }),

/***/ "(ssr)/./src/app/layout.js":
/*!***************************!*\
  !*** ./src/app/layout.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ RootLayout)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _utils_Bootstrap_BootstrapClient__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/utils/Bootstrap/BootstrapClient */ \"(ssr)/./src/utils/Bootstrap/BootstrapClient.js\");\n/* harmony import */ var next_head__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/head */ \"(ssr)/./node_modules/next/dist/client/components/noop-head.js\");\n/* harmony import */ var next_head__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_head__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _context_AuthContext__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/context/AuthContext */ \"(ssr)/./src/context/AuthContext.js\");\n/* harmony import */ var _vendor_trumbowyg_trumbowyg_min_css__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../vendor/trumbowyg/trumbowyg.min.css */ \"(ssr)/./src/vendor/trumbowyg/trumbowyg.min.css\");\n/* harmony import */ var filepond_dist_filepond_min_css__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! filepond/dist/filepond.min.css */ \"(ssr)/./node_modules/filepond/dist/filepond.min.css\");\n/* harmony import */ var _vendor_fontawesome_css_all_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../vendor/fontawesome/css/all.css */ \"(ssr)/./src/vendor/fontawesome/css/all.css\");\n/* harmony import */ var _vendor_datatable_datatable2_buttons_dataTables_min_css__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../vendor/datatable/datatable2/buttons.dataTables.min.css */ \"(ssr)/./src/vendor/datatable/datatable2/buttons.dataTables.min.css\");\n/* harmony import */ var _vendor_prism_prism_min_css__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../vendor/prism/prism.min.css */ \"(ssr)/./src/vendor/prism/prism.min.css\");\n/* harmony import */ var slick_carousel_slick_slick_css__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! slick-carousel/slick/slick.css */ \"(ssr)/./node_modules/slick-carousel/slick/slick.css\");\n/* harmony import */ var slick_carousel_slick_slick_theme_css__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! slick-carousel/slick/slick-theme.css */ \"(ssr)/./node_modules/slick-carousel/slick/slick-theme.css\");\n/* harmony import */ var _vendor_animation_animate_min_css__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../vendor/animation/animate.min.css */ \"(ssr)/./src/vendor/animation/animate.min.css\");\n/* harmony import */ var _vendor_datatable_jquery_dataTables_min_css__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../vendor/datatable/jquery.dataTables.min.css */ \"(ssr)/./src/vendor/datatable/jquery.dataTables.min.css\");\n/* harmony import */ var _vendor_weather_weather_icons_css__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../vendor/weather/weather-icons.css */ \"(ssr)/./src/vendor/weather/weather-icons.css\");\n/* harmony import */ var _vendor_animated_icon_mdi_light_css__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../vendor/animated_icon/mdi-light.css */ \"(ssr)/./src/vendor/animated_icon/mdi-light.css\");\n/* harmony import */ var _vendor_ionio_icon_css_iconoir_css__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../vendor/ionio-icon/css/iconoir.css */ \"(ssr)/./src/vendor/ionio-icon/css/iconoir.css\");\n/* harmony import */ var _vendor_leafletmaps_leaflet_css__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../vendor/leafletmaps/leaflet.css */ \"(ssr)/./src/vendor/leafletmaps/leaflet.css\");\n/* harmony import */ var _vendor_vector_map_jquery_jvectormap_css__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../vendor/vector-map/jquery-jvectormap.css */ \"(ssr)/./src/vendor/vector-map/jquery-jvectormap.css\");\n/* harmony import */ var _vendor_shepherdjs_shepherd_css__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../vendor/shepherdjs/shepherd.css */ \"(ssr)/./src/vendor/shepherdjs/shepherd.css\");\n/* harmony import */ var _vendor_jstree_style_min_css__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ../vendor/jstree/style.min.css */ \"(ssr)/./src/vendor/jstree/style.min.css\");\n/* harmony import */ var _vendor_dual_listboxes_dual_listbox_css__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ../vendor/dual_listboxes/dual-listbox.css */ \"(ssr)/./src/vendor/dual_listboxes/dual-listbox.css\");\n/* harmony import */ var _vendor_fullcalendar_global_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ../vendor/fullcalendar/global.js */ \"(ssr)/./src/vendor/fullcalendar/global.js\");\n/* harmony import */ var _vendor_fullcalendar_global_js__WEBPACK_IMPORTED_MODULE_21___default = /*#__PURE__*/__webpack_require__.n(_vendor_fullcalendar_global_js__WEBPACK_IMPORTED_MODULE_21__);\n/* harmony import */ var _vendor_slick_slick_css__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ../vendor/slick/slick.css */ \"(ssr)/./src/vendor/slick/slick.css\");\n/* harmony import */ var _vendor_datepikar_flatpickr_min_css__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ../vendor/datepikar/flatpickr.min.css */ \"(ssr)/./src/vendor/datepikar/flatpickr.min.css\");\n/* harmony import */ var filepond_plugin_image_preview_dist_filepond_plugin_image_preview_css__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! filepond-plugin-image-preview/dist/filepond-plugin-image-preview.css */ \"(ssr)/./node_modules/filepond-plugin-image-preview/dist/filepond-plugin-image-preview.css\");\n/* harmony import */ var _vendor_tabler_icons_tabler_icons_css__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ../vendor/tabler-icons/tabler-icons.css */ \"(ssr)/./src/vendor/tabler-icons/tabler-icons.css\");\n/* harmony import */ var _vendor_phosphor_phosphor_light_css__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ../vendor/phosphor/phosphor-light.css */ \"(ssr)/./src/vendor/phosphor/phosphor-light.css\");\n/* harmony import */ var _vendor_flag_icons_master_flag_icon_css__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ../vendor/flag-icons-master/flag-icon.css */ \"(ssr)/./src/vendor/flag-icons-master/flag-icon.css\");\n/* harmony import */ var _vendor_nouislider_nouislider_min_css__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ../vendor/nouislider/nouislider.min.css */ \"(ssr)/./src/vendor/nouislider/nouislider.min.css\");\n/* harmony import */ var simplebar_react_dist_simplebar_min_css__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! simplebar-react/dist/simplebar.min.css */ \"(ssr)/./node_modules/simplebar-react/dist/simplebar.min.css\");\n/* harmony import */ var bootstrap_dist_css_bootstrap_min_css__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! bootstrap/dist/css/bootstrap.min.css */ \"(ssr)/./node_modules/bootstrap/dist/css/bootstrap.min.css\");\n/* harmony import */ var _vendor_select_select2_min_css__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ../vendor/select/select2.min.css */ \"(ssr)/./src/vendor/select/select2.min.css\");\n/* harmony import */ var _scss_style_scss__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ../scss/style.scss */ \"(ssr)/./src/scss/style.scss\");\n/* harmony import */ var _scss_responsive_scss__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ../scss/responsive.scss */ \"(ssr)/./src/scss/responsive.scss\");\n/* harmony import */ var _globle_css__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ./globle.css */ \"(ssr)/./src/app/globle.css\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \n\n\n //  import context\n// CSS imports\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction RootLayout({ children }) {\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"html\", {\n        lang: \"en\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((next_head__WEBPACK_IMPORTED_MODULE_2___default()), {\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"link\", {\n                        rel: \"preconnect\",\n                        href: \"https://fonts.googleapis.com\"\n                    }, void 0, false, {\n                        fileName: \"D:\\\\next\\\\org\\\\src\\\\app\\\\layout.js\",\n                        lineNumber: 44,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"link\", {\n                        rel: \"preconnect\",\n                        href: \"https://fonts.gstatic.com\",\n                        crossOrigin: \"true\"\n                    }, void 0, false, {\n                        fileName: \"D:\\\\next\\\\org\\\\src\\\\app\\\\layout.js\",\n                        lineNumber: 45,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"link\", {\n                        href: \"https://fonts.googleapis.com/css2?family=Golos+Text:wght@400..900&display=swap\",\n                        rel: \"stylesheet\"\n                    }, void 0, false, {\n                        fileName: \"D:\\\\next\\\\org\\\\src\\\\app\\\\layout.js\",\n                        lineNumber: 46,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"link\", {\n                        rel: \"icon\",\n                        href: \"/images/logo/favicon.png\",\n                        type: \"image/x-icon\"\n                    }, void 0, false, {\n                        fileName: \"D:\\\\next\\\\org\\\\src\\\\app\\\\layout.js\",\n                        lineNumber: 50,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"link\", {\n                        rel: \"shortcut icon\",\n                        href: \"/images/logo/favicon.png\",\n                        type: \"image/x-icon\"\n                    }, void 0, false, {\n                        fileName: \"D:\\\\next\\\\org\\\\src\\\\app\\\\layout.js\",\n                        lineNumber: 51,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"meta\", {\n                        name: \"msapplication-TileImage\",\n                        content: \"/images/logo/favicon.png\"\n                    }, void 0, false, {\n                        fileName: \"D:\\\\next\\\\org\\\\src\\\\app\\\\layout.js\",\n                        lineNumber: 52,\n                        columnNumber: 9\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"D:\\\\next\\\\org\\\\src\\\\app\\\\layout.js\",\n                lineNumber: 43,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"body\", {\n                className: \"ltr light\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_context_AuthContext__WEBPACK_IMPORTED_MODULE_3__.AuthProvider, {\n                    children: children\n                }, void 0, false, {\n                    fileName: \"D:\\\\next\\\\org\\\\src\\\\app\\\\layout.js\",\n                    lineNumber: 56,\n                    columnNumber: 9\n                }, this)\n            }, void 0, false, {\n                fileName: \"D:\\\\next\\\\org\\\\src\\\\app\\\\layout.js\",\n                lineNumber: 54,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_utils_Bootstrap_BootstrapClient__WEBPACK_IMPORTED_MODULE_1__[\"default\"], {}, void 0, false, {\n                fileName: \"D:\\\\next\\\\org\\\\src\\\\app\\\\layout.js\",\n                lineNumber: 60,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"D:\\\\next\\\\org\\\\src\\\\app\\\\layout.js\",\n        lineNumber: 42,\n        columnNumber: 5\n    }, this);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9zcmMvYXBwL2xheW91dC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQ2dFO0FBQ25DO0FBQ3dCLENBQUMsbUJBQW1CO0FBRXpFLGNBQWM7QUFDaUM7QUFDUDtBQUNHO0FBQ3dCO0FBQzVCO0FBQ0M7QUFDTTtBQUNEO0FBQ1U7QUFDVjtBQUNFO0FBQ0Q7QUFDSDtBQUNTO0FBQ1Q7QUFDSDtBQUNXO0FBQ1Q7QUFDUDtBQUNZO0FBQytCO0FBQzdCO0FBQ0Y7QUFDSTtBQUNDO0FBQ0g7QUFDRDtBQUNGO0FBQ0o7QUFDZDtBQUNLO0FBQ1g7QUFFUCxTQUFTRyxXQUFXLEVBQUVDLFFBQVEsRUFBRTtJQUM3QyxxQkFDRSw4REFBQ0M7UUFBS0MsTUFBSzs7MEJBQ1QsOERBQUNMLGtEQUFJQTs7a0NBQ0gsOERBQUNNO3dCQUFLQyxLQUFJO3dCQUFhQyxNQUFLOzs7Ozs7a0NBQzVCLDhEQUFDRjt3QkFBS0MsS0FBSTt3QkFBYUMsTUFBSzt3QkFBNEJDLGFBQVk7Ozs7OztrQ0FDcEUsOERBQUNIO3dCQUNDRSxNQUFLO3dCQUNMRCxLQUFJOzs7Ozs7a0NBRU4sOERBQUNEO3dCQUFLQyxLQUFJO3dCQUFPQyxNQUFLO3dCQUEyQkUsTUFBSzs7Ozs7O2tDQUN0RCw4REFBQ0o7d0JBQUtDLEtBQUk7d0JBQWdCQyxNQUFLO3dCQUEyQkUsTUFBSzs7Ozs7O2tDQUMvRCw4REFBQ0M7d0JBQUtDLE1BQUs7d0JBQTBCQyxTQUFROzs7Ozs7Ozs7Ozs7MEJBRS9DLDhEQUFDQztnQkFBS0MsV0FBVTswQkFFZCw0RUFBQ2QsOERBQVlBOzhCQUNWRTs7Ozs7Ozs7Ozs7MEJBR0wsOERBQUNKLHdFQUFlQTs7Ozs7Ozs7Ozs7QUFHdEIiLCJzb3VyY2VzIjpbIkQ6XFxuZXh0XFxvcmdcXHNyY1xcYXBwXFxsYXlvdXQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCI7XHJcbmltcG9ydCBCb290c3RyYXBDbGllbnQgZnJvbSBcIkAvdXRpbHMvQm9vdHN0cmFwL0Jvb3RzdHJhcENsaWVudFwiO1xyXG5pbXBvcnQgSGVhZCBmcm9tIFwibmV4dC9oZWFkXCI7XHJcbmltcG9ydCB7IEF1dGhQcm92aWRlciB9IGZyb20gXCJAL2NvbnRleHQvQXV0aENvbnRleHRcIjsgLy8g4pyFIGltcG9ydCBjb250ZXh0XHJcblxyXG4vLyBDU1MgaW1wb3J0c1xyXG5pbXBvcnQgJy4uL3ZlbmRvci90cnVtYm93eWcvdHJ1bWJvd3lnLm1pbi5jc3MnO1xyXG5pbXBvcnQgJ2ZpbGVwb25kL2Rpc3QvZmlsZXBvbmQubWluLmNzcyc7XHJcbmltcG9ydCAnLi4vdmVuZG9yL2ZvbnRhd2Vzb21lL2Nzcy9hbGwuY3NzJztcclxuaW1wb3J0ICcuLi92ZW5kb3IvZGF0YXRhYmxlL2RhdGF0YWJsZTIvYnV0dG9ucy5kYXRhVGFibGVzLm1pbi5jc3MnO1xyXG5pbXBvcnQgJy4uL3ZlbmRvci9wcmlzbS9wcmlzbS5taW4uY3NzJztcclxuaW1wb3J0IFwic2xpY2stY2Fyb3VzZWwvc2xpY2svc2xpY2suY3NzXCI7XHJcbmltcG9ydCBcInNsaWNrLWNhcm91c2VsL3NsaWNrL3NsaWNrLXRoZW1lLmNzc1wiO1xyXG5pbXBvcnQgJy4uL3ZlbmRvci9hbmltYXRpb24vYW5pbWF0ZS5taW4uY3NzJztcclxuaW1wb3J0ICcuLi92ZW5kb3IvZGF0YXRhYmxlL2pxdWVyeS5kYXRhVGFibGVzLm1pbi5jc3MnO1xyXG5pbXBvcnQgJy4uL3ZlbmRvci93ZWF0aGVyL3dlYXRoZXItaWNvbnMuY3NzJztcclxuaW1wb3J0ICcuLi92ZW5kb3IvYW5pbWF0ZWRfaWNvbi9tZGktbGlnaHQuY3NzJztcclxuaW1wb3J0ICcuLi92ZW5kb3IvaW9uaW8taWNvbi9jc3MvaWNvbm9pci5jc3MnO1xyXG5pbXBvcnQgJy4uL3ZlbmRvci9sZWFmbGV0bWFwcy9sZWFmbGV0LmNzcyc7XHJcbmltcG9ydCAnLi4vdmVuZG9yL3ZlY3Rvci1tYXAvanF1ZXJ5LWp2ZWN0b3JtYXAuY3NzJztcclxuaW1wb3J0ICcuLi92ZW5kb3Ivc2hlcGhlcmRqcy9zaGVwaGVyZC5jc3MnO1xyXG5pbXBvcnQgJy4uL3ZlbmRvci9qc3RyZWUvc3R5bGUubWluLmNzcyc7XHJcbmltcG9ydCAnLi4vdmVuZG9yL2R1YWxfbGlzdGJveGVzL2R1YWwtbGlzdGJveC5jc3MnO1xyXG5pbXBvcnQgJy4uL3ZlbmRvci9mdWxsY2FsZW5kYXIvZ2xvYmFsLmpzJztcclxuaW1wb3J0ICcuLi92ZW5kb3Ivc2xpY2svc2xpY2suY3NzJztcclxuaW1wb3J0ICcuLi92ZW5kb3IvZGF0ZXBpa2FyL2ZsYXRwaWNrci5taW4uY3NzJztcclxuaW1wb3J0ICdmaWxlcG9uZC1wbHVnaW4taW1hZ2UtcHJldmlldy9kaXN0L2ZpbGVwb25kLXBsdWdpbi1pbWFnZS1wcmV2aWV3LmNzcyc7XHJcbmltcG9ydCBcIi4uL3ZlbmRvci90YWJsZXItaWNvbnMvdGFibGVyLWljb25zLmNzc1wiO1xyXG5pbXBvcnQgXCIuLi92ZW5kb3IvcGhvc3Bob3IvcGhvc3Bob3ItbGlnaHQuY3NzXCI7XHJcbmltcG9ydCBcIi4uL3ZlbmRvci9mbGFnLWljb25zLW1hc3Rlci9mbGFnLWljb24uY3NzXCI7XHJcbmltcG9ydCBcIi4uL3ZlbmRvci92ZWN0b3ItbWFwL2pxdWVyeS1qdmVjdG9ybWFwLmNzc1wiO1xyXG5pbXBvcnQgXCIuLi92ZW5kb3Ivbm91aXNsaWRlci9ub3Vpc2xpZGVyLm1pbi5jc3NcIjtcclxuaW1wb3J0ICdzaW1wbGViYXItcmVhY3QvZGlzdC9zaW1wbGViYXIubWluLmNzcyc7XHJcbmltcG9ydCBcImJvb3RzdHJhcC9kaXN0L2Nzcy9ib290c3RyYXAubWluLmNzc1wiO1xyXG5pbXBvcnQgJy4uL3ZlbmRvci9zZWxlY3Qvc2VsZWN0Mi5taW4uY3NzJztcclxuaW1wb3J0IFwiLi4vc2Nzcy9zdHlsZS5zY3NzXCI7XHJcbmltcG9ydCBcIi4uL3Njc3MvcmVzcG9uc2l2ZS5zY3NzXCI7XHJcbmltcG9ydCAnLi9nbG9ibGUuY3NzJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFJvb3RMYXlvdXQoeyBjaGlsZHJlbiB9KSB7XHJcbiAgcmV0dXJuIChcclxuICAgIDxodG1sIGxhbmc9XCJlblwiPlxyXG4gICAgICA8SGVhZD5cclxuICAgICAgICA8bGluayByZWw9XCJwcmVjb25uZWN0XCIgaHJlZj1cImh0dHBzOi8vZm9udHMuZ29vZ2xlYXBpcy5jb21cIi8+XHJcbiAgICAgICAgPGxpbmsgcmVsPVwicHJlY29ubmVjdFwiIGhyZWY9XCJodHRwczovL2ZvbnRzLmdzdGF0aWMuY29tXCIgY3Jvc3NPcmlnaW49XCJ0cnVlXCIvPlxyXG4gICAgICAgIDxsaW5rXHJcbiAgICAgICAgICBocmVmPVwiaHR0cHM6Ly9mb250cy5nb29nbGVhcGlzLmNvbS9jc3MyP2ZhbWlseT1Hb2xvcytUZXh0OndnaHRANDAwLi45MDAmZGlzcGxheT1zd2FwXCJcclxuICAgICAgICAgIHJlbD1cInN0eWxlc2hlZXRcIlxyXG4gICAgICAgIC8+XHJcbiAgICAgICAgPGxpbmsgcmVsPVwiaWNvblwiIGhyZWY9XCIvaW1hZ2VzL2xvZ28vZmF2aWNvbi5wbmdcIiB0eXBlPVwiaW1hZ2UveC1pY29uXCIvPlxyXG4gICAgICAgIDxsaW5rIHJlbD1cInNob3J0Y3V0IGljb25cIiBocmVmPVwiL2ltYWdlcy9sb2dvL2Zhdmljb24ucG5nXCIgdHlwZT1cImltYWdlL3gtaWNvblwiLz5cclxuICAgICAgICA8bWV0YSBuYW1lPVwibXNhcHBsaWNhdGlvbi1UaWxlSW1hZ2VcIiBjb250ZW50PVwiL2ltYWdlcy9sb2dvL2Zhdmljb24ucG5nXCIvPlxyXG4gICAgICA8L0hlYWQ+XHJcbiAgICAgIDxib2R5IGNsYXNzTmFtZT1cImx0ciBsaWdodFwiPlxyXG4gICAgICAgIHsvKiDinIUgV3JhcCBhcHAgd2l0aCBBdXRoUHJvdmlkZXIgKi99XHJcbiAgICAgICAgPEF1dGhQcm92aWRlcj5cclxuICAgICAgICAgIHtjaGlsZHJlbn1cclxuICAgICAgICA8L0F1dGhQcm92aWRlcj5cclxuICAgICAgPC9ib2R5PlxyXG4gICAgICA8Qm9vdHN0cmFwQ2xpZW50IC8+XHJcbiAgICA8L2h0bWw+XHJcbiAgKTtcclxufVxyXG4iXSwibmFtZXMiOlsiQm9vdHN0cmFwQ2xpZW50IiwiSGVhZCIsIkF1dGhQcm92aWRlciIsIlJvb3RMYXlvdXQiLCJjaGlsZHJlbiIsImh0bWwiLCJsYW5nIiwibGluayIsInJlbCIsImhyZWYiLCJjcm9zc09yaWdpbiIsInR5cGUiLCJtZXRhIiwibmFtZSIsImNvbnRlbnQiLCJib2R5IiwiY2xhc3NOYW1lIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./src/app/layout.js\n");

/***/ }),

/***/ "(ssr)/./src/components/CommonElements/Loader/index.js":
/*!*******************************************************!*\
  !*** ./src/components/CommonElements/Loader/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* __next_internal_client_entry_do_not_use__ default auto */ \n\nconst Loader = ()=>{\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"loader-wrapper\",\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            className: \"loader_16\"\n        }, void 0, false, {\n            fileName: \"D:\\\\next\\\\org\\\\src\\\\components\\\\CommonElements\\\\Loader\\\\index.js\",\n            lineNumber: 7,\n            columnNumber: 11\n        }, undefined)\n    }, void 0, false, {\n        fileName: \"D:\\\\next\\\\org\\\\src\\\\components\\\\CommonElements\\\\Loader\\\\index.js\",\n        lineNumber: 6,\n        columnNumber: 7\n    }, undefined);\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Loader);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9zcmMvY29tcG9uZW50cy9Db21tb25FbGVtZW50cy9Mb2FkZXIvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQzBCO0FBRTFCLE1BQU1DLFNBQVM7SUFDYixxQkFDSSw4REFBQ0M7UUFBSUMsV0FBVTtrQkFDWCw0RUFBQ0Q7WUFBSUMsV0FBVTs7Ozs7Ozs7Ozs7QUFHekI7QUFFQSxpRUFBZUYsTUFBTUEsRUFBQyIsInNvdXJjZXMiOlsiRDpcXG5leHRcXG9yZ1xcc3JjXFxjb21wb25lbnRzXFxDb21tb25FbGVtZW50c1xcTG9hZGVyXFxpbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIjtcclxuaW1wb3J0IFJlYWN0IGZyb20gXCJyZWFjdFwiO1xyXG5cclxuY29uc3QgTG9hZGVyID0gKCkgPT4ge1xyXG4gIHJldHVybiAoXHJcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwibG9hZGVyLXdyYXBwZXJcIj5cclxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwibG9hZGVyXzE2XCI+PC9kaXY+XHJcbiAgICAgIDwvZGl2PlxyXG4gICk7XHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBMb2FkZXI7XHJcbiJdLCJuYW1lcyI6WyJSZWFjdCIsIkxvYWRlciIsImRpdiIsImNsYXNzTmFtZSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./src/components/CommonElements/Loader/index.js\n");

/***/ }),

/***/ "(ssr)/./src/components/Pages/Auth_Pages/Sign_In_with_Bg_image/index.js":
/*!************************************************************************!*\
  !*** ./src/components/Pages/Auth_Pages/Sign_In_with_Bg_image/index.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var reactstrap__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! reactstrap */ \"(ssr)/./node_modules/reactstrap/esm/Container.js\");\n/* harmony import */ var reactstrap__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! reactstrap */ \"(ssr)/./node_modules/reactstrap/esm/Row.js\");\n/* harmony import */ var reactstrap__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! reactstrap */ \"(ssr)/./node_modules/reactstrap/esm/Col.js\");\n/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/link */ \"(ssr)/./node_modules/next/dist/client/app-dir/link.js\");\n/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_link__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _context_AuthContext__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/context/AuthContext */ \"(ssr)/./src/context/AuthContext.js\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \n\n\n\n\nconst SignInBg = ()=>{\n    const { login, loading, socialLogin } = (0,_context_AuthContext__WEBPACK_IMPORTED_MODULE_3__.useAuth)();\n    const [email, setEmail] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"\");\n    const [password, setPassword] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"\");\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"\");\n    const handleLogin = async (e)=>{\n        e.preventDefault();\n        setError(\"\");\n        try {\n            await login(email, password);\n            window.location.href = \"/dashboard\";\n        } catch (err) {\n            setError(err.message || \"Something went wrong\");\n        }\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(reactstrap__WEBPACK_IMPORTED_MODULE_4__[\"default\"], {\n        fluid: true,\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(reactstrap__WEBPACK_IMPORTED_MODULE_5__[\"default\"], {\n            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(reactstrap__WEBPACK_IMPORTED_MODULE_6__[\"default\"], {\n                xs: 12,\n                className: \"p-0\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"login-form-container\",\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"my-4 text-center\",\n                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((next_link__WEBPACK_IMPORTED_MODULE_2___default()), {\n                                className: \"logo d-inline-block\",\n                                href: \"/\",\n                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"img\", {\n                                    src: \"/images/logo/myn.png\",\n                                    className: \"img-fluid\",\n                                    alt: \"logo\",\n                                    style: {\n                                        maxWidth: \"50px\",\n                                        height: \"auto\"\n                                    }\n                                }, void 0, false, {\n                                    fileName: \"D:\\\\next\\\\org\\\\src\\\\components\\\\Pages\\\\Auth_Pages\\\\Sign_In_with_Bg_image\\\\index.js\",\n                                    lineNumber: 32,\n                                    columnNumber: 17\n                                }, undefined)\n                            }, void 0, false, {\n                                fileName: \"D:\\\\next\\\\org\\\\src\\\\components\\\\Pages\\\\Auth_Pages\\\\Sign_In_with_Bg_image\\\\index.js\",\n                                lineNumber: 31,\n                                columnNumber: 15\n                            }, undefined)\n                        }, void 0, false, {\n                            fileName: \"D:\\\\next\\\\org\\\\src\\\\components\\\\Pages\\\\Auth_Pages\\\\Sign_In_with_Bg_image\\\\index.js\",\n                            lineNumber: 30,\n                            columnNumber: 13\n                        }, undefined),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"form_container\",\n                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"form\", {\n                                className: \"app-form\",\n                                onSubmit: handleLogin,\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        className: \"mb-3 text-center\",\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h3\", {\n                                                children: \"Login to your Account\"\n                                            }, void 0, false, {\n                                                fileName: \"D:\\\\next\\\\org\\\\src\\\\components\\\\Pages\\\\Auth_Pages\\\\Sign_In_with_Bg_image\\\\index.js\",\n                                                lineNumber: 44,\n                                                columnNumber: 19\n                                            }, undefined),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                                className: \"f-s-12 text-secondary\",\n                                                children: \"Get started with our app, just log in and enjoy the experience.\"\n                                            }, void 0, false, {\n                                                fileName: \"D:\\\\next\\\\org\\\\src\\\\components\\\\Pages\\\\Auth_Pages\\\\Sign_In_with_Bg_image\\\\index.js\",\n                                                lineNumber: 45,\n                                                columnNumber: 19\n                                            }, undefined)\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"D:\\\\next\\\\org\\\\src\\\\components\\\\Pages\\\\Auth_Pages\\\\Sign_In_with_Bg_image\\\\index.js\",\n                                        lineNumber: 43,\n                                        columnNumber: 17\n                                    }, undefined),\n                                    error && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                        className: \"text-danger text-center\",\n                                        children: error\n                                    }, void 0, false, {\n                                        fileName: \"D:\\\\next\\\\org\\\\src\\\\components\\\\Pages\\\\Auth_Pages\\\\Sign_In_with_Bg_image\\\\index.js\",\n                                        lineNumber: 50,\n                                        columnNumber: 27\n                                    }, undefined),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        className: \"mb-3\",\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"label\", {\n                                                className: \"form-label\",\n                                                children: \"Email address\"\n                                            }, void 0, false, {\n                                                fileName: \"D:\\\\next\\\\org\\\\src\\\\components\\\\Pages\\\\Auth_Pages\\\\Sign_In_with_Bg_image\\\\index.js\",\n                                                lineNumber: 53,\n                                                columnNumber: 19\n                                            }, undefined),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                                                type: \"email\",\n                                                className: \"form-control\",\n                                                placeholder: \"Enter Your Email\",\n                                                value: email,\n                                                onChange: (e)=>setEmail(e.target.value)\n                                            }, void 0, false, {\n                                                fileName: \"D:\\\\next\\\\org\\\\src\\\\components\\\\Pages\\\\Auth_Pages\\\\Sign_In_with_Bg_image\\\\index.js\",\n                                                lineNumber: 54,\n                                                columnNumber: 19\n                                            }, undefined)\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"D:\\\\next\\\\org\\\\src\\\\components\\\\Pages\\\\Auth_Pages\\\\Sign_In_with_Bg_image\\\\index.js\",\n                                        lineNumber: 52,\n                                        columnNumber: 17\n                                    }, undefined),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        className: \"mb-3\",\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"label\", {\n                                                className: \"form-label\",\n                                                children: \"Password\"\n                                            }, void 0, false, {\n                                                fileName: \"D:\\\\next\\\\org\\\\src\\\\components\\\\Pages\\\\Auth_Pages\\\\Sign_In_with_Bg_image\\\\index.js\",\n                                                lineNumber: 64,\n                                                columnNumber: 19\n                                            }, undefined),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((next_link__WEBPACK_IMPORTED_MODULE_2___default()), {\n                                                href: \"/admin-pages/auth_pages/password_reset\",\n                                                className: \"link-primary float-end\",\n                                                children: \"Forgot Password?\"\n                                            }, void 0, false, {\n                                                fileName: \"D:\\\\next\\\\org\\\\src\\\\components\\\\Pages\\\\Auth_Pages\\\\Sign_In_with_Bg_image\\\\index.js\",\n                                                lineNumber: 65,\n                                                columnNumber: 19\n                                            }, undefined),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                                                type: \"password\",\n                                                className: \"form-control\",\n                                                placeholder: \"Enter Your Password\",\n                                                value: password,\n                                                onChange: (e)=>setPassword(e.target.value)\n                                            }, void 0, false, {\n                                                fileName: \"D:\\\\next\\\\org\\\\src\\\\components\\\\Pages\\\\Auth_Pages\\\\Sign_In_with_Bg_image\\\\index.js\",\n                                                lineNumber: 71,\n                                                columnNumber: 19\n                                            }, undefined)\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"D:\\\\next\\\\org\\\\src\\\\components\\\\Pages\\\\Auth_Pages\\\\Sign_In_with_Bg_image\\\\index.js\",\n                                        lineNumber: 63,\n                                        columnNumber: 17\n                                    }, undefined),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        className: \"mb-3 form-check\",\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                                                type: \"checkbox\",\n                                                className: \"form-check-input\",\n                                                id: \"formCheck1\"\n                                            }, void 0, false, {\n                                                fileName: \"D:\\\\next\\\\org\\\\src\\\\components\\\\Pages\\\\Auth_Pages\\\\Sign_In_with_Bg_image\\\\index.js\",\n                                                lineNumber: 81,\n                                                columnNumber: 19\n                                            }, undefined),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"label\", {\n                                                className: \"form-check-label\",\n                                                htmlFor: \"formCheck1\",\n                                                children: \"Remember me\"\n                                            }, void 0, false, {\n                                                fileName: \"D:\\\\next\\\\org\\\\src\\\\components\\\\Pages\\\\Auth_Pages\\\\Sign_In_with_Bg_image\\\\index.js\",\n                                                lineNumber: 82,\n                                                columnNumber: 19\n                                            }, undefined)\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"D:\\\\next\\\\org\\\\src\\\\components\\\\Pages\\\\Auth_Pages\\\\Sign_In_with_Bg_image\\\\index.js\",\n                                        lineNumber: 80,\n                                        columnNumber: 17\n                                    }, undefined),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                            type: \"submit\",\n                                            disabled: loading,\n                                            className: \"btn btn-primary w-100\",\n                                            children: loading ? \"Signing In...\" : \"Sign In\"\n                                        }, void 0, false, {\n                                            fileName: \"D:\\\\next\\\\org\\\\src\\\\components\\\\Pages\\\\Auth_Pages\\\\Sign_In_with_Bg_image\\\\index.js\",\n                                            lineNumber: 88,\n                                            columnNumber: 19\n                                        }, undefined)\n                                    }, void 0, false, {\n                                        fileName: \"D:\\\\next\\\\org\\\\src\\\\components\\\\Pages\\\\Auth_Pages\\\\Sign_In_with_Bg_image\\\\index.js\",\n                                        lineNumber: 87,\n                                        columnNumber: 17\n                                    }, undefined),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        className: \"app-divider-v justify-content-center\",\n                                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                            children: \"OR\"\n                                        }, void 0, false, {\n                                            fileName: \"D:\\\\next\\\\org\\\\src\\\\components\\\\Pages\\\\Auth_Pages\\\\Sign_In_with_Bg_image\\\\index.js\",\n                                            lineNumber: 98,\n                                            columnNumber: 19\n                                        }, undefined)\n                                    }, void 0, false, {\n                                        fileName: \"D:\\\\next\\\\org\\\\src\\\\components\\\\Pages\\\\Auth_Pages\\\\Sign_In_with_Bg_image\\\\index.js\",\n                                        lineNumber: 97,\n                                        columnNumber: 17\n                                    }, undefined),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        className: \"mb-3 text-center\",\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                                type: \"button\",\n                                                className: \"btn btn-primary icon-btn b-r-5 m-1\",\n                                                onClick: ()=>socialLogin(\"facebook\"),\n                                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"i\", {\n                                                    className: \"ti ti-brand-facebook text-white\"\n                                                }, void 0, false, {\n                                                    fileName: \"D:\\\\next\\\\org\\\\src\\\\components\\\\Pages\\\\Auth_Pages\\\\Sign_In_with_Bg_image\\\\index.js\",\n                                                    lineNumber: 107,\n                                                    columnNumber: 23\n                                                }, undefined)\n                                            }, void 0, false, {\n                                                fileName: \"D:\\\\next\\\\org\\\\src\\\\components\\\\Pages\\\\Auth_Pages\\\\Sign_In_with_Bg_image\\\\index.js\",\n                                                lineNumber: 102,\n                                                columnNumber: 21\n                                            }, undefined),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                                type: \"button\",\n                                                className: \"btn btn-danger icon-btn b-r-5 m-1\",\n                                                onClick: ()=>socialLogin(\"google\"),\n                                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"i\", {\n                                                    className: \"ti ti-brand-google text-white\"\n                                                }, void 0, false, {\n                                                    fileName: \"D:\\\\next\\\\org\\\\src\\\\components\\\\Pages\\\\Auth_Pages\\\\Sign_In_with_Bg_image\\\\index.js\",\n                                                    lineNumber: 115,\n                                                    columnNumber: 23\n                                                }, undefined)\n                                            }, void 0, false, {\n                                                fileName: \"D:\\\\next\\\\org\\\\src\\\\components\\\\Pages\\\\Auth_Pages\\\\Sign_In_with_Bg_image\\\\index.js\",\n                                                lineNumber: 110,\n                                                columnNumber: 21\n                                            }, undefined),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                                type: \"button\",\n                                                className: \"btn btn-info icon-btn b-r-5 m-1\",\n                                                onClick: ()=>socialLogin(\"linkedin_oidc\"),\n                                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"i\", {\n                                                    className: \"ti ti-brand-linkedin text-white\"\n                                                }, void 0, false, {\n                                                    fileName: \"D:\\\\next\\\\org\\\\src\\\\components\\\\Pages\\\\Auth_Pages\\\\Sign_In_with_Bg_image\\\\index.js\",\n                                                    lineNumber: 123,\n                                                    columnNumber: 23\n                                                }, undefined)\n                                            }, void 0, false, {\n                                                fileName: \"D:\\\\next\\\\org\\\\src\\\\components\\\\Pages\\\\Auth_Pages\\\\Sign_In_with_Bg_image\\\\index.js\",\n                                                lineNumber: 118,\n                                                columnNumber: 21\n                                            }, undefined)\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"D:\\\\next\\\\org\\\\src\\\\components\\\\Pages\\\\Auth_Pages\\\\Sign_In_with_Bg_image\\\\index.js\",\n                                        lineNumber: 101,\n                                        columnNumber: 17\n                                    }, undefined),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        className: \"text-center\",\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                children: \"Don't have an account? \"\n                                            }, void 0, false, {\n                                                fileName: \"D:\\\\next\\\\org\\\\src\\\\components\\\\Pages\\\\Auth_Pages\\\\Sign_In_with_Bg_image\\\\index.js\",\n                                                lineNumber: 128,\n                                                columnNumber: 19\n                                            }, undefined),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((next_link__WEBPACK_IMPORTED_MODULE_2___default()), {\n                                                href: \"/auth/signup\",\n                                                className: \"link-primary text-decoration-underline\",\n                                                children: \"Sign up\"\n                                            }, void 0, false, {\n                                                fileName: \"D:\\\\next\\\\org\\\\src\\\\components\\\\Pages\\\\Auth_Pages\\\\Sign_In_with_Bg_image\\\\index.js\",\n                                                lineNumber: 129,\n                                                columnNumber: 19\n                                            }, undefined)\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"D:\\\\next\\\\org\\\\src\\\\components\\\\Pages\\\\Auth_Pages\\\\Sign_In_with_Bg_image\\\\index.js\",\n                                        lineNumber: 127,\n                                        columnNumber: 17\n                                    }, undefined)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"D:\\\\next\\\\org\\\\src\\\\components\\\\Pages\\\\Auth_Pages\\\\Sign_In_with_Bg_image\\\\index.js\",\n                                lineNumber: 42,\n                                columnNumber: 15\n                            }, undefined)\n                        }, void 0, false, {\n                            fileName: \"D:\\\\next\\\\org\\\\src\\\\components\\\\Pages\\\\Auth_Pages\\\\Sign_In_with_Bg_image\\\\index.js\",\n                            lineNumber: 41,\n                            columnNumber: 13\n                        }, undefined)\n                    ]\n                }, void 0, true, {\n                    fileName: \"D:\\\\next\\\\org\\\\src\\\\components\\\\Pages\\\\Auth_Pages\\\\Sign_In_with_Bg_image\\\\index.js\",\n                    lineNumber: 29,\n                    columnNumber: 11\n                }, undefined)\n            }, void 0, false, {\n                fileName: \"D:\\\\next\\\\org\\\\src\\\\components\\\\Pages\\\\Auth_Pages\\\\Sign_In_with_Bg_image\\\\index.js\",\n                lineNumber: 28,\n                columnNumber: 9\n            }, undefined)\n        }, void 0, false, {\n            fileName: \"D:\\\\next\\\\org\\\\src\\\\components\\\\Pages\\\\Auth_Pages\\\\Sign_In_with_Bg_image\\\\index.js\",\n            lineNumber: 27,\n            columnNumber: 7\n        }, undefined)\n    }, void 0, false, {\n        fileName: \"D:\\\\next\\\\org\\\\src\\\\components\\\\Pages\\\\Auth_Pages\\\\Sign_In_with_Bg_image\\\\index.js\",\n        lineNumber: 26,\n        columnNumber: 5\n    }, undefined);\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SignInBg);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9zcmMvY29tcG9uZW50cy9QYWdlcy9BdXRoX1BhZ2VzL1NpZ25fSW5fd2l0aF9CZ19pbWFnZS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFDd0M7QUFDUztBQUNwQjtBQUNtQjtBQUVoRCxNQUFNTyxXQUFXO0lBQ2YsTUFBTSxFQUFFQyxLQUFLLEVBQUVDLE9BQU8sRUFBRUMsV0FBVyxFQUFFLEdBQUdKLDZEQUFPQTtJQUMvQyxNQUFNLENBQUNLLE9BQU9DLFNBQVMsR0FBR1gsK0NBQVFBLENBQUM7SUFDbkMsTUFBTSxDQUFDWSxVQUFVQyxZQUFZLEdBQUdiLCtDQUFRQSxDQUFDO0lBQ3pDLE1BQU0sQ0FBQ2MsT0FBT0MsU0FBUyxHQUFHZiwrQ0FBUUEsQ0FBQztJQUVuQyxNQUFNZ0IsY0FBYyxPQUFPQztRQUN6QkEsRUFBRUMsY0FBYztRQUNoQkgsU0FBUztRQUVULElBQUk7WUFDRixNQUFNUixNQUFNRyxPQUFPRTtZQUNuQk8sT0FBT0MsUUFBUSxDQUFDQyxJQUFJLEdBQUc7UUFDekIsRUFBRSxPQUFPQyxLQUFLO1lBQ1pQLFNBQVNPLElBQUlDLE9BQU8sSUFBSTtRQUMxQjtJQUNGO0lBRUEscUJBQ0UsOERBQUNyQixrREFBU0E7UUFBQ3NCLEtBQUs7a0JBQ2QsNEVBQUNyQixrREFBR0E7c0JBQ0YsNEVBQUNGLGtEQUFHQTtnQkFBQ3dCLElBQUk7Z0JBQUlDLFdBQVU7MEJBQ3JCLDRFQUFDQztvQkFBSUQsV0FBVTs7c0NBQ2IsOERBQUNDOzRCQUFJRCxXQUFVO3NDQUNiLDRFQUFDdEIsa0RBQUlBO2dDQUFDc0IsV0FBVTtnQ0FBc0JMLE1BQUs7MENBQ3pDLDRFQUFDTztvQ0FDQ0MsS0FBSTtvQ0FDSkgsV0FBVTtvQ0FDVkksS0FBSTtvQ0FDSkMsT0FBTzt3Q0FBRUMsVUFBVTt3Q0FBUUMsUUFBUTtvQ0FBTzs7Ozs7Ozs7Ozs7Ozs7OztzQ0FLaEQsOERBQUNOOzRCQUFJRCxXQUFVO3NDQUNiLDRFQUFDUTtnQ0FBS1IsV0FBVTtnQ0FBV1MsVUFBVW5COztrREFDbkMsOERBQUNXO3dDQUFJRCxXQUFVOzswREFDYiw4REFBQ1U7MERBQUc7Ozs7OzswREFDSiw4REFBQ0M7Z0RBQUVYLFdBQVU7MERBQXdCOzs7Ozs7Ozs7Ozs7b0NBS3RDWix1QkFBUyw4REFBQ3VCO3dDQUFFWCxXQUFVO2tEQUEyQlo7Ozs7OztrREFFbEQsOERBQUNhO3dDQUFJRCxXQUFVOzswREFDYiw4REFBQ1k7Z0RBQU1aLFdBQVU7MERBQWE7Ozs7OzswREFDOUIsOERBQUNhO2dEQUNDQyxNQUFLO2dEQUNMZCxXQUFVO2dEQUNWZSxhQUFZO2dEQUNaQyxPQUFPaEM7Z0RBQ1BpQyxVQUFVLENBQUMxQixJQUFNTixTQUFTTSxFQUFFMkIsTUFBTSxDQUFDRixLQUFLOzs7Ozs7Ozs7Ozs7a0RBSTVDLDhEQUFDZjt3Q0FBSUQsV0FBVTs7MERBQ2IsOERBQUNZO2dEQUFNWixXQUFVOzBEQUFhOzs7Ozs7MERBQzlCLDhEQUFDdEIsa0RBQUlBO2dEQUNIaUIsTUFBSztnREFDTEssV0FBVTswREFDWDs7Ozs7OzBEQUdELDhEQUFDYTtnREFDQ0MsTUFBSztnREFDTGQsV0FBVTtnREFDVmUsYUFBWTtnREFDWkMsT0FBTzlCO2dEQUNQK0IsVUFBVSxDQUFDMUIsSUFBTUosWUFBWUksRUFBRTJCLE1BQU0sQ0FBQ0YsS0FBSzs7Ozs7Ozs7Ozs7O2tEQUkvQyw4REFBQ2Y7d0NBQUlELFdBQVU7OzBEQUNiLDhEQUFDYTtnREFBTUMsTUFBSztnREFBV2QsV0FBVTtnREFBbUJtQixJQUFHOzs7Ozs7MERBQ3ZELDhEQUFDUDtnREFBTVosV0FBVTtnREFBbUJvQixTQUFROzBEQUFhOzs7Ozs7Ozs7Ozs7a0RBSzNELDhEQUFDbkI7a0RBQ0MsNEVBQUNvQjs0Q0FDQ1AsTUFBSzs0Q0FDTFEsVUFBVXhDOzRDQUNWa0IsV0FBVTtzREFFVGxCLFVBQVUsa0JBQWtCOzs7Ozs7Ozs7OztrREFJakMsOERBQUNtQjt3Q0FBSUQsV0FBVTtrREFDYiw0RUFBQ1c7c0RBQUU7Ozs7Ozs7Ozs7O2tEQUdMLDhEQUFDVjt3Q0FBSUQsV0FBVTs7MERBQ1gsOERBQUNxQjtnREFDQ1AsTUFBSztnREFDTGQsV0FBVTtnREFDVnVCLFNBQVMsSUFBTXhDLFlBQVk7MERBRTNCLDRFQUFDeUM7b0RBQUV4QixXQUFVOzs7Ozs7Ozs7OzswREFHZiw4REFBQ3FCO2dEQUNDUCxNQUFLO2dEQUNMZCxXQUFVO2dEQUNWdUIsU0FBUyxJQUFNeEMsWUFBWTswREFFM0IsNEVBQUN5QztvREFBRXhCLFdBQVU7Ozs7Ozs7Ozs7OzBEQUdmLDhEQUFDcUI7Z0RBQ0NQLE1BQUs7Z0RBQ0xkLFdBQVU7Z0RBQ1Z1QixTQUFTLElBQU14QyxZQUFZOzBEQUUzQiw0RUFBQ3lDO29EQUFFeEIsV0FBVTs7Ozs7Ozs7Ozs7Ozs7Ozs7a0RBSW5CLDhEQUFDQzt3Q0FBSUQsV0FBVTs7MERBQ2IsOERBQUN5QjswREFBSzs7Ozs7OzBEQUNOLDhEQUFDL0Msa0RBQUlBO2dEQUNIaUIsTUFBSztnREFDTEssV0FBVTswREFDWDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFZbkI7QUFFQSxpRUFBZXBCLFFBQVFBLEVBQUMiLCJzb3VyY2VzIjpbIkQ6XFxuZXh0XFxvcmdcXHNyY1xcY29tcG9uZW50c1xcUGFnZXNcXEF1dGhfUGFnZXNcXFNpZ25fSW5fd2l0aF9CZ19pbWFnZVxcaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCI7XHJcbmltcG9ydCBSZWFjdCwgeyB1c2VTdGF0ZSB9IGZyb20gXCJyZWFjdFwiO1xyXG5pbXBvcnQgeyBDb2wsIENvbnRhaW5lciwgUm93IH0gZnJvbSBcInJlYWN0c3RyYXBcIjtcclxuaW1wb3J0IExpbmsgZnJvbSBcIm5leHQvbGlua1wiO1xyXG5pbXBvcnQgeyB1c2VBdXRoIH0gZnJvbSBcIkAvY29udGV4dC9BdXRoQ29udGV4dFwiOyBcclxuXHJcbmNvbnN0IFNpZ25JbkJnID0gKCkgPT4ge1xyXG4gIGNvbnN0IHsgbG9naW4sIGxvYWRpbmcsIHNvY2lhbExvZ2luIH0gPSB1c2VBdXRoKCk7IFxyXG4gIGNvbnN0IFtlbWFpbCwgc2V0RW1haWxdID0gdXNlU3RhdGUoXCJcIik7XHJcbiAgY29uc3QgW3Bhc3N3b3JkLCBzZXRQYXNzd29yZF0gPSB1c2VTdGF0ZShcIlwiKTtcclxuICBjb25zdCBbZXJyb3IsIHNldEVycm9yXSA9IHVzZVN0YXRlKFwiXCIpO1xyXG5cclxuICBjb25zdCBoYW5kbGVMb2dpbiA9IGFzeW5jIChlKSA9PiB7XHJcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICBzZXRFcnJvcihcIlwiKTtcclxuXHJcbiAgICB0cnkge1xyXG4gICAgICBhd2FpdCBsb2dpbihlbWFpbCwgcGFzc3dvcmQpOyBcclxuICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSBcIi9kYXNoYm9hcmRcIjsgXHJcbiAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgc2V0RXJyb3IoZXJyLm1lc3NhZ2UgfHwgXCJTb21ldGhpbmcgd2VudCB3cm9uZ1wiKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICByZXR1cm4gKFxyXG4gICAgPENvbnRhaW5lciBmbHVpZD5cclxuICAgICAgPFJvdz5cclxuICAgICAgICA8Q29sIHhzPXsxMn0gY2xhc3NOYW1lPVwicC0wXCI+XHJcbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImxvZ2luLWZvcm0tY29udGFpbmVyXCI+XHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwibXktNCB0ZXh0LWNlbnRlclwiPlxyXG4gICAgICAgICAgICAgIDxMaW5rIGNsYXNzTmFtZT1cImxvZ28gZC1pbmxpbmUtYmxvY2tcIiBocmVmPVwiL1wiPlxyXG4gICAgICAgICAgICAgICAgPGltZ1xyXG4gICAgICAgICAgICAgICAgICBzcmM9XCIvaW1hZ2VzL2xvZ28vbXluLnBuZ1wiXHJcbiAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cImltZy1mbHVpZFwiXHJcbiAgICAgICAgICAgICAgICAgIGFsdD1cImxvZ29cIlxyXG4gICAgICAgICAgICAgICAgICBzdHlsZT17eyBtYXhXaWR0aDogXCI1MHB4XCIsIGhlaWdodDogXCJhdXRvXCIgfX1cclxuICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgPC9MaW5rPlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuXHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZm9ybV9jb250YWluZXJcIj5cclxuICAgICAgICAgICAgICA8Zm9ybSBjbGFzc05hbWU9XCJhcHAtZm9ybVwiIG9uU3VibWl0PXtoYW5kbGVMb2dpbn0+XHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm1iLTMgdGV4dC1jZW50ZXJcIj5cclxuICAgICAgICAgICAgICAgICAgPGgzPkxvZ2luIHRvIHlvdXIgQWNjb3VudDwvaDM+XHJcbiAgICAgICAgICAgICAgICAgIDxwIGNsYXNzTmFtZT1cImYtcy0xMiB0ZXh0LXNlY29uZGFyeVwiPlxyXG4gICAgICAgICAgICAgICAgICAgIEdldCBzdGFydGVkIHdpdGggb3VyIGFwcCwganVzdCBsb2cgaW4gYW5kIGVuam95IHRoZSBleHBlcmllbmNlLlxyXG4gICAgICAgICAgICAgICAgICA8L3A+XHJcbiAgICAgICAgICAgICAgICA8L2Rpdj5cclxuXHJcbiAgICAgICAgICAgICAgICB7ZXJyb3IgJiYgPHAgY2xhc3NOYW1lPVwidGV4dC1kYW5nZXIgdGV4dC1jZW50ZXJcIj57ZXJyb3J9PC9wPn1cclxuXHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm1iLTNcIj5cclxuICAgICAgICAgICAgICAgICAgPGxhYmVsIGNsYXNzTmFtZT1cImZvcm0tbGFiZWxcIj5FbWFpbCBhZGRyZXNzPC9sYWJlbD5cclxuICAgICAgICAgICAgICAgICAgPGlucHV0XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZT1cImVtYWlsXCJcclxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJmb3JtLWNvbnRyb2xcIlxyXG4gICAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyPVwiRW50ZXIgWW91ciBFbWFpbFwiXHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU9e2VtYWlsfVxyXG4gICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXsoZSkgPT4gc2V0RW1haWwoZS50YXJnZXQudmFsdWUpfVxyXG4gICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcblxyXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJtYi0zXCI+XHJcbiAgICAgICAgICAgICAgICAgIDxsYWJlbCBjbGFzc05hbWU9XCJmb3JtLWxhYmVsXCI+UGFzc3dvcmQ8L2xhYmVsPlxyXG4gICAgICAgICAgICAgICAgICA8TGlua1xyXG4gICAgICAgICAgICAgICAgICAgIGhyZWY9XCIvYWRtaW4tcGFnZXMvYXV0aF9wYWdlcy9wYXNzd29yZF9yZXNldFwiXHJcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwibGluay1wcmltYXJ5IGZsb2F0LWVuZFwiXHJcbiAgICAgICAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICAgICAgICBGb3Jnb3QgUGFzc3dvcmQ/XHJcbiAgICAgICAgICAgICAgICAgIDwvTGluaz5cclxuICAgICAgICAgICAgICAgICAgPGlucHV0XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZT1cInBhc3N3b3JkXCJcclxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJmb3JtLWNvbnRyb2xcIlxyXG4gICAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyPVwiRW50ZXIgWW91ciBQYXNzd29yZFwiXHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU9e3Bhc3N3b3JkfVxyXG4gICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXsoZSkgPT4gc2V0UGFzc3dvcmQoZS50YXJnZXQudmFsdWUpfVxyXG4gICAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcblxyXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJtYi0zIGZvcm0tY2hlY2tcIj5cclxuICAgICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJjaGVja2JveFwiIGNsYXNzTmFtZT1cImZvcm0tY2hlY2staW5wdXRcIiBpZD1cImZvcm1DaGVjazFcIiAvPlxyXG4gICAgICAgICAgICAgICAgICA8bGFiZWwgY2xhc3NOYW1lPVwiZm9ybS1jaGVjay1sYWJlbFwiIGh0bWxGb3I9XCJmb3JtQ2hlY2sxXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgUmVtZW1iZXIgbWVcclxuICAgICAgICAgICAgICAgICAgPC9sYWJlbD5cclxuICAgICAgICAgICAgICAgIDwvZGl2PlxyXG5cclxuICAgICAgICAgICAgICAgIDxkaXY+XHJcbiAgICAgICAgICAgICAgICAgIDxidXR0b25cclxuICAgICAgICAgICAgICAgICAgICB0eXBlPVwic3VibWl0XCJcclxuICAgICAgICAgICAgICAgICAgICBkaXNhYmxlZD17bG9hZGluZ31cclxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJidG4gYnRuLXByaW1hcnkgdy0xMDBcIlxyXG4gICAgICAgICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICAgICAge2xvYWRpbmcgPyBcIlNpZ25pbmcgSW4uLi5cIiA6IFwiU2lnbiBJblwifVxyXG4gICAgICAgICAgICAgICAgICA8L2J1dHRvbj5cclxuICAgICAgICAgICAgICAgIDwvZGl2PlxyXG5cclxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYXBwLWRpdmlkZXItdiBqdXN0aWZ5LWNvbnRlbnQtY2VudGVyXCI+XHJcbiAgICAgICAgICAgICAgICAgIDxwPk9SPC9wPlxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcblxyXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJtYi0zIHRleHQtY2VudGVyXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgPGJ1dHRvblxyXG4gICAgICAgICAgICAgICAgICAgICAgdHlwZT1cImJ1dHRvblwiXHJcbiAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJidG4gYnRuLXByaW1hcnkgaWNvbi1idG4gYi1yLTUgbS0xXCJcclxuICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IHNvY2lhbExvZ2luKFwiZmFjZWJvb2tcIil9XHJcbiAgICAgICAgICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICAgICAgICAgICAgPGkgY2xhc3NOYW1lPVwidGkgdGktYnJhbmQtZmFjZWJvb2sgdGV4dC13aGl0ZVwiPjwvaT5cclxuICAgICAgICAgICAgICAgICAgICA8L2J1dHRvbj5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgPGJ1dHRvblxyXG4gICAgICAgICAgICAgICAgICAgICAgdHlwZT1cImJ1dHRvblwiXHJcbiAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJidG4gYnRuLWRhbmdlciBpY29uLWJ0biBiLXItNSBtLTFcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4gc29jaWFsTG9naW4oXCJnb29nbGVcIil9XHJcbiAgICAgICAgICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICAgICAgICAgICAgPGkgY2xhc3NOYW1lPVwidGkgdGktYnJhbmQtZ29vZ2xlIHRleHQtd2hpdGVcIj48L2k+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9idXR0b24+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIDxidXR0b25cclxuICAgICAgICAgICAgICAgICAgICAgIHR5cGU9XCJidXR0b25cIlxyXG4gICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiYnRuIGJ0bi1pbmZvIGljb24tYnRuIGItci01IG0tMVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiBzb2NpYWxMb2dpbihcImxpbmtlZGluX29pZGNcIil9XHJcbiAgICAgICAgICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICAgICAgICAgICAgPGkgY2xhc3NOYW1lPVwidGkgdGktYnJhbmQtbGlua2VkaW4gdGV4dC13aGl0ZVwiPjwvaT5cclxuICAgICAgICAgICAgICAgICAgICA8L2J1dHRvbj5cclxuICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcblxyXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ0ZXh0LWNlbnRlclwiPlxyXG4gICAgICAgICAgICAgICAgICA8c3Bhbj5Eb24mYXBvczt0IGhhdmUgYW4gYWNjb3VudD8gPC9zcGFuPlxyXG4gICAgICAgICAgICAgICAgICA8TGlua1xyXG4gICAgICAgICAgICAgICAgICAgIGhyZWY9XCIvYXV0aC9zaWdudXBcIlxyXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cImxpbmstcHJpbWFyeSB0ZXh0LWRlY29yYXRpb24tdW5kZXJsaW5lXCJcclxuICAgICAgICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICAgICAgICAgIFNpZ24gdXBcclxuICAgICAgICAgICAgICAgICAgPC9MaW5rPlxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcblxyXG4gICAgICAgICAgICAgIDwvZm9ybT5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8L0NvbD5cclxuICAgICAgPC9Sb3c+XHJcbiAgICA8L0NvbnRhaW5lcj5cclxuICApO1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgU2lnbkluQmc7XHJcbiJdLCJuYW1lcyI6WyJSZWFjdCIsInVzZVN0YXRlIiwiQ29sIiwiQ29udGFpbmVyIiwiUm93IiwiTGluayIsInVzZUF1dGgiLCJTaWduSW5CZyIsImxvZ2luIiwibG9hZGluZyIsInNvY2lhbExvZ2luIiwiZW1haWwiLCJzZXRFbWFpbCIsInBhc3N3b3JkIiwic2V0UGFzc3dvcmQiLCJlcnJvciIsInNldEVycm9yIiwiaGFuZGxlTG9naW4iLCJlIiwicHJldmVudERlZmF1bHQiLCJ3aW5kb3ciLCJsb2NhdGlvbiIsImhyZWYiLCJlcnIiLCJtZXNzYWdlIiwiZmx1aWQiLCJ4cyIsImNsYXNzTmFtZSIsImRpdiIsImltZyIsInNyYyIsImFsdCIsInN0eWxlIiwibWF4V2lkdGgiLCJoZWlnaHQiLCJmb3JtIiwib25TdWJtaXQiLCJoMyIsInAiLCJsYWJlbCIsImlucHV0IiwidHlwZSIsInBsYWNlaG9sZGVyIiwidmFsdWUiLCJvbkNoYW5nZSIsInRhcmdldCIsImlkIiwiaHRtbEZvciIsImJ1dHRvbiIsImRpc2FibGVkIiwib25DbGljayIsImkiLCJzcGFuIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./src/components/Pages/Auth_Pages/Sign_In_with_Bg_image/index.js\n");

/***/ }),

/***/ "(ssr)/./src/context/AuthContext.js":
/*!************************************!*\
  !*** ./src/context/AuthContext.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AuthProvider: () => (/* binding */ AuthProvider),\n/* harmony export */   useAuth: () => (/* binding */ useAuth)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _utils_supabaseClient__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/utils/supabaseClient */ \"(ssr)/./src/utils/supabaseClient.js\");\n/* __next_internal_client_entry_do_not_use__ AuthProvider,useAuth auto */ \n\n\nconst AuthContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)();\nconst AuthProvider = ({ children })=>{\n    const [user, setUser] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null); // full profile from backend\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);\n    // Load profile on mount\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"AuthProvider.useEffect\": ()=>{\n            fetchProfile();\n        }\n    }[\"AuthProvider.useEffect\"], []);\n    // ...\n    const fetchProfile = async ()=>{\n        try {\n            const res = await fetch(`/api/auth/me`, {\n                method: \"GET\",\n                credentials: \"include\"\n            });\n            if (res.ok) setUser(await res.json());\n            else setUser(null);\n        } catch (e) {\n            console.error(\"Profile fetch failed:\", e);\n            setUser(null);\n        } finally{\n            setLoading(false);\n        }\n    };\n    const login = async (email, password)=>{\n        setLoading(true);\n        try {\n            const res = await fetch(`/api/auth/login`, {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify({\n                    email,\n                    password\n                }),\n                credentials: \"include\"\n            });\n            const data = await res.json();\n            if (!res.ok) throw new Error(data.detail || \"Login failed\");\n            await fetchProfile();\n            return true;\n        } catch (err) {\n            console.error(\"Login error:\", err);\n            throw err;\n        } finally{\n            setLoading(false);\n        }\n    };\n    const logout = async ()=>{\n        try {\n            await fetch(`/api/auth/logout`, {\n                method: \"POST\",\n                credentials: \"include\"\n            });\n        } catch (e) {\n            console.error(\"Logout failed:\", e);\n        }\n        setUser(null);\n        window.location.href = \"/auth/login\";\n    };\n    const authedFetch = async (url, options = {})=>{\n        let res = await fetch(url.startsWith(\"/\") ? url : `/api${url}`, {\n            ...options,\n            credentials: \"include\"\n        });\n        if (res.status === 401) {\n            const refreshRes = await fetch(`/api/auth/refresh`, {\n                method: \"POST\",\n                credentials: \"include\"\n            });\n            if (refreshRes.ok) {\n                res = await fetch(url.startsWith(\"/\") ? url : `/api${url}`, {\n                    ...options,\n                    credentials: \"include\"\n                });\n            }\n        }\n        return res;\n    };\n    // Social login unchanged, but keep redirectTo same origin:\n    const socialLogin = async (provider)=>{\n        const { error } = await _utils_supabaseClient__WEBPACK_IMPORTED_MODULE_2__.supabase.auth.signInWithOAuth({\n            provider,\n            options: {\n                redirectTo: `${window.location.origin}/auth/callback`\n            }\n        });\n        if (error) throw error;\n    };\n    // ...\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(AuthContext.Provider, {\n        value: {\n            user,\n            loading,\n            login,\n            logout,\n            authedFetch,\n            fetchProfile,\n            socialLogin\n        },\n        children: children\n    }, void 0, false, {\n        fileName: \"D:\\\\next\\\\org\\\\src\\\\context\\\\AuthContext.js\",\n        lineNumber: 91,\n        columnNumber: 5\n    }, undefined);\n};\nconst useAuth = ()=>(0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(AuthContext);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9zcmMvY29udGV4dC9BdXRoQ29udGV4dC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUM4RTtBQUM1QjtBQUVsRCxNQUFNTSw0QkFBY0wsb0RBQWFBO0FBRTFCLE1BQU1NLGVBQWUsQ0FBQyxFQUFFQyxRQUFRLEVBQUU7SUFDdkMsTUFBTSxDQUFDQyxNQUFNQyxRQUFRLEdBQUdOLCtDQUFRQSxDQUFDLE9BQVMsNEJBQTRCO0lBQ3RFLE1BQU0sQ0FBQ08sU0FBU0MsV0FBVyxHQUFHUiwrQ0FBUUEsQ0FBQztJQUV2Qyx3QkFBd0I7SUFDeEJELGdEQUFTQTtrQ0FBQztZQUNSVTtRQUNGO2lDQUFHLEVBQUU7SUFHTCxNQUFNO0lBQ1IsTUFBTUEsZUFBZTtRQUNuQixJQUFJO1lBQ0YsTUFBTUMsTUFBTSxNQUFNQyxNQUFNLENBQUMsWUFBWSxDQUFDLEVBQUU7Z0JBQUVDLFFBQVE7Z0JBQU9DLGFBQWE7WUFBVTtZQUNoRixJQUFJSCxJQUFJSSxFQUFFLEVBQUVSLFFBQVEsTUFBTUksSUFBSUssSUFBSTtpQkFDN0JULFFBQVE7UUFDZixFQUFFLE9BQU9VLEdBQUc7WUFDVkMsUUFBUUMsS0FBSyxDQUFDLHlCQUF5QkY7WUFDdkNWLFFBQVE7UUFDVixTQUFVO1lBQ1JFLFdBQVc7UUFDYjtJQUNGO0lBRUEsTUFBTVcsUUFBUSxPQUFPQyxPQUFPQztRQUMxQmIsV0FBVztRQUNYLElBQUk7WUFDRixNQUFNRSxNQUFNLE1BQU1DLE1BQU0sQ0FBQyxlQUFlLENBQUMsRUFBRTtnQkFDekNDLFFBQVE7Z0JBQ1JVLFNBQVM7b0JBQUUsZ0JBQWdCO2dCQUFtQjtnQkFDOUNDLE1BQU1DLEtBQUtDLFNBQVMsQ0FBQztvQkFBRUw7b0JBQU9DO2dCQUFTO2dCQUN2Q1IsYUFBYTtZQUNmO1lBQ0EsTUFBTWEsT0FBTyxNQUFNaEIsSUFBSUssSUFBSTtZQUMzQixJQUFJLENBQUNMLElBQUlJLEVBQUUsRUFBRSxNQUFNLElBQUlhLE1BQU1ELEtBQUtFLE1BQU0sSUFBSTtZQUM1QyxNQUFNbkI7WUFDTixPQUFPO1FBQ1QsRUFBRSxPQUFPb0IsS0FBSztZQUNaWixRQUFRQyxLQUFLLENBQUMsZ0JBQWdCVztZQUM5QixNQUFNQTtRQUNSLFNBQVU7WUFDUnJCLFdBQVc7UUFDYjtJQUNGO0lBRUEsTUFBTXNCLFNBQVM7UUFDYixJQUFJO1lBQ0YsTUFBTW5CLE1BQU0sQ0FBQyxnQkFBZ0IsQ0FBQyxFQUFFO2dCQUFFQyxRQUFRO2dCQUFRQyxhQUFhO1lBQVU7UUFDM0UsRUFBRSxPQUFPRyxHQUFHO1lBQ1ZDLFFBQVFDLEtBQUssQ0FBQyxrQkFBa0JGO1FBQ2xDO1FBQ0FWLFFBQVE7UUFDUnlCLE9BQU9DLFFBQVEsQ0FBQ0MsSUFBSSxHQUFHO0lBQ3pCO0lBRUEsTUFBTUMsY0FBYyxPQUFPQyxLQUFLQyxVQUFVLENBQUMsQ0FBQztRQUMxQyxJQUFJMUIsTUFBTSxNQUFNQyxNQUFNd0IsSUFBSUUsVUFBVSxDQUFDLE9BQU9GLE1BQU0sQ0FBQyxJQUFJLEVBQUVBLEtBQUssRUFBRTtZQUM5RCxHQUFHQyxPQUFPO1lBQ1Z2QixhQUFhO1FBQ2Y7UUFDQSxJQUFJSCxJQUFJNEIsTUFBTSxLQUFLLEtBQUs7WUFDdEIsTUFBTUMsYUFBYSxNQUFNNUIsTUFBTSxDQUFDLGlCQUFpQixDQUFDLEVBQUU7Z0JBQUVDLFFBQVE7Z0JBQVFDLGFBQWE7WUFBVTtZQUM3RixJQUFJMEIsV0FBV3pCLEVBQUUsRUFBRTtnQkFDakJKLE1BQU0sTUFBTUMsTUFBTXdCLElBQUlFLFVBQVUsQ0FBQyxPQUFPRixNQUFNLENBQUMsSUFBSSxFQUFFQSxLQUFLLEVBQUU7b0JBQzFELEdBQUdDLE9BQU87b0JBQ1Z2QixhQUFhO2dCQUNmO1lBQ0Y7UUFDRjtRQUNBLE9BQU9IO0lBQ1Q7SUFFQSwyREFBMkQ7SUFDM0QsTUFBTThCLGNBQWMsT0FBT0M7UUFDekIsTUFBTSxFQUFFdkIsS0FBSyxFQUFFLEdBQUcsTUFBTWpCLDJEQUFRQSxDQUFDeUMsSUFBSSxDQUFDQyxlQUFlLENBQUM7WUFDcERGO1lBQ0FMLFNBQVM7Z0JBQUVRLFlBQVksR0FBR2IsT0FBT0MsUUFBUSxDQUFDYSxNQUFNLENBQUMsY0FBYyxDQUFDO1lBQUM7UUFDbkU7UUFDQSxJQUFJM0IsT0FBTyxNQUFNQTtJQUNuQjtJQUNBLE1BQU07SUFHSixxQkFDRSw4REFBQ2hCLFlBQVk0QyxRQUFRO1FBQ25CQyxPQUFPO1lBQ0wxQztZQUNBRTtZQUNBWTtZQUNBVztZQUNBSTtZQUNBekI7WUFDQStCO1FBQ0Y7a0JBRUNwQzs7Ozs7O0FBR1AsRUFBRTtBQUVLLE1BQU00QyxVQUFVLElBQU1sRCxpREFBVUEsQ0FBQ0ksYUFBYSIsInNvdXJjZXMiOlsiRDpcXG5leHRcXG9yZ1xcc3JjXFxjb250ZXh0XFxBdXRoQ29udGV4dC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIjtcclxuaW1wb3J0IFJlYWN0LCB7IGNyZWF0ZUNvbnRleHQsIHVzZUNvbnRleHQsIHVzZUVmZmVjdCwgdXNlU3RhdGUgfSBmcm9tIFwicmVhY3RcIjtcclxuaW1wb3J0IHsgc3VwYWJhc2UgfSBmcm9tIFwiQC91dGlscy9zdXBhYmFzZUNsaWVudFwiO1xyXG5cclxuY29uc3QgQXV0aENvbnRleHQgPSBjcmVhdGVDb250ZXh0KCk7XHJcblxyXG5leHBvcnQgY29uc3QgQXV0aFByb3ZpZGVyID0gKHsgY2hpbGRyZW4gfSkgPT4ge1xyXG4gIGNvbnN0IFt1c2VyLCBzZXRVc2VyXSA9IHVzZVN0YXRlKG51bGwpOyAgIC8vIGZ1bGwgcHJvZmlsZSBmcm9tIGJhY2tlbmRcclxuICBjb25zdCBbbG9hZGluZywgc2V0TG9hZGluZ10gPSB1c2VTdGF0ZSh0cnVlKTtcclxuXHJcbiAgLy8gTG9hZCBwcm9maWxlIG9uIG1vdW50XHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIGZldGNoUHJvZmlsZSgpO1xyXG4gIH0sIFtdKTtcclxuXHJcblxyXG4gIC8vIC4uLlxyXG5jb25zdCBmZXRjaFByb2ZpbGUgPSBhc3luYyAoKSA9PiB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKGAvYXBpL2F1dGgvbWVgLCB7IG1ldGhvZDogXCJHRVRcIiwgY3JlZGVudGlhbHM6IFwiaW5jbHVkZVwiIH0pO1xyXG4gICAgaWYgKHJlcy5vaykgc2V0VXNlcihhd2FpdCByZXMuanNvbigpKTtcclxuICAgIGVsc2Ugc2V0VXNlcihudWxsKTtcclxuICB9IGNhdGNoIChlKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKFwiUHJvZmlsZSBmZXRjaCBmYWlsZWQ6XCIsIGUpO1xyXG4gICAgc2V0VXNlcihudWxsKTtcclxuICB9IGZpbmFsbHkge1xyXG4gICAgc2V0TG9hZGluZyhmYWxzZSk7XHJcbiAgfVxyXG59O1xyXG5cclxuY29uc3QgbG9naW4gPSBhc3luYyAoZW1haWwsIHBhc3N3b3JkKSA9PiB7XHJcbiAgc2V0TG9hZGluZyh0cnVlKTtcclxuICB0cnkge1xyXG4gICAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2goYC9hcGkvYXV0aC9sb2dpbmAsIHtcclxuICAgICAgbWV0aG9kOiBcIlBPU1RcIixcclxuICAgICAgaGVhZGVyczogeyBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LFxyXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IGVtYWlsLCBwYXNzd29yZCB9KSxcclxuICAgICAgY3JlZGVudGlhbHM6IFwiaW5jbHVkZVwiLFxyXG4gICAgfSk7XHJcbiAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzLmpzb24oKTtcclxuICAgIGlmICghcmVzLm9rKSB0aHJvdyBuZXcgRXJyb3IoZGF0YS5kZXRhaWwgfHwgXCJMb2dpbiBmYWlsZWRcIik7XHJcbiAgICBhd2FpdCBmZXRjaFByb2ZpbGUoKTtcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH0gY2F0Y2ggKGVycikge1xyXG4gICAgY29uc29sZS5lcnJvcihcIkxvZ2luIGVycm9yOlwiLCBlcnIpO1xyXG4gICAgdGhyb3cgZXJyO1xyXG4gIH0gZmluYWxseSB7XHJcbiAgICBzZXRMb2FkaW5nKGZhbHNlKTtcclxuICB9XHJcbn07XHJcblxyXG5jb25zdCBsb2dvdXQgPSBhc3luYyAoKSA9PiB7XHJcbiAgdHJ5IHtcclxuICAgIGF3YWl0IGZldGNoKGAvYXBpL2F1dGgvbG9nb3V0YCwgeyBtZXRob2Q6IFwiUE9TVFwiLCBjcmVkZW50aWFsczogXCJpbmNsdWRlXCIgfSk7XHJcbiAgfSBjYXRjaCAoZSkge1xyXG4gICAgY29uc29sZS5lcnJvcihcIkxvZ291dCBmYWlsZWQ6XCIsIGUpO1xyXG4gIH1cclxuICBzZXRVc2VyKG51bGwpO1xyXG4gIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gXCIvYXV0aC9sb2dpblwiO1xyXG59O1xyXG5cclxuY29uc3QgYXV0aGVkRmV0Y2ggPSBhc3luYyAodXJsLCBvcHRpb25zID0ge30pID0+IHtcclxuICBsZXQgcmVzID0gYXdhaXQgZmV0Y2godXJsLnN0YXJ0c1dpdGgoXCIvXCIpID8gdXJsIDogYC9hcGkke3VybH1gLCB7XHJcbiAgICAuLi5vcHRpb25zLFxyXG4gICAgY3JlZGVudGlhbHM6IFwiaW5jbHVkZVwiLFxyXG4gIH0pO1xyXG4gIGlmIChyZXMuc3RhdHVzID09PSA0MDEpIHtcclxuICAgIGNvbnN0IHJlZnJlc2hSZXMgPSBhd2FpdCBmZXRjaChgL2FwaS9hdXRoL3JlZnJlc2hgLCB7IG1ldGhvZDogXCJQT1NUXCIsIGNyZWRlbnRpYWxzOiBcImluY2x1ZGVcIiB9KTtcclxuICAgIGlmIChyZWZyZXNoUmVzLm9rKSB7XHJcbiAgICAgIHJlcyA9IGF3YWl0IGZldGNoKHVybC5zdGFydHNXaXRoKFwiL1wiKSA/IHVybCA6IGAvYXBpJHt1cmx9YCwge1xyXG4gICAgICAgIC4uLm9wdGlvbnMsXHJcbiAgICAgICAgY3JlZGVudGlhbHM6IFwiaW5jbHVkZVwiLFxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIHJlcztcclxufTtcclxuXHJcbi8vIFNvY2lhbCBsb2dpbiB1bmNoYW5nZWQsIGJ1dCBrZWVwIHJlZGlyZWN0VG8gc2FtZSBvcmlnaW46XHJcbmNvbnN0IHNvY2lhbExvZ2luID0gYXN5bmMgKHByb3ZpZGVyKSA9PiB7XHJcbiAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2UuYXV0aC5zaWduSW5XaXRoT0F1dGgoe1xyXG4gICAgcHJvdmlkZXIsXHJcbiAgICBvcHRpb25zOiB7IHJlZGlyZWN0VG86IGAke3dpbmRvdy5sb2NhdGlvbi5vcmlnaW59L2F1dGgvY2FsbGJhY2tgIH0sXHJcbiAgfSk7XHJcbiAgaWYgKGVycm9yKSB0aHJvdyBlcnJvcjtcclxufTtcclxuLy8gLi4uXHJcblxyXG5cclxuICByZXR1cm4gKFxyXG4gICAgPEF1dGhDb250ZXh0LlByb3ZpZGVyXHJcbiAgICAgIHZhbHVlPXt7XHJcbiAgICAgICAgdXNlciwgICAgICAgIC8vIGZ1bGwgcHJvZmlsZSBmcm9tIC9hdXRoL21lXHJcbiAgICAgICAgbG9hZGluZyxcclxuICAgICAgICBsb2dpbixcclxuICAgICAgICBsb2dvdXQsXHJcbiAgICAgICAgYXV0aGVkRmV0Y2gsXHJcbiAgICAgICAgZmV0Y2hQcm9maWxlLFxyXG4gICAgICAgIHNvY2lhbExvZ2luLCAvLyA8LSBuZXdcclxuICAgICAgfX1cclxuICAgID5cclxuICAgICAge2NoaWxkcmVufVxyXG4gICAgPC9BdXRoQ29udGV4dC5Qcm92aWRlcj5cclxuICApO1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IHVzZUF1dGggPSAoKSA9PiB1c2VDb250ZXh0KEF1dGhDb250ZXh0KTtcclxuIl0sIm5hbWVzIjpbIlJlYWN0IiwiY3JlYXRlQ29udGV4dCIsInVzZUNvbnRleHQiLCJ1c2VFZmZlY3QiLCJ1c2VTdGF0ZSIsInN1cGFiYXNlIiwiQXV0aENvbnRleHQiLCJBdXRoUHJvdmlkZXIiLCJjaGlsZHJlbiIsInVzZXIiLCJzZXRVc2VyIiwibG9hZGluZyIsInNldExvYWRpbmciLCJmZXRjaFByb2ZpbGUiLCJyZXMiLCJmZXRjaCIsIm1ldGhvZCIsImNyZWRlbnRpYWxzIiwib2siLCJqc29uIiwiZSIsImNvbnNvbGUiLCJlcnJvciIsImxvZ2luIiwiZW1haWwiLCJwYXNzd29yZCIsImhlYWRlcnMiLCJib2R5IiwiSlNPTiIsInN0cmluZ2lmeSIsImRhdGEiLCJFcnJvciIsImRldGFpbCIsImVyciIsImxvZ291dCIsIndpbmRvdyIsImxvY2F0aW9uIiwiaHJlZiIsImF1dGhlZEZldGNoIiwidXJsIiwib3B0aW9ucyIsInN0YXJ0c1dpdGgiLCJzdGF0dXMiLCJyZWZyZXNoUmVzIiwic29jaWFsTG9naW4iLCJwcm92aWRlciIsImF1dGgiLCJzaWduSW5XaXRoT0F1dGgiLCJyZWRpcmVjdFRvIiwib3JpZ2luIiwiUHJvdmlkZXIiLCJ2YWx1ZSIsInVzZUF1dGgiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./src/context/AuthContext.js\n");

/***/ }),

/***/ "(ssr)/./src/scss/responsive.scss":
/*!**********************************!*\
  !*** ./src/scss/responsive.scss ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"c0eb5e010522\");\nif (false) {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9zcmMvc2Nzcy9yZXNwb25zaXZlLnNjc3MiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLGlFQUFlLGNBQWM7QUFDN0IsSUFBSSxLQUFVLEVBQUUsRUFBdUIiLCJzb3VyY2VzIjpbIkQ6XFxuZXh0XFxvcmdcXHNyY1xcc2Nzc1xccmVzcG9uc2l2ZS5zY3NzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IFwiYzBlYjVlMDEwNTIyXCJcbmlmIChtb2R1bGUuaG90KSB7IG1vZHVsZS5ob3QuYWNjZXB0KCkgfVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./src/scss/responsive.scss\n");

/***/ }),

/***/ "(ssr)/./src/scss/style.scss":
/*!*****************************!*\
  !*** ./src/scss/style.scss ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"1c86bb57e2a7\");\nif (false) {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9zcmMvc2Nzcy9zdHlsZS5zY3NzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxpRUFBZSxjQUFjO0FBQzdCLElBQUksS0FBVSxFQUFFLEVBQXVCIiwic291cmNlcyI6WyJEOlxcbmV4dFxcb3JnXFxzcmNcXHNjc3NcXHN0eWxlLnNjc3MiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgXCIxYzg2YmI1N2UyYTdcIlxuaWYgKG1vZHVsZS5ob3QpIHsgbW9kdWxlLmhvdC5hY2NlcHQoKSB9XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./src/scss/style.scss\n");

/***/ }),

/***/ "(ssr)/./src/utils/Bootstrap/BootstrapClient.js":
/*!************************************************!*\
  !*** ./src/utils/Bootstrap/BootstrapClient.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* __next_internal_client_entry_do_not_use__ default auto */ \nconst BootstrapClient = ()=>{\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"BootstrapClient.useEffect\": ()=>{\n            Promise.all(/*! import() */[__webpack_require__.e(\"vendor-chunks/jquery\"), __webpack_require__.e(\"_ssr_src_vendor_bootstrap_bootstrap_bundle_min_js\")]).then(__webpack_require__.t.bind(__webpack_require__, /*! ../../vendor/bootstrap/bootstrap.bundle.min.js */ \"(ssr)/./src/vendor/bootstrap/bootstrap.bundle.min.js\", 23));\n            Promise.all(/*! import() */[__webpack_require__.e(\"vendor-chunks/jquery\"), __webpack_require__.e(\"_ssr_src_vendor_vector-map_jquery-jvectormap-2_0_5_min_js\")]).then(__webpack_require__.t.bind(__webpack_require__, /*! ../../vendor/vector-map/jquery-jvectormap-2.0.5.min */ \"(ssr)/./src/vendor/vector-map/jquery-jvectormap-2.0.5.min.js\", 23));\n            Promise.all(/*! import() */[__webpack_require__.e(\"vendor-chunks/jquery\"), __webpack_require__.e(\"_ssr_src_vendor_datatable_jquery_dataTables_min_js\")]).then(__webpack_require__.t.bind(__webpack_require__, /*! ../../vendor/datatable/jquery.dataTables.min.js */ \"(ssr)/./src/vendor/datatable/jquery.dataTables.min.js\", 23));\n            Promise.all(/*! import() */[__webpack_require__.e(\"vendor-chunks/jquery\"), __webpack_require__.e(\"_ssr_src_vendor_trumbowyg_trumbowyg_min_js\")]).then(__webpack_require__.t.bind(__webpack_require__, /*! ../../vendor/trumbowyg/trumbowyg.min */ \"(ssr)/./src/vendor/trumbowyg/trumbowyg.min.js\", 23));\n            Promise.all(/*! import() */[__webpack_require__.e(\"vendor-chunks/jquery\"), __webpack_require__.e(\"_ssr_src_vendor_listJs_list-jquery_min_js\")]).then(__webpack_require__.t.bind(__webpack_require__, /*! ../../vendor/listJs/list-jquery.min */ \"(ssr)/./src/vendor/listJs/list-jquery.min.js\", 23));\n            __webpack_require__.e(/*! import() */ \"_ssr_src_vendor_listJs_list_min_js\").then(__webpack_require__.t.bind(__webpack_require__, /*! ../../vendor/listJs/list.min */ \"(ssr)/./src/vendor/listJs/list.min.js\", 23));\n            setTimeout({\n                \"BootstrapClient.useEffect\": ()=>{\n                    Promise.all(/*! import() */[__webpack_require__.e(\"vendor-chunks/jquery\"), __webpack_require__.e(\"_ssr_src_vendor_vector-map_jquery-jvectormap-world-mill_js\")]).then(__webpack_require__.t.bind(__webpack_require__, /*! ../../vendor/vector-map/jquery-jvectormap-world-mill */ \"(ssr)/./src/vendor/vector-map/jquery-jvectormap-world-mill.js\", 23));\n                    Promise.all(/*! import() */[__webpack_require__.e(\"vendor-chunks/jquery\"), __webpack_require__.e(\"_ssr_src_vendor_vector-map_africa-mill_js\")]).then(__webpack_require__.t.bind(__webpack_require__, /*! ../../vendor/vector-map/africa-mill */ \"(ssr)/./src/vendor/vector-map/africa-mill.js\", 23));\n                    Promise.all(/*! import() */[__webpack_require__.e(\"vendor-chunks/jquery\"), __webpack_require__.e(\"_ssr_src_vendor_vector-map_asia-mill_js\")]).then(__webpack_require__.t.bind(__webpack_require__, /*! ../../vendor/vector-map/asia-mill */ \"(ssr)/./src/vendor/vector-map/asia-mill.js\", 23));\n                    Promise.all(/*! import() */[__webpack_require__.e(\"vendor-chunks/jquery\"), __webpack_require__.e(\"_ssr_src_vendor_vector-map_ru-mill_js\")]).then(__webpack_require__.t.bind(__webpack_require__, /*! ../../vendor/vector-map/ru-mill */ \"(ssr)/./src/vendor/vector-map/ru-mill.js\", 23));\n                    Promise.all(/*! import() */[__webpack_require__.e(\"vendor-chunks/jquery\"), __webpack_require__.e(\"_ssr_src_vendor_vector-map_europe-mill_js\")]).then(__webpack_require__.t.bind(__webpack_require__, /*! ../../vendor/vector-map/europe-mill */ \"(ssr)/./src/vendor/vector-map/europe-mill.js\", 23));\n                    Promise.all(/*! import() */[__webpack_require__.e(\"vendor-chunks/jquery\"), __webpack_require__.e(\"_ssr_src_vendor_vector-map_jquery-jvectormap-us-lcc_js\")]).then(__webpack_require__.t.bind(__webpack_require__, /*! ../../vendor/vector-map/jquery-jvectormap-us-lcc */ \"(ssr)/./src/vendor/vector-map/jquery-jvectormap-us-lcc.js\", 23));\n                    Promise.all(/*! import() */[__webpack_require__.e(\"vendor-chunks/jquery\"), __webpack_require__.e(\"_ssr_src_vendor_vector-map_uk_countries-mill_js\")]).then(__webpack_require__.t.bind(__webpack_require__, /*! ../../vendor/vector-map/uk_countries-mill */ \"(ssr)/./src/vendor/vector-map/uk_countries-mill.js\", 23));\n                    Promise.all(/*! import() */[__webpack_require__.e(\"vendor-chunks/jquery\"), __webpack_require__.e(\"_ssr_src_vendor_vector-map_jvectormap-es-mill_js\")]).then(__webpack_require__.t.bind(__webpack_require__, /*! ../../vendor/vector-map/jvectormap-es-mill */ \"(ssr)/./src/vendor/vector-map/jvectormap-es-mill.js\", 23));\n                }\n            }[\"BootstrapClient.useEffect\"], 500);\n            Promise.all(/*! import() */[__webpack_require__.e(\"vendor-chunks/jquery\"), __webpack_require__.e(\"_ssr_src_vendor_select_select2_min_js\")]).then(__webpack_require__.t.bind(__webpack_require__, /*! ../../vendor/select/select2.min.js */ \"(ssr)/./src/vendor/select/select2.min.js\", 23));\n            __webpack_require__.e(/*! import() */ \"_ssr_src_vendor_phosphor_phosphor_js\").then(__webpack_require__.t.bind(__webpack_require__, /*! ../../vendor/phosphor/phosphor.js */ \"(ssr)/./src/vendor/phosphor/phosphor.js\", 23));\n            __webpack_require__.e(/*! import() */ \"_ssr_src_vendor_animated_icon_iconify-icon_min_js\").then(__webpack_require__.t.bind(__webpack_require__, /*! ../../vendor/animated_icon/iconify-icon.min */ \"(ssr)/./src/vendor/animated_icon/iconify-icon.min.js\", 23));\n            Promise.all(/*! import() */[__webpack_require__.e(\"vendor-chunks/jquery\"), __webpack_require__.e(\"_ssr_src_vendor_block-ui_jquery_blockUI_js\")]).then(__webpack_require__.t.bind(__webpack_require__, /*! ../../vendor/block-ui/jquery.blockUI */ \"(ssr)/./src/vendor/block-ui/jquery.blockUI.js\", 23));\n            __webpack_require__.e(/*! import() */ \"_ssr_src_vendor_dual_listboxes_dual-listbox_js\").then(__webpack_require__.t.bind(__webpack_require__, /*! ../../vendor/dual_listboxes/dual-listbox */ \"(ssr)/./src/vendor/dual_listboxes/dual-listbox.js\", 23));\n            Promise.all(/*! import() */[__webpack_require__.e(\"vendor-chunks/jquery\"), __webpack_require__.e(\"_ssr_src_vendor_googlemap_gmaps_js\")]).then(__webpack_require__.t.bind(__webpack_require__, /*! ../../vendor/googlemap/gmaps */ \"(ssr)/./src/vendor/googlemap/gmaps.js\", 23));\n            __webpack_require__.e(/*! import() */ \"_ssr_src_vendor_googlemap_google_js\").then(__webpack_require__.t.bind(__webpack_require__, /*! ../../vendor/googlemap/google */ \"(ssr)/./src/vendor/googlemap/google.js\", 23));\n            __webpack_require__.e(/*! import() */ \"_ssr_src_components_Forms_Elements_Dual_List_Boxes_initDataListBox_js\").then(__webpack_require__.bind(__webpack_require__, /*! ../../components/Forms_Elements/Dual_List_Boxes/initDataListBox */ \"(ssr)/./src/components/Forms_Elements/Dual_List_Boxes/initDataListBox.js\"));\n            Promise.all(/*! import() */[__webpack_require__.e(\"vendor-chunks/jquery\"), __webpack_require__.e(\"_ssr_src_utils_CommonJs_index_js\")]).then(__webpack_require__.t.bind(__webpack_require__, /*! ../CommonJs/index */ \"(ssr)/./src/utils/CommonJs/index.js\", 23));\n        }\n    }[\"BootstrapClient.useEffect\"], []);\n    return null;\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (BootstrapClient);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9zcmMvdXRpbHMvQm9vdHN0cmFwL0Jvb3RzdHJhcENsaWVudC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7NkRBRWtDO0FBRWxDLE1BQU1DLGtCQUFrQjtJQUNwQkQsZ0RBQVNBO3FDQUFDO1lBQ04sK1RBQXdEO1lBQ3hELG9WQUE2RDtZQUM3RCxrVUFBeUQ7WUFDekQsdVNBQThDO1lBQzlDLG9TQUE2QztZQUM3QyxrTkFBc0M7WUFDdENFOzZDQUFXO29CQUNQLHVWQUE4RDtvQkFDOUQsb1NBQTZDO29CQUM3Qyw4UkFBMkM7b0JBQzNDLHdSQUF5QztvQkFDekMsb1NBQTZDO29CQUM3QywyVUFBMEQ7b0JBQzFELHNUQUFtRDtvQkFDbkQseVRBQW9EO2dCQUN4RDs0Q0FBRztZQUNILDJSQUE0QztZQUM1QywyTkFBMkM7WUFDM0MsK1BBQXFEO1lBQ3JELHVTQUE4QztZQUM5QyxzUEFBa0Q7WUFDbEQsK1FBQXNDO1lBQ3RDLHFOQUF1QztZQUN2QyxxVEFBeUU7WUFDekUsZ1FBQTJCO1FBQy9CO29DQUFHLEVBQUU7SUFFTCxPQUFPO0FBQ1g7QUFFQSxpRUFBZUQsZUFBZUEsRUFBQyIsInNvdXJjZXMiOlsiRDpcXG5leHRcXG9yZ1xcc3JjXFx1dGlsc1xcQm9vdHN0cmFwXFxCb290c3RyYXBDbGllbnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCI7XHJcblxyXG5pbXBvcnQgeyB1c2VFZmZlY3QgfSBmcm9tIFwicmVhY3RcIjtcclxuXHJcbmNvbnN0IEJvb3RzdHJhcENsaWVudCA9ICgpID0+IHtcclxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgaW1wb3J0KFwiLi4vLi4vdmVuZG9yL2Jvb3RzdHJhcC9ib290c3RyYXAuYnVuZGxlLm1pbi5qc1wiKTtcclxuICAgICAgICBpbXBvcnQoJy4uLy4uL3ZlbmRvci92ZWN0b3ItbWFwL2pxdWVyeS1qdmVjdG9ybWFwLTIuMC41Lm1pbicpO1xyXG4gICAgICAgIGltcG9ydChcIi4uLy4uL3ZlbmRvci9kYXRhdGFibGUvanF1ZXJ5LmRhdGFUYWJsZXMubWluLmpzXCIpO1xyXG4gICAgICAgIGltcG9ydChcIi4uLy4uL3ZlbmRvci90cnVtYm93eWcvdHJ1bWJvd3lnLm1pblwiKTtcclxuICAgICAgICBpbXBvcnQoXCIuLi8uLi92ZW5kb3IvbGlzdEpzL2xpc3QtanF1ZXJ5Lm1pblwiKTtcclxuICAgICAgICBpbXBvcnQoXCIuLi8uLi92ZW5kb3IvbGlzdEpzL2xpc3QubWluXCIpO1xyXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICBpbXBvcnQoJy4uLy4uL3ZlbmRvci92ZWN0b3ItbWFwL2pxdWVyeS1qdmVjdG9ybWFwLXdvcmxkLW1pbGwnKTtcclxuICAgICAgICAgICAgaW1wb3J0KCcuLi8uLi92ZW5kb3IvdmVjdG9yLW1hcC9hZnJpY2EtbWlsbCcpO1xyXG4gICAgICAgICAgICBpbXBvcnQoJy4uLy4uL3ZlbmRvci92ZWN0b3ItbWFwL2FzaWEtbWlsbCcpO1xyXG4gICAgICAgICAgICBpbXBvcnQoJy4uLy4uL3ZlbmRvci92ZWN0b3ItbWFwL3J1LW1pbGwnKTtcclxuICAgICAgICAgICAgaW1wb3J0KCcuLi8uLi92ZW5kb3IvdmVjdG9yLW1hcC9ldXJvcGUtbWlsbCcpO1xyXG4gICAgICAgICAgICBpbXBvcnQoJy4uLy4uL3ZlbmRvci92ZWN0b3ItbWFwL2pxdWVyeS1qdmVjdG9ybWFwLXVzLWxjYycpO1xyXG4gICAgICAgICAgICBpbXBvcnQoJy4uLy4uL3ZlbmRvci92ZWN0b3ItbWFwL3VrX2NvdW50cmllcy1taWxsJyk7XHJcbiAgICAgICAgICAgIGltcG9ydCgnLi4vLi4vdmVuZG9yL3ZlY3Rvci1tYXAvanZlY3Rvcm1hcC1lcy1taWxsJyk7XHJcbiAgICAgICAgfSwgNTAwKVxyXG4gICAgICAgIGltcG9ydChcIi4uLy4uL3ZlbmRvci9zZWxlY3Qvc2VsZWN0Mi5taW4uanNcIik7XHJcbiAgICAgICAgaW1wb3J0KFwiLi4vLi4vdmVuZG9yL3Bob3NwaG9yL3Bob3NwaG9yLmpzXCIpO1xyXG4gICAgICAgIGltcG9ydChcIi4uLy4uL3ZlbmRvci9hbmltYXRlZF9pY29uL2ljb25pZnktaWNvbi5taW5cIik7XHJcbiAgICAgICAgaW1wb3J0KCcuLi8uLi92ZW5kb3IvYmxvY2stdWkvanF1ZXJ5LmJsb2NrVUknKTtcclxuICAgICAgICBpbXBvcnQoJy4uLy4uL3ZlbmRvci9kdWFsX2xpc3Rib3hlcy9kdWFsLWxpc3Rib3gnKTtcclxuICAgICAgICBpbXBvcnQoJy4uLy4uL3ZlbmRvci9nb29nbGVtYXAvZ21hcHMnKTtcclxuICAgICAgICBpbXBvcnQoJy4uLy4uL3ZlbmRvci9nb29nbGVtYXAvZ29vZ2xlJyk7XHJcbiAgICAgICAgaW1wb3J0KFwiLi4vLi4vY29tcG9uZW50cy9Gb3Jtc19FbGVtZW50cy9EdWFsX0xpc3RfQm94ZXMvaW5pdERhdGFMaXN0Qm94XCIpO1xyXG4gICAgICAgIGltcG9ydChcIi4uL0NvbW1vbkpzL2luZGV4XCIpXHJcbiAgICB9LCBbXSk7XHJcblxyXG4gICAgcmV0dXJuIG51bGw7XHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBCb290c3RyYXBDbGllbnQ7Il0sIm5hbWVzIjpbInVzZUVmZmVjdCIsIkJvb3RzdHJhcENsaWVudCIsInNldFRpbWVvdXQiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./src/utils/Bootstrap/BootstrapClient.js\n");

/***/ }),

/***/ "(ssr)/./src/utils/supabaseClient.js":
/*!*************************************!*\
  !*** ./src/utils/supabaseClient.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   supabase: () => (/* binding */ supabase)\n/* harmony export */ });\n/* harmony import */ var _supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @supabase/supabase-js */ \"(ssr)/./node_modules/@supabase/supabase-js/dist/module/index.js\");\n\nconst supabase = (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__.createClient)(\"https://fazmwdhhessljlyxndee.supabase.co\", \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImZhem13ZGhoZXNzbGpseXhuZGVlIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTgyNjUyNzcsImV4cCI6MjA3Mzg0MTI3N30.eqb4M8SnT6HA0wL2Kr3DPCLOAeERkDo86xwX1XMtxSs\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9zcmMvdXRpbHMvc3VwYWJhc2VDbGllbnQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBcUQ7QUFFOUMsTUFBTUMsV0FBV0QsbUVBQVlBLENBQ2xDRSwwQ0FBb0MsRUFDcENBLGtOQUF5QyxFQUN6QyIsInNvdXJjZXMiOlsiRDpcXG5leHRcXG9yZ1xcc3JjXFx1dGlsc1xcc3VwYWJhc2VDbGllbnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY3JlYXRlQ2xpZW50IH0gZnJvbSBcIkBzdXBhYmFzZS9zdXBhYmFzZS1qc1wiO1xyXG5cclxuZXhwb3J0IGNvbnN0IHN1cGFiYXNlID0gY3JlYXRlQ2xpZW50KFxyXG4gIHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1NVUEFCQVNFX1VSTCxcclxuICBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19TVVBBQkFTRV9BTk9OX0tFWVxyXG4pO1xyXG4iXSwibmFtZXMiOlsiY3JlYXRlQ2xpZW50Iiwic3VwYWJhc2UiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfU1VQQUJBU0VfVVJMIiwiTkVYVF9QVUJMSUNfU1VQQUJBU0VfQU5PTl9LRVkiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./src/utils/supabaseClient.js\n");

/***/ }),

/***/ "(ssr)/./src/vendor/animated_icon/mdi-light.css":
/*!************************************************!*\
  !*** ./src/vendor/animated_icon/mdi-light.css ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"2f497456dd18\");\nif (false) {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9zcmMvdmVuZG9yL2FuaW1hdGVkX2ljb24vbWRpLWxpZ2h0LmNzcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsaUVBQWUsY0FBYztBQUM3QixJQUFJLEtBQVUsRUFBRSxFQUF1QiIsInNvdXJjZXMiOlsiRDpcXG5leHRcXG9yZ1xcc3JjXFx2ZW5kb3JcXGFuaW1hdGVkX2ljb25cXG1kaS1saWdodC5jc3MiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgXCIyZjQ5NzQ1NmRkMThcIlxuaWYgKG1vZHVsZS5ob3QpIHsgbW9kdWxlLmhvdC5hY2NlcHQoKSB9XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./src/vendor/animated_icon/mdi-light.css\n");

/***/ }),

/***/ "(ssr)/./src/vendor/animation/animate.min.css":
/*!**********************************************!*\
  !*** ./src/vendor/animation/animate.min.css ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"bc96496831f4\");\nif (false) {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9zcmMvdmVuZG9yL2FuaW1hdGlvbi9hbmltYXRlLm1pbi5jc3MiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLGlFQUFlLGNBQWM7QUFDN0IsSUFBSSxLQUFVLEVBQUUsRUFBdUIiLCJzb3VyY2VzIjpbIkQ6XFxuZXh0XFxvcmdcXHNyY1xcdmVuZG9yXFxhbmltYXRpb25cXGFuaW1hdGUubWluLmNzcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBcImJjOTY0OTY4MzFmNFwiXG5pZiAobW9kdWxlLmhvdCkgeyBtb2R1bGUuaG90LmFjY2VwdCgpIH1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./src/vendor/animation/animate.min.css\n");

/***/ }),

/***/ "(ssr)/./src/vendor/datatable/datatable2/buttons.dataTables.min.css":
/*!********************************************************************!*\
  !*** ./src/vendor/datatable/datatable2/buttons.dataTables.min.css ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"98d36c9ecaac\");\nif (false) {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9zcmMvdmVuZG9yL2RhdGF0YWJsZS9kYXRhdGFibGUyL2J1dHRvbnMuZGF0YVRhYmxlcy5taW4uY3NzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxpRUFBZSxjQUFjO0FBQzdCLElBQUksS0FBVSxFQUFFLEVBQXVCIiwic291cmNlcyI6WyJEOlxcbmV4dFxcb3JnXFxzcmNcXHZlbmRvclxcZGF0YXRhYmxlXFxkYXRhdGFibGUyXFxidXR0b25zLmRhdGFUYWJsZXMubWluLmNzcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBcIjk4ZDM2YzllY2FhY1wiXG5pZiAobW9kdWxlLmhvdCkgeyBtb2R1bGUuaG90LmFjY2VwdCgpIH1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./src/vendor/datatable/datatable2/buttons.dataTables.min.css\n");

/***/ }),

/***/ "(ssr)/./src/vendor/datatable/jquery.dataTables.min.css":
/*!********************************************************!*\
  !*** ./src/vendor/datatable/jquery.dataTables.min.css ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"73ffcf1e0bcb\");\nif (false) {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9zcmMvdmVuZG9yL2RhdGF0YWJsZS9qcXVlcnkuZGF0YVRhYmxlcy5taW4uY3NzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxpRUFBZSxjQUFjO0FBQzdCLElBQUksS0FBVSxFQUFFLEVBQXVCIiwic291cmNlcyI6WyJEOlxcbmV4dFxcb3JnXFxzcmNcXHZlbmRvclxcZGF0YXRhYmxlXFxqcXVlcnkuZGF0YVRhYmxlcy5taW4uY3NzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IFwiNzNmZmNmMWUwYmNiXCJcbmlmIChtb2R1bGUuaG90KSB7IG1vZHVsZS5ob3QuYWNjZXB0KCkgfVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./src/vendor/datatable/jquery.dataTables.min.css\n");

/***/ }),

/***/ "(ssr)/./src/vendor/datepikar/flatpickr.min.css":
/*!************************************************!*\
  !*** ./src/vendor/datepikar/flatpickr.min.css ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"0e47f86cb8b1\");\nif (false) {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9zcmMvdmVuZG9yL2RhdGVwaWthci9mbGF0cGlja3IubWluLmNzcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsaUVBQWUsY0FBYztBQUM3QixJQUFJLEtBQVUsRUFBRSxFQUF1QiIsInNvdXJjZXMiOlsiRDpcXG5leHRcXG9yZ1xcc3JjXFx2ZW5kb3JcXGRhdGVwaWthclxcZmxhdHBpY2tyLm1pbi5jc3MiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgXCIwZTQ3Zjg2Y2I4YjFcIlxuaWYgKG1vZHVsZS5ob3QpIHsgbW9kdWxlLmhvdC5hY2NlcHQoKSB9XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./src/vendor/datepikar/flatpickr.min.css\n");

/***/ }),

/***/ "(ssr)/./src/vendor/dual_listboxes/dual-listbox.css":
/*!****************************************************!*\
  !*** ./src/vendor/dual_listboxes/dual-listbox.css ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"391850b3ecca\");\nif (false) {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9zcmMvdmVuZG9yL2R1YWxfbGlzdGJveGVzL2R1YWwtbGlzdGJveC5jc3MiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLGlFQUFlLGNBQWM7QUFDN0IsSUFBSSxLQUFVLEVBQUUsRUFBdUIiLCJzb3VyY2VzIjpbIkQ6XFxuZXh0XFxvcmdcXHNyY1xcdmVuZG9yXFxkdWFsX2xpc3Rib3hlc1xcZHVhbC1saXN0Ym94LmNzcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBcIjM5MTg1MGIzZWNjYVwiXG5pZiAobW9kdWxlLmhvdCkgeyBtb2R1bGUuaG90LmFjY2VwdCgpIH1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./src/vendor/dual_listboxes/dual-listbox.css\n");

/***/ }),

/***/ "(ssr)/./src/vendor/flag-icons-master/flag-icon.css":
/*!****************************************************!*\
  !*** ./src/vendor/flag-icons-master/flag-icon.css ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"b75f2de74f2f\");\nif (false) {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9zcmMvdmVuZG9yL2ZsYWctaWNvbnMtbWFzdGVyL2ZsYWctaWNvbi5jc3MiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLGlFQUFlLGNBQWM7QUFDN0IsSUFBSSxLQUFVLEVBQUUsRUFBdUIiLCJzb3VyY2VzIjpbIkQ6XFxuZXh0XFxvcmdcXHNyY1xcdmVuZG9yXFxmbGFnLWljb25zLW1hc3RlclxcZmxhZy1pY29uLmNzcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBcImI3NWYyZGU3NGYyZlwiXG5pZiAobW9kdWxlLmhvdCkgeyBtb2R1bGUuaG90LmFjY2VwdCgpIH1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./src/vendor/flag-icons-master/flag-icon.css\n");

/***/ }),

/***/ "(ssr)/./src/vendor/fontawesome/css/all.css":
/*!********************************************!*\
  !*** ./src/vendor/fontawesome/css/all.css ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"2a578f9c050d\");\nif (false) {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9zcmMvdmVuZG9yL2ZvbnRhd2Vzb21lL2Nzcy9hbGwuY3NzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxpRUFBZSxjQUFjO0FBQzdCLElBQUksS0FBVSxFQUFFLEVBQXVCIiwic291cmNlcyI6WyJEOlxcbmV4dFxcb3JnXFxzcmNcXHZlbmRvclxcZm9udGF3ZXNvbWVcXGNzc1xcYWxsLmNzcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBcIjJhNTc4ZjljMDUwZFwiXG5pZiAobW9kdWxlLmhvdCkgeyBtb2R1bGUuaG90LmFjY2VwdCgpIH1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./src/vendor/fontawesome/css/all.css\n");

/***/ }),

/***/ "(ssr)/./src/vendor/fullcalendar/global.js":
/*!*******************************************!*\
  !*** ./src/vendor/fullcalendar/global.js ***!
  \*******************************************/
/***/ (() => {

eval("/*!\r\nFullCalendar Standard Bundle v6.1.8\r\nDocs & License: https://fullcalendar.io/docs/initialize-globals\r\n(c) 2023 Adam Shaw\r\n*/ var FullCalendar = function(exports) {\n    'use strict';\n    var n, l$1, u$1, i$1, t, r$1, o, f$1, e$1, c$1 = {}, s = [], a$1 = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;\n    function h(n, l) {\n        for(var u in l)n[u] = l[u];\n        return n;\n    }\n    function v$1(n) {\n        var l = n.parentNode;\n        l && l.removeChild(n);\n    }\n    function y(l, u, i) {\n        var t, r, o, f = {};\n        for(o in u)\"key\" == o ? t = u[o] : \"ref\" == o ? r = u[o] : f[o] = u[o];\n        if (arguments.length > 2 && (f.children = arguments.length > 3 ? n.call(arguments, 2) : i), \"function\" == typeof l && null != l.defaultProps) for(o in l.defaultProps)void 0 === f[o] && (f[o] = l.defaultProps[o]);\n        return p(l, f, t, r, null);\n    }\n    function p(n, i, t, r, o) {\n        var f = {\n            type: n,\n            props: i,\n            key: t,\n            ref: r,\n            __k: null,\n            __: null,\n            __b: 0,\n            __e: null,\n            __d: void 0,\n            __c: null,\n            __h: null,\n            constructor: void 0,\n            __v: null == o ? ++u$1 : o\n        };\n        return null == o && null != l$1.vnode && l$1.vnode(f), f;\n    }\n    function d() {\n        return {\n            current: null\n        };\n    }\n    function _(n) {\n        return n.children;\n    }\n    function k$1(n, l, u, i, t) {\n        var r;\n        for(r in u)\"children\" === r || \"key\" === r || r in l || g$2(n, r, null, u[r], i);\n        for(r in l)t && \"function\" != typeof l[r] || \"children\" === r || \"key\" === r || \"value\" === r || \"checked\" === r || u[r] === l[r] || g$2(n, r, l[r], u[r], i);\n    }\n    function b$1(n, l, u) {\n        \"-\" === l[0] ? n.setProperty(l, null == u ? \"\" : u) : n[l] = null == u ? \"\" : \"number\" != typeof u || a$1.test(l) ? u : u + \"px\";\n    }\n    function g$2(n, l, u, i, t) {\n        var r;\n        n: if (\"style\" === l) if (\"string\" == typeof u) n.style.cssText = u;\n        else {\n            if (\"string\" == typeof i && (n.style.cssText = i = \"\"), i) for(l in i)u && l in u || b$1(n.style, l, \"\");\n            if (u) for(l in u)i && u[l] === i[l] || b$1(n.style, l, u[l]);\n        }\n        else if (\"o\" === l[0] && \"n\" === l[1]) r = l !== (l = l.replace(/Capture$/, \"\")), l = l.toLowerCase() in n ? l.toLowerCase().slice(2) : l.slice(2), n.l || (n.l = {}), n.l[l + r] = u, u ? i || n.addEventListener(l, r ? w$2 : m$1, r) : n.removeEventListener(l, r ? w$2 : m$1, r);\n        else if (\"dangerouslySetInnerHTML\" !== l) {\n            if (t) l = l.replace(/xlink(H|:h)/, \"h\").replace(/sName$/, \"s\");\n            else if (\"width\" !== l && \"height\" !== l && \"href\" !== l && \"list\" !== l && \"form\" !== l && \"tabIndex\" !== l && \"download\" !== l && l in n) try {\n                n[l] = null == u ? \"\" : u;\n                break n;\n            } catch (n) {}\n            \"function\" == typeof u || (null == u || !1 === u && -1 == l.indexOf(\"-\") ? n.removeAttribute(l) : n.setAttribute(l, u));\n        }\n    }\n    function m$1(n) {\n        t = !0;\n        try {\n            return this.l[n.type + !1](l$1.event ? l$1.event(n) : n);\n        } finally{\n            t = !1;\n        }\n    }\n    function w$2(n) {\n        t = !0;\n        try {\n            return this.l[n.type + !0](l$1.event ? l$1.event(n) : n);\n        } finally{\n            t = !1;\n        }\n    }\n    function x$1(n, l) {\n        this.props = n, this.context = l;\n    }\n    function A(n, l) {\n        if (null == l) return n.__ ? A(n.__, n.__.__k.indexOf(n) + 1) : null;\n        for(var u; l < n.__k.length; l++)if (null != (u = n.__k[l]) && null != u.__e) return u.__e;\n        return \"function\" == typeof n.type ? A(n) : null;\n    }\n    function P$1(n) {\n        var l, u;\n        if (null != (n = n.__) && null != n.__c) {\n            for(n.__e = n.__c.base = null, l = 0; l < n.__k.length; l++)if (null != (u = n.__k[l]) && null != u.__e) {\n                n.__e = n.__c.base = u.__e;\n                break;\n            }\n            return P$1(n);\n        }\n    }\n    function C$1(n) {\n        t ? setTimeout(n) : f$1(n);\n    }\n    function T$1(n) {\n        (!n.__d && (n.__d = !0) && r$1.push(n) && !$$1.__r++ || o !== l$1.debounceRendering) && ((o = l$1.debounceRendering) || C$1)($$1);\n    }\n    function $$1() {\n        var n, l, u, i, t, o, f, e;\n        for(r$1.sort(function(n, l) {\n            return n.__v.__b - l.__v.__b;\n        }); n = r$1.shift();)n.__d && (l = r$1.length, i = void 0, t = void 0, f = (o = (u = n).__v).__e, (e = u.__P) && (i = [], (t = h({}, o)).__v = o.__v + 1, M(e, o, t, u.__n, void 0 !== e.ownerSVGElement, null != o.__h ? [\n            f\n        ] : null, i, null == f ? A(o) : f, o.__h), N(i, o), o.__e != f && P$1(o)), r$1.length > l && r$1.sort(function(n, l) {\n            return n.__v.__b - l.__v.__b;\n        }));\n        $$1.__r = 0;\n    }\n    function H$1(n, l, u, i, t, r, o, f, e, a) {\n        var h, v, y, d, k, b, g, m = i && i.__k || s, w = m.length;\n        for(u.__k = [], h = 0; h < l.length; h++)if (null != (d = u.__k[h] = null == (d = l[h]) || \"boolean\" == typeof d ? null : \"string\" == typeof d || \"number\" == typeof d || \"bigint\" == typeof d ? p(null, d, null, null, d) : Array.isArray(d) ? p(_, {\n            children: d\n        }, null, null, null) : d.__b > 0 ? p(d.type, d.props, d.key, d.ref ? d.ref : null, d.__v) : d)) {\n            if (d.__ = u, d.__b = u.__b + 1, null === (y = m[h]) || y && d.key == y.key && d.type === y.type) m[h] = void 0;\n            else for(v = 0; v < w; v++){\n                if ((y = m[v]) && d.key == y.key && d.type === y.type) {\n                    m[v] = void 0;\n                    break;\n                }\n                y = null;\n            }\n            M(n, d, y = y || c$1, t, r, o, f, e, a), k = d.__e, (v = d.ref) && y.ref != v && (g || (g = []), y.ref && g.push(y.ref, null, d), g.push(v, d.__c || k, d)), null != k ? (null == b && (b = k), \"function\" == typeof d.type && d.__k === y.__k ? d.__d = e = I$1(d, e, n) : e = z$1(n, d, y, m, k, e), \"function\" == typeof u.type && (u.__d = e)) : e && y.__e == e && e.parentNode != n && (e = A(y));\n        }\n        for(u.__e = b, h = w; h--;)null != m[h] && (\"function\" == typeof u.type && null != m[h].__e && m[h].__e == u.__d && (u.__d = L$1(i).nextSibling), q(m[h], m[h]));\n        if (g) for(h = 0; h < g.length; h++)S(g[h], g[++h], g[++h]);\n    }\n    function I$1(n, l, u) {\n        for(var i, t = n.__k, r = 0; t && r < t.length; r++)(i = t[r]) && (i.__ = n, l = \"function\" == typeof i.type ? I$1(i, l, u) : z$1(u, i, i, t, i.__e, l));\n        return l;\n    }\n    function j$2(n, l) {\n        return l = l || [], null == n || \"boolean\" == typeof n || (Array.isArray(n) ? n.some(function(n) {\n            j$2(n, l);\n        }) : l.push(n)), l;\n    }\n    function z$1(n, l, u, i, t, r) {\n        var o, f, e;\n        if (void 0 !== l.__d) o = l.__d, l.__d = void 0;\n        else if (null == u || t != r || null == t.parentNode) n: if (null == r || r.parentNode !== n) n.appendChild(t), o = null;\n        else {\n            for(f = r, e = 0; (f = f.nextSibling) && e < i.length; e += 1)if (f == t) break n;\n            n.insertBefore(t, r), o = r;\n        }\n        return void 0 !== o ? o : t.nextSibling;\n    }\n    function L$1(n) {\n        var l, u, i;\n        if (null == n.type || \"string\" == typeof n.type) return n.__e;\n        if (n.__k) {\n            for(l = n.__k.length - 1; l >= 0; l--)if ((u = n.__k[l]) && (i = L$1(u))) return i;\n        }\n        return null;\n    }\n    function M(n, u, i, t, r, o, f, e, c) {\n        var s, a, v, y, p, d, k, b, g, m, w, A, P, C, T, $ = u.type;\n        if (void 0 !== u.constructor) return null;\n        null != i.__h && (c = i.__h, e = u.__e = i.__e, u.__h = null, o = [\n            e\n        ]), (s = l$1.__b) && s(u);\n        try {\n            n: if (\"function\" == typeof $) {\n                if (b = u.props, g = (s = $.contextType) && t[s.__c], m = s ? g ? g.props.value : s.__ : t, i.__c ? k = (a = u.__c = i.__c).__ = a.__E : (\"prototype\" in $ && $.prototype.render ? u.__c = a = new $(b, m) : (u.__c = a = new x$1(b, m), a.constructor = $, a.render = B$1), g && g.sub(a), a.props = b, a.state || (a.state = {}), a.context = m, a.__n = t, v = a.__d = !0, a.__h = [], a._sb = []), null == a.__s && (a.__s = a.state), null != $.getDerivedStateFromProps && (a.__s == a.state && (a.__s = h({}, a.__s)), h(a.__s, $.getDerivedStateFromProps(b, a.__s))), y = a.props, p = a.state, a.__v = u, v) null == $.getDerivedStateFromProps && null != a.componentWillMount && a.componentWillMount(), null != a.componentDidMount && a.__h.push(a.componentDidMount);\n                else {\n                    if (null == $.getDerivedStateFromProps && b !== y && null != a.componentWillReceiveProps && a.componentWillReceiveProps(b, m), !a.__e && null != a.shouldComponentUpdate && !1 === a.shouldComponentUpdate(b, a.__s, m) || u.__v === i.__v) {\n                        for(u.__v !== i.__v && (a.props = b, a.state = a.__s, a.__d = !1), u.__e = i.__e, u.__k = i.__k, u.__k.forEach(function(n) {\n                            n && (n.__ = u);\n                        }), w = 0; w < a._sb.length; w++)a.__h.push(a._sb[w]);\n                        a._sb = [], a.__h.length && f.push(a);\n                        break n;\n                    }\n                    null != a.componentWillUpdate && a.componentWillUpdate(b, a.__s, m), null != a.componentDidUpdate && a.__h.push(function() {\n                        a.componentDidUpdate(y, p, d);\n                    });\n                }\n                if (a.context = m, a.props = b, a.__P = n, A = l$1.__r, P = 0, \"prototype\" in $ && $.prototype.render) {\n                    for(a.state = a.__s, a.__d = !1, A && A(u), s = a.render(a.props, a.state, a.context), C = 0; C < a._sb.length; C++)a.__h.push(a._sb[C]);\n                    a._sb = [];\n                } else do {\n                    a.__d = !1, A && A(u), s = a.render(a.props, a.state, a.context), a.state = a.__s;\n                }while (a.__d && ++P < 25);\n                a.state = a.__s, null != a.getChildContext && (t = h(h({}, t), a.getChildContext())), v || null == a.getSnapshotBeforeUpdate || (d = a.getSnapshotBeforeUpdate(y, p)), T = null != s && s.type === _ && null == s.key ? s.props.children : s, H$1(n, Array.isArray(T) ? T : [\n                    T\n                ], u, i, t, r, o, f, e, c), a.base = u.__e, u.__h = null, a.__h.length && f.push(a), k && (a.__E = a.__ = null), a.__e = !1;\n            } else null == o && u.__v === i.__v ? (u.__k = i.__k, u.__e = i.__e) : u.__e = O(i.__e, u, i, t, r, o, f, c);\n            (s = l$1.diffed) && s(u);\n        } catch (n) {\n            u.__v = null, (c || null != o) && (u.__e = e, u.__h = !!c, o[o.indexOf(e)] = null), l$1.__e(n, u, i);\n        }\n    }\n    function N(n, u) {\n        l$1.__c && l$1.__c(u, n), n.some(function(u) {\n            try {\n                n = u.__h, u.__h = [], n.some(function(n) {\n                    n.call(u);\n                });\n            } catch (n) {\n                l$1.__e(n, u.__v);\n            }\n        });\n    }\n    function O(l, u, i, t, r, o, f, e) {\n        var s, a, h, y = i.props, p = u.props, d = u.type, _ = 0;\n        if (\"svg\" === d && (r = !0), null != o) {\n            for(; _ < o.length; _++)if ((s = o[_]) && \"setAttribute\" in s == !!d && (d ? s.localName === d : 3 === s.nodeType)) {\n                l = s, o[_] = null;\n                break;\n            }\n        }\n        if (null == l) {\n            if (null === d) return document.createTextNode(p);\n            l = r ? document.createElementNS(\"http://www.w3.org/2000/svg\", d) : document.createElement(d, p.is && p), o = null, e = !1;\n        }\n        if (null === d) y === p || e && l.data === p || (l.data = p);\n        else {\n            if (o = o && n.call(l.childNodes), a = (y = i.props || c$1).dangerouslySetInnerHTML, h = p.dangerouslySetInnerHTML, !e) {\n                if (null != o) for(y = {}, _ = 0; _ < l.attributes.length; _++)y[l.attributes[_].name] = l.attributes[_].value;\n                (h || a) && (h && (a && h.__html == a.__html || h.__html === l.innerHTML) || (l.innerHTML = h && h.__html || \"\"));\n            }\n            if (k$1(l, p, y, r, e), h) u.__k = [];\n            else if (_ = u.props.children, H$1(l, Array.isArray(_) ? _ : [\n                _\n            ], u, i, t, r && \"foreignObject\" !== d, o, f, o ? o[0] : i.__k && A(i, 0), e), null != o) for(_ = o.length; _--;)null != o[_] && v$1(o[_]);\n            e || (\"value\" in p && void 0 !== (_ = p.value) && (_ !== l.value || \"progress\" === d && !_ || \"option\" === d && _ !== y.value) && g$2(l, \"value\", _, y.value, !1), \"checked\" in p && void 0 !== (_ = p.checked) && _ !== l.checked && g$2(l, \"checked\", _, y.checked, !1));\n        }\n        return l;\n    }\n    function S(n, u, i) {\n        try {\n            \"function\" == typeof n ? n(u) : n.current = u;\n        } catch (n) {\n            l$1.__e(n, i);\n        }\n    }\n    function q(n, u, i) {\n        var t, r;\n        if (l$1.unmount && l$1.unmount(n), (t = n.ref) && (t.current && t.current !== n.__e || S(t, null, u)), null != (t = n.__c)) {\n            if (t.componentWillUnmount) try {\n                t.componentWillUnmount();\n            } catch (n) {\n                l$1.__e(n, u);\n            }\n            t.base = t.__P = null, n.__c = void 0;\n        }\n        if (t = n.__k) for(r = 0; r < t.length; r++)t[r] && q(t[r], u, i || \"function\" != typeof n.type);\n        i || null == n.__e || v$1(n.__e), n.__ = n.__e = n.__d = void 0;\n    }\n    function B$1(n, l, u) {\n        return this.constructor(n, u);\n    }\n    function D$1(u, i, t) {\n        var r, o, f;\n        l$1.__ && l$1.__(u, i), o = (r = \"function\" == typeof t) ? null : t && t.__k || i.__k, f = [], M(i, u = (!r && t || i).__k = y(_, null, [\n            u\n        ]), o || c$1, c$1, void 0 !== i.ownerSVGElement, !r && t ? [\n            t\n        ] : o ? null : i.firstChild ? n.call(i.childNodes) : null, f, !r && t ? t : o ? o.__e : i.firstChild, r), N(f, u);\n    }\n    function E(n, l) {\n        D$1(n, l, E);\n    }\n    function F$1(l, u, i) {\n        var t, r, o, f = h({}, l.props);\n        for(o in u)\"key\" == o ? t = u[o] : \"ref\" == o ? r = u[o] : f[o] = u[o];\n        return arguments.length > 2 && (f.children = arguments.length > 3 ? n.call(arguments, 2) : i), p(l.type, f, t || l.key, r || l.ref, null);\n    }\n    function G$1(n, l) {\n        var u = {\n            __c: l = \"__cC\" + e$1++,\n            __: n,\n            Consumer: function(n, l) {\n                return n.children(l);\n            },\n            Provider: function(n) {\n                var u, i;\n                return this.getChildContext || (u = [], (i = {})[l] = this, this.getChildContext = function() {\n                    return i;\n                }, this.shouldComponentUpdate = function(n) {\n                    this.props.value !== n.value && u.some(function(n) {\n                        n.__e = !0, T$1(n);\n                    });\n                }, this.sub = function(n) {\n                    u.push(n);\n                    var l = n.componentWillUnmount;\n                    n.componentWillUnmount = function() {\n                        u.splice(u.indexOf(n), 1), l && l.call(n);\n                    };\n                }), n.children;\n            }\n        };\n        return u.Provider.__ = u.Consumer.contextType = u;\n    }\n    n = s.slice, l$1 = {\n        __e: function(n, l, u, i) {\n            for(var t, r, o; l = l.__;)if ((t = l.__c) && !t.__) try {\n                if ((r = t.constructor) && null != r.getDerivedStateFromError && (t.setState(r.getDerivedStateFromError(n)), o = t.__d), null != t.componentDidCatch && (t.componentDidCatch(n, i || {}), o = t.__d), o) return t.__E = t;\n            } catch (l) {\n                n = l;\n            }\n            throw n;\n        }\n    }, u$1 = 0, i$1 = function(n) {\n        return null != n && void 0 === n.constructor;\n    }, t = !1, x$1.prototype.setState = function(n, l) {\n        var u;\n        u = null != this.__s && this.__s !== this.state ? this.__s : this.__s = h({}, this.state), \"function\" == typeof n && (n = n(h({}, u), this.props)), n && h(u, n), null != n && this.__v && (l && this._sb.push(l), T$1(this));\n    }, x$1.prototype.forceUpdate = function(n) {\n        this.__v && (this.__e = !0, n && this.__h.push(n), T$1(this));\n    }, x$1.prototype.render = _, r$1 = [], f$1 = \"function\" == typeof Promise ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, $$1.__r = 0, e$1 = 0;\n    var r, u, i, f = [], c = [], e = l$1.__b, a = l$1.__r, v = l$1.diffed, l = l$1.__c, m = l$1.unmount;\n    function b() {\n        for(var t; t = f.shift();)if (t.__P && t.__H) try {\n            t.__H.__h.forEach(k), t.__H.__h.forEach(w$1), t.__H.__h = [];\n        } catch (r) {\n            t.__H.__h = [], l$1.__e(r, t.__v);\n        }\n    }\n    l$1.__b = function(n) {\n        r = null, e && e(n);\n    }, l$1.__r = function(n) {\n        a && a(n);\n        var i = (r = n.__c).__H;\n        i && (u === r ? (i.__h = [], r.__h = [], i.__.forEach(function(n) {\n            n.__N && (n.__ = n.__N), n.__V = c, n.__N = n.i = void 0;\n        })) : (i.__h.forEach(k), i.__h.forEach(w$1), i.__h = [])), u = r;\n    }, l$1.diffed = function(t) {\n        v && v(t);\n        var o = t.__c;\n        o && o.__H && (o.__H.__h.length && (1 !== f.push(o) && i === l$1.requestAnimationFrame || ((i = l$1.requestAnimationFrame) || j$1)(b)), o.__H.__.forEach(function(n) {\n            n.i && (n.__H = n.i), n.__V !== c && (n.__ = n.__V), n.i = void 0, n.__V = c;\n        })), u = r = null;\n    }, l$1.__c = function(t, r) {\n        r.some(function(t) {\n            try {\n                t.__h.forEach(k), t.__h = t.__h.filter(function(n) {\n                    return !n.__ || w$1(n);\n                });\n            } catch (u) {\n                r.some(function(n) {\n                    n.__h && (n.__h = []);\n                }), r = [], l$1.__e(u, t.__v);\n            }\n        }), l && l(t, r);\n    }, l$1.unmount = function(t) {\n        m && m(t);\n        var r, u = t.__c;\n        u && u.__H && (u.__H.__.forEach(function(n) {\n            try {\n                k(n);\n            } catch (n) {\n                r = n;\n            }\n        }), u.__H = void 0, r && l$1.__e(r, u.__v));\n    };\n    var g$1 = \"function\" == typeof requestAnimationFrame;\n    function j$1(n) {\n        var t, r = function() {\n            clearTimeout(u), g$1 && cancelAnimationFrame(t), setTimeout(n);\n        }, u = setTimeout(r, 100);\n        g$1 && (t = requestAnimationFrame(r));\n    }\n    function k(n) {\n        var t = r, u = n.__c;\n        \"function\" == typeof u && (n.__c = void 0, u()), r = t;\n    }\n    function w$1(n) {\n        var t = r;\n        n.__c = n.__(), r = t;\n    }\n    function g(n, t) {\n        for(var e in t)n[e] = t[e];\n        return n;\n    }\n    function C(n, t) {\n        for(var e in n)if (\"__source\" !== e && !(e in t)) return !0;\n        for(var r in t)if (\"__source\" !== r && n[r] !== t[r]) return !0;\n        return !1;\n    }\n    function w(n) {\n        this.props = n;\n    }\n    (w.prototype = new x$1).isPureReactComponent = !0, w.prototype.shouldComponentUpdate = function(n, t) {\n        return C(this.props, n) || C(this.state, t);\n    };\n    var x = l$1.__b;\n    l$1.__b = function(n) {\n        n.type && n.type.__f && n.ref && (n.props.ref = n.ref, n.ref = null), x && x(n);\n    };\n    var T = l$1.__e;\n    l$1.__e = function(n, t, e, r) {\n        if (n.then) {\n            for(var u, o = t; o = o.__;)if ((u = o.__c) && u.__c) return null == t.__e && (t.__e = e.__e, t.__k = e.__k), u.__c(n, t);\n        }\n        T(n, t, e, r);\n    };\n    var I = l$1.unmount;\n    function L(n, t, e) {\n        return n && (n.__c && n.__c.__H && (n.__c.__H.__.forEach(function(n) {\n            \"function\" == typeof n.__c && n.__c();\n        }), n.__c.__H = null), null != (n = g({}, n)).__c && (n.__c.__P === e && (n.__c.__P = t), n.__c = null), n.__k = n.__k && n.__k.map(function(n) {\n            return L(n, t, e);\n        })), n;\n    }\n    function U(n, t, e) {\n        return n && (n.__v = null, n.__k = n.__k && n.__k.map(function(n) {\n            return U(n, t, e);\n        }), n.__c && n.__c.__P === t && (n.__e && e.insertBefore(n.__e, n.__d), n.__c.__e = !0, n.__c.__P = e)), n;\n    }\n    function D() {\n        this.__u = 0, this.t = null, this.__b = null;\n    }\n    function F(n) {\n        var t = n.__.__c;\n        return t && t.__a && t.__a(n);\n    }\n    function V() {\n        this.u = null, this.o = null;\n    }\n    l$1.unmount = function(n) {\n        var t = n.__c;\n        t && t.__R && t.__R(), t && !0 === n.__h && (n.type = null), I && I(n);\n    }, (D.prototype = new x$1).__c = function(n, t) {\n        var e = t.__c, r = this;\n        null == r.t && (r.t = []), r.t.push(e);\n        var u = F(r.__v), o = !1, i = function() {\n            o || (o = !0, e.__R = null, u ? u(l) : l());\n        };\n        e.__R = i;\n        var l = function() {\n            if (!--r.__u) {\n                if (r.state.__a) {\n                    var n = r.state.__a;\n                    r.__v.__k[0] = U(n, n.__c.__P, n.__c.__O);\n                }\n                var t;\n                for(r.setState({\n                    __a: r.__b = null\n                }); t = r.t.pop();)t.forceUpdate();\n            }\n        }, c = !0 === t.__h;\n        r.__u++ || c || r.setState({\n            __a: r.__b = r.__v.__k[0]\n        }), n.then(i, i);\n    }, D.prototype.componentWillUnmount = function() {\n        this.t = [];\n    }, D.prototype.render = function(n, e) {\n        if (this.__b) {\n            if (this.__v.__k) {\n                var r = document.createElement(\"div\"), o = this.__v.__k[0].__c;\n                this.__v.__k[0] = L(this.__b, r, o.__O = o.__P);\n            }\n            this.__b = null;\n        }\n        var i = e.__a && y(_, null, n.fallback);\n        return i && (i.__h = null), [\n            y(_, null, e.__a ? null : n.children),\n            i\n        ];\n    };\n    var W = function(n, t, e) {\n        if (++e[1] === e[0] && n.o.delete(t), n.props.revealOrder && (\"t\" !== n.props.revealOrder[0] || !n.o.size)) for(e = n.u; e;){\n            for(; e.length > 3;)e.pop()();\n            if (e[1] < e[0]) break;\n            n.u = e = e[2];\n        }\n    };\n    function P(n) {\n        return this.getChildContext = function() {\n            return n.context;\n        }, n.children;\n    }\n    function $(n) {\n        var e = this, r = n.i;\n        e.componentWillUnmount = function() {\n            D$1(null, e.l), e.l = null, e.i = null;\n        }, e.i && e.i !== r && e.componentWillUnmount(), n.__v ? (e.l || (e.i = r, e.l = {\n            nodeType: 1,\n            parentNode: r,\n            childNodes: [],\n            appendChild: function(n) {\n                this.childNodes.push(n), e.i.appendChild(n);\n            },\n            insertBefore: function(n, t) {\n                this.childNodes.push(n), e.i.appendChild(n);\n            },\n            removeChild: function(n) {\n                this.childNodes.splice(this.childNodes.indexOf(n) >>> 1, 1), e.i.removeChild(n);\n            }\n        }), D$1(y(P, {\n            context: e.context\n        }, n.__v), e.l)) : e.l && e.componentWillUnmount();\n    }\n    function j(n, e) {\n        var r = y($, {\n            __v: n,\n            i: e\n        });\n        return r.containerInfo = e, r;\n    }\n    (V.prototype = new x$1).__a = function(n) {\n        var t = this, e = F(t.__v), r = t.o.get(n);\n        return r[0]++, function(u) {\n            var o = function() {\n                t.props.revealOrder ? (r.push(u), W(t, n, r)) : u();\n            };\n            e ? e(o) : o();\n        };\n    }, V.prototype.render = function(n) {\n        this.u = null, this.o = new Map;\n        var t = j$2(n.children);\n        n.revealOrder && \"b\" === n.revealOrder[0] && t.reverse();\n        for(var e = t.length; e--;)this.o.set(t[e], this.u = [\n            1,\n            0,\n            this.u\n        ]);\n        return n.children;\n    }, V.prototype.componentDidUpdate = V.prototype.componentDidMount = function() {\n        var n = this;\n        this.o.forEach(function(t, e) {\n            W(n, e, t);\n        });\n    };\n    var z = \"undefined\" != typeof Symbol && Symbol.for && Symbol.for(\"react.element\") || 60103, B = /^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|dominant|fill|flood|font|glyph(?!R)|horiz|image|letter|lighting|marker(?!H|W|U)|overline|paint|pointer|shape|stop|strikethrough|stroke|text(?!L)|transform|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/, H = \"undefined\" != typeof document, Z = function(n) {\n        return (\"undefined\" != typeof Symbol && \"symbol\" == typeof Symbol() ? /fil|che|rad/i : /fil|che|ra/i).test(n);\n    };\n    x$1.prototype.isReactComponent = {}, [\n        \"componentWillMount\",\n        \"componentWillReceiveProps\",\n        \"componentWillUpdate\"\n    ].forEach(function(t) {\n        Object.defineProperty(x$1.prototype, t, {\n            configurable: !0,\n            get: function() {\n                return this[\"UNSAFE_\" + t];\n            },\n            set: function(n) {\n                Object.defineProperty(this, t, {\n                    configurable: !0,\n                    writable: !0,\n                    value: n\n                });\n            }\n        });\n    });\n    var G = l$1.event;\n    function J() {}\n    function K() {\n        return this.cancelBubble;\n    }\n    function Q() {\n        return this.defaultPrevented;\n    }\n    l$1.event = function(n) {\n        return G && (n = G(n)), n.persist = J, n.isPropagationStopped = K, n.isDefaultPrevented = Q, n.nativeEvent = n;\n    };\n    var nn = {\n        configurable: !0,\n        get: function() {\n            return this.class;\n        }\n    }, tn = l$1.vnode;\n    l$1.vnode = function(n) {\n        var t = n.type, e = n.props, u = e;\n        if (\"string\" == typeof t) {\n            var o = -1 === t.indexOf(\"-\");\n            for(var i in u = {}, e){\n                var l = e[i];\n                H && \"children\" === i && \"noscript\" === t || \"value\" === i && \"defaultValue\" in e && null == l || (\"defaultValue\" === i && \"value\" in e && null == e.value ? i = \"value\" : \"download\" === i && !0 === l ? l = \"\" : /ondoubleclick/i.test(i) ? i = \"ondblclick\" : /^onchange(textarea|input)/i.test(i + t) && !Z(e.type) ? i = \"oninput\" : /^onfocus$/i.test(i) ? i = \"onfocusin\" : /^onblur$/i.test(i) ? i = \"onfocusout\" : /^on(Ani|Tra|Tou|BeforeInp|Compo)/.test(i) ? i = i.toLowerCase() : o && B.test(i) ? i = i.replace(/[A-Z0-9]/g, \"-$&\").toLowerCase() : null === l && (l = void 0), /^oninput$/i.test(i) && (i = i.toLowerCase(), u[i] && (i = \"oninputCapture\")), u[i] = l);\n            }\n            \"select\" == t && u.multiple && Array.isArray(u.value) && (u.value = j$2(e.children).forEach(function(n) {\n                n.props.selected = -1 != u.value.indexOf(n.props.value);\n            })), \"select\" == t && null != u.defaultValue && (u.value = j$2(e.children).forEach(function(n) {\n                n.props.selected = u.multiple ? -1 != u.defaultValue.indexOf(n.props.value) : u.defaultValue == n.props.value;\n            })), n.props = u, e.class != e.className && (nn.enumerable = \"className\" in e, null != e.className && (u.class = e.className), Object.defineProperty(u, \"className\", nn));\n        }\n        n.$$typeof = z, tn && tn(n);\n    };\n    var en = l$1.__r;\n    l$1.__r = function(n) {\n        en && en(n), n.__c;\n    };\n    const styleTexts = [];\n    const styleEls = new Map();\n    function injectStyles(styleText) {\n        styleTexts.push(styleText);\n        styleEls.forEach((styleEl)=>{\n            appendStylesTo(styleEl, styleText);\n        });\n    }\n    function ensureElHasStyles(el) {\n        if (el.isConnected) {\n            registerStylesRoot(el.getRootNode());\n        }\n    }\n    function registerStylesRoot(rootNode) {\n        let styleEl = styleEls.get(rootNode);\n        if (!styleEl || !styleEl.isConnected) {\n            styleEl = rootNode.querySelector('style[data-fullcalendar]');\n            if (!styleEl) {\n                styleEl = document.createElement('style');\n                styleEl.setAttribute('data-fullcalendar', '');\n                const nonce = getNonceValue();\n                if (nonce) {\n                    styleEl.nonce = nonce;\n                }\n                const parentEl = rootNode === document ? document.head : rootNode;\n                const insertBefore = rootNode === document ? parentEl.querySelector('script,link[rel=stylesheet],link[as=style],style') : parentEl.firstChild;\n                parentEl.insertBefore(styleEl, insertBefore);\n            }\n            styleEls.set(rootNode, styleEl);\n            hydrateStylesRoot(styleEl);\n        }\n    }\n    function hydrateStylesRoot(styleEl) {\n        for (const styleText of styleTexts){\n            appendStylesTo(styleEl, styleText);\n        }\n    }\n    function appendStylesTo(styleEl, styleText) {\n        const { sheet } = styleEl;\n        const ruleCnt = sheet.cssRules.length;\n        styleText.split('}').forEach((styleStr, i)=>{\n            styleStr = styleStr.trim();\n            if (styleStr) {\n                sheet.insertRule(styleStr + '}', ruleCnt + i);\n            }\n        });\n    }\n    // nonce\n    // -------------------------------------------------------------------------------------------------\n    let queriedNonceValue;\n    function getNonceValue() {\n        if (queriedNonceValue === undefined) {\n            queriedNonceValue = queryNonceValue();\n        }\n        return queriedNonceValue;\n    }\n    /*\r\n    TODO: discourage meta tag and instead put nonce attribute on placeholder <style> tag\r\n    */ function queryNonceValue() {\n        const metaWithNonce = document.querySelector('meta[name=\"csp-nonce\"]');\n        if (metaWithNonce && metaWithNonce.hasAttribute('content')) {\n            return metaWithNonce.getAttribute('content');\n        }\n        const elWithNonce = document.querySelector('script[nonce]');\n        if (elWithNonce) {\n            return elWithNonce.nonce || '';\n        }\n        return '';\n    }\n    // main\n    // -------------------------------------------------------------------------------------------------\n    if (typeof document !== 'undefined') {\n        registerStylesRoot(document);\n    }\n    var css_248z$4 = \":root{--fc-small-font-size:.85em;--fc-page-bg-color:#fff;--fc-neutral-bg-color:hsla(0,0%,82%,.3);--fc-neutral-text-color:grey;--fc-border-color:#ddd;--fc-button-text-color:#fff;--fc-button-bg-color:#2c3e50;--fc-button-border-color:#2c3e50;--fc-button-hover-bg-color:#1e2b37;--fc-button-hover-border-color:#1a252f;--fc-button-active-bg-color:#1a252f;--fc-button-active-border-color:#151e27;--fc-event-bg-color:#3788d8;--fc-event-border-color:#3788d8;--fc-event-text-color:#fff;--fc-event-selected-overlay-color:rgba(0,0,0,.25);--fc-more-link-bg-color:#d0d0d0;--fc-more-link-text-color:inherit;--fc-event-resizer-thickness:8px;--fc-event-resizer-dot-total-width:8px;--fc-event-resizer-dot-border-width:1px;--fc-non-business-color:hsla(0,0%,84%,.3);--fc-bg-event-color:#8fdf82;--fc-bg-event-opacity:0.3;--fc-highlight-color:rgba(188,232,241,.3);--fc-today-bg-color:rgba(255,220,40,.15);--fc-now-indicator-color:red}.fc-not-allowed,.fc-not-allowed .fc-event{cursor:not-allowed}.fc{display:flex;flex-direction:column;font-size:1em}.fc,.fc *,.fc :after,.fc :before{box-sizing:border-box}.fc table{border-collapse:collapse;border-spacing:0;font-size:1em}.fc th{text-align:center}.fc td,.fc th{padding:0;vertical-align:top}.fc a[data-navlink]{cursor:pointer}.fc a[data-navlink]:hover{text-decoration:underline}.fc-direction-ltr{direction:ltr;text-align:left}.fc-direction-rtl{direction:rtl;text-align:right}.fc-theme-standard td,.fc-theme-standard th{border:1px solid var(--fc-border-color)}.fc-liquid-hack td,.fc-liquid-hack th{position:relative}@font-face{font-family:fcicons;font-style:normal;font-weight:400;src:url(\\\"data:application/x-font-ttf;charset=utf-8;base64,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\\\") format(\\\"truetype\\\")}.fc-icon{speak:none;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;display:inline-block;font-family:fcicons!important;font-style:normal;font-variant:normal;font-weight:400;height:1em;line-height:1;text-align:center;text-transform:none;-webkit-user-select:none;-moz-user-select:none;user-select:none;width:1em}.fc-icon-chevron-left:before{content:\\\"\\\\e900\\\"}.fc-icon-chevron-right:before{content:\\\"\\\\e901\\\"}.fc-icon-chevrons-left:before{content:\\\"\\\\e902\\\"}.fc-icon-chevrons-right:before{content:\\\"\\\\e903\\\"}.fc-icon-minus-square:before{content:\\\"\\\\e904\\\"}.fc-icon-plus-square:before{content:\\\"\\\\e905\\\"}.fc-icon-x:before{content:\\\"\\\\e906\\\"}.fc .fc-button{border-radius:0;font-family:inherit;font-size:inherit;line-height:inherit;margin:0;overflow:visible;text-transform:none}.fc .fc-button:focus{outline:1px dotted;outline:5px auto -webkit-focus-ring-color}.fc .fc-button{-webkit-appearance:button}.fc .fc-button:not(:disabled){cursor:pointer}.fc .fc-button{background-color:transparent;border:1px solid transparent;border-radius:.25em;display:inline-block;font-size:1em;font-weight:400;line-height:1.5;padding:.4em .65em;text-align:center;-webkit-user-select:none;-moz-user-select:none;user-select:none;vertical-align:middle}.fc .fc-button:hover{text-decoration:none}.fc .fc-button:focus{box-shadow:0 0 0 .2rem rgba(44,62,80,.25);outline:0}.fc .fc-button:disabled{opacity:.65}.fc .fc-button-primary{background-color:var(--fc-button-bg-color);border-color:var(--fc-button-border-color);color:var(--fc-button-text-color)}.fc .fc-button-primary:hover{background-color:var(--fc-button-hover-bg-color);border-color:var(--fc-button-hover-border-color);color:var(--fc-button-text-color)}.fc .fc-button-primary:disabled{background-color:var(--fc-button-bg-color);border-color:var(--fc-button-border-color);color:var(--fc-button-text-color)}.fc .fc-button-primary:focus{box-shadow:0 0 0 .2rem rgba(76,91,106,.5)}.fc .fc-button-primary:not(:disabled).fc-button-active,.fc .fc-button-primary:not(:disabled):active{background-color:var(--fc-button-active-bg-color);border-color:var(--fc-button-active-border-color);color:var(--fc-button-text-color)}.fc .fc-button-primary:not(:disabled).fc-button-active:focus,.fc .fc-button-primary:not(:disabled):active:focus{box-shadow:0 0 0 .2rem rgba(76,91,106,.5)}.fc .fc-button .fc-icon{font-size:1.5em;vertical-align:middle}.fc .fc-button-group{display:inline-flex;position:relative;vertical-align:middle}.fc .fc-button-group>.fc-button{flex:1 1 auto;position:relative}.fc .fc-button-group>.fc-button.fc-button-active,.fc .fc-button-group>.fc-button:active,.fc .fc-button-group>.fc-button:focus,.fc .fc-button-group>.fc-button:hover{z-index:1}.fc-direction-ltr .fc-button-group>.fc-button:not(:first-child){border-bottom-left-radius:0;border-top-left-radius:0;margin-left:-1px}.fc-direction-ltr .fc-button-group>.fc-button:not(:last-child){border-bottom-right-radius:0;border-top-right-radius:0}.fc-direction-rtl .fc-button-group>.fc-button:not(:first-child){border-bottom-right-radius:0;border-top-right-radius:0;margin-right:-1px}.fc-direction-rtl .fc-button-group>.fc-button:not(:last-child){border-bottom-left-radius:0;border-top-left-radius:0}.fc .fc-toolbar{align-items:center;display:flex;justify-content:space-between}.fc .fc-toolbar.fc-header-toolbar{margin-bottom:1.5em}.fc .fc-toolbar.fc-footer-toolbar{margin-top:1.5em}.fc .fc-toolbar-title{font-size:1.75em;margin:0}.fc-direction-ltr .fc-toolbar>*>:not(:first-child){margin-left:.75em}.fc-direction-rtl .fc-toolbar>*>:not(:first-child){margin-right:.75em}.fc-direction-rtl .fc-toolbar-ltr{flex-direction:row-reverse}.fc .fc-scroller{-webkit-overflow-scrolling:touch;position:relative}.fc .fc-scroller-liquid{height:100%}.fc .fc-scroller-liquid-absolute{bottom:0;left:0;position:absolute;right:0;top:0}.fc .fc-scroller-harness{direction:ltr;overflow:hidden;position:relative}.fc .fc-scroller-harness-liquid{height:100%}.fc-direction-rtl .fc-scroller-harness>.fc-scroller{direction:rtl}.fc-theme-standard .fc-scrollgrid{border:1px solid var(--fc-border-color)}.fc .fc-scrollgrid,.fc .fc-scrollgrid table{table-layout:fixed;width:100%}.fc .fc-scrollgrid table{border-left-style:hidden;border-right-style:hidden;border-top-style:hidden}.fc .fc-scrollgrid{border-bottom-width:0;border-collapse:separate;border-right-width:0}.fc .fc-scrollgrid-liquid{height:100%}.fc .fc-scrollgrid-section,.fc .fc-scrollgrid-section table,.fc .fc-scrollgrid-section>td{height:1px}.fc .fc-scrollgrid-section-liquid>td{height:100%}.fc .fc-scrollgrid-section>*{border-left-width:0;border-top-width:0}.fc .fc-scrollgrid-section-footer>*,.fc .fc-scrollgrid-section-header>*{border-bottom-width:0}.fc .fc-scrollgrid-section-body table,.fc .fc-scrollgrid-section-footer table{border-bottom-style:hidden}.fc .fc-scrollgrid-section-sticky>*{background:var(--fc-page-bg-color);position:sticky;z-index:3}.fc .fc-scrollgrid-section-header.fc-scrollgrid-section-sticky>*{top:0}.fc .fc-scrollgrid-section-footer.fc-scrollgrid-section-sticky>*{bottom:0}.fc .fc-scrollgrid-sticky-shim{height:1px;margin-bottom:-1px}.fc-sticky{position:sticky}.fc .fc-view-harness{flex-grow:1;position:relative}.fc .fc-view-harness-active>.fc-view{bottom:0;left:0;position:absolute;right:0;top:0}.fc .fc-col-header-cell-cushion{display:inline-block;padding:2px 4px}.fc .fc-bg-event,.fc .fc-highlight,.fc .fc-non-business{bottom:0;left:0;position:absolute;right:0;top:0}.fc .fc-non-business{background:var(--fc-non-business-color)}.fc .fc-bg-event{background:var(--fc-bg-event-color);opacity:var(--fc-bg-event-opacity)}.fc .fc-bg-event .fc-event-title{font-size:var(--fc-small-font-size);font-style:italic;margin:.5em}.fc .fc-highlight{background:var(--fc-highlight-color)}.fc .fc-cell-shaded,.fc .fc-day-disabled{background:var(--fc-neutral-bg-color)}a.fc-event,a.fc-event:hover{text-decoration:none}.fc-event.fc-event-draggable,.fc-event[href]{cursor:pointer}.fc-event .fc-event-main{position:relative;z-index:2}.fc-event-dragging:not(.fc-event-selected){opacity:.75}.fc-event-dragging.fc-event-selected{box-shadow:0 2px 7px rgba(0,0,0,.3)}.fc-event .fc-event-resizer{display:none;position:absolute;z-index:4}.fc-event-selected .fc-event-resizer,.fc-event:hover .fc-event-resizer{display:block}.fc-event-selected .fc-event-resizer{background:var(--fc-page-bg-color);border-color:inherit;border-radius:calc(var(--fc-event-resizer-dot-total-width)/2);border-style:solid;border-width:var(--fc-event-resizer-dot-border-width);height:var(--fc-event-resizer-dot-total-width);width:var(--fc-event-resizer-dot-total-width)}.fc-event-selected .fc-event-resizer:before{bottom:-20px;content:\\\"\\\";left:-20px;position:absolute;right:-20px;top:-20px}.fc-event-selected,.fc-event:focus{box-shadow:0 2px 5px rgba(0,0,0,.2)}.fc-event-selected:before,.fc-event:focus:before{bottom:0;content:\\\"\\\";left:0;position:absolute;right:0;top:0;z-index:3}.fc-event-selected:after,.fc-event:focus:after{background:var(--fc-event-selected-overlay-color);bottom:-1px;content:\\\"\\\";left:-1px;position:absolute;right:-1px;top:-1px;z-index:1}.fc-h-event{background-color:var(--fc-event-bg-color);border:1px solid var(--fc-event-border-color);display:block}.fc-h-event .fc-event-main{color:var(--fc-event-text-color)}.fc-h-event .fc-event-main-frame{display:flex}.fc-h-event .fc-event-time{max-width:100%;overflow:hidden}.fc-h-event .fc-event-title-container{flex-grow:1;flex-shrink:1;min-width:0}.fc-h-event .fc-event-title{display:inline-block;left:0;max-width:100%;overflow:hidden;right:0;vertical-align:top}.fc-h-event.fc-event-selected:before{bottom:-10px;top:-10px}.fc-direction-ltr .fc-daygrid-block-event:not(.fc-event-start),.fc-direction-rtl .fc-daygrid-block-event:not(.fc-event-end){border-bottom-left-radius:0;border-left-width:0;border-top-left-radius:0}.fc-direction-ltr .fc-daygrid-block-event:not(.fc-event-end),.fc-direction-rtl .fc-daygrid-block-event:not(.fc-event-start){border-bottom-right-radius:0;border-right-width:0;border-top-right-radius:0}.fc-h-event:not(.fc-event-selected) .fc-event-resizer{bottom:0;top:0;width:var(--fc-event-resizer-thickness)}.fc-direction-ltr .fc-h-event:not(.fc-event-selected) .fc-event-resizer-start,.fc-direction-rtl .fc-h-event:not(.fc-event-selected) .fc-event-resizer-end{cursor:w-resize;left:calc(var(--fc-event-resizer-thickness)*-.5)}.fc-direction-ltr .fc-h-event:not(.fc-event-selected) .fc-event-resizer-end,.fc-direction-rtl .fc-h-event:not(.fc-event-selected) .fc-event-resizer-start{cursor:e-resize;right:calc(var(--fc-event-resizer-thickness)*-.5)}.fc-h-event.fc-event-selected .fc-event-resizer{margin-top:calc(var(--fc-event-resizer-dot-total-width)*-.5);top:50%}.fc-direction-ltr .fc-h-event.fc-event-selected .fc-event-resizer-start,.fc-direction-rtl .fc-h-event.fc-event-selected .fc-event-resizer-end{left:calc(var(--fc-event-resizer-dot-total-width)*-.5)}.fc-direction-ltr .fc-h-event.fc-event-selected .fc-event-resizer-end,.fc-direction-rtl .fc-h-event.fc-event-selected .fc-event-resizer-start{right:calc(var(--fc-event-resizer-dot-total-width)*-.5)}.fc .fc-popover{box-shadow:0 2px 6px rgba(0,0,0,.15);position:absolute;z-index:9999}.fc .fc-popover-header{align-items:center;display:flex;flex-direction:row;justify-content:space-between;padding:3px 4px}.fc .fc-popover-title{margin:0 2px}.fc .fc-popover-close{cursor:pointer;font-size:1.1em;opacity:.65}.fc-theme-standard .fc-popover{background:var(--fc-page-bg-color);border:1px solid var(--fc-border-color)}.fc-theme-standard .fc-popover-header{background:var(--fc-neutral-bg-color)}\";\n    injectStyles(css_248z$4);\n    function removeElement(el) {\n        if (el.parentNode) {\n            el.parentNode.removeChild(el);\n        }\n    }\n    // Querying\n    // ----------------------------------------------------------------------------------------------------------------\n    function elementClosest(el, selector) {\n        if (el.closest) {\n            return el.closest(selector);\n        // really bad fallback for IE\n        // from https://developer.mozilla.org/en-US/docs/Web/API/Element/closest\n        }\n        if (!document.documentElement.contains(el)) {\n            return null;\n        }\n        do {\n            if (elementMatches(el, selector)) {\n                return el;\n            }\n            el = el.parentElement || el.parentNode;\n        }while (el !== null && el.nodeType === 1);\n        return null;\n    }\n    function elementMatches(el, selector) {\n        let method = el.matches || el.matchesSelector || el.msMatchesSelector;\n        return method.call(el, selector);\n    }\n    // accepts multiple subject els\n    // returns a real array. good for methods like forEach\n    // TODO: accept the document\n    function findElements(container, selector) {\n        let containers = container instanceof HTMLElement ? [\n            container\n        ] : container;\n        let allMatches = [];\n        for(let i = 0; i < containers.length; i += 1){\n            let matches = containers[i].querySelectorAll(selector);\n            for(let j = 0; j < matches.length; j += 1){\n                allMatches.push(matches[j]);\n            }\n        }\n        return allMatches;\n    }\n    // accepts multiple subject els\n    // only queries direct child elements // TODO: rename to findDirectChildren!\n    function findDirectChildren(parent, selector) {\n        let parents = parent instanceof HTMLElement ? [\n            parent\n        ] : parent;\n        let allMatches = [];\n        for(let i = 0; i < parents.length; i += 1){\n            let childNodes = parents[i].children; // only ever elements\n            for(let j = 0; j < childNodes.length; j += 1){\n                let childNode = childNodes[j];\n                if (!selector || elementMatches(childNode, selector)) {\n                    allMatches.push(childNode);\n                }\n            }\n        }\n        return allMatches;\n    }\n    // Style\n    // ----------------------------------------------------------------------------------------------------------------\n    const PIXEL_PROP_RE = /(top|left|right|bottom|width|height)$/i;\n    function applyStyle(el, props) {\n        for(let propName in props){\n            applyStyleProp(el, propName, props[propName]);\n        }\n    }\n    function applyStyleProp(el, name, val) {\n        if (val == null) {\n            el.style[name] = '';\n        } else if (typeof val === 'number' && PIXEL_PROP_RE.test(name)) {\n            el.style[name] = `${val}px`;\n        } else {\n            el.style[name] = val;\n        }\n    }\n    // Event Handling\n    // ----------------------------------------------------------------------------------------------------------------\n    // if intercepting bubbled events at the document/window/body level,\n    // and want to see originating element (the 'target'), use this util instead\n    // of `ev.target` because it goes within web-component boundaries.\n    function getEventTargetViaRoot(ev) {\n        var _a, _b;\n        return (_b = (_a = ev.composedPath) === null || _a === void 0 ? void 0 : _a.call(ev)[0]) !== null && _b !== void 0 ? _b : ev.target;\n    }\n    // Unique ID for DOM attribute\n    let guid$1 = 0;\n    function getUniqueDomId() {\n        guid$1 += 1;\n        return 'fc-dom-' + guid$1;\n    }\n    // Stops a mouse/touch event from doing it's native browser action\n    function preventDefault(ev) {\n        ev.preventDefault();\n    }\n    // Event Delegation\n    // ----------------------------------------------------------------------------------------------------------------\n    function buildDelegationHandler(selector, handler) {\n        return (ev)=>{\n            let matchedChild = elementClosest(ev.target, selector);\n            if (matchedChild) {\n                handler.call(matchedChild, ev, matchedChild);\n            }\n        };\n    }\n    function listenBySelector(container, eventType, selector, handler) {\n        let attachedHandler = buildDelegationHandler(selector, handler);\n        container.addEventListener(eventType, attachedHandler);\n        return ()=>{\n            container.removeEventListener(eventType, attachedHandler);\n        };\n    }\n    function listenToHoverBySelector(container, selector, onMouseEnter, onMouseLeave) {\n        let currentMatchedChild;\n        return listenBySelector(container, 'mouseover', selector, (mouseOverEv, matchedChild)=>{\n            if (matchedChild !== currentMatchedChild) {\n                currentMatchedChild = matchedChild;\n                onMouseEnter(mouseOverEv, matchedChild);\n                let realOnMouseLeave = (mouseLeaveEv)=>{\n                    currentMatchedChild = null;\n                    onMouseLeave(mouseLeaveEv, matchedChild);\n                    matchedChild.removeEventListener('mouseleave', realOnMouseLeave);\n                };\n                // listen to the next mouseleave, and then unattach\n                matchedChild.addEventListener('mouseleave', realOnMouseLeave);\n            }\n        });\n    }\n    // Animation\n    // ----------------------------------------------------------------------------------------------------------------\n    const transitionEventNames = [\n        'webkitTransitionEnd',\n        'otransitionend',\n        'oTransitionEnd',\n        'msTransitionEnd',\n        'transitionend'\n    ];\n    // triggered only when the next single subsequent transition finishes\n    function whenTransitionDone(el, callback) {\n        let realCallback = (ev)=>{\n            callback(ev);\n            transitionEventNames.forEach((eventName)=>{\n                el.removeEventListener(eventName, realCallback);\n            });\n        };\n        transitionEventNames.forEach((eventName)=>{\n            el.addEventListener(eventName, realCallback); // cross-browser way to determine when the transition finishes\n        });\n    }\n    // ARIA workarounds\n    // ----------------------------------------------------------------------------------------------------------------\n    function createAriaClickAttrs(handler) {\n        return Object.assign({\n            onClick: handler\n        }, createAriaKeyboardAttrs(handler));\n    }\n    function createAriaKeyboardAttrs(handler) {\n        return {\n            tabIndex: 0,\n            onKeyDown (ev) {\n                if (ev.key === 'Enter' || ev.key === ' ') {\n                    handler(ev);\n                    ev.preventDefault(); // if space, don't scroll down page\n                }\n            }\n        };\n    }\n    let guidNumber = 0;\n    function guid() {\n        guidNumber += 1;\n        return String(guidNumber);\n    }\n    /* FullCalendar-specific DOM Utilities\r\n    ----------------------------------------------------------------------------------------------------------------------*/ // Make the mouse cursor express that an event is not allowed in the current area\n    function disableCursor() {\n        document.body.classList.add('fc-not-allowed');\n    }\n    // Returns the mouse cursor to its original look\n    function enableCursor() {\n        document.body.classList.remove('fc-not-allowed');\n    }\n    /* Selection\r\n    ----------------------------------------------------------------------------------------------------------------------*/ function preventSelection(el) {\n        el.style.userSelect = 'none';\n        el.addEventListener('selectstart', preventDefault);\n    }\n    function allowSelection(el) {\n        el.style.userSelect = '';\n        el.removeEventListener('selectstart', preventDefault);\n    }\n    /* Context Menu\r\n    ----------------------------------------------------------------------------------------------------------------------*/ function preventContextMenu(el) {\n        el.addEventListener('contextmenu', preventDefault);\n    }\n    function allowContextMenu(el) {\n        el.removeEventListener('contextmenu', preventDefault);\n    }\n    function parseFieldSpecs(input) {\n        let specs = [];\n        let tokens = [];\n        let i;\n        let token;\n        if (typeof input === 'string') {\n            tokens = input.split(/\\s*,\\s*/);\n        } else if (typeof input === 'function') {\n            tokens = [\n                input\n            ];\n        } else if (Array.isArray(input)) {\n            tokens = input;\n        }\n        for(i = 0; i < tokens.length; i += 1){\n            token = tokens[i];\n            if (typeof token === 'string') {\n                specs.push(token.charAt(0) === '-' ? {\n                    field: token.substring(1),\n                    order: -1\n                } : {\n                    field: token,\n                    order: 1\n                });\n            } else if (typeof token === 'function') {\n                specs.push({\n                    func: token\n                });\n            }\n        }\n        return specs;\n    }\n    function compareByFieldSpecs(obj0, obj1, fieldSpecs) {\n        let i;\n        let cmp;\n        for(i = 0; i < fieldSpecs.length; i += 1){\n            cmp = compareByFieldSpec(obj0, obj1, fieldSpecs[i]);\n            if (cmp) {\n                return cmp;\n            }\n        }\n        return 0;\n    }\n    function compareByFieldSpec(obj0, obj1, fieldSpec) {\n        if (fieldSpec.func) {\n            return fieldSpec.func(obj0, obj1);\n        }\n        return flexibleCompare(obj0[fieldSpec.field], obj1[fieldSpec.field]) * (fieldSpec.order || 1);\n    }\n    function flexibleCompare(a, b) {\n        if (!a && !b) {\n            return 0;\n        }\n        if (b == null) {\n            return -1;\n        }\n        if (a == null) {\n            return 1;\n        }\n        if (typeof a === 'string' || typeof b === 'string') {\n            return String(a).localeCompare(String(b));\n        }\n        return a - b;\n    }\n    /* String Utilities\r\n    ----------------------------------------------------------------------------------------------------------------------*/ function padStart(val, len) {\n        let s = String(val);\n        return '000'.substr(0, len - s.length) + s;\n    }\n    function formatWithOrdinals(formatter, args, fallbackText) {\n        if (typeof formatter === 'function') {\n            return formatter(...args);\n        }\n        if (typeof formatter === 'string') {\n            return args.reduce((str, arg, index)=>str.replace('$' + index, arg || ''), formatter);\n        }\n        return fallbackText;\n    }\n    /* Number Utilities\r\n    ----------------------------------------------------------------------------------------------------------------------*/ function compareNumbers(a, b) {\n        return a - b;\n    }\n    function isInt(n) {\n        return n % 1 === 0;\n    }\n    /* FC-specific DOM dimension stuff\r\n    ----------------------------------------------------------------------------------------------------------------------*/ function computeSmallestCellWidth(cellEl) {\n        let allWidthEl = cellEl.querySelector('.fc-scrollgrid-shrink-frame');\n        let contentWidthEl = cellEl.querySelector('.fc-scrollgrid-shrink-cushion');\n        if (!allWidthEl) {\n            throw new Error('needs fc-scrollgrid-shrink-frame className'); // TODO: use const\n        }\n        if (!contentWidthEl) {\n            throw new Error('needs fc-scrollgrid-shrink-cushion className');\n        }\n        return cellEl.getBoundingClientRect().width - allWidthEl.getBoundingClientRect().width + // the cell padding+border\n        contentWidthEl.getBoundingClientRect().width;\n    }\n    const INTERNAL_UNITS = [\n        'years',\n        'months',\n        'days',\n        'milliseconds'\n    ];\n    const PARSE_RE = /^(-?)(?:(\\d+)\\.)?(\\d+):(\\d\\d)(?::(\\d\\d)(?:\\.(\\d\\d\\d))?)?/;\n    // Parsing and Creation\n    function createDuration(input, unit) {\n        if (typeof input === 'string') {\n            return parseString(input);\n        }\n        if (typeof input === 'object' && input) {\n            return parseObject(input);\n        }\n        if (typeof input === 'number') {\n            return parseObject({\n                [unit || 'milliseconds']: input\n            });\n        }\n        return null;\n    }\n    function parseString(s) {\n        let m = PARSE_RE.exec(s);\n        if (m) {\n            let sign = m[1] ? -1 : 1;\n            return {\n                years: 0,\n                months: 0,\n                days: sign * (m[2] ? parseInt(m[2], 10) : 0),\n                milliseconds: sign * ((m[3] ? parseInt(m[3], 10) : 0) * 60 * 60 * 1000 + // hours\n                (m[4] ? parseInt(m[4], 10) : 0) * 60 * 1000 + // minutes\n                (m[5] ? parseInt(m[5], 10) : 0) * 1000 + // seconds\n                (m[6] ? parseInt(m[6], 10) : 0 // ms\n                ))\n            };\n        }\n        return null;\n    }\n    function parseObject(obj) {\n        let duration = {\n            years: obj.years || obj.year || 0,\n            months: obj.months || obj.month || 0,\n            days: obj.days || obj.day || 0,\n            milliseconds: (obj.hours || obj.hour || 0) * 60 * 60 * 1000 + // hours\n            (obj.minutes || obj.minute || 0) * 60 * 1000 + // minutes\n            (obj.seconds || obj.second || 0) * 1000 + // seconds\n            (obj.milliseconds || obj.millisecond || obj.ms || 0)\n        };\n        let weeks = obj.weeks || obj.week;\n        if (weeks) {\n            duration.days += weeks * 7;\n            duration.specifiedWeeks = true;\n        }\n        return duration;\n    }\n    // Equality\n    function durationsEqual(d0, d1) {\n        return d0.years === d1.years && d0.months === d1.months && d0.days === d1.days && d0.milliseconds === d1.milliseconds;\n    }\n    function asCleanDays(dur) {\n        if (!dur.years && !dur.months && !dur.milliseconds) {\n            return dur.days;\n        }\n        return 0;\n    }\n    // Simple Math\n    function addDurations(d0, d1) {\n        return {\n            years: d0.years + d1.years,\n            months: d0.months + d1.months,\n            days: d0.days + d1.days,\n            milliseconds: d0.milliseconds + d1.milliseconds\n        };\n    }\n    function subtractDurations(d1, d0) {\n        return {\n            years: d1.years - d0.years,\n            months: d1.months - d0.months,\n            days: d1.days - d0.days,\n            milliseconds: d1.milliseconds - d0.milliseconds\n        };\n    }\n    function multiplyDuration(d, n) {\n        return {\n            years: d.years * n,\n            months: d.months * n,\n            days: d.days * n,\n            milliseconds: d.milliseconds * n\n        };\n    }\n    // Conversions\n    // \"Rough\" because they are based on average-case Gregorian months/years\n    function asRoughYears(dur) {\n        return asRoughDays(dur) / 365;\n    }\n    function asRoughMonths(dur) {\n        return asRoughDays(dur) / 30;\n    }\n    function asRoughDays(dur) {\n        return asRoughMs(dur) / 864e5;\n    }\n    function asRoughMinutes(dur) {\n        return asRoughMs(dur) / (1000 * 60);\n    }\n    function asRoughSeconds(dur) {\n        return asRoughMs(dur) / 1000;\n    }\n    function asRoughMs(dur) {\n        return dur.years * (365 * 864e5) + dur.months * (30 * 864e5) + dur.days * 864e5 + dur.milliseconds;\n    }\n    // Advanced Math\n    function wholeDivideDurations(numerator, denominator) {\n        let res = null;\n        for(let i = 0; i < INTERNAL_UNITS.length; i += 1){\n            let unit = INTERNAL_UNITS[i];\n            if (denominator[unit]) {\n                let localRes = numerator[unit] / denominator[unit];\n                if (!isInt(localRes) || res !== null && res !== localRes) {\n                    return null;\n                }\n                res = localRes;\n            } else if (numerator[unit]) {\n                // needs to divide by something but can't!\n                return null;\n            }\n        }\n        return res;\n    }\n    function greatestDurationDenominator(dur) {\n        let ms = dur.milliseconds;\n        if (ms) {\n            if (ms % 1000 !== 0) {\n                return {\n                    unit: 'millisecond',\n                    value: ms\n                };\n            }\n            if (ms % (1000 * 60) !== 0) {\n                return {\n                    unit: 'second',\n                    value: ms / 1000\n                };\n            }\n            if (ms % (1000 * 60 * 60) !== 0) {\n                return {\n                    unit: 'minute',\n                    value: ms / (1000 * 60)\n                };\n            }\n            if (ms) {\n                return {\n                    unit: 'hour',\n                    value: ms / (1000 * 60 * 60)\n                };\n            }\n        }\n        if (dur.days) {\n            if (dur.specifiedWeeks && dur.days % 7 === 0) {\n                return {\n                    unit: 'week',\n                    value: dur.days / 7\n                };\n            }\n            return {\n                unit: 'day',\n                value: dur.days\n            };\n        }\n        if (dur.months) {\n            return {\n                unit: 'month',\n                value: dur.months\n            };\n        }\n        if (dur.years) {\n            return {\n                unit: 'year',\n                value: dur.years\n            };\n        }\n        return {\n            unit: 'millisecond',\n            value: 0\n        };\n    }\n    const { hasOwnProperty } = Object.prototype;\n    // Merges an array of objects into a single object.\n    // The second argument allows for an array of property names who's object values will be merged together.\n    function mergeProps(propObjs, complexPropsMap) {\n        let dest = {};\n        if (complexPropsMap) {\n            for(let name in complexPropsMap){\n                if (complexPropsMap[name] === isMaybeObjectsEqual) {\n                    let complexObjs = [];\n                    // collect the trailing object values, stopping when a non-object is discovered\n                    for(let i = propObjs.length - 1; i >= 0; i -= 1){\n                        let val = propObjs[i][name];\n                        if (typeof val === 'object' && val) {\n                            complexObjs.unshift(val);\n                        } else if (val !== undefined) {\n                            dest[name] = val; // if there were no objects, this value will be used\n                            break;\n                        }\n                    }\n                    // if the trailing values were objects, use the merged value\n                    if (complexObjs.length) {\n                        dest[name] = mergeProps(complexObjs);\n                    }\n                }\n            }\n        }\n        // copy values into the destination, going from last to first\n        for(let i = propObjs.length - 1; i >= 0; i -= 1){\n            let props = propObjs[i];\n            for(let name in props){\n                if (!(name in dest)) {\n                    dest[name] = props[name];\n                }\n            }\n        }\n        return dest;\n    }\n    function filterHash(hash, func) {\n        let filtered = {};\n        for(let key in hash){\n            if (func(hash[key], key)) {\n                filtered[key] = hash[key];\n            }\n        }\n        return filtered;\n    }\n    function mapHash(hash, func) {\n        let newHash = {};\n        for(let key in hash){\n            newHash[key] = func(hash[key], key);\n        }\n        return newHash;\n    }\n    function arrayToHash(a) {\n        let hash = {};\n        for (let item of a){\n            hash[item] = true;\n        }\n        return hash;\n    }\n    // TODO: reassess browser support\n    // https://caniuse.com/?search=object.values\n    function hashValuesToArray(obj) {\n        let a = [];\n        for(let key in obj){\n            a.push(obj[key]);\n        }\n        return a;\n    }\n    function isPropsEqual(obj0, obj1) {\n        if (obj0 === obj1) {\n            return true;\n        }\n        for(let key in obj0){\n            if (hasOwnProperty.call(obj0, key)) {\n                if (!(key in obj1)) {\n                    return false;\n                }\n            }\n        }\n        for(let key in obj1){\n            if (hasOwnProperty.call(obj1, key)) {\n                if (obj0[key] !== obj1[key]) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    const HANDLER_RE = /^on[A-Z]/;\n    function isNonHandlerPropsEqual(obj0, obj1) {\n        const keys = getUnequalProps(obj0, obj1);\n        for (let key of keys){\n            if (!HANDLER_RE.test(key)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    function getUnequalProps(obj0, obj1) {\n        let keys = [];\n        for(let key in obj0){\n            if (hasOwnProperty.call(obj0, key)) {\n                if (!(key in obj1)) {\n                    keys.push(key);\n                }\n            }\n        }\n        for(let key in obj1){\n            if (hasOwnProperty.call(obj1, key)) {\n                if (obj0[key] !== obj1[key]) {\n                    keys.push(key);\n                }\n            }\n        }\n        return keys;\n    }\n    function compareObjs(oldProps, newProps, equalityFuncs = {}) {\n        if (oldProps === newProps) {\n            return true;\n        }\n        for(let key in newProps){\n            if (key in oldProps && isObjValsEqual(oldProps[key], newProps[key], equalityFuncs[key])) ;\n            else {\n                return false;\n            }\n        }\n        // check for props that were omitted in the new\n        for(let key in oldProps){\n            if (!(key in newProps)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /*\r\n    assumed \"true\" equality for handler names like \"onReceiveSomething\"\r\n    */ function isObjValsEqual(val0, val1, comparator) {\n        if (val0 === val1 || comparator === true) {\n            return true;\n        }\n        if (comparator) {\n            return comparator(val0, val1);\n        }\n        return false;\n    }\n    function collectFromHash(hash, startIndex = 0, endIndex, step = 1) {\n        let res = [];\n        if (endIndex == null) {\n            endIndex = Object.keys(hash).length;\n        }\n        for(let i = startIndex; i < endIndex; i += step){\n            let val = hash[i];\n            if (val !== undefined) {\n                res.push(val);\n            }\n        }\n        return res;\n    }\n    // TODO: new util arrayify?\n    function removeExact(array, exactVal) {\n        let removeCnt = 0;\n        let i = 0;\n        while(i < array.length){\n            if (array[i] === exactVal) {\n                array.splice(i, 1);\n                removeCnt += 1;\n            } else {\n                i += 1;\n            }\n        }\n        return removeCnt;\n    }\n    function isArraysEqual(a0, a1, equalityFunc) {\n        if (a0 === a1) {\n            return true;\n        }\n        let len = a0.length;\n        let i;\n        if (len !== a1.length) {\n            return false;\n        }\n        for(i = 0; i < len; i += 1){\n            if (!(equalityFunc ? equalityFunc(a0[i], a1[i]) : a0[i] === a1[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    const DAY_IDS = [\n        'sun',\n        'mon',\n        'tue',\n        'wed',\n        'thu',\n        'fri',\n        'sat'\n    ];\n    // Adding\n    function addWeeks(m, n) {\n        let a = dateToUtcArray(m);\n        a[2] += n * 7;\n        return arrayToUtcDate(a);\n    }\n    function addDays(m, n) {\n        let a = dateToUtcArray(m);\n        a[2] += n;\n        return arrayToUtcDate(a);\n    }\n    function addMs(m, n) {\n        let a = dateToUtcArray(m);\n        a[6] += n;\n        return arrayToUtcDate(a);\n    }\n    // Diffing (all return floats)\n    // TODO: why not use ranges?\n    function diffWeeks(m0, m1) {\n        return diffDays(m0, m1) / 7;\n    }\n    function diffDays(m0, m1) {\n        return (m1.valueOf() - m0.valueOf()) / (1000 * 60 * 60 * 24);\n    }\n    function diffHours(m0, m1) {\n        return (m1.valueOf() - m0.valueOf()) / (1000 * 60 * 60);\n    }\n    function diffMinutes(m0, m1) {\n        return (m1.valueOf() - m0.valueOf()) / (1000 * 60);\n    }\n    function diffSeconds(m0, m1) {\n        return (m1.valueOf() - m0.valueOf()) / 1000;\n    }\n    function diffDayAndTime(m0, m1) {\n        let m0day = startOfDay(m0);\n        let m1day = startOfDay(m1);\n        return {\n            years: 0,\n            months: 0,\n            days: Math.round(diffDays(m0day, m1day)),\n            milliseconds: m1.valueOf() - m1day.valueOf() - (m0.valueOf() - m0day.valueOf())\n        };\n    }\n    // Diffing Whole Units\n    function diffWholeWeeks(m0, m1) {\n        let d = diffWholeDays(m0, m1);\n        if (d !== null && d % 7 === 0) {\n            return d / 7;\n        }\n        return null;\n    }\n    function diffWholeDays(m0, m1) {\n        if (timeAsMs(m0) === timeAsMs(m1)) {\n            return Math.round(diffDays(m0, m1));\n        }\n        return null;\n    }\n    // Start-Of\n    function startOfDay(m) {\n        return arrayToUtcDate([\n            m.getUTCFullYear(),\n            m.getUTCMonth(),\n            m.getUTCDate()\n        ]);\n    }\n    function startOfHour(m) {\n        return arrayToUtcDate([\n            m.getUTCFullYear(),\n            m.getUTCMonth(),\n            m.getUTCDate(),\n            m.getUTCHours()\n        ]);\n    }\n    function startOfMinute(m) {\n        return arrayToUtcDate([\n            m.getUTCFullYear(),\n            m.getUTCMonth(),\n            m.getUTCDate(),\n            m.getUTCHours(),\n            m.getUTCMinutes()\n        ]);\n    }\n    function startOfSecond(m) {\n        return arrayToUtcDate([\n            m.getUTCFullYear(),\n            m.getUTCMonth(),\n            m.getUTCDate(),\n            m.getUTCHours(),\n            m.getUTCMinutes(),\n            m.getUTCSeconds()\n        ]);\n    }\n    // Week Computation\n    function weekOfYear(marker, dow, doy) {\n        let y = marker.getUTCFullYear();\n        let w = weekOfGivenYear(marker, y, dow, doy);\n        if (w < 1) {\n            return weekOfGivenYear(marker, y - 1, dow, doy);\n        }\n        let nextW = weekOfGivenYear(marker, y + 1, dow, doy);\n        if (nextW >= 1) {\n            return Math.min(w, nextW);\n        }\n        return w;\n    }\n    function weekOfGivenYear(marker, year, dow, doy) {\n        let firstWeekStart = arrayToUtcDate([\n            year,\n            0,\n            1 + firstWeekOffset(year, dow, doy)\n        ]);\n        let dayStart = startOfDay(marker);\n        let days = Math.round(diffDays(firstWeekStart, dayStart));\n        return Math.floor(days / 7) + 1; // zero-indexed\n    }\n    // start-of-first-week - start-of-year\n    function firstWeekOffset(year, dow, doy) {\n        // first-week day -- which january is always in the first week (4 for iso, 1 for other)\n        let fwd = 7 + dow - doy;\n        // first-week day local weekday -- which local weekday is fwd\n        let fwdlw = (7 + arrayToUtcDate([\n            year,\n            0,\n            fwd\n        ]).getUTCDay() - dow) % 7;\n        return -fwdlw + fwd - 1;\n    }\n    // Array Conversion\n    function dateToLocalArray(date) {\n        return [\n            date.getFullYear(),\n            date.getMonth(),\n            date.getDate(),\n            date.getHours(),\n            date.getMinutes(),\n            date.getSeconds(),\n            date.getMilliseconds()\n        ];\n    }\n    function arrayToLocalDate(a) {\n        return new Date(a[0], a[1] || 0, a[2] == null ? 1 : a[2], a[3] || 0, a[4] || 0, a[5] || 0);\n    }\n    function dateToUtcArray(date) {\n        return [\n            date.getUTCFullYear(),\n            date.getUTCMonth(),\n            date.getUTCDate(),\n            date.getUTCHours(),\n            date.getUTCMinutes(),\n            date.getUTCSeconds(),\n            date.getUTCMilliseconds()\n        ];\n    }\n    function arrayToUtcDate(a) {\n        // according to web standards (and Safari), a month index is required.\n        // massage if only given a year.\n        if (a.length === 1) {\n            a = a.concat([\n                0\n            ]);\n        }\n        return new Date(Date.UTC(...a));\n    }\n    // Other Utils\n    function isValidDate(m) {\n        return !isNaN(m.valueOf());\n    }\n    function timeAsMs(m) {\n        return m.getUTCHours() * 1000 * 60 * 60 + m.getUTCMinutes() * 1000 * 60 + m.getUTCSeconds() * 1000 + m.getUTCMilliseconds();\n    }\n    // timeZoneOffset is in minutes\n    function buildIsoString(marker, timeZoneOffset, stripZeroTime = false) {\n        let s = marker.toISOString();\n        s = s.replace('.000', '');\n        if (stripZeroTime) {\n            s = s.replace('T00:00:00Z', '');\n        }\n        if (s.length > 10) {\n            if (timeZoneOffset == null) {\n                s = s.replace('Z', '');\n            } else if (timeZoneOffset !== 0) {\n                s = s.replace('Z', formatTimeZoneOffset(timeZoneOffset, true));\n            }\n        // otherwise, its UTC-0 and we want to keep the Z\n        }\n        return s;\n    }\n    // formats the date, but with no time part\n    // TODO: somehow merge with buildIsoString and stripZeroTime\n    // TODO: rename. omit \"string\"\n    function formatDayString(marker) {\n        return marker.toISOString().replace(/T.*$/, '');\n    }\n    function formatIsoMonthStr(marker) {\n        return marker.toISOString().match(/^\\d{4}-\\d{2}/)[0];\n    }\n    // TODO: use Date::toISOString and use everything after the T?\n    function formatIsoTimeString(marker) {\n        return padStart(marker.getUTCHours(), 2) + ':' + padStart(marker.getUTCMinutes(), 2) + ':' + padStart(marker.getUTCSeconds(), 2);\n    }\n    function formatTimeZoneOffset(minutes, doIso = false) {\n        let sign = minutes < 0 ? '-' : '+';\n        let abs = Math.abs(minutes);\n        let hours = Math.floor(abs / 60);\n        let mins = Math.round(abs % 60);\n        if (doIso) {\n            return `${sign + padStart(hours, 2)}:${padStart(mins, 2)}`;\n        }\n        return `GMT${sign}${hours}${mins ? `:${padStart(mins, 2)}` : ''}`;\n    }\n    function memoize(workerFunc, resEquality, teardownFunc) {\n        let currentArgs;\n        let currentRes;\n        return function(...newArgs) {\n            if (!currentArgs) {\n                currentRes = workerFunc.apply(this, newArgs);\n            } else if (!isArraysEqual(currentArgs, newArgs)) {\n                if (teardownFunc) {\n                    teardownFunc(currentRes);\n                }\n                let res = workerFunc.apply(this, newArgs);\n                if (!resEquality || !resEquality(res, currentRes)) {\n                    currentRes = res;\n                }\n            }\n            currentArgs = newArgs;\n            return currentRes;\n        };\n    }\n    function memoizeObjArg(workerFunc, resEquality, teardownFunc) {\n        let currentArg;\n        let currentRes;\n        return (newArg)=>{\n            if (!currentArg) {\n                currentRes = workerFunc.call(this, newArg);\n            } else if (!isPropsEqual(currentArg, newArg)) {\n                if (teardownFunc) {\n                    teardownFunc(currentRes);\n                }\n                let res = workerFunc.call(this, newArg);\n                if (!resEquality || !resEquality(res, currentRes)) {\n                    currentRes = res;\n                }\n            }\n            currentArg = newArg;\n            return currentRes;\n        };\n    }\n    function memoizeArraylike(workerFunc, resEquality, teardownFunc) {\n        let currentArgSets = [];\n        let currentResults = [];\n        return (newArgSets)=>{\n            let currentLen = currentArgSets.length;\n            let newLen = newArgSets.length;\n            let i = 0;\n            for(; i < currentLen; i += 1){\n                if (!newArgSets[i]) {\n                    if (teardownFunc) {\n                        teardownFunc(currentResults[i]);\n                    }\n                } else if (!isArraysEqual(currentArgSets[i], newArgSets[i])) {\n                    if (teardownFunc) {\n                        teardownFunc(currentResults[i]);\n                    }\n                    let res = workerFunc.apply(this, newArgSets[i]);\n                    if (!resEquality || !resEquality(res, currentResults[i])) {\n                        currentResults[i] = res;\n                    }\n                }\n            }\n            for(; i < newLen; i += 1){\n                currentResults[i] = workerFunc.apply(this, newArgSets[i]);\n            }\n            currentArgSets = newArgSets;\n            currentResults.splice(newLen); // remove excess\n            return currentResults;\n        };\n    }\n    function memoizeHashlike(workerFunc, resEquality, teardownFunc) {\n        let currentArgHash = {};\n        let currentResHash = {};\n        return (newArgHash)=>{\n            let newResHash = {};\n            for(let key in newArgHash){\n                if (!currentResHash[key]) {\n                    newResHash[key] = workerFunc.apply(this, newArgHash[key]);\n                } else if (!isArraysEqual(currentArgHash[key], newArgHash[key])) {\n                    if (teardownFunc) {\n                        teardownFunc(currentResHash[key]);\n                    }\n                    let res = workerFunc.apply(this, newArgHash[key]);\n                    newResHash[key] = resEquality && resEquality(res, currentResHash[key]) ? currentResHash[key] : res;\n                } else {\n                    newResHash[key] = currentResHash[key];\n                }\n            }\n            currentArgHash = newArgHash;\n            currentResHash = newResHash;\n            return newResHash;\n        };\n    }\n    const EXTENDED_SETTINGS_AND_SEVERITIES = {\n        week: 3,\n        separator: 0,\n        omitZeroMinute: 0,\n        meridiem: 0,\n        omitCommas: 0\n    };\n    const STANDARD_DATE_PROP_SEVERITIES = {\n        timeZoneName: 7,\n        era: 6,\n        year: 5,\n        month: 4,\n        day: 2,\n        weekday: 2,\n        hour: 1,\n        minute: 1,\n        second: 1\n    };\n    const MERIDIEM_RE = /\\s*([ap])\\.?m\\.?/i; // eats up leading spaces too\n    const COMMA_RE = /,/g; // we need re for globalness\n    const MULTI_SPACE_RE = /\\s+/g;\n    const LTR_RE = /\\u200e/g; // control character\n    const UTC_RE = /UTC|GMT/;\n    class NativeFormatter {\n        constructor(formatSettings){\n            let standardDateProps = {};\n            let extendedSettings = {};\n            let severity = 0;\n            for(let name in formatSettings){\n                if (name in EXTENDED_SETTINGS_AND_SEVERITIES) {\n                    extendedSettings[name] = formatSettings[name];\n                    severity = Math.max(EXTENDED_SETTINGS_AND_SEVERITIES[name], severity);\n                } else {\n                    standardDateProps[name] = formatSettings[name];\n                    if (name in STANDARD_DATE_PROP_SEVERITIES) {\n                        severity = Math.max(STANDARD_DATE_PROP_SEVERITIES[name], severity);\n                    }\n                }\n            }\n            this.standardDateProps = standardDateProps;\n            this.extendedSettings = extendedSettings;\n            this.severity = severity;\n            this.buildFormattingFunc = memoize(buildFormattingFunc);\n        }\n        format(date, context) {\n            return this.buildFormattingFunc(this.standardDateProps, this.extendedSettings, context)(date);\n        }\n        formatRange(start, end, context, betterDefaultSeparator) {\n            let { standardDateProps, extendedSettings } = this;\n            let diffSeverity = computeMarkerDiffSeverity(start.marker, end.marker, context.calendarSystem);\n            if (!diffSeverity) {\n                return this.format(start, context);\n            }\n            let biggestUnitForPartial = diffSeverity;\n            if (biggestUnitForPartial > 1 && // the two dates are different in a way that's larger scale than time\n            (standardDateProps.year === 'numeric' || standardDateProps.year === '2-digit') && (standardDateProps.month === 'numeric' || standardDateProps.month === '2-digit') && (standardDateProps.day === 'numeric' || standardDateProps.day === '2-digit')) {\n                biggestUnitForPartial = 1; // make it look like the dates are only different in terms of time\n            }\n            let full0 = this.format(start, context);\n            let full1 = this.format(end, context);\n            if (full0 === full1) {\n                return full0;\n            }\n            let partialDateProps = computePartialFormattingOptions(standardDateProps, biggestUnitForPartial);\n            let partialFormattingFunc = buildFormattingFunc(partialDateProps, extendedSettings, context);\n            let partial0 = partialFormattingFunc(start);\n            let partial1 = partialFormattingFunc(end);\n            let insertion = findCommonInsertion(full0, partial0, full1, partial1);\n            let separator = extendedSettings.separator || betterDefaultSeparator || context.defaultSeparator || '';\n            if (insertion) {\n                return insertion.before + partial0 + separator + partial1 + insertion.after;\n            }\n            return full0 + separator + full1;\n        }\n        getLargestUnit() {\n            switch(this.severity){\n                case 7:\n                case 6:\n                case 5:\n                    return 'year';\n                case 4:\n                    return 'month';\n                case 3:\n                    return 'week';\n                case 2:\n                    return 'day';\n                default:\n                    return 'time'; // really?\n            }\n        }\n    }\n    function buildFormattingFunc(standardDateProps, extendedSettings, context) {\n        let standardDatePropCnt = Object.keys(standardDateProps).length;\n        if (standardDatePropCnt === 1 && standardDateProps.timeZoneName === 'short') {\n            return (date)=>formatTimeZoneOffset(date.timeZoneOffset);\n        }\n        if (standardDatePropCnt === 0 && extendedSettings.week) {\n            return (date)=>formatWeekNumber(context.computeWeekNumber(date.marker), context.weekText, context.weekTextLong, context.locale, extendedSettings.week);\n        }\n        return buildNativeFormattingFunc(standardDateProps, extendedSettings, context);\n    }\n    function buildNativeFormattingFunc(standardDateProps, extendedSettings, context) {\n        standardDateProps = Object.assign({}, standardDateProps); // copy\n        extendedSettings = Object.assign({}, extendedSettings); // copy\n        sanitizeSettings(standardDateProps, extendedSettings);\n        standardDateProps.timeZone = 'UTC'; // we leverage the only guaranteed timeZone for our UTC markers\n        let normalFormat = new Intl.DateTimeFormat(context.locale.codes, standardDateProps);\n        let zeroFormat; // needed?\n        if (extendedSettings.omitZeroMinute) {\n            let zeroProps = Object.assign({}, standardDateProps);\n            delete zeroProps.minute; // seconds and ms were already considered in sanitizeSettings\n            zeroFormat = new Intl.DateTimeFormat(context.locale.codes, zeroProps);\n        }\n        return (date)=>{\n            let { marker } = date;\n            let format;\n            if (zeroFormat && !marker.getUTCMinutes()) {\n                format = zeroFormat;\n            } else {\n                format = normalFormat;\n            }\n            let s = format.format(marker);\n            return postProcess(s, date, standardDateProps, extendedSettings, context);\n        };\n    }\n    function sanitizeSettings(standardDateProps, extendedSettings) {\n        // deal with a browser inconsistency where formatting the timezone\n        // requires that the hour/minute be present.\n        if (standardDateProps.timeZoneName) {\n            if (!standardDateProps.hour) {\n                standardDateProps.hour = '2-digit';\n            }\n            if (!standardDateProps.minute) {\n                standardDateProps.minute = '2-digit';\n            }\n        }\n        // only support short timezone names\n        if (standardDateProps.timeZoneName === 'long') {\n            standardDateProps.timeZoneName = 'short';\n        }\n        // if requesting to display seconds, MUST display minutes\n        if (extendedSettings.omitZeroMinute && (standardDateProps.second || standardDateProps.millisecond)) {\n            delete extendedSettings.omitZeroMinute;\n        }\n    }\n    function postProcess(s, date, standardDateProps, extendedSettings, context) {\n        s = s.replace(LTR_RE, ''); // remove left-to-right control chars. do first. good for other regexes\n        if (standardDateProps.timeZoneName === 'short') {\n            s = injectTzoStr(s, context.timeZone === 'UTC' || date.timeZoneOffset == null ? 'UTC' : formatTimeZoneOffset(date.timeZoneOffset));\n        }\n        if (extendedSettings.omitCommas) {\n            s = s.replace(COMMA_RE, '').trim();\n        }\n        if (extendedSettings.omitZeroMinute) {\n            s = s.replace(':00', ''); // zeroFormat doesn't always achieve this\n        }\n        // ^ do anything that might create adjacent spaces before this point,\n        // because MERIDIEM_RE likes to eat up loading spaces\n        if (extendedSettings.meridiem === false) {\n            s = s.replace(MERIDIEM_RE, '').trim();\n        } else if (extendedSettings.meridiem === 'narrow') {\n            s = s.replace(MERIDIEM_RE, (m0, m1)=>m1.toLocaleLowerCase());\n        } else if (extendedSettings.meridiem === 'short') {\n            s = s.replace(MERIDIEM_RE, (m0, m1)=>`${m1.toLocaleLowerCase()}m`);\n        } else if (extendedSettings.meridiem === 'lowercase') {\n            s = s.replace(MERIDIEM_RE, (m0)=>m0.toLocaleLowerCase());\n        }\n        s = s.replace(MULTI_SPACE_RE, ' ');\n        s = s.trim();\n        return s;\n    }\n    function injectTzoStr(s, tzoStr) {\n        let replaced = false;\n        s = s.replace(UTC_RE, ()=>{\n            replaced = true;\n            return tzoStr;\n        });\n        // IE11 doesn't include UTC/GMT in the original string, so append to end\n        if (!replaced) {\n            s += ` ${tzoStr}`;\n        }\n        return s;\n    }\n    function formatWeekNumber(num, weekText, weekTextLong, locale, display) {\n        let parts = [];\n        if (display === 'long') {\n            parts.push(weekTextLong);\n        } else if (display === 'short' || display === 'narrow') {\n            parts.push(weekText);\n        }\n        if (display === 'long' || display === 'short') {\n            parts.push(' ');\n        }\n        parts.push(locale.simpleNumberFormat.format(num));\n        if (locale.options.direction === 'rtl') {\n            parts.reverse();\n        }\n        return parts.join('');\n    }\n    // Range Formatting Utils\n    // 0 = exactly the same\n    // 1 = different by time\n    // and bigger\n    function computeMarkerDiffSeverity(d0, d1, ca) {\n        if (ca.getMarkerYear(d0) !== ca.getMarkerYear(d1)) {\n            return 5;\n        }\n        if (ca.getMarkerMonth(d0) !== ca.getMarkerMonth(d1)) {\n            return 4;\n        }\n        if (ca.getMarkerDay(d0) !== ca.getMarkerDay(d1)) {\n            return 2;\n        }\n        if (timeAsMs(d0) !== timeAsMs(d1)) {\n            return 1;\n        }\n        return 0;\n    }\n    function computePartialFormattingOptions(options, biggestUnit) {\n        let partialOptions = {};\n        for(let name in options){\n            if (!(name in STANDARD_DATE_PROP_SEVERITIES) || // not a date part prop (like timeZone)\n            STANDARD_DATE_PROP_SEVERITIES[name] <= biggestUnit) {\n                partialOptions[name] = options[name];\n            }\n        }\n        return partialOptions;\n    }\n    function findCommonInsertion(full0, partial0, full1, partial1) {\n        let i0 = 0;\n        while(i0 < full0.length){\n            let found0 = full0.indexOf(partial0, i0);\n            if (found0 === -1) {\n                break;\n            }\n            let before0 = full0.substr(0, found0);\n            i0 = found0 + partial0.length;\n            let after0 = full0.substr(i0);\n            let i1 = 0;\n            while(i1 < full1.length){\n                let found1 = full1.indexOf(partial1, i1);\n                if (found1 === -1) {\n                    break;\n                }\n                let before1 = full1.substr(0, found1);\n                i1 = found1 + partial1.length;\n                let after1 = full1.substr(i1);\n                if (before0 === before1 && after0 === after1) {\n                    return {\n                        before: before0,\n                        after: after0\n                    };\n                }\n            }\n        }\n        return null;\n    }\n    function expandZonedMarker(dateInfo, calendarSystem) {\n        let a = calendarSystem.markerToArray(dateInfo.marker);\n        return {\n            marker: dateInfo.marker,\n            timeZoneOffset: dateInfo.timeZoneOffset,\n            array: a,\n            year: a[0],\n            month: a[1],\n            day: a[2],\n            hour: a[3],\n            minute: a[4],\n            second: a[5],\n            millisecond: a[6]\n        };\n    }\n    function createVerboseFormattingArg(start, end, context, betterDefaultSeparator) {\n        let startInfo = expandZonedMarker(start, context.calendarSystem);\n        let endInfo = end ? expandZonedMarker(end, context.calendarSystem) : null;\n        return {\n            date: startInfo,\n            start: startInfo,\n            end: endInfo,\n            timeZone: context.timeZone,\n            localeCodes: context.locale.codes,\n            defaultSeparator: betterDefaultSeparator || context.defaultSeparator\n        };\n    }\n    /*\r\n    TODO: fix the terminology of \"formatter\" vs \"formatting func\"\r\n    */ /*\r\n    At the time of instantiation, this object does not know which cmd-formatting system it will use.\r\n    It receives this at the time of formatting, as a setting.\r\n    */ class CmdFormatter {\n        constructor(cmdStr){\n            this.cmdStr = cmdStr;\n        }\n        format(date, context, betterDefaultSeparator) {\n            return context.cmdFormatter(this.cmdStr, createVerboseFormattingArg(date, null, context, betterDefaultSeparator));\n        }\n        formatRange(start, end, context, betterDefaultSeparator) {\n            return context.cmdFormatter(this.cmdStr, createVerboseFormattingArg(start, end, context, betterDefaultSeparator));\n        }\n    }\n    class FuncFormatter {\n        constructor(func){\n            this.func = func;\n        }\n        format(date, context, betterDefaultSeparator) {\n            return this.func(createVerboseFormattingArg(date, null, context, betterDefaultSeparator));\n        }\n        formatRange(start, end, context, betterDefaultSeparator) {\n            return this.func(createVerboseFormattingArg(start, end, context, betterDefaultSeparator));\n        }\n    }\n    function createFormatter(input) {\n        if (typeof input === 'object' && input) {\n            return new NativeFormatter(input);\n        }\n        if (typeof input === 'string') {\n            return new CmdFormatter(input);\n        }\n        if (typeof input === 'function') {\n            return new FuncFormatter(input);\n        }\n        return null;\n    }\n    // base options\n    // ------------\n    const BASE_OPTION_REFINERS = {\n        navLinkDayClick: identity,\n        navLinkWeekClick: identity,\n        duration: createDuration,\n        bootstrapFontAwesome: identity,\n        buttonIcons: identity,\n        customButtons: identity,\n        defaultAllDayEventDuration: createDuration,\n        defaultTimedEventDuration: createDuration,\n        nextDayThreshold: createDuration,\n        scrollTime: createDuration,\n        scrollTimeReset: Boolean,\n        slotMinTime: createDuration,\n        slotMaxTime: createDuration,\n        dayPopoverFormat: createFormatter,\n        slotDuration: createDuration,\n        snapDuration: createDuration,\n        headerToolbar: identity,\n        footerToolbar: identity,\n        defaultRangeSeparator: String,\n        titleRangeSeparator: String,\n        forceEventDuration: Boolean,\n        dayHeaders: Boolean,\n        dayHeaderFormat: createFormatter,\n        dayHeaderClassNames: identity,\n        dayHeaderContent: identity,\n        dayHeaderDidMount: identity,\n        dayHeaderWillUnmount: identity,\n        dayCellClassNames: identity,\n        dayCellContent: identity,\n        dayCellDidMount: identity,\n        dayCellWillUnmount: identity,\n        initialView: String,\n        aspectRatio: Number,\n        weekends: Boolean,\n        weekNumberCalculation: identity,\n        weekNumbers: Boolean,\n        weekNumberClassNames: identity,\n        weekNumberContent: identity,\n        weekNumberDidMount: identity,\n        weekNumberWillUnmount: identity,\n        editable: Boolean,\n        viewClassNames: identity,\n        viewDidMount: identity,\n        viewWillUnmount: identity,\n        nowIndicator: Boolean,\n        nowIndicatorClassNames: identity,\n        nowIndicatorContent: identity,\n        nowIndicatorDidMount: identity,\n        nowIndicatorWillUnmount: identity,\n        showNonCurrentDates: Boolean,\n        lazyFetching: Boolean,\n        startParam: String,\n        endParam: String,\n        timeZoneParam: String,\n        timeZone: String,\n        locales: identity,\n        locale: identity,\n        themeSystem: String,\n        dragRevertDuration: Number,\n        dragScroll: Boolean,\n        allDayMaintainDuration: Boolean,\n        unselectAuto: Boolean,\n        dropAccept: identity,\n        eventOrder: parseFieldSpecs,\n        eventOrderStrict: Boolean,\n        handleWindowResize: Boolean,\n        windowResizeDelay: Number,\n        longPressDelay: Number,\n        eventDragMinDistance: Number,\n        expandRows: Boolean,\n        height: identity,\n        contentHeight: identity,\n        direction: String,\n        weekNumberFormat: createFormatter,\n        eventResizableFromStart: Boolean,\n        displayEventTime: Boolean,\n        displayEventEnd: Boolean,\n        weekText: String,\n        weekTextLong: String,\n        progressiveEventRendering: Boolean,\n        businessHours: identity,\n        initialDate: identity,\n        now: identity,\n        eventDataTransform: identity,\n        stickyHeaderDates: identity,\n        stickyFooterScrollbar: identity,\n        viewHeight: identity,\n        defaultAllDay: Boolean,\n        eventSourceFailure: identity,\n        eventSourceSuccess: identity,\n        eventDisplay: String,\n        eventStartEditable: Boolean,\n        eventDurationEditable: Boolean,\n        eventOverlap: identity,\n        eventConstraint: identity,\n        eventAllow: identity,\n        eventBackgroundColor: String,\n        eventBorderColor: String,\n        eventTextColor: String,\n        eventColor: String,\n        eventClassNames: identity,\n        eventContent: identity,\n        eventDidMount: identity,\n        eventWillUnmount: identity,\n        selectConstraint: identity,\n        selectOverlap: identity,\n        selectAllow: identity,\n        droppable: Boolean,\n        unselectCancel: String,\n        slotLabelFormat: identity,\n        slotLaneClassNames: identity,\n        slotLaneContent: identity,\n        slotLaneDidMount: identity,\n        slotLaneWillUnmount: identity,\n        slotLabelClassNames: identity,\n        slotLabelContent: identity,\n        slotLabelDidMount: identity,\n        slotLabelWillUnmount: identity,\n        dayMaxEvents: identity,\n        dayMaxEventRows: identity,\n        dayMinWidth: Number,\n        slotLabelInterval: createDuration,\n        allDayText: String,\n        allDayClassNames: identity,\n        allDayContent: identity,\n        allDayDidMount: identity,\n        allDayWillUnmount: identity,\n        slotMinWidth: Number,\n        navLinks: Boolean,\n        eventTimeFormat: createFormatter,\n        rerenderDelay: Number,\n        moreLinkText: identity,\n        moreLinkHint: identity,\n        selectMinDistance: Number,\n        selectable: Boolean,\n        selectLongPressDelay: Number,\n        eventLongPressDelay: Number,\n        selectMirror: Boolean,\n        eventMaxStack: Number,\n        eventMinHeight: Number,\n        eventMinWidth: Number,\n        eventShortHeight: Number,\n        slotEventOverlap: Boolean,\n        plugins: identity,\n        firstDay: Number,\n        dayCount: Number,\n        dateAlignment: String,\n        dateIncrement: createDuration,\n        hiddenDays: identity,\n        fixedWeekCount: Boolean,\n        validRange: identity,\n        visibleRange: identity,\n        titleFormat: identity,\n        eventInteractive: Boolean,\n        // only used by list-view, but languages define the value, so we need it in base options\n        noEventsText: String,\n        viewHint: identity,\n        navLinkHint: identity,\n        closeHint: String,\n        timeHint: String,\n        eventHint: String,\n        moreLinkClick: identity,\n        moreLinkClassNames: identity,\n        moreLinkContent: identity,\n        moreLinkDidMount: identity,\n        moreLinkWillUnmount: identity,\n        monthStartFormat: createFormatter,\n        // for connectors\n        // (can't be part of plugin system b/c must be provided at runtime)\n        handleCustomRendering: identity,\n        customRenderingMetaMap: identity,\n        customRenderingReplacesEl: Boolean\n    };\n    // do NOT give a type here. need `typeof BASE_OPTION_DEFAULTS` to give real results.\n    // raw values.\n    const BASE_OPTION_DEFAULTS = {\n        eventDisplay: 'auto',\n        defaultRangeSeparator: ' - ',\n        titleRangeSeparator: ' \\u2013 ',\n        defaultTimedEventDuration: '01:00:00',\n        defaultAllDayEventDuration: {\n            day: 1\n        },\n        forceEventDuration: false,\n        nextDayThreshold: '00:00:00',\n        dayHeaders: true,\n        initialView: '',\n        aspectRatio: 1.35,\n        headerToolbar: {\n            start: 'title',\n            center: '',\n            end: 'today prev,next'\n        },\n        weekends: true,\n        weekNumbers: false,\n        weekNumberCalculation: 'local',\n        editable: false,\n        nowIndicator: false,\n        scrollTime: '06:00:00',\n        scrollTimeReset: true,\n        slotMinTime: '00:00:00',\n        slotMaxTime: '24:00:00',\n        showNonCurrentDates: true,\n        lazyFetching: true,\n        startParam: 'start',\n        endParam: 'end',\n        timeZoneParam: 'timeZone',\n        timeZone: 'local',\n        locales: [],\n        locale: '',\n        themeSystem: 'standard',\n        dragRevertDuration: 500,\n        dragScroll: true,\n        allDayMaintainDuration: false,\n        unselectAuto: true,\n        dropAccept: '*',\n        eventOrder: 'start,-duration,allDay,title',\n        dayPopoverFormat: {\n            month: 'long',\n            day: 'numeric',\n            year: 'numeric'\n        },\n        handleWindowResize: true,\n        windowResizeDelay: 100,\n        longPressDelay: 1000,\n        eventDragMinDistance: 5,\n        expandRows: false,\n        navLinks: false,\n        selectable: false,\n        eventMinHeight: 15,\n        eventMinWidth: 30,\n        eventShortHeight: 30,\n        monthStartFormat: {\n            month: 'long',\n            day: 'numeric'\n        }\n    };\n    // calendar listeners\n    // ------------------\n    const CALENDAR_LISTENER_REFINERS = {\n        datesSet: identity,\n        eventsSet: identity,\n        eventAdd: identity,\n        eventChange: identity,\n        eventRemove: identity,\n        windowResize: identity,\n        eventClick: identity,\n        eventMouseEnter: identity,\n        eventMouseLeave: identity,\n        select: identity,\n        unselect: identity,\n        loading: identity,\n        // internal\n        _unmount: identity,\n        _beforeprint: identity,\n        _afterprint: identity,\n        _noEventDrop: identity,\n        _noEventResize: identity,\n        _resize: identity,\n        _scrollRequest: identity\n    };\n    // calendar-specific options\n    // -------------------------\n    const CALENDAR_OPTION_REFINERS = {\n        buttonText: identity,\n        buttonHints: identity,\n        views: identity,\n        plugins: identity,\n        initialEvents: identity,\n        events: identity,\n        eventSources: identity\n    };\n    const COMPLEX_OPTION_COMPARATORS = {\n        headerToolbar: isMaybeObjectsEqual,\n        footerToolbar: isMaybeObjectsEqual,\n        buttonText: isMaybeObjectsEqual,\n        buttonHints: isMaybeObjectsEqual,\n        buttonIcons: isMaybeObjectsEqual,\n        dateIncrement: isMaybeObjectsEqual,\n        plugins: isMaybeArraysEqual,\n        events: isMaybeArraysEqual,\n        eventSources: isMaybeArraysEqual,\n        ['resources']: isMaybeArraysEqual\n    };\n    function isMaybeObjectsEqual(a, b) {\n        if (typeof a === 'object' && typeof b === 'object' && a && b) {\n            return isPropsEqual(a, b);\n        }\n        return a === b;\n    }\n    function isMaybeArraysEqual(a, b) {\n        if (Array.isArray(a) && Array.isArray(b)) {\n            return isArraysEqual(a, b);\n        }\n        return a === b;\n    }\n    // view-specific options\n    // ---------------------\n    const VIEW_OPTION_REFINERS = {\n        type: String,\n        component: identity,\n        buttonText: String,\n        buttonTextKey: String,\n        dateProfileGeneratorClass: identity,\n        usesMinMaxTime: Boolean,\n        classNames: identity,\n        content: identity,\n        didMount: identity,\n        willUnmount: identity\n    };\n    // util funcs\n    // ----------------------------------------------------------------------------------------------------\n    function mergeRawOptions(optionSets) {\n        return mergeProps(optionSets, COMPLEX_OPTION_COMPARATORS);\n    }\n    function refineProps(input, refiners) {\n        let refined = {};\n        let extra = {};\n        for(let propName in refiners){\n            if (propName in input) {\n                refined[propName] = refiners[propName](input[propName]);\n            }\n        }\n        for(let propName in input){\n            if (!(propName in refiners)) {\n                extra[propName] = input[propName];\n            }\n        }\n        return {\n            refined,\n            extra\n        };\n    }\n    function identity(raw) {\n        return raw;\n    }\n    function createEventInstance(defId, range, forcedStartTzo, forcedEndTzo) {\n        return {\n            instanceId: guid(),\n            defId,\n            range,\n            forcedStartTzo: forcedStartTzo == null ? null : forcedStartTzo,\n            forcedEndTzo: forcedEndTzo == null ? null : forcedEndTzo\n        };\n    }\n    function parseRecurring(refined, defaultAllDay, dateEnv, recurringTypes) {\n        for(let i = 0; i < recurringTypes.length; i += 1){\n            let parsed = recurringTypes[i].parse(refined, dateEnv);\n            if (parsed) {\n                let { allDay } = refined;\n                if (allDay == null) {\n                    allDay = defaultAllDay;\n                    if (allDay == null) {\n                        allDay = parsed.allDayGuess;\n                        if (allDay == null) {\n                            allDay = false;\n                        }\n                    }\n                }\n                return {\n                    allDay,\n                    duration: parsed.duration,\n                    typeData: parsed.typeData,\n                    typeId: i\n                };\n            }\n        }\n        return null;\n    }\n    function expandRecurring(eventStore, framingRange, context) {\n        let { dateEnv, pluginHooks, options } = context;\n        let { defs, instances } = eventStore;\n        // remove existing recurring instances\n        // TODO: bad. always expand events as a second step\n        instances = filterHash(instances, (instance)=>!defs[instance.defId].recurringDef);\n        for(let defId in defs){\n            let def = defs[defId];\n            if (def.recurringDef) {\n                let { duration } = def.recurringDef;\n                if (!duration) {\n                    duration = def.allDay ? options.defaultAllDayEventDuration : options.defaultTimedEventDuration;\n                }\n                let starts = expandRecurringRanges(def, duration, framingRange, dateEnv, pluginHooks.recurringTypes);\n                for (let start of starts){\n                    let instance = createEventInstance(defId, {\n                        start,\n                        end: dateEnv.add(start, duration)\n                    });\n                    instances[instance.instanceId] = instance;\n                }\n            }\n        }\n        return {\n            defs,\n            instances\n        };\n    }\n    /*\r\n    Event MUST have a recurringDef\r\n    */ function expandRecurringRanges(eventDef, duration, framingRange, dateEnv, recurringTypes) {\n        let typeDef = recurringTypes[eventDef.recurringDef.typeId];\n        let markers = typeDef.expand(eventDef.recurringDef.typeData, {\n            start: dateEnv.subtract(framingRange.start, duration),\n            end: framingRange.end\n        }, dateEnv);\n        // the recurrence plugins don't guarantee that all-day events are start-of-day, so we have to\n        if (eventDef.allDay) {\n            markers = markers.map(startOfDay);\n        }\n        return markers;\n    }\n    function parseEvents(rawEvents, eventSource, context, allowOpenRange, defIdMap, instanceIdMap) {\n        let eventStore = createEmptyEventStore();\n        let eventRefiners = buildEventRefiners(context);\n        for (let rawEvent of rawEvents){\n            let tuple = parseEvent(rawEvent, eventSource, context, allowOpenRange, eventRefiners, defIdMap, instanceIdMap);\n            if (tuple) {\n                eventTupleToStore(tuple, eventStore);\n            }\n        }\n        return eventStore;\n    }\n    function eventTupleToStore(tuple, eventStore = createEmptyEventStore()) {\n        eventStore.defs[tuple.def.defId] = tuple.def;\n        if (tuple.instance) {\n            eventStore.instances[tuple.instance.instanceId] = tuple.instance;\n        }\n        return eventStore;\n    }\n    // retrieves events that have the same groupId as the instance specified by `instanceId`\n    // or they are the same as the instance.\n    // why might instanceId not be in the store? an event from another calendar?\n    function getRelevantEvents(eventStore, instanceId) {\n        let instance = eventStore.instances[instanceId];\n        if (instance) {\n            let def = eventStore.defs[instance.defId];\n            // get events/instances with same group\n            let newStore = filterEventStoreDefs(eventStore, (lookDef)=>isEventDefsGrouped(def, lookDef));\n            // add the original\n            // TODO: wish we could use eventTupleToStore or something like it\n            newStore.defs[def.defId] = def;\n            newStore.instances[instance.instanceId] = instance;\n            return newStore;\n        }\n        return createEmptyEventStore();\n    }\n    function isEventDefsGrouped(def0, def1) {\n        return Boolean(def0.groupId && def0.groupId === def1.groupId);\n    }\n    function createEmptyEventStore() {\n        return {\n            defs: {},\n            instances: {}\n        };\n    }\n    function mergeEventStores(store0, store1) {\n        return {\n            defs: Object.assign(Object.assign({}, store0.defs), store1.defs),\n            instances: Object.assign(Object.assign({}, store0.instances), store1.instances)\n        };\n    }\n    function filterEventStoreDefs(eventStore, filterFunc) {\n        let defs = filterHash(eventStore.defs, filterFunc);\n        let instances = filterHash(eventStore.instances, (instance)=>defs[instance.defId] // still exists?\n        );\n        return {\n            defs,\n            instances\n        };\n    }\n    function excludeSubEventStore(master, sub) {\n        let { defs, instances } = master;\n        let filteredDefs = {};\n        let filteredInstances = {};\n        for(let defId in defs){\n            if (!sub.defs[defId]) {\n                filteredDefs[defId] = defs[defId];\n            }\n        }\n        for(let instanceId in instances){\n            if (!sub.instances[instanceId] && // not explicitly excluded\n            filteredDefs[instances[instanceId].defId] // def wasn't filtered away\n            ) {\n                filteredInstances[instanceId] = instances[instanceId];\n            }\n        }\n        return {\n            defs: filteredDefs,\n            instances: filteredInstances\n        };\n    }\n    function normalizeConstraint(input, context) {\n        if (Array.isArray(input)) {\n            return parseEvents(input, null, context, true); // allowOpenRange=true\n        }\n        if (typeof input === 'object' && input) {\n            return parseEvents([\n                input\n            ], null, context, true); // allowOpenRange=true\n        }\n        if (input != null) {\n            return String(input);\n        }\n        return null;\n    }\n    function parseClassNames(raw) {\n        if (Array.isArray(raw)) {\n            return raw;\n        }\n        if (typeof raw === 'string') {\n            return raw.split(/\\s+/);\n        }\n        return [];\n    }\n    // TODO: better called \"EventSettings\" or \"EventConfig\"\n    // TODO: move this file into structs\n    // TODO: separate constraint/overlap/allow, because selection uses only that, not other props\n    const EVENT_UI_REFINERS = {\n        display: String,\n        editable: Boolean,\n        startEditable: Boolean,\n        durationEditable: Boolean,\n        constraint: identity,\n        overlap: identity,\n        allow: identity,\n        className: parseClassNames,\n        classNames: parseClassNames,\n        color: String,\n        backgroundColor: String,\n        borderColor: String,\n        textColor: String\n    };\n    const EMPTY_EVENT_UI = {\n        display: null,\n        startEditable: null,\n        durationEditable: null,\n        constraints: [],\n        overlap: null,\n        allows: [],\n        backgroundColor: '',\n        borderColor: '',\n        textColor: '',\n        classNames: []\n    };\n    function createEventUi(refined, context) {\n        let constraint = normalizeConstraint(refined.constraint, context);\n        return {\n            display: refined.display || null,\n            startEditable: refined.startEditable != null ? refined.startEditable : refined.editable,\n            durationEditable: refined.durationEditable != null ? refined.durationEditable : refined.editable,\n            constraints: constraint != null ? [\n                constraint\n            ] : [],\n            overlap: refined.overlap != null ? refined.overlap : null,\n            allows: refined.allow != null ? [\n                refined.allow\n            ] : [],\n            backgroundColor: refined.backgroundColor || refined.color || '',\n            borderColor: refined.borderColor || refined.color || '',\n            textColor: refined.textColor || '',\n            classNames: (refined.className || []).concat(refined.classNames || [])\n        };\n    }\n    // TODO: prevent against problems with <2 args!\n    function combineEventUis(uis) {\n        return uis.reduce(combineTwoEventUis, EMPTY_EVENT_UI);\n    }\n    function combineTwoEventUis(item0, item1) {\n        return {\n            display: item1.display != null ? item1.display : item0.display,\n            startEditable: item1.startEditable != null ? item1.startEditable : item0.startEditable,\n            durationEditable: item1.durationEditable != null ? item1.durationEditable : item0.durationEditable,\n            constraints: item0.constraints.concat(item1.constraints),\n            overlap: typeof item1.overlap === 'boolean' ? item1.overlap : item0.overlap,\n            allows: item0.allows.concat(item1.allows),\n            backgroundColor: item1.backgroundColor || item0.backgroundColor,\n            borderColor: item1.borderColor || item0.borderColor,\n            textColor: item1.textColor || item0.textColor,\n            classNames: item0.classNames.concat(item1.classNames)\n        };\n    }\n    const EVENT_NON_DATE_REFINERS = {\n        id: String,\n        groupId: String,\n        title: String,\n        url: String,\n        interactive: Boolean\n    };\n    const EVENT_DATE_REFINERS = {\n        start: identity,\n        end: identity,\n        date: identity,\n        allDay: Boolean\n    };\n    const EVENT_REFINERS = Object.assign(Object.assign(Object.assign({}, EVENT_NON_DATE_REFINERS), EVENT_DATE_REFINERS), {\n        extendedProps: identity\n    });\n    function parseEvent(raw, eventSource, context, allowOpenRange, refiners = buildEventRefiners(context), defIdMap, instanceIdMap) {\n        let { refined, extra } = refineEventDef(raw, context, refiners);\n        let defaultAllDay = computeIsDefaultAllDay(eventSource, context);\n        let recurringRes = parseRecurring(refined, defaultAllDay, context.dateEnv, context.pluginHooks.recurringTypes);\n        if (recurringRes) {\n            let def = parseEventDef(refined, extra, eventSource ? eventSource.sourceId : '', recurringRes.allDay, Boolean(recurringRes.duration), context, defIdMap);\n            def.recurringDef = {\n                typeId: recurringRes.typeId,\n                typeData: recurringRes.typeData,\n                duration: recurringRes.duration\n            };\n            return {\n                def,\n                instance: null\n            };\n        }\n        let singleRes = parseSingle(refined, defaultAllDay, context, allowOpenRange);\n        if (singleRes) {\n            let def = parseEventDef(refined, extra, eventSource ? eventSource.sourceId : '', singleRes.allDay, singleRes.hasEnd, context, defIdMap);\n            let instance = createEventInstance(def.defId, singleRes.range, singleRes.forcedStartTzo, singleRes.forcedEndTzo);\n            if (instanceIdMap && def.publicId && instanceIdMap[def.publicId]) {\n                instance.instanceId = instanceIdMap[def.publicId];\n            }\n            return {\n                def,\n                instance\n            };\n        }\n        return null;\n    }\n    function refineEventDef(raw, context, refiners = buildEventRefiners(context)) {\n        return refineProps(raw, refiners);\n    }\n    function buildEventRefiners(context) {\n        return Object.assign(Object.assign(Object.assign({}, EVENT_UI_REFINERS), EVENT_REFINERS), context.pluginHooks.eventRefiners);\n    }\n    /*\r\n    Will NOT populate extendedProps with the leftover properties.\r\n    Will NOT populate date-related props.\r\n    */ function parseEventDef(refined, extra, sourceId, allDay, hasEnd, context, defIdMap) {\n        let def = {\n            title: refined.title || '',\n            groupId: refined.groupId || '',\n            publicId: refined.id || '',\n            url: refined.url || '',\n            recurringDef: null,\n            defId: (defIdMap && refined.id ? defIdMap[refined.id] : '') || guid(),\n            sourceId,\n            allDay,\n            hasEnd,\n            interactive: refined.interactive,\n            ui: createEventUi(refined, context),\n            extendedProps: Object.assign(Object.assign({}, refined.extendedProps || {}), extra)\n        };\n        for (let memberAdder of context.pluginHooks.eventDefMemberAdders){\n            Object.assign(def, memberAdder(refined));\n        }\n        // help out EventImpl from having user modify props\n        Object.freeze(def.ui.classNames);\n        Object.freeze(def.extendedProps);\n        return def;\n    }\n    function parseSingle(refined, defaultAllDay, context, allowOpenRange) {\n        let { allDay } = refined;\n        let startMeta;\n        let startMarker = null;\n        let hasEnd = false;\n        let endMeta;\n        let endMarker = null;\n        let startInput = refined.start != null ? refined.start : refined.date;\n        startMeta = context.dateEnv.createMarkerMeta(startInput);\n        if (startMeta) {\n            startMarker = startMeta.marker;\n        } else if (!allowOpenRange) {\n            return null;\n        }\n        if (refined.end != null) {\n            endMeta = context.dateEnv.createMarkerMeta(refined.end);\n        }\n        if (allDay == null) {\n            if (defaultAllDay != null) {\n                allDay = defaultAllDay;\n            } else {\n                // fall back to the date props LAST\n                allDay = (!startMeta || startMeta.isTimeUnspecified) && (!endMeta || endMeta.isTimeUnspecified);\n            }\n        }\n        if (allDay && startMarker) {\n            startMarker = startOfDay(startMarker);\n        }\n        if (endMeta) {\n            endMarker = endMeta.marker;\n            if (allDay) {\n                endMarker = startOfDay(endMarker);\n            }\n            if (startMarker && endMarker <= startMarker) {\n                endMarker = null;\n            }\n        }\n        if (endMarker) {\n            hasEnd = true;\n        } else if (!allowOpenRange) {\n            hasEnd = context.options.forceEventDuration || false;\n            endMarker = context.dateEnv.add(startMarker, allDay ? context.options.defaultAllDayEventDuration : context.options.defaultTimedEventDuration);\n        }\n        return {\n            allDay,\n            hasEnd,\n            range: {\n                start: startMarker,\n                end: endMarker\n            },\n            forcedStartTzo: startMeta ? startMeta.forcedTzo : null,\n            forcedEndTzo: endMeta ? endMeta.forcedTzo : null\n        };\n    }\n    function computeIsDefaultAllDay(eventSource, context) {\n        let res = null;\n        if (eventSource) {\n            res = eventSource.defaultAllDay;\n        }\n        if (res == null) {\n            res = context.options.defaultAllDay;\n        }\n        return res;\n    }\n    const DEF_DEFAULTS = {\n        startTime: '09:00',\n        endTime: '17:00',\n        daysOfWeek: [\n            1,\n            2,\n            3,\n            4,\n            5\n        ],\n        display: 'inverse-background',\n        classNames: 'fc-non-business',\n        groupId: '_businessHours'\n    };\n    /*\r\n    TODO: pass around as EventDefHash!!!\r\n    */ function parseBusinessHours(input, context) {\n        return parseEvents(refineInputs(input), null, context);\n    }\n    function refineInputs(input) {\n        let rawDefs;\n        if (input === true) {\n            rawDefs = [\n                {}\n            ]; // will get DEF_DEFAULTS verbatim\n        } else if (Array.isArray(input)) {\n            // if specifying an array, every sub-definition NEEDS a day-of-week\n            rawDefs = input.filter((rawDef)=>rawDef.daysOfWeek);\n        } else if (typeof input === 'object' && input) {\n            rawDefs = [\n                input\n            ];\n        } else {\n            rawDefs = [];\n        }\n        rawDefs = rawDefs.map((rawDef)=>Object.assign(Object.assign({}, DEF_DEFAULTS), rawDef));\n        return rawDefs;\n    }\n    /* Date stuff that doesn't belong in datelib core\r\n    ----------------------------------------------------------------------------------------------------------------------*/ // given a timed range, computes an all-day range that has the same exact duration,\n    // but whose start time is aligned with the start of the day.\n    function computeAlignedDayRange(timedRange) {\n        let dayCnt = Math.floor(diffDays(timedRange.start, timedRange.end)) || 1;\n        let start = startOfDay(timedRange.start);\n        let end = addDays(start, dayCnt);\n        return {\n            start,\n            end\n        };\n    }\n    // given a timed range, computes an all-day range based on how for the end date bleeds into the next day\n    // TODO: give nextDayThreshold a default arg\n    function computeVisibleDayRange(timedRange, nextDayThreshold = createDuration(0)) {\n        let startDay = null;\n        let endDay = null;\n        if (timedRange.end) {\n            endDay = startOfDay(timedRange.end);\n            let endTimeMS = timedRange.end.valueOf() - endDay.valueOf(); // # of milliseconds into `endDay`\n            // If the end time is actually inclusively part of the next day and is equal to or\n            // beyond the next day threshold, adjust the end to be the exclusive end of `endDay`.\n            // Otherwise, leaving it as inclusive will cause it to exclude `endDay`.\n            if (endTimeMS && endTimeMS >= asRoughMs(nextDayThreshold)) {\n                endDay = addDays(endDay, 1);\n            }\n        }\n        if (timedRange.start) {\n            startDay = startOfDay(timedRange.start); // the beginning of the day the range starts\n            // If end is within `startDay` but not past nextDayThreshold, assign the default duration of one day.\n            if (endDay && endDay <= startDay) {\n                endDay = addDays(startDay, 1);\n            }\n        }\n        return {\n            start: startDay,\n            end: endDay\n        };\n    }\n    // spans from one day into another?\n    function isMultiDayRange(range) {\n        let visibleRange = computeVisibleDayRange(range);\n        return diffDays(visibleRange.start, visibleRange.end) > 1;\n    }\n    function diffDates(date0, date1, dateEnv, largeUnit) {\n        if (largeUnit === 'year') {\n            return createDuration(dateEnv.diffWholeYears(date0, date1), 'year');\n        }\n        if (largeUnit === 'month') {\n            return createDuration(dateEnv.diffWholeMonths(date0, date1), 'month');\n        }\n        return diffDayAndTime(date0, date1); // returns a duration\n    }\n    function pointInsideRect(point, rect) {\n        return point.left >= rect.left && point.left < rect.right && point.top >= rect.top && point.top < rect.bottom;\n    }\n    // Returns a new rectangle that is the intersection of the two rectangles. If they don't intersect, returns false\n    function intersectRects(rect1, rect2) {\n        let res = {\n            left: Math.max(rect1.left, rect2.left),\n            right: Math.min(rect1.right, rect2.right),\n            top: Math.max(rect1.top, rect2.top),\n            bottom: Math.min(rect1.bottom, rect2.bottom)\n        };\n        if (res.left < res.right && res.top < res.bottom) {\n            return res;\n        }\n        return false;\n    }\n    function translateRect(rect, deltaX, deltaY) {\n        return {\n            left: rect.left + deltaX,\n            right: rect.right + deltaX,\n            top: rect.top + deltaY,\n            bottom: rect.bottom + deltaY\n        };\n    }\n    // Returns a new point that will have been moved to reside within the given rectangle\n    function constrainPoint(point, rect) {\n        return {\n            left: Math.min(Math.max(point.left, rect.left), rect.right),\n            top: Math.min(Math.max(point.top, rect.top), rect.bottom)\n        };\n    }\n    // Returns a point that is the center of the given rectangle\n    function getRectCenter(rect) {\n        return {\n            left: (rect.left + rect.right) / 2,\n            top: (rect.top + rect.bottom) / 2\n        };\n    }\n    // Subtracts point2's coordinates from point1's coordinates, returning a delta\n    function diffPoints(point1, point2) {\n        return {\n            left: point1.left - point2.left,\n            top: point1.top - point2.top\n        };\n    }\n    let canVGrowWithinCell;\n    function getCanVGrowWithinCell() {\n        if (canVGrowWithinCell == null) {\n            canVGrowWithinCell = computeCanVGrowWithinCell();\n        }\n        return canVGrowWithinCell;\n    }\n    function computeCanVGrowWithinCell() {\n        // for SSR, because this function is call immediately at top-level\n        // TODO: just make this logic execute top-level, immediately, instead of doing lazily\n        if (typeof document === 'undefined') {\n            return true;\n        }\n        let el = document.createElement('div');\n        el.style.position = 'absolute';\n        el.style.top = '0px';\n        el.style.left = '0px';\n        el.innerHTML = '<table><tr><td><div></div></td></tr></table>';\n        el.querySelector('table').style.height = '100px';\n        el.querySelector('div').style.height = '100%';\n        document.body.appendChild(el);\n        let div = el.querySelector('div');\n        let possible = div.offsetHeight > 0;\n        document.body.removeChild(el);\n        return possible;\n    }\n    const EMPTY_EVENT_STORE = createEmptyEventStore(); // for purecomponents. TODO: keep elsewhere\n    class Splitter {\n        constructor(){\n            this.getKeysForEventDefs = memoize(this._getKeysForEventDefs);\n            this.splitDateSelection = memoize(this._splitDateSpan);\n            this.splitEventStore = memoize(this._splitEventStore);\n            this.splitIndividualUi = memoize(this._splitIndividualUi);\n            this.splitEventDrag = memoize(this._splitInteraction);\n            this.splitEventResize = memoize(this._splitInteraction);\n            this.eventUiBuilders = {}; // TODO: typescript protection\n        }\n        splitProps(props) {\n            let keyInfos = this.getKeyInfo(props);\n            let defKeys = this.getKeysForEventDefs(props.eventStore);\n            let dateSelections = this.splitDateSelection(props.dateSelection);\n            let individualUi = this.splitIndividualUi(props.eventUiBases, defKeys); // the individual *bases*\n            let eventStores = this.splitEventStore(props.eventStore, defKeys);\n            let eventDrags = this.splitEventDrag(props.eventDrag);\n            let eventResizes = this.splitEventResize(props.eventResize);\n            let splitProps = {};\n            this.eventUiBuilders = mapHash(keyInfos, (info, key)=>this.eventUiBuilders[key] || memoize(buildEventUiForKey));\n            for(let key in keyInfos){\n                let keyInfo = keyInfos[key];\n                let eventStore = eventStores[key] || EMPTY_EVENT_STORE;\n                let buildEventUi = this.eventUiBuilders[key];\n                splitProps[key] = {\n                    businessHours: keyInfo.businessHours || props.businessHours,\n                    dateSelection: dateSelections[key] || null,\n                    eventStore,\n                    eventUiBases: buildEventUi(props.eventUiBases[''], keyInfo.ui, individualUi[key]),\n                    eventSelection: eventStore.instances[props.eventSelection] ? props.eventSelection : '',\n                    eventDrag: eventDrags[key] || null,\n                    eventResize: eventResizes[key] || null\n                };\n            }\n            return splitProps;\n        }\n        _splitDateSpan(dateSpan) {\n            let dateSpans = {};\n            if (dateSpan) {\n                let keys = this.getKeysForDateSpan(dateSpan);\n                for (let key of keys){\n                    dateSpans[key] = dateSpan;\n                }\n            }\n            return dateSpans;\n        }\n        _getKeysForEventDefs(eventStore) {\n            return mapHash(eventStore.defs, (eventDef)=>this.getKeysForEventDef(eventDef));\n        }\n        _splitEventStore(eventStore, defKeys) {\n            let { defs, instances } = eventStore;\n            let splitStores = {};\n            for(let defId in defs){\n                for (let key of defKeys[defId]){\n                    if (!splitStores[key]) {\n                        splitStores[key] = createEmptyEventStore();\n                    }\n                    splitStores[key].defs[defId] = defs[defId];\n                }\n            }\n            for(let instanceId in instances){\n                let instance = instances[instanceId];\n                for (let key of defKeys[instance.defId]){\n                    if (splitStores[key]) {\n                        splitStores[key].instances[instanceId] = instance;\n                    }\n                }\n            }\n            return splitStores;\n        }\n        _splitIndividualUi(eventUiBases, defKeys) {\n            let splitHashes = {};\n            for(let defId in eventUiBases){\n                if (defId) {\n                    for (let key of defKeys[defId]){\n                        if (!splitHashes[key]) {\n                            splitHashes[key] = {};\n                        }\n                        splitHashes[key][defId] = eventUiBases[defId];\n                    }\n                }\n            }\n            return splitHashes;\n        }\n        _splitInteraction(interaction) {\n            let splitStates = {};\n            if (interaction) {\n                let affectedStores = this._splitEventStore(interaction.affectedEvents, this._getKeysForEventDefs(interaction.affectedEvents));\n                // can't rely on defKeys because event data is mutated\n                let mutatedKeysByDefId = this._getKeysForEventDefs(interaction.mutatedEvents);\n                let mutatedStores = this._splitEventStore(interaction.mutatedEvents, mutatedKeysByDefId);\n                let populate = (key)=>{\n                    if (!splitStates[key]) {\n                        splitStates[key] = {\n                            affectedEvents: affectedStores[key] || EMPTY_EVENT_STORE,\n                            mutatedEvents: mutatedStores[key] || EMPTY_EVENT_STORE,\n                            isEvent: interaction.isEvent\n                        };\n                    }\n                };\n                for(let key in affectedStores){\n                    populate(key);\n                }\n                for(let key in mutatedStores){\n                    populate(key);\n                }\n            }\n            return splitStates;\n        }\n    }\n    function buildEventUiForKey(allUi, eventUiForKey, individualUi) {\n        let baseParts = [];\n        if (allUi) {\n            baseParts.push(allUi);\n        }\n        if (eventUiForKey) {\n            baseParts.push(eventUiForKey);\n        }\n        let stuff = {\n            '': combineEventUis(baseParts)\n        };\n        if (individualUi) {\n            Object.assign(stuff, individualUi);\n        }\n        return stuff;\n    }\n    function parseRange(input, dateEnv) {\n        let start = null;\n        let end = null;\n        if (input.start) {\n            start = dateEnv.createMarker(input.start);\n        }\n        if (input.end) {\n            end = dateEnv.createMarker(input.end);\n        }\n        if (!start && !end) {\n            return null;\n        }\n        if (start && end && end < start) {\n            return null;\n        }\n        return {\n            start,\n            end\n        };\n    }\n    // SIDE-EFFECT: will mutate ranges.\n    // Will return a new array result.\n    function invertRanges(ranges, constraintRange) {\n        let invertedRanges = [];\n        let { start } = constraintRange; // the end of the previous range. the start of the new range\n        let i;\n        let dateRange;\n        // ranges need to be in order. required for our date-walking algorithm\n        ranges.sort(compareRanges);\n        for(i = 0; i < ranges.length; i += 1){\n            dateRange = ranges[i];\n            // add the span of time before the event (if there is any)\n            if (dateRange.start > start) {\n                invertedRanges.push({\n                    start,\n                    end: dateRange.start\n                });\n            }\n            if (dateRange.end > start) {\n                start = dateRange.end;\n            }\n        }\n        // add the span of time after the last event (if there is any)\n        if (start < constraintRange.end) {\n            invertedRanges.push({\n                start,\n                end: constraintRange.end\n            });\n        }\n        return invertedRanges;\n    }\n    function compareRanges(range0, range1) {\n        return range0.start.valueOf() - range1.start.valueOf(); // earlier ranges go first\n    }\n    function intersectRanges(range0, range1) {\n        let { start, end } = range0;\n        let newRange = null;\n        if (range1.start !== null) {\n            if (start === null) {\n                start = range1.start;\n            } else {\n                start = new Date(Math.max(start.valueOf(), range1.start.valueOf()));\n            }\n        }\n        if (range1.end != null) {\n            if (end === null) {\n                end = range1.end;\n            } else {\n                end = new Date(Math.min(end.valueOf(), range1.end.valueOf()));\n            }\n        }\n        if (start === null || end === null || start < end) {\n            newRange = {\n                start,\n                end\n            };\n        }\n        return newRange;\n    }\n    function rangesEqual(range0, range1) {\n        return (range0.start === null ? null : range0.start.valueOf()) === (range1.start === null ? null : range1.start.valueOf()) && (range0.end === null ? null : range0.end.valueOf()) === (range1.end === null ? null : range1.end.valueOf());\n    }\n    function rangesIntersect(range0, range1) {\n        return (range0.end === null || range1.start === null || range0.end > range1.start) && (range0.start === null || range1.end === null || range0.start < range1.end);\n    }\n    function rangeContainsRange(outerRange, innerRange) {\n        return (outerRange.start === null || innerRange.start !== null && innerRange.start >= outerRange.start) && (outerRange.end === null || innerRange.end !== null && innerRange.end <= outerRange.end);\n    }\n    function rangeContainsMarker(range, date) {\n        return (range.start === null || date >= range.start) && (range.end === null || date < range.end);\n    }\n    // If the given date is not within the given range, move it inside.\n    // (If it's past the end, make it one millisecond before the end).\n    function constrainMarkerToRange(date, range) {\n        if (range.start != null && date < range.start) {\n            return range.start;\n        }\n        if (range.end != null && date >= range.end) {\n            return new Date(range.end.valueOf() - 1);\n        }\n        return date;\n    }\n    function getDateMeta(date, todayRange, nowDate, dateProfile) {\n        return {\n            dow: date.getUTCDay(),\n            isDisabled: Boolean(dateProfile && !rangeContainsMarker(dateProfile.activeRange, date)),\n            isOther: Boolean(dateProfile && !rangeContainsMarker(dateProfile.currentRange, date)),\n            isToday: Boolean(todayRange && rangeContainsMarker(todayRange, date)),\n            isPast: Boolean(nowDate ? date < nowDate : todayRange ? date < todayRange.start : false),\n            isFuture: Boolean(nowDate ? date > nowDate : todayRange ? date >= todayRange.end : false)\n        };\n    }\n    function getDayClassNames(meta, theme) {\n        let classNames = [\n            'fc-day',\n            `fc-day-${DAY_IDS[meta.dow]}`\n        ];\n        if (meta.isDisabled) {\n            classNames.push('fc-day-disabled');\n        } else {\n            if (meta.isToday) {\n                classNames.push('fc-day-today');\n                classNames.push(theme.getClass('today'));\n            }\n            if (meta.isPast) {\n                classNames.push('fc-day-past');\n            }\n            if (meta.isFuture) {\n                classNames.push('fc-day-future');\n            }\n            if (meta.isOther) {\n                classNames.push('fc-day-other');\n            }\n        }\n        return classNames;\n    }\n    function getSlotClassNames(meta, theme) {\n        let classNames = [\n            'fc-slot',\n            `fc-slot-${DAY_IDS[meta.dow]}`\n        ];\n        if (meta.isDisabled) {\n            classNames.push('fc-slot-disabled');\n        } else {\n            if (meta.isToday) {\n                classNames.push('fc-slot-today');\n                classNames.push(theme.getClass('today'));\n            }\n            if (meta.isPast) {\n                classNames.push('fc-slot-past');\n            }\n            if (meta.isFuture) {\n                classNames.push('fc-slot-future');\n            }\n        }\n        return classNames;\n    }\n    const DAY_FORMAT = createFormatter({\n        year: 'numeric',\n        month: 'long',\n        day: 'numeric'\n    });\n    const WEEK_FORMAT = createFormatter({\n        week: 'long'\n    });\n    function buildNavLinkAttrs(context, dateMarker, viewType = 'day', isTabbable = true) {\n        const { dateEnv, options, calendarApi } = context;\n        let dateStr = dateEnv.format(dateMarker, viewType === 'week' ? WEEK_FORMAT : DAY_FORMAT);\n        if (options.navLinks) {\n            let zonedDate = dateEnv.toDate(dateMarker);\n            const handleInteraction = (ev)=>{\n                let customAction = viewType === 'day' ? options.navLinkDayClick : viewType === 'week' ? options.navLinkWeekClick : null;\n                if (typeof customAction === 'function') {\n                    customAction.call(calendarApi, dateEnv.toDate(dateMarker), ev);\n                } else {\n                    if (typeof customAction === 'string') {\n                        viewType = customAction;\n                    }\n                    calendarApi.zoomTo(dateMarker, viewType);\n                }\n            };\n            return Object.assign({\n                title: formatWithOrdinals(options.navLinkHint, [\n                    dateStr,\n                    zonedDate\n                ], dateStr),\n                'data-navlink': ''\n            }, isTabbable ? createAriaClickAttrs(handleInteraction) : {\n                onClick: handleInteraction\n            });\n        }\n        return {\n            'aria-label': dateStr\n        };\n    }\n    let _isRtlScrollbarOnLeft = null;\n    function getIsRtlScrollbarOnLeft() {\n        if (_isRtlScrollbarOnLeft === null) {\n            _isRtlScrollbarOnLeft = computeIsRtlScrollbarOnLeft();\n        }\n        return _isRtlScrollbarOnLeft;\n    }\n    function computeIsRtlScrollbarOnLeft() {\n        let outerEl = document.createElement('div');\n        applyStyle(outerEl, {\n            position: 'absolute',\n            top: -1000,\n            left: 0,\n            border: 0,\n            padding: 0,\n            overflow: 'scroll',\n            direction: 'rtl'\n        });\n        outerEl.innerHTML = '<div></div>';\n        document.body.appendChild(outerEl);\n        let innerEl = outerEl.firstChild;\n        let res = innerEl.getBoundingClientRect().left > outerEl.getBoundingClientRect().left;\n        removeElement(outerEl);\n        return res;\n    }\n    let _scrollbarWidths;\n    function getScrollbarWidths() {\n        if (!_scrollbarWidths) {\n            _scrollbarWidths = computeScrollbarWidths();\n        }\n        return _scrollbarWidths;\n    }\n    function computeScrollbarWidths() {\n        let el = document.createElement('div');\n        el.style.overflow = 'scroll';\n        el.style.position = 'absolute';\n        el.style.top = '-9999px';\n        el.style.left = '-9999px';\n        document.body.appendChild(el);\n        let res = computeScrollbarWidthsForEl(el);\n        document.body.removeChild(el);\n        return res;\n    }\n    // WARNING: will include border\n    function computeScrollbarWidthsForEl(el) {\n        return {\n            x: el.offsetHeight - el.clientHeight,\n            y: el.offsetWidth - el.clientWidth\n        };\n    }\n    function computeEdges(el, getPadding = false) {\n        let computedStyle = window.getComputedStyle(el);\n        let borderLeft = parseInt(computedStyle.borderLeftWidth, 10) || 0;\n        let borderRight = parseInt(computedStyle.borderRightWidth, 10) || 0;\n        let borderTop = parseInt(computedStyle.borderTopWidth, 10) || 0;\n        let borderBottom = parseInt(computedStyle.borderBottomWidth, 10) || 0;\n        let badScrollbarWidths = computeScrollbarWidthsForEl(el); // includes border!\n        let scrollbarLeftRight = badScrollbarWidths.y - borderLeft - borderRight;\n        let scrollbarBottom = badScrollbarWidths.x - borderTop - borderBottom;\n        let res = {\n            borderLeft,\n            borderRight,\n            borderTop,\n            borderBottom,\n            scrollbarBottom,\n            scrollbarLeft: 0,\n            scrollbarRight: 0\n        };\n        if (getIsRtlScrollbarOnLeft() && computedStyle.direction === 'rtl') {\n            res.scrollbarLeft = scrollbarLeftRight;\n        } else {\n            res.scrollbarRight = scrollbarLeftRight;\n        }\n        if (getPadding) {\n            res.paddingLeft = parseInt(computedStyle.paddingLeft, 10) || 0;\n            res.paddingRight = parseInt(computedStyle.paddingRight, 10) || 0;\n            res.paddingTop = parseInt(computedStyle.paddingTop, 10) || 0;\n            res.paddingBottom = parseInt(computedStyle.paddingBottom, 10) || 0;\n        }\n        return res;\n    }\n    function computeInnerRect(el, goWithinPadding = false, doFromWindowViewport) {\n        let outerRect = doFromWindowViewport ? el.getBoundingClientRect() : computeRect(el);\n        let edges = computeEdges(el, goWithinPadding);\n        let res = {\n            left: outerRect.left + edges.borderLeft + edges.scrollbarLeft,\n            right: outerRect.right - edges.borderRight - edges.scrollbarRight,\n            top: outerRect.top + edges.borderTop,\n            bottom: outerRect.bottom - edges.borderBottom - edges.scrollbarBottom\n        };\n        if (goWithinPadding) {\n            res.left += edges.paddingLeft;\n            res.right -= edges.paddingRight;\n            res.top += edges.paddingTop;\n            res.bottom -= edges.paddingBottom;\n        }\n        return res;\n    }\n    function computeRect(el) {\n        let rect = el.getBoundingClientRect();\n        return {\n            left: rect.left + window.pageXOffset,\n            top: rect.top + window.pageYOffset,\n            right: rect.right + window.pageXOffset,\n            bottom: rect.bottom + window.pageYOffset\n        };\n    }\n    function computeClippedClientRect(el) {\n        let clippingParents = getClippingParents(el);\n        let rect = el.getBoundingClientRect();\n        for (let clippingParent of clippingParents){\n            let intersection = intersectRects(rect, clippingParent.getBoundingClientRect());\n            if (intersection) {\n                rect = intersection;\n            } else {\n                return null;\n            }\n        }\n        return rect;\n    }\n    // does not return window\n    function getClippingParents(el) {\n        let parents = [];\n        while(el instanceof HTMLElement){\n            let computedStyle = window.getComputedStyle(el);\n            if (computedStyle.position === 'fixed') {\n                break;\n            }\n            if (/(auto|scroll)/.test(computedStyle.overflow + computedStyle.overflowY + computedStyle.overflowX)) {\n                parents.push(el);\n            }\n            el = el.parentNode;\n        }\n        return parents;\n    }\n    /*\r\n    given a function that resolves a result asynchronously.\r\n    the function can either call passed-in success and failure callbacks,\r\n    or it can return a promise.\r\n    if you need to pass additional params to func, bind them first.\r\n    */ function unpromisify(func, normalizedSuccessCallback, normalizedFailureCallback) {\n        // guard against success/failure callbacks being called more than once\n        // and guard against a promise AND callback being used together.\n        let isResolved = false;\n        let wrappedSuccess = function(res) {\n            if (!isResolved) {\n                isResolved = true;\n                normalizedSuccessCallback(res);\n            }\n        };\n        let wrappedFailure = function(error) {\n            if (!isResolved) {\n                isResolved = true;\n                normalizedFailureCallback(error);\n            }\n        };\n        let res = func(wrappedSuccess, wrappedFailure);\n        if (res && typeof res.then === 'function') {\n            res.then(wrappedSuccess, wrappedFailure);\n        }\n    }\n    class Emitter {\n        constructor(){\n            this.handlers = {};\n            this.thisContext = null;\n        }\n        setThisContext(thisContext) {\n            this.thisContext = thisContext;\n        }\n        setOptions(options) {\n            this.options = options;\n        }\n        on(type, handler) {\n            addToHash(this.handlers, type, handler);\n        }\n        off(type, handler) {\n            removeFromHash(this.handlers, type, handler);\n        }\n        trigger(type, ...args) {\n            let attachedHandlers = this.handlers[type] || [];\n            let optionHandler = this.options && this.options[type];\n            let handlers = [].concat(optionHandler || [], attachedHandlers);\n            for (let handler of handlers){\n                handler.apply(this.thisContext, args);\n            }\n        }\n        hasHandlers(type) {\n            return Boolean(this.handlers[type] && this.handlers[type].length || this.options && this.options[type]);\n        }\n    }\n    function addToHash(hash, type, handler) {\n        (hash[type] || (hash[type] = [])).push(handler);\n    }\n    function removeFromHash(hash, type, handler) {\n        if (handler) {\n            if (hash[type]) {\n                hash[type] = hash[type].filter((func)=>func !== handler);\n            }\n        } else {\n            delete hash[type]; // remove all handler funcs for this type\n        }\n    }\n    /*\r\n    Records offset information for a set of elements, relative to an origin element.\r\n    Can record the left/right OR the top/bottom OR both.\r\n    Provides methods for querying the cache by position.\r\n    */ class PositionCache {\n        constructor(originEl, els, isHorizontal, isVertical){\n            this.els = els;\n            let originClientRect = this.originClientRect = originEl.getBoundingClientRect(); // relative to viewport top-left\n            if (isHorizontal) {\n                this.buildElHorizontals(originClientRect.left);\n            }\n            if (isVertical) {\n                this.buildElVerticals(originClientRect.top);\n            }\n        }\n        // Populates the left/right internal coordinate arrays\n        buildElHorizontals(originClientLeft) {\n            let lefts = [];\n            let rights = [];\n            for (let el of this.els){\n                let rect = el.getBoundingClientRect();\n                lefts.push(rect.left - originClientLeft);\n                rights.push(rect.right - originClientLeft);\n            }\n            this.lefts = lefts;\n            this.rights = rights;\n        }\n        // Populates the top/bottom internal coordinate arrays\n        buildElVerticals(originClientTop) {\n            let tops = [];\n            let bottoms = [];\n            for (let el of this.els){\n                let rect = el.getBoundingClientRect();\n                tops.push(rect.top - originClientTop);\n                bottoms.push(rect.bottom - originClientTop);\n            }\n            this.tops = tops;\n            this.bottoms = bottoms;\n        }\n        // Given a left offset (from document left), returns the index of the el that it horizontally intersects.\n        // If no intersection is made, returns undefined.\n        leftToIndex(leftPosition) {\n            let { lefts, rights } = this;\n            let len = lefts.length;\n            let i;\n            for(i = 0; i < len; i += 1){\n                if (leftPosition >= lefts[i] && leftPosition < rights[i]) {\n                    return i;\n                }\n            }\n            return undefined; // TODO: better\n        }\n        // Given a top offset (from document top), returns the index of the el that it vertically intersects.\n        // If no intersection is made, returns undefined.\n        topToIndex(topPosition) {\n            let { tops, bottoms } = this;\n            let len = tops.length;\n            let i;\n            for(i = 0; i < len; i += 1){\n                if (topPosition >= tops[i] && topPosition < bottoms[i]) {\n                    return i;\n                }\n            }\n            return undefined; // TODO: better\n        }\n        // Gets the width of the element at the given index\n        getWidth(leftIndex) {\n            return this.rights[leftIndex] - this.lefts[leftIndex];\n        }\n        // Gets the height of the element at the given index\n        getHeight(topIndex) {\n            return this.bottoms[topIndex] - this.tops[topIndex];\n        }\n        similarTo(otherCache) {\n            return similarNumArrays(this.tops || [], otherCache.tops || []) && similarNumArrays(this.bottoms || [], otherCache.bottoms || []) && similarNumArrays(this.lefts || [], otherCache.lefts || []) && similarNumArrays(this.rights || [], otherCache.rights || []);\n        }\n    }\n    function similarNumArrays(a, b) {\n        const len = a.length;\n        if (len !== b.length) {\n            return false;\n        }\n        for(let i = 0; i < len; i++){\n            if (Math.round(a[i]) !== Math.round(b[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /* eslint max-classes-per-file: \"off\" */ /*\r\n    An object for getting/setting scroll-related information for an element.\r\n    Internally, this is done very differently for window versus DOM element,\r\n    so this object serves as a common interface.\r\n    */ class ScrollController {\n        getMaxScrollTop() {\n            return this.getScrollHeight() - this.getClientHeight();\n        }\n        getMaxScrollLeft() {\n            return this.getScrollWidth() - this.getClientWidth();\n        }\n        canScrollVertically() {\n            return this.getMaxScrollTop() > 0;\n        }\n        canScrollHorizontally() {\n            return this.getMaxScrollLeft() > 0;\n        }\n        canScrollUp() {\n            return this.getScrollTop() > 0;\n        }\n        canScrollDown() {\n            return this.getScrollTop() < this.getMaxScrollTop();\n        }\n        canScrollLeft() {\n            return this.getScrollLeft() > 0;\n        }\n        canScrollRight() {\n            return this.getScrollLeft() < this.getMaxScrollLeft();\n        }\n    }\n    class ElementScrollController extends ScrollController {\n        constructor(el){\n            super();\n            this.el = el;\n        }\n        getScrollTop() {\n            return this.el.scrollTop;\n        }\n        getScrollLeft() {\n            return this.el.scrollLeft;\n        }\n        setScrollTop(top) {\n            this.el.scrollTop = top;\n        }\n        setScrollLeft(left) {\n            this.el.scrollLeft = left;\n        }\n        getScrollWidth() {\n            return this.el.scrollWidth;\n        }\n        getScrollHeight() {\n            return this.el.scrollHeight;\n        }\n        getClientHeight() {\n            return this.el.clientHeight;\n        }\n        getClientWidth() {\n            return this.el.clientWidth;\n        }\n    }\n    class WindowScrollController extends ScrollController {\n        getScrollTop() {\n            return window.pageYOffset;\n        }\n        getScrollLeft() {\n            return window.pageXOffset;\n        }\n        setScrollTop(n) {\n            window.scroll(window.pageXOffset, n);\n        }\n        setScrollLeft(n) {\n            window.scroll(n, window.pageYOffset);\n        }\n        getScrollWidth() {\n            return document.documentElement.scrollWidth;\n        }\n        getScrollHeight() {\n            return document.documentElement.scrollHeight;\n        }\n        getClientHeight() {\n            return document.documentElement.clientHeight;\n        }\n        getClientWidth() {\n            return document.documentElement.clientWidth;\n        }\n    }\n    class Theme {\n        constructor(calendarOptions){\n            if (this.iconOverrideOption) {\n                this.setIconOverride(calendarOptions[this.iconOverrideOption]);\n            }\n        }\n        setIconOverride(iconOverrideHash) {\n            let iconClassesCopy;\n            let buttonName;\n            if (typeof iconOverrideHash === 'object' && iconOverrideHash) {\n                iconClassesCopy = Object.assign({}, this.iconClasses);\n                for(buttonName in iconOverrideHash){\n                    iconClassesCopy[buttonName] = this.applyIconOverridePrefix(iconOverrideHash[buttonName]);\n                }\n                this.iconClasses = iconClassesCopy;\n            } else if (iconOverrideHash === false) {\n                this.iconClasses = {};\n            }\n        }\n        applyIconOverridePrefix(className) {\n            let prefix = this.iconOverridePrefix;\n            if (prefix && className.indexOf(prefix) !== 0) {\n                className = prefix + className;\n            }\n            return className;\n        }\n        getClass(key) {\n            return this.classes[key] || '';\n        }\n        getIconClass(buttonName, isRtl) {\n            let className;\n            if (isRtl && this.rtlIconClasses) {\n                className = this.rtlIconClasses[buttonName] || this.iconClasses[buttonName];\n            } else {\n                className = this.iconClasses[buttonName];\n            }\n            if (className) {\n                return `${this.baseIconClass} ${className}`;\n            }\n            return '';\n        }\n        getCustomButtonIconClass(customButtonProps) {\n            let className;\n            if (this.iconOverrideCustomButtonOption) {\n                className = customButtonProps[this.iconOverrideCustomButtonOption];\n                if (className) {\n                    return `${this.baseIconClass} ${this.applyIconOverridePrefix(className)}`;\n                }\n            }\n            return '';\n        }\n    }\n    Theme.prototype.classes = {};\n    Theme.prototype.iconClasses = {};\n    Theme.prototype.baseIconClass = '';\n    Theme.prototype.iconOverridePrefix = '';\n    /*\r\n    NOTE: this can be a public API, especially createElement for hooks.\r\n    See examples/typescript-scheduler/src/index.ts\r\n    */ function flushSync(runBeforeFlush) {\n        runBeforeFlush();\n        let oldDebounceRendering = l$1.debounceRendering; // orig\n        let callbackQ = [];\n        function execCallbackSync(callback) {\n            callbackQ.push(callback);\n        }\n        l$1.debounceRendering = execCallbackSync;\n        D$1(y(FakeComponent, {}), document.createElement('div'));\n        while(callbackQ.length){\n            callbackQ.shift()();\n        }\n        l$1.debounceRendering = oldDebounceRendering;\n    }\n    class FakeComponent extends x$1 {\n        render() {\n            return y('div', {});\n        }\n        componentDidMount() {\n            this.setState({});\n        }\n    }\n    // TODO: use preact/compat instead?\n    function createContext(defaultValue) {\n        let ContextType = G$1(defaultValue);\n        let origProvider = ContextType.Provider;\n        ContextType.Provider = function() {\n            let isNew = !this.getChildContext;\n            let children = origProvider.apply(this, arguments); // eslint-disable-line prefer-rest-params\n            if (isNew) {\n                let subs = [];\n                this.shouldComponentUpdate = (_props)=>{\n                    if (this.props.value !== _props.value) {\n                        subs.forEach((c)=>{\n                            c.context = _props.value;\n                            c.forceUpdate();\n                        });\n                    }\n                };\n                this.sub = (c)=>{\n                    subs.push(c);\n                    let old = c.componentWillUnmount;\n                    c.componentWillUnmount = ()=>{\n                        subs.splice(subs.indexOf(c), 1);\n                        old && old.call(c);\n                    };\n                };\n            }\n            return children;\n        };\n        return ContextType;\n    }\n    class ScrollResponder {\n        constructor(execFunc, emitter, scrollTime, scrollTimeReset){\n            this.execFunc = execFunc;\n            this.emitter = emitter;\n            this.scrollTime = scrollTime;\n            this.scrollTimeReset = scrollTimeReset;\n            this.handleScrollRequest = (request)=>{\n                this.queuedRequest = Object.assign({}, this.queuedRequest || {}, request);\n                this.drain();\n            };\n            emitter.on('_scrollRequest', this.handleScrollRequest);\n            this.fireInitialScroll();\n        }\n        detach() {\n            this.emitter.off('_scrollRequest', this.handleScrollRequest);\n        }\n        update(isDatesNew) {\n            if (isDatesNew && this.scrollTimeReset) {\n                this.fireInitialScroll(); // will drain\n            } else {\n                this.drain();\n            }\n        }\n        fireInitialScroll() {\n            this.handleScrollRequest({\n                time: this.scrollTime\n            });\n        }\n        drain() {\n            if (this.queuedRequest && this.execFunc(this.queuedRequest)) {\n                this.queuedRequest = null;\n            }\n        }\n    }\n    const ViewContextType = createContext({}); // for Components\n    function buildViewContext(viewSpec, viewApi, viewOptions, dateProfileGenerator, dateEnv, theme, pluginHooks, dispatch, getCurrentData, emitter, calendarApi, registerInteractiveComponent, unregisterInteractiveComponent) {\n        return {\n            dateEnv,\n            options: viewOptions,\n            pluginHooks,\n            emitter,\n            dispatch,\n            getCurrentData,\n            calendarApi,\n            viewSpec,\n            viewApi,\n            dateProfileGenerator,\n            theme,\n            isRtl: viewOptions.direction === 'rtl',\n            addResizeHandler (handler) {\n                emitter.on('_resize', handler);\n            },\n            removeResizeHandler (handler) {\n                emitter.off('_resize', handler);\n            },\n            createScrollResponder (execFunc) {\n                return new ScrollResponder(execFunc, emitter, createDuration(viewOptions.scrollTime), viewOptions.scrollTimeReset);\n            },\n            registerInteractiveComponent,\n            unregisterInteractiveComponent\n        };\n    }\n    /* eslint max-classes-per-file: off */ class PureComponent extends x$1 {\n        shouldComponentUpdate(nextProps, nextState) {\n            if (this.debug) {\n                // eslint-disable-next-line no-console\n                console.log(getUnequalProps(nextProps, this.props), getUnequalProps(nextState, this.state));\n            }\n            return !compareObjs(this.props, nextProps, this.propEquality) || !compareObjs(this.state, nextState, this.stateEquality);\n        }\n        // HACK for freakin' React StrictMode\n        safeSetState(newState) {\n            if (!compareObjs(this.state, Object.assign(Object.assign({}, this.state), newState), this.stateEquality)) {\n                this.setState(newState);\n            }\n        }\n    }\n    PureComponent.addPropsEquality = addPropsEquality;\n    PureComponent.addStateEquality = addStateEquality;\n    PureComponent.contextType = ViewContextType;\n    PureComponent.prototype.propEquality = {};\n    PureComponent.prototype.stateEquality = {};\n    class BaseComponent extends PureComponent {\n    }\n    BaseComponent.contextType = ViewContextType;\n    function addPropsEquality(propEquality) {\n        let hash = Object.create(this.prototype.propEquality);\n        Object.assign(hash, propEquality);\n        this.prototype.propEquality = hash;\n    }\n    function addStateEquality(stateEquality) {\n        let hash = Object.create(this.prototype.stateEquality);\n        Object.assign(hash, stateEquality);\n        this.prototype.stateEquality = hash;\n    }\n    // use other one\n    function setRef(ref, current) {\n        if (typeof ref === 'function') {\n            ref(current);\n        } else if (ref) {\n            // see https://github.com/facebook/react/issues/13029\n            ref.current = current;\n        }\n    }\n    /*\r\n    an INTERACTABLE date component\r\n\r\n    PURPOSES:\r\n    - hook up to fg, fill, and mirror renderers\r\n    - interface for dragging and hits\r\n    */ class DateComponent extends BaseComponent {\n        constructor(){\n            super(...arguments);\n            this.uid = guid();\n        }\n        // Hit System\n        // -----------------------------------------------------------------------------------------------------------------\n        prepareHits() {}\n        queryHit(positionLeft, positionTop, elWidth, elHeight) {\n            return null; // this should be abstract\n        }\n        // Pointer Interaction Utils\n        // -----------------------------------------------------------------------------------------------------------------\n        isValidSegDownEl(el) {\n            return !this.props.eventDrag && // HACK\n            !this.props.eventResize && // HACK\n            !elementClosest(el, '.fc-event-mirror');\n        }\n        isValidDateDownEl(el) {\n            return !elementClosest(el, '.fc-event:not(.fc-bg-event)') && !elementClosest(el, '.fc-more-link') && // a \"more..\" link\n            !elementClosest(el, 'a[data-navlink]') && // a clickable nav link\n            !elementClosest(el, '.fc-popover'); // hack\n        }\n    }\n    function reduceCurrentDate(currentDate, action) {\n        switch(action.type){\n            case 'CHANGE_DATE':\n                return action.dateMarker;\n            default:\n                return currentDate;\n        }\n    }\n    function getInitialDate(options, dateEnv) {\n        let initialDateInput = options.initialDate;\n        // compute the initial ambig-timezone date\n        if (initialDateInput != null) {\n            return dateEnv.createMarker(initialDateInput);\n        }\n        return getNow(options.now, dateEnv); // getNow already returns unzoned\n    }\n    function getNow(nowInput, dateEnv) {\n        if (typeof nowInput === 'function') {\n            nowInput = nowInput();\n        }\n        if (nowInput == null) {\n            return dateEnv.createNowMarker();\n        }\n        return dateEnv.createMarker(nowInput);\n    }\n    class DateProfileGenerator {\n        constructor(props){\n            this.props = props;\n            this.nowDate = getNow(props.nowInput, props.dateEnv);\n            this.initHiddenDays();\n        }\n        /* Date Range Computation\r\n        ------------------------------------------------------------------------------------------------------------------*/ // Builds a structure with info about what the dates/ranges will be for the \"prev\" view.\n        buildPrev(currentDateProfile, currentDate, forceToValid) {\n            let { dateEnv } = this.props;\n            let prevDate = dateEnv.subtract(dateEnv.startOf(currentDate, currentDateProfile.currentRangeUnit), currentDateProfile.dateIncrement);\n            return this.build(prevDate, -1, forceToValid);\n        }\n        // Builds a structure with info about what the dates/ranges will be for the \"next\" view.\n        buildNext(currentDateProfile, currentDate, forceToValid) {\n            let { dateEnv } = this.props;\n            let nextDate = dateEnv.add(dateEnv.startOf(currentDate, currentDateProfile.currentRangeUnit), currentDateProfile.dateIncrement);\n            return this.build(nextDate, 1, forceToValid);\n        }\n        // Builds a structure holding dates/ranges for rendering around the given date.\n        // Optional direction param indicates whether the date is being incremented/decremented\n        // from its previous value. decremented = -1, incremented = 1 (default).\n        build(currentDate, direction, forceToValid = true) {\n            let { props } = this;\n            let validRange;\n            let currentInfo;\n            let isRangeAllDay;\n            let renderRange;\n            let activeRange;\n            let isValid;\n            validRange = this.buildValidRange();\n            validRange = this.trimHiddenDays(validRange);\n            if (forceToValid) {\n                currentDate = constrainMarkerToRange(currentDate, validRange);\n            }\n            currentInfo = this.buildCurrentRangeInfo(currentDate, direction);\n            isRangeAllDay = /^(year|month|week|day)$/.test(currentInfo.unit);\n            renderRange = this.buildRenderRange(this.trimHiddenDays(currentInfo.range), currentInfo.unit, isRangeAllDay);\n            renderRange = this.trimHiddenDays(renderRange);\n            activeRange = renderRange;\n            if (!props.showNonCurrentDates) {\n                activeRange = intersectRanges(activeRange, currentInfo.range);\n            }\n            activeRange = this.adjustActiveRange(activeRange);\n            activeRange = intersectRanges(activeRange, validRange); // might return null\n            // it's invalid if the originally requested date is not contained,\n            // or if the range is completely outside of the valid range.\n            isValid = rangesIntersect(currentInfo.range, validRange);\n            // HACK: constrain to render-range so `currentDate` is more useful to view rendering\n            if (!rangeContainsMarker(renderRange, currentDate)) {\n                currentDate = renderRange.start;\n            }\n            return {\n                currentDate,\n                // constraint for where prev/next operations can go and where events can be dragged/resized to.\n                // an object with optional start and end properties.\n                validRange,\n                // range the view is formally responsible for.\n                // for example, a month view might have 1st-31st, excluding padded dates\n                currentRange: currentInfo.range,\n                // name of largest unit being displayed, like \"month\" or \"week\"\n                currentRangeUnit: currentInfo.unit,\n                isRangeAllDay,\n                // dates that display events and accept drag-n-drop\n                // will be `null` if no dates accept events\n                activeRange,\n                // date range with a rendered skeleton\n                // includes not-active days that need some sort of DOM\n                renderRange,\n                // Duration object that denotes the first visible time of any given day\n                slotMinTime: props.slotMinTime,\n                // Duration object that denotes the exclusive visible end time of any given day\n                slotMaxTime: props.slotMaxTime,\n                isValid,\n                // how far the current date will move for a prev/next operation\n                dateIncrement: this.buildDateIncrement(currentInfo.duration)\n            };\n        }\n        // Builds an object with optional start/end properties.\n        // Indicates the minimum/maximum dates to display.\n        // not responsible for trimming hidden days.\n        buildValidRange() {\n            let input = this.props.validRangeInput;\n            let simpleInput = typeof input === 'function' ? input.call(this.props.calendarApi, this.nowDate) : input;\n            return this.refineRange(simpleInput) || {\n                start: null,\n                end: null\n            }; // completely open-ended\n        }\n        // Builds a structure with info about the \"current\" range, the range that is\n        // highlighted as being the current month for example.\n        // See build() for a description of `direction`.\n        // Guaranteed to have `range` and `unit` properties. `duration` is optional.\n        buildCurrentRangeInfo(date, direction) {\n            let { props } = this;\n            let duration = null;\n            let unit = null;\n            let range = null;\n            let dayCount;\n            if (props.duration) {\n                duration = props.duration;\n                unit = props.durationUnit;\n                range = this.buildRangeFromDuration(date, direction, duration, unit);\n            } else if (dayCount = this.props.dayCount) {\n                unit = 'day';\n                range = this.buildRangeFromDayCount(date, direction, dayCount);\n            } else if (range = this.buildCustomVisibleRange(date)) {\n                unit = props.dateEnv.greatestWholeUnit(range.start, range.end).unit;\n            } else {\n                duration = this.getFallbackDuration();\n                unit = greatestDurationDenominator(duration).unit;\n                range = this.buildRangeFromDuration(date, direction, duration, unit);\n            }\n            return {\n                duration,\n                unit,\n                range\n            };\n        }\n        getFallbackDuration() {\n            return createDuration({\n                day: 1\n            });\n        }\n        // Returns a new activeRange to have time values (un-ambiguate)\n        // slotMinTime or slotMaxTime causes the range to expand.\n        adjustActiveRange(range) {\n            let { dateEnv, usesMinMaxTime, slotMinTime, slotMaxTime } = this.props;\n            let { start, end } = range;\n            if (usesMinMaxTime) {\n                // expand active range if slotMinTime is negative (why not when positive?)\n                if (asRoughDays(slotMinTime) < 0) {\n                    start = startOfDay(start); // necessary?\n                    start = dateEnv.add(start, slotMinTime);\n                }\n                // expand active range if slotMaxTime is beyond one day (why not when negative?)\n                if (asRoughDays(slotMaxTime) > 1) {\n                    end = startOfDay(end); // necessary?\n                    end = addDays(end, -1);\n                    end = dateEnv.add(end, slotMaxTime);\n                }\n            }\n            return {\n                start,\n                end\n            };\n        }\n        // Builds the \"current\" range when it is specified as an explicit duration.\n        // `unit` is the already-computed greatestDurationDenominator unit of duration.\n        buildRangeFromDuration(date, direction, duration, unit) {\n            let { dateEnv, dateAlignment } = this.props;\n            let start;\n            let end;\n            let res;\n            // compute what the alignment should be\n            if (!dateAlignment) {\n                let { dateIncrement } = this.props;\n                if (dateIncrement) {\n                    // use the smaller of the two units\n                    if (asRoughMs(dateIncrement) < asRoughMs(duration)) {\n                        dateAlignment = greatestDurationDenominator(dateIncrement).unit;\n                    } else {\n                        dateAlignment = unit;\n                    }\n                } else {\n                    dateAlignment = unit;\n                }\n            }\n            // if the view displays a single day or smaller\n            if (asRoughDays(duration) <= 1) {\n                if (this.isHiddenDay(start)) {\n                    start = this.skipHiddenDays(start, direction);\n                    start = startOfDay(start);\n                }\n            }\n            function computeRes() {\n                start = dateEnv.startOf(date, dateAlignment);\n                end = dateEnv.add(start, duration);\n                res = {\n                    start,\n                    end\n                };\n            }\n            computeRes();\n            // if range is completely enveloped by hidden days, go past the hidden days\n            if (!this.trimHiddenDays(res)) {\n                date = this.skipHiddenDays(date, direction);\n                computeRes();\n            }\n            return res;\n        }\n        // Builds the \"current\" range when a dayCount is specified.\n        buildRangeFromDayCount(date, direction, dayCount) {\n            let { dateEnv, dateAlignment } = this.props;\n            let runningCount = 0;\n            let start = date;\n            let end;\n            if (dateAlignment) {\n                start = dateEnv.startOf(start, dateAlignment);\n            }\n            start = startOfDay(start);\n            start = this.skipHiddenDays(start, direction);\n            end = start;\n            do {\n                end = addDays(end, 1);\n                if (!this.isHiddenDay(end)) {\n                    runningCount += 1;\n                }\n            }while (runningCount < dayCount);\n            return {\n                start,\n                end\n            };\n        }\n        // Builds a normalized range object for the \"visible\" range,\n        // which is a way to define the currentRange and activeRange at the same time.\n        buildCustomVisibleRange(date) {\n            let { props } = this;\n            let input = props.visibleRangeInput;\n            let simpleInput = typeof input === 'function' ? input.call(props.calendarApi, props.dateEnv.toDate(date)) : input;\n            let range = this.refineRange(simpleInput);\n            if (range && (range.start == null || range.end == null)) {\n                return null;\n            }\n            return range;\n        }\n        // Computes the range that will represent the element/cells for *rendering*,\n        // but which may have voided days/times.\n        // not responsible for trimming hidden days.\n        buildRenderRange(currentRange, currentRangeUnit, isRangeAllDay) {\n            return currentRange;\n        }\n        // Compute the duration value that should be added/substracted to the current date\n        // when a prev/next operation happens.\n        buildDateIncrement(fallback) {\n            let { dateIncrement } = this.props;\n            let customAlignment;\n            if (dateIncrement) {\n                return dateIncrement;\n            }\n            if (customAlignment = this.props.dateAlignment) {\n                return createDuration(1, customAlignment);\n            }\n            if (fallback) {\n                return fallback;\n            }\n            return createDuration({\n                days: 1\n            });\n        }\n        refineRange(rangeInput) {\n            if (rangeInput) {\n                let range = parseRange(rangeInput, this.props.dateEnv);\n                if (range) {\n                    range = computeVisibleDayRange(range);\n                }\n                return range;\n            }\n            return null;\n        }\n        /* Hidden Days\r\n        ------------------------------------------------------------------------------------------------------------------*/ // Initializes internal variables related to calculating hidden days-of-week\n        initHiddenDays() {\n            let hiddenDays = this.props.hiddenDays || []; // array of day-of-week indices that are hidden\n            let isHiddenDayHash = []; // is the day-of-week hidden? (hash with day-of-week-index -> bool)\n            let dayCnt = 0;\n            let i;\n            if (this.props.weekends === false) {\n                hiddenDays.push(0, 6); // 0=sunday, 6=saturday\n            }\n            for(i = 0; i < 7; i += 1){\n                if (!(isHiddenDayHash[i] = hiddenDays.indexOf(i) !== -1)) {\n                    dayCnt += 1;\n                }\n            }\n            if (!dayCnt) {\n                throw new Error('invalid hiddenDays'); // all days were hidden? bad.\n            }\n            this.isHiddenDayHash = isHiddenDayHash;\n        }\n        // Remove days from the beginning and end of the range that are computed as hidden.\n        // If the whole range is trimmed off, returns null\n        trimHiddenDays(range) {\n            let { start, end } = range;\n            if (start) {\n                start = this.skipHiddenDays(start);\n            }\n            if (end) {\n                end = this.skipHiddenDays(end, -1, true);\n            }\n            if (start == null || end == null || start < end) {\n                return {\n                    start,\n                    end\n                };\n            }\n            return null;\n        }\n        // Is the current day hidden?\n        // `day` is a day-of-week index (0-6), or a Date (used for UTC)\n        isHiddenDay(day) {\n            if (day instanceof Date) {\n                day = day.getUTCDay();\n            }\n            return this.isHiddenDayHash[day];\n        }\n        // Incrementing the current day until it is no longer a hidden day, returning a copy.\n        // DOES NOT CONSIDER validRange!\n        // If the initial value of `date` is not a hidden day, don't do anything.\n        // Pass `isExclusive` as `true` if you are dealing with an end date.\n        // `inc` defaults to `1` (increment one day forward each time)\n        skipHiddenDays(date, inc = 1, isExclusive = false) {\n            while(this.isHiddenDayHash[(date.getUTCDay() + (isExclusive ? inc : 0) + 7) % 7]){\n                date = addDays(date, inc);\n            }\n            return date;\n        }\n    }\n    function triggerDateSelect(selection, pev, context) {\n        context.emitter.trigger('select', Object.assign(Object.assign({}, buildDateSpanApiWithContext(selection, context)), {\n            jsEvent: pev ? pev.origEvent : null,\n            view: context.viewApi || context.calendarApi.view\n        }));\n    }\n    function triggerDateUnselect(pev, context) {\n        context.emitter.trigger('unselect', {\n            jsEvent: pev ? pev.origEvent : null,\n            view: context.viewApi || context.calendarApi.view\n        });\n    }\n    function buildDateSpanApiWithContext(dateSpan, context) {\n        let props = {};\n        for (let transform of context.pluginHooks.dateSpanTransforms){\n            Object.assign(props, transform(dateSpan, context));\n        }\n        Object.assign(props, buildDateSpanApi(dateSpan, context.dateEnv));\n        return props;\n    }\n    // Given an event's allDay status and start date, return what its fallback end date should be.\n    // TODO: rename to computeDefaultEventEnd\n    function getDefaultEventEnd(allDay, marker, context) {\n        let { dateEnv, options } = context;\n        let end = marker;\n        if (allDay) {\n            end = startOfDay(end);\n            end = dateEnv.add(end, options.defaultAllDayEventDuration);\n        } else {\n            end = dateEnv.add(end, options.defaultTimedEventDuration);\n        }\n        return end;\n    }\n    // applies the mutation to ALL defs/instances within the event store\n    function applyMutationToEventStore(eventStore, eventConfigBase, mutation, context) {\n        let eventConfigs = compileEventUis(eventStore.defs, eventConfigBase);\n        let dest = createEmptyEventStore();\n        for(let defId in eventStore.defs){\n            let def = eventStore.defs[defId];\n            dest.defs[defId] = applyMutationToEventDef(def, eventConfigs[defId], mutation, context);\n        }\n        for(let instanceId in eventStore.instances){\n            let instance = eventStore.instances[instanceId];\n            let def = dest.defs[instance.defId]; // important to grab the newly modified def\n            dest.instances[instanceId] = applyMutationToEventInstance(instance, def, eventConfigs[instance.defId], mutation, context);\n        }\n        return dest;\n    }\n    function applyMutationToEventDef(eventDef, eventConfig, mutation, context) {\n        let standardProps = mutation.standardProps || {};\n        // if hasEnd has not been specified, guess a good value based on deltas.\n        // if duration will change, there's no way the default duration will persist,\n        // and thus, we need to mark the event as having a real end\n        if (standardProps.hasEnd == null && eventConfig.durationEditable && (mutation.startDelta || mutation.endDelta)) {\n            standardProps.hasEnd = true; // TODO: is this mutation okay?\n        }\n        let copy = Object.assign(Object.assign(Object.assign({}, eventDef), standardProps), {\n            ui: Object.assign(Object.assign({}, eventDef.ui), standardProps.ui)\n        });\n        if (mutation.extendedProps) {\n            copy.extendedProps = Object.assign(Object.assign({}, copy.extendedProps), mutation.extendedProps);\n        }\n        for (let applier of context.pluginHooks.eventDefMutationAppliers){\n            applier(copy, mutation, context);\n        }\n        if (!copy.hasEnd && context.options.forceEventDuration) {\n            copy.hasEnd = true;\n        }\n        return copy;\n    }\n    function applyMutationToEventInstance(eventInstance, eventDef, eventConfig, mutation, context) {\n        let { dateEnv } = context;\n        let forceAllDay = mutation.standardProps && mutation.standardProps.allDay === true;\n        let clearEnd = mutation.standardProps && mutation.standardProps.hasEnd === false;\n        let copy = Object.assign({}, eventInstance);\n        if (forceAllDay) {\n            copy.range = computeAlignedDayRange(copy.range);\n        }\n        if (mutation.datesDelta && eventConfig.startEditable) {\n            copy.range = {\n                start: dateEnv.add(copy.range.start, mutation.datesDelta),\n                end: dateEnv.add(copy.range.end, mutation.datesDelta)\n            };\n        }\n        if (mutation.startDelta && eventConfig.durationEditable) {\n            copy.range = {\n                start: dateEnv.add(copy.range.start, mutation.startDelta),\n                end: copy.range.end\n            };\n        }\n        if (mutation.endDelta && eventConfig.durationEditable) {\n            copy.range = {\n                start: copy.range.start,\n                end: dateEnv.add(copy.range.end, mutation.endDelta)\n            };\n        }\n        if (clearEnd) {\n            copy.range = {\n                start: copy.range.start,\n                end: getDefaultEventEnd(eventDef.allDay, copy.range.start, context)\n            };\n        }\n        // in case event was all-day but the supplied deltas were not\n        // better util for this?\n        if (eventDef.allDay) {\n            copy.range = {\n                start: startOfDay(copy.range.start),\n                end: startOfDay(copy.range.end)\n            };\n        }\n        // handle invalid durations\n        if (copy.range.end < copy.range.start) {\n            copy.range.end = getDefaultEventEnd(eventDef.allDay, copy.range.start, context);\n        }\n        return copy;\n    }\n    class EventSourceImpl {\n        constructor(context, internalEventSource){\n            this.context = context;\n            this.internalEventSource = internalEventSource;\n        }\n        remove() {\n            this.context.dispatch({\n                type: 'REMOVE_EVENT_SOURCE',\n                sourceId: this.internalEventSource.sourceId\n            });\n        }\n        refetch() {\n            this.context.dispatch({\n                type: 'FETCH_EVENT_SOURCES',\n                sourceIds: [\n                    this.internalEventSource.sourceId\n                ],\n                isRefetch: true\n            });\n        }\n        get id() {\n            return this.internalEventSource.publicId;\n        }\n        get url() {\n            return this.internalEventSource.meta.url;\n        }\n        get format() {\n            return this.internalEventSource.meta.format; // TODO: bad. not guaranteed\n        }\n    }\n    class EventImpl {\n        // instance will be null if expressing a recurring event that has no current instances,\n        // OR if trying to validate an incoming external event that has no dates assigned\n        constructor(context, def, instance){\n            this._context = context;\n            this._def = def;\n            this._instance = instance || null;\n        }\n        /*\r\n        TODO: make event struct more responsible for this\r\n        */ setProp(name, val) {\n            if (name in EVENT_DATE_REFINERS) {\n                console.warn('Could not set date-related prop \\'name\\'. Use one of the date-related methods instead.');\n            // TODO: make proper aliasing system?\n            } else if (name === 'id') {\n                val = EVENT_NON_DATE_REFINERS[name](val);\n                this.mutate({\n                    standardProps: {\n                        publicId: val\n                    }\n                });\n            } else if (name in EVENT_NON_DATE_REFINERS) {\n                val = EVENT_NON_DATE_REFINERS[name](val);\n                this.mutate({\n                    standardProps: {\n                        [name]: val\n                    }\n                });\n            } else if (name in EVENT_UI_REFINERS) {\n                let ui = EVENT_UI_REFINERS[name](val);\n                if (name === 'color') {\n                    ui = {\n                        backgroundColor: val,\n                        borderColor: val\n                    };\n                } else if (name === 'editable') {\n                    ui = {\n                        startEditable: val,\n                        durationEditable: val\n                    };\n                } else {\n                    ui = {\n                        [name]: val\n                    };\n                }\n                this.mutate({\n                    standardProps: {\n                        ui\n                    }\n                });\n            } else {\n                console.warn(`Could not set prop '${name}'. Use setExtendedProp instead.`);\n            }\n        }\n        setExtendedProp(name, val) {\n            this.mutate({\n                extendedProps: {\n                    [name]: val\n                }\n            });\n        }\n        setStart(startInput, options = {}) {\n            let { dateEnv } = this._context;\n            let start = dateEnv.createMarker(startInput);\n            if (start && this._instance) {\n                let instanceRange = this._instance.range;\n                let startDelta = diffDates(instanceRange.start, start, dateEnv, options.granularity); // what if parsed bad!?\n                if (options.maintainDuration) {\n                    this.mutate({\n                        datesDelta: startDelta\n                    });\n                } else {\n                    this.mutate({\n                        startDelta\n                    });\n                }\n            }\n        }\n        setEnd(endInput, options = {}) {\n            let { dateEnv } = this._context;\n            let end;\n            if (endInput != null) {\n                end = dateEnv.createMarker(endInput);\n                if (!end) {\n                    return; // TODO: warning if parsed bad\n                }\n            }\n            if (this._instance) {\n                if (end) {\n                    let endDelta = diffDates(this._instance.range.end, end, dateEnv, options.granularity);\n                    this.mutate({\n                        endDelta\n                    });\n                } else {\n                    this.mutate({\n                        standardProps: {\n                            hasEnd: false\n                        }\n                    });\n                }\n            }\n        }\n        setDates(startInput, endInput, options = {}) {\n            let { dateEnv } = this._context;\n            let standardProps = {\n                allDay: options.allDay\n            };\n            let start = dateEnv.createMarker(startInput);\n            let end;\n            if (!start) {\n                return; // TODO: warning if parsed bad\n            }\n            if (endInput != null) {\n                end = dateEnv.createMarker(endInput);\n                if (!end) {\n                    return;\n                }\n            }\n            if (this._instance) {\n                let instanceRange = this._instance.range;\n                // when computing the diff for an event being converted to all-day,\n                // compute diff off of the all-day values the way event-mutation does.\n                if (options.allDay === true) {\n                    instanceRange = computeAlignedDayRange(instanceRange);\n                }\n                let startDelta = diffDates(instanceRange.start, start, dateEnv, options.granularity);\n                if (end) {\n                    let endDelta = diffDates(instanceRange.end, end, dateEnv, options.granularity);\n                    if (durationsEqual(startDelta, endDelta)) {\n                        this.mutate({\n                            datesDelta: startDelta,\n                            standardProps\n                        });\n                    } else {\n                        this.mutate({\n                            startDelta,\n                            endDelta,\n                            standardProps\n                        });\n                    }\n                } else {\n                    standardProps.hasEnd = false;\n                    this.mutate({\n                        datesDelta: startDelta,\n                        standardProps\n                    });\n                }\n            }\n        }\n        moveStart(deltaInput) {\n            let delta = createDuration(deltaInput);\n            if (delta) {\n                this.mutate({\n                    startDelta: delta\n                });\n            }\n        }\n        moveEnd(deltaInput) {\n            let delta = createDuration(deltaInput);\n            if (delta) {\n                this.mutate({\n                    endDelta: delta\n                });\n            }\n        }\n        moveDates(deltaInput) {\n            let delta = createDuration(deltaInput);\n            if (delta) {\n                this.mutate({\n                    datesDelta: delta\n                });\n            }\n        }\n        setAllDay(allDay, options = {}) {\n            let standardProps = {\n                allDay\n            };\n            let { maintainDuration } = options;\n            if (maintainDuration == null) {\n                maintainDuration = this._context.options.allDayMaintainDuration;\n            }\n            if (this._def.allDay !== allDay) {\n                standardProps.hasEnd = maintainDuration;\n            }\n            this.mutate({\n                standardProps\n            });\n        }\n        formatRange(formatInput) {\n            let { dateEnv } = this._context;\n            let instance = this._instance;\n            let formatter = createFormatter(formatInput);\n            if (this._def.hasEnd) {\n                return dateEnv.formatRange(instance.range.start, instance.range.end, formatter, {\n                    forcedStartTzo: instance.forcedStartTzo,\n                    forcedEndTzo: instance.forcedEndTzo\n                });\n            }\n            return dateEnv.format(instance.range.start, formatter, {\n                forcedTzo: instance.forcedStartTzo\n            });\n        }\n        mutate(mutation) {\n            let instance = this._instance;\n            if (instance) {\n                let def = this._def;\n                let context = this._context;\n                let { eventStore } = context.getCurrentData();\n                let relevantEvents = getRelevantEvents(eventStore, instance.instanceId);\n                let eventConfigBase = {\n                    '': {\n                        display: '',\n                        startEditable: true,\n                        durationEditable: true,\n                        constraints: [],\n                        overlap: null,\n                        allows: [],\n                        backgroundColor: '',\n                        borderColor: '',\n                        textColor: '',\n                        classNames: []\n                    }\n                };\n                relevantEvents = applyMutationToEventStore(relevantEvents, eventConfigBase, mutation, context);\n                let oldEvent = new EventImpl(context, def, instance); // snapshot\n                this._def = relevantEvents.defs[def.defId];\n                this._instance = relevantEvents.instances[instance.instanceId];\n                context.dispatch({\n                    type: 'MERGE_EVENTS',\n                    eventStore: relevantEvents\n                });\n                context.emitter.trigger('eventChange', {\n                    oldEvent,\n                    event: this,\n                    relatedEvents: buildEventApis(relevantEvents, context, instance),\n                    revert () {\n                        context.dispatch({\n                            type: 'RESET_EVENTS',\n                            eventStore\n                        });\n                    }\n                });\n            }\n        }\n        remove() {\n            let context = this._context;\n            let asStore = eventApiToStore(this);\n            context.dispatch({\n                type: 'REMOVE_EVENTS',\n                eventStore: asStore\n            });\n            context.emitter.trigger('eventRemove', {\n                event: this,\n                relatedEvents: [],\n                revert () {\n                    context.dispatch({\n                        type: 'MERGE_EVENTS',\n                        eventStore: asStore\n                    });\n                }\n            });\n        }\n        get source() {\n            let { sourceId } = this._def;\n            if (sourceId) {\n                return new EventSourceImpl(this._context, this._context.getCurrentData().eventSources[sourceId]);\n            }\n            return null;\n        }\n        get start() {\n            return this._instance ? this._context.dateEnv.toDate(this._instance.range.start) : null;\n        }\n        get end() {\n            return this._instance && this._def.hasEnd ? this._context.dateEnv.toDate(this._instance.range.end) : null;\n        }\n        get startStr() {\n            let instance = this._instance;\n            if (instance) {\n                return this._context.dateEnv.formatIso(instance.range.start, {\n                    omitTime: this._def.allDay,\n                    forcedTzo: instance.forcedStartTzo\n                });\n            }\n            return '';\n        }\n        get endStr() {\n            let instance = this._instance;\n            if (instance && this._def.hasEnd) {\n                return this._context.dateEnv.formatIso(instance.range.end, {\n                    omitTime: this._def.allDay,\n                    forcedTzo: instance.forcedEndTzo\n                });\n            }\n            return '';\n        }\n        // computable props that all access the def\n        // TODO: find a TypeScript-compatible way to do this at scale\n        get id() {\n            return this._def.publicId;\n        }\n        get groupId() {\n            return this._def.groupId;\n        }\n        get allDay() {\n            return this._def.allDay;\n        }\n        get title() {\n            return this._def.title;\n        }\n        get url() {\n            return this._def.url;\n        }\n        get display() {\n            return this._def.ui.display || 'auto';\n        }\n        get startEditable() {\n            return this._def.ui.startEditable;\n        }\n        get durationEditable() {\n            return this._def.ui.durationEditable;\n        }\n        get constraint() {\n            return this._def.ui.constraints[0] || null;\n        }\n        get overlap() {\n            return this._def.ui.overlap;\n        }\n        get allow() {\n            return this._def.ui.allows[0] || null;\n        }\n        get backgroundColor() {\n            return this._def.ui.backgroundColor;\n        }\n        get borderColor() {\n            return this._def.ui.borderColor;\n        }\n        get textColor() {\n            return this._def.ui.textColor;\n        }\n        // NOTE: user can't modify these because Object.freeze was called in event-def parsing\n        get classNames() {\n            return this._def.ui.classNames;\n        }\n        get extendedProps() {\n            return this._def.extendedProps;\n        }\n        toPlainObject(settings = {}) {\n            let def = this._def;\n            let { ui } = def;\n            let { startStr, endStr } = this;\n            let res = {\n                allDay: def.allDay\n            };\n            if (def.title) {\n                res.title = def.title;\n            }\n            if (startStr) {\n                res.start = startStr;\n            }\n            if (endStr) {\n                res.end = endStr;\n            }\n            if (def.publicId) {\n                res.id = def.publicId;\n            }\n            if (def.groupId) {\n                res.groupId = def.groupId;\n            }\n            if (def.url) {\n                res.url = def.url;\n            }\n            if (ui.display && ui.display !== 'auto') {\n                res.display = ui.display;\n            }\n            // TODO: what about recurring-event properties???\n            // TODO: include startEditable/durationEditable/constraint/overlap/allow\n            if (settings.collapseColor && ui.backgroundColor && ui.backgroundColor === ui.borderColor) {\n                res.color = ui.backgroundColor;\n            } else {\n                if (ui.backgroundColor) {\n                    res.backgroundColor = ui.backgroundColor;\n                }\n                if (ui.borderColor) {\n                    res.borderColor = ui.borderColor;\n                }\n            }\n            if (ui.textColor) {\n                res.textColor = ui.textColor;\n            }\n            if (ui.classNames.length) {\n                res.classNames = ui.classNames;\n            }\n            if (Object.keys(def.extendedProps).length) {\n                if (settings.collapseExtendedProps) {\n                    Object.assign(res, def.extendedProps);\n                } else {\n                    res.extendedProps = def.extendedProps;\n                }\n            }\n            return res;\n        }\n        toJSON() {\n            return this.toPlainObject();\n        }\n    }\n    function eventApiToStore(eventApi) {\n        let def = eventApi._def;\n        let instance = eventApi._instance;\n        return {\n            defs: {\n                [def.defId]: def\n            },\n            instances: instance ? {\n                [instance.instanceId]: instance\n            } : {}\n        };\n    }\n    function buildEventApis(eventStore, context, excludeInstance) {\n        let { defs, instances } = eventStore;\n        let eventApis = [];\n        let excludeInstanceId = excludeInstance ? excludeInstance.instanceId : '';\n        for(let id in instances){\n            let instance = instances[id];\n            let def = defs[instance.defId];\n            if (instance.instanceId !== excludeInstanceId) {\n                eventApis.push(new EventImpl(context, def, instance));\n            }\n        }\n        return eventApis;\n    }\n    /*\r\n    Specifying nextDayThreshold signals that all-day ranges should be sliced.\r\n    */ function sliceEventStore(eventStore, eventUiBases, framingRange, nextDayThreshold) {\n        let inverseBgByGroupId = {};\n        let inverseBgByDefId = {};\n        let defByGroupId = {};\n        let bgRanges = [];\n        let fgRanges = [];\n        let eventUis = compileEventUis(eventStore.defs, eventUiBases);\n        for(let defId in eventStore.defs){\n            let def = eventStore.defs[defId];\n            let ui = eventUis[def.defId];\n            if (ui.display === 'inverse-background') {\n                if (def.groupId) {\n                    inverseBgByGroupId[def.groupId] = [];\n                    if (!defByGroupId[def.groupId]) {\n                        defByGroupId[def.groupId] = def;\n                    }\n                } else {\n                    inverseBgByDefId[defId] = [];\n                }\n            }\n        }\n        for(let instanceId in eventStore.instances){\n            let instance = eventStore.instances[instanceId];\n            let def = eventStore.defs[instance.defId];\n            let ui = eventUis[def.defId];\n            let origRange = instance.range;\n            let normalRange = !def.allDay && nextDayThreshold ? computeVisibleDayRange(origRange, nextDayThreshold) : origRange;\n            let slicedRange = intersectRanges(normalRange, framingRange);\n            if (slicedRange) {\n                if (ui.display === 'inverse-background') {\n                    if (def.groupId) {\n                        inverseBgByGroupId[def.groupId].push(slicedRange);\n                    } else {\n                        inverseBgByDefId[instance.defId].push(slicedRange);\n                    }\n                } else if (ui.display !== 'none') {\n                    (ui.display === 'background' ? bgRanges : fgRanges).push({\n                        def,\n                        ui,\n                        instance,\n                        range: slicedRange,\n                        isStart: normalRange.start && normalRange.start.valueOf() === slicedRange.start.valueOf(),\n                        isEnd: normalRange.end && normalRange.end.valueOf() === slicedRange.end.valueOf()\n                    });\n                }\n            }\n        }\n        for(let groupId in inverseBgByGroupId){\n            let ranges = inverseBgByGroupId[groupId];\n            let invertedRanges = invertRanges(ranges, framingRange);\n            for (let invertedRange of invertedRanges){\n                let def = defByGroupId[groupId];\n                let ui = eventUis[def.defId];\n                bgRanges.push({\n                    def,\n                    ui,\n                    instance: null,\n                    range: invertedRange,\n                    isStart: false,\n                    isEnd: false\n                });\n            }\n        }\n        for(let defId in inverseBgByDefId){\n            let ranges = inverseBgByDefId[defId];\n            let invertedRanges = invertRanges(ranges, framingRange);\n            for (let invertedRange of invertedRanges){\n                bgRanges.push({\n                    def: eventStore.defs[defId],\n                    ui: eventUis[defId],\n                    instance: null,\n                    range: invertedRange,\n                    isStart: false,\n                    isEnd: false\n                });\n            }\n        }\n        return {\n            bg: bgRanges,\n            fg: fgRanges\n        };\n    }\n    function hasBgRendering(def) {\n        return def.ui.display === 'background' || def.ui.display === 'inverse-background';\n    }\n    function setElSeg(el, seg) {\n        el.fcSeg = seg;\n    }\n    function getElSeg(el) {\n        return el.fcSeg || el.parentNode.fcSeg || // for the harness\n        null;\n    }\n    // event ui computation\n    function compileEventUis(eventDefs, eventUiBases) {\n        return mapHash(eventDefs, (eventDef)=>compileEventUi(eventDef, eventUiBases));\n    }\n    function compileEventUi(eventDef, eventUiBases) {\n        let uis = [];\n        if (eventUiBases['']) {\n            uis.push(eventUiBases['']);\n        }\n        if (eventUiBases[eventDef.defId]) {\n            uis.push(eventUiBases[eventDef.defId]);\n        }\n        uis.push(eventDef.ui);\n        return combineEventUis(uis);\n    }\n    function sortEventSegs(segs, eventOrderSpecs) {\n        let objs = segs.map(buildSegCompareObj);\n        objs.sort((obj0, obj1)=>compareByFieldSpecs(obj0, obj1, eventOrderSpecs));\n        return objs.map((c)=>c._seg);\n    }\n    // returns a object with all primitive props that can be compared\n    function buildSegCompareObj(seg) {\n        let { eventRange } = seg;\n        let eventDef = eventRange.def;\n        let range = eventRange.instance ? eventRange.instance.range : eventRange.range;\n        let start = range.start ? range.start.valueOf() : 0; // TODO: better support for open-range events\n        let end = range.end ? range.end.valueOf() : 0; // \"\n        return Object.assign(Object.assign(Object.assign({}, eventDef.extendedProps), eventDef), {\n            id: eventDef.publicId,\n            start,\n            end,\n            duration: end - start,\n            allDay: Number(eventDef.allDay),\n            _seg: seg\n        });\n    }\n    function computeSegDraggable(seg, context) {\n        let { pluginHooks } = context;\n        let transformers = pluginHooks.isDraggableTransformers;\n        let { def, ui } = seg.eventRange;\n        let val = ui.startEditable;\n        for (let transformer of transformers){\n            val = transformer(val, def, ui, context);\n        }\n        return val;\n    }\n    function computeSegStartResizable(seg, context) {\n        return seg.isStart && seg.eventRange.ui.durationEditable && context.options.eventResizableFromStart;\n    }\n    function computeSegEndResizable(seg, context) {\n        return seg.isEnd && seg.eventRange.ui.durationEditable;\n    }\n    function buildSegTimeText(seg, timeFormat, context, defaultDisplayEventTime, defaultDisplayEventEnd, startOverride, endOverride) {\n        let { dateEnv, options } = context;\n        let { displayEventTime, displayEventEnd } = options;\n        let eventDef = seg.eventRange.def;\n        let eventInstance = seg.eventRange.instance;\n        if (displayEventTime == null) {\n            displayEventTime = defaultDisplayEventTime !== false;\n        }\n        if (displayEventEnd == null) {\n            displayEventEnd = defaultDisplayEventEnd !== false;\n        }\n        let wholeEventStart = eventInstance.range.start;\n        let wholeEventEnd = eventInstance.range.end;\n        let segStart = startOverride || seg.start || seg.eventRange.range.start;\n        let segEnd = endOverride || seg.end || seg.eventRange.range.end;\n        let isStartDay = startOfDay(wholeEventStart).valueOf() === startOfDay(segStart).valueOf();\n        let isEndDay = startOfDay(addMs(wholeEventEnd, -1)).valueOf() === startOfDay(addMs(segEnd, -1)).valueOf();\n        if (displayEventTime && !eventDef.allDay && (isStartDay || isEndDay)) {\n            segStart = isStartDay ? wholeEventStart : segStart;\n            segEnd = isEndDay ? wholeEventEnd : segEnd;\n            if (displayEventEnd && eventDef.hasEnd) {\n                return dateEnv.formatRange(segStart, segEnd, timeFormat, {\n                    forcedStartTzo: startOverride ? null : eventInstance.forcedStartTzo,\n                    forcedEndTzo: endOverride ? null : eventInstance.forcedEndTzo\n                });\n            }\n            return dateEnv.format(segStart, timeFormat, {\n                forcedTzo: startOverride ? null : eventInstance.forcedStartTzo\n            });\n        }\n        return '';\n    }\n    function getSegMeta(seg, todayRange, nowDate) {\n        let segRange = seg.eventRange.range;\n        return {\n            isPast: segRange.end < (nowDate || todayRange.start),\n            isFuture: segRange.start >= (nowDate || todayRange.end),\n            isToday: todayRange && rangeContainsMarker(todayRange, segRange.start)\n        };\n    }\n    function getEventClassNames(props) {\n        let classNames = [\n            'fc-event'\n        ];\n        if (props.isMirror) {\n            classNames.push('fc-event-mirror');\n        }\n        if (props.isDraggable) {\n            classNames.push('fc-event-draggable');\n        }\n        if (props.isStartResizable || props.isEndResizable) {\n            classNames.push('fc-event-resizable');\n        }\n        if (props.isDragging) {\n            classNames.push('fc-event-dragging');\n        }\n        if (props.isResizing) {\n            classNames.push('fc-event-resizing');\n        }\n        if (props.isSelected) {\n            classNames.push('fc-event-selected');\n        }\n        if (props.isStart) {\n            classNames.push('fc-event-start');\n        }\n        if (props.isEnd) {\n            classNames.push('fc-event-end');\n        }\n        if (props.isPast) {\n            classNames.push('fc-event-past');\n        }\n        if (props.isToday) {\n            classNames.push('fc-event-today');\n        }\n        if (props.isFuture) {\n            classNames.push('fc-event-future');\n        }\n        return classNames;\n    }\n    function buildEventRangeKey(eventRange) {\n        return eventRange.instance ? eventRange.instance.instanceId : `${eventRange.def.defId}:${eventRange.range.start.toISOString()}`;\n    // inverse-background events don't have specific instances. TODO: better solution\n    }\n    function getSegAnchorAttrs(seg, context) {\n        let { def, instance } = seg.eventRange;\n        let { url } = def;\n        if (url) {\n            return {\n                href: url\n            };\n        }\n        let { emitter, options } = context;\n        let { eventInteractive } = options;\n        if (eventInteractive == null) {\n            eventInteractive = def.interactive;\n            if (eventInteractive == null) {\n                eventInteractive = Boolean(emitter.hasHandlers('eventClick'));\n            }\n        }\n        // mock what happens in EventClicking\n        if (eventInteractive) {\n            // only attach keyboard-related handlers because click handler is already done in EventClicking\n            return createAriaKeyboardAttrs((ev)=>{\n                emitter.trigger('eventClick', {\n                    el: ev.target,\n                    event: new EventImpl(context, def, instance),\n                    jsEvent: ev,\n                    view: context.viewApi\n                });\n            });\n        }\n        return {};\n    }\n    const STANDARD_PROPS = {\n        start: identity,\n        end: identity,\n        allDay: Boolean\n    };\n    function parseDateSpan(raw, dateEnv, defaultDuration) {\n        let span = parseOpenDateSpan(raw, dateEnv);\n        let { range } = span;\n        if (!range.start) {\n            return null;\n        }\n        if (!range.end) {\n            if (defaultDuration == null) {\n                return null;\n            }\n            range.end = dateEnv.add(range.start, defaultDuration);\n        }\n        return span;\n    }\n    /*\r\n    TODO: somehow combine with parseRange?\r\n    Will return null if the start/end props were present but parsed invalidly.\r\n    */ function parseOpenDateSpan(raw, dateEnv) {\n        let { refined: standardProps, extra } = refineProps(raw, STANDARD_PROPS);\n        let startMeta = standardProps.start ? dateEnv.createMarkerMeta(standardProps.start) : null;\n        let endMeta = standardProps.end ? dateEnv.createMarkerMeta(standardProps.end) : null;\n        let { allDay } = standardProps;\n        if (allDay == null) {\n            allDay = startMeta && startMeta.isTimeUnspecified && (!endMeta || endMeta.isTimeUnspecified);\n        }\n        return Object.assign({\n            range: {\n                start: startMeta ? startMeta.marker : null,\n                end: endMeta ? endMeta.marker : null\n            },\n            allDay\n        }, extra);\n    }\n    function isDateSpansEqual(span0, span1) {\n        return rangesEqual(span0.range, span1.range) && span0.allDay === span1.allDay && isSpanPropsEqual(span0, span1);\n    }\n    // the NON-DATE-RELATED props\n    function isSpanPropsEqual(span0, span1) {\n        for(let propName in span1){\n            if (propName !== 'range' && propName !== 'allDay') {\n                if (span0[propName] !== span1[propName]) {\n                    return false;\n                }\n            }\n        }\n        // are there any props that span0 has that span1 DOESN'T have?\n        // both have range/allDay, so no need to special-case.\n        for(let propName in span0){\n            if (!(propName in span1)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    function buildDateSpanApi(span, dateEnv) {\n        return Object.assign(Object.assign({}, buildRangeApi(span.range, dateEnv, span.allDay)), {\n            allDay: span.allDay\n        });\n    }\n    function buildRangeApiWithTimeZone(range, dateEnv, omitTime) {\n        return Object.assign(Object.assign({}, buildRangeApi(range, dateEnv, omitTime)), {\n            timeZone: dateEnv.timeZone\n        });\n    }\n    function buildRangeApi(range, dateEnv, omitTime) {\n        return {\n            start: dateEnv.toDate(range.start),\n            end: dateEnv.toDate(range.end),\n            startStr: dateEnv.formatIso(range.start, {\n                omitTime\n            }),\n            endStr: dateEnv.formatIso(range.end, {\n                omitTime\n            })\n        };\n    }\n    function fabricateEventRange(dateSpan, eventUiBases, context) {\n        let res = refineEventDef({\n            editable: false\n        }, context);\n        let def = parseEventDef(res.refined, res.extra, '', dateSpan.allDay, true, context);\n        return {\n            def,\n            ui: compileEventUi(def, eventUiBases),\n            instance: createEventInstance(def.defId, dateSpan.range),\n            range: dateSpan.range,\n            isStart: true,\n            isEnd: true\n        };\n    }\n    let calendarSystemClassMap = {};\n    function registerCalendarSystem(name, theClass) {\n        calendarSystemClassMap[name] = theClass;\n    }\n    function createCalendarSystem(name) {\n        return new calendarSystemClassMap[name]();\n    }\n    class GregorianCalendarSystem {\n        getMarkerYear(d) {\n            return d.getUTCFullYear();\n        }\n        getMarkerMonth(d) {\n            return d.getUTCMonth();\n        }\n        getMarkerDay(d) {\n            return d.getUTCDate();\n        }\n        arrayToMarker(arr) {\n            return arrayToUtcDate(arr);\n        }\n        markerToArray(marker) {\n            return dateToUtcArray(marker);\n        }\n    }\n    registerCalendarSystem('gregory', GregorianCalendarSystem);\n    const ISO_RE = /^\\s*(\\d{4})(-?(\\d{2})(-?(\\d{2})([T ](\\d{2}):?(\\d{2})(:?(\\d{2})(\\.(\\d+))?)?(Z|(([-+])(\\d{2})(:?(\\d{2}))?))?)?)?)?$/;\n    function parse(str) {\n        let m = ISO_RE.exec(str);\n        if (m) {\n            let marker = new Date(Date.UTC(Number(m[1]), m[3] ? Number(m[3]) - 1 : 0, Number(m[5] || 1), Number(m[7] || 0), Number(m[8] || 0), Number(m[10] || 0), m[12] ? Number(`0.${m[12]}`) * 1000 : 0));\n            if (isValidDate(marker)) {\n                let timeZoneOffset = null;\n                if (m[13]) {\n                    timeZoneOffset = (m[15] === '-' ? -1 : 1) * (Number(m[16] || 0) * 60 + Number(m[18] || 0));\n                }\n                return {\n                    marker,\n                    isTimeUnspecified: !m[6],\n                    timeZoneOffset\n                };\n            }\n        }\n        return null;\n    }\n    class DateEnv {\n        constructor(settings){\n            let timeZone = this.timeZone = settings.timeZone;\n            let isNamedTimeZone = timeZone !== 'local' && timeZone !== 'UTC';\n            if (settings.namedTimeZoneImpl && isNamedTimeZone) {\n                this.namedTimeZoneImpl = new settings.namedTimeZoneImpl(timeZone);\n            }\n            this.canComputeOffset = Boolean(!isNamedTimeZone || this.namedTimeZoneImpl);\n            this.calendarSystem = createCalendarSystem(settings.calendarSystem);\n            this.locale = settings.locale;\n            this.weekDow = settings.locale.week.dow;\n            this.weekDoy = settings.locale.week.doy;\n            if (settings.weekNumberCalculation === 'ISO') {\n                this.weekDow = 1;\n                this.weekDoy = 4;\n            }\n            if (typeof settings.firstDay === 'number') {\n                this.weekDow = settings.firstDay;\n            }\n            if (typeof settings.weekNumberCalculation === 'function') {\n                this.weekNumberFunc = settings.weekNumberCalculation;\n            }\n            this.weekText = settings.weekText != null ? settings.weekText : settings.locale.options.weekText;\n            this.weekTextLong = (settings.weekTextLong != null ? settings.weekTextLong : settings.locale.options.weekTextLong) || this.weekText;\n            this.cmdFormatter = settings.cmdFormatter;\n            this.defaultSeparator = settings.defaultSeparator;\n        }\n        // Creating / Parsing\n        createMarker(input) {\n            let meta = this.createMarkerMeta(input);\n            if (meta === null) {\n                return null;\n            }\n            return meta.marker;\n        }\n        createNowMarker() {\n            if (this.canComputeOffset) {\n                return this.timestampToMarker(new Date().valueOf());\n            }\n            // if we can't compute the current date val for a timezone,\n            // better to give the current local date vals than UTC\n            return arrayToUtcDate(dateToLocalArray(new Date()));\n        }\n        createMarkerMeta(input) {\n            if (typeof input === 'string') {\n                return this.parse(input);\n            }\n            let marker = null;\n            if (typeof input === 'number') {\n                marker = this.timestampToMarker(input);\n            } else if (input instanceof Date) {\n                input = input.valueOf();\n                if (!isNaN(input)) {\n                    marker = this.timestampToMarker(input);\n                }\n            } else if (Array.isArray(input)) {\n                marker = arrayToUtcDate(input);\n            }\n            if (marker === null || !isValidDate(marker)) {\n                return null;\n            }\n            return {\n                marker,\n                isTimeUnspecified: false,\n                forcedTzo: null\n            };\n        }\n        parse(s) {\n            let parts = parse(s);\n            if (parts === null) {\n                return null;\n            }\n            let { marker } = parts;\n            let forcedTzo = null;\n            if (parts.timeZoneOffset !== null) {\n                if (this.canComputeOffset) {\n                    marker = this.timestampToMarker(marker.valueOf() - parts.timeZoneOffset * 60 * 1000);\n                } else {\n                    forcedTzo = parts.timeZoneOffset;\n                }\n            }\n            return {\n                marker,\n                isTimeUnspecified: parts.isTimeUnspecified,\n                forcedTzo\n            };\n        }\n        // Accessors\n        getYear(marker) {\n            return this.calendarSystem.getMarkerYear(marker);\n        }\n        getMonth(marker) {\n            return this.calendarSystem.getMarkerMonth(marker);\n        }\n        getDay(marker) {\n            return this.calendarSystem.getMarkerDay(marker);\n        }\n        // Adding / Subtracting\n        add(marker, dur) {\n            let a = this.calendarSystem.markerToArray(marker);\n            a[0] += dur.years;\n            a[1] += dur.months;\n            a[2] += dur.days;\n            a[6] += dur.milliseconds;\n            return this.calendarSystem.arrayToMarker(a);\n        }\n        subtract(marker, dur) {\n            let a = this.calendarSystem.markerToArray(marker);\n            a[0] -= dur.years;\n            a[1] -= dur.months;\n            a[2] -= dur.days;\n            a[6] -= dur.milliseconds;\n            return this.calendarSystem.arrayToMarker(a);\n        }\n        addYears(marker, n) {\n            let a = this.calendarSystem.markerToArray(marker);\n            a[0] += n;\n            return this.calendarSystem.arrayToMarker(a);\n        }\n        addMonths(marker, n) {\n            let a = this.calendarSystem.markerToArray(marker);\n            a[1] += n;\n            return this.calendarSystem.arrayToMarker(a);\n        }\n        // Diffing Whole Units\n        diffWholeYears(m0, m1) {\n            let { calendarSystem } = this;\n            if (timeAsMs(m0) === timeAsMs(m1) && calendarSystem.getMarkerDay(m0) === calendarSystem.getMarkerDay(m1) && calendarSystem.getMarkerMonth(m0) === calendarSystem.getMarkerMonth(m1)) {\n                return calendarSystem.getMarkerYear(m1) - calendarSystem.getMarkerYear(m0);\n            }\n            return null;\n        }\n        diffWholeMonths(m0, m1) {\n            let { calendarSystem } = this;\n            if (timeAsMs(m0) === timeAsMs(m1) && calendarSystem.getMarkerDay(m0) === calendarSystem.getMarkerDay(m1)) {\n                return calendarSystem.getMarkerMonth(m1) - calendarSystem.getMarkerMonth(m0) + (calendarSystem.getMarkerYear(m1) - calendarSystem.getMarkerYear(m0)) * 12;\n            }\n            return null;\n        }\n        // Range / Duration\n        greatestWholeUnit(m0, m1) {\n            let n = this.diffWholeYears(m0, m1);\n            if (n !== null) {\n                return {\n                    unit: 'year',\n                    value: n\n                };\n            }\n            n = this.diffWholeMonths(m0, m1);\n            if (n !== null) {\n                return {\n                    unit: 'month',\n                    value: n\n                };\n            }\n            n = diffWholeWeeks(m0, m1);\n            if (n !== null) {\n                return {\n                    unit: 'week',\n                    value: n\n                };\n            }\n            n = diffWholeDays(m0, m1);\n            if (n !== null) {\n                return {\n                    unit: 'day',\n                    value: n\n                };\n            }\n            n = diffHours(m0, m1);\n            if (isInt(n)) {\n                return {\n                    unit: 'hour',\n                    value: n\n                };\n            }\n            n = diffMinutes(m0, m1);\n            if (isInt(n)) {\n                return {\n                    unit: 'minute',\n                    value: n\n                };\n            }\n            n = diffSeconds(m0, m1);\n            if (isInt(n)) {\n                return {\n                    unit: 'second',\n                    value: n\n                };\n            }\n            return {\n                unit: 'millisecond',\n                value: m1.valueOf() - m0.valueOf()\n            };\n        }\n        countDurationsBetween(m0, m1, d) {\n            // TODO: can use greatestWholeUnit\n            let diff;\n            if (d.years) {\n                diff = this.diffWholeYears(m0, m1);\n                if (diff !== null) {\n                    return diff / asRoughYears(d);\n                }\n            }\n            if (d.months) {\n                diff = this.diffWholeMonths(m0, m1);\n                if (diff !== null) {\n                    return diff / asRoughMonths(d);\n                }\n            }\n            if (d.days) {\n                diff = diffWholeDays(m0, m1);\n                if (diff !== null) {\n                    return diff / asRoughDays(d);\n                }\n            }\n            return (m1.valueOf() - m0.valueOf()) / asRoughMs(d);\n        }\n        // Start-Of\n        // these DON'T return zoned-dates. only UTC start-of dates\n        startOf(m, unit) {\n            if (unit === 'year') {\n                return this.startOfYear(m);\n            }\n            if (unit === 'month') {\n                return this.startOfMonth(m);\n            }\n            if (unit === 'week') {\n                return this.startOfWeek(m);\n            }\n            if (unit === 'day') {\n                return startOfDay(m);\n            }\n            if (unit === 'hour') {\n                return startOfHour(m);\n            }\n            if (unit === 'minute') {\n                return startOfMinute(m);\n            }\n            if (unit === 'second') {\n                return startOfSecond(m);\n            }\n            return null;\n        }\n        startOfYear(m) {\n            return this.calendarSystem.arrayToMarker([\n                this.calendarSystem.getMarkerYear(m)\n            ]);\n        }\n        startOfMonth(m) {\n            return this.calendarSystem.arrayToMarker([\n                this.calendarSystem.getMarkerYear(m),\n                this.calendarSystem.getMarkerMonth(m)\n            ]);\n        }\n        startOfWeek(m) {\n            return this.calendarSystem.arrayToMarker([\n                this.calendarSystem.getMarkerYear(m),\n                this.calendarSystem.getMarkerMonth(m),\n                m.getUTCDate() - (m.getUTCDay() - this.weekDow + 7) % 7\n            ]);\n        }\n        // Week Number\n        computeWeekNumber(marker) {\n            if (this.weekNumberFunc) {\n                return this.weekNumberFunc(this.toDate(marker));\n            }\n            return weekOfYear(marker, this.weekDow, this.weekDoy);\n        }\n        // TODO: choke on timeZoneName: long\n        format(marker, formatter, dateOptions = {}) {\n            return formatter.format({\n                marker,\n                timeZoneOffset: dateOptions.forcedTzo != null ? dateOptions.forcedTzo : this.offsetForMarker(marker)\n            }, this);\n        }\n        formatRange(start, end, formatter, dateOptions = {}) {\n            if (dateOptions.isEndExclusive) {\n                end = addMs(end, -1);\n            }\n            return formatter.formatRange({\n                marker: start,\n                timeZoneOffset: dateOptions.forcedStartTzo != null ? dateOptions.forcedStartTzo : this.offsetForMarker(start)\n            }, {\n                marker: end,\n                timeZoneOffset: dateOptions.forcedEndTzo != null ? dateOptions.forcedEndTzo : this.offsetForMarker(end)\n            }, this, dateOptions.defaultSeparator);\n        }\n        /*\r\n        DUMB: the omitTime arg is dumb. if we omit the time, we want to omit the timezone offset. and if we do that,\r\n        might as well use buildIsoString or some other util directly\r\n        */ formatIso(marker, extraOptions = {}) {\n            let timeZoneOffset = null;\n            if (!extraOptions.omitTimeZoneOffset) {\n                if (extraOptions.forcedTzo != null) {\n                    timeZoneOffset = extraOptions.forcedTzo;\n                } else {\n                    timeZoneOffset = this.offsetForMarker(marker);\n                }\n            }\n            return buildIsoString(marker, timeZoneOffset, extraOptions.omitTime);\n        }\n        // TimeZone\n        timestampToMarker(ms) {\n            if (this.timeZone === 'local') {\n                return arrayToUtcDate(dateToLocalArray(new Date(ms)));\n            }\n            if (this.timeZone === 'UTC' || !this.namedTimeZoneImpl) {\n                return new Date(ms);\n            }\n            return arrayToUtcDate(this.namedTimeZoneImpl.timestampToArray(ms));\n        }\n        offsetForMarker(m) {\n            if (this.timeZone === 'local') {\n                return -arrayToLocalDate(dateToUtcArray(m)).getTimezoneOffset(); // convert \"inverse\" offset to \"normal\" offset\n            }\n            if (this.timeZone === 'UTC') {\n                return 0;\n            }\n            if (this.namedTimeZoneImpl) {\n                return this.namedTimeZoneImpl.offsetForArray(dateToUtcArray(m));\n            }\n            return null;\n        }\n        // Conversion\n        toDate(m, forcedTzo) {\n            if (this.timeZone === 'local') {\n                return arrayToLocalDate(dateToUtcArray(m));\n            }\n            if (this.timeZone === 'UTC') {\n                return new Date(m.valueOf()); // make sure it's a copy\n            }\n            if (!this.namedTimeZoneImpl) {\n                return new Date(m.valueOf() - (forcedTzo || 0));\n            }\n            return new Date(m.valueOf() - this.namedTimeZoneImpl.offsetForArray(dateToUtcArray(m)) * 1000 * 60);\n        }\n    }\n    class NamedTimeZoneImpl {\n        constructor(timeZoneName){\n            this.timeZoneName = timeZoneName;\n        }\n    }\n    class SegHierarchy {\n        constructor(){\n            // settings\n            this.strictOrder = false;\n            this.allowReslicing = false;\n            this.maxCoord = -1; // -1 means no max\n            this.maxStackCnt = -1; // -1 means no max\n            this.levelCoords = []; // ordered\n            this.entriesByLevel = []; // parallel with levelCoords\n            this.stackCnts = {}; // TODO: use better technique!?\n        }\n        addSegs(inputs) {\n            let hiddenEntries = [];\n            for (let input of inputs){\n                this.insertEntry(input, hiddenEntries);\n            }\n            return hiddenEntries;\n        }\n        insertEntry(entry, hiddenEntries) {\n            let insertion = this.findInsertion(entry);\n            if (this.isInsertionValid(insertion, entry)) {\n                this.insertEntryAt(entry, insertion);\n                return 1;\n            }\n            return this.handleInvalidInsertion(insertion, entry, hiddenEntries);\n        }\n        isInsertionValid(insertion, entry) {\n            return (this.maxCoord === -1 || insertion.levelCoord + entry.thickness <= this.maxCoord) && (this.maxStackCnt === -1 || insertion.stackCnt < this.maxStackCnt);\n        }\n        // returns number of new entries inserted\n        handleInvalidInsertion(insertion, entry, hiddenEntries) {\n            if (this.allowReslicing && insertion.touchingEntry) {\n                return this.splitEntry(entry, insertion.touchingEntry, hiddenEntries);\n            }\n            hiddenEntries.push(entry);\n            return 0;\n        }\n        splitEntry(entry, barrier, hiddenEntries) {\n            let partCnt = 0;\n            let splitHiddenEntries = [];\n            let entrySpan = entry.span;\n            let barrierSpan = barrier.span;\n            if (entrySpan.start < barrierSpan.start) {\n                partCnt += this.insertEntry({\n                    index: entry.index,\n                    thickness: entry.thickness,\n                    span: {\n                        start: entrySpan.start,\n                        end: barrierSpan.start\n                    }\n                }, splitHiddenEntries);\n            }\n            if (entrySpan.end > barrierSpan.end) {\n                partCnt += this.insertEntry({\n                    index: entry.index,\n                    thickness: entry.thickness,\n                    span: {\n                        start: barrierSpan.end,\n                        end: entrySpan.end\n                    }\n                }, splitHiddenEntries);\n            }\n            if (partCnt) {\n                hiddenEntries.push({\n                    index: entry.index,\n                    thickness: entry.thickness,\n                    span: intersectSpans(barrierSpan, entrySpan)\n                }, ...splitHiddenEntries);\n                return partCnt;\n            }\n            hiddenEntries.push(entry);\n            return 0;\n        }\n        insertEntryAt(entry, insertion) {\n            let { entriesByLevel, levelCoords } = this;\n            if (insertion.lateral === -1) {\n                // create a new level\n                insertAt(levelCoords, insertion.level, insertion.levelCoord);\n                insertAt(entriesByLevel, insertion.level, [\n                    entry\n                ]);\n            } else {\n                // insert into existing level\n                insertAt(entriesByLevel[insertion.level], insertion.lateral, entry);\n            }\n            this.stackCnts[buildEntryKey(entry)] = insertion.stackCnt;\n        }\n        findInsertion(newEntry) {\n            let { levelCoords, entriesByLevel, strictOrder, stackCnts } = this;\n            let levelCnt = levelCoords.length;\n            let candidateCoord = 0;\n            let touchingLevel = -1;\n            let touchingLateral = -1;\n            let touchingEntry = null;\n            let stackCnt = 0;\n            for(let trackingLevel = 0; trackingLevel < levelCnt; trackingLevel += 1){\n                let trackingCoord = levelCoords[trackingLevel];\n                // if the current level is past the placed entry, we have found a good empty space and can stop.\n                // if strictOrder, keep finding more lateral intersections.\n                if (!strictOrder && trackingCoord >= candidateCoord + newEntry.thickness) {\n                    break;\n                }\n                let trackingEntries = entriesByLevel[trackingLevel];\n                let trackingEntry;\n                let searchRes = binarySearch(trackingEntries, newEntry.span.start, getEntrySpanEnd); // find first entry after newEntry's end\n                let lateralIndex = searchRes[0] + searchRes[1]; // if exact match (which doesn't collide), go to next one\n                while((trackingEntry = trackingEntries[lateralIndex]) && // but not past the whole entry list\n                trackingEntry.span.start < newEntry.span.end // and not entirely past newEntry\n                ){\n                    let trackingEntryBottom = trackingCoord + trackingEntry.thickness;\n                    // intersects into the top of the candidate?\n                    if (trackingEntryBottom > candidateCoord) {\n                        candidateCoord = trackingEntryBottom;\n                        touchingEntry = trackingEntry;\n                        touchingLevel = trackingLevel;\n                        touchingLateral = lateralIndex;\n                    }\n                    // butts up against top of candidate? (will happen if just intersected as well)\n                    if (trackingEntryBottom === candidateCoord) {\n                        // accumulate the highest possible stackCnt of the trackingEntries that butt up\n                        stackCnt = Math.max(stackCnt, stackCnts[buildEntryKey(trackingEntry)] + 1);\n                    }\n                    lateralIndex += 1;\n                }\n            }\n            // the destination level will be after touchingEntry's level. find it\n            let destLevel = 0;\n            if (touchingEntry) {\n                destLevel = touchingLevel + 1;\n                while(destLevel < levelCnt && levelCoords[destLevel] < candidateCoord){\n                    destLevel += 1;\n                }\n            }\n            // if adding to an existing level, find where to insert\n            let destLateral = -1;\n            if (destLevel < levelCnt && levelCoords[destLevel] === candidateCoord) {\n                destLateral = binarySearch(entriesByLevel[destLevel], newEntry.span.end, getEntrySpanEnd)[0];\n            }\n            return {\n                touchingLevel,\n                touchingLateral,\n                touchingEntry,\n                stackCnt,\n                levelCoord: candidateCoord,\n                level: destLevel,\n                lateral: destLateral\n            };\n        }\n        // sorted by levelCoord (lowest to highest)\n        toRects() {\n            let { entriesByLevel, levelCoords } = this;\n            let levelCnt = entriesByLevel.length;\n            let rects = [];\n            for(let level = 0; level < levelCnt; level += 1){\n                let entries = entriesByLevel[level];\n                let levelCoord = levelCoords[level];\n                for (let entry of entries){\n                    rects.push(Object.assign(Object.assign({}, entry), {\n                        levelCoord\n                    }));\n                }\n            }\n            return rects;\n        }\n    }\n    function getEntrySpanEnd(entry) {\n        return entry.span.end;\n    }\n    function buildEntryKey(entry) {\n        return entry.index + ':' + entry.span.start;\n    }\n    // returns groups with entries sorted by input order\n    function groupIntersectingEntries(entries) {\n        let merges = [];\n        for (let entry of entries){\n            let filteredMerges = [];\n            let hungryMerge = {\n                span: entry.span,\n                entries: [\n                    entry\n                ]\n            };\n            for (let merge of merges){\n                if (intersectSpans(merge.span, hungryMerge.span)) {\n                    hungryMerge = {\n                        entries: merge.entries.concat(hungryMerge.entries),\n                        span: joinSpans(merge.span, hungryMerge.span)\n                    };\n                } else {\n                    filteredMerges.push(merge);\n                }\n            }\n            filteredMerges.push(hungryMerge);\n            merges = filteredMerges;\n        }\n        return merges;\n    }\n    function joinSpans(span0, span1) {\n        return {\n            start: Math.min(span0.start, span1.start),\n            end: Math.max(span0.end, span1.end)\n        };\n    }\n    function intersectSpans(span0, span1) {\n        let start = Math.max(span0.start, span1.start);\n        let end = Math.min(span0.end, span1.end);\n        if (start < end) {\n            return {\n                start,\n                end\n            };\n        }\n        return null;\n    }\n    // general util\n    // ---------------------------------------------------------------------------------------------------------------------\n    function insertAt(arr, index, item) {\n        arr.splice(index, 0, item);\n    }\n    function binarySearch(a, searchVal, getItemVal) {\n        let startIndex = 0;\n        let endIndex = a.length; // exclusive\n        if (!endIndex || searchVal < getItemVal(a[startIndex])) {\n            return [\n                0,\n                0\n            ];\n        }\n        if (searchVal > getItemVal(a[endIndex - 1])) {\n            return [\n                endIndex,\n                0\n            ];\n        }\n        while(startIndex < endIndex){\n            let middleIndex = Math.floor(startIndex + (endIndex - startIndex) / 2);\n            let middleVal = getItemVal(a[middleIndex]);\n            if (searchVal < middleVal) {\n                endIndex = middleIndex;\n            } else if (searchVal > middleVal) {\n                startIndex = middleIndex + 1;\n            } else {\n                return [\n                    middleIndex,\n                    1\n                ];\n            }\n        }\n        return [\n            startIndex,\n            0\n        ];\n    }\n    class Interaction {\n        constructor(settings){\n            this.component = settings.component;\n            this.isHitComboAllowed = settings.isHitComboAllowed || null;\n        }\n        destroy() {}\n    }\n    function parseInteractionSettings(component, input) {\n        return {\n            component,\n            el: input.el,\n            useEventCenter: input.useEventCenter != null ? input.useEventCenter : true,\n            isHitComboAllowed: input.isHitComboAllowed || null\n        };\n    }\n    function interactionSettingsToStore(settings) {\n        return {\n            [settings.component.uid]: settings\n        };\n    }\n    // global state\n    const interactionSettingsStore = {};\n    /*\r\n    An abstraction for a dragging interaction originating on an event.\r\n    Does higher-level things than PointerDragger, such as possibly:\r\n    - a \"mirror\" that moves with the pointer\r\n    - a minimum number of pixels or other criteria for a true drag to begin\r\n\r\n    subclasses must emit:\r\n    - pointerdown\r\n    - dragstart\r\n    - dragmove\r\n    - pointerup\r\n    - dragend\r\n    */ class ElementDragging {\n        constructor(el, selector){\n            this.emitter = new Emitter();\n        }\n        destroy() {}\n        setMirrorIsVisible(bool) {\n        // optional if subclass doesn't want to support a mirror\n        }\n        setMirrorNeedsRevert(bool) {\n        // optional if subclass doesn't want to support a mirror\n        }\n        setAutoScrollEnabled(bool) {\n        // optional\n        }\n    }\n    // TODO: get rid of this in favor of options system,\n    // tho it's really easy to access this globally rather than pass thru options.\n    const config = {};\n    /*\r\n    Information about what will happen when an external element is dragged-and-dropped\r\n    onto a calendar. Contains information for creating an event.\r\n    */ const DRAG_META_REFINERS = {\n        startTime: createDuration,\n        duration: createDuration,\n        create: Boolean,\n        sourceId: String\n    };\n    function parseDragMeta(raw) {\n        let { refined, extra } = refineProps(raw, DRAG_META_REFINERS);\n        return {\n            startTime: refined.startTime || null,\n            duration: refined.duration || null,\n            create: refined.create != null ? refined.create : true,\n            sourceId: refined.sourceId,\n            leftoverProps: extra\n        };\n    }\n    class CalendarRoot extends BaseComponent {\n        constructor(){\n            super(...arguments);\n            this.state = {\n                forPrint: false\n            };\n            this.handleBeforePrint = ()=>{\n                this.setState({\n                    forPrint: true\n                });\n            };\n            this.handleAfterPrint = ()=>{\n                this.setState({\n                    forPrint: false\n                });\n            };\n        }\n        render() {\n            let { props } = this;\n            let { options } = props;\n            let { forPrint } = this.state;\n            let isHeightAuto = forPrint || options.height === 'auto' || options.contentHeight === 'auto';\n            let height = !isHeightAuto && options.height != null ? options.height : '';\n            let classNames = [\n                'fc',\n                forPrint ? 'fc-media-print' : 'fc-media-screen',\n                `fc-direction-${options.direction}`,\n                props.theme.getClass('root')\n            ];\n            if (!getCanVGrowWithinCell()) {\n                classNames.push('fc-liquid-hack');\n            }\n            return props.children(classNames, height, isHeightAuto, forPrint);\n        }\n        componentDidMount() {\n            let { emitter } = this.props;\n            emitter.on('_beforeprint', this.handleBeforePrint);\n            emitter.on('_afterprint', this.handleAfterPrint);\n        }\n        componentWillUnmount() {\n            let { emitter } = this.props;\n            emitter.off('_beforeprint', this.handleBeforePrint);\n            emitter.off('_afterprint', this.handleAfterPrint);\n        }\n    }\n    // Computes a default column header formatting string if `colFormat` is not explicitly defined\n    function computeFallbackHeaderFormat(datesRepDistinctDays, dayCnt) {\n        // if more than one week row, or if there are a lot of columns with not much space,\n        // put just the day numbers will be in each cell\n        if (!datesRepDistinctDays || dayCnt > 10) {\n            return createFormatter({\n                weekday: 'short'\n            }); // \"Sat\"\n        }\n        if (dayCnt > 1) {\n            return createFormatter({\n                weekday: 'short',\n                month: 'numeric',\n                day: 'numeric',\n                omitCommas: true\n            }); // \"Sat 11/12\"\n        }\n        return createFormatter({\n            weekday: 'long'\n        }); // \"Saturday\"\n    }\n    const CLASS_NAME = 'fc-col-header-cell'; // do the cushion too? no\n    function renderInner$1(renderProps) {\n        return renderProps.text;\n    }\n    class ContentInjector extends BaseComponent {\n        constructor(){\n            super(...arguments);\n            this.id = guid();\n            this.queuedDomNodes = [];\n            this.currentDomNodes = [];\n            this.handleEl = (el)=>{\n                if (this.props.elRef) {\n                    setRef(this.props.elRef, el);\n                }\n            };\n        }\n        render() {\n            const { props, context } = this;\n            const { options } = context;\n            const { customGenerator, defaultGenerator, renderProps } = props;\n            const attrs = buildElAttrs(props);\n            let useDefault = false;\n            let innerContent;\n            let queuedDomNodes = [];\n            let currentGeneratorMeta;\n            if (customGenerator != null) {\n                const customGeneratorRes = typeof customGenerator === 'function' ? customGenerator(renderProps, y) : customGenerator;\n                if (customGeneratorRes === true) {\n                    useDefault = true;\n                } else {\n                    const isObject = customGeneratorRes && typeof customGeneratorRes === 'object'; // non-null\n                    if (isObject && 'html' in customGeneratorRes) {\n                        attrs.dangerouslySetInnerHTML = {\n                            __html: customGeneratorRes.html\n                        };\n                    } else if (isObject && 'domNodes' in customGeneratorRes) {\n                        queuedDomNodes = Array.prototype.slice.call(customGeneratorRes.domNodes);\n                    } else if (!isObject && typeof customGeneratorRes !== 'function') {\n                        // primitive value (like string or number)\n                        innerContent = customGeneratorRes;\n                    } else {\n                        // an exotic object for handleCustomRendering\n                        currentGeneratorMeta = customGeneratorRes;\n                    }\n                }\n            } else {\n                useDefault = !hasCustomRenderingHandler(props.generatorName, options);\n            }\n            if (useDefault && defaultGenerator) {\n                innerContent = defaultGenerator(renderProps);\n            }\n            this.queuedDomNodes = queuedDomNodes;\n            this.currentGeneratorMeta = currentGeneratorMeta;\n            return y(props.elTag, attrs, innerContent);\n        }\n        componentDidMount() {\n            this.applyQueueudDomNodes();\n            this.triggerCustomRendering(true);\n        }\n        componentDidUpdate() {\n            this.applyQueueudDomNodes();\n            this.triggerCustomRendering(true);\n        }\n        componentWillUnmount() {\n            this.triggerCustomRendering(false); // TODO: different API for removal?\n        }\n        triggerCustomRendering(isActive) {\n            var _a;\n            const { props, context } = this;\n            const { handleCustomRendering, customRenderingMetaMap } = context.options;\n            if (handleCustomRendering) {\n                const generatorMeta = (_a = this.currentGeneratorMeta) !== null && _a !== void 0 ? _a : customRenderingMetaMap === null || customRenderingMetaMap === void 0 ? void 0 : customRenderingMetaMap[props.generatorName];\n                if (generatorMeta) {\n                    handleCustomRendering(Object.assign(Object.assign({\n                        id: this.id,\n                        isActive,\n                        containerEl: this.base,\n                        reportNewContainerEl: this.handleEl,\n                        generatorMeta\n                    }, props), {\n                        elClasses: (props.elClasses || []).filter(isTruthy)\n                    }));\n                }\n            }\n        }\n        applyQueueudDomNodes() {\n            const { queuedDomNodes, currentDomNodes } = this;\n            const el = this.base;\n            if (!isArraysEqual(queuedDomNodes, currentDomNodes)) {\n                currentDomNodes.forEach(removeElement);\n                for (let newNode of queuedDomNodes){\n                    el.appendChild(newNode);\n                }\n                this.currentDomNodes = queuedDomNodes;\n            }\n        }\n    }\n    ContentInjector.addPropsEquality({\n        elClasses: isArraysEqual,\n        elStyle: isPropsEqual,\n        elAttrs: isNonHandlerPropsEqual,\n        renderProps: isPropsEqual\n    });\n    // Util\n    /*\r\n    Does UI-framework provide custom way of rendering?\r\n    */ function hasCustomRenderingHandler(generatorName, options) {\n        var _a;\n        return Boolean(options.handleCustomRendering && generatorName && ((_a = options.customRenderingMetaMap) === null || _a === void 0 ? void 0 : _a[generatorName]));\n    }\n    function buildElAttrs(props, extraClassNames) {\n        const attrs = Object.assign(Object.assign({}, props.elAttrs), {\n            ref: props.elRef\n        });\n        if (props.elClasses || extraClassNames) {\n            attrs.className = (props.elClasses || []).concat(extraClassNames || []).concat(attrs.className || []).filter(Boolean).join(' ');\n        }\n        if (props.elStyle) {\n            attrs.style = props.elStyle;\n        }\n        return attrs;\n    }\n    function isTruthy(val) {\n        return Boolean(val);\n    }\n    const RenderId = createContext(0);\n    class ContentContainer extends x$1 {\n        constructor(){\n            super(...arguments);\n            this.InnerContent = InnerContentInjector.bind(undefined, this);\n            this.handleRootEl = (el)=>{\n                this.rootEl = el;\n                if (this.props.elRef) {\n                    setRef(this.props.elRef, el);\n                }\n            };\n        }\n        render() {\n            const { props } = this;\n            const generatedClassNames = generateClassNames(props.classNameGenerator, props.renderProps);\n            if (props.children) {\n                const elAttrs = buildElAttrs(props, generatedClassNames);\n                const children = props.children(this.InnerContent, props.renderProps, elAttrs);\n                if (props.elTag) {\n                    return y(props.elTag, elAttrs, children);\n                } else {\n                    return children;\n                }\n            } else {\n                return y(ContentInjector, Object.assign(Object.assign({}, props), {\n                    elRef: this.handleRootEl,\n                    elTag: props.elTag || 'div',\n                    elClasses: (props.elClasses || []).concat(generatedClassNames),\n                    renderId: this.context\n                }));\n            }\n        }\n        componentDidMount() {\n            var _a, _b;\n            (_b = (_a = this.props).didMount) === null || _b === void 0 ? void 0 : _b.call(_a, Object.assign(Object.assign({}, this.props.renderProps), {\n                el: this.rootEl || this.base\n            }));\n        }\n        componentWillUnmount() {\n            var _a, _b;\n            (_b = (_a = this.props).willUnmount) === null || _b === void 0 ? void 0 : _b.call(_a, Object.assign(Object.assign({}, this.props.renderProps), {\n                el: this.rootEl || this.base\n            }));\n        }\n    }\n    ContentContainer.contextType = RenderId;\n    function InnerContentInjector(containerComponent, props) {\n        const parentProps = containerComponent.props;\n        return y(ContentInjector, Object.assign({\n            renderProps: parentProps.renderProps,\n            generatorName: parentProps.generatorName,\n            customGenerator: parentProps.customGenerator,\n            defaultGenerator: parentProps.defaultGenerator,\n            renderId: containerComponent.context\n        }, props));\n    }\n    // Utils\n    function generateClassNames(classNameGenerator, renderProps) {\n        const classNames = typeof classNameGenerator === 'function' ? classNameGenerator(renderProps) : classNameGenerator || [];\n        return typeof classNames === 'string' ? [\n            classNames\n        ] : classNames;\n    }\n    // BAD name for this class now. used in the Header\n    class TableDateCell extends BaseComponent {\n        render() {\n            let { dateEnv, options, theme, viewApi } = this.context;\n            let { props } = this;\n            let { date, dateProfile } = props;\n            let dayMeta = getDateMeta(date, props.todayRange, null, dateProfile);\n            let classNames = [\n                CLASS_NAME\n            ].concat(getDayClassNames(dayMeta, theme));\n            let text = dateEnv.format(date, props.dayHeaderFormat);\n            // if colCnt is 1, we are already in a day-view and don't need a navlink\n            let navLinkAttrs = !dayMeta.isDisabled && props.colCnt > 1 ? buildNavLinkAttrs(this.context, date) : {};\n            let renderProps = Object.assign(Object.assign(Object.assign({\n                date: dateEnv.toDate(date),\n                view: viewApi\n            }, props.extraRenderProps), {\n                text\n            }), dayMeta);\n            return y(ContentContainer, {\n                elTag: \"th\",\n                elClasses: classNames,\n                elAttrs: Object.assign({\n                    role: 'columnheader',\n                    colSpan: props.colSpan,\n                    'data-date': !dayMeta.isDisabled ? formatDayString(date) : undefined\n                }, props.extraDataAttrs),\n                renderProps: renderProps,\n                generatorName: \"dayHeaderContent\",\n                customGenerator: options.dayHeaderContent,\n                defaultGenerator: renderInner$1,\n                classNameGenerator: options.dayHeaderClassNames,\n                didMount: options.dayHeaderDidMount,\n                willUnmount: options.dayHeaderWillUnmount\n            }, (InnerContainer)=>y(\"div\", {\n                    className: \"fc-scrollgrid-sync-inner\"\n                }, !dayMeta.isDisabled && y(InnerContainer, {\n                    elTag: \"a\",\n                    elAttrs: navLinkAttrs,\n                    elClasses: [\n                        'fc-col-header-cell-cushion',\n                        props.isSticky && 'fc-sticky'\n                    ]\n                })));\n        }\n    }\n    const WEEKDAY_FORMAT = createFormatter({\n        weekday: 'long'\n    });\n    class TableDowCell extends BaseComponent {\n        render() {\n            let { props } = this;\n            let { dateEnv, theme, viewApi, options } = this.context;\n            let date = addDays(new Date(259200000), props.dow); // start with Sun, 04 Jan 1970 00:00:00 GMT\n            let dateMeta = {\n                dow: props.dow,\n                isDisabled: false,\n                isFuture: false,\n                isPast: false,\n                isToday: false,\n                isOther: false\n            };\n            let text = dateEnv.format(date, props.dayHeaderFormat);\n            let renderProps = Object.assign(Object.assign(Object.assign(Object.assign({\n                date\n            }, dateMeta), {\n                view: viewApi\n            }), props.extraRenderProps), {\n                text\n            });\n            return y(ContentContainer, {\n                elTag: \"th\",\n                elClasses: [\n                    CLASS_NAME,\n                    ...getDayClassNames(dateMeta, theme),\n                    ...props.extraClassNames || []\n                ],\n                elAttrs: Object.assign({\n                    role: 'columnheader',\n                    colSpan: props.colSpan\n                }, props.extraDataAttrs),\n                renderProps: renderProps,\n                generatorName: \"dayHeaderContent\",\n                customGenerator: options.dayHeaderContent,\n                defaultGenerator: renderInner$1,\n                classNameGenerator: options.dayHeaderClassNames,\n                didMount: options.dayHeaderDidMount,\n                willUnmount: options.dayHeaderWillUnmount\n            }, (InnerContent)=>y(\"div\", {\n                    className: \"fc-scrollgrid-sync-inner\"\n                }, y(InnerContent, {\n                    elTag: \"a\",\n                    elClasses: [\n                        'fc-col-header-cell-cushion',\n                        props.isSticky && 'fc-sticky'\n                    ],\n                    elAttrs: {\n                        'aria-label': dateEnv.format(date, WEEKDAY_FORMAT)\n                    }\n                })));\n        }\n    }\n    class NowTimer extends x$1 {\n        constructor(props, context){\n            super(props, context);\n            this.initialNowDate = getNow(context.options.now, context.dateEnv);\n            this.initialNowQueriedMs = new Date().valueOf();\n            this.state = this.computeTiming().currentState;\n        }\n        render() {\n            let { props, state } = this;\n            return props.children(state.nowDate, state.todayRange);\n        }\n        componentDidMount() {\n            this.setTimeout();\n        }\n        componentDidUpdate(prevProps) {\n            if (prevProps.unit !== this.props.unit) {\n                this.clearTimeout();\n                this.setTimeout();\n            }\n        }\n        componentWillUnmount() {\n            this.clearTimeout();\n        }\n        computeTiming() {\n            let { props, context } = this;\n            let unroundedNow = addMs(this.initialNowDate, new Date().valueOf() - this.initialNowQueriedMs);\n            let currentUnitStart = context.dateEnv.startOf(unroundedNow, props.unit);\n            let nextUnitStart = context.dateEnv.add(currentUnitStart, createDuration(1, props.unit));\n            let waitMs = nextUnitStart.valueOf() - unroundedNow.valueOf();\n            // there is a max setTimeout ms value (https://stackoverflow.com/a/3468650/96342)\n            // ensure no longer than a day\n            waitMs = Math.min(1000 * 60 * 60 * 24, waitMs);\n            return {\n                currentState: {\n                    nowDate: currentUnitStart,\n                    todayRange: buildDayRange(currentUnitStart)\n                },\n                nextState: {\n                    nowDate: nextUnitStart,\n                    todayRange: buildDayRange(nextUnitStart)\n                },\n                waitMs\n            };\n        }\n        setTimeout() {\n            let { nextState, waitMs } = this.computeTiming();\n            this.timeoutId = setTimeout(()=>{\n                this.setState(nextState, ()=>{\n                    this.setTimeout();\n                });\n            }, waitMs);\n        }\n        clearTimeout() {\n            if (this.timeoutId) {\n                clearTimeout(this.timeoutId);\n            }\n        }\n    }\n    NowTimer.contextType = ViewContextType;\n    function buildDayRange(date) {\n        let start = startOfDay(date);\n        let end = addDays(start, 1);\n        return {\n            start,\n            end\n        };\n    }\n    class DayHeader extends BaseComponent {\n        constructor(){\n            super(...arguments);\n            this.createDayHeaderFormatter = memoize(createDayHeaderFormatter);\n        }\n        render() {\n            let { context } = this;\n            let { dates, dateProfile, datesRepDistinctDays, renderIntro } = this.props;\n            let dayHeaderFormat = this.createDayHeaderFormatter(context.options.dayHeaderFormat, datesRepDistinctDays, dates.length);\n            return y(NowTimer, {\n                unit: \"day\"\n            }, (nowDate, todayRange)=>y(\"tr\", {\n                    role: \"row\"\n                }, renderIntro && renderIntro('day'), dates.map((date)=>datesRepDistinctDays ? y(TableDateCell, {\n                        key: date.toISOString(),\n                        date: date,\n                        dateProfile: dateProfile,\n                        todayRange: todayRange,\n                        colCnt: dates.length,\n                        dayHeaderFormat: dayHeaderFormat\n                    }) : y(TableDowCell, {\n                        key: date.getUTCDay(),\n                        dow: date.getUTCDay(),\n                        dayHeaderFormat: dayHeaderFormat\n                    }))));\n        }\n    }\n    function createDayHeaderFormatter(explicitFormat, datesRepDistinctDays, dateCnt) {\n        return explicitFormat || computeFallbackHeaderFormat(datesRepDistinctDays, dateCnt);\n    }\n    class DaySeriesModel {\n        constructor(range, dateProfileGenerator){\n            let date = range.start;\n            let { end } = range;\n            let indices = [];\n            let dates = [];\n            let dayIndex = -1;\n            while(date < end){\n                if (dateProfileGenerator.isHiddenDay(date)) {\n                    indices.push(dayIndex + 0.5); // mark that it's between indices\n                } else {\n                    dayIndex += 1;\n                    indices.push(dayIndex);\n                    dates.push(date);\n                }\n                date = addDays(date, 1);\n            }\n            this.dates = dates;\n            this.indices = indices;\n            this.cnt = dates.length;\n        }\n        sliceRange(range) {\n            let firstIndex = this.getDateDayIndex(range.start); // inclusive first index\n            let lastIndex = this.getDateDayIndex(addDays(range.end, -1)); // inclusive last index\n            let clippedFirstIndex = Math.max(0, firstIndex);\n            let clippedLastIndex = Math.min(this.cnt - 1, lastIndex);\n            // deal with in-between indices\n            clippedFirstIndex = Math.ceil(clippedFirstIndex); // in-between starts round to next cell\n            clippedLastIndex = Math.floor(clippedLastIndex); // in-between ends round to prev cell\n            if (clippedFirstIndex <= clippedLastIndex) {\n                return {\n                    firstIndex: clippedFirstIndex,\n                    lastIndex: clippedLastIndex,\n                    isStart: firstIndex === clippedFirstIndex,\n                    isEnd: lastIndex === clippedLastIndex\n                };\n            }\n            return null;\n        }\n        // Given a date, returns its chronolocial cell-index from the first cell of the grid.\n        // If the date lies between cells (because of hiddenDays), returns a floating-point value between offsets.\n        // If before the first offset, returns a negative number.\n        // If after the last offset, returns an offset past the last cell offset.\n        // Only works for *start* dates of cells. Will not work for exclusive end dates for cells.\n        getDateDayIndex(date) {\n            let { indices } = this;\n            let dayOffset = Math.floor(diffDays(this.dates[0], date));\n            if (dayOffset < 0) {\n                return indices[0] - 1;\n            }\n            if (dayOffset >= indices.length) {\n                return indices[indices.length - 1] + 1;\n            }\n            return indices[dayOffset];\n        }\n    }\n    class DayTableModel {\n        constructor(daySeries, breakOnWeeks){\n            let { dates } = daySeries;\n            let daysPerRow;\n            let firstDay;\n            let rowCnt;\n            if (breakOnWeeks) {\n                // count columns until the day-of-week repeats\n                firstDay = dates[0].getUTCDay();\n                for(daysPerRow = 1; daysPerRow < dates.length; daysPerRow += 1){\n                    if (dates[daysPerRow].getUTCDay() === firstDay) {\n                        break;\n                    }\n                }\n                rowCnt = Math.ceil(dates.length / daysPerRow);\n            } else {\n                rowCnt = 1;\n                daysPerRow = dates.length;\n            }\n            this.rowCnt = rowCnt;\n            this.colCnt = daysPerRow;\n            this.daySeries = daySeries;\n            this.cells = this.buildCells();\n            this.headerDates = this.buildHeaderDates();\n        }\n        buildCells() {\n            let rows = [];\n            for(let row = 0; row < this.rowCnt; row += 1){\n                let cells = [];\n                for(let col = 0; col < this.colCnt; col += 1){\n                    cells.push(this.buildCell(row, col));\n                }\n                rows.push(cells);\n            }\n            return rows;\n        }\n        buildCell(row, col) {\n            let date = this.daySeries.dates[row * this.colCnt + col];\n            return {\n                key: date.toISOString(),\n                date\n            };\n        }\n        buildHeaderDates() {\n            let dates = [];\n            for(let col = 0; col < this.colCnt; col += 1){\n                dates.push(this.cells[0][col].date);\n            }\n            return dates;\n        }\n        sliceRange(range) {\n            let { colCnt } = this;\n            let seriesSeg = this.daySeries.sliceRange(range);\n            let segs = [];\n            if (seriesSeg) {\n                let { firstIndex, lastIndex } = seriesSeg;\n                let index = firstIndex;\n                while(index <= lastIndex){\n                    let row = Math.floor(index / colCnt);\n                    let nextIndex = Math.min((row + 1) * colCnt, lastIndex + 1);\n                    segs.push({\n                        row,\n                        firstCol: index % colCnt,\n                        lastCol: (nextIndex - 1) % colCnt,\n                        isStart: seriesSeg.isStart && index === firstIndex,\n                        isEnd: seriesSeg.isEnd && nextIndex - 1 === lastIndex\n                    });\n                    index = nextIndex;\n                }\n            }\n            return segs;\n        }\n    }\n    class Slicer {\n        constructor(){\n            this.sliceBusinessHours = memoize(this._sliceBusinessHours);\n            this.sliceDateSelection = memoize(this._sliceDateSpan);\n            this.sliceEventStore = memoize(this._sliceEventStore);\n            this.sliceEventDrag = memoize(this._sliceInteraction);\n            this.sliceEventResize = memoize(this._sliceInteraction);\n            this.forceDayIfListItem = false; // hack\n        }\n        sliceProps(props, dateProfile, nextDayThreshold, context, ...extraArgs) {\n            let { eventUiBases } = props;\n            let eventSegs = this.sliceEventStore(props.eventStore, eventUiBases, dateProfile, nextDayThreshold, ...extraArgs);\n            return {\n                dateSelectionSegs: this.sliceDateSelection(props.dateSelection, dateProfile, nextDayThreshold, eventUiBases, context, ...extraArgs),\n                businessHourSegs: this.sliceBusinessHours(props.businessHours, dateProfile, nextDayThreshold, context, ...extraArgs),\n                fgEventSegs: eventSegs.fg,\n                bgEventSegs: eventSegs.bg,\n                eventDrag: this.sliceEventDrag(props.eventDrag, eventUiBases, dateProfile, nextDayThreshold, ...extraArgs),\n                eventResize: this.sliceEventResize(props.eventResize, eventUiBases, dateProfile, nextDayThreshold, ...extraArgs),\n                eventSelection: props.eventSelection\n            }; // TODO: give interactionSegs?\n        }\n        sliceNowDate(date, dateProfile, nextDayThreshold, context, ...extraArgs) {\n            return this._sliceDateSpan({\n                range: {\n                    start: date,\n                    end: addMs(date, 1)\n                },\n                allDay: false\n            }, dateProfile, nextDayThreshold, {}, context, ...extraArgs);\n        }\n        _sliceBusinessHours(businessHours, dateProfile, nextDayThreshold, context, ...extraArgs) {\n            if (!businessHours) {\n                return [];\n            }\n            return this._sliceEventStore(expandRecurring(businessHours, computeActiveRange(dateProfile, Boolean(nextDayThreshold)), context), {}, dateProfile, nextDayThreshold, ...extraArgs).bg;\n        }\n        _sliceEventStore(eventStore, eventUiBases, dateProfile, nextDayThreshold, ...extraArgs) {\n            if (eventStore) {\n                let rangeRes = sliceEventStore(eventStore, eventUiBases, computeActiveRange(dateProfile, Boolean(nextDayThreshold)), nextDayThreshold);\n                return {\n                    bg: this.sliceEventRanges(rangeRes.bg, extraArgs),\n                    fg: this.sliceEventRanges(rangeRes.fg, extraArgs)\n                };\n            }\n            return {\n                bg: [],\n                fg: []\n            };\n        }\n        _sliceInteraction(interaction, eventUiBases, dateProfile, nextDayThreshold, ...extraArgs) {\n            if (!interaction) {\n                return null;\n            }\n            let rangeRes = sliceEventStore(interaction.mutatedEvents, eventUiBases, computeActiveRange(dateProfile, Boolean(nextDayThreshold)), nextDayThreshold);\n            return {\n                segs: this.sliceEventRanges(rangeRes.fg, extraArgs),\n                affectedInstances: interaction.affectedEvents.instances,\n                isEvent: interaction.isEvent\n            };\n        }\n        _sliceDateSpan(dateSpan, dateProfile, nextDayThreshold, eventUiBases, context, ...extraArgs) {\n            if (!dateSpan) {\n                return [];\n            }\n            let activeRange = computeActiveRange(dateProfile, Boolean(nextDayThreshold));\n            let activeDateSpanRange = intersectRanges(dateSpan.range, activeRange);\n            if (activeDateSpanRange) {\n                dateSpan = Object.assign(Object.assign({}, dateSpan), {\n                    range: activeDateSpanRange\n                });\n                let eventRange = fabricateEventRange(dateSpan, eventUiBases, context);\n                let segs = this.sliceRange(dateSpan.range, ...extraArgs);\n                for (let seg of segs){\n                    seg.eventRange = eventRange;\n                }\n                return segs;\n            }\n            return [];\n        }\n        /*\r\n        \"complete\" seg means it has component and eventRange\r\n        */ sliceEventRanges(eventRanges, extraArgs) {\n            let segs = [];\n            for (let eventRange of eventRanges){\n                segs.push(...this.sliceEventRange(eventRange, extraArgs));\n            }\n            return segs;\n        }\n        /*\r\n        \"complete\" seg means it has component and eventRange\r\n        */ sliceEventRange(eventRange, extraArgs) {\n            let dateRange = eventRange.range;\n            // hack to make multi-day events that are being force-displayed as list-items to take up only one day\n            if (this.forceDayIfListItem && eventRange.ui.display === 'list-item') {\n                dateRange = {\n                    start: dateRange.start,\n                    end: addDays(dateRange.start, 1)\n                };\n            }\n            let segs = this.sliceRange(dateRange, ...extraArgs);\n            for (let seg of segs){\n                seg.eventRange = eventRange;\n                seg.isStart = eventRange.isStart && seg.isStart;\n                seg.isEnd = eventRange.isEnd && seg.isEnd;\n            }\n            return segs;\n        }\n    }\n    /*\r\n    for incorporating slotMinTime/slotMaxTime if appropriate\r\n    TODO: should be part of DateProfile!\r\n    TimelineDateProfile already does this btw\r\n    */ function computeActiveRange(dateProfile, isComponentAllDay) {\n        let range = dateProfile.activeRange;\n        if (isComponentAllDay) {\n            return range;\n        }\n        return {\n            start: addMs(range.start, dateProfile.slotMinTime.milliseconds),\n            end: addMs(range.end, dateProfile.slotMaxTime.milliseconds - 864e5)\n        };\n    }\n    function reduceEventStore(eventStore, action, eventSources, dateProfile, context) {\n        switch(action.type){\n            case 'RECEIVE_EVENTS':\n                return receiveRawEvents(eventStore, eventSources[action.sourceId], action.fetchId, action.fetchRange, action.rawEvents, context);\n            case 'RESET_RAW_EVENTS':\n                return resetRawEvents(eventStore, eventSources[action.sourceId], action.rawEvents, dateProfile.activeRange, context);\n            case 'ADD_EVENTS':\n                return addEvent(eventStore, action.eventStore, dateProfile ? dateProfile.activeRange : null, context);\n            case 'RESET_EVENTS':\n                return action.eventStore;\n            case 'MERGE_EVENTS':\n                return mergeEventStores(eventStore, action.eventStore);\n            case 'PREV':\n            case 'NEXT':\n            case 'CHANGE_DATE':\n            case 'CHANGE_VIEW_TYPE':\n                if (dateProfile) {\n                    return expandRecurring(eventStore, dateProfile.activeRange, context);\n                }\n                return eventStore;\n            case 'REMOVE_EVENTS':\n                return excludeSubEventStore(eventStore, action.eventStore);\n            case 'REMOVE_EVENT_SOURCE':\n                return excludeEventsBySourceId(eventStore, action.sourceId);\n            case 'REMOVE_ALL_EVENT_SOURCES':\n                return filterEventStoreDefs(eventStore, (eventDef)=>!eventDef.sourceId // only keep events with no source id\n                );\n            case 'REMOVE_ALL_EVENTS':\n                return createEmptyEventStore();\n            default:\n                return eventStore;\n        }\n    }\n    function receiveRawEvents(eventStore, eventSource, fetchId, fetchRange, rawEvents, context) {\n        if (eventSource && // not already removed\n        fetchId === eventSource.latestFetchId // TODO: wish this logic was always in event-sources\n        ) {\n            let subset = parseEvents(transformRawEvents(rawEvents, eventSource, context), eventSource, context);\n            if (fetchRange) {\n                subset = expandRecurring(subset, fetchRange, context);\n            }\n            return mergeEventStores(excludeEventsBySourceId(eventStore, eventSource.sourceId), subset);\n        }\n        return eventStore;\n    }\n    function resetRawEvents(existingEventStore, eventSource, rawEvents, activeRange, context) {\n        const { defIdMap, instanceIdMap } = buildPublicIdMaps(existingEventStore);\n        let newEventStore = parseEvents(transformRawEvents(rawEvents, eventSource, context), eventSource, context, false, defIdMap, instanceIdMap);\n        return expandRecurring(newEventStore, activeRange, context);\n    }\n    function transformRawEvents(rawEvents, eventSource, context) {\n        let calEachTransform = context.options.eventDataTransform;\n        let sourceEachTransform = eventSource ? eventSource.eventDataTransform : null;\n        if (sourceEachTransform) {\n            rawEvents = transformEachRawEvent(rawEvents, sourceEachTransform);\n        }\n        if (calEachTransform) {\n            rawEvents = transformEachRawEvent(rawEvents, calEachTransform);\n        }\n        return rawEvents;\n    }\n    function transformEachRawEvent(rawEvents, func) {\n        let refinedEvents;\n        if (!func) {\n            refinedEvents = rawEvents;\n        } else {\n            refinedEvents = [];\n            for (let rawEvent of rawEvents){\n                let refinedEvent = func(rawEvent);\n                if (refinedEvent) {\n                    refinedEvents.push(refinedEvent);\n                } else if (refinedEvent == null) {\n                    refinedEvents.push(rawEvent);\n                } // if a different falsy value, do nothing\n            }\n        }\n        return refinedEvents;\n    }\n    function addEvent(eventStore, subset, expandRange, context) {\n        if (expandRange) {\n            subset = expandRecurring(subset, expandRange, context);\n        }\n        return mergeEventStores(eventStore, subset);\n    }\n    function rezoneEventStoreDates(eventStore, oldDateEnv, newDateEnv) {\n        let { defs } = eventStore;\n        let instances = mapHash(eventStore.instances, (instance)=>{\n            let def = defs[instance.defId];\n            if (def.allDay) {\n                return instance; // isn't dependent on timezone\n            }\n            return Object.assign(Object.assign({}, instance), {\n                range: {\n                    start: newDateEnv.createMarker(oldDateEnv.toDate(instance.range.start, instance.forcedStartTzo)),\n                    end: newDateEnv.createMarker(oldDateEnv.toDate(instance.range.end, instance.forcedEndTzo))\n                },\n                forcedStartTzo: newDateEnv.canComputeOffset ? null : instance.forcedStartTzo,\n                forcedEndTzo: newDateEnv.canComputeOffset ? null : instance.forcedEndTzo\n            });\n        });\n        return {\n            defs,\n            instances\n        };\n    }\n    function excludeEventsBySourceId(eventStore, sourceId) {\n        return filterEventStoreDefs(eventStore, (eventDef)=>eventDef.sourceId !== sourceId);\n    }\n    // QUESTION: why not just return instances? do a general object-property-exclusion util\n    function excludeInstances(eventStore, removals) {\n        return {\n            defs: eventStore.defs,\n            instances: filterHash(eventStore.instances, (instance)=>!removals[instance.instanceId])\n        };\n    }\n    function buildPublicIdMaps(eventStore) {\n        const { defs, instances } = eventStore;\n        const defIdMap = {};\n        const instanceIdMap = {};\n        for(let defId in defs){\n            const def = defs[defId];\n            const { publicId } = def;\n            if (publicId) {\n                defIdMap[publicId] = defId;\n            }\n        }\n        for(let instanceId in instances){\n            const instance = instances[instanceId];\n            const def = defs[instance.defId];\n            const { publicId } = def;\n            if (publicId) {\n                instanceIdMap[publicId] = instanceId;\n            }\n        }\n        return {\n            defIdMap,\n            instanceIdMap\n        };\n    }\n    // high-level segmenting-aware tester functions\n    // ------------------------------------------------------------------------------------------------------------------------\n    function isInteractionValid(interaction, dateProfile, context) {\n        let { instances } = interaction.mutatedEvents;\n        for(let instanceId in instances){\n            if (!rangeContainsRange(dateProfile.validRange, instances[instanceId].range)) {\n                return false;\n            }\n        }\n        return isNewPropsValid({\n            eventDrag: interaction\n        }, context); // HACK: the eventDrag props is used for ALL interactions\n    }\n    function isDateSelectionValid(dateSelection, dateProfile, context) {\n        if (!rangeContainsRange(dateProfile.validRange, dateSelection.range)) {\n            return false;\n        }\n        return isNewPropsValid({\n            dateSelection\n        }, context);\n    }\n    function isNewPropsValid(newProps, context) {\n        let calendarState = context.getCurrentData();\n        let props = Object.assign({\n            businessHours: calendarState.businessHours,\n            dateSelection: '',\n            eventStore: calendarState.eventStore,\n            eventUiBases: calendarState.eventUiBases,\n            eventSelection: '',\n            eventDrag: null,\n            eventResize: null\n        }, newProps);\n        return (context.pluginHooks.isPropsValid || isPropsValid)(props, context);\n    }\n    function isPropsValid(state, context, dateSpanMeta = {}, filterConfig) {\n        if (state.eventDrag && !isInteractionPropsValid(state, context, dateSpanMeta, filterConfig)) {\n            return false;\n        }\n        if (state.dateSelection && !isDateSelectionPropsValid(state, context, dateSpanMeta, filterConfig)) {\n            return false;\n        }\n        return true;\n    }\n    // Moving Event Validation\n    // ------------------------------------------------------------------------------------------------------------------------\n    function isInteractionPropsValid(state, context, dateSpanMeta, filterConfig) {\n        let currentState = context.getCurrentData();\n        let interaction = state.eventDrag; // HACK: the eventDrag props is used for ALL interactions\n        let subjectEventStore = interaction.mutatedEvents;\n        let subjectDefs = subjectEventStore.defs;\n        let subjectInstances = subjectEventStore.instances;\n        let subjectConfigs = compileEventUis(subjectDefs, interaction.isEvent ? state.eventUiBases : {\n            '': currentState.selectionConfig\n        });\n        if (filterConfig) {\n            subjectConfigs = mapHash(subjectConfigs, filterConfig);\n        }\n        // exclude the subject events. TODO: exclude defs too?\n        let otherEventStore = excludeInstances(state.eventStore, interaction.affectedEvents.instances);\n        let otherDefs = otherEventStore.defs;\n        let otherInstances = otherEventStore.instances;\n        let otherConfigs = compileEventUis(otherDefs, state.eventUiBases);\n        for(let subjectInstanceId in subjectInstances){\n            let subjectInstance = subjectInstances[subjectInstanceId];\n            let subjectRange = subjectInstance.range;\n            let subjectConfig = subjectConfigs[subjectInstance.defId];\n            let subjectDef = subjectDefs[subjectInstance.defId];\n            // constraint\n            if (!allConstraintsPass(subjectConfig.constraints, subjectRange, otherEventStore, state.businessHours, context)) {\n                return false;\n            }\n            // overlap\n            let { eventOverlap } = context.options;\n            let eventOverlapFunc = typeof eventOverlap === 'function' ? eventOverlap : null;\n            for(let otherInstanceId in otherInstances){\n                let otherInstance = otherInstances[otherInstanceId];\n                // intersect! evaluate\n                if (rangesIntersect(subjectRange, otherInstance.range)) {\n                    let otherOverlap = otherConfigs[otherInstance.defId].overlap;\n                    // consider the other event's overlap. only do this if the subject event is a \"real\" event\n                    if (otherOverlap === false && interaction.isEvent) {\n                        return false;\n                    }\n                    if (subjectConfig.overlap === false) {\n                        return false;\n                    }\n                    if (eventOverlapFunc && !eventOverlapFunc(new EventImpl(context, otherDefs[otherInstance.defId], otherInstance), new EventImpl(context, subjectDef, subjectInstance))) {\n                        return false;\n                    }\n                }\n            }\n            // allow (a function)\n            let calendarEventStore = currentState.eventStore; // need global-to-calendar, not local to component (splittable)state\n            for (let subjectAllow of subjectConfig.allows){\n                let subjectDateSpan = Object.assign(Object.assign({}, dateSpanMeta), {\n                    range: subjectInstance.range,\n                    allDay: subjectDef.allDay\n                });\n                let origDef = calendarEventStore.defs[subjectDef.defId];\n                let origInstance = calendarEventStore.instances[subjectInstanceId];\n                let eventApi;\n                if (origDef) {\n                    eventApi = new EventImpl(context, origDef, origInstance);\n                } else {\n                    eventApi = new EventImpl(context, subjectDef); // no instance, because had no dates\n                }\n                if (!subjectAllow(buildDateSpanApiWithContext(subjectDateSpan, context), eventApi)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    // Date Selection Validation\n    // ------------------------------------------------------------------------------------------------------------------------\n    function isDateSelectionPropsValid(state, context, dateSpanMeta, filterConfig) {\n        let relevantEventStore = state.eventStore;\n        let relevantDefs = relevantEventStore.defs;\n        let relevantInstances = relevantEventStore.instances;\n        let selection = state.dateSelection;\n        let selectionRange = selection.range;\n        let { selectionConfig } = context.getCurrentData();\n        if (filterConfig) {\n            selectionConfig = filterConfig(selectionConfig);\n        }\n        // constraint\n        if (!allConstraintsPass(selectionConfig.constraints, selectionRange, relevantEventStore, state.businessHours, context)) {\n            return false;\n        }\n        // overlap\n        let { selectOverlap } = context.options;\n        let selectOverlapFunc = typeof selectOverlap === 'function' ? selectOverlap : null;\n        for(let relevantInstanceId in relevantInstances){\n            let relevantInstance = relevantInstances[relevantInstanceId];\n            // intersect! evaluate\n            if (rangesIntersect(selectionRange, relevantInstance.range)) {\n                if (selectionConfig.overlap === false) {\n                    return false;\n                }\n                if (selectOverlapFunc && !selectOverlapFunc(new EventImpl(context, relevantDefs[relevantInstance.defId], relevantInstance), null)) {\n                    return false;\n                }\n            }\n        }\n        // allow (a function)\n        for (let selectionAllow of selectionConfig.allows){\n            let fullDateSpan = Object.assign(Object.assign({}, dateSpanMeta), selection);\n            if (!selectionAllow(buildDateSpanApiWithContext(fullDateSpan, context), null)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    // Constraint Utils\n    // ------------------------------------------------------------------------------------------------------------------------\n    function allConstraintsPass(constraints, subjectRange, otherEventStore, businessHoursUnexpanded, context) {\n        for (let constraint of constraints){\n            if (!anyRangesContainRange(constraintToRanges(constraint, subjectRange, otherEventStore, businessHoursUnexpanded, context), subjectRange)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    function constraintToRanges(constraint, subjectRange, otherEventStore, businessHoursUnexpanded, context) {\n        if (constraint === 'businessHours') {\n            return eventStoreToRanges(expandRecurring(businessHoursUnexpanded, subjectRange, context));\n        }\n        if (typeof constraint === 'string') {\n            return eventStoreToRanges(filterEventStoreDefs(otherEventStore, (eventDef)=>eventDef.groupId === constraint));\n        }\n        if (typeof constraint === 'object' && constraint) {\n            return eventStoreToRanges(expandRecurring(constraint, subjectRange, context));\n        }\n        return []; // if it's false\n    }\n    // TODO: move to event-store file?\n    function eventStoreToRanges(eventStore) {\n        let { instances } = eventStore;\n        let ranges = [];\n        for(let instanceId in instances){\n            ranges.push(instances[instanceId].range);\n        }\n        return ranges;\n    }\n    // TODO: move to geom file?\n    function anyRangesContainRange(outerRanges, innerRange) {\n        for (let outerRange of outerRanges){\n            if (rangeContainsRange(outerRange, innerRange)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    class JsonRequestError extends Error {\n        constructor(message, response){\n            super(message);\n            this.response = response;\n        }\n    }\n    function requestJson(method, url, params) {\n        method = method.toUpperCase();\n        const fetchOptions = {\n            method\n        };\n        if (method === 'GET') {\n            url += (url.indexOf('?') === -1 ? '?' : '&') + new URLSearchParams(params);\n        } else {\n            fetchOptions.body = new URLSearchParams(params);\n            fetchOptions.headers = {\n                'Content-Type': 'application/x-www-form-urlencoded'\n            };\n        }\n        return fetch(url, fetchOptions).then((fetchRes)=>{\n            if (fetchRes.ok) {\n                return fetchRes.json().then((parsedResponse)=>{\n                    return [\n                        parsedResponse,\n                        fetchRes\n                    ];\n                }, ()=>{\n                    throw new JsonRequestError('Failure parsing JSON', fetchRes);\n                });\n            } else {\n                throw new JsonRequestError('Request failed', fetchRes);\n            }\n        });\n    }\n    class DelayedRunner {\n        constructor(drainedOption){\n            this.drainedOption = drainedOption;\n            this.isRunning = false;\n            this.isDirty = false;\n            this.pauseDepths = {};\n            this.timeoutId = 0;\n        }\n        request(delay) {\n            this.isDirty = true;\n            if (!this.isPaused()) {\n                this.clearTimeout();\n                if (delay == null) {\n                    this.tryDrain();\n                } else {\n                    this.timeoutId = setTimeout(this.tryDrain.bind(this), delay);\n                }\n            }\n        }\n        pause(scope = '') {\n            let { pauseDepths } = this;\n            pauseDepths[scope] = (pauseDepths[scope] || 0) + 1;\n            this.clearTimeout();\n        }\n        resume(scope = '', force) {\n            let { pauseDepths } = this;\n            if (scope in pauseDepths) {\n                if (force) {\n                    delete pauseDepths[scope];\n                } else {\n                    pauseDepths[scope] -= 1;\n                    let depth = pauseDepths[scope];\n                    if (depth <= 0) {\n                        delete pauseDepths[scope];\n                    }\n                }\n                this.tryDrain();\n            }\n        }\n        isPaused() {\n            return Object.keys(this.pauseDepths).length;\n        }\n        tryDrain() {\n            if (!this.isRunning && !this.isPaused()) {\n                this.isRunning = true;\n                while(this.isDirty){\n                    this.isDirty = false;\n                    this.drained(); // might set isDirty to true again\n                }\n                this.isRunning = false;\n            }\n        }\n        clear() {\n            this.clearTimeout();\n            this.isDirty = false;\n            this.pauseDepths = {};\n        }\n        clearTimeout() {\n            if (this.timeoutId) {\n                clearTimeout(this.timeoutId);\n                this.timeoutId = 0;\n            }\n        }\n        drained() {\n            if (this.drainedOption) {\n                this.drainedOption();\n            }\n        }\n    }\n    const VISIBLE_HIDDEN_RE = /^(visible|hidden)$/;\n    class Scroller extends BaseComponent {\n        constructor(){\n            super(...arguments);\n            this.handleEl = (el)=>{\n                this.el = el;\n                setRef(this.props.elRef, el);\n            };\n        }\n        render() {\n            let { props } = this;\n            let { liquid, liquidIsAbsolute } = props;\n            let isAbsolute = liquid && liquidIsAbsolute;\n            let className = [\n                'fc-scroller'\n            ];\n            if (liquid) {\n                if (liquidIsAbsolute) {\n                    className.push('fc-scroller-liquid-absolute');\n                } else {\n                    className.push('fc-scroller-liquid');\n                }\n            }\n            return y(\"div\", {\n                ref: this.handleEl,\n                className: className.join(' '),\n                style: {\n                    overflowX: props.overflowX,\n                    overflowY: props.overflowY,\n                    left: isAbsolute && -(props.overcomeLeft || 0) || '',\n                    right: isAbsolute && -(props.overcomeRight || 0) || '',\n                    bottom: isAbsolute && -(props.overcomeBottom || 0) || '',\n                    marginLeft: !isAbsolute && -(props.overcomeLeft || 0) || '',\n                    marginRight: !isAbsolute && -(props.overcomeRight || 0) || '',\n                    marginBottom: !isAbsolute && -(props.overcomeBottom || 0) || '',\n                    maxHeight: props.maxHeight || ''\n                }\n            }, props.children);\n        }\n        needsXScrolling() {\n            if (VISIBLE_HIDDEN_RE.test(this.props.overflowX)) {\n                return false;\n            }\n            // testing scrollWidth>clientWidth is unreliable cross-browser when pixel heights aren't integers.\n            // much more reliable to see if children are taller than the scroller, even tho doesn't account for\n            // inner-child margins and absolute positioning\n            let { el } = this;\n            let realClientWidth = this.el.getBoundingClientRect().width - this.getYScrollbarWidth();\n            let { children } = el;\n            for(let i = 0; i < children.length; i += 1){\n                let childEl = children[i];\n                if (childEl.getBoundingClientRect().width > realClientWidth) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        needsYScrolling() {\n            if (VISIBLE_HIDDEN_RE.test(this.props.overflowY)) {\n                return false;\n            }\n            // testing scrollHeight>clientHeight is unreliable cross-browser when pixel heights aren't integers.\n            // much more reliable to see if children are taller than the scroller, even tho doesn't account for\n            // inner-child margins and absolute positioning\n            let { el } = this;\n            let realClientHeight = this.el.getBoundingClientRect().height - this.getXScrollbarWidth();\n            let { children } = el;\n            for(let i = 0; i < children.length; i += 1){\n                let childEl = children[i];\n                if (childEl.getBoundingClientRect().height > realClientHeight) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        getXScrollbarWidth() {\n            if (VISIBLE_HIDDEN_RE.test(this.props.overflowX)) {\n                return 0;\n            }\n            return this.el.offsetHeight - this.el.clientHeight; // only works because we guarantee no borders. TODO: add to CSS with important?\n        }\n        getYScrollbarWidth() {\n            if (VISIBLE_HIDDEN_RE.test(this.props.overflowY)) {\n                return 0;\n            }\n            return this.el.offsetWidth - this.el.clientWidth; // only works because we guarantee no borders. TODO: add to CSS with important?\n        }\n    }\n    /*\r\n    TODO: somehow infer OtherArgs from masterCallback?\r\n    TODO: infer RefType from masterCallback if provided\r\n    */ class RefMap {\n        constructor(masterCallback){\n            this.masterCallback = masterCallback;\n            this.currentMap = {};\n            this.depths = {};\n            this.callbackMap = {};\n            this.handleValue = (val, key)=>{\n                let { depths, currentMap } = this;\n                let removed = false;\n                let added = false;\n                if (val !== null) {\n                    // for bug... ACTUALLY: can probably do away with this now that callers don't share numeric indices anymore\n                    removed = key in currentMap;\n                    currentMap[key] = val;\n                    depths[key] = (depths[key] || 0) + 1;\n                    added = true;\n                } else {\n                    depths[key] -= 1;\n                    if (!depths[key]) {\n                        delete currentMap[key];\n                        delete this.callbackMap[key];\n                        removed = true;\n                    }\n                }\n                if (this.masterCallback) {\n                    if (removed) {\n                        this.masterCallback(null, String(key));\n                    }\n                    if (added) {\n                        this.masterCallback(val, String(key));\n                    }\n                }\n            };\n        }\n        createRef(key) {\n            let refCallback = this.callbackMap[key];\n            if (!refCallback) {\n                refCallback = this.callbackMap[key] = (val)=>{\n                    this.handleValue(val, String(key));\n                };\n            }\n            return refCallback;\n        }\n        // TODO: check callers that don't care about order. should use getAll instead\n        // NOTE: this method has become less valuable now that we are encouraged to map order by some other index\n        // TODO: provide ONE array-export function, buildArray, which fails on non-numeric indexes. caller can manipulate and \"collect\"\n        collect(startIndex, endIndex, step) {\n            return collectFromHash(this.currentMap, startIndex, endIndex, step);\n        }\n        getAll() {\n            return hashValuesToArray(this.currentMap);\n        }\n    }\n    function computeShrinkWidth(chunkEls) {\n        let shrinkCells = findElements(chunkEls, '.fc-scrollgrid-shrink');\n        let largestWidth = 0;\n        for (let shrinkCell of shrinkCells){\n            largestWidth = Math.max(largestWidth, computeSmallestCellWidth(shrinkCell));\n        }\n        return Math.ceil(largestWidth); // <table> elements work best with integers. round up to ensure contents fits\n    }\n    function getSectionHasLiquidHeight(props, sectionConfig) {\n        return props.liquid && sectionConfig.liquid; // does the section do liquid-height? (need to have whole scrollgrid liquid-height as well)\n    }\n    function getAllowYScrolling(props, sectionConfig) {\n        return sectionConfig.maxHeight != null || // if its possible for the height to max out, we might need scrollbars\n        getSectionHasLiquidHeight(props, sectionConfig); // if the section is liquid height, it might condense enough to require scrollbars\n    }\n    // TODO: ONLY use `arg`. force out internal function to use same API\n    function renderChunkContent(sectionConfig, chunkConfig, arg, isHeader) {\n        let { expandRows } = arg;\n        let content = typeof chunkConfig.content === 'function' ? chunkConfig.content(arg) : y('table', {\n            role: 'presentation',\n            className: [\n                chunkConfig.tableClassName,\n                sectionConfig.syncRowHeights ? 'fc-scrollgrid-sync-table' : ''\n            ].join(' '),\n            style: {\n                minWidth: arg.tableMinWidth,\n                width: arg.clientWidth,\n                height: expandRows ? arg.clientHeight : ''\n            }\n        }, arg.tableColGroupNode, y(isHeader ? 'thead' : 'tbody', {\n            role: 'presentation'\n        }, typeof chunkConfig.rowContent === 'function' ? chunkConfig.rowContent(arg) : chunkConfig.rowContent));\n        return content;\n    }\n    function isColPropsEqual(cols0, cols1) {\n        return isArraysEqual(cols0, cols1, isPropsEqual);\n    }\n    function renderMicroColGroup(cols, shrinkWidth) {\n        let colNodes = [];\n        /*\r\n        for ColProps with spans, it would have been great to make a single <col span=\"\">\r\n        HOWEVER, Chrome was getting messing up distributing the width to <td>/<th> elements with colspans.\r\n        SOLUTION: making individual <col> elements makes Chrome behave.\r\n        */ for (let colProps of cols){\n            let span = colProps.span || 1;\n            for(let i = 0; i < span; i += 1){\n                colNodes.push(y(\"col\", {\n                    style: {\n                        width: colProps.width === 'shrink' ? sanitizeShrinkWidth(shrinkWidth) : colProps.width || '',\n                        minWidth: colProps.minWidth || ''\n                    }\n                }));\n            }\n        }\n        return y('colgroup', {}, ...colNodes);\n    }\n    function sanitizeShrinkWidth(shrinkWidth) {\n        /* why 4? if we do 0, it will kill any border, which are needed for computeSmallestCellWidth\r\n        4 accounts for 2 2-pixel borders. TODO: better solution? */ return shrinkWidth == null ? 4 : shrinkWidth;\n    }\n    function hasShrinkWidth(cols) {\n        for (let col of cols){\n            if (col.width === 'shrink') {\n                return true;\n            }\n        }\n        return false;\n    }\n    function getScrollGridClassNames(liquid, context) {\n        let classNames = [\n            'fc-scrollgrid',\n            context.theme.getClass('table')\n        ];\n        if (liquid) {\n            classNames.push('fc-scrollgrid-liquid');\n        }\n        return classNames;\n    }\n    function getSectionClassNames(sectionConfig, wholeTableVGrow) {\n        let classNames = [\n            'fc-scrollgrid-section',\n            `fc-scrollgrid-section-${sectionConfig.type}`,\n            sectionConfig.className\n        ];\n        if (wholeTableVGrow && sectionConfig.liquid && sectionConfig.maxHeight == null) {\n            classNames.push('fc-scrollgrid-section-liquid');\n        }\n        if (sectionConfig.isSticky) {\n            classNames.push('fc-scrollgrid-section-sticky');\n        }\n        return classNames;\n    }\n    function renderScrollShim(arg) {\n        return y(\"div\", {\n            className: \"fc-scrollgrid-sticky-shim\",\n            style: {\n                width: arg.clientWidth,\n                minWidth: arg.tableMinWidth\n            }\n        });\n    }\n    function getStickyHeaderDates(options) {\n        let { stickyHeaderDates } = options;\n        if (stickyHeaderDates == null || stickyHeaderDates === 'auto') {\n            stickyHeaderDates = options.height === 'auto' || options.viewHeight === 'auto';\n        }\n        return stickyHeaderDates;\n    }\n    function getStickyFooterScrollbar(options) {\n        let { stickyFooterScrollbar } = options;\n        if (stickyFooterScrollbar == null || stickyFooterScrollbar === 'auto') {\n            stickyFooterScrollbar = options.height === 'auto' || options.viewHeight === 'auto';\n        }\n        return stickyFooterScrollbar;\n    }\n    class SimpleScrollGrid extends BaseComponent {\n        constructor(){\n            super(...arguments);\n            this.processCols = memoize((a)=>a, isColPropsEqual); // so we get same `cols` props every time\n            // yucky to memoize VNodes, but much more efficient for consumers\n            this.renderMicroColGroup = memoize(renderMicroColGroup);\n            this.scrollerRefs = new RefMap();\n            this.scrollerElRefs = new RefMap(this._handleScrollerEl.bind(this));\n            this.state = {\n                shrinkWidth: null,\n                forceYScrollbars: false,\n                scrollerClientWidths: {},\n                scrollerClientHeights: {}\n            };\n            // TODO: can do a really simple print-view. dont need to join rows\n            this.handleSizing = ()=>{\n                this.safeSetState(Object.assign({\n                    shrinkWidth: this.computeShrinkWidth()\n                }, this.computeScrollerDims()));\n            };\n        }\n        render() {\n            let { props, state, context } = this;\n            let sectionConfigs = props.sections || [];\n            let cols = this.processCols(props.cols);\n            let microColGroupNode = this.renderMicroColGroup(cols, state.shrinkWidth);\n            let classNames = getScrollGridClassNames(props.liquid, context);\n            if (props.collapsibleWidth) {\n                classNames.push('fc-scrollgrid-collapsible');\n            }\n            // TODO: make DRY\n            let configCnt = sectionConfigs.length;\n            let configI = 0;\n            let currentConfig;\n            let headSectionNodes = [];\n            let bodySectionNodes = [];\n            let footSectionNodes = [];\n            while(configI < configCnt && (currentConfig = sectionConfigs[configI]).type === 'header'){\n                headSectionNodes.push(this.renderSection(currentConfig, microColGroupNode, true));\n                configI += 1;\n            }\n            while(configI < configCnt && (currentConfig = sectionConfigs[configI]).type === 'body'){\n                bodySectionNodes.push(this.renderSection(currentConfig, microColGroupNode, false));\n                configI += 1;\n            }\n            while(configI < configCnt && (currentConfig = sectionConfigs[configI]).type === 'footer'){\n                footSectionNodes.push(this.renderSection(currentConfig, microColGroupNode, true));\n                configI += 1;\n            }\n            // firefox bug: when setting height on table and there is a thead or tfoot,\n            // the necessary height:100% on the liquid-height body section forces the *whole* table to be taller. (bug #5524)\n            // use getCanVGrowWithinCell as a way to detect table-stupid firefox.\n            // if so, use a simpler dom structure, jam everything into a lone tbody.\n            let isBuggy = !getCanVGrowWithinCell();\n            const roleAttrs = {\n                role: 'rowgroup'\n            };\n            return y('table', {\n                role: 'grid',\n                className: classNames.join(' '),\n                style: {\n                    height: props.height\n                }\n            }, Boolean(!isBuggy && headSectionNodes.length) && y('thead', roleAttrs, ...headSectionNodes), Boolean(!isBuggy && bodySectionNodes.length) && y('tbody', roleAttrs, ...bodySectionNodes), Boolean(!isBuggy && footSectionNodes.length) && y('tfoot', roleAttrs, ...footSectionNodes), isBuggy && y('tbody', roleAttrs, ...headSectionNodes, ...bodySectionNodes, ...footSectionNodes));\n        }\n        renderSection(sectionConfig, microColGroupNode, isHeader) {\n            if ('outerContent' in sectionConfig) {\n                return y(_, {\n                    key: sectionConfig.key\n                }, sectionConfig.outerContent);\n            }\n            return y(\"tr\", {\n                key: sectionConfig.key,\n                role: \"presentation\",\n                className: getSectionClassNames(sectionConfig, this.props.liquid).join(' ')\n            }, this.renderChunkTd(sectionConfig, microColGroupNode, sectionConfig.chunk, isHeader));\n        }\n        renderChunkTd(sectionConfig, microColGroupNode, chunkConfig, isHeader) {\n            if ('outerContent' in chunkConfig) {\n                return chunkConfig.outerContent;\n            }\n            let { props } = this;\n            let { forceYScrollbars, scrollerClientWidths, scrollerClientHeights } = this.state;\n            let needsYScrolling = getAllowYScrolling(props, sectionConfig); // TODO: do lazily. do in section config?\n            let isLiquid = getSectionHasLiquidHeight(props, sectionConfig);\n            // for `!props.liquid` - is WHOLE scrollgrid natural height?\n            // TODO: do same thing in advanced scrollgrid? prolly not b/c always has horizontal scrollbars\n            let overflowY = !props.liquid ? 'visible' : forceYScrollbars ? 'scroll' : !needsYScrolling ? 'hidden' : 'auto';\n            let sectionKey = sectionConfig.key;\n            let content = renderChunkContent(sectionConfig, chunkConfig, {\n                tableColGroupNode: microColGroupNode,\n                tableMinWidth: '',\n                clientWidth: !props.collapsibleWidth && scrollerClientWidths[sectionKey] !== undefined ? scrollerClientWidths[sectionKey] : null,\n                clientHeight: scrollerClientHeights[sectionKey] !== undefined ? scrollerClientHeights[sectionKey] : null,\n                expandRows: sectionConfig.expandRows,\n                syncRowHeights: false,\n                rowSyncHeights: [],\n                reportRowHeightChange: ()=>{}\n            }, isHeader);\n            return y(isHeader ? 'th' : 'td', {\n                ref: chunkConfig.elRef,\n                role: 'presentation'\n            }, y(\"div\", {\n                className: `fc-scroller-harness${isLiquid ? ' fc-scroller-harness-liquid' : ''}`\n            }, y(Scroller, {\n                ref: this.scrollerRefs.createRef(sectionKey),\n                elRef: this.scrollerElRefs.createRef(sectionKey),\n                overflowY: overflowY,\n                overflowX: !props.liquid ? 'visible' : 'hidden' /* natural height? */ ,\n                maxHeight: sectionConfig.maxHeight,\n                liquid: isLiquid,\n                liquidIsAbsolute: true\n            }, content)));\n        }\n        _handleScrollerEl(scrollerEl, key) {\n            let section = getSectionByKey(this.props.sections, key);\n            if (section) {\n                setRef(section.chunk.scrollerElRef, scrollerEl);\n            }\n        }\n        componentDidMount() {\n            this.handleSizing();\n            this.context.addResizeHandler(this.handleSizing);\n        }\n        componentDidUpdate() {\n            // TODO: need better solution when state contains non-sizing things\n            this.handleSizing();\n        }\n        componentWillUnmount() {\n            this.context.removeResizeHandler(this.handleSizing);\n        }\n        computeShrinkWidth() {\n            return hasShrinkWidth(this.props.cols) ? computeShrinkWidth(this.scrollerElRefs.getAll()) : 0;\n        }\n        computeScrollerDims() {\n            let scrollbarWidth = getScrollbarWidths();\n            let { scrollerRefs, scrollerElRefs } = this;\n            let forceYScrollbars = false;\n            let scrollerClientWidths = {};\n            let scrollerClientHeights = {};\n            for(let sectionKey in scrollerRefs.currentMap){\n                let scroller = scrollerRefs.currentMap[sectionKey];\n                if (scroller && scroller.needsYScrolling()) {\n                    forceYScrollbars = true;\n                    break;\n                }\n            }\n            for (let section of this.props.sections){\n                let sectionKey = section.key;\n                let scrollerEl = scrollerElRefs.currentMap[sectionKey];\n                if (scrollerEl) {\n                    let harnessEl = scrollerEl.parentNode; // TODO: weird way to get this. need harness b/c doesn't include table borders\n                    scrollerClientWidths[sectionKey] = Math.floor(harnessEl.getBoundingClientRect().width - (forceYScrollbars ? scrollbarWidth.y // use global because scroller might not have scrollbars yet but will need them in future\n                     : 0));\n                    scrollerClientHeights[sectionKey] = Math.floor(harnessEl.getBoundingClientRect().height);\n                }\n            }\n            return {\n                forceYScrollbars,\n                scrollerClientWidths,\n                scrollerClientHeights\n            };\n        }\n    }\n    SimpleScrollGrid.addStateEquality({\n        scrollerClientWidths: isPropsEqual,\n        scrollerClientHeights: isPropsEqual\n    });\n    function getSectionByKey(sections, key) {\n        for (let section of sections){\n            if (section.key === key) {\n                return section;\n            }\n        }\n        return null;\n    }\n    class EventContainer extends BaseComponent {\n        constructor(){\n            super(...arguments);\n            this.handleEl = (el)=>{\n                this.el = el;\n                if (el) {\n                    setElSeg(el, this.props.seg);\n                }\n            };\n        }\n        render() {\n            const { props, context } = this;\n            const { options } = context;\n            const { seg } = props;\n            const { eventRange } = seg;\n            const { ui } = eventRange;\n            const renderProps = {\n                event: new EventImpl(context, eventRange.def, eventRange.instance),\n                view: context.viewApi,\n                timeText: props.timeText,\n                textColor: ui.textColor,\n                backgroundColor: ui.backgroundColor,\n                borderColor: ui.borderColor,\n                isDraggable: !props.disableDragging && computeSegDraggable(seg, context),\n                isStartResizable: !props.disableResizing && computeSegStartResizable(seg, context),\n                isEndResizable: !props.disableResizing && computeSegEndResizable(seg),\n                isMirror: Boolean(props.isDragging || props.isResizing || props.isDateSelecting),\n                isStart: Boolean(seg.isStart),\n                isEnd: Boolean(seg.isEnd),\n                isPast: Boolean(props.isPast),\n                isFuture: Boolean(props.isFuture),\n                isToday: Boolean(props.isToday),\n                isSelected: Boolean(props.isSelected),\n                isDragging: Boolean(props.isDragging),\n                isResizing: Boolean(props.isResizing)\n            };\n            return y(ContentContainer, Object.assign({}, props /* contains children */ , {\n                elRef: this.handleEl,\n                elClasses: [\n                    ...getEventClassNames(renderProps),\n                    ...seg.eventRange.ui.classNames,\n                    ...props.elClasses || []\n                ],\n                renderProps: renderProps,\n                generatorName: \"eventContent\",\n                customGenerator: options.eventContent,\n                defaultGenerator: props.defaultGenerator,\n                classNameGenerator: options.eventClassNames,\n                didMount: options.eventDidMount,\n                willUnmount: options.eventWillUnmount\n            }));\n        }\n        componentDidUpdate(prevProps) {\n            if (this.el && this.props.seg !== prevProps.seg) {\n                setElSeg(this.el, this.props.seg);\n            }\n        }\n    }\n    // should not be a purecomponent\n    class StandardEvent extends BaseComponent {\n        render() {\n            let { props, context } = this;\n            let { options } = context;\n            let { seg } = props;\n            let { ui } = seg.eventRange;\n            let timeFormat = options.eventTimeFormat || props.defaultTimeFormat;\n            let timeText = buildSegTimeText(seg, timeFormat, context, props.defaultDisplayEventTime, props.defaultDisplayEventEnd);\n            return y(EventContainer, Object.assign({}, props /* includes elRef */ , {\n                elTag: \"a\",\n                elStyle: {\n                    borderColor: ui.borderColor,\n                    backgroundColor: ui.backgroundColor\n                },\n                elAttrs: getSegAnchorAttrs(seg, context),\n                defaultGenerator: renderInnerContent$1$1,\n                timeText: timeText\n            }), (InnerContent, eventContentArg)=>y(_, null, y(InnerContent, {\n                    elTag: \"div\",\n                    elClasses: [\n                        'fc-event-main'\n                    ],\n                    elStyle: {\n                        color: eventContentArg.textColor\n                    }\n                }), Boolean(eventContentArg.isStartResizable) && y(\"div\", {\n                    className: \"fc-event-resizer fc-event-resizer-start\"\n                }), Boolean(eventContentArg.isEndResizable) && y(\"div\", {\n                    className: \"fc-event-resizer fc-event-resizer-end\"\n                })));\n        }\n    }\n    function renderInnerContent$1$1(innerProps) {\n        return y(\"div\", {\n            className: \"fc-event-main-frame\"\n        }, innerProps.timeText && y(\"div\", {\n            className: \"fc-event-time\"\n        }, innerProps.timeText), y(\"div\", {\n            className: \"fc-event-title-container\"\n        }, y(\"div\", {\n            className: \"fc-event-title fc-sticky\"\n        }, innerProps.event.title || y(_, null, \"\\u00A0\"))));\n    }\n    const NowIndicatorContainer = (props)=>y(ViewContextType.Consumer, null, (context)=>{\n            let { options } = context;\n            let renderProps = {\n                isAxis: props.isAxis,\n                date: context.dateEnv.toDate(props.date),\n                view: context.viewApi\n            };\n            return y(ContentContainer, Object.assign({}, props /* includes children */ , {\n                elTag: props.elTag || 'div',\n                renderProps: renderProps,\n                generatorName: \"nowIndicatorContent\",\n                customGenerator: options.nowIndicatorContent,\n                classNameGenerator: options.nowIndicatorClassNames,\n                didMount: options.nowIndicatorDidMount,\n                willUnmount: options.nowIndicatorWillUnmount\n            }));\n        });\n    const DAY_NUM_FORMAT = createFormatter({\n        day: 'numeric'\n    });\n    class DayCellContainer extends BaseComponent {\n        constructor(){\n            super(...arguments);\n            this.refineRenderProps = memoizeObjArg(refineRenderProps);\n        }\n        render() {\n            let { props, context } = this;\n            let { options } = context;\n            let renderProps = this.refineRenderProps({\n                date: props.date,\n                dateProfile: props.dateProfile,\n                todayRange: props.todayRange,\n                isMonthStart: props.isMonthStart || false,\n                showDayNumber: props.showDayNumber,\n                extraRenderProps: props.extraRenderProps,\n                viewApi: context.viewApi,\n                dateEnv: context.dateEnv,\n                monthStartFormat: options.monthStartFormat\n            });\n            return y(ContentContainer, Object.assign({}, props /* includes children */ , {\n                elClasses: [\n                    ...getDayClassNames(renderProps, context.theme),\n                    ...props.elClasses || []\n                ],\n                elAttrs: Object.assign(Object.assign({}, props.elAttrs), renderProps.isDisabled ? {} : {\n                    'data-date': formatDayString(props.date)\n                }),\n                renderProps: renderProps,\n                generatorName: \"dayCellContent\",\n                customGenerator: options.dayCellContent,\n                defaultGenerator: props.defaultGenerator,\n                classNameGenerator: // don't use custom classNames if disabled\n                renderProps.isDisabled ? undefined : options.dayCellClassNames,\n                didMount: options.dayCellDidMount,\n                willUnmount: options.dayCellWillUnmount\n            }));\n        }\n    }\n    function hasCustomDayCellContent(options) {\n        return Boolean(options.dayCellContent || hasCustomRenderingHandler('dayCellContent', options));\n    }\n    function refineRenderProps(raw) {\n        let { date, dateEnv, dateProfile, isMonthStart } = raw;\n        let dayMeta = getDateMeta(date, raw.todayRange, null, dateProfile);\n        let dayNumberText = raw.showDayNumber ? dateEnv.format(date, isMonthStart ? raw.monthStartFormat : DAY_NUM_FORMAT) : '';\n        return Object.assign(Object.assign(Object.assign({\n            date: dateEnv.toDate(date),\n            view: raw.viewApi\n        }, dayMeta), {\n            isMonthStart,\n            dayNumberText\n        }), raw.extraRenderProps);\n    }\n    class BgEvent extends BaseComponent {\n        render() {\n            let { props } = this;\n            let { seg } = props;\n            return y(EventContainer, {\n                elTag: \"div\",\n                elClasses: [\n                    'fc-bg-event'\n                ],\n                elStyle: {\n                    backgroundColor: seg.eventRange.ui.backgroundColor\n                },\n                defaultGenerator: renderInnerContent$3,\n                seg: seg,\n                timeText: \"\",\n                isDragging: false,\n                isResizing: false,\n                isDateSelecting: false,\n                isSelected: false,\n                isPast: props.isPast,\n                isFuture: props.isFuture,\n                isToday: props.isToday,\n                disableDragging: true,\n                disableResizing: true\n            });\n        }\n    }\n    function renderInnerContent$3(props) {\n        let { title } = props.event;\n        return title && y(\"div\", {\n            className: \"fc-event-title\"\n        }, props.event.title);\n    }\n    function renderFill(fillType) {\n        return y(\"div\", {\n            className: `fc-${fillType}`\n        });\n    }\n    const WeekNumberContainer = (props)=>y(ViewContextType.Consumer, null, (context)=>{\n            let { dateEnv, options } = context;\n            let { date } = props;\n            let format = options.weekNumberFormat || props.defaultFormat;\n            let num = dateEnv.computeWeekNumber(date); // TODO: somehow use for formatting as well?\n            let text = dateEnv.format(date, format);\n            let renderProps = {\n                num,\n                text,\n                date\n            };\n            return y(ContentContainer // why isn't WeekNumberContentArg being auto-detected?\n            , Object.assign({}, props /* includes children */ , {\n                renderProps: renderProps,\n                generatorName: \"weekNumberContent\",\n                customGenerator: options.weekNumberContent,\n                defaultGenerator: renderInner,\n                classNameGenerator: options.weekNumberClassNames,\n                didMount: options.weekNumberDidMount,\n                willUnmount: options.weekNumberWillUnmount\n            }));\n        });\n    function renderInner(innerProps) {\n        return innerProps.text;\n    }\n    const PADDING_FROM_VIEWPORT = 10;\n    class Popover extends BaseComponent {\n        constructor(){\n            super(...arguments);\n            this.state = {\n                titleId: getUniqueDomId()\n            };\n            this.handleRootEl = (el)=>{\n                this.rootEl = el;\n                if (this.props.elRef) {\n                    setRef(this.props.elRef, el);\n                }\n            };\n            // Triggered when the user clicks *anywhere* in the document, for the autoHide feature\n            this.handleDocumentMouseDown = (ev)=>{\n                // only hide the popover if the click happened outside the popover\n                const target = getEventTargetViaRoot(ev);\n                if (!this.rootEl.contains(target)) {\n                    this.handleCloseClick();\n                }\n            };\n            this.handleDocumentKeyDown = (ev)=>{\n                if (ev.key === 'Escape') {\n                    this.handleCloseClick();\n                }\n            };\n            this.handleCloseClick = ()=>{\n                let { onClose } = this.props;\n                if (onClose) {\n                    onClose();\n                }\n            };\n        }\n        render() {\n            let { theme, options } = this.context;\n            let { props, state } = this;\n            let classNames = [\n                'fc-popover',\n                theme.getClass('popover')\n            ].concat(props.extraClassNames || []);\n            return j(y(\"div\", Object.assign({}, props.extraAttrs, {\n                id: props.id,\n                className: classNames.join(' '),\n                \"aria-labelledby\": state.titleId,\n                ref: this.handleRootEl\n            }), y(\"div\", {\n                className: 'fc-popover-header ' + theme.getClass('popoverHeader')\n            }, y(\"span\", {\n                className: \"fc-popover-title\",\n                id: state.titleId\n            }, props.title), y(\"span\", {\n                className: 'fc-popover-close ' + theme.getIconClass('close'),\n                title: options.closeHint,\n                onClick: this.handleCloseClick\n            })), y(\"div\", {\n                className: 'fc-popover-body ' + theme.getClass('popoverContent')\n            }, props.children)), props.parentEl);\n        }\n        componentDidMount() {\n            document.addEventListener('mousedown', this.handleDocumentMouseDown);\n            document.addEventListener('keydown', this.handleDocumentKeyDown);\n            this.updateSize();\n        }\n        componentWillUnmount() {\n            document.removeEventListener('mousedown', this.handleDocumentMouseDown);\n            document.removeEventListener('keydown', this.handleDocumentKeyDown);\n        }\n        updateSize() {\n            let { isRtl } = this.context;\n            let { alignmentEl, alignGridTop } = this.props;\n            let { rootEl } = this;\n            let alignmentRect = computeClippedClientRect(alignmentEl);\n            if (alignmentRect) {\n                let popoverDims = rootEl.getBoundingClientRect();\n                // position relative to viewport\n                let popoverTop = alignGridTop ? elementClosest(alignmentEl, '.fc-scrollgrid').getBoundingClientRect().top : alignmentRect.top;\n                let popoverLeft = isRtl ? alignmentRect.right - popoverDims.width : alignmentRect.left;\n                // constrain\n                popoverTop = Math.max(popoverTop, PADDING_FROM_VIEWPORT);\n                popoverLeft = Math.min(popoverLeft, document.documentElement.clientWidth - PADDING_FROM_VIEWPORT - popoverDims.width);\n                popoverLeft = Math.max(popoverLeft, PADDING_FROM_VIEWPORT);\n                let origin = rootEl.offsetParent.getBoundingClientRect();\n                applyStyle(rootEl, {\n                    top: popoverTop - origin.top,\n                    left: popoverLeft - origin.left\n                });\n            }\n        }\n    }\n    class MorePopover extends DateComponent {\n        constructor(){\n            super(...arguments);\n            this.handleRootEl = (rootEl)=>{\n                this.rootEl = rootEl;\n                if (rootEl) {\n                    this.context.registerInteractiveComponent(this, {\n                        el: rootEl,\n                        useEventCenter: false\n                    });\n                } else {\n                    this.context.unregisterInteractiveComponent(this);\n                }\n            };\n        }\n        render() {\n            let { options, dateEnv } = this.context;\n            let { props } = this;\n            let { startDate, todayRange, dateProfile } = props;\n            let title = dateEnv.format(startDate, options.dayPopoverFormat);\n            return y(DayCellContainer, {\n                elRef: this.handleRootEl,\n                date: startDate,\n                dateProfile: dateProfile,\n                todayRange: todayRange\n            }, (InnerContent, renderProps, elAttrs)=>y(Popover, {\n                    elRef: elAttrs.ref,\n                    id: props.id,\n                    title: title,\n                    extraClassNames: [\n                        'fc-more-popover'\n                    ].concat(elAttrs.className || []),\n                    extraAttrs: elAttrs /* TODO: make these time-based when not whole-day? */ ,\n                    parentEl: props.parentEl,\n                    alignmentEl: props.alignmentEl,\n                    alignGridTop: props.alignGridTop,\n                    onClose: props.onClose\n                }, hasCustomDayCellContent(options) && y(InnerContent, {\n                    elTag: \"div\",\n                    elClasses: [\n                        'fc-more-popover-misc'\n                    ]\n                }), props.children));\n        }\n        queryHit(positionLeft, positionTop, elWidth, elHeight) {\n            let { rootEl, props } = this;\n            if (positionLeft >= 0 && positionLeft < elWidth && positionTop >= 0 && positionTop < elHeight) {\n                return {\n                    dateProfile: props.dateProfile,\n                    dateSpan: Object.assign({\n                        allDay: !props.forceTimed,\n                        range: {\n                            start: props.startDate,\n                            end: props.endDate\n                        }\n                    }, props.extraDateSpan),\n                    dayEl: rootEl,\n                    rect: {\n                        left: 0,\n                        top: 0,\n                        right: elWidth,\n                        bottom: elHeight\n                    },\n                    layer: 1\n                };\n            }\n            return null;\n        }\n    }\n    class MoreLinkContainer extends BaseComponent {\n        constructor(){\n            super(...arguments);\n            this.state = {\n                isPopoverOpen: false,\n                popoverId: getUniqueDomId()\n            };\n            this.handleLinkEl = (linkEl)=>{\n                this.linkEl = linkEl;\n                if (this.props.elRef) {\n                    setRef(this.props.elRef, linkEl);\n                }\n            };\n            this.handleClick = (ev)=>{\n                let { props, context } = this;\n                let { moreLinkClick } = context.options;\n                let date = computeRange(props).start;\n                function buildPublicSeg(seg) {\n                    let { def, instance, range } = seg.eventRange;\n                    return {\n                        event: new EventImpl(context, def, instance),\n                        start: context.dateEnv.toDate(range.start),\n                        end: context.dateEnv.toDate(range.end),\n                        isStart: seg.isStart,\n                        isEnd: seg.isEnd\n                    };\n                }\n                if (typeof moreLinkClick === 'function') {\n                    moreLinkClick = moreLinkClick({\n                        date,\n                        allDay: Boolean(props.allDayDate),\n                        allSegs: props.allSegs.map(buildPublicSeg),\n                        hiddenSegs: props.hiddenSegs.map(buildPublicSeg),\n                        jsEvent: ev,\n                        view: context.viewApi\n                    });\n                }\n                if (!moreLinkClick || moreLinkClick === 'popover') {\n                    this.setState({\n                        isPopoverOpen: true\n                    });\n                } else if (typeof moreLinkClick === 'string') {\n                    context.calendarApi.zoomTo(date, moreLinkClick);\n                }\n            };\n            this.handlePopoverClose = ()=>{\n                this.setState({\n                    isPopoverOpen: false\n                });\n            };\n        }\n        render() {\n            let { props, state } = this;\n            return y(ViewContextType.Consumer, null, (context)=>{\n                let { viewApi, options, calendarApi } = context;\n                let { moreLinkText } = options;\n                let { moreCnt } = props;\n                let range = computeRange(props);\n                let text = typeof moreLinkText === 'function' // TODO: eventually use formatWithOrdinals\n                 ? moreLinkText.call(calendarApi, moreCnt) : `+${moreCnt} ${moreLinkText}`;\n                let hint = formatWithOrdinals(options.moreLinkHint, [\n                    moreCnt\n                ], text);\n                let renderProps = {\n                    num: moreCnt,\n                    shortText: `+${moreCnt}`,\n                    text,\n                    view: viewApi\n                };\n                return y(_, null, Boolean(props.moreCnt) && y(ContentContainer, {\n                    elTag: props.elTag || 'a',\n                    elRef: this.handleLinkEl,\n                    elClasses: [\n                        ...props.elClasses || [],\n                        'fc-more-link'\n                    ],\n                    elStyle: props.elStyle,\n                    elAttrs: Object.assign(Object.assign(Object.assign({}, props.elAttrs), createAriaClickAttrs(this.handleClick)), {\n                        title: hint,\n                        'aria-expanded': state.isPopoverOpen,\n                        'aria-controls': state.isPopoverOpen ? state.popoverId : ''\n                    }),\n                    renderProps: renderProps,\n                    generatorName: \"moreLinkContent\",\n                    customGenerator: options.moreLinkContent,\n                    defaultGenerator: props.defaultGenerator || renderMoreLinkInner$1,\n                    classNameGenerator: options.moreLinkClassNames,\n                    didMount: options.moreLinkDidMount,\n                    willUnmount: options.moreLinkWillUnmount\n                }, props.children), state.isPopoverOpen && y(MorePopover, {\n                    id: state.popoverId,\n                    startDate: range.start,\n                    endDate: range.end,\n                    dateProfile: props.dateProfile,\n                    todayRange: props.todayRange,\n                    extraDateSpan: props.extraDateSpan,\n                    parentEl: this.parentEl,\n                    alignmentEl: props.alignmentElRef ? props.alignmentElRef.current : this.linkEl,\n                    alignGridTop: props.alignGridTop,\n                    forceTimed: props.forceTimed,\n                    onClose: this.handlePopoverClose\n                }, props.popoverContent()));\n            });\n        }\n        componentDidMount() {\n            this.updateParentEl();\n        }\n        componentDidUpdate() {\n            this.updateParentEl();\n        }\n        updateParentEl() {\n            if (this.linkEl) {\n                this.parentEl = elementClosest(this.linkEl, '.fc-view-harness');\n            }\n        }\n    }\n    function renderMoreLinkInner$1(props) {\n        return props.text;\n    }\n    function computeRange(props) {\n        if (props.allDayDate) {\n            return {\n                start: props.allDayDate,\n                end: addDays(props.allDayDate, 1)\n            };\n        }\n        let { hiddenSegs } = props;\n        return {\n            start: computeEarliestSegStart(hiddenSegs),\n            end: computeLatestSegEnd(hiddenSegs)\n        };\n    }\n    function computeEarliestSegStart(segs) {\n        return segs.reduce(pickEarliestStart).eventRange.range.start;\n    }\n    function pickEarliestStart(seg0, seg1) {\n        return seg0.eventRange.range.start < seg1.eventRange.range.start ? seg0 : seg1;\n    }\n    function computeLatestSegEnd(segs) {\n        return segs.reduce(pickLatestEnd).eventRange.range.end;\n    }\n    function pickLatestEnd(seg0, seg1) {\n        return seg0.eventRange.range.end > seg1.eventRange.range.end ? seg0 : seg1;\n    }\n    class ViewContainer extends BaseComponent {\n        render() {\n            let { props, context } = this;\n            let { options } = context;\n            let renderProps = {\n                view: context.viewApi\n            };\n            return y(ContentContainer, Object.assign({}, props, {\n                elTag: props.elTag || 'div',\n                elClasses: [\n                    ...buildViewClassNames(props.viewSpec),\n                    ...props.elClasses || []\n                ],\n                renderProps: renderProps,\n                classNameGenerator: options.viewClassNames,\n                generatorName: undefined,\n                didMount: options.viewDidMount,\n                willUnmount: options.viewWillUnmount\n            }), ()=>props.children);\n        }\n    }\n    function buildViewClassNames(viewSpec) {\n        return [\n            `fc-${viewSpec.type}-view`,\n            'fc-view'\n        ];\n    }\n    const EVENT_SOURCE_REFINERS = {\n        id: String,\n        defaultAllDay: Boolean,\n        url: String,\n        format: String,\n        events: identity,\n        eventDataTransform: identity,\n        // for any network-related sources\n        success: identity,\n        failure: identity\n    };\n    function parseEventSource(raw, context, refiners = buildEventSourceRefiners(context)) {\n        let rawObj;\n        if (typeof raw === 'string') {\n            rawObj = {\n                url: raw\n            };\n        } else if (typeof raw === 'function' || Array.isArray(raw)) {\n            rawObj = {\n                events: raw\n            };\n        } else if (typeof raw === 'object' && raw) {\n            rawObj = raw;\n        }\n        if (rawObj) {\n            let { refined, extra } = refineProps(rawObj, refiners);\n            let metaRes = buildEventSourceMeta(refined, context);\n            if (metaRes) {\n                return {\n                    _raw: raw,\n                    isFetching: false,\n                    latestFetchId: '',\n                    fetchRange: null,\n                    defaultAllDay: refined.defaultAllDay,\n                    eventDataTransform: refined.eventDataTransform,\n                    success: refined.success,\n                    failure: refined.failure,\n                    publicId: refined.id || '',\n                    sourceId: guid(),\n                    sourceDefId: metaRes.sourceDefId,\n                    meta: metaRes.meta,\n                    ui: createEventUi(refined, context),\n                    extendedProps: extra\n                };\n            }\n        }\n        return null;\n    }\n    function buildEventSourceRefiners(context) {\n        return Object.assign(Object.assign(Object.assign({}, EVENT_UI_REFINERS), EVENT_SOURCE_REFINERS), context.pluginHooks.eventSourceRefiners);\n    }\n    function buildEventSourceMeta(raw, context) {\n        let defs = context.pluginHooks.eventSourceDefs;\n        for(let i = defs.length - 1; i >= 0; i -= 1){\n            let def = defs[i];\n            let meta = def.parseMeta(raw);\n            if (meta) {\n                return {\n                    sourceDefId: i,\n                    meta\n                };\n            }\n        }\n        return null;\n    }\n    class CalendarImpl {\n        getCurrentData() {\n            return this.currentDataManager.getCurrentData();\n        }\n        dispatch(action) {\n            this.currentDataManager.dispatch(action);\n        }\n        get view() {\n            return this.getCurrentData().viewApi;\n        }\n        batchRendering(callback) {\n            callback();\n        }\n        updateSize() {\n            this.trigger('_resize', true);\n        }\n        // Options\n        // -----------------------------------------------------------------------------------------------------------------\n        setOption(name, val) {\n            this.dispatch({\n                type: 'SET_OPTION',\n                optionName: name,\n                rawOptionValue: val\n            });\n        }\n        getOption(name) {\n            return this.currentDataManager.currentCalendarOptionsInput[name];\n        }\n        getAvailableLocaleCodes() {\n            return Object.keys(this.getCurrentData().availableRawLocales);\n        }\n        // Trigger\n        // -----------------------------------------------------------------------------------------------------------------\n        on(handlerName, handler) {\n            let { currentDataManager } = this;\n            if (currentDataManager.currentCalendarOptionsRefiners[handlerName]) {\n                currentDataManager.emitter.on(handlerName, handler);\n            } else {\n                console.warn(`Unknown listener name '${handlerName}'`);\n            }\n        }\n        off(handlerName, handler) {\n            this.currentDataManager.emitter.off(handlerName, handler);\n        }\n        // not meant for public use\n        trigger(handlerName, ...args) {\n            this.currentDataManager.emitter.trigger(handlerName, ...args);\n        }\n        // View\n        // -----------------------------------------------------------------------------------------------------------------\n        changeView(viewType, dateOrRange) {\n            this.batchRendering(()=>{\n                this.unselect();\n                if (dateOrRange) {\n                    if (dateOrRange.start && dateOrRange.end) {\n                        this.dispatch({\n                            type: 'CHANGE_VIEW_TYPE',\n                            viewType\n                        });\n                        this.dispatch({\n                            type: 'SET_OPTION',\n                            optionName: 'visibleRange',\n                            rawOptionValue: dateOrRange\n                        });\n                    } else {\n                        let { dateEnv } = this.getCurrentData();\n                        this.dispatch({\n                            type: 'CHANGE_VIEW_TYPE',\n                            viewType,\n                            dateMarker: dateEnv.createMarker(dateOrRange)\n                        });\n                    }\n                } else {\n                    this.dispatch({\n                        type: 'CHANGE_VIEW_TYPE',\n                        viewType\n                    });\n                }\n            });\n        }\n        // Forces navigation to a view for the given date.\n        // `viewType` can be a specific view name or a generic one like \"week\" or \"day\".\n        // needs to change\n        zoomTo(dateMarker, viewType) {\n            let state = this.getCurrentData();\n            let spec;\n            viewType = viewType || 'day'; // day is default zoom\n            spec = state.viewSpecs[viewType] || this.getUnitViewSpec(viewType);\n            this.unselect();\n            if (spec) {\n                this.dispatch({\n                    type: 'CHANGE_VIEW_TYPE',\n                    viewType: spec.type,\n                    dateMarker\n                });\n            } else {\n                this.dispatch({\n                    type: 'CHANGE_DATE',\n                    dateMarker\n                });\n            }\n        }\n        // Given a duration singular unit, like \"week\" or \"day\", finds a matching view spec.\n        // Preference is given to views that have corresponding buttons.\n        getUnitViewSpec(unit) {\n            let { viewSpecs, toolbarConfig } = this.getCurrentData();\n            let viewTypes = [].concat(toolbarConfig.header ? toolbarConfig.header.viewsWithButtons : [], toolbarConfig.footer ? toolbarConfig.footer.viewsWithButtons : []);\n            let i;\n            let spec;\n            for(let viewType in viewSpecs){\n                viewTypes.push(viewType);\n            }\n            for(i = 0; i < viewTypes.length; i += 1){\n                spec = viewSpecs[viewTypes[i]];\n                if (spec) {\n                    if (spec.singleUnit === unit) {\n                        return spec;\n                    }\n                }\n            }\n            return null;\n        }\n        // Current Date\n        // -----------------------------------------------------------------------------------------------------------------\n        prev() {\n            this.unselect();\n            this.dispatch({\n                type: 'PREV'\n            });\n        }\n        next() {\n            this.unselect();\n            this.dispatch({\n                type: 'NEXT'\n            });\n        }\n        prevYear() {\n            let state = this.getCurrentData();\n            this.unselect();\n            this.dispatch({\n                type: 'CHANGE_DATE',\n                dateMarker: state.dateEnv.addYears(state.currentDate, -1)\n            });\n        }\n        nextYear() {\n            let state = this.getCurrentData();\n            this.unselect();\n            this.dispatch({\n                type: 'CHANGE_DATE',\n                dateMarker: state.dateEnv.addYears(state.currentDate, 1)\n            });\n        }\n        today() {\n            let state = this.getCurrentData();\n            this.unselect();\n            this.dispatch({\n                type: 'CHANGE_DATE',\n                dateMarker: getNow(state.calendarOptions.now, state.dateEnv)\n            });\n        }\n        gotoDate(zonedDateInput) {\n            let state = this.getCurrentData();\n            this.unselect();\n            this.dispatch({\n                type: 'CHANGE_DATE',\n                dateMarker: state.dateEnv.createMarker(zonedDateInput)\n            });\n        }\n        incrementDate(deltaInput) {\n            let state = this.getCurrentData();\n            let delta = createDuration(deltaInput);\n            if (delta) {\n                this.unselect();\n                this.dispatch({\n                    type: 'CHANGE_DATE',\n                    dateMarker: state.dateEnv.add(state.currentDate, delta)\n                });\n            }\n        }\n        getDate() {\n            let state = this.getCurrentData();\n            return state.dateEnv.toDate(state.currentDate);\n        }\n        // Date Formatting Utils\n        // -----------------------------------------------------------------------------------------------------------------\n        formatDate(d, formatter) {\n            let { dateEnv } = this.getCurrentData();\n            return dateEnv.format(dateEnv.createMarker(d), createFormatter(formatter));\n        }\n        // `settings` is for formatter AND isEndExclusive\n        formatRange(d0, d1, settings) {\n            let { dateEnv } = this.getCurrentData();\n            return dateEnv.formatRange(dateEnv.createMarker(d0), dateEnv.createMarker(d1), createFormatter(settings), settings);\n        }\n        formatIso(d, omitTime) {\n            let { dateEnv } = this.getCurrentData();\n            return dateEnv.formatIso(dateEnv.createMarker(d), {\n                omitTime\n            });\n        }\n        // Date Selection / Event Selection / DayClick\n        // -----------------------------------------------------------------------------------------------------------------\n        select(dateOrObj, endDate) {\n            let selectionInput;\n            if (endDate == null) {\n                if (dateOrObj.start != null) {\n                    selectionInput = dateOrObj;\n                } else {\n                    selectionInput = {\n                        start: dateOrObj,\n                        end: null\n                    };\n                }\n            } else {\n                selectionInput = {\n                    start: dateOrObj,\n                    end: endDate\n                };\n            }\n            let state = this.getCurrentData();\n            let selection = parseDateSpan(selectionInput, state.dateEnv, createDuration({\n                days: 1\n            }));\n            if (selection) {\n                this.dispatch({\n                    type: 'SELECT_DATES',\n                    selection\n                });\n                triggerDateSelect(selection, null, state);\n            }\n        }\n        unselect(pev) {\n            let state = this.getCurrentData();\n            if (state.dateSelection) {\n                this.dispatch({\n                    type: 'UNSELECT_DATES'\n                });\n                triggerDateUnselect(pev, state);\n            }\n        }\n        // Public Events API\n        // -----------------------------------------------------------------------------------------------------------------\n        addEvent(eventInput, sourceInput) {\n            if (eventInput instanceof EventImpl) {\n                let def = eventInput._def;\n                let instance = eventInput._instance;\n                let currentData = this.getCurrentData();\n                // not already present? don't want to add an old snapshot\n                if (!currentData.eventStore.defs[def.defId]) {\n                    this.dispatch({\n                        type: 'ADD_EVENTS',\n                        eventStore: eventTupleToStore({\n                            def,\n                            instance\n                        })\n                    });\n                    this.triggerEventAdd(eventInput);\n                }\n                return eventInput;\n            }\n            let state = this.getCurrentData();\n            let eventSource;\n            if (sourceInput instanceof EventSourceImpl) {\n                eventSource = sourceInput.internalEventSource;\n            } else if (typeof sourceInput === 'boolean') {\n                if (sourceInput) {\n                    [eventSource] = hashValuesToArray(state.eventSources);\n                }\n            } else if (sourceInput != null) {\n                let sourceApi = this.getEventSourceById(sourceInput); // TODO: use an internal function\n                if (!sourceApi) {\n                    console.warn(`Could not find an event source with ID \"${sourceInput}\"`); // TODO: test\n                    return null;\n                }\n                eventSource = sourceApi.internalEventSource;\n            }\n            let tuple = parseEvent(eventInput, eventSource, state, false);\n            if (tuple) {\n                let newEventApi = new EventImpl(state, tuple.def, tuple.def.recurringDef ? null : tuple.instance);\n                this.dispatch({\n                    type: 'ADD_EVENTS',\n                    eventStore: eventTupleToStore(tuple)\n                });\n                this.triggerEventAdd(newEventApi);\n                return newEventApi;\n            }\n            return null;\n        }\n        triggerEventAdd(eventApi) {\n            let { emitter } = this.getCurrentData();\n            emitter.trigger('eventAdd', {\n                event: eventApi,\n                relatedEvents: [],\n                revert: ()=>{\n                    this.dispatch({\n                        type: 'REMOVE_EVENTS',\n                        eventStore: eventApiToStore(eventApi)\n                    });\n                }\n            });\n        }\n        // TODO: optimize\n        getEventById(id) {\n            let state = this.getCurrentData();\n            let { defs, instances } = state.eventStore;\n            id = String(id);\n            for(let defId in defs){\n                let def = defs[defId];\n                if (def.publicId === id) {\n                    if (def.recurringDef) {\n                        return new EventImpl(state, def, null);\n                    }\n                    for(let instanceId in instances){\n                        let instance = instances[instanceId];\n                        if (instance.defId === def.defId) {\n                            return new EventImpl(state, def, instance);\n                        }\n                    }\n                }\n            }\n            return null;\n        }\n        getEvents() {\n            let currentData = this.getCurrentData();\n            return buildEventApis(currentData.eventStore, currentData);\n        }\n        removeAllEvents() {\n            this.dispatch({\n                type: 'REMOVE_ALL_EVENTS'\n            });\n        }\n        // Public Event Sources API\n        // -----------------------------------------------------------------------------------------------------------------\n        getEventSources() {\n            let state = this.getCurrentData();\n            let sourceHash = state.eventSources;\n            let sourceApis = [];\n            for(let internalId in sourceHash){\n                sourceApis.push(new EventSourceImpl(state, sourceHash[internalId]));\n            }\n            return sourceApis;\n        }\n        getEventSourceById(id) {\n            let state = this.getCurrentData();\n            let sourceHash = state.eventSources;\n            id = String(id);\n            for(let sourceId in sourceHash){\n                if (sourceHash[sourceId].publicId === id) {\n                    return new EventSourceImpl(state, sourceHash[sourceId]);\n                }\n            }\n            return null;\n        }\n        addEventSource(sourceInput) {\n            let state = this.getCurrentData();\n            if (sourceInput instanceof EventSourceImpl) {\n                // not already present? don't want to add an old snapshot\n                if (!state.eventSources[sourceInput.internalEventSource.sourceId]) {\n                    this.dispatch({\n                        type: 'ADD_EVENT_SOURCES',\n                        sources: [\n                            sourceInput.internalEventSource\n                        ]\n                    });\n                }\n                return sourceInput;\n            }\n            let eventSource = parseEventSource(sourceInput, state);\n            if (eventSource) {\n                this.dispatch({\n                    type: 'ADD_EVENT_SOURCES',\n                    sources: [\n                        eventSource\n                    ]\n                });\n                return new EventSourceImpl(state, eventSource);\n            }\n            return null;\n        }\n        removeAllEventSources() {\n            this.dispatch({\n                type: 'REMOVE_ALL_EVENT_SOURCES'\n            });\n        }\n        refetchEvents() {\n            this.dispatch({\n                type: 'FETCH_EVENT_SOURCES',\n                isRefetch: true\n            });\n        }\n        // Scroll\n        // -----------------------------------------------------------------------------------------------------------------\n        scrollToTime(timeInput) {\n            let time = createDuration(timeInput);\n            if (time) {\n                this.trigger('_scrollRequest', {\n                    time\n                });\n            }\n        }\n    }\n    class Store {\n        constructor(){\n            this.handlers = [];\n        }\n        set(value) {\n            this.currentValue = value;\n            for (let handler of this.handlers){\n                handler(value);\n            }\n        }\n        subscribe(handler) {\n            this.handlers.push(handler);\n            if (this.currentValue !== undefined) {\n                handler(this.currentValue);\n            }\n        }\n    }\n    /*\r\n    Subscribers will get a LIST of CustomRenderings\r\n    */ class CustomRenderingStore extends Store {\n        constructor(){\n            super(...arguments);\n            this.map = new Map();\n        }\n        // for consistent order\n        handle(customRendering) {\n            const { map } = this;\n            let updated = false;\n            if (customRendering.isActive) {\n                map.set(customRendering.id, customRendering);\n                updated = true;\n            } else if (map.has(customRendering.id)) {\n                map.delete(customRendering.id);\n                updated = true;\n            }\n            if (updated) {\n                this.set(map);\n            }\n        }\n    }\n    var internal = {\n        __proto__: null,\n        BASE_OPTION_DEFAULTS: BASE_OPTION_DEFAULTS,\n        BaseComponent: BaseComponent,\n        BgEvent: BgEvent,\n        CalendarImpl: CalendarImpl,\n        CalendarRoot: CalendarRoot,\n        ContentContainer: ContentContainer,\n        CustomRenderingStore: CustomRenderingStore,\n        DateComponent: DateComponent,\n        DateEnv: DateEnv,\n        DateProfileGenerator: DateProfileGenerator,\n        DayCellContainer: DayCellContainer,\n        DayHeader: DayHeader,\n        DaySeriesModel: DaySeriesModel,\n        DayTableModel: DayTableModel,\n        DelayedRunner: DelayedRunner,\n        ElementDragging: ElementDragging,\n        ElementScrollController: ElementScrollController,\n        Emitter: Emitter,\n        EventContainer: EventContainer,\n        EventImpl: EventImpl,\n        Interaction: Interaction,\n        MoreLinkContainer: MoreLinkContainer,\n        NamedTimeZoneImpl: NamedTimeZoneImpl,\n        NowIndicatorContainer: NowIndicatorContainer,\n        NowTimer: NowTimer,\n        PositionCache: PositionCache,\n        RefMap: RefMap,\n        ScrollController: ScrollController,\n        ScrollResponder: ScrollResponder,\n        Scroller: Scroller,\n        SegHierarchy: SegHierarchy,\n        SimpleScrollGrid: SimpleScrollGrid,\n        Slicer: Slicer,\n        Splitter: Splitter,\n        StandardEvent: StandardEvent,\n        TableDateCell: TableDateCell,\n        TableDowCell: TableDowCell,\n        Theme: Theme,\n        ViewContainer: ViewContainer,\n        ViewContextType: ViewContextType,\n        WeekNumberContainer: WeekNumberContainer,\n        WindowScrollController: WindowScrollController,\n        addDays: addDays,\n        addDurations: addDurations,\n        addMs: addMs,\n        addWeeks: addWeeks,\n        allowContextMenu: allowContextMenu,\n        allowSelection: allowSelection,\n        applyMutationToEventStore: applyMutationToEventStore,\n        applyStyle: applyStyle,\n        asCleanDays: asCleanDays,\n        asRoughMinutes: asRoughMinutes,\n        asRoughMs: asRoughMs,\n        asRoughSeconds: asRoughSeconds,\n        binarySearch: binarySearch,\n        buildElAttrs: buildElAttrs,\n        buildEntryKey: buildEntryKey,\n        buildEventApis: buildEventApis,\n        buildEventRangeKey: buildEventRangeKey,\n        buildIsoString: buildIsoString,\n        buildNavLinkAttrs: buildNavLinkAttrs,\n        buildSegTimeText: buildSegTimeText,\n        collectFromHash: collectFromHash,\n        combineEventUis: combineEventUis,\n        compareByFieldSpecs: compareByFieldSpecs,\n        compareNumbers: compareNumbers,\n        compareObjs: compareObjs,\n        computeEarliestSegStart: computeEarliestSegStart,\n        computeEdges: computeEdges,\n        computeFallbackHeaderFormat: computeFallbackHeaderFormat,\n        computeInnerRect: computeInnerRect,\n        computeRect: computeRect,\n        computeShrinkWidth: computeShrinkWidth,\n        computeVisibleDayRange: computeVisibleDayRange,\n        config: config,\n        constrainPoint: constrainPoint,\n        createDuration: createDuration,\n        createEmptyEventStore: createEmptyEventStore,\n        createEventInstance: createEventInstance,\n        createEventUi: createEventUi,\n        createFormatter: createFormatter,\n        diffDates: diffDates,\n        diffDayAndTime: diffDayAndTime,\n        diffDays: diffDays,\n        diffPoints: diffPoints,\n        diffWeeks: diffWeeks,\n        diffWholeDays: diffWholeDays,\n        diffWholeWeeks: diffWholeWeeks,\n        disableCursor: disableCursor,\n        elementClosest: elementClosest,\n        elementMatches: elementMatches,\n        enableCursor: enableCursor,\n        eventTupleToStore: eventTupleToStore,\n        filterHash: filterHash,\n        findDirectChildren: findDirectChildren,\n        findElements: findElements,\n        flexibleCompare: flexibleCompare,\n        formatDayString: formatDayString,\n        formatIsoMonthStr: formatIsoMonthStr,\n        formatIsoTimeString: formatIsoTimeString,\n        getAllowYScrolling: getAllowYScrolling,\n        getCanVGrowWithinCell: getCanVGrowWithinCell,\n        getClippingParents: getClippingParents,\n        getDateMeta: getDateMeta,\n        getDayClassNames: getDayClassNames,\n        getDefaultEventEnd: getDefaultEventEnd,\n        getElSeg: getElSeg,\n        getEntrySpanEnd: getEntrySpanEnd,\n        getEventTargetViaRoot: getEventTargetViaRoot,\n        getIsRtlScrollbarOnLeft: getIsRtlScrollbarOnLeft,\n        getRectCenter: getRectCenter,\n        getRelevantEvents: getRelevantEvents,\n        getScrollGridClassNames: getScrollGridClassNames,\n        getScrollbarWidths: getScrollbarWidths,\n        getSectionClassNames: getSectionClassNames,\n        getSectionHasLiquidHeight: getSectionHasLiquidHeight,\n        getSegAnchorAttrs: getSegAnchorAttrs,\n        getSegMeta: getSegMeta,\n        getSlotClassNames: getSlotClassNames,\n        getStickyFooterScrollbar: getStickyFooterScrollbar,\n        getStickyHeaderDates: getStickyHeaderDates,\n        getUniqueDomId: getUniqueDomId,\n        greatestDurationDenominator: greatestDurationDenominator,\n        groupIntersectingEntries: groupIntersectingEntries,\n        guid: guid,\n        hasBgRendering: hasBgRendering,\n        hasCustomDayCellContent: hasCustomDayCellContent,\n        hasShrinkWidth: hasShrinkWidth,\n        identity: identity,\n        injectStyles: injectStyles,\n        interactionSettingsStore: interactionSettingsStore,\n        interactionSettingsToStore: interactionSettingsToStore,\n        intersectRanges: intersectRanges,\n        intersectRects: intersectRects,\n        intersectSpans: intersectSpans,\n        isArraysEqual: isArraysEqual,\n        isColPropsEqual: isColPropsEqual,\n        isDateSelectionValid: isDateSelectionValid,\n        isDateSpansEqual: isDateSpansEqual,\n        isInt: isInt,\n        isInteractionValid: isInteractionValid,\n        isMultiDayRange: isMultiDayRange,\n        isPropsEqual: isPropsEqual,\n        isPropsValid: isPropsValid,\n        isValidDate: isValidDate,\n        mapHash: mapHash,\n        memoize: memoize,\n        memoizeArraylike: memoizeArraylike,\n        memoizeHashlike: memoizeHashlike,\n        memoizeObjArg: memoizeObjArg,\n        mergeEventStores: mergeEventStores,\n        multiplyDuration: multiplyDuration,\n        padStart: padStart,\n        parseBusinessHours: parseBusinessHours,\n        parseClassNames: parseClassNames,\n        parseDragMeta: parseDragMeta,\n        parseEventDef: parseEventDef,\n        parseFieldSpecs: parseFieldSpecs,\n        parseMarker: parse,\n        pointInsideRect: pointInsideRect,\n        preventContextMenu: preventContextMenu,\n        preventDefault: preventDefault,\n        preventSelection: preventSelection,\n        rangeContainsMarker: rangeContainsMarker,\n        rangeContainsRange: rangeContainsRange,\n        rangesEqual: rangesEqual,\n        rangesIntersect: rangesIntersect,\n        refineEventDef: refineEventDef,\n        refineProps: refineProps,\n        removeElement: removeElement,\n        removeExact: removeExact,\n        renderChunkContent: renderChunkContent,\n        renderFill: renderFill,\n        renderMicroColGroup: renderMicroColGroup,\n        renderScrollShim: renderScrollShim,\n        requestJson: requestJson,\n        sanitizeShrinkWidth: sanitizeShrinkWidth,\n        setRef: setRef,\n        sliceEventStore: sliceEventStore,\n        sortEventSegs: sortEventSegs,\n        startOfDay: startOfDay,\n        translateRect: translateRect,\n        triggerDateSelect: triggerDateSelect,\n        unpromisify: unpromisify,\n        whenTransitionDone: whenTransitionDone,\n        wholeDivideDurations: wholeDivideDurations\n    };\n    var preact = {\n        __proto__: null,\n        createPortal: j,\n        createContext: createContext,\n        flushSync: flushSync,\n        Component: x$1,\n        Fragment: _,\n        cloneElement: F$1,\n        createElement: y,\n        createRef: d,\n        h: y,\n        hydrate: E,\n        get isValidElement () {\n            return i$1;\n        },\n        get options () {\n            return l$1;\n        },\n        render: D$1,\n        toChildArray: j$2\n    };\n    const globalLocales = [];\n    const MINIMAL_RAW_EN_LOCALE = {\n        code: 'en',\n        week: {\n            dow: 0,\n            doy: 4\n        },\n        direction: 'ltr',\n        buttonText: {\n            prev: 'prev',\n            next: 'next',\n            prevYear: 'prev year',\n            nextYear: 'next year',\n            year: 'year',\n            today: 'today',\n            month: 'month',\n            week: 'week',\n            day: 'day',\n            list: 'list'\n        },\n        weekText: 'W',\n        weekTextLong: 'Week',\n        closeHint: 'Close',\n        timeHint: 'Time',\n        eventHint: 'Event',\n        allDayText: 'all-day',\n        moreLinkText: 'more',\n        noEventsText: 'No events to display'\n    };\n    const RAW_EN_LOCALE = Object.assign(Object.assign({}, MINIMAL_RAW_EN_LOCALE), {\n        // Includes things we don't want other locales to inherit,\n        // things that derive from other translatable strings.\n        buttonHints: {\n            prev: 'Previous $0',\n            next: 'Next $0',\n            today (buttonText, unit) {\n                return unit === 'day' ? 'Today' : `This ${buttonText}`;\n            }\n        },\n        viewHint: '$0 view',\n        navLinkHint: 'Go to $0',\n        moreLinkHint (eventCnt) {\n            return `Show ${eventCnt} more event${eventCnt === 1 ? '' : 's'}`;\n        }\n    });\n    function organizeRawLocales(explicitRawLocales) {\n        let defaultCode = explicitRawLocales.length > 0 ? explicitRawLocales[0].code : 'en';\n        let allRawLocales = globalLocales.concat(explicitRawLocales);\n        let rawLocaleMap = {\n            en: RAW_EN_LOCALE\n        };\n        for (let rawLocale of allRawLocales){\n            rawLocaleMap[rawLocale.code] = rawLocale;\n        }\n        return {\n            map: rawLocaleMap,\n            defaultCode\n        };\n    }\n    function buildLocale(inputSingular, available) {\n        if (typeof inputSingular === 'object' && !Array.isArray(inputSingular)) {\n            return parseLocale(inputSingular.code, [\n                inputSingular.code\n            ], inputSingular);\n        }\n        return queryLocale(inputSingular, available);\n    }\n    function queryLocale(codeArg, available) {\n        let codes = [].concat(codeArg || []); // will convert to array\n        let raw = queryRawLocale(codes, available) || RAW_EN_LOCALE;\n        return parseLocale(codeArg, codes, raw);\n    }\n    function queryRawLocale(codes, available) {\n        for(let i = 0; i < codes.length; i += 1){\n            let parts = codes[i].toLocaleLowerCase().split('-');\n            for(let j = parts.length; j > 0; j -= 1){\n                let simpleId = parts.slice(0, j).join('-');\n                if (available[simpleId]) {\n                    return available[simpleId];\n                }\n            }\n        }\n        return null;\n    }\n    function parseLocale(codeArg, codes, raw) {\n        let merged = mergeProps([\n            MINIMAL_RAW_EN_LOCALE,\n            raw\n        ], [\n            'buttonText'\n        ]);\n        delete merged.code; // don't want this part of the options\n        let { week } = merged;\n        delete merged.week;\n        return {\n            codeArg,\n            codes,\n            week,\n            simpleNumberFormat: new Intl.NumberFormat(codeArg),\n            options: merged\n        };\n    }\n    // TODO: easier way to add new hooks? need to update a million things\n    function createPlugin(input) {\n        return {\n            id: guid(),\n            name: input.name,\n            premiumReleaseDate: input.premiumReleaseDate ? new Date(input.premiumReleaseDate) : undefined,\n            deps: input.deps || [],\n            reducers: input.reducers || [],\n            isLoadingFuncs: input.isLoadingFuncs || [],\n            contextInit: [].concat(input.contextInit || []),\n            eventRefiners: input.eventRefiners || {},\n            eventDefMemberAdders: input.eventDefMemberAdders || [],\n            eventSourceRefiners: input.eventSourceRefiners || {},\n            isDraggableTransformers: input.isDraggableTransformers || [],\n            eventDragMutationMassagers: input.eventDragMutationMassagers || [],\n            eventDefMutationAppliers: input.eventDefMutationAppliers || [],\n            dateSelectionTransformers: input.dateSelectionTransformers || [],\n            datePointTransforms: input.datePointTransforms || [],\n            dateSpanTransforms: input.dateSpanTransforms || [],\n            views: input.views || {},\n            viewPropsTransformers: input.viewPropsTransformers || [],\n            isPropsValid: input.isPropsValid || null,\n            externalDefTransforms: input.externalDefTransforms || [],\n            viewContainerAppends: input.viewContainerAppends || [],\n            eventDropTransformers: input.eventDropTransformers || [],\n            componentInteractions: input.componentInteractions || [],\n            calendarInteractions: input.calendarInteractions || [],\n            themeClasses: input.themeClasses || {},\n            eventSourceDefs: input.eventSourceDefs || [],\n            cmdFormatter: input.cmdFormatter,\n            recurringTypes: input.recurringTypes || [],\n            namedTimeZonedImpl: input.namedTimeZonedImpl,\n            initialView: input.initialView || '',\n            elementDraggingImpl: input.elementDraggingImpl,\n            optionChangeHandlers: input.optionChangeHandlers || {},\n            scrollGridImpl: input.scrollGridImpl || null,\n            listenerRefiners: input.listenerRefiners || {},\n            optionRefiners: input.optionRefiners || {},\n            propSetHandlers: input.propSetHandlers || {}\n        };\n    }\n    function buildPluginHooks(pluginDefs, globalDefs) {\n        let currentPluginIds = {};\n        let hooks = {\n            premiumReleaseDate: undefined,\n            reducers: [],\n            isLoadingFuncs: [],\n            contextInit: [],\n            eventRefiners: {},\n            eventDefMemberAdders: [],\n            eventSourceRefiners: {},\n            isDraggableTransformers: [],\n            eventDragMutationMassagers: [],\n            eventDefMutationAppliers: [],\n            dateSelectionTransformers: [],\n            datePointTransforms: [],\n            dateSpanTransforms: [],\n            views: {},\n            viewPropsTransformers: [],\n            isPropsValid: null,\n            externalDefTransforms: [],\n            viewContainerAppends: [],\n            eventDropTransformers: [],\n            componentInteractions: [],\n            calendarInteractions: [],\n            themeClasses: {},\n            eventSourceDefs: [],\n            cmdFormatter: null,\n            recurringTypes: [],\n            namedTimeZonedImpl: null,\n            initialView: '',\n            elementDraggingImpl: null,\n            optionChangeHandlers: {},\n            scrollGridImpl: null,\n            listenerRefiners: {},\n            optionRefiners: {},\n            propSetHandlers: {}\n        };\n        function addDefs(defs) {\n            for (let def of defs){\n                const pluginName = def.name;\n                const currentId = currentPluginIds[pluginName];\n                if (currentId === undefined) {\n                    currentPluginIds[pluginName] = def.id;\n                    addDefs(def.deps);\n                    hooks = combineHooks(hooks, def);\n                } else if (currentId !== def.id) {\n                    // different ID than the one already added\n                    console.warn(`Duplicate plugin '${pluginName}'`);\n                }\n            }\n        }\n        if (pluginDefs) {\n            addDefs(pluginDefs);\n        }\n        addDefs(globalDefs);\n        return hooks;\n    }\n    function buildBuildPluginHooks() {\n        let currentOverrideDefs = [];\n        let currentGlobalDefs = [];\n        let currentHooks;\n        return (overrideDefs, globalDefs)=>{\n            if (!currentHooks || !isArraysEqual(overrideDefs, currentOverrideDefs) || !isArraysEqual(globalDefs, currentGlobalDefs)) {\n                currentHooks = buildPluginHooks(overrideDefs, globalDefs);\n            }\n            currentOverrideDefs = overrideDefs;\n            currentGlobalDefs = globalDefs;\n            return currentHooks;\n        };\n    }\n    function combineHooks(hooks0, hooks1) {\n        return {\n            premiumReleaseDate: compareOptionalDates(hooks0.premiumReleaseDate, hooks1.premiumReleaseDate),\n            reducers: hooks0.reducers.concat(hooks1.reducers),\n            isLoadingFuncs: hooks0.isLoadingFuncs.concat(hooks1.isLoadingFuncs),\n            contextInit: hooks0.contextInit.concat(hooks1.contextInit),\n            eventRefiners: Object.assign(Object.assign({}, hooks0.eventRefiners), hooks1.eventRefiners),\n            eventDefMemberAdders: hooks0.eventDefMemberAdders.concat(hooks1.eventDefMemberAdders),\n            eventSourceRefiners: Object.assign(Object.assign({}, hooks0.eventSourceRefiners), hooks1.eventSourceRefiners),\n            isDraggableTransformers: hooks0.isDraggableTransformers.concat(hooks1.isDraggableTransformers),\n            eventDragMutationMassagers: hooks0.eventDragMutationMassagers.concat(hooks1.eventDragMutationMassagers),\n            eventDefMutationAppliers: hooks0.eventDefMutationAppliers.concat(hooks1.eventDefMutationAppliers),\n            dateSelectionTransformers: hooks0.dateSelectionTransformers.concat(hooks1.dateSelectionTransformers),\n            datePointTransforms: hooks0.datePointTransforms.concat(hooks1.datePointTransforms),\n            dateSpanTransforms: hooks0.dateSpanTransforms.concat(hooks1.dateSpanTransforms),\n            views: Object.assign(Object.assign({}, hooks0.views), hooks1.views),\n            viewPropsTransformers: hooks0.viewPropsTransformers.concat(hooks1.viewPropsTransformers),\n            isPropsValid: hooks1.isPropsValid || hooks0.isPropsValid,\n            externalDefTransforms: hooks0.externalDefTransforms.concat(hooks1.externalDefTransforms),\n            viewContainerAppends: hooks0.viewContainerAppends.concat(hooks1.viewContainerAppends),\n            eventDropTransformers: hooks0.eventDropTransformers.concat(hooks1.eventDropTransformers),\n            calendarInteractions: hooks0.calendarInteractions.concat(hooks1.calendarInteractions),\n            componentInteractions: hooks0.componentInteractions.concat(hooks1.componentInteractions),\n            themeClasses: Object.assign(Object.assign({}, hooks0.themeClasses), hooks1.themeClasses),\n            eventSourceDefs: hooks0.eventSourceDefs.concat(hooks1.eventSourceDefs),\n            cmdFormatter: hooks1.cmdFormatter || hooks0.cmdFormatter,\n            recurringTypes: hooks0.recurringTypes.concat(hooks1.recurringTypes),\n            namedTimeZonedImpl: hooks1.namedTimeZonedImpl || hooks0.namedTimeZonedImpl,\n            initialView: hooks0.initialView || hooks1.initialView,\n            elementDraggingImpl: hooks0.elementDraggingImpl || hooks1.elementDraggingImpl,\n            optionChangeHandlers: Object.assign(Object.assign({}, hooks0.optionChangeHandlers), hooks1.optionChangeHandlers),\n            scrollGridImpl: hooks1.scrollGridImpl || hooks0.scrollGridImpl,\n            listenerRefiners: Object.assign(Object.assign({}, hooks0.listenerRefiners), hooks1.listenerRefiners),\n            optionRefiners: Object.assign(Object.assign({}, hooks0.optionRefiners), hooks1.optionRefiners),\n            propSetHandlers: Object.assign(Object.assign({}, hooks0.propSetHandlers), hooks1.propSetHandlers)\n        };\n    }\n    function compareOptionalDates(date0, date1) {\n        if (date0 === undefined) {\n            return date1;\n        }\n        if (date1 === undefined) {\n            return date0;\n        }\n        return new Date(Math.max(date0.valueOf(), date1.valueOf()));\n    }\n    class StandardTheme extends Theme {\n    }\n    StandardTheme.prototype.classes = {\n        root: 'fc-theme-standard',\n        tableCellShaded: 'fc-cell-shaded',\n        buttonGroup: 'fc-button-group',\n        button: 'fc-button fc-button-primary',\n        buttonActive: 'fc-button-active'\n    };\n    StandardTheme.prototype.baseIconClass = 'fc-icon';\n    StandardTheme.prototype.iconClasses = {\n        close: 'fc-icon-x',\n        prev: 'fc-icon-chevron-left',\n        next: 'fc-icon-chevron-right',\n        prevYear: 'fc-icon-chevrons-left',\n        nextYear: 'fc-icon-chevrons-right'\n    };\n    StandardTheme.prototype.rtlIconClasses = {\n        prev: 'fc-icon-chevron-right',\n        next: 'fc-icon-chevron-left',\n        prevYear: 'fc-icon-chevrons-right',\n        nextYear: 'fc-icon-chevrons-left'\n    };\n    StandardTheme.prototype.iconOverrideOption = 'buttonIcons'; // TODO: make TS-friendly\n    StandardTheme.prototype.iconOverrideCustomButtonOption = 'icon';\n    StandardTheme.prototype.iconOverridePrefix = 'fc-icon-';\n    function compileViewDefs(defaultConfigs, overrideConfigs) {\n        let hash = {};\n        let viewType;\n        for(viewType in defaultConfigs){\n            ensureViewDef(viewType, hash, defaultConfigs, overrideConfigs);\n        }\n        for(viewType in overrideConfigs){\n            ensureViewDef(viewType, hash, defaultConfigs, overrideConfigs);\n        }\n        return hash;\n    }\n    function ensureViewDef(viewType, hash, defaultConfigs, overrideConfigs) {\n        if (hash[viewType]) {\n            return hash[viewType];\n        }\n        let viewDef = buildViewDef(viewType, hash, defaultConfigs, overrideConfigs);\n        if (viewDef) {\n            hash[viewType] = viewDef;\n        }\n        return viewDef;\n    }\n    function buildViewDef(viewType, hash, defaultConfigs, overrideConfigs) {\n        let defaultConfig = defaultConfigs[viewType];\n        let overrideConfig = overrideConfigs[viewType];\n        let queryProp = (name)=>defaultConfig && defaultConfig[name] !== null ? defaultConfig[name] : overrideConfig && overrideConfig[name] !== null ? overrideConfig[name] : null;\n        let theComponent = queryProp('component');\n        let superType = queryProp('superType');\n        let superDef = null;\n        if (superType) {\n            if (superType === viewType) {\n                throw new Error('Can\\'t have a custom view type that references itself');\n            }\n            superDef = ensureViewDef(superType, hash, defaultConfigs, overrideConfigs);\n        }\n        if (!theComponent && superDef) {\n            theComponent = superDef.component;\n        }\n        if (!theComponent) {\n            return null; // don't throw a warning, might be settings for a single-unit view\n        }\n        return {\n            type: viewType,\n            component: theComponent,\n            defaults: Object.assign(Object.assign({}, superDef ? superDef.defaults : {}), defaultConfig ? defaultConfig.rawOptions : {}),\n            overrides: Object.assign(Object.assign({}, superDef ? superDef.overrides : {}), overrideConfig ? overrideConfig.rawOptions : {})\n        };\n    }\n    function parseViewConfigs(inputs) {\n        return mapHash(inputs, parseViewConfig);\n    }\n    function parseViewConfig(input) {\n        let rawOptions = typeof input === 'function' ? {\n            component: input\n        } : input;\n        let { component } = rawOptions;\n        if (rawOptions.content) {\n            // TODO: remove content/classNames/didMount/etc from options?\n            component = createViewHookComponent(rawOptions);\n        } else if (component && !(component.prototype instanceof BaseComponent)) {\n            // WHY?: people were using `component` property for `content`\n            // TODO: converge on one setting name\n            component = createViewHookComponent(Object.assign(Object.assign({}, rawOptions), {\n                content: component\n            }));\n        }\n        return {\n            superType: rawOptions.type,\n            component: component,\n            rawOptions\n        };\n    }\n    function createViewHookComponent(options) {\n        return (viewProps)=>y(ViewContextType.Consumer, null, (context)=>y(ContentContainer, {\n                    elTag: \"div\",\n                    elClasses: buildViewClassNames(context.viewSpec),\n                    renderProps: Object.assign(Object.assign({}, viewProps), {\n                        nextDayThreshold: context.options.nextDayThreshold\n                    }),\n                    generatorName: undefined,\n                    customGenerator: options.content,\n                    classNameGenerator: options.classNames,\n                    didMount: options.didMount,\n                    willUnmount: options.willUnmount\n                }));\n    }\n    function buildViewSpecs(defaultInputs, optionOverrides, dynamicOptionOverrides, localeDefaults) {\n        let defaultConfigs = parseViewConfigs(defaultInputs);\n        let overrideConfigs = parseViewConfigs(optionOverrides.views);\n        let viewDefs = compileViewDefs(defaultConfigs, overrideConfigs);\n        return mapHash(viewDefs, (viewDef)=>buildViewSpec(viewDef, overrideConfigs, optionOverrides, dynamicOptionOverrides, localeDefaults));\n    }\n    function buildViewSpec(viewDef, overrideConfigs, optionOverrides, dynamicOptionOverrides, localeDefaults) {\n        let durationInput = viewDef.overrides.duration || viewDef.defaults.duration || dynamicOptionOverrides.duration || optionOverrides.duration;\n        let duration = null;\n        let durationUnit = '';\n        let singleUnit = '';\n        let singleUnitOverrides = {};\n        if (durationInput) {\n            duration = createDurationCached(durationInput);\n            if (duration) {\n                let denom = greatestDurationDenominator(duration);\n                durationUnit = denom.unit;\n                if (denom.value === 1) {\n                    singleUnit = durationUnit;\n                    singleUnitOverrides = overrideConfigs[durationUnit] ? overrideConfigs[durationUnit].rawOptions : {};\n                }\n            }\n        }\n        let queryButtonText = (optionsSubset)=>{\n            let buttonTextMap = optionsSubset.buttonText || {};\n            let buttonTextKey = viewDef.defaults.buttonTextKey;\n            if (buttonTextKey != null && buttonTextMap[buttonTextKey] != null) {\n                return buttonTextMap[buttonTextKey];\n            }\n            if (buttonTextMap[viewDef.type] != null) {\n                return buttonTextMap[viewDef.type];\n            }\n            if (buttonTextMap[singleUnit] != null) {\n                return buttonTextMap[singleUnit];\n            }\n            return null;\n        };\n        let queryButtonTitle = (optionsSubset)=>{\n            let buttonHints = optionsSubset.buttonHints || {};\n            let buttonKey = viewDef.defaults.buttonTextKey; // use same key as text\n            if (buttonKey != null && buttonHints[buttonKey] != null) {\n                return buttonHints[buttonKey];\n            }\n            if (buttonHints[viewDef.type] != null) {\n                return buttonHints[viewDef.type];\n            }\n            if (buttonHints[singleUnit] != null) {\n                return buttonHints[singleUnit];\n            }\n            return null;\n        };\n        return {\n            type: viewDef.type,\n            component: viewDef.component,\n            duration,\n            durationUnit,\n            singleUnit,\n            optionDefaults: viewDef.defaults,\n            optionOverrides: Object.assign(Object.assign({}, singleUnitOverrides), viewDef.overrides),\n            buttonTextOverride: queryButtonText(dynamicOptionOverrides) || queryButtonText(optionOverrides) || // constructor-specified buttonText lookup hash takes precedence\n            viewDef.overrides.buttonText,\n            buttonTextDefault: queryButtonText(localeDefaults) || viewDef.defaults.buttonText || queryButtonText(BASE_OPTION_DEFAULTS) || viewDef.type,\n            // not DRY\n            buttonTitleOverride: queryButtonTitle(dynamicOptionOverrides) || queryButtonTitle(optionOverrides) || viewDef.overrides.buttonHint,\n            buttonTitleDefault: queryButtonTitle(localeDefaults) || viewDef.defaults.buttonHint || queryButtonTitle(BASE_OPTION_DEFAULTS)\n        };\n    }\n    // hack to get memoization working\n    let durationInputMap = {};\n    function createDurationCached(durationInput) {\n        let json = JSON.stringify(durationInput);\n        let res = durationInputMap[json];\n        if (res === undefined) {\n            res = createDuration(durationInput);\n            durationInputMap[json] = res;\n        }\n        return res;\n    }\n    function reduceViewType(viewType, action) {\n        switch(action.type){\n            case 'CHANGE_VIEW_TYPE':\n                viewType = action.viewType;\n        }\n        return viewType;\n    }\n    function reduceDynamicOptionOverrides(dynamicOptionOverrides, action) {\n        switch(action.type){\n            case 'SET_OPTION':\n                return Object.assign(Object.assign({}, dynamicOptionOverrides), {\n                    [action.optionName]: action.rawOptionValue\n                });\n            default:\n                return dynamicOptionOverrides;\n        }\n    }\n    function reduceDateProfile(currentDateProfile, action, currentDate, dateProfileGenerator) {\n        let dp;\n        switch(action.type){\n            case 'CHANGE_VIEW_TYPE':\n                return dateProfileGenerator.build(action.dateMarker || currentDate);\n            case 'CHANGE_DATE':\n                return dateProfileGenerator.build(action.dateMarker);\n            case 'PREV':\n                dp = dateProfileGenerator.buildPrev(currentDateProfile, currentDate);\n                if (dp.isValid) {\n                    return dp;\n                }\n                break;\n            case 'NEXT':\n                dp = dateProfileGenerator.buildNext(currentDateProfile, currentDate);\n                if (dp.isValid) {\n                    return dp;\n                }\n                break;\n        }\n        return currentDateProfile;\n    }\n    function initEventSources(calendarOptions, dateProfile, context) {\n        let activeRange = dateProfile ? dateProfile.activeRange : null;\n        return addSources({}, parseInitialSources(calendarOptions, context), activeRange, context);\n    }\n    function reduceEventSources(eventSources, action, dateProfile, context) {\n        let activeRange = dateProfile ? dateProfile.activeRange : null; // need this check?\n        switch(action.type){\n            case 'ADD_EVENT_SOURCES':\n                return addSources(eventSources, action.sources, activeRange, context);\n            case 'REMOVE_EVENT_SOURCE':\n                return removeSource(eventSources, action.sourceId);\n            case 'PREV':\n            case 'NEXT':\n            case 'CHANGE_DATE':\n            case 'CHANGE_VIEW_TYPE':\n                if (dateProfile) {\n                    return fetchDirtySources(eventSources, activeRange, context);\n                }\n                return eventSources;\n            case 'FETCH_EVENT_SOURCES':\n                return fetchSourcesByIds(eventSources, action.sourceIds ? arrayToHash(action.sourceIds) : excludeStaticSources(eventSources, context), activeRange, action.isRefetch || false, context);\n            case 'RECEIVE_EVENTS':\n            case 'RECEIVE_EVENT_ERROR':\n                return receiveResponse(eventSources, action.sourceId, action.fetchId, action.fetchRange);\n            case 'REMOVE_ALL_EVENT_SOURCES':\n                return {};\n            default:\n                return eventSources;\n        }\n    }\n    function reduceEventSourcesNewTimeZone(eventSources, dateProfile, context) {\n        let activeRange = dateProfile ? dateProfile.activeRange : null; // need this check?\n        return fetchSourcesByIds(eventSources, excludeStaticSources(eventSources, context), activeRange, true, context);\n    }\n    function computeEventSourcesLoading(eventSources) {\n        for(let sourceId in eventSources){\n            if (eventSources[sourceId].isFetching) {\n                return true;\n            }\n        }\n        return false;\n    }\n    function addSources(eventSourceHash, sources, fetchRange, context) {\n        let hash = {};\n        for (let source of sources){\n            hash[source.sourceId] = source;\n        }\n        if (fetchRange) {\n            hash = fetchDirtySources(hash, fetchRange, context);\n        }\n        return Object.assign(Object.assign({}, eventSourceHash), hash);\n    }\n    function removeSource(eventSourceHash, sourceId) {\n        return filterHash(eventSourceHash, (eventSource)=>eventSource.sourceId !== sourceId);\n    }\n    function fetchDirtySources(sourceHash, fetchRange, context) {\n        return fetchSourcesByIds(sourceHash, filterHash(sourceHash, (eventSource)=>isSourceDirty(eventSource, fetchRange, context)), fetchRange, false, context);\n    }\n    function isSourceDirty(eventSource, fetchRange, context) {\n        if (!doesSourceNeedRange(eventSource, context)) {\n            return !eventSource.latestFetchId;\n        }\n        return !context.options.lazyFetching || !eventSource.fetchRange || eventSource.isFetching || // always cancel outdated in-progress fetches\n        fetchRange.start < eventSource.fetchRange.start || fetchRange.end > eventSource.fetchRange.end;\n    }\n    function fetchSourcesByIds(prevSources, sourceIdHash, fetchRange, isRefetch, context) {\n        let nextSources = {};\n        for(let sourceId in prevSources){\n            let source = prevSources[sourceId];\n            if (sourceIdHash[sourceId]) {\n                nextSources[sourceId] = fetchSource(source, fetchRange, isRefetch, context);\n            } else {\n                nextSources[sourceId] = source;\n            }\n        }\n        return nextSources;\n    }\n    function fetchSource(eventSource, fetchRange, isRefetch, context) {\n        let { options, calendarApi } = context;\n        let sourceDef = context.pluginHooks.eventSourceDefs[eventSource.sourceDefId];\n        let fetchId = guid();\n        sourceDef.fetch({\n            eventSource,\n            range: fetchRange,\n            isRefetch,\n            context\n        }, (res)=>{\n            let { rawEvents } = res;\n            if (options.eventSourceSuccess) {\n                rawEvents = options.eventSourceSuccess.call(calendarApi, rawEvents, res.response) || rawEvents;\n            }\n            if (eventSource.success) {\n                rawEvents = eventSource.success.call(calendarApi, rawEvents, res.response) || rawEvents;\n            }\n            context.dispatch({\n                type: 'RECEIVE_EVENTS',\n                sourceId: eventSource.sourceId,\n                fetchId,\n                fetchRange,\n                rawEvents\n            });\n        }, (error)=>{\n            let errorHandled = false;\n            if (options.eventSourceFailure) {\n                options.eventSourceFailure.call(calendarApi, error);\n                errorHandled = true;\n            }\n            if (eventSource.failure) {\n                eventSource.failure(error);\n                errorHandled = true;\n            }\n            if (!errorHandled) {\n                console.warn(error.message, error);\n            }\n            context.dispatch({\n                type: 'RECEIVE_EVENT_ERROR',\n                sourceId: eventSource.sourceId,\n                fetchId,\n                fetchRange,\n                error\n            });\n        });\n        return Object.assign(Object.assign({}, eventSource), {\n            isFetching: true,\n            latestFetchId: fetchId\n        });\n    }\n    function receiveResponse(sourceHash, sourceId, fetchId, fetchRange) {\n        let eventSource = sourceHash[sourceId];\n        if (eventSource && // not already removed\n        fetchId === eventSource.latestFetchId) {\n            return Object.assign(Object.assign({}, sourceHash), {\n                [sourceId]: Object.assign(Object.assign({}, eventSource), {\n                    isFetching: false,\n                    fetchRange\n                })\n            });\n        }\n        return sourceHash;\n    }\n    function excludeStaticSources(eventSources, context) {\n        return filterHash(eventSources, (eventSource)=>doesSourceNeedRange(eventSource, context));\n    }\n    function parseInitialSources(rawOptions, context) {\n        let refiners = buildEventSourceRefiners(context);\n        let rawSources = [].concat(rawOptions.eventSources || []);\n        let sources = []; // parsed\n        if (rawOptions.initialEvents) {\n            rawSources.unshift(rawOptions.initialEvents);\n        }\n        if (rawOptions.events) {\n            rawSources.unshift(rawOptions.events);\n        }\n        for (let rawSource of rawSources){\n            let source = parseEventSource(rawSource, context, refiners);\n            if (source) {\n                sources.push(source);\n            }\n        }\n        return sources;\n    }\n    function doesSourceNeedRange(eventSource, context) {\n        let defs = context.pluginHooks.eventSourceDefs;\n        return !defs[eventSource.sourceDefId].ignoreRange;\n    }\n    function reduceDateSelection(currentSelection, action) {\n        switch(action.type){\n            case 'UNSELECT_DATES':\n                return null;\n            case 'SELECT_DATES':\n                return action.selection;\n            default:\n                return currentSelection;\n        }\n    }\n    function reduceSelectedEvent(currentInstanceId, action) {\n        switch(action.type){\n            case 'UNSELECT_EVENT':\n                return '';\n            case 'SELECT_EVENT':\n                return action.eventInstanceId;\n            default:\n                return currentInstanceId;\n        }\n    }\n    function reduceEventDrag(currentDrag, action) {\n        let newDrag;\n        switch(action.type){\n            case 'UNSET_EVENT_DRAG':\n                return null;\n            case 'SET_EVENT_DRAG':\n                newDrag = action.state;\n                return {\n                    affectedEvents: newDrag.affectedEvents,\n                    mutatedEvents: newDrag.mutatedEvents,\n                    isEvent: newDrag.isEvent\n                };\n            default:\n                return currentDrag;\n        }\n    }\n    function reduceEventResize(currentResize, action) {\n        let newResize;\n        switch(action.type){\n            case 'UNSET_EVENT_RESIZE':\n                return null;\n            case 'SET_EVENT_RESIZE':\n                newResize = action.state;\n                return {\n                    affectedEvents: newResize.affectedEvents,\n                    mutatedEvents: newResize.mutatedEvents,\n                    isEvent: newResize.isEvent\n                };\n            default:\n                return currentResize;\n        }\n    }\n    function parseToolbars(calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi) {\n        let header = calendarOptions.headerToolbar ? parseToolbar(calendarOptions.headerToolbar, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi) : null;\n        let footer = calendarOptions.footerToolbar ? parseToolbar(calendarOptions.footerToolbar, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi) : null;\n        return {\n            header,\n            footer\n        };\n    }\n    function parseToolbar(sectionStrHash, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi) {\n        let sectionWidgets = {};\n        let viewsWithButtons = [];\n        let hasTitle = false;\n        for(let sectionName in sectionStrHash){\n            let sectionStr = sectionStrHash[sectionName];\n            let sectionRes = parseSection(sectionStr, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi);\n            sectionWidgets[sectionName] = sectionRes.widgets;\n            viewsWithButtons.push(...sectionRes.viewsWithButtons);\n            hasTitle = hasTitle || sectionRes.hasTitle;\n        }\n        return {\n            sectionWidgets,\n            viewsWithButtons,\n            hasTitle\n        };\n    }\n    /*\r\n    BAD: querying icons and text here. should be done at render time\r\n    */ function parseSection(sectionStr, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi) {\n        let isRtl = calendarOptions.direction === 'rtl';\n        let calendarCustomButtons = calendarOptions.customButtons || {};\n        let calendarButtonTextOverrides = calendarOptionOverrides.buttonText || {};\n        let calendarButtonText = calendarOptions.buttonText || {};\n        let calendarButtonHintOverrides = calendarOptionOverrides.buttonHints || {};\n        let calendarButtonHints = calendarOptions.buttonHints || {};\n        let sectionSubstrs = sectionStr ? sectionStr.split(' ') : [];\n        let viewsWithButtons = [];\n        let hasTitle = false;\n        let widgets = sectionSubstrs.map((buttonGroupStr)=>buttonGroupStr.split(',').map((buttonName)=>{\n                if (buttonName === 'title') {\n                    hasTitle = true;\n                    return {\n                        buttonName\n                    };\n                }\n                let customButtonProps;\n                let viewSpec;\n                let buttonClick;\n                let buttonIcon; // only one of these will be set\n                let buttonText; // \"\n                let buttonHint;\n                // ^ for the title=\"\" attribute, for accessibility\n                if (customButtonProps = calendarCustomButtons[buttonName]) {\n                    buttonClick = (ev)=>{\n                        if (customButtonProps.click) {\n                            customButtonProps.click.call(ev.target, ev, ev.target); // TODO: use Calendar this context?\n                        }\n                    };\n                    (buttonIcon = theme.getCustomButtonIconClass(customButtonProps)) || (buttonIcon = theme.getIconClass(buttonName, isRtl)) || (buttonText = customButtonProps.text);\n                    buttonHint = customButtonProps.hint || customButtonProps.text;\n                } else if (viewSpec = viewSpecs[buttonName]) {\n                    viewsWithButtons.push(buttonName);\n                    buttonClick = ()=>{\n                        calendarApi.changeView(buttonName);\n                    };\n                    (buttonText = viewSpec.buttonTextOverride) || (buttonIcon = theme.getIconClass(buttonName, isRtl)) || (buttonText = viewSpec.buttonTextDefault);\n                    let textFallback = viewSpec.buttonTextOverride || viewSpec.buttonTextDefault;\n                    buttonHint = formatWithOrdinals(viewSpec.buttonTitleOverride || viewSpec.buttonTitleDefault || calendarOptions.viewHint, [\n                        textFallback,\n                        buttonName\n                    ], textFallback);\n                } else if (calendarApi[buttonName]) {\n                    buttonClick = ()=>{\n                        calendarApi[buttonName]();\n                    };\n                    (buttonText = calendarButtonTextOverrides[buttonName]) || (buttonIcon = theme.getIconClass(buttonName, isRtl)) || (buttonText = calendarButtonText[buttonName]); // everything else is considered default\n                    if (buttonName === 'prevYear' || buttonName === 'nextYear') {\n                        let prevOrNext = buttonName === 'prevYear' ? 'prev' : 'next';\n                        buttonHint = formatWithOrdinals(calendarButtonHintOverrides[prevOrNext] || calendarButtonHints[prevOrNext], [\n                            calendarButtonText.year || 'year',\n                            'year'\n                        ], calendarButtonText[buttonName]);\n                    } else {\n                        buttonHint = (navUnit)=>formatWithOrdinals(calendarButtonHintOverrides[buttonName] || calendarButtonHints[buttonName], [\n                                calendarButtonText[navUnit] || navUnit,\n                                navUnit\n                            ], calendarButtonText[buttonName]);\n                    }\n                }\n                return {\n                    buttonName,\n                    buttonClick,\n                    buttonIcon,\n                    buttonText,\n                    buttonHint\n                };\n            }));\n        return {\n            widgets,\n            viewsWithButtons,\n            hasTitle\n        };\n    }\n    // always represents the current view. otherwise, it'd need to change value every time date changes\n    class ViewImpl {\n        constructor(type, getCurrentData, dateEnv){\n            this.type = type;\n            this.getCurrentData = getCurrentData;\n            this.dateEnv = dateEnv;\n        }\n        get calendar() {\n            return this.getCurrentData().calendarApi;\n        }\n        get title() {\n            return this.getCurrentData().viewTitle;\n        }\n        get activeStart() {\n            return this.dateEnv.toDate(this.getCurrentData().dateProfile.activeRange.start);\n        }\n        get activeEnd() {\n            return this.dateEnv.toDate(this.getCurrentData().dateProfile.activeRange.end);\n        }\n        get currentStart() {\n            return this.dateEnv.toDate(this.getCurrentData().dateProfile.currentRange.start);\n        }\n        get currentEnd() {\n            return this.dateEnv.toDate(this.getCurrentData().dateProfile.currentRange.end);\n        }\n        getOption(name) {\n            return this.getCurrentData().options[name]; // are the view-specific options\n        }\n    }\n    let eventSourceDef$2 = {\n        ignoreRange: true,\n        parseMeta (refined) {\n            if (Array.isArray(refined.events)) {\n                return refined.events;\n            }\n            return null;\n        },\n        fetch (arg, successCallback) {\n            successCallback({\n                rawEvents: arg.eventSource.meta\n            });\n        }\n    };\n    const arrayEventSourcePlugin = createPlugin({\n        name: 'array-event-source',\n        eventSourceDefs: [\n            eventSourceDef$2\n        ]\n    });\n    let eventSourceDef$1 = {\n        parseMeta (refined) {\n            if (typeof refined.events === 'function') {\n                return refined.events;\n            }\n            return null;\n        },\n        fetch (arg, successCallback, errorCallback) {\n            const { dateEnv } = arg.context;\n            const func = arg.eventSource.meta;\n            unpromisify(func.bind(null, buildRangeApiWithTimeZone(arg.range, dateEnv)), (rawEvents)=>successCallback({\n                    rawEvents\n                }), errorCallback);\n        }\n    };\n    const funcEventSourcePlugin = createPlugin({\n        name: 'func-event-source',\n        eventSourceDefs: [\n            eventSourceDef$1\n        ]\n    });\n    const JSON_FEED_EVENT_SOURCE_REFINERS = {\n        method: String,\n        extraParams: identity,\n        startParam: String,\n        endParam: String,\n        timeZoneParam: String\n    };\n    let eventSourceDef = {\n        parseMeta (refined) {\n            if (refined.url && (refined.format === 'json' || !refined.format)) {\n                return {\n                    url: refined.url,\n                    format: 'json',\n                    method: (refined.method || 'GET').toUpperCase(),\n                    extraParams: refined.extraParams,\n                    startParam: refined.startParam,\n                    endParam: refined.endParam,\n                    timeZoneParam: refined.timeZoneParam\n                };\n            }\n            return null;\n        },\n        fetch (arg, successCallback, errorCallback) {\n            const { meta } = arg.eventSource;\n            const requestParams = buildRequestParams(meta, arg.range, arg.context);\n            requestJson(meta.method, meta.url, requestParams).then(([rawEvents, response])=>{\n                successCallback({\n                    rawEvents,\n                    response\n                });\n            }, errorCallback);\n        }\n    };\n    const jsonFeedEventSourcePlugin = createPlugin({\n        name: 'json-event-source',\n        eventSourceRefiners: JSON_FEED_EVENT_SOURCE_REFINERS,\n        eventSourceDefs: [\n            eventSourceDef\n        ]\n    });\n    function buildRequestParams(meta, range, context) {\n        let { dateEnv, options } = context;\n        let startParam;\n        let endParam;\n        let timeZoneParam;\n        let customRequestParams;\n        let params = {};\n        startParam = meta.startParam;\n        if (startParam == null) {\n            startParam = options.startParam;\n        }\n        endParam = meta.endParam;\n        if (endParam == null) {\n            endParam = options.endParam;\n        }\n        timeZoneParam = meta.timeZoneParam;\n        if (timeZoneParam == null) {\n            timeZoneParam = options.timeZoneParam;\n        }\n        // retrieve any outbound GET/POST data from the options\n        if (typeof meta.extraParams === 'function') {\n            // supplied as a function that returns a key/value object\n            customRequestParams = meta.extraParams();\n        } else {\n            // probably supplied as a straight key/value object\n            customRequestParams = meta.extraParams || {};\n        }\n        Object.assign(params, customRequestParams);\n        params[startParam] = dateEnv.formatIso(range.start);\n        params[endParam] = dateEnv.formatIso(range.end);\n        if (dateEnv.timeZone !== 'local') {\n            params[timeZoneParam] = dateEnv.timeZone;\n        }\n        return params;\n    }\n    const SIMPLE_RECURRING_REFINERS = {\n        daysOfWeek: identity,\n        startTime: createDuration,\n        endTime: createDuration,\n        duration: createDuration,\n        startRecur: identity,\n        endRecur: identity\n    };\n    let recurring = {\n        parse (refined, dateEnv) {\n            if (refined.daysOfWeek || refined.startTime || refined.endTime || refined.startRecur || refined.endRecur) {\n                let recurringData = {\n                    daysOfWeek: refined.daysOfWeek || null,\n                    startTime: refined.startTime || null,\n                    endTime: refined.endTime || null,\n                    startRecur: refined.startRecur ? dateEnv.createMarker(refined.startRecur) : null,\n                    endRecur: refined.endRecur ? dateEnv.createMarker(refined.endRecur) : null\n                };\n                let duration;\n                if (refined.duration) {\n                    duration = refined.duration;\n                }\n                if (!duration && refined.startTime && refined.endTime) {\n                    duration = subtractDurations(refined.endTime, refined.startTime);\n                }\n                return {\n                    allDayGuess: Boolean(!refined.startTime && !refined.endTime),\n                    duration,\n                    typeData: recurringData\n                };\n            }\n            return null;\n        },\n        expand (typeData, framingRange, dateEnv) {\n            let clippedFramingRange = intersectRanges(framingRange, {\n                start: typeData.startRecur,\n                end: typeData.endRecur\n            });\n            if (clippedFramingRange) {\n                return expandRanges(typeData.daysOfWeek, typeData.startTime, clippedFramingRange, dateEnv);\n            }\n            return [];\n        }\n    };\n    const simpleRecurringEventsPlugin = createPlugin({\n        name: 'simple-recurring-event',\n        recurringTypes: [\n            recurring\n        ],\n        eventRefiners: SIMPLE_RECURRING_REFINERS\n    });\n    function expandRanges(daysOfWeek, startTime, framingRange, dateEnv) {\n        let dowHash = daysOfWeek ? arrayToHash(daysOfWeek) : null;\n        let dayMarker = startOfDay(framingRange.start);\n        let endMarker = framingRange.end;\n        let instanceStarts = [];\n        while(dayMarker < endMarker){\n            let instanceStart;\n            // if everyday, or this particular day-of-week\n            if (!dowHash || dowHash[dayMarker.getUTCDay()]) {\n                if (startTime) {\n                    instanceStart = dateEnv.add(dayMarker, startTime);\n                } else {\n                    instanceStart = dayMarker;\n                }\n                instanceStarts.push(instanceStart);\n            }\n            dayMarker = addDays(dayMarker, 1);\n        }\n        return instanceStarts;\n    }\n    const changeHandlerPlugin = createPlugin({\n        name: 'change-handler',\n        optionChangeHandlers: {\n            events (events, context) {\n                handleEventSources([\n                    events\n                ], context);\n            },\n            eventSources: handleEventSources\n        }\n    });\n    /*\r\n    BUG: if `event` was supplied, all previously-given `eventSources` will be wiped out\r\n    */ function handleEventSources(inputs, context) {\n        let unfoundSources = hashValuesToArray(context.getCurrentData().eventSources);\n        if (unfoundSources.length === 1 && inputs.length === 1 && Array.isArray(unfoundSources[0]._raw) && Array.isArray(inputs[0])) {\n            context.dispatch({\n                type: 'RESET_RAW_EVENTS',\n                sourceId: unfoundSources[0].sourceId,\n                rawEvents: inputs[0]\n            });\n            return;\n        }\n        let newInputs = [];\n        for (let input of inputs){\n            let inputFound = false;\n            for(let i = 0; i < unfoundSources.length; i += 1){\n                if (unfoundSources[i]._raw === input) {\n                    unfoundSources.splice(i, 1); // delete\n                    inputFound = true;\n                    break;\n                }\n            }\n            if (!inputFound) {\n                newInputs.push(input);\n            }\n        }\n        for (let unfoundSource of unfoundSources){\n            context.dispatch({\n                type: 'REMOVE_EVENT_SOURCE',\n                sourceId: unfoundSource.sourceId\n            });\n        }\n        for (let newInput of newInputs){\n            context.calendarApi.addEventSource(newInput);\n        }\n    }\n    function handleDateProfile(dateProfile, context) {\n        context.emitter.trigger('datesSet', Object.assign(Object.assign({}, buildRangeApiWithTimeZone(dateProfile.activeRange, context.dateEnv)), {\n            view: context.viewApi\n        }));\n    }\n    function handleEventStore(eventStore, context) {\n        let { emitter } = context;\n        if (emitter.hasHandlers('eventsSet')) {\n            emitter.trigger('eventsSet', buildEventApis(eventStore, context));\n        }\n    }\n    /*\r\n    this array is exposed on the root namespace so that UMD plugins can add to it.\r\n    see the rollup-bundles script.\r\n    */ const globalPlugins = [\n        arrayEventSourcePlugin,\n        funcEventSourcePlugin,\n        jsonFeedEventSourcePlugin,\n        simpleRecurringEventsPlugin,\n        changeHandlerPlugin,\n        createPlugin({\n            name: 'misc',\n            isLoadingFuncs: [\n                (state)=>computeEventSourcesLoading(state.eventSources)\n            ],\n            propSetHandlers: {\n                dateProfile: handleDateProfile,\n                eventStore: handleEventStore\n            }\n        })\n    ];\n    class TaskRunner {\n        constructor(runTaskOption, drainedOption){\n            this.runTaskOption = runTaskOption;\n            this.drainedOption = drainedOption;\n            this.queue = [];\n            this.delayedRunner = new DelayedRunner(this.drain.bind(this));\n        }\n        request(task, delay) {\n            this.queue.push(task);\n            this.delayedRunner.request(delay);\n        }\n        pause(scope) {\n            this.delayedRunner.pause(scope);\n        }\n        resume(scope, force) {\n            this.delayedRunner.resume(scope, force);\n        }\n        drain() {\n            let { queue } = this;\n            while(queue.length){\n                let completedTasks = [];\n                let task;\n                while(task = queue.shift()){\n                    this.runTask(task);\n                    completedTasks.push(task);\n                }\n                this.drained(completedTasks);\n            } // keep going, in case new tasks were added in the drained handler\n        }\n        runTask(task) {\n            if (this.runTaskOption) {\n                this.runTaskOption(task);\n            }\n        }\n        drained(completedTasks) {\n            if (this.drainedOption) {\n                this.drainedOption(completedTasks);\n            }\n        }\n    }\n    // Computes what the title at the top of the calendarApi should be for this view\n    function buildTitle(dateProfile, viewOptions, dateEnv) {\n        let range;\n        // for views that span a large unit of time, show the proper interval, ignoring stray days before and after\n        if (/^(year|month)$/.test(dateProfile.currentRangeUnit)) {\n            range = dateProfile.currentRange;\n        } else {\n            range = dateProfile.activeRange;\n        }\n        return dateEnv.formatRange(range.start, range.end, createFormatter(viewOptions.titleFormat || buildTitleFormat(dateProfile)), {\n            isEndExclusive: dateProfile.isRangeAllDay,\n            defaultSeparator: viewOptions.titleRangeSeparator\n        });\n    }\n    // Generates the format string that should be used to generate the title for the current date range.\n    // Attempts to compute the most appropriate format if not explicitly specified with `titleFormat`.\n    function buildTitleFormat(dateProfile) {\n        let { currentRangeUnit } = dateProfile;\n        if (currentRangeUnit === 'year') {\n            return {\n                year: 'numeric'\n            };\n        }\n        if (currentRangeUnit === 'month') {\n            return {\n                year: 'numeric',\n                month: 'long'\n            }; // like \"September 2014\"\n        }\n        let days = diffWholeDays(dateProfile.currentRange.start, dateProfile.currentRange.end);\n        if (days !== null && days > 1) {\n            // multi-day range. shorter, like \"Sep 9 - 10 2014\"\n            return {\n                year: 'numeric',\n                month: 'short',\n                day: 'numeric'\n            };\n        }\n        // one day. longer, like \"September 9 2014\"\n        return {\n            year: 'numeric',\n            month: 'long',\n            day: 'numeric'\n        };\n    }\n    // in future refactor, do the redux-style function(state=initial) for initial-state\n    // also, whatever is happening in constructor, have it happen in action queue too\n    class CalendarDataManager {\n        constructor(props){\n            this.computeCurrentViewData = memoize(this._computeCurrentViewData);\n            this.organizeRawLocales = memoize(organizeRawLocales);\n            this.buildLocale = memoize(buildLocale);\n            this.buildPluginHooks = buildBuildPluginHooks();\n            this.buildDateEnv = memoize(buildDateEnv$1);\n            this.buildTheme = memoize(buildTheme);\n            this.parseToolbars = memoize(parseToolbars);\n            this.buildViewSpecs = memoize(buildViewSpecs);\n            this.buildDateProfileGenerator = memoizeObjArg(buildDateProfileGenerator);\n            this.buildViewApi = memoize(buildViewApi);\n            this.buildViewUiProps = memoizeObjArg(buildViewUiProps);\n            this.buildEventUiBySource = memoize(buildEventUiBySource, isPropsEqual);\n            this.buildEventUiBases = memoize(buildEventUiBases);\n            this.parseContextBusinessHours = memoizeObjArg(parseContextBusinessHours);\n            this.buildTitle = memoize(buildTitle);\n            this.emitter = new Emitter();\n            this.actionRunner = new TaskRunner(this._handleAction.bind(this), this.updateData.bind(this));\n            this.currentCalendarOptionsInput = {};\n            this.currentCalendarOptionsRefined = {};\n            this.currentViewOptionsInput = {};\n            this.currentViewOptionsRefined = {};\n            this.currentCalendarOptionsRefiners = {};\n            this.optionsForRefining = [];\n            this.optionsForHandling = [];\n            this.getCurrentData = ()=>this.data;\n            this.dispatch = (action)=>{\n                this.actionRunner.request(action); // protects against recursive calls to _handleAction\n            };\n            this.props = props;\n            this.actionRunner.pause();\n            let dynamicOptionOverrides = {};\n            let optionsData = this.computeOptionsData(props.optionOverrides, dynamicOptionOverrides, props.calendarApi);\n            let currentViewType = optionsData.calendarOptions.initialView || optionsData.pluginHooks.initialView;\n            let currentViewData = this.computeCurrentViewData(currentViewType, optionsData, props.optionOverrides, dynamicOptionOverrides);\n            // wire things up\n            // TODO: not DRY\n            props.calendarApi.currentDataManager = this;\n            this.emitter.setThisContext(props.calendarApi);\n            this.emitter.setOptions(currentViewData.options);\n            let currentDate = getInitialDate(optionsData.calendarOptions, optionsData.dateEnv);\n            let dateProfile = currentViewData.dateProfileGenerator.build(currentDate);\n            if (!rangeContainsMarker(dateProfile.activeRange, currentDate)) {\n                currentDate = dateProfile.currentRange.start;\n            }\n            let calendarContext = {\n                dateEnv: optionsData.dateEnv,\n                options: optionsData.calendarOptions,\n                pluginHooks: optionsData.pluginHooks,\n                calendarApi: props.calendarApi,\n                dispatch: this.dispatch,\n                emitter: this.emitter,\n                getCurrentData: this.getCurrentData\n            };\n            // needs to be after setThisContext\n            for (let callback of optionsData.pluginHooks.contextInit){\n                callback(calendarContext);\n            }\n            // NOT DRY\n            let eventSources = initEventSources(optionsData.calendarOptions, dateProfile, calendarContext);\n            let initialState = {\n                dynamicOptionOverrides,\n                currentViewType,\n                currentDate,\n                dateProfile,\n                businessHours: this.parseContextBusinessHours(calendarContext),\n                eventSources,\n                eventUiBases: {},\n                eventStore: createEmptyEventStore(),\n                renderableEventStore: createEmptyEventStore(),\n                dateSelection: null,\n                eventSelection: '',\n                eventDrag: null,\n                eventResize: null,\n                selectionConfig: this.buildViewUiProps(calendarContext).selectionConfig\n            };\n            let contextAndState = Object.assign(Object.assign({}, calendarContext), initialState);\n            for (let reducer of optionsData.pluginHooks.reducers){\n                Object.assign(initialState, reducer(null, null, contextAndState));\n            }\n            if (computeIsLoading(initialState, calendarContext)) {\n                this.emitter.trigger('loading', true); // NOT DRY\n            }\n            this.state = initialState;\n            this.updateData();\n            this.actionRunner.resume();\n        }\n        resetOptions(optionOverrides, changedOptionNames) {\n            let { props } = this;\n            if (changedOptionNames === undefined) {\n                props.optionOverrides = optionOverrides;\n            } else {\n                props.optionOverrides = Object.assign(Object.assign({}, props.optionOverrides || {}), optionOverrides);\n                this.optionsForRefining.push(...changedOptionNames);\n            }\n            if (changedOptionNames === undefined || changedOptionNames.length) {\n                this.actionRunner.request({\n                    type: 'NOTHING'\n                });\n            }\n        }\n        _handleAction(action) {\n            let { props, state, emitter } = this;\n            let dynamicOptionOverrides = reduceDynamicOptionOverrides(state.dynamicOptionOverrides, action);\n            let optionsData = this.computeOptionsData(props.optionOverrides, dynamicOptionOverrides, props.calendarApi);\n            let currentViewType = reduceViewType(state.currentViewType, action);\n            let currentViewData = this.computeCurrentViewData(currentViewType, optionsData, props.optionOverrides, dynamicOptionOverrides);\n            // wire things up\n            // TODO: not DRY\n            props.calendarApi.currentDataManager = this;\n            emitter.setThisContext(props.calendarApi);\n            emitter.setOptions(currentViewData.options);\n            let calendarContext = {\n                dateEnv: optionsData.dateEnv,\n                options: optionsData.calendarOptions,\n                pluginHooks: optionsData.pluginHooks,\n                calendarApi: props.calendarApi,\n                dispatch: this.dispatch,\n                emitter,\n                getCurrentData: this.getCurrentData\n            };\n            let { currentDate, dateProfile } = state;\n            if (this.data && this.data.dateProfileGenerator !== currentViewData.dateProfileGenerator) {\n                dateProfile = currentViewData.dateProfileGenerator.build(currentDate);\n            }\n            currentDate = reduceCurrentDate(currentDate, action);\n            dateProfile = reduceDateProfile(dateProfile, action, currentDate, currentViewData.dateProfileGenerator);\n            if (action.type === 'PREV' || // TODO: move this logic into DateProfileGenerator\n            action.type === 'NEXT' || // \"\n            !rangeContainsMarker(dateProfile.currentRange, currentDate)) {\n                currentDate = dateProfile.currentRange.start;\n            }\n            let eventSources = reduceEventSources(state.eventSources, action, dateProfile, calendarContext);\n            let eventStore = reduceEventStore(state.eventStore, action, eventSources, dateProfile, calendarContext);\n            let isEventsLoading = computeEventSourcesLoading(eventSources); // BAD. also called in this func in computeIsLoading\n            let renderableEventStore = isEventsLoading && !currentViewData.options.progressiveEventRendering ? state.renderableEventStore || eventStore : eventStore;\n            let { eventUiSingleBase, selectionConfig } = this.buildViewUiProps(calendarContext); // will memoize obj\n            let eventUiBySource = this.buildEventUiBySource(eventSources);\n            let eventUiBases = this.buildEventUiBases(renderableEventStore.defs, eventUiSingleBase, eventUiBySource);\n            let newState = {\n                dynamicOptionOverrides,\n                currentViewType,\n                currentDate,\n                dateProfile,\n                eventSources,\n                eventStore,\n                renderableEventStore,\n                selectionConfig,\n                eventUiBases,\n                businessHours: this.parseContextBusinessHours(calendarContext),\n                dateSelection: reduceDateSelection(state.dateSelection, action),\n                eventSelection: reduceSelectedEvent(state.eventSelection, action),\n                eventDrag: reduceEventDrag(state.eventDrag, action),\n                eventResize: reduceEventResize(state.eventResize, action)\n            };\n            let contextAndState = Object.assign(Object.assign({}, calendarContext), newState);\n            for (let reducer of optionsData.pluginHooks.reducers){\n                Object.assign(newState, reducer(state, action, contextAndState)); // give the OLD state, for old value\n            }\n            let wasLoading = computeIsLoading(state, calendarContext);\n            let isLoading = computeIsLoading(newState, calendarContext);\n            // TODO: use propSetHandlers in plugin system\n            if (!wasLoading && isLoading) {\n                emitter.trigger('loading', true);\n            } else if (wasLoading && !isLoading) {\n                emitter.trigger('loading', false);\n            }\n            this.state = newState;\n            if (props.onAction) {\n                props.onAction(action);\n            }\n        }\n        updateData() {\n            let { props, state } = this;\n            let oldData = this.data;\n            let optionsData = this.computeOptionsData(props.optionOverrides, state.dynamicOptionOverrides, props.calendarApi);\n            let currentViewData = this.computeCurrentViewData(state.currentViewType, optionsData, props.optionOverrides, state.dynamicOptionOverrides);\n            let data = this.data = Object.assign(Object.assign(Object.assign({\n                viewTitle: this.buildTitle(state.dateProfile, currentViewData.options, optionsData.dateEnv),\n                calendarApi: props.calendarApi,\n                dispatch: this.dispatch,\n                emitter: this.emitter,\n                getCurrentData: this.getCurrentData\n            }, optionsData), currentViewData), state);\n            let changeHandlers = optionsData.pluginHooks.optionChangeHandlers;\n            let oldCalendarOptions = oldData && oldData.calendarOptions;\n            let newCalendarOptions = optionsData.calendarOptions;\n            if (oldCalendarOptions && oldCalendarOptions !== newCalendarOptions) {\n                if (oldCalendarOptions.timeZone !== newCalendarOptions.timeZone) {\n                    // hack\n                    state.eventSources = data.eventSources = reduceEventSourcesNewTimeZone(data.eventSources, state.dateProfile, data);\n                    state.eventStore = data.eventStore = rezoneEventStoreDates(data.eventStore, oldData.dateEnv, data.dateEnv);\n                    state.renderableEventStore = data.renderableEventStore = rezoneEventStoreDates(data.renderableEventStore, oldData.dateEnv, data.dateEnv);\n                }\n                for(let optionName in changeHandlers){\n                    if (this.optionsForHandling.indexOf(optionName) !== -1 || oldCalendarOptions[optionName] !== newCalendarOptions[optionName]) {\n                        changeHandlers[optionName](newCalendarOptions[optionName], data);\n                    }\n                }\n            }\n            this.optionsForHandling = [];\n            if (props.onData) {\n                props.onData(data);\n            }\n        }\n        computeOptionsData(optionOverrides, dynamicOptionOverrides, calendarApi) {\n            // TODO: blacklist options that are handled by optionChangeHandlers\n            if (!this.optionsForRefining.length && optionOverrides === this.stableOptionOverrides && dynamicOptionOverrides === this.stableDynamicOptionOverrides) {\n                return this.stableCalendarOptionsData;\n            }\n            let { refinedOptions, pluginHooks, localeDefaults, availableLocaleData, extra } = this.processRawCalendarOptions(optionOverrides, dynamicOptionOverrides);\n            warnUnknownOptions(extra);\n            let dateEnv = this.buildDateEnv(refinedOptions.timeZone, refinedOptions.locale, refinedOptions.weekNumberCalculation, refinedOptions.firstDay, refinedOptions.weekText, pluginHooks, availableLocaleData, refinedOptions.defaultRangeSeparator);\n            let viewSpecs = this.buildViewSpecs(pluginHooks.views, this.stableOptionOverrides, this.stableDynamicOptionOverrides, localeDefaults);\n            let theme = this.buildTheme(refinedOptions, pluginHooks);\n            let toolbarConfig = this.parseToolbars(refinedOptions, this.stableOptionOverrides, theme, viewSpecs, calendarApi);\n            return this.stableCalendarOptionsData = {\n                calendarOptions: refinedOptions,\n                pluginHooks,\n                dateEnv,\n                viewSpecs,\n                theme,\n                toolbarConfig,\n                localeDefaults,\n                availableRawLocales: availableLocaleData.map\n            };\n        }\n        // always called from behind a memoizer\n        processRawCalendarOptions(optionOverrides, dynamicOptionOverrides) {\n            let { locales, locale } = mergeRawOptions([\n                BASE_OPTION_DEFAULTS,\n                optionOverrides,\n                dynamicOptionOverrides\n            ]);\n            let availableLocaleData = this.organizeRawLocales(locales);\n            let availableRawLocales = availableLocaleData.map;\n            let localeDefaults = this.buildLocale(locale || availableLocaleData.defaultCode, availableRawLocales).options;\n            let pluginHooks = this.buildPluginHooks(optionOverrides.plugins || [], globalPlugins);\n            let refiners = this.currentCalendarOptionsRefiners = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, BASE_OPTION_REFINERS), CALENDAR_LISTENER_REFINERS), CALENDAR_OPTION_REFINERS), pluginHooks.listenerRefiners), pluginHooks.optionRefiners);\n            let extra = {};\n            let raw = mergeRawOptions([\n                BASE_OPTION_DEFAULTS,\n                localeDefaults,\n                optionOverrides,\n                dynamicOptionOverrides\n            ]);\n            let refined = {};\n            let currentRaw = this.currentCalendarOptionsInput;\n            let currentRefined = this.currentCalendarOptionsRefined;\n            let anyChanges = false;\n            for(let optionName in raw){\n                if (this.optionsForRefining.indexOf(optionName) === -1 && (raw[optionName] === currentRaw[optionName] || COMPLEX_OPTION_COMPARATORS[optionName] && optionName in currentRaw && COMPLEX_OPTION_COMPARATORS[optionName](currentRaw[optionName], raw[optionName]))) {\n                    refined[optionName] = currentRefined[optionName];\n                } else if (refiners[optionName]) {\n                    refined[optionName] = refiners[optionName](raw[optionName]);\n                    anyChanges = true;\n                } else {\n                    extra[optionName] = currentRaw[optionName];\n                }\n            }\n            if (anyChanges) {\n                this.currentCalendarOptionsInput = raw;\n                this.currentCalendarOptionsRefined = refined;\n                this.stableOptionOverrides = optionOverrides;\n                this.stableDynamicOptionOverrides = dynamicOptionOverrides;\n            }\n            this.optionsForHandling.push(...this.optionsForRefining);\n            this.optionsForRefining = [];\n            return {\n                rawOptions: this.currentCalendarOptionsInput,\n                refinedOptions: this.currentCalendarOptionsRefined,\n                pluginHooks,\n                availableLocaleData,\n                localeDefaults,\n                extra\n            };\n        }\n        _computeCurrentViewData(viewType, optionsData, optionOverrides, dynamicOptionOverrides) {\n            let viewSpec = optionsData.viewSpecs[viewType];\n            if (!viewSpec) {\n                throw new Error(`viewType \"${viewType}\" is not available. Please make sure you've loaded all neccessary plugins`);\n            }\n            let { refinedOptions, extra } = this.processRawViewOptions(viewSpec, optionsData.pluginHooks, optionsData.localeDefaults, optionOverrides, dynamicOptionOverrides);\n            warnUnknownOptions(extra);\n            let dateProfileGenerator = this.buildDateProfileGenerator({\n                dateProfileGeneratorClass: viewSpec.optionDefaults.dateProfileGeneratorClass,\n                duration: viewSpec.duration,\n                durationUnit: viewSpec.durationUnit,\n                usesMinMaxTime: viewSpec.optionDefaults.usesMinMaxTime,\n                dateEnv: optionsData.dateEnv,\n                calendarApi: this.props.calendarApi,\n                slotMinTime: refinedOptions.slotMinTime,\n                slotMaxTime: refinedOptions.slotMaxTime,\n                showNonCurrentDates: refinedOptions.showNonCurrentDates,\n                dayCount: refinedOptions.dayCount,\n                dateAlignment: refinedOptions.dateAlignment,\n                dateIncrement: refinedOptions.dateIncrement,\n                hiddenDays: refinedOptions.hiddenDays,\n                weekends: refinedOptions.weekends,\n                nowInput: refinedOptions.now,\n                validRangeInput: refinedOptions.validRange,\n                visibleRangeInput: refinedOptions.visibleRange,\n                fixedWeekCount: refinedOptions.fixedWeekCount\n            });\n            let viewApi = this.buildViewApi(viewType, this.getCurrentData, optionsData.dateEnv);\n            return {\n                viewSpec,\n                options: refinedOptions,\n                dateProfileGenerator,\n                viewApi\n            };\n        }\n        processRawViewOptions(viewSpec, pluginHooks, localeDefaults, optionOverrides, dynamicOptionOverrides) {\n            let raw = mergeRawOptions([\n                BASE_OPTION_DEFAULTS,\n                viewSpec.optionDefaults,\n                localeDefaults,\n                optionOverrides,\n                viewSpec.optionOverrides,\n                dynamicOptionOverrides\n            ]);\n            let refiners = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, BASE_OPTION_REFINERS), CALENDAR_LISTENER_REFINERS), CALENDAR_OPTION_REFINERS), VIEW_OPTION_REFINERS), pluginHooks.listenerRefiners), pluginHooks.optionRefiners);\n            let refined = {};\n            let currentRaw = this.currentViewOptionsInput;\n            let currentRefined = this.currentViewOptionsRefined;\n            let anyChanges = false;\n            let extra = {};\n            for(let optionName in raw){\n                if (raw[optionName] === currentRaw[optionName] || COMPLEX_OPTION_COMPARATORS[optionName] && COMPLEX_OPTION_COMPARATORS[optionName](raw[optionName], currentRaw[optionName])) {\n                    refined[optionName] = currentRefined[optionName];\n                } else {\n                    if (raw[optionName] === this.currentCalendarOptionsInput[optionName] || COMPLEX_OPTION_COMPARATORS[optionName] && COMPLEX_OPTION_COMPARATORS[optionName](raw[optionName], this.currentCalendarOptionsInput[optionName])) {\n                        if (optionName in this.currentCalendarOptionsRefined) {\n                            refined[optionName] = this.currentCalendarOptionsRefined[optionName];\n                        }\n                    } else if (refiners[optionName]) {\n                        refined[optionName] = refiners[optionName](raw[optionName]);\n                    } else {\n                        extra[optionName] = raw[optionName];\n                    }\n                    anyChanges = true;\n                }\n            }\n            if (anyChanges) {\n                this.currentViewOptionsInput = raw;\n                this.currentViewOptionsRefined = refined;\n            }\n            return {\n                rawOptions: this.currentViewOptionsInput,\n                refinedOptions: this.currentViewOptionsRefined,\n                extra\n            };\n        }\n    }\n    function buildDateEnv$1(timeZone, explicitLocale, weekNumberCalculation, firstDay, weekText, pluginHooks, availableLocaleData, defaultSeparator) {\n        let locale = buildLocale(explicitLocale || availableLocaleData.defaultCode, availableLocaleData.map);\n        return new DateEnv({\n            calendarSystem: 'gregory',\n            timeZone,\n            namedTimeZoneImpl: pluginHooks.namedTimeZonedImpl,\n            locale,\n            weekNumberCalculation,\n            firstDay,\n            weekText,\n            cmdFormatter: pluginHooks.cmdFormatter,\n            defaultSeparator\n        });\n    }\n    function buildTheme(options, pluginHooks) {\n        let ThemeClass = pluginHooks.themeClasses[options.themeSystem] || StandardTheme;\n        return new ThemeClass(options);\n    }\n    function buildDateProfileGenerator(props) {\n        let DateProfileGeneratorClass = props.dateProfileGeneratorClass || DateProfileGenerator;\n        return new DateProfileGeneratorClass(props);\n    }\n    function buildViewApi(type, getCurrentData, dateEnv) {\n        return new ViewImpl(type, getCurrentData, dateEnv);\n    }\n    function buildEventUiBySource(eventSources) {\n        return mapHash(eventSources, (eventSource)=>eventSource.ui);\n    }\n    function buildEventUiBases(eventDefs, eventUiSingleBase, eventUiBySource) {\n        let eventUiBases = {\n            '': eventUiSingleBase\n        };\n        for(let defId in eventDefs){\n            let def = eventDefs[defId];\n            if (def.sourceId && eventUiBySource[def.sourceId]) {\n                eventUiBases[defId] = eventUiBySource[def.sourceId];\n            }\n        }\n        return eventUiBases;\n    }\n    function buildViewUiProps(calendarContext) {\n        let { options } = calendarContext;\n        return {\n            eventUiSingleBase: createEventUi({\n                display: options.eventDisplay,\n                editable: options.editable,\n                startEditable: options.eventStartEditable,\n                durationEditable: options.eventDurationEditable,\n                constraint: options.eventConstraint,\n                overlap: typeof options.eventOverlap === 'boolean' ? options.eventOverlap : undefined,\n                allow: options.eventAllow,\n                backgroundColor: options.eventBackgroundColor,\n                borderColor: options.eventBorderColor,\n                textColor: options.eventTextColor,\n                color: options.eventColor\n            }, calendarContext),\n            selectionConfig: createEventUi({\n                constraint: options.selectConstraint,\n                overlap: typeof options.selectOverlap === 'boolean' ? options.selectOverlap : undefined,\n                allow: options.selectAllow\n            }, calendarContext)\n        };\n    }\n    function computeIsLoading(state, context) {\n        for (let isLoadingFunc of context.pluginHooks.isLoadingFuncs){\n            if (isLoadingFunc(state)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    function parseContextBusinessHours(calendarContext) {\n        return parseBusinessHours(calendarContext.options.businessHours, calendarContext);\n    }\n    function warnUnknownOptions(options, viewName) {\n        for(let optionName in options){\n            console.warn(`Unknown option '${optionName}'` + (viewName ? ` for view '${viewName}'` : ''));\n        }\n    }\n    class ToolbarSection extends BaseComponent {\n        render() {\n            let children = this.props.widgetGroups.map((widgetGroup)=>this.renderWidgetGroup(widgetGroup));\n            return y('div', {\n                className: 'fc-toolbar-chunk'\n            }, ...children);\n        }\n        renderWidgetGroup(widgetGroup) {\n            let { props } = this;\n            let { theme } = this.context;\n            let children = [];\n            let isOnlyButtons = true;\n            for (let widget of widgetGroup){\n                let { buttonName, buttonClick, buttonText, buttonIcon, buttonHint } = widget;\n                if (buttonName === 'title') {\n                    isOnlyButtons = false;\n                    children.push(y(\"h2\", {\n                        className: \"fc-toolbar-title\",\n                        id: props.titleId\n                    }, props.title));\n                } else {\n                    let isPressed = buttonName === props.activeButton;\n                    let isDisabled = !props.isTodayEnabled && buttonName === 'today' || !props.isPrevEnabled && buttonName === 'prev' || !props.isNextEnabled && buttonName === 'next';\n                    let buttonClasses = [\n                        `fc-${buttonName}-button`,\n                        theme.getClass('button')\n                    ];\n                    if (isPressed) {\n                        buttonClasses.push(theme.getClass('buttonActive'));\n                    }\n                    children.push(y(\"button\", {\n                        type: \"button\",\n                        title: typeof buttonHint === 'function' ? buttonHint(props.navUnit) : buttonHint,\n                        disabled: isDisabled,\n                        \"aria-pressed\": isPressed,\n                        className: buttonClasses.join(' '),\n                        onClick: buttonClick\n                    }, buttonText || (buttonIcon ? y(\"span\", {\n                        className: buttonIcon\n                    }) : '')));\n                }\n            }\n            if (children.length > 1) {\n                let groupClassName = isOnlyButtons && theme.getClass('buttonGroup') || '';\n                return y('div', {\n                    className: groupClassName\n                }, ...children);\n            }\n            return children[0];\n        }\n    }\n    class Toolbar extends BaseComponent {\n        render() {\n            let { model, extraClassName } = this.props;\n            let forceLtr = false;\n            let startContent;\n            let endContent;\n            let sectionWidgets = model.sectionWidgets;\n            let centerContent = sectionWidgets.center;\n            if (sectionWidgets.left) {\n                forceLtr = true;\n                startContent = sectionWidgets.left;\n            } else {\n                startContent = sectionWidgets.start;\n            }\n            if (sectionWidgets.right) {\n                forceLtr = true;\n                endContent = sectionWidgets.right;\n            } else {\n                endContent = sectionWidgets.end;\n            }\n            let classNames = [\n                extraClassName || '',\n                'fc-toolbar',\n                forceLtr ? 'fc-toolbar-ltr' : ''\n            ];\n            return y(\"div\", {\n                className: classNames.join(' ')\n            }, this.renderSection('start', startContent || []), this.renderSection('center', centerContent || []), this.renderSection('end', endContent || []));\n        }\n        renderSection(key, widgetGroups) {\n            let { props } = this;\n            return y(ToolbarSection, {\n                key: key,\n                widgetGroups: widgetGroups,\n                title: props.title,\n                navUnit: props.navUnit,\n                activeButton: props.activeButton,\n                isTodayEnabled: props.isTodayEnabled,\n                isPrevEnabled: props.isPrevEnabled,\n                isNextEnabled: props.isNextEnabled,\n                titleId: props.titleId\n            });\n        }\n    }\n    class ViewHarness extends BaseComponent {\n        constructor(){\n            super(...arguments);\n            this.state = {\n                availableWidth: null\n            };\n            this.handleEl = (el)=>{\n                this.el = el;\n                setRef(this.props.elRef, el);\n                this.updateAvailableWidth();\n            };\n            this.handleResize = ()=>{\n                this.updateAvailableWidth();\n            };\n        }\n        render() {\n            let { props, state } = this;\n            let { aspectRatio } = props;\n            let classNames = [\n                'fc-view-harness',\n                aspectRatio || props.liquid || props.height ? 'fc-view-harness-active' // harness controls the height\n                 : 'fc-view-harness-passive'\n            ];\n            let height = '';\n            let paddingBottom = '';\n            if (aspectRatio) {\n                if (state.availableWidth !== null) {\n                    height = state.availableWidth / aspectRatio;\n                } else {\n                    // while waiting to know availableWidth, we can't set height to *zero*\n                    // because will cause lots of unnecessary scrollbars within scrollgrid.\n                    // BETTER: don't start rendering ANYTHING yet until we know container width\n                    // NOTE: why not always use paddingBottom? Causes height oscillation (issue 5606)\n                    paddingBottom = `${1 / aspectRatio * 100}%`;\n                }\n            } else {\n                height = props.height || '';\n            }\n            return y(\"div\", {\n                \"aria-labelledby\": props.labeledById,\n                ref: this.handleEl,\n                className: classNames.join(' '),\n                style: {\n                    height,\n                    paddingBottom\n                }\n            }, props.children);\n        }\n        componentDidMount() {\n            this.context.addResizeHandler(this.handleResize);\n        }\n        componentWillUnmount() {\n            this.context.removeResizeHandler(this.handleResize);\n        }\n        updateAvailableWidth() {\n            if (this.el && // needed. but why?\n            this.props.aspectRatio // aspectRatio is the only height setting that needs availableWidth\n            ) {\n                this.setState({\n                    availableWidth: this.el.offsetWidth\n                });\n            }\n        }\n    }\n    /*\r\n    Detects when the user clicks on an event within a DateComponent\r\n    */ class EventClicking extends Interaction {\n        constructor(settings){\n            super(settings);\n            this.handleSegClick = (ev, segEl)=>{\n                let { component } = this;\n                let { context } = component;\n                let seg = getElSeg(segEl);\n                if (seg && // might be the <div> surrounding the more link\n                component.isValidSegDownEl(ev.target)) {\n                    // our way to simulate a link click for elements that can't be <a> tags\n                    // grab before trigger fired in case trigger trashes DOM thru rerendering\n                    let hasUrlContainer = elementClosest(ev.target, '.fc-event-forced-url');\n                    let url = hasUrlContainer ? hasUrlContainer.querySelector('a[href]').href : '';\n                    context.emitter.trigger('eventClick', {\n                        el: segEl,\n                        event: new EventImpl(component.context, seg.eventRange.def, seg.eventRange.instance),\n                        jsEvent: ev,\n                        view: context.viewApi\n                    });\n                    if (url && !ev.defaultPrevented) {\n                        window.location.href = url;\n                    }\n                }\n            };\n            this.destroy = listenBySelector(settings.el, 'click', '.fc-event', this.handleSegClick);\n        }\n    }\n    /*\r\n    Triggers events and adds/removes core classNames when the user's pointer\r\n    enters/leaves event-elements of a component.\r\n    */ class EventHovering extends Interaction {\n        constructor(settings){\n            super(settings);\n            // for simulating an eventMouseLeave when the event el is destroyed while mouse is over it\n            this.handleEventElRemove = (el)=>{\n                if (el === this.currentSegEl) {\n                    this.handleSegLeave(null, this.currentSegEl);\n                }\n            };\n            this.handleSegEnter = (ev, segEl)=>{\n                if (getElSeg(segEl)) {\n                    this.currentSegEl = segEl;\n                    this.triggerEvent('eventMouseEnter', ev, segEl);\n                }\n            };\n            this.handleSegLeave = (ev, segEl)=>{\n                if (this.currentSegEl) {\n                    this.currentSegEl = null;\n                    this.triggerEvent('eventMouseLeave', ev, segEl);\n                }\n            };\n            this.removeHoverListeners = listenToHoverBySelector(settings.el, '.fc-event', this.handleSegEnter, this.handleSegLeave);\n        }\n        destroy() {\n            this.removeHoverListeners();\n        }\n        triggerEvent(publicEvName, ev, segEl) {\n            let { component } = this;\n            let { context } = component;\n            let seg = getElSeg(segEl);\n            if (!ev || component.isValidSegDownEl(ev.target)) {\n                context.emitter.trigger(publicEvName, {\n                    el: segEl,\n                    event: new EventImpl(context, seg.eventRange.def, seg.eventRange.instance),\n                    jsEvent: ev,\n                    view: context.viewApi\n                });\n            }\n        }\n    }\n    class CalendarContent extends PureComponent {\n        constructor(){\n            super(...arguments);\n            this.buildViewContext = memoize(buildViewContext);\n            this.buildViewPropTransformers = memoize(buildViewPropTransformers);\n            this.buildToolbarProps = memoize(buildToolbarProps);\n            this.headerRef = d();\n            this.footerRef = d();\n            this.interactionsStore = {};\n            // eslint-disable-next-line\n            this.state = {\n                viewLabelId: getUniqueDomId()\n            };\n            // Component Registration\n            // -----------------------------------------------------------------------------------------------------------------\n            this.registerInteractiveComponent = (component, settingsInput)=>{\n                let settings = parseInteractionSettings(component, settingsInput);\n                let DEFAULT_INTERACTIONS = [\n                    EventClicking,\n                    EventHovering\n                ];\n                let interactionClasses = DEFAULT_INTERACTIONS.concat(this.props.pluginHooks.componentInteractions);\n                let interactions = interactionClasses.map((TheInteractionClass)=>new TheInteractionClass(settings));\n                this.interactionsStore[component.uid] = interactions;\n                interactionSettingsStore[component.uid] = settings;\n            };\n            this.unregisterInteractiveComponent = (component)=>{\n                let listeners = this.interactionsStore[component.uid];\n                if (listeners) {\n                    for (let listener of listeners){\n                        listener.destroy();\n                    }\n                    delete this.interactionsStore[component.uid];\n                }\n                delete interactionSettingsStore[component.uid];\n            };\n            // Resizing\n            // -----------------------------------------------------------------------------------------------------------------\n            this.resizeRunner = new DelayedRunner(()=>{\n                this.props.emitter.trigger('_resize', true); // should window resizes be considered \"forced\" ?\n                this.props.emitter.trigger('windowResize', {\n                    view: this.props.viewApi\n                });\n            });\n            this.handleWindowResize = (ev)=>{\n                let { options } = this.props;\n                if (options.handleWindowResize && ev.target === window // avoid jqui events\n                ) {\n                    this.resizeRunner.request(options.windowResizeDelay);\n                }\n            };\n        }\n        /*\r\n        renders INSIDE of an outer div\r\n        */ render() {\n            let { props } = this;\n            let { toolbarConfig, options } = props;\n            let toolbarProps = this.buildToolbarProps(props.viewSpec, props.dateProfile, props.dateProfileGenerator, props.currentDate, getNow(props.options.now, props.dateEnv), props.viewTitle);\n            let viewVGrow = false;\n            let viewHeight = '';\n            let viewAspectRatio;\n            if (props.isHeightAuto || props.forPrint) {\n                viewHeight = '';\n            } else if (options.height != null) {\n                viewVGrow = true;\n            } else if (options.contentHeight != null) {\n                viewHeight = options.contentHeight;\n            } else {\n                viewAspectRatio = Math.max(options.aspectRatio, 0.5); // prevent from getting too tall\n            }\n            let viewContext = this.buildViewContext(props.viewSpec, props.viewApi, props.options, props.dateProfileGenerator, props.dateEnv, props.theme, props.pluginHooks, props.dispatch, props.getCurrentData, props.emitter, props.calendarApi, this.registerInteractiveComponent, this.unregisterInteractiveComponent);\n            let viewLabelId = toolbarConfig.header && toolbarConfig.header.hasTitle ? this.state.viewLabelId : '';\n            return y(ViewContextType.Provider, {\n                value: viewContext\n            }, toolbarConfig.header && y(Toolbar, Object.assign({\n                ref: this.headerRef,\n                extraClassName: \"fc-header-toolbar\",\n                model: toolbarConfig.header,\n                titleId: viewLabelId\n            }, toolbarProps)), y(ViewHarness, {\n                liquid: viewVGrow,\n                height: viewHeight,\n                aspectRatio: viewAspectRatio,\n                labeledById: viewLabelId\n            }, this.renderView(props), this.buildAppendContent()), toolbarConfig.footer && y(Toolbar, Object.assign({\n                ref: this.footerRef,\n                extraClassName: \"fc-footer-toolbar\",\n                model: toolbarConfig.footer,\n                titleId: \"\"\n            }, toolbarProps)));\n        }\n        componentDidMount() {\n            let { props } = this;\n            this.calendarInteractions = props.pluginHooks.calendarInteractions.map((CalendarInteractionClass)=>new CalendarInteractionClass(props));\n            window.addEventListener('resize', this.handleWindowResize);\n            let { propSetHandlers } = props.pluginHooks;\n            for(let propName in propSetHandlers){\n                propSetHandlers[propName](props[propName], props);\n            }\n        }\n        componentDidUpdate(prevProps) {\n            let { props } = this;\n            let { propSetHandlers } = props.pluginHooks;\n            for(let propName in propSetHandlers){\n                if (props[propName] !== prevProps[propName]) {\n                    propSetHandlers[propName](props[propName], props);\n                }\n            }\n        }\n        componentWillUnmount() {\n            window.removeEventListener('resize', this.handleWindowResize);\n            this.resizeRunner.clear();\n            for (let interaction of this.calendarInteractions){\n                interaction.destroy();\n            }\n            this.props.emitter.trigger('_unmount');\n        }\n        buildAppendContent() {\n            let { props } = this;\n            let children = props.pluginHooks.viewContainerAppends.map((buildAppendContent)=>buildAppendContent(props));\n            return y(_, {}, ...children);\n        }\n        renderView(props) {\n            let { pluginHooks } = props;\n            let { viewSpec } = props;\n            let viewProps = {\n                dateProfile: props.dateProfile,\n                businessHours: props.businessHours,\n                eventStore: props.renderableEventStore,\n                eventUiBases: props.eventUiBases,\n                dateSelection: props.dateSelection,\n                eventSelection: props.eventSelection,\n                eventDrag: props.eventDrag,\n                eventResize: props.eventResize,\n                isHeightAuto: props.isHeightAuto,\n                forPrint: props.forPrint\n            };\n            let transformers = this.buildViewPropTransformers(pluginHooks.viewPropsTransformers);\n            for (let transformer of transformers){\n                Object.assign(viewProps, transformer.transform(viewProps, props));\n            }\n            let ViewComponent = viewSpec.component;\n            return y(ViewComponent, Object.assign({}, viewProps));\n        }\n    }\n    function buildToolbarProps(viewSpec, dateProfile, dateProfileGenerator, currentDate, now, title) {\n        // don't force any date-profiles to valid date profiles (the `false`) so that we can tell if it's invalid\n        let todayInfo = dateProfileGenerator.build(now, undefined, false); // TODO: need `undefined` or else INFINITE LOOP for some reason\n        let prevInfo = dateProfileGenerator.buildPrev(dateProfile, currentDate, false);\n        let nextInfo = dateProfileGenerator.buildNext(dateProfile, currentDate, false);\n        return {\n            title,\n            activeButton: viewSpec.type,\n            navUnit: viewSpec.singleUnit,\n            isTodayEnabled: todayInfo.isValid && !rangeContainsMarker(dateProfile.currentRange, now),\n            isPrevEnabled: prevInfo.isValid,\n            isNextEnabled: nextInfo.isValid\n        };\n    }\n    // Plugin\n    // -----------------------------------------------------------------------------------------------------------------\n    function buildViewPropTransformers(theClasses) {\n        return theClasses.map((TheClass)=>new TheClass());\n    }\n    class Calendar extends CalendarImpl {\n        constructor(el, optionOverrides = {}){\n            super();\n            this.isRendering = false;\n            this.isRendered = false;\n            this.currentClassNames = [];\n            this.customContentRenderId = 0;\n            this.handleAction = (action)=>{\n                // actions we know we want to render immediately\n                switch(action.type){\n                    case 'SET_EVENT_DRAG':\n                    case 'SET_EVENT_RESIZE':\n                        this.renderRunner.tryDrain();\n                }\n            };\n            this.handleData = (data)=>{\n                this.currentData = data;\n                this.renderRunner.request(data.calendarOptions.rerenderDelay);\n            };\n            this.handleRenderRequest = ()=>{\n                if (this.isRendering) {\n                    this.isRendered = true;\n                    let { currentData } = this;\n                    flushSync(()=>{\n                        D$1(y(CalendarRoot, {\n                            options: currentData.calendarOptions,\n                            theme: currentData.theme,\n                            emitter: currentData.emitter\n                        }, (classNames, height, isHeightAuto, forPrint)=>{\n                            this.setClassNames(classNames);\n                            this.setHeight(height);\n                            return y(RenderId.Provider, {\n                                value: this.customContentRenderId\n                            }, y(CalendarContent, Object.assign({\n                                isHeightAuto: isHeightAuto,\n                                forPrint: forPrint\n                            }, currentData)));\n                        }), this.el);\n                    });\n                } else if (this.isRendered) {\n                    this.isRendered = false;\n                    D$1(null, this.el);\n                    this.setClassNames([]);\n                    this.setHeight('');\n                }\n            };\n            ensureElHasStyles(el);\n            this.el = el;\n            this.renderRunner = new DelayedRunner(this.handleRenderRequest);\n            new CalendarDataManager({\n                optionOverrides,\n                calendarApi: this,\n                onAction: this.handleAction,\n                onData: this.handleData\n            });\n        }\n        render() {\n            let wasRendering = this.isRendering;\n            if (!wasRendering) {\n                this.isRendering = true;\n            } else {\n                this.customContentRenderId += 1;\n            }\n            this.renderRunner.request();\n            if (wasRendering) {\n                this.updateSize();\n            }\n        }\n        destroy() {\n            if (this.isRendering) {\n                this.isRendering = false;\n                this.renderRunner.request();\n            }\n        }\n        updateSize() {\n            flushSync(()=>{\n                super.updateSize();\n            });\n        }\n        batchRendering(func) {\n            this.renderRunner.pause('batchRendering');\n            func();\n            this.renderRunner.resume('batchRendering');\n        }\n        pauseRendering() {\n            this.renderRunner.pause('pauseRendering');\n        }\n        resumeRendering() {\n            this.renderRunner.resume('pauseRendering', true);\n        }\n        resetOptions(optionOverrides, changedOptionNames) {\n            this.currentDataManager.resetOptions(optionOverrides, changedOptionNames);\n        }\n        setClassNames(classNames) {\n            if (!isArraysEqual(classNames, this.currentClassNames)) {\n                let { classList } = this.el;\n                for (let className of this.currentClassNames){\n                    classList.remove(className);\n                }\n                for (let className of classNames){\n                    classList.add(className);\n                }\n                this.currentClassNames = classNames;\n            }\n        }\n        setHeight(height) {\n            applyStyleProp(this.el, 'height', height);\n        }\n    }\n    function formatDate(dateInput, options = {}) {\n        let dateEnv = buildDateEnv(options);\n        let formatter = createFormatter(options);\n        let dateMeta = dateEnv.createMarkerMeta(dateInput);\n        if (!dateMeta) {\n            return '';\n        }\n        return dateEnv.format(dateMeta.marker, formatter, {\n            forcedTzo: dateMeta.forcedTzo\n        });\n    }\n    function formatRange(startInput, endInput, options) {\n        let dateEnv = buildDateEnv(typeof options === 'object' && options ? options : {}); // pass in if non-null object\n        let formatter = createFormatter(options);\n        let startMeta = dateEnv.createMarkerMeta(startInput);\n        let endMeta = dateEnv.createMarkerMeta(endInput);\n        if (!startMeta || !endMeta) {\n            return '';\n        }\n        return dateEnv.formatRange(startMeta.marker, endMeta.marker, formatter, {\n            forcedStartTzo: startMeta.forcedTzo,\n            forcedEndTzo: endMeta.forcedTzo,\n            isEndExclusive: options.isEndExclusive,\n            defaultSeparator: BASE_OPTION_DEFAULTS.defaultRangeSeparator\n        });\n    }\n    // TODO: more DRY and optimized\n    function buildDateEnv(settings) {\n        let locale = buildLocale(settings.locale || 'en', organizeRawLocales([]).map); // TODO: don't hardcode 'en' everywhere\n        return new DateEnv(Object.assign(Object.assign({\n            timeZone: BASE_OPTION_DEFAULTS.timeZone,\n            calendarSystem: 'gregory'\n        }, settings), {\n            locale\n        }));\n    }\n    // HELPERS\n    /*\r\n    if nextDayThreshold is specified, slicing is done in an all-day fashion.\r\n    you can get nextDayThreshold from context.nextDayThreshold\r\n    */ function sliceEvents(props, allDay) {\n        return sliceEventStore(props.eventStore, props.eventUiBases, props.dateProfile.activeRange, allDay ? props.nextDayThreshold : null).fg;\n    }\n    const version = '6.1.8';\n    config.touchMouseIgnoreWait = 500;\n    let ignoreMouseDepth = 0;\n    let listenerCnt = 0;\n    let isWindowTouchMoveCancelled = false;\n    /*\r\n    Uses a \"pointer\" abstraction, which monitors UI events for both mouse and touch.\r\n    Tracks when the pointer \"drags\" on a certain element, meaning down+move+up.\r\n\r\n    Also, tracks if there was touch-scrolling.\r\n    Also, can prevent touch-scrolling from happening.\r\n    Also, can fire pointermove events when scrolling happens underneath, even when no real pointer movement.\r\n\r\n    emits:\r\n    - pointerdown\r\n    - pointermove\r\n    - pointerup\r\n    */ class PointerDragging {\n        constructor(containerEl){\n            this.subjectEl = null;\n            // options that can be directly assigned by caller\n            this.selector = ''; // will cause subjectEl in all emitted events to be this element\n            this.handleSelector = '';\n            this.shouldIgnoreMove = false;\n            this.shouldWatchScroll = true; // for simulating pointermove on scroll\n            // internal states\n            this.isDragging = false;\n            this.isTouchDragging = false;\n            this.wasTouchScroll = false;\n            // Mouse\n            // ----------------------------------------------------------------------------------------------------\n            this.handleMouseDown = (ev)=>{\n                if (!this.shouldIgnoreMouse() && isPrimaryMouseButton(ev) && this.tryStart(ev)) {\n                    let pev = this.createEventFromMouse(ev, true);\n                    this.emitter.trigger('pointerdown', pev);\n                    this.initScrollWatch(pev);\n                    if (!this.shouldIgnoreMove) {\n                        document.addEventListener('mousemove', this.handleMouseMove);\n                    }\n                    document.addEventListener('mouseup', this.handleMouseUp);\n                }\n            };\n            this.handleMouseMove = (ev)=>{\n                let pev = this.createEventFromMouse(ev);\n                this.recordCoords(pev);\n                this.emitter.trigger('pointermove', pev);\n            };\n            this.handleMouseUp = (ev)=>{\n                document.removeEventListener('mousemove', this.handleMouseMove);\n                document.removeEventListener('mouseup', this.handleMouseUp);\n                this.emitter.trigger('pointerup', this.createEventFromMouse(ev));\n                this.cleanup(); // call last so that pointerup has access to props\n            };\n            // Touch\n            // ----------------------------------------------------------------------------------------------------\n            this.handleTouchStart = (ev)=>{\n                if (this.tryStart(ev)) {\n                    this.isTouchDragging = true;\n                    let pev = this.createEventFromTouch(ev, true);\n                    this.emitter.trigger('pointerdown', pev);\n                    this.initScrollWatch(pev);\n                    // unlike mouse, need to attach to target, not document\n                    // https://stackoverflow.com/a/45760014\n                    let targetEl = ev.target;\n                    if (!this.shouldIgnoreMove) {\n                        targetEl.addEventListener('touchmove', this.handleTouchMove);\n                    }\n                    targetEl.addEventListener('touchend', this.handleTouchEnd);\n                    targetEl.addEventListener('touchcancel', this.handleTouchEnd); // treat it as a touch end\n                    // attach a handler to get called when ANY scroll action happens on the page.\n                    // this was impossible to do with normal on/off because 'scroll' doesn't bubble.\n                    // http://stackoverflow.com/a/32954565/96342\n                    window.addEventListener('scroll', this.handleTouchScroll, true);\n                }\n            };\n            this.handleTouchMove = (ev)=>{\n                let pev = this.createEventFromTouch(ev);\n                this.recordCoords(pev);\n                this.emitter.trigger('pointermove', pev);\n            };\n            this.handleTouchEnd = (ev)=>{\n                if (this.isDragging) {\n                    let targetEl = ev.target;\n                    targetEl.removeEventListener('touchmove', this.handleTouchMove);\n                    targetEl.removeEventListener('touchend', this.handleTouchEnd);\n                    targetEl.removeEventListener('touchcancel', this.handleTouchEnd);\n                    window.removeEventListener('scroll', this.handleTouchScroll, true); // useCaptured=true\n                    this.emitter.trigger('pointerup', this.createEventFromTouch(ev));\n                    this.cleanup(); // call last so that pointerup has access to props\n                    this.isTouchDragging = false;\n                    startIgnoringMouse();\n                }\n            };\n            this.handleTouchScroll = ()=>{\n                this.wasTouchScroll = true;\n            };\n            this.handleScroll = (ev)=>{\n                if (!this.shouldIgnoreMove) {\n                    let pageX = window.pageXOffset - this.prevScrollX + this.prevPageX;\n                    let pageY = window.pageYOffset - this.prevScrollY + this.prevPageY;\n                    this.emitter.trigger('pointermove', {\n                        origEvent: ev,\n                        isTouch: this.isTouchDragging,\n                        subjectEl: this.subjectEl,\n                        pageX,\n                        pageY,\n                        deltaX: pageX - this.origPageX,\n                        deltaY: pageY - this.origPageY\n                    });\n                }\n            };\n            this.containerEl = containerEl;\n            this.emitter = new Emitter();\n            containerEl.addEventListener('mousedown', this.handleMouseDown);\n            containerEl.addEventListener('touchstart', this.handleTouchStart, {\n                passive: true\n            });\n            listenerCreated();\n        }\n        destroy() {\n            this.containerEl.removeEventListener('mousedown', this.handleMouseDown);\n            this.containerEl.removeEventListener('touchstart', this.handleTouchStart, {\n                passive: true\n            });\n            listenerDestroyed();\n        }\n        tryStart(ev) {\n            let subjectEl = this.querySubjectEl(ev);\n            let downEl = ev.target;\n            if (subjectEl && (!this.handleSelector || elementClosest(downEl, this.handleSelector))) {\n                this.subjectEl = subjectEl;\n                this.isDragging = true; // do this first so cancelTouchScroll will work\n                this.wasTouchScroll = false;\n                return true;\n            }\n            return false;\n        }\n        cleanup() {\n            isWindowTouchMoveCancelled = false;\n            this.isDragging = false;\n            this.subjectEl = null;\n            // keep wasTouchScroll around for later access\n            this.destroyScrollWatch();\n        }\n        querySubjectEl(ev) {\n            if (this.selector) {\n                return elementClosest(ev.target, this.selector);\n            }\n            return this.containerEl;\n        }\n        shouldIgnoreMouse() {\n            return ignoreMouseDepth || this.isTouchDragging;\n        }\n        // can be called by user of this class, to cancel touch-based scrolling for the current drag\n        cancelTouchScroll() {\n            if (this.isDragging) {\n                isWindowTouchMoveCancelled = true;\n            }\n        }\n        // Scrolling that simulates pointermoves\n        // ----------------------------------------------------------------------------------------------------\n        initScrollWatch(ev) {\n            if (this.shouldWatchScroll) {\n                this.recordCoords(ev);\n                window.addEventListener('scroll', this.handleScroll, true); // useCapture=true\n            }\n        }\n        recordCoords(ev) {\n            if (this.shouldWatchScroll) {\n                this.prevPageX = ev.pageX;\n                this.prevPageY = ev.pageY;\n                this.prevScrollX = window.pageXOffset;\n                this.prevScrollY = window.pageYOffset;\n            }\n        }\n        destroyScrollWatch() {\n            if (this.shouldWatchScroll) {\n                window.removeEventListener('scroll', this.handleScroll, true); // useCaptured=true\n            }\n        }\n        // Event Normalization\n        // ----------------------------------------------------------------------------------------------------\n        createEventFromMouse(ev, isFirst) {\n            let deltaX = 0;\n            let deltaY = 0;\n            // TODO: repeat code\n            if (isFirst) {\n                this.origPageX = ev.pageX;\n                this.origPageY = ev.pageY;\n            } else {\n                deltaX = ev.pageX - this.origPageX;\n                deltaY = ev.pageY - this.origPageY;\n            }\n            return {\n                origEvent: ev,\n                isTouch: false,\n                subjectEl: this.subjectEl,\n                pageX: ev.pageX,\n                pageY: ev.pageY,\n                deltaX,\n                deltaY\n            };\n        }\n        createEventFromTouch(ev, isFirst) {\n            let touches = ev.touches;\n            let pageX;\n            let pageY;\n            let deltaX = 0;\n            let deltaY = 0;\n            // if touch coords available, prefer,\n            // because FF would give bad ev.pageX ev.pageY\n            if (touches && touches.length) {\n                pageX = touches[0].pageX;\n                pageY = touches[0].pageY;\n            } else {\n                pageX = ev.pageX;\n                pageY = ev.pageY;\n            }\n            // TODO: repeat code\n            if (isFirst) {\n                this.origPageX = pageX;\n                this.origPageY = pageY;\n            } else {\n                deltaX = pageX - this.origPageX;\n                deltaY = pageY - this.origPageY;\n            }\n            return {\n                origEvent: ev,\n                isTouch: true,\n                subjectEl: this.subjectEl,\n                pageX,\n                pageY,\n                deltaX,\n                deltaY\n            };\n        }\n    }\n    // Returns a boolean whether this was a left mouse click and no ctrl key (which means right click on Mac)\n    function isPrimaryMouseButton(ev) {\n        return ev.button === 0 && !ev.ctrlKey;\n    }\n    // Ignoring fake mouse events generated by touch\n    // ----------------------------------------------------------------------------------------------------\n    function startIgnoringMouse() {\n        ignoreMouseDepth += 1;\n        setTimeout(()=>{\n            ignoreMouseDepth -= 1;\n        }, config.touchMouseIgnoreWait);\n    }\n    // We want to attach touchmove as early as possible for Safari\n    // ----------------------------------------------------------------------------------------------------\n    function listenerCreated() {\n        listenerCnt += 1;\n        if (listenerCnt === 1) {\n            window.addEventListener('touchmove', onWindowTouchMove, {\n                passive: false\n            });\n        }\n    }\n    function listenerDestroyed() {\n        listenerCnt -= 1;\n        if (!listenerCnt) {\n            window.removeEventListener('touchmove', onWindowTouchMove, {\n                passive: false\n            });\n        }\n    }\n    function onWindowTouchMove(ev) {\n        if (isWindowTouchMoveCancelled) {\n            ev.preventDefault();\n        }\n    }\n    /*\r\n    An effect in which an element follows the movement of a pointer across the screen.\r\n    The moving element is a clone of some other element.\r\n    Must call start + handleMove + stop.\r\n    */ class ElementMirror {\n        constructor(){\n            this.isVisible = false; // must be explicitly enabled\n            this.sourceEl = null;\n            this.mirrorEl = null;\n            this.sourceElRect = null; // screen coords relative to viewport\n            // options that can be set directly by caller\n            this.parentNode = document.body; // HIGHLY SUGGESTED to set this to sidestep ShadowDOM issues\n            this.zIndex = 9999;\n            this.revertDuration = 0;\n        }\n        start(sourceEl, pageX, pageY) {\n            this.sourceEl = sourceEl;\n            this.sourceElRect = this.sourceEl.getBoundingClientRect();\n            this.origScreenX = pageX - window.pageXOffset;\n            this.origScreenY = pageY - window.pageYOffset;\n            this.deltaX = 0;\n            this.deltaY = 0;\n            this.updateElPosition();\n        }\n        handleMove(pageX, pageY) {\n            this.deltaX = pageX - window.pageXOffset - this.origScreenX;\n            this.deltaY = pageY - window.pageYOffset - this.origScreenY;\n            this.updateElPosition();\n        }\n        // can be called before start\n        setIsVisible(bool) {\n            if (bool) {\n                if (!this.isVisible) {\n                    if (this.mirrorEl) {\n                        this.mirrorEl.style.display = '';\n                    }\n                    this.isVisible = bool; // needs to happen before updateElPosition\n                    this.updateElPosition(); // because was not updating the position while invisible\n                }\n            } else if (this.isVisible) {\n                if (this.mirrorEl) {\n                    this.mirrorEl.style.display = 'none';\n                }\n                this.isVisible = bool;\n            }\n        }\n        // always async\n        stop(needsRevertAnimation, callback) {\n            let done = ()=>{\n                this.cleanup();\n                callback();\n            };\n            if (needsRevertAnimation && this.mirrorEl && this.isVisible && this.revertDuration && // if 0, transition won't work\n            (this.deltaX || this.deltaY // if same coords, transition won't work\n            )) {\n                this.doRevertAnimation(done, this.revertDuration);\n            } else {\n                setTimeout(done, 0);\n            }\n        }\n        doRevertAnimation(callback, revertDuration) {\n            let mirrorEl = this.mirrorEl;\n            let finalSourceElRect = this.sourceEl.getBoundingClientRect(); // because autoscrolling might have happened\n            mirrorEl.style.transition = 'top ' + revertDuration + 'ms,' + 'left ' + revertDuration + 'ms';\n            applyStyle(mirrorEl, {\n                left: finalSourceElRect.left,\n                top: finalSourceElRect.top\n            });\n            whenTransitionDone(mirrorEl, ()=>{\n                mirrorEl.style.transition = '';\n                callback();\n            });\n        }\n        cleanup() {\n            if (this.mirrorEl) {\n                removeElement(this.mirrorEl);\n                this.mirrorEl = null;\n            }\n            this.sourceEl = null;\n        }\n        updateElPosition() {\n            if (this.sourceEl && this.isVisible) {\n                applyStyle(this.getMirrorEl(), {\n                    left: this.sourceElRect.left + this.deltaX,\n                    top: this.sourceElRect.top + this.deltaY\n                });\n            }\n        }\n        getMirrorEl() {\n            let sourceElRect = this.sourceElRect;\n            let mirrorEl = this.mirrorEl;\n            if (!mirrorEl) {\n                mirrorEl = this.mirrorEl = this.sourceEl.cloneNode(true); // cloneChildren=true\n                // we don't want long taps or any mouse interaction causing selection/menus.\n                // would use preventSelection(), but that prevents selectstart, causing problems.\n                mirrorEl.style.userSelect = 'none';\n                mirrorEl.classList.add('fc-event-dragging');\n                applyStyle(mirrorEl, {\n                    position: 'fixed',\n                    zIndex: this.zIndex,\n                    visibility: '',\n                    boxSizing: 'border-box',\n                    width: sourceElRect.right - sourceElRect.left,\n                    height: sourceElRect.bottom - sourceElRect.top,\n                    right: 'auto',\n                    bottom: 'auto',\n                    margin: 0\n                });\n                this.parentNode.appendChild(mirrorEl);\n            }\n            return mirrorEl;\n        }\n    }\n    /*\r\n    Is a cache for a given element's scroll information (all the info that ScrollController stores)\r\n    in addition the \"client rectangle\" of the element.. the area within the scrollbars.\r\n\r\n    The cache can be in one of two modes:\r\n    - doesListening:false - ignores when the container is scrolled by someone else\r\n    - doesListening:true - watch for scrolling and update the cache\r\n    */ class ScrollGeomCache extends ScrollController {\n        constructor(scrollController, doesListening){\n            super();\n            this.handleScroll = ()=>{\n                this.scrollTop = this.scrollController.getScrollTop();\n                this.scrollLeft = this.scrollController.getScrollLeft();\n                this.handleScrollChange();\n            };\n            this.scrollController = scrollController;\n            this.doesListening = doesListening;\n            this.scrollTop = this.origScrollTop = scrollController.getScrollTop();\n            this.scrollLeft = this.origScrollLeft = scrollController.getScrollLeft();\n            this.scrollWidth = scrollController.getScrollWidth();\n            this.scrollHeight = scrollController.getScrollHeight();\n            this.clientWidth = scrollController.getClientWidth();\n            this.clientHeight = scrollController.getClientHeight();\n            this.clientRect = this.computeClientRect(); // do last in case it needs cached values\n            if (this.doesListening) {\n                this.getEventTarget().addEventListener('scroll', this.handleScroll);\n            }\n        }\n        destroy() {\n            if (this.doesListening) {\n                this.getEventTarget().removeEventListener('scroll', this.handleScroll);\n            }\n        }\n        getScrollTop() {\n            return this.scrollTop;\n        }\n        getScrollLeft() {\n            return this.scrollLeft;\n        }\n        setScrollTop(top) {\n            this.scrollController.setScrollTop(top);\n            if (!this.doesListening) {\n                // we are not relying on the element to normalize out-of-bounds scroll values\n                // so we need to sanitize ourselves\n                this.scrollTop = Math.max(Math.min(top, this.getMaxScrollTop()), 0);\n                this.handleScrollChange();\n            }\n        }\n        setScrollLeft(top) {\n            this.scrollController.setScrollLeft(top);\n            if (!this.doesListening) {\n                // we are not relying on the element to normalize out-of-bounds scroll values\n                // so we need to sanitize ourselves\n                this.scrollLeft = Math.max(Math.min(top, this.getMaxScrollLeft()), 0);\n                this.handleScrollChange();\n            }\n        }\n        getClientWidth() {\n            return this.clientWidth;\n        }\n        getClientHeight() {\n            return this.clientHeight;\n        }\n        getScrollWidth() {\n            return this.scrollWidth;\n        }\n        getScrollHeight() {\n            return this.scrollHeight;\n        }\n        handleScrollChange() {}\n    }\n    class ElementScrollGeomCache extends ScrollGeomCache {\n        constructor(el, doesListening){\n            super(new ElementScrollController(el), doesListening);\n        }\n        getEventTarget() {\n            return this.scrollController.el;\n        }\n        computeClientRect() {\n            return computeInnerRect(this.scrollController.el);\n        }\n    }\n    class WindowScrollGeomCache extends ScrollGeomCache {\n        constructor(doesListening){\n            super(new WindowScrollController(), doesListening);\n        }\n        getEventTarget() {\n            return window;\n        }\n        computeClientRect() {\n            return {\n                left: this.scrollLeft,\n                right: this.scrollLeft + this.clientWidth,\n                top: this.scrollTop,\n                bottom: this.scrollTop + this.clientHeight\n            };\n        }\n        // the window is the only scroll object that changes it's rectangle relative\n        // to the document's topleft as it scrolls\n        handleScrollChange() {\n            this.clientRect = this.computeClientRect();\n        }\n    }\n    // If available we are using native \"performance\" API instead of \"Date\"\n    // Read more about it on MDN:\n    // https://developer.mozilla.org/en-US/docs/Web/API/Performance\n    const getTime = typeof performance === 'function' ? performance.now : Date.now;\n    /*\r\n    For a pointer interaction, automatically scrolls certain scroll containers when the pointer\r\n    approaches the edge.\r\n\r\n    The caller must call start + handleMove + stop.\r\n    */ class AutoScroller {\n        constructor(){\n            // options that can be set by caller\n            this.isEnabled = true;\n            this.scrollQuery = [\n                window,\n                '.fc-scroller'\n            ];\n            this.edgeThreshold = 50; // pixels\n            this.maxVelocity = 300; // pixels per second\n            // internal state\n            this.pointerScreenX = null;\n            this.pointerScreenY = null;\n            this.isAnimating = false;\n            this.scrollCaches = null;\n            // protect against the initial pointerdown being too close to an edge and starting the scroll\n            this.everMovedUp = false;\n            this.everMovedDown = false;\n            this.everMovedLeft = false;\n            this.everMovedRight = false;\n            this.animate = ()=>{\n                if (this.isAnimating) {\n                    let edge = this.computeBestEdge(this.pointerScreenX + window.pageXOffset, this.pointerScreenY + window.pageYOffset);\n                    if (edge) {\n                        let now = getTime();\n                        this.handleSide(edge, (now - this.msSinceRequest) / 1000);\n                        this.requestAnimation(now);\n                    } else {\n                        this.isAnimating = false; // will stop animation\n                    }\n                }\n            };\n        }\n        start(pageX, pageY, scrollStartEl) {\n            if (this.isEnabled) {\n                this.scrollCaches = this.buildCaches(scrollStartEl);\n                this.pointerScreenX = null;\n                this.pointerScreenY = null;\n                this.everMovedUp = false;\n                this.everMovedDown = false;\n                this.everMovedLeft = false;\n                this.everMovedRight = false;\n                this.handleMove(pageX, pageY);\n            }\n        }\n        handleMove(pageX, pageY) {\n            if (this.isEnabled) {\n                let pointerScreenX = pageX - window.pageXOffset;\n                let pointerScreenY = pageY - window.pageYOffset;\n                let yDelta = this.pointerScreenY === null ? 0 : pointerScreenY - this.pointerScreenY;\n                let xDelta = this.pointerScreenX === null ? 0 : pointerScreenX - this.pointerScreenX;\n                if (yDelta < 0) {\n                    this.everMovedUp = true;\n                } else if (yDelta > 0) {\n                    this.everMovedDown = true;\n                }\n                if (xDelta < 0) {\n                    this.everMovedLeft = true;\n                } else if (xDelta > 0) {\n                    this.everMovedRight = true;\n                }\n                this.pointerScreenX = pointerScreenX;\n                this.pointerScreenY = pointerScreenY;\n                if (!this.isAnimating) {\n                    this.isAnimating = true;\n                    this.requestAnimation(getTime());\n                }\n            }\n        }\n        stop() {\n            if (this.isEnabled) {\n                this.isAnimating = false; // will stop animation\n                for (let scrollCache of this.scrollCaches){\n                    scrollCache.destroy();\n                }\n                this.scrollCaches = null;\n            }\n        }\n        requestAnimation(now) {\n            this.msSinceRequest = now;\n            requestAnimationFrame(this.animate);\n        }\n        handleSide(edge, seconds) {\n            let { scrollCache } = edge;\n            let { edgeThreshold } = this;\n            let invDistance = edgeThreshold - edge.distance;\n            let velocity = invDistance * invDistance / (edgeThreshold * edgeThreshold) * // quadratic\n            this.maxVelocity * seconds;\n            let sign = 1;\n            switch(edge.name){\n                case 'left':\n                    sign = -1;\n                // falls through\n                case 'right':\n                    scrollCache.setScrollLeft(scrollCache.getScrollLeft() + velocity * sign);\n                    break;\n                case 'top':\n                    sign = -1;\n                // falls through\n                case 'bottom':\n                    scrollCache.setScrollTop(scrollCache.getScrollTop() + velocity * sign);\n                    break;\n            }\n        }\n        // left/top are relative to document topleft\n        computeBestEdge(left, top) {\n            let { edgeThreshold } = this;\n            let bestSide = null;\n            let scrollCaches = this.scrollCaches || [];\n            for (let scrollCache of scrollCaches){\n                let rect = scrollCache.clientRect;\n                let leftDist = left - rect.left;\n                let rightDist = rect.right - left;\n                let topDist = top - rect.top;\n                let bottomDist = rect.bottom - top;\n                // completely within the rect?\n                if (leftDist >= 0 && rightDist >= 0 && topDist >= 0 && bottomDist >= 0) {\n                    if (topDist <= edgeThreshold && this.everMovedUp && scrollCache.canScrollUp() && (!bestSide || bestSide.distance > topDist)) {\n                        bestSide = {\n                            scrollCache,\n                            name: 'top',\n                            distance: topDist\n                        };\n                    }\n                    if (bottomDist <= edgeThreshold && this.everMovedDown && scrollCache.canScrollDown() && (!bestSide || bestSide.distance > bottomDist)) {\n                        bestSide = {\n                            scrollCache,\n                            name: 'bottom',\n                            distance: bottomDist\n                        };\n                    }\n                    if (leftDist <= edgeThreshold && this.everMovedLeft && scrollCache.canScrollLeft() && (!bestSide || bestSide.distance > leftDist)) {\n                        bestSide = {\n                            scrollCache,\n                            name: 'left',\n                            distance: leftDist\n                        };\n                    }\n                    if (rightDist <= edgeThreshold && this.everMovedRight && scrollCache.canScrollRight() && (!bestSide || bestSide.distance > rightDist)) {\n                        bestSide = {\n                            scrollCache,\n                            name: 'right',\n                            distance: rightDist\n                        };\n                    }\n                }\n            }\n            return bestSide;\n        }\n        buildCaches(scrollStartEl) {\n            return this.queryScrollEls(scrollStartEl).map((el)=>{\n                if (el === window) {\n                    return new WindowScrollGeomCache(false); // false = don't listen to user-generated scrolls\n                }\n                return new ElementScrollGeomCache(el, false); // false = don't listen to user-generated scrolls\n            });\n        }\n        queryScrollEls(scrollStartEl) {\n            let els = [];\n            for (let query of this.scrollQuery){\n                if (typeof query === 'object') {\n                    els.push(query);\n                } else {\n                    els.push(...Array.prototype.slice.call(scrollStartEl.getRootNode().querySelectorAll(query)));\n                }\n            }\n            return els;\n        }\n    }\n    /*\r\n    Monitors dragging on an element. Has a number of high-level features:\r\n    - minimum distance required before dragging\r\n    - minimum wait time (\"delay\") before dragging\r\n    - a mirror element that follows the pointer\r\n    */ class FeaturefulElementDragging extends ElementDragging {\n        constructor(containerEl, selector){\n            super(containerEl);\n            this.containerEl = containerEl;\n            // options that can be directly set by caller\n            // the caller can also set the PointerDragging's options as well\n            this.delay = null;\n            this.minDistance = 0;\n            this.touchScrollAllowed = true; // prevents drag from starting and blocks scrolling during drag\n            this.mirrorNeedsRevert = false;\n            this.isInteracting = false; // is the user validly moving the pointer? lasts until pointerup\n            this.isDragging = false; // is it INTENTFULLY dragging? lasts until after revert animation\n            this.isDelayEnded = false;\n            this.isDistanceSurpassed = false;\n            this.delayTimeoutId = null;\n            this.onPointerDown = (ev)=>{\n                if (!this.isDragging) {\n                    this.isInteracting = true;\n                    this.isDelayEnded = false;\n                    this.isDistanceSurpassed = false;\n                    preventSelection(document.body);\n                    preventContextMenu(document.body);\n                    // prevent links from being visited if there's an eventual drag.\n                    // also prevents selection in older browsers (maybe?).\n                    // not necessary for touch, besides, browser would complain about passiveness.\n                    if (!ev.isTouch) {\n                        ev.origEvent.preventDefault();\n                    }\n                    this.emitter.trigger('pointerdown', ev);\n                    if (this.isInteracting && // not destroyed via pointerdown handler\n                    !this.pointer.shouldIgnoreMove) {\n                        // actions related to initiating dragstart+dragmove+dragend...\n                        this.mirror.setIsVisible(false); // reset. caller must set-visible\n                        this.mirror.start(ev.subjectEl, ev.pageX, ev.pageY); // must happen on first pointer down\n                        this.startDelay(ev);\n                        if (!this.minDistance) {\n                            this.handleDistanceSurpassed(ev);\n                        }\n                    }\n                }\n            };\n            this.onPointerMove = (ev)=>{\n                if (this.isInteracting) {\n                    this.emitter.trigger('pointermove', ev);\n                    if (!this.isDistanceSurpassed) {\n                        let minDistance = this.minDistance;\n                        let distanceSq; // current distance from the origin, squared\n                        let { deltaX, deltaY } = ev;\n                        distanceSq = deltaX * deltaX + deltaY * deltaY;\n                        if (distanceSq >= minDistance * minDistance) {\n                            this.handleDistanceSurpassed(ev);\n                        }\n                    }\n                    if (this.isDragging) {\n                        // a real pointer move? (not one simulated by scrolling)\n                        if (ev.origEvent.type !== 'scroll') {\n                            this.mirror.handleMove(ev.pageX, ev.pageY);\n                            this.autoScroller.handleMove(ev.pageX, ev.pageY);\n                        }\n                        this.emitter.trigger('dragmove', ev);\n                    }\n                }\n            };\n            this.onPointerUp = (ev)=>{\n                if (this.isInteracting) {\n                    this.isInteracting = false;\n                    allowSelection(document.body);\n                    allowContextMenu(document.body);\n                    this.emitter.trigger('pointerup', ev); // can potentially set mirrorNeedsRevert\n                    if (this.isDragging) {\n                        this.autoScroller.stop();\n                        this.tryStopDrag(ev); // which will stop the mirror\n                    }\n                    if (this.delayTimeoutId) {\n                        clearTimeout(this.delayTimeoutId);\n                        this.delayTimeoutId = null;\n                    }\n                }\n            };\n            let pointer = this.pointer = new PointerDragging(containerEl);\n            pointer.emitter.on('pointerdown', this.onPointerDown);\n            pointer.emitter.on('pointermove', this.onPointerMove);\n            pointer.emitter.on('pointerup', this.onPointerUp);\n            if (selector) {\n                pointer.selector = selector;\n            }\n            this.mirror = new ElementMirror();\n            this.autoScroller = new AutoScroller();\n        }\n        destroy() {\n            this.pointer.destroy();\n            // HACK: simulate a pointer-up to end the current drag\n            // TODO: fire 'dragend' directly and stop interaction. discourage use of pointerup event (b/c might not fire)\n            this.onPointerUp({});\n        }\n        startDelay(ev) {\n            if (typeof this.delay === 'number') {\n                this.delayTimeoutId = setTimeout(()=>{\n                    this.delayTimeoutId = null;\n                    this.handleDelayEnd(ev);\n                }, this.delay); // not assignable to number!\n            } else {\n                this.handleDelayEnd(ev);\n            }\n        }\n        handleDelayEnd(ev) {\n            this.isDelayEnded = true;\n            this.tryStartDrag(ev);\n        }\n        handleDistanceSurpassed(ev) {\n            this.isDistanceSurpassed = true;\n            this.tryStartDrag(ev);\n        }\n        tryStartDrag(ev) {\n            if (this.isDelayEnded && this.isDistanceSurpassed) {\n                if (!this.pointer.wasTouchScroll || this.touchScrollAllowed) {\n                    this.isDragging = true;\n                    this.mirrorNeedsRevert = false;\n                    this.autoScroller.start(ev.pageX, ev.pageY, this.containerEl);\n                    this.emitter.trigger('dragstart', ev);\n                    if (this.touchScrollAllowed === false) {\n                        this.pointer.cancelTouchScroll();\n                    }\n                }\n            }\n        }\n        tryStopDrag(ev) {\n            // .stop() is ALWAYS asynchronous, which we NEED because we want all pointerup events\n            // that come from the document to fire beforehand. much more convenient this way.\n            this.mirror.stop(this.mirrorNeedsRevert, this.stopDrag.bind(this, ev));\n        }\n        stopDrag(ev) {\n            this.isDragging = false;\n            this.emitter.trigger('dragend', ev);\n        }\n        // fill in the implementations...\n        setIgnoreMove(bool) {\n            this.pointer.shouldIgnoreMove = bool;\n        }\n        setMirrorIsVisible(bool) {\n            this.mirror.setIsVisible(bool);\n        }\n        setMirrorNeedsRevert(bool) {\n            this.mirrorNeedsRevert = bool;\n        }\n        setAutoScrollEnabled(bool) {\n            this.autoScroller.isEnabled = bool;\n        }\n    }\n    /*\r\n    When this class is instantiated, it records the offset of an element (relative to the document topleft),\r\n    and continues to monitor scrolling, updating the cached coordinates if it needs to.\r\n    Does not access the DOM after instantiation, so highly performant.\r\n\r\n    Also keeps track of all scrolling/overflow:hidden containers that are parents of the given element\r\n    and an determine if a given point is inside the combined clipping rectangle.\r\n    */ class OffsetTracker {\n        constructor(el){\n            this.origRect = computeRect(el);\n            // will work fine for divs that have overflow:hidden\n            this.scrollCaches = getClippingParents(el).map((scrollEl)=>new ElementScrollGeomCache(scrollEl, true));\n        }\n        destroy() {\n            for (let scrollCache of this.scrollCaches){\n                scrollCache.destroy();\n            }\n        }\n        computeLeft() {\n            let left = this.origRect.left;\n            for (let scrollCache of this.scrollCaches){\n                left += scrollCache.origScrollLeft - scrollCache.getScrollLeft();\n            }\n            return left;\n        }\n        computeTop() {\n            let top = this.origRect.top;\n            for (let scrollCache of this.scrollCaches){\n                top += scrollCache.origScrollTop - scrollCache.getScrollTop();\n            }\n            return top;\n        }\n        isWithinClipping(pageX, pageY) {\n            let point = {\n                left: pageX,\n                top: pageY\n            };\n            for (let scrollCache of this.scrollCaches){\n                if (!isIgnoredClipping(scrollCache.getEventTarget()) && !pointInsideRect(point, scrollCache.clientRect)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n    // certain clipping containers should never constrain interactions, like <html> and <body>\n    // https://github.com/fullcalendar/fullcalendar/issues/3615\n    function isIgnoredClipping(node) {\n        let tagName = node.tagName;\n        return tagName === 'HTML' || tagName === 'BODY';\n    }\n    /*\r\n    Tracks movement over multiple droppable areas (aka \"hits\")\r\n    that exist in one or more DateComponents.\r\n    Relies on an existing draggable.\r\n\r\n    emits:\r\n    - pointerdown\r\n    - dragstart\r\n    - hitchange - fires initially, even if not over a hit\r\n    - pointerup\r\n    - (hitchange - again, to null, if ended over a hit)\r\n    - dragend\r\n    */ class HitDragging {\n        constructor(dragging, droppableStore){\n            // options that can be set by caller\n            this.useSubjectCenter = false;\n            this.requireInitial = true; // if doesn't start out on a hit, won't emit any events\n            this.initialHit = null;\n            this.movingHit = null;\n            this.finalHit = null; // won't ever be populated if shouldIgnoreMove\n            this.handlePointerDown = (ev)=>{\n                let { dragging } = this;\n                this.initialHit = null;\n                this.movingHit = null;\n                this.finalHit = null;\n                this.prepareHits();\n                this.processFirstCoord(ev);\n                if (this.initialHit || !this.requireInitial) {\n                    dragging.setIgnoreMove(false);\n                    // TODO: fire this before computing processFirstCoord, so listeners can cancel. this gets fired by almost every handler :(\n                    this.emitter.trigger('pointerdown', ev);\n                } else {\n                    dragging.setIgnoreMove(true);\n                }\n            };\n            this.handleDragStart = (ev)=>{\n                this.emitter.trigger('dragstart', ev);\n                this.handleMove(ev, true); // force = fire even if initially null\n            };\n            this.handleDragMove = (ev)=>{\n                this.emitter.trigger('dragmove', ev);\n                this.handleMove(ev);\n            };\n            this.handlePointerUp = (ev)=>{\n                this.releaseHits();\n                this.emitter.trigger('pointerup', ev);\n            };\n            this.handleDragEnd = (ev)=>{\n                if (this.movingHit) {\n                    this.emitter.trigger('hitupdate', null, true, ev);\n                }\n                this.finalHit = this.movingHit;\n                this.movingHit = null;\n                this.emitter.trigger('dragend', ev);\n            };\n            this.droppableStore = droppableStore;\n            dragging.emitter.on('pointerdown', this.handlePointerDown);\n            dragging.emitter.on('dragstart', this.handleDragStart);\n            dragging.emitter.on('dragmove', this.handleDragMove);\n            dragging.emitter.on('pointerup', this.handlePointerUp);\n            dragging.emitter.on('dragend', this.handleDragEnd);\n            this.dragging = dragging;\n            this.emitter = new Emitter();\n        }\n        // sets initialHit\n        // sets coordAdjust\n        processFirstCoord(ev) {\n            let origPoint = {\n                left: ev.pageX,\n                top: ev.pageY\n            };\n            let adjustedPoint = origPoint;\n            let subjectEl = ev.subjectEl;\n            let subjectRect;\n            if (subjectEl instanceof HTMLElement) {\n                subjectRect = computeRect(subjectEl);\n                adjustedPoint = constrainPoint(adjustedPoint, subjectRect);\n            }\n            let initialHit = this.initialHit = this.queryHitForOffset(adjustedPoint.left, adjustedPoint.top);\n            if (initialHit) {\n                if (this.useSubjectCenter && subjectRect) {\n                    let slicedSubjectRect = intersectRects(subjectRect, initialHit.rect);\n                    if (slicedSubjectRect) {\n                        adjustedPoint = getRectCenter(slicedSubjectRect);\n                    }\n                }\n                this.coordAdjust = diffPoints(adjustedPoint, origPoint);\n            } else {\n                this.coordAdjust = {\n                    left: 0,\n                    top: 0\n                };\n            }\n        }\n        handleMove(ev, forceHandle) {\n            let hit = this.queryHitForOffset(ev.pageX + this.coordAdjust.left, ev.pageY + this.coordAdjust.top);\n            if (forceHandle || !isHitsEqual(this.movingHit, hit)) {\n                this.movingHit = hit;\n                this.emitter.trigger('hitupdate', hit, false, ev);\n            }\n        }\n        prepareHits() {\n            this.offsetTrackers = mapHash(this.droppableStore, (interactionSettings)=>{\n                interactionSettings.component.prepareHits();\n                return new OffsetTracker(interactionSettings.el);\n            });\n        }\n        releaseHits() {\n            let { offsetTrackers } = this;\n            for(let id in offsetTrackers){\n                offsetTrackers[id].destroy();\n            }\n            this.offsetTrackers = {};\n        }\n        queryHitForOffset(offsetLeft, offsetTop) {\n            let { droppableStore, offsetTrackers } = this;\n            let bestHit = null;\n            for(let id in droppableStore){\n                let component = droppableStore[id].component;\n                let offsetTracker = offsetTrackers[id];\n                if (offsetTracker && // wasn't destroyed mid-drag\n                offsetTracker.isWithinClipping(offsetLeft, offsetTop)) {\n                    let originLeft = offsetTracker.computeLeft();\n                    let originTop = offsetTracker.computeTop();\n                    let positionLeft = offsetLeft - originLeft;\n                    let positionTop = offsetTop - originTop;\n                    let { origRect } = offsetTracker;\n                    let width = origRect.right - origRect.left;\n                    let height = origRect.bottom - origRect.top;\n                    if (// must be within the element's bounds\n                    positionLeft >= 0 && positionLeft < width && positionTop >= 0 && positionTop < height) {\n                        let hit = component.queryHit(positionLeft, positionTop, width, height);\n                        if (hit && // make sure the hit is within activeRange, meaning it's not a dead cell\n                        rangeContainsRange(hit.dateProfile.activeRange, hit.dateSpan.range) && (!bestHit || hit.layer > bestHit.layer)) {\n                            hit.componentId = id;\n                            hit.context = component.context;\n                            // TODO: better way to re-orient rectangle\n                            hit.rect.left += originLeft;\n                            hit.rect.right += originLeft;\n                            hit.rect.top += originTop;\n                            hit.rect.bottom += originTop;\n                            bestHit = hit;\n                        }\n                    }\n                }\n            }\n            return bestHit;\n        }\n    }\n    function isHitsEqual(hit0, hit1) {\n        if (!hit0 && !hit1) {\n            return true;\n        }\n        if (Boolean(hit0) !== Boolean(hit1)) {\n            return false;\n        }\n        return isDateSpansEqual(hit0.dateSpan, hit1.dateSpan);\n    }\n    function buildDatePointApiWithContext(dateSpan, context) {\n        let props = {};\n        for (let transform of context.pluginHooks.datePointTransforms){\n            Object.assign(props, transform(dateSpan, context));\n        }\n        Object.assign(props, buildDatePointApi(dateSpan, context.dateEnv));\n        return props;\n    }\n    function buildDatePointApi(span, dateEnv) {\n        return {\n            date: dateEnv.toDate(span.range.start),\n            dateStr: dateEnv.formatIso(span.range.start, {\n                omitTime: span.allDay\n            }),\n            allDay: span.allDay\n        };\n    }\n    /*\r\n    Monitors when the user clicks on a specific date/time of a component.\r\n    A pointerdown+pointerup on the same \"hit\" constitutes a click.\r\n    */ class DateClicking extends Interaction {\n        constructor(settings){\n            super(settings);\n            this.handlePointerDown = (pev)=>{\n                let { dragging } = this;\n                let downEl = pev.origEvent.target;\n                // do this in pointerdown (not dragend) because DOM might be mutated by the time dragend is fired\n                dragging.setIgnoreMove(!this.component.isValidDateDownEl(downEl));\n            };\n            // won't even fire if moving was ignored\n            this.handleDragEnd = (ev)=>{\n                let { component } = this;\n                let { pointer } = this.dragging;\n                if (!pointer.wasTouchScroll) {\n                    let { initialHit, finalHit } = this.hitDragging;\n                    if (initialHit && finalHit && isHitsEqual(initialHit, finalHit)) {\n                        let { context } = component;\n                        let arg = Object.assign(Object.assign({}, buildDatePointApiWithContext(initialHit.dateSpan, context)), {\n                            dayEl: initialHit.dayEl,\n                            jsEvent: ev.origEvent,\n                            view: context.viewApi || context.calendarApi.view\n                        });\n                        context.emitter.trigger('dateClick', arg);\n                    }\n                }\n            };\n            // we DO want to watch pointer moves because otherwise finalHit won't get populated\n            this.dragging = new FeaturefulElementDragging(settings.el);\n            this.dragging.autoScroller.isEnabled = false;\n            let hitDragging = this.hitDragging = new HitDragging(this.dragging, interactionSettingsToStore(settings));\n            hitDragging.emitter.on('pointerdown', this.handlePointerDown);\n            hitDragging.emitter.on('dragend', this.handleDragEnd);\n        }\n        destroy() {\n            this.dragging.destroy();\n        }\n    }\n    /*\r\n    Tracks when the user selects a portion of time of a component,\r\n    constituted by a drag over date cells, with a possible delay at the beginning of the drag.\r\n    */ class DateSelecting extends Interaction {\n        constructor(settings){\n            super(settings);\n            this.dragSelection = null;\n            this.handlePointerDown = (ev)=>{\n                let { component, dragging } = this;\n                let { options } = component.context;\n                let canSelect = options.selectable && component.isValidDateDownEl(ev.origEvent.target);\n                // don't bother to watch expensive moves if component won't do selection\n                dragging.setIgnoreMove(!canSelect);\n                // if touch, require user to hold down\n                dragging.delay = ev.isTouch ? getComponentTouchDelay$1(component) : null;\n            };\n            this.handleDragStart = (ev)=>{\n                this.component.context.calendarApi.unselect(ev); // unselect previous selections\n            };\n            this.handleHitUpdate = (hit, isFinal)=>{\n                let { context } = this.component;\n                let dragSelection = null;\n                let isInvalid = false;\n                if (hit) {\n                    let initialHit = this.hitDragging.initialHit;\n                    let disallowed = hit.componentId === initialHit.componentId && this.isHitComboAllowed && !this.isHitComboAllowed(initialHit, hit);\n                    if (!disallowed) {\n                        dragSelection = joinHitsIntoSelection(initialHit, hit, context.pluginHooks.dateSelectionTransformers);\n                    }\n                    if (!dragSelection || !isDateSelectionValid(dragSelection, hit.dateProfile, context)) {\n                        isInvalid = true;\n                        dragSelection = null;\n                    }\n                }\n                if (dragSelection) {\n                    context.dispatch({\n                        type: 'SELECT_DATES',\n                        selection: dragSelection\n                    });\n                } else if (!isFinal) {\n                    context.dispatch({\n                        type: 'UNSELECT_DATES'\n                    });\n                }\n                if (!isInvalid) {\n                    enableCursor();\n                } else {\n                    disableCursor();\n                }\n                if (!isFinal) {\n                    this.dragSelection = dragSelection; // only clear if moved away from all hits while dragging\n                }\n            };\n            this.handlePointerUp = (pev)=>{\n                if (this.dragSelection) {\n                    // selection is already rendered, so just need to report selection\n                    triggerDateSelect(this.dragSelection, pev, this.component.context);\n                    this.dragSelection = null;\n                }\n            };\n            let { component } = settings;\n            let { options } = component.context;\n            let dragging = this.dragging = new FeaturefulElementDragging(settings.el);\n            dragging.touchScrollAllowed = false;\n            dragging.minDistance = options.selectMinDistance || 0;\n            dragging.autoScroller.isEnabled = options.dragScroll;\n            let hitDragging = this.hitDragging = new HitDragging(this.dragging, interactionSettingsToStore(settings));\n            hitDragging.emitter.on('pointerdown', this.handlePointerDown);\n            hitDragging.emitter.on('dragstart', this.handleDragStart);\n            hitDragging.emitter.on('hitupdate', this.handleHitUpdate);\n            hitDragging.emitter.on('pointerup', this.handlePointerUp);\n        }\n        destroy() {\n            this.dragging.destroy();\n        }\n    }\n    function getComponentTouchDelay$1(component) {\n        let { options } = component.context;\n        let delay = options.selectLongPressDelay;\n        if (delay == null) {\n            delay = options.longPressDelay;\n        }\n        return delay;\n    }\n    function joinHitsIntoSelection(hit0, hit1, dateSelectionTransformers) {\n        let dateSpan0 = hit0.dateSpan;\n        let dateSpan1 = hit1.dateSpan;\n        let ms = [\n            dateSpan0.range.start,\n            dateSpan0.range.end,\n            dateSpan1.range.start,\n            dateSpan1.range.end\n        ];\n        ms.sort(compareNumbers);\n        let props = {};\n        for (let transformer of dateSelectionTransformers){\n            let res = transformer(hit0, hit1);\n            if (res === false) {\n                return null;\n            }\n            if (res) {\n                Object.assign(props, res);\n            }\n        }\n        props.range = {\n            start: ms[0],\n            end: ms[3]\n        };\n        props.allDay = dateSpan0.allDay;\n        return props;\n    }\n    class EventDragging extends Interaction {\n        constructor(settings){\n            super(settings);\n            // internal state\n            this.subjectEl = null;\n            this.subjectSeg = null; // the seg being selected/dragged\n            this.isDragging = false;\n            this.eventRange = null;\n            this.relevantEvents = null; // the events being dragged\n            this.receivingContext = null;\n            this.validMutation = null;\n            this.mutatedRelevantEvents = null;\n            this.handlePointerDown = (ev)=>{\n                let origTarget = ev.origEvent.target;\n                let { component, dragging } = this;\n                let { mirror } = dragging;\n                let { options } = component.context;\n                let initialContext = component.context;\n                this.subjectEl = ev.subjectEl;\n                let subjectSeg = this.subjectSeg = getElSeg(ev.subjectEl);\n                let eventRange = this.eventRange = subjectSeg.eventRange;\n                let eventInstanceId = eventRange.instance.instanceId;\n                this.relevantEvents = getRelevantEvents(initialContext.getCurrentData().eventStore, eventInstanceId);\n                dragging.minDistance = ev.isTouch ? 0 : options.eventDragMinDistance;\n                dragging.delay = // only do a touch delay if touch and this event hasn't been selected yet\n                ev.isTouch && eventInstanceId !== component.props.eventSelection ? getComponentTouchDelay(component) : null;\n                if (options.fixedMirrorParent) {\n                    mirror.parentNode = options.fixedMirrorParent;\n                } else {\n                    mirror.parentNode = elementClosest(origTarget, '.fc');\n                }\n                mirror.revertDuration = options.dragRevertDuration;\n                let isValid = component.isValidSegDownEl(origTarget) && !elementClosest(origTarget, '.fc-event-resizer'); // NOT on a resizer\n                dragging.setIgnoreMove(!isValid);\n                // disable dragging for elements that are resizable (ie, selectable)\n                // but are not draggable\n                this.isDragging = isValid && ev.subjectEl.classList.contains('fc-event-draggable');\n            };\n            this.handleDragStart = (ev)=>{\n                let initialContext = this.component.context;\n                let eventRange = this.eventRange;\n                let eventInstanceId = eventRange.instance.instanceId;\n                if (ev.isTouch) {\n                    // need to select a different event?\n                    if (eventInstanceId !== this.component.props.eventSelection) {\n                        initialContext.dispatch({\n                            type: 'SELECT_EVENT',\n                            eventInstanceId\n                        });\n                    }\n                } else {\n                    // if now using mouse, but was previous touch interaction, clear selected event\n                    initialContext.dispatch({\n                        type: 'UNSELECT_EVENT'\n                    });\n                }\n                if (this.isDragging) {\n                    initialContext.calendarApi.unselect(ev); // unselect *date* selection\n                    initialContext.emitter.trigger('eventDragStart', {\n                        el: this.subjectEl,\n                        event: new EventImpl(initialContext, eventRange.def, eventRange.instance),\n                        jsEvent: ev.origEvent,\n                        view: initialContext.viewApi\n                    });\n                }\n            };\n            this.handleHitUpdate = (hit, isFinal)=>{\n                if (!this.isDragging) {\n                    return;\n                }\n                let relevantEvents = this.relevantEvents;\n                let initialHit = this.hitDragging.initialHit;\n                let initialContext = this.component.context;\n                // states based on new hit\n                let receivingContext = null;\n                let mutation = null;\n                let mutatedRelevantEvents = null;\n                let isInvalid = false;\n                let interaction = {\n                    affectedEvents: relevantEvents,\n                    mutatedEvents: createEmptyEventStore(),\n                    isEvent: true\n                };\n                if (hit) {\n                    receivingContext = hit.context;\n                    let receivingOptions = receivingContext.options;\n                    if (initialContext === receivingContext || receivingOptions.editable && receivingOptions.droppable) {\n                        mutation = computeEventMutation(initialHit, hit, receivingContext.getCurrentData().pluginHooks.eventDragMutationMassagers);\n                        if (mutation) {\n                            mutatedRelevantEvents = applyMutationToEventStore(relevantEvents, receivingContext.getCurrentData().eventUiBases, mutation, receivingContext);\n                            interaction.mutatedEvents = mutatedRelevantEvents;\n                            if (!isInteractionValid(interaction, hit.dateProfile, receivingContext)) {\n                                isInvalid = true;\n                                mutation = null;\n                                mutatedRelevantEvents = null;\n                                interaction.mutatedEvents = createEmptyEventStore();\n                            }\n                        }\n                    } else {\n                        receivingContext = null;\n                    }\n                }\n                this.displayDrag(receivingContext, interaction);\n                if (!isInvalid) {\n                    enableCursor();\n                } else {\n                    disableCursor();\n                }\n                if (!isFinal) {\n                    if (initialContext === receivingContext && // TODO: write test for this\n                    isHitsEqual(initialHit, hit)) {\n                        mutation = null;\n                    }\n                    this.dragging.setMirrorNeedsRevert(!mutation);\n                    // render the mirror if no already-rendered mirror\n                    // TODO: wish we could somehow wait for dispatch to guarantee render\n                    this.dragging.setMirrorIsVisible(!hit || !this.subjectEl.getRootNode().querySelector('.fc-event-mirror'));\n                    // assign states based on new hit\n                    this.receivingContext = receivingContext;\n                    this.validMutation = mutation;\n                    this.mutatedRelevantEvents = mutatedRelevantEvents;\n                }\n            };\n            this.handlePointerUp = ()=>{\n                if (!this.isDragging) {\n                    this.cleanup(); // because handleDragEnd won't fire\n                }\n            };\n            this.handleDragEnd = (ev)=>{\n                if (this.isDragging) {\n                    let initialContext = this.component.context;\n                    let initialView = initialContext.viewApi;\n                    let { receivingContext, validMutation } = this;\n                    let eventDef = this.eventRange.def;\n                    let eventInstance = this.eventRange.instance;\n                    let eventApi = new EventImpl(initialContext, eventDef, eventInstance);\n                    let relevantEvents = this.relevantEvents;\n                    let mutatedRelevantEvents = this.mutatedRelevantEvents;\n                    let { finalHit } = this.hitDragging;\n                    this.clearDrag(); // must happen after revert animation\n                    initialContext.emitter.trigger('eventDragStop', {\n                        el: this.subjectEl,\n                        event: eventApi,\n                        jsEvent: ev.origEvent,\n                        view: initialView\n                    });\n                    if (validMutation) {\n                        // dropped within same calendar\n                        if (receivingContext === initialContext) {\n                            let updatedEventApi = new EventImpl(initialContext, mutatedRelevantEvents.defs[eventDef.defId], eventInstance ? mutatedRelevantEvents.instances[eventInstance.instanceId] : null);\n                            initialContext.dispatch({\n                                type: 'MERGE_EVENTS',\n                                eventStore: mutatedRelevantEvents\n                            });\n                            let eventChangeArg = {\n                                oldEvent: eventApi,\n                                event: updatedEventApi,\n                                relatedEvents: buildEventApis(mutatedRelevantEvents, initialContext, eventInstance),\n                                revert () {\n                                    initialContext.dispatch({\n                                        type: 'MERGE_EVENTS',\n                                        eventStore: relevantEvents\n                                    });\n                                }\n                            };\n                            let transformed = {};\n                            for (let transformer of initialContext.getCurrentData().pluginHooks.eventDropTransformers){\n                                Object.assign(transformed, transformer(validMutation, initialContext));\n                            }\n                            initialContext.emitter.trigger('eventDrop', Object.assign(Object.assign(Object.assign({}, eventChangeArg), transformed), {\n                                el: ev.subjectEl,\n                                delta: validMutation.datesDelta,\n                                jsEvent: ev.origEvent,\n                                view: initialView\n                            }));\n                            initialContext.emitter.trigger('eventChange', eventChangeArg);\n                        // dropped in different calendar\n                        } else if (receivingContext) {\n                            let eventRemoveArg = {\n                                event: eventApi,\n                                relatedEvents: buildEventApis(relevantEvents, initialContext, eventInstance),\n                                revert () {\n                                    initialContext.dispatch({\n                                        type: 'MERGE_EVENTS',\n                                        eventStore: relevantEvents\n                                    });\n                                }\n                            };\n                            initialContext.emitter.trigger('eventLeave', Object.assign(Object.assign({}, eventRemoveArg), {\n                                draggedEl: ev.subjectEl,\n                                view: initialView\n                            }));\n                            initialContext.dispatch({\n                                type: 'REMOVE_EVENTS',\n                                eventStore: relevantEvents\n                            });\n                            initialContext.emitter.trigger('eventRemove', eventRemoveArg);\n                            let addedEventDef = mutatedRelevantEvents.defs[eventDef.defId];\n                            let addedEventInstance = mutatedRelevantEvents.instances[eventInstance.instanceId];\n                            let addedEventApi = new EventImpl(receivingContext, addedEventDef, addedEventInstance);\n                            receivingContext.dispatch({\n                                type: 'MERGE_EVENTS',\n                                eventStore: mutatedRelevantEvents\n                            });\n                            let eventAddArg = {\n                                event: addedEventApi,\n                                relatedEvents: buildEventApis(mutatedRelevantEvents, receivingContext, addedEventInstance),\n                                revert () {\n                                    receivingContext.dispatch({\n                                        type: 'REMOVE_EVENTS',\n                                        eventStore: mutatedRelevantEvents\n                                    });\n                                }\n                            };\n                            receivingContext.emitter.trigger('eventAdd', eventAddArg);\n                            if (ev.isTouch) {\n                                receivingContext.dispatch({\n                                    type: 'SELECT_EVENT',\n                                    eventInstanceId: eventInstance.instanceId\n                                });\n                            }\n                            receivingContext.emitter.trigger('drop', Object.assign(Object.assign({}, buildDatePointApiWithContext(finalHit.dateSpan, receivingContext)), {\n                                draggedEl: ev.subjectEl,\n                                jsEvent: ev.origEvent,\n                                view: finalHit.context.viewApi\n                            }));\n                            receivingContext.emitter.trigger('eventReceive', Object.assign(Object.assign({}, eventAddArg), {\n                                draggedEl: ev.subjectEl,\n                                view: finalHit.context.viewApi\n                            }));\n                        }\n                    } else {\n                        initialContext.emitter.trigger('_noEventDrop');\n                    }\n                }\n                this.cleanup();\n            };\n            let { component } = this;\n            let { options } = component.context;\n            let dragging = this.dragging = new FeaturefulElementDragging(settings.el);\n            dragging.pointer.selector = EventDragging.SELECTOR;\n            dragging.touchScrollAllowed = false;\n            dragging.autoScroller.isEnabled = options.dragScroll;\n            let hitDragging = this.hitDragging = new HitDragging(this.dragging, interactionSettingsStore);\n            hitDragging.useSubjectCenter = settings.useEventCenter;\n            hitDragging.emitter.on('pointerdown', this.handlePointerDown);\n            hitDragging.emitter.on('dragstart', this.handleDragStart);\n            hitDragging.emitter.on('hitupdate', this.handleHitUpdate);\n            hitDragging.emitter.on('pointerup', this.handlePointerUp);\n            hitDragging.emitter.on('dragend', this.handleDragEnd);\n        }\n        destroy() {\n            this.dragging.destroy();\n        }\n        // render a drag state on the next receivingCalendar\n        displayDrag(nextContext, state) {\n            let initialContext = this.component.context;\n            let prevContext = this.receivingContext;\n            // does the previous calendar need to be cleared?\n            if (prevContext && prevContext !== nextContext) {\n                // does the initial calendar need to be cleared?\n                // if so, don't clear all the way. we still need to to hide the affectedEvents\n                if (prevContext === initialContext) {\n                    prevContext.dispatch({\n                        type: 'SET_EVENT_DRAG',\n                        state: {\n                            affectedEvents: state.affectedEvents,\n                            mutatedEvents: createEmptyEventStore(),\n                            isEvent: true\n                        }\n                    });\n                // completely clear the old calendar if it wasn't the initial\n                } else {\n                    prevContext.dispatch({\n                        type: 'UNSET_EVENT_DRAG'\n                    });\n                }\n            }\n            if (nextContext) {\n                nextContext.dispatch({\n                    type: 'SET_EVENT_DRAG',\n                    state\n                });\n            }\n        }\n        clearDrag() {\n            let initialCalendar = this.component.context;\n            let { receivingContext } = this;\n            if (receivingContext) {\n                receivingContext.dispatch({\n                    type: 'UNSET_EVENT_DRAG'\n                });\n            }\n            // the initial calendar might have an dummy drag state from displayDrag\n            if (initialCalendar !== receivingContext) {\n                initialCalendar.dispatch({\n                    type: 'UNSET_EVENT_DRAG'\n                });\n            }\n        }\n        cleanup() {\n            this.subjectSeg = null;\n            this.isDragging = false;\n            this.eventRange = null;\n            this.relevantEvents = null;\n            this.receivingContext = null;\n            this.validMutation = null;\n            this.mutatedRelevantEvents = null;\n        }\n    }\n    // TODO: test this in IE11\n    // QUESTION: why do we need it on the resizable???\n    EventDragging.SELECTOR = '.fc-event-draggable, .fc-event-resizable';\n    function computeEventMutation(hit0, hit1, massagers) {\n        let dateSpan0 = hit0.dateSpan;\n        let dateSpan1 = hit1.dateSpan;\n        let date0 = dateSpan0.range.start;\n        let date1 = dateSpan1.range.start;\n        let standardProps = {};\n        if (dateSpan0.allDay !== dateSpan1.allDay) {\n            standardProps.allDay = dateSpan1.allDay;\n            standardProps.hasEnd = hit1.context.options.allDayMaintainDuration;\n            if (dateSpan1.allDay) {\n                // means date1 is already start-of-day,\n                // but date0 needs to be converted\n                date0 = startOfDay(date0);\n            }\n        }\n        let delta = diffDates(date0, date1, hit0.context.dateEnv, hit0.componentId === hit1.componentId ? hit0.largeUnit : null);\n        if (delta.milliseconds) {\n            standardProps.allDay = false;\n        }\n        let mutation = {\n            datesDelta: delta,\n            standardProps\n        };\n        for (let massager of massagers){\n            massager(mutation, hit0, hit1);\n        }\n        return mutation;\n    }\n    function getComponentTouchDelay(component) {\n        let { options } = component.context;\n        let delay = options.eventLongPressDelay;\n        if (delay == null) {\n            delay = options.longPressDelay;\n        }\n        return delay;\n    }\n    class EventResizing extends Interaction {\n        constructor(settings){\n            super(settings);\n            // internal state\n            this.draggingSegEl = null;\n            this.draggingSeg = null; // TODO: rename to resizingSeg? subjectSeg?\n            this.eventRange = null;\n            this.relevantEvents = null;\n            this.validMutation = null;\n            this.mutatedRelevantEvents = null;\n            this.handlePointerDown = (ev)=>{\n                let { component } = this;\n                let segEl = this.querySegEl(ev);\n                let seg = getElSeg(segEl);\n                let eventRange = this.eventRange = seg.eventRange;\n                this.dragging.minDistance = component.context.options.eventDragMinDistance;\n                // if touch, need to be working with a selected event\n                this.dragging.setIgnoreMove(!this.component.isValidSegDownEl(ev.origEvent.target) || ev.isTouch && this.component.props.eventSelection !== eventRange.instance.instanceId);\n            };\n            this.handleDragStart = (ev)=>{\n                let { context } = this.component;\n                let eventRange = this.eventRange;\n                this.relevantEvents = getRelevantEvents(context.getCurrentData().eventStore, this.eventRange.instance.instanceId);\n                let segEl = this.querySegEl(ev);\n                this.draggingSegEl = segEl;\n                this.draggingSeg = getElSeg(segEl);\n                context.calendarApi.unselect();\n                context.emitter.trigger('eventResizeStart', {\n                    el: segEl,\n                    event: new EventImpl(context, eventRange.def, eventRange.instance),\n                    jsEvent: ev.origEvent,\n                    view: context.viewApi\n                });\n            };\n            this.handleHitUpdate = (hit, isFinal, ev)=>{\n                let { context } = this.component;\n                let relevantEvents = this.relevantEvents;\n                let initialHit = this.hitDragging.initialHit;\n                let eventInstance = this.eventRange.instance;\n                let mutation = null;\n                let mutatedRelevantEvents = null;\n                let isInvalid = false;\n                let interaction = {\n                    affectedEvents: relevantEvents,\n                    mutatedEvents: createEmptyEventStore(),\n                    isEvent: true\n                };\n                if (hit) {\n                    let disallowed = hit.componentId === initialHit.componentId && this.isHitComboAllowed && !this.isHitComboAllowed(initialHit, hit);\n                    if (!disallowed) {\n                        mutation = computeMutation(initialHit, hit, ev.subjectEl.classList.contains('fc-event-resizer-start'), eventInstance.range);\n                    }\n                }\n                if (mutation) {\n                    mutatedRelevantEvents = applyMutationToEventStore(relevantEvents, context.getCurrentData().eventUiBases, mutation, context);\n                    interaction.mutatedEvents = mutatedRelevantEvents;\n                    if (!isInteractionValid(interaction, hit.dateProfile, context)) {\n                        isInvalid = true;\n                        mutation = null;\n                        mutatedRelevantEvents = null;\n                        interaction.mutatedEvents = null;\n                    }\n                }\n                if (mutatedRelevantEvents) {\n                    context.dispatch({\n                        type: 'SET_EVENT_RESIZE',\n                        state: interaction\n                    });\n                } else {\n                    context.dispatch({\n                        type: 'UNSET_EVENT_RESIZE'\n                    });\n                }\n                if (!isInvalid) {\n                    enableCursor();\n                } else {\n                    disableCursor();\n                }\n                if (!isFinal) {\n                    if (mutation && isHitsEqual(initialHit, hit)) {\n                        mutation = null;\n                    }\n                    this.validMutation = mutation;\n                    this.mutatedRelevantEvents = mutatedRelevantEvents;\n                }\n            };\n            this.handleDragEnd = (ev)=>{\n                let { context } = this.component;\n                let eventDef = this.eventRange.def;\n                let eventInstance = this.eventRange.instance;\n                let eventApi = new EventImpl(context, eventDef, eventInstance);\n                let relevantEvents = this.relevantEvents;\n                let mutatedRelevantEvents = this.mutatedRelevantEvents;\n                context.emitter.trigger('eventResizeStop', {\n                    el: this.draggingSegEl,\n                    event: eventApi,\n                    jsEvent: ev.origEvent,\n                    view: context.viewApi\n                });\n                if (this.validMutation) {\n                    let updatedEventApi = new EventImpl(context, mutatedRelevantEvents.defs[eventDef.defId], eventInstance ? mutatedRelevantEvents.instances[eventInstance.instanceId] : null);\n                    context.dispatch({\n                        type: 'MERGE_EVENTS',\n                        eventStore: mutatedRelevantEvents\n                    });\n                    let eventChangeArg = {\n                        oldEvent: eventApi,\n                        event: updatedEventApi,\n                        relatedEvents: buildEventApis(mutatedRelevantEvents, context, eventInstance),\n                        revert () {\n                            context.dispatch({\n                                type: 'MERGE_EVENTS',\n                                eventStore: relevantEvents\n                            });\n                        }\n                    };\n                    context.emitter.trigger('eventResize', Object.assign(Object.assign({}, eventChangeArg), {\n                        el: this.draggingSegEl,\n                        startDelta: this.validMutation.startDelta || createDuration(0),\n                        endDelta: this.validMutation.endDelta || createDuration(0),\n                        jsEvent: ev.origEvent,\n                        view: context.viewApi\n                    }));\n                    context.emitter.trigger('eventChange', eventChangeArg);\n                } else {\n                    context.emitter.trigger('_noEventResize');\n                }\n                // reset all internal state\n                this.draggingSeg = null;\n                this.relevantEvents = null;\n                this.validMutation = null;\n            // okay to keep eventInstance around. useful to set it in handlePointerDown\n            };\n            let { component } = settings;\n            let dragging = this.dragging = new FeaturefulElementDragging(settings.el);\n            dragging.pointer.selector = '.fc-event-resizer';\n            dragging.touchScrollAllowed = false;\n            dragging.autoScroller.isEnabled = component.context.options.dragScroll;\n            let hitDragging = this.hitDragging = new HitDragging(this.dragging, interactionSettingsToStore(settings));\n            hitDragging.emitter.on('pointerdown', this.handlePointerDown);\n            hitDragging.emitter.on('dragstart', this.handleDragStart);\n            hitDragging.emitter.on('hitupdate', this.handleHitUpdate);\n            hitDragging.emitter.on('dragend', this.handleDragEnd);\n        }\n        destroy() {\n            this.dragging.destroy();\n        }\n        querySegEl(ev) {\n            return elementClosest(ev.subjectEl, '.fc-event');\n        }\n    }\n    function computeMutation(hit0, hit1, isFromStart, instanceRange) {\n        let dateEnv = hit0.context.dateEnv;\n        let date0 = hit0.dateSpan.range.start;\n        let date1 = hit1.dateSpan.range.start;\n        let delta = diffDates(date0, date1, dateEnv, hit0.largeUnit);\n        if (isFromStart) {\n            if (dateEnv.add(instanceRange.start, delta) < instanceRange.end) {\n                return {\n                    startDelta: delta\n                };\n            }\n        } else if (dateEnv.add(instanceRange.end, delta) > instanceRange.start) {\n            return {\n                endDelta: delta\n            };\n        }\n        return null;\n    }\n    class UnselectAuto {\n        constructor(context){\n            this.context = context;\n            this.isRecentPointerDateSelect = false; // wish we could use a selector to detect date selection, but uses hit system\n            this.matchesCancel = false;\n            this.matchesEvent = false;\n            this.onSelect = (selectInfo)=>{\n                if (selectInfo.jsEvent) {\n                    this.isRecentPointerDateSelect = true;\n                }\n            };\n            this.onDocumentPointerDown = (pev)=>{\n                let unselectCancel = this.context.options.unselectCancel;\n                let downEl = getEventTargetViaRoot(pev.origEvent);\n                this.matchesCancel = !!elementClosest(downEl, unselectCancel);\n                this.matchesEvent = !!elementClosest(downEl, EventDragging.SELECTOR); // interaction started on an event?\n            };\n            this.onDocumentPointerUp = (pev)=>{\n                let { context } = this;\n                let { documentPointer } = this;\n                let calendarState = context.getCurrentData();\n                // touch-scrolling should never unfocus any type of selection\n                if (!documentPointer.wasTouchScroll) {\n                    if (calendarState.dateSelection && // an existing date selection?\n                    !this.isRecentPointerDateSelect // a new pointer-initiated date selection since last onDocumentPointerUp?\n                    ) {\n                        let unselectAuto = context.options.unselectAuto;\n                        if (unselectAuto && (!unselectAuto || !this.matchesCancel)) {\n                            context.calendarApi.unselect(pev);\n                        }\n                    }\n                    if (calendarState.eventSelection && // an existing event selected?\n                    !this.matchesEvent // interaction DIDN'T start on an event\n                    ) {\n                        context.dispatch({\n                            type: 'UNSELECT_EVENT'\n                        });\n                    }\n                }\n                this.isRecentPointerDateSelect = false;\n            };\n            let documentPointer = this.documentPointer = new PointerDragging(document);\n            documentPointer.shouldIgnoreMove = true;\n            documentPointer.shouldWatchScroll = false;\n            documentPointer.emitter.on('pointerdown', this.onDocumentPointerDown);\n            documentPointer.emitter.on('pointerup', this.onDocumentPointerUp);\n            /*\r\n            TODO: better way to know about whether there was a selection with the pointer\r\n            */ context.emitter.on('select', this.onSelect);\n        }\n        destroy() {\n            this.context.emitter.off('select', this.onSelect);\n            this.documentPointer.destroy();\n        }\n    }\n    const OPTION_REFINERS$3 = {\n        fixedMirrorParent: identity\n    };\n    const LISTENER_REFINERS = {\n        dateClick: identity,\n        eventDragStart: identity,\n        eventDragStop: identity,\n        eventDrop: identity,\n        eventResizeStart: identity,\n        eventResizeStop: identity,\n        eventResize: identity,\n        drop: identity,\n        eventReceive: identity,\n        eventLeave: identity\n    };\n    /*\r\n    Given an already instantiated draggable object for one-or-more elements,\r\n    Interprets any dragging as an attempt to drag an events that lives outside\r\n    of a calendar onto a calendar.\r\n    */ class ExternalElementDragging {\n        constructor(dragging, suppliedDragMeta){\n            this.receivingContext = null;\n            this.droppableEvent = null; // will exist for all drags, even if create:false\n            this.suppliedDragMeta = null;\n            this.dragMeta = null;\n            this.handleDragStart = (ev)=>{\n                this.dragMeta = this.buildDragMeta(ev.subjectEl);\n            };\n            this.handleHitUpdate = (hit, isFinal, ev)=>{\n                let { dragging } = this.hitDragging;\n                let receivingContext = null;\n                let droppableEvent = null;\n                let isInvalid = false;\n                let interaction = {\n                    affectedEvents: createEmptyEventStore(),\n                    mutatedEvents: createEmptyEventStore(),\n                    isEvent: this.dragMeta.create\n                };\n                if (hit) {\n                    receivingContext = hit.context;\n                    if (this.canDropElOnCalendar(ev.subjectEl, receivingContext)) {\n                        droppableEvent = computeEventForDateSpan(hit.dateSpan, this.dragMeta, receivingContext);\n                        interaction.mutatedEvents = eventTupleToStore(droppableEvent);\n                        isInvalid = !isInteractionValid(interaction, hit.dateProfile, receivingContext);\n                        if (isInvalid) {\n                            interaction.mutatedEvents = createEmptyEventStore();\n                            droppableEvent = null;\n                        }\n                    }\n                }\n                this.displayDrag(receivingContext, interaction);\n                // show mirror if no already-rendered mirror element OR if we are shutting down the mirror (?)\n                // TODO: wish we could somehow wait for dispatch to guarantee render\n                dragging.setMirrorIsVisible(isFinal || !droppableEvent || !document.querySelector('.fc-event-mirror'));\n                if (!isInvalid) {\n                    enableCursor();\n                } else {\n                    disableCursor();\n                }\n                if (!isFinal) {\n                    dragging.setMirrorNeedsRevert(!droppableEvent);\n                    this.receivingContext = receivingContext;\n                    this.droppableEvent = droppableEvent;\n                }\n            };\n            this.handleDragEnd = (pev)=>{\n                let { receivingContext, droppableEvent } = this;\n                this.clearDrag();\n                if (receivingContext && droppableEvent) {\n                    let finalHit = this.hitDragging.finalHit;\n                    let finalView = finalHit.context.viewApi;\n                    let dragMeta = this.dragMeta;\n                    receivingContext.emitter.trigger('drop', Object.assign(Object.assign({}, buildDatePointApiWithContext(finalHit.dateSpan, receivingContext)), {\n                        draggedEl: pev.subjectEl,\n                        jsEvent: pev.origEvent,\n                        view: finalView\n                    }));\n                    if (dragMeta.create) {\n                        let addingEvents = eventTupleToStore(droppableEvent);\n                        receivingContext.dispatch({\n                            type: 'MERGE_EVENTS',\n                            eventStore: addingEvents\n                        });\n                        if (pev.isTouch) {\n                            receivingContext.dispatch({\n                                type: 'SELECT_EVENT',\n                                eventInstanceId: droppableEvent.instance.instanceId\n                            });\n                        }\n                        // signal that an external event landed\n                        receivingContext.emitter.trigger('eventReceive', {\n                            event: new EventImpl(receivingContext, droppableEvent.def, droppableEvent.instance),\n                            relatedEvents: [],\n                            revert () {\n                                receivingContext.dispatch({\n                                    type: 'REMOVE_EVENTS',\n                                    eventStore: addingEvents\n                                });\n                            },\n                            draggedEl: pev.subjectEl,\n                            view: finalView\n                        });\n                    }\n                }\n                this.receivingContext = null;\n                this.droppableEvent = null;\n            };\n            let hitDragging = this.hitDragging = new HitDragging(dragging, interactionSettingsStore);\n            hitDragging.requireInitial = false; // will start outside of a component\n            hitDragging.emitter.on('dragstart', this.handleDragStart);\n            hitDragging.emitter.on('hitupdate', this.handleHitUpdate);\n            hitDragging.emitter.on('dragend', this.handleDragEnd);\n            this.suppliedDragMeta = suppliedDragMeta;\n        }\n        buildDragMeta(subjectEl) {\n            if (typeof this.suppliedDragMeta === 'object') {\n                return parseDragMeta(this.suppliedDragMeta);\n            }\n            if (typeof this.suppliedDragMeta === 'function') {\n                return parseDragMeta(this.suppliedDragMeta(subjectEl));\n            }\n            return getDragMetaFromEl(subjectEl);\n        }\n        displayDrag(nextContext, state) {\n            let prevContext = this.receivingContext;\n            if (prevContext && prevContext !== nextContext) {\n                prevContext.dispatch({\n                    type: 'UNSET_EVENT_DRAG'\n                });\n            }\n            if (nextContext) {\n                nextContext.dispatch({\n                    type: 'SET_EVENT_DRAG',\n                    state\n                });\n            }\n        }\n        clearDrag() {\n            if (this.receivingContext) {\n                this.receivingContext.dispatch({\n                    type: 'UNSET_EVENT_DRAG'\n                });\n            }\n        }\n        canDropElOnCalendar(el, receivingContext) {\n            let dropAccept = receivingContext.options.dropAccept;\n            if (typeof dropAccept === 'function') {\n                return dropAccept.call(receivingContext.calendarApi, el);\n            }\n            if (typeof dropAccept === 'string' && dropAccept) {\n                return Boolean(elementMatches(el, dropAccept));\n            }\n            return true;\n        }\n    }\n    // Utils for computing event store from the DragMeta\n    // ----------------------------------------------------------------------------------------------------\n    function computeEventForDateSpan(dateSpan, dragMeta, context) {\n        let defProps = Object.assign({}, dragMeta.leftoverProps);\n        for (let transform of context.pluginHooks.externalDefTransforms){\n            Object.assign(defProps, transform(dateSpan, dragMeta));\n        }\n        let { refined, extra } = refineEventDef(defProps, context);\n        let def = parseEventDef(refined, extra, dragMeta.sourceId, dateSpan.allDay, context.options.forceEventDuration || Boolean(dragMeta.duration), context);\n        let start = dateSpan.range.start;\n        // only rely on time info if drop zone is all-day,\n        // otherwise, we already know the time\n        if (dateSpan.allDay && dragMeta.startTime) {\n            start = context.dateEnv.add(start, dragMeta.startTime);\n        }\n        let end = dragMeta.duration ? context.dateEnv.add(start, dragMeta.duration) : getDefaultEventEnd(dateSpan.allDay, start, context);\n        let instance = createEventInstance(def.defId, {\n            start,\n            end\n        });\n        return {\n            def,\n            instance\n        };\n    }\n    // Utils for extracting data from element\n    // ----------------------------------------------------------------------------------------------------\n    function getDragMetaFromEl(el) {\n        let str = getEmbeddedElData(el, 'event');\n        let obj = str ? JSON.parse(str) : {\n            create: false\n        }; // if no embedded data, assume no event creation\n        return parseDragMeta(obj);\n    }\n    config.dataAttrPrefix = '';\n    function getEmbeddedElData(el, name) {\n        let prefix = config.dataAttrPrefix;\n        let prefixedName = (prefix ? prefix + '-' : '') + name;\n        return el.getAttribute('data-' + prefixedName) || '';\n    }\n    /*\r\n    Makes an element (that is *external* to any calendar) draggable.\r\n    Can pass in data that determines how an event will be created when dropped onto a calendar.\r\n    Leverages FullCalendar's internal drag-n-drop functionality WITHOUT a third-party drag system.\r\n    */ class ExternalDraggable {\n        constructor(el, settings = {}){\n            this.handlePointerDown = (ev)=>{\n                let { dragging } = this;\n                let { minDistance, longPressDelay } = this.settings;\n                dragging.minDistance = minDistance != null ? minDistance : ev.isTouch ? 0 : BASE_OPTION_DEFAULTS.eventDragMinDistance;\n                dragging.delay = ev.isTouch ? longPressDelay != null ? longPressDelay : BASE_OPTION_DEFAULTS.longPressDelay : 0;\n            };\n            this.handleDragStart = (ev)=>{\n                if (ev.isTouch && this.dragging.delay && ev.subjectEl.classList.contains('fc-event')) {\n                    this.dragging.mirror.getMirrorEl().classList.add('fc-event-selected');\n                }\n            };\n            this.settings = settings;\n            let dragging = this.dragging = new FeaturefulElementDragging(el);\n            dragging.touchScrollAllowed = false;\n            if (settings.itemSelector != null) {\n                dragging.pointer.selector = settings.itemSelector;\n            }\n            if (settings.appendTo != null) {\n                dragging.mirror.parentNode = settings.appendTo; // TODO: write tests\n            }\n            dragging.emitter.on('pointerdown', this.handlePointerDown);\n            dragging.emitter.on('dragstart', this.handleDragStart);\n            new ExternalElementDragging(dragging, settings.eventData); // eslint-disable-line no-new\n        }\n        destroy() {\n            this.dragging.destroy();\n        }\n    }\n    /*\r\n    Detects when a *THIRD-PARTY* drag-n-drop system interacts with elements.\r\n    The third-party system is responsible for drawing the visuals effects of the drag.\r\n    This class simply monitors for pointer movements and fires events.\r\n    It also has the ability to hide the moving element (the \"mirror\") during the drag.\r\n    */ class InferredElementDragging extends ElementDragging {\n        constructor(containerEl){\n            super(containerEl);\n            this.shouldIgnoreMove = false;\n            this.mirrorSelector = '';\n            this.currentMirrorEl = null;\n            this.handlePointerDown = (ev)=>{\n                this.emitter.trigger('pointerdown', ev);\n                if (!this.shouldIgnoreMove) {\n                    // fire dragstart right away. does not support delay or min-distance\n                    this.emitter.trigger('dragstart', ev);\n                }\n            };\n            this.handlePointerMove = (ev)=>{\n                if (!this.shouldIgnoreMove) {\n                    this.emitter.trigger('dragmove', ev);\n                }\n            };\n            this.handlePointerUp = (ev)=>{\n                this.emitter.trigger('pointerup', ev);\n                if (!this.shouldIgnoreMove) {\n                    // fire dragend right away. does not support a revert animation\n                    this.emitter.trigger('dragend', ev);\n                }\n            };\n            let pointer = this.pointer = new PointerDragging(containerEl);\n            pointer.emitter.on('pointerdown', this.handlePointerDown);\n            pointer.emitter.on('pointermove', this.handlePointerMove);\n            pointer.emitter.on('pointerup', this.handlePointerUp);\n        }\n        destroy() {\n            this.pointer.destroy();\n        }\n        setIgnoreMove(bool) {\n            this.shouldIgnoreMove = bool;\n        }\n        setMirrorIsVisible(bool) {\n            if (bool) {\n                // restore a previously hidden element.\n                // use the reference in case the selector class has already been removed.\n                if (this.currentMirrorEl) {\n                    this.currentMirrorEl.style.visibility = '';\n                    this.currentMirrorEl = null;\n                }\n            } else {\n                let mirrorEl = this.mirrorSelector ? document.querySelector(this.mirrorSelector) : null;\n                if (mirrorEl) {\n                    this.currentMirrorEl = mirrorEl;\n                    mirrorEl.style.visibility = 'hidden';\n                }\n            }\n        }\n    }\n    /*\r\n    Bridges third-party drag-n-drop systems with FullCalendar.\r\n    Must be instantiated and destroyed by caller.\r\n    */ class ThirdPartyDraggable {\n        constructor(containerOrSettings, settings){\n            let containerEl = document;\n            if (// wish we could just test instanceof EventTarget, but doesn't work in IE11\n            containerOrSettings === document || containerOrSettings instanceof Element) {\n                containerEl = containerOrSettings;\n                settings = settings || {};\n            } else {\n                settings = containerOrSettings || {};\n            }\n            let dragging = this.dragging = new InferredElementDragging(containerEl);\n            if (typeof settings.itemSelector === 'string') {\n                dragging.pointer.selector = settings.itemSelector;\n            } else if (containerEl === document) {\n                dragging.pointer.selector = '[data-event]';\n            }\n            if (typeof settings.mirrorSelector === 'string') {\n                dragging.mirrorSelector = settings.mirrorSelector;\n            }\n            new ExternalElementDragging(dragging, settings.eventData); // eslint-disable-line no-new\n        }\n        destroy() {\n            this.dragging.destroy();\n        }\n    }\n    var index$4 = createPlugin({\n        name: '@fullcalendar/interaction',\n        componentInteractions: [\n            DateClicking,\n            DateSelecting,\n            EventDragging,\n            EventResizing\n        ],\n        calendarInteractions: [\n            UnselectAuto\n        ],\n        elementDraggingImpl: FeaturefulElementDragging,\n        optionRefiners: OPTION_REFINERS$3,\n        listenerRefiners: LISTENER_REFINERS\n    });\n    var css_248z$3 = \":root{--fc-daygrid-event-dot-width:8px}.fc-daygrid-day-events:after,.fc-daygrid-day-events:before,.fc-daygrid-day-frame:after,.fc-daygrid-day-frame:before,.fc-daygrid-event-harness:after,.fc-daygrid-event-harness:before{clear:both;content:\\\"\\\";display:table}.fc .fc-daygrid-body{position:relative;z-index:1}.fc .fc-daygrid-day.fc-day-today{background-color:var(--fc-today-bg-color)}.fc .fc-daygrid-day-frame{min-height:100%;position:relative}.fc .fc-daygrid-day-top{display:flex;flex-direction:row-reverse}.fc .fc-day-other .fc-daygrid-day-top{opacity:.3}.fc .fc-daygrid-day-number{padding:4px;position:relative;z-index:4}.fc .fc-daygrid-month-start{font-size:1.1em;font-weight:700}.fc .fc-daygrid-day-events{margin-top:1px}.fc .fc-daygrid-body-balanced .fc-daygrid-day-events{left:0;position:absolute;right:0}.fc .fc-daygrid-body-unbalanced .fc-daygrid-day-events{min-height:2em;position:relative}.fc .fc-daygrid-body-natural .fc-daygrid-day-events{margin-bottom:1em}.fc .fc-daygrid-event-harness{position:relative}.fc .fc-daygrid-event-harness-abs{left:0;position:absolute;right:0;top:0}.fc .fc-daygrid-bg-harness{bottom:0;position:absolute;top:0}.fc .fc-daygrid-day-bg .fc-non-business{z-index:1}.fc .fc-daygrid-day-bg .fc-bg-event{z-index:2}.fc .fc-daygrid-day-bg .fc-highlight{z-index:3}.fc .fc-daygrid-event{margin-top:1px;z-index:6}.fc .fc-daygrid-event.fc-event-mirror{z-index:7}.fc .fc-daygrid-day-bottom{font-size:.85em;margin:0 2px}.fc .fc-daygrid-day-bottom:after,.fc .fc-daygrid-day-bottom:before{clear:both;content:\\\"\\\";display:table}.fc .fc-daygrid-more-link{border-radius:3px;cursor:pointer;line-height:1;margin-top:1px;max-width:100%;overflow:hidden;padding:2px;position:relative;white-space:nowrap;z-index:4}.fc .fc-daygrid-more-link:hover{background-color:rgba(0,0,0,.1)}.fc .fc-daygrid-week-number{background-color:var(--fc-neutral-bg-color);color:var(--fc-neutral-text-color);min-width:1.5em;padding:2px;position:absolute;text-align:center;top:0;z-index:5}.fc .fc-more-popover .fc-popover-body{min-width:220px;padding:10px}.fc-direction-ltr .fc-daygrid-event.fc-event-start,.fc-direction-rtl .fc-daygrid-event.fc-event-end{margin-left:2px}.fc-direction-ltr .fc-daygrid-event.fc-event-end,.fc-direction-rtl .fc-daygrid-event.fc-event-start{margin-right:2px}.fc-direction-ltr .fc-daygrid-more-link{float:left}.fc-direction-ltr .fc-daygrid-week-number{border-radius:0 0 3px 0;left:0}.fc-direction-rtl .fc-daygrid-more-link{float:right}.fc-direction-rtl .fc-daygrid-week-number{border-radius:0 0 0 3px;right:0}.fc-liquid-hack .fc-daygrid-day-frame{position:static}.fc-daygrid-event{border-radius:3px;font-size:var(--fc-small-font-size);position:relative;white-space:nowrap}.fc-daygrid-block-event .fc-event-time{font-weight:700}.fc-daygrid-block-event .fc-event-time,.fc-daygrid-block-event .fc-event-title{padding:1px}.fc-daygrid-dot-event{align-items:center;display:flex;padding:2px 0}.fc-daygrid-dot-event .fc-event-title{flex-grow:1;flex-shrink:1;font-weight:700;min-width:0;overflow:hidden}.fc-daygrid-dot-event.fc-event-mirror,.fc-daygrid-dot-event:hover{background:rgba(0,0,0,.1)}.fc-daygrid-dot-event.fc-event-selected:before{bottom:-10px;top:-10px}.fc-daygrid-event-dot{border:calc(var(--fc-daygrid-event-dot-width)/2) solid var(--fc-event-border-color);border-radius:calc(var(--fc-daygrid-event-dot-width)/2);box-sizing:content-box;height:0;margin:0 4px;width:0}.fc-direction-ltr .fc-daygrid-event .fc-event-time{margin-right:3px}.fc-direction-rtl .fc-daygrid-event .fc-event-time{margin-left:3px}\";\n    injectStyles(css_248z$3);\n    function splitSegsByRow(segs, rowCnt) {\n        let byRow = [];\n        for(let i = 0; i < rowCnt; i += 1){\n            byRow[i] = [];\n        }\n        for (let seg of segs){\n            byRow[seg.row].push(seg);\n        }\n        return byRow;\n    }\n    function splitSegsByFirstCol(segs, colCnt) {\n        let byCol = [];\n        for(let i = 0; i < colCnt; i += 1){\n            byCol[i] = [];\n        }\n        for (let seg of segs){\n            byCol[seg.firstCol].push(seg);\n        }\n        return byCol;\n    }\n    function splitInteractionByRow(ui, rowCnt) {\n        let byRow = [];\n        if (!ui) {\n            for(let i = 0; i < rowCnt; i += 1){\n                byRow[i] = null;\n            }\n        } else {\n            for(let i = 0; i < rowCnt; i += 1){\n                byRow[i] = {\n                    affectedInstances: ui.affectedInstances,\n                    isEvent: ui.isEvent,\n                    segs: []\n                };\n            }\n            for (let seg of ui.segs){\n                byRow[seg.row].segs.push(seg);\n            }\n        }\n        return byRow;\n    }\n    const DEFAULT_TABLE_EVENT_TIME_FORMAT = createFormatter({\n        hour: 'numeric',\n        minute: '2-digit',\n        omitZeroMinute: true,\n        meridiem: 'narrow'\n    });\n    function hasListItemDisplay(seg) {\n        let { display } = seg.eventRange.ui;\n        return display === 'list-item' || display === 'auto' && !seg.eventRange.def.allDay && seg.firstCol === seg.lastCol && // can't be multi-day\n        seg.isStart && // \"\n        seg.isEnd // \"\n        ;\n    }\n    class TableBlockEvent extends BaseComponent {\n        render() {\n            let { props } = this;\n            return y(StandardEvent, Object.assign({}, props, {\n                elClasses: [\n                    'fc-daygrid-event',\n                    'fc-daygrid-block-event',\n                    'fc-h-event'\n                ],\n                defaultTimeFormat: DEFAULT_TABLE_EVENT_TIME_FORMAT,\n                defaultDisplayEventEnd: props.defaultDisplayEventEnd,\n                disableResizing: !props.seg.eventRange.def.allDay\n            }));\n        }\n    }\n    class TableListItemEvent extends BaseComponent {\n        render() {\n            let { props, context } = this;\n            let { options } = context;\n            let { seg } = props;\n            let timeFormat = options.eventTimeFormat || DEFAULT_TABLE_EVENT_TIME_FORMAT;\n            let timeText = buildSegTimeText(seg, timeFormat, context, true, props.defaultDisplayEventEnd);\n            return y(EventContainer, Object.assign({}, props, {\n                elTag: \"a\",\n                elClasses: [\n                    'fc-daygrid-event',\n                    'fc-daygrid-dot-event'\n                ],\n                elAttrs: getSegAnchorAttrs(props.seg, context),\n                defaultGenerator: renderInnerContent$2,\n                timeText: timeText,\n                isResizing: false,\n                isDateSelecting: false\n            }));\n        }\n    }\n    function renderInnerContent$2(renderProps) {\n        return y(_, null, y(\"div\", {\n            className: \"fc-daygrid-event-dot\",\n            style: {\n                borderColor: renderProps.borderColor || renderProps.backgroundColor\n            }\n        }), renderProps.timeText && y(\"div\", {\n            className: \"fc-event-time\"\n        }, renderProps.timeText), y(\"div\", {\n            className: \"fc-event-title\"\n        }, renderProps.event.title || y(_, null, \"\\u00A0\")));\n    }\n    class TableCellMoreLink extends BaseComponent {\n        constructor(){\n            super(...arguments);\n            this.compileSegs = memoize(compileSegs);\n        }\n        render() {\n            let { props } = this;\n            let { allSegs, invisibleSegs } = this.compileSegs(props.singlePlacements);\n            return y(MoreLinkContainer, {\n                elClasses: [\n                    'fc-daygrid-more-link'\n                ],\n                dateProfile: props.dateProfile,\n                todayRange: props.todayRange,\n                allDayDate: props.allDayDate,\n                moreCnt: props.moreCnt,\n                allSegs: allSegs,\n                hiddenSegs: invisibleSegs,\n                alignmentElRef: props.alignmentElRef,\n                alignGridTop: props.alignGridTop,\n                extraDateSpan: props.extraDateSpan,\n                popoverContent: ()=>{\n                    let isForcedInvisible = (props.eventDrag ? props.eventDrag.affectedInstances : null) || (props.eventResize ? props.eventResize.affectedInstances : null) || {};\n                    return y(_, null, allSegs.map((seg)=>{\n                        let instanceId = seg.eventRange.instance.instanceId;\n                        return y(\"div\", {\n                            className: \"fc-daygrid-event-harness\",\n                            key: instanceId,\n                            style: {\n                                visibility: isForcedInvisible[instanceId] ? 'hidden' : ''\n                            }\n                        }, hasListItemDisplay(seg) ? y(TableListItemEvent, Object.assign({\n                            seg: seg,\n                            isDragging: false,\n                            isSelected: instanceId === props.eventSelection,\n                            defaultDisplayEventEnd: false\n                        }, getSegMeta(seg, props.todayRange))) : y(TableBlockEvent, Object.assign({\n                            seg: seg,\n                            isDragging: false,\n                            isResizing: false,\n                            isDateSelecting: false,\n                            isSelected: instanceId === props.eventSelection,\n                            defaultDisplayEventEnd: false\n                        }, getSegMeta(seg, props.todayRange))));\n                    }));\n                }\n            });\n        }\n    }\n    function compileSegs(singlePlacements) {\n        let allSegs = [];\n        let invisibleSegs = [];\n        for (let placement of singlePlacements){\n            allSegs.push(placement.seg);\n            if (!placement.isVisible) {\n                invisibleSegs.push(placement.seg);\n            }\n        }\n        return {\n            allSegs,\n            invisibleSegs\n        };\n    }\n    const DEFAULT_WEEK_NUM_FORMAT$1 = createFormatter({\n        week: 'narrow'\n    });\n    class TableCell extends DateComponent {\n        constructor(){\n            super(...arguments);\n            this.rootElRef = d();\n            this.state = {\n                dayNumberId: getUniqueDomId()\n            };\n            this.handleRootEl = (el)=>{\n                setRef(this.rootElRef, el);\n                setRef(this.props.elRef, el);\n            };\n        }\n        render() {\n            let { context, props, state, rootElRef } = this;\n            let { options, dateEnv } = context;\n            let { date, dateProfile } = props;\n            // TODO: memoize this?\n            const isMonthStart = props.showDayNumber && shouldDisplayMonthStart(date, dateProfile.currentRange, dateEnv);\n            return y(DayCellContainer, {\n                elTag: \"td\",\n                elRef: this.handleRootEl,\n                elClasses: [\n                    'fc-daygrid-day',\n                    ...props.extraClassNames || []\n                ],\n                elAttrs: Object.assign(Object.assign(Object.assign({}, props.extraDataAttrs), props.showDayNumber ? {\n                    'aria-labelledby': state.dayNumberId\n                } : {}), {\n                    role: 'gridcell'\n                }),\n                defaultGenerator: renderTopInner,\n                date: date,\n                dateProfile: dateProfile,\n                todayRange: props.todayRange,\n                showDayNumber: props.showDayNumber,\n                isMonthStart: isMonthStart,\n                extraRenderProps: props.extraRenderProps\n            }, (InnerContent, renderProps)=>y(\"div\", {\n                    ref: props.innerElRef,\n                    className: \"fc-daygrid-day-frame fc-scrollgrid-sync-inner\",\n                    style: {\n                        minHeight: props.minHeight\n                    }\n                }, props.showWeekNumber && y(WeekNumberContainer, {\n                    elTag: \"a\",\n                    elClasses: [\n                        'fc-daygrid-week-number'\n                    ],\n                    elAttrs: buildNavLinkAttrs(context, date, 'week'),\n                    date: date,\n                    defaultFormat: DEFAULT_WEEK_NUM_FORMAT$1\n                }), !renderProps.isDisabled && (props.showDayNumber || hasCustomDayCellContent(options) || props.forceDayTop) ? y(\"div\", {\n                    className: \"fc-daygrid-day-top\"\n                }, y(InnerContent, {\n                    elTag: \"a\",\n                    elClasses: [\n                        'fc-daygrid-day-number',\n                        isMonthStart && 'fc-daygrid-month-start'\n                    ],\n                    elAttrs: Object.assign(Object.assign({}, buildNavLinkAttrs(context, date)), {\n                        id: state.dayNumberId\n                    })\n                })) : props.showDayNumber ? // for creating correct amount of space (see issue #7162)\n                y(\"div\", {\n                    className: \"fc-daygrid-day-top\",\n                    style: {\n                        visibility: 'hidden'\n                    }\n                }, y(\"a\", {\n                    className: \"fc-daygrid-day-number\"\n                }, \"\\u00A0\")) : undefined, y(\"div\", {\n                    className: \"fc-daygrid-day-events\",\n                    ref: props.fgContentElRef\n                }, props.fgContent, y(\"div\", {\n                    className: \"fc-daygrid-day-bottom\",\n                    style: {\n                        marginTop: props.moreMarginTop\n                    }\n                }, y(TableCellMoreLink, {\n                    allDayDate: date,\n                    singlePlacements: props.singlePlacements,\n                    moreCnt: props.moreCnt,\n                    alignmentElRef: rootElRef,\n                    alignGridTop: !props.showDayNumber,\n                    extraDateSpan: props.extraDateSpan,\n                    dateProfile: props.dateProfile,\n                    eventSelection: props.eventSelection,\n                    eventDrag: props.eventDrag,\n                    eventResize: props.eventResize,\n                    todayRange: props.todayRange\n                }))), y(\"div\", {\n                    className: \"fc-daygrid-day-bg\"\n                }, props.bgContent)));\n        }\n    }\n    function renderTopInner(props) {\n        return props.dayNumberText || y(_, null, \"\\u00A0\");\n    }\n    function shouldDisplayMonthStart(date, currentRange, dateEnv) {\n        const { start: currentStart, end: currentEnd } = currentRange;\n        const currentEndIncl = addMs(currentEnd, -1);\n        const currentFirstYear = dateEnv.getYear(currentStart);\n        const currentFirstMonth = dateEnv.getMonth(currentStart);\n        const currentLastYear = dateEnv.getYear(currentEndIncl);\n        const currentLastMonth = dateEnv.getMonth(currentEndIncl);\n        // spans more than one month?\n        return !(currentFirstYear === currentLastYear && currentFirstMonth === currentLastMonth) && Boolean(// first date in current view?\n        date.valueOf() === currentStart.valueOf() || // a month-start that's within the current range?\n        dateEnv.getDay(date) === 1 && date.valueOf() < currentEnd.valueOf());\n    }\n    function computeFgSegPlacement(segs, dayMaxEvents, dayMaxEventRows, strictOrder, eventInstanceHeights, maxContentHeight, cells) {\n        let hierarchy = new DayGridSegHierarchy();\n        hierarchy.allowReslicing = true;\n        hierarchy.strictOrder = strictOrder;\n        if (dayMaxEvents === true || dayMaxEventRows === true) {\n            hierarchy.maxCoord = maxContentHeight;\n            hierarchy.hiddenConsumes = true;\n        } else if (typeof dayMaxEvents === 'number') {\n            hierarchy.maxStackCnt = dayMaxEvents;\n        } else if (typeof dayMaxEventRows === 'number') {\n            hierarchy.maxStackCnt = dayMaxEventRows;\n            hierarchy.hiddenConsumes = true;\n        }\n        // create segInputs only for segs with known heights\n        let segInputs = [];\n        let unknownHeightSegs = [];\n        for(let i = 0; i < segs.length; i += 1){\n            let seg = segs[i];\n            let { instanceId } = seg.eventRange.instance;\n            let eventHeight = eventInstanceHeights[instanceId];\n            if (eventHeight != null) {\n                segInputs.push({\n                    index: i,\n                    thickness: eventHeight,\n                    span: {\n                        start: seg.firstCol,\n                        end: seg.lastCol + 1\n                    }\n                });\n            } else {\n                unknownHeightSegs.push(seg);\n            }\n        }\n        let hiddenEntries = hierarchy.addSegs(segInputs);\n        let segRects = hierarchy.toRects();\n        let { singleColPlacements, multiColPlacements, leftoverMargins } = placeRects(segRects, segs, cells);\n        let moreCnts = [];\n        let moreMarginTops = [];\n        // add segs with unknown heights\n        for (let seg of unknownHeightSegs){\n            multiColPlacements[seg.firstCol].push({\n                seg,\n                isVisible: false,\n                isAbsolute: true,\n                absoluteTop: 0,\n                marginTop: 0\n            });\n            for(let col = seg.firstCol; col <= seg.lastCol; col += 1){\n                singleColPlacements[col].push({\n                    seg: resliceSeg(seg, col, col + 1, cells),\n                    isVisible: false,\n                    isAbsolute: false,\n                    absoluteTop: 0,\n                    marginTop: 0\n                });\n            }\n        }\n        // add the hidden entries\n        for(let col = 0; col < cells.length; col += 1){\n            moreCnts.push(0);\n        }\n        for (let hiddenEntry of hiddenEntries){\n            let seg = segs[hiddenEntry.index];\n            let hiddenSpan = hiddenEntry.span;\n            multiColPlacements[hiddenSpan.start].push({\n                seg: resliceSeg(seg, hiddenSpan.start, hiddenSpan.end, cells),\n                isVisible: false,\n                isAbsolute: true,\n                absoluteTop: 0,\n                marginTop: 0\n            });\n            for(let col = hiddenSpan.start; col < hiddenSpan.end; col += 1){\n                moreCnts[col] += 1;\n                singleColPlacements[col].push({\n                    seg: resliceSeg(seg, col, col + 1, cells),\n                    isVisible: false,\n                    isAbsolute: false,\n                    absoluteTop: 0,\n                    marginTop: 0\n                });\n            }\n        }\n        // deal with leftover margins\n        for(let col = 0; col < cells.length; col += 1){\n            moreMarginTops.push(leftoverMargins[col]);\n        }\n        return {\n            singleColPlacements,\n            multiColPlacements,\n            moreCnts,\n            moreMarginTops\n        };\n    }\n    // rects ordered by top coord, then left\n    function placeRects(allRects, segs, cells) {\n        let rectsByEachCol = groupRectsByEachCol(allRects, cells.length);\n        let singleColPlacements = [];\n        let multiColPlacements = [];\n        let leftoverMargins = [];\n        for(let col = 0; col < cells.length; col += 1){\n            let rects = rectsByEachCol[col];\n            // compute all static segs in singlePlacements\n            let singlePlacements = [];\n            let currentHeight = 0;\n            let currentMarginTop = 0;\n            for (let rect of rects){\n                let seg = segs[rect.index];\n                singlePlacements.push({\n                    seg: resliceSeg(seg, col, col + 1, cells),\n                    isVisible: true,\n                    isAbsolute: false,\n                    absoluteTop: rect.levelCoord,\n                    marginTop: rect.levelCoord - currentHeight\n                });\n                currentHeight = rect.levelCoord + rect.thickness;\n            }\n            // compute mixed static/absolute segs in multiPlacements\n            let multiPlacements = [];\n            currentHeight = 0;\n            currentMarginTop = 0;\n            for (let rect of rects){\n                let seg = segs[rect.index];\n                let isAbsolute = rect.span.end - rect.span.start > 1; // multi-column?\n                let isFirstCol = rect.span.start === col;\n                currentMarginTop += rect.levelCoord - currentHeight; // amount of space since bottom of previous seg\n                currentHeight = rect.levelCoord + rect.thickness; // height will now be bottom of current seg\n                if (isAbsolute) {\n                    currentMarginTop += rect.thickness;\n                    if (isFirstCol) {\n                        multiPlacements.push({\n                            seg: resliceSeg(seg, rect.span.start, rect.span.end, cells),\n                            isVisible: true,\n                            isAbsolute: true,\n                            absoluteTop: rect.levelCoord,\n                            marginTop: 0\n                        });\n                    }\n                } else if (isFirstCol) {\n                    multiPlacements.push({\n                        seg: resliceSeg(seg, rect.span.start, rect.span.end, cells),\n                        isVisible: true,\n                        isAbsolute: false,\n                        absoluteTop: rect.levelCoord,\n                        marginTop: currentMarginTop\n                    });\n                    currentMarginTop = 0;\n                }\n            }\n            singleColPlacements.push(singlePlacements);\n            multiColPlacements.push(multiPlacements);\n            leftoverMargins.push(currentMarginTop);\n        }\n        return {\n            singleColPlacements,\n            multiColPlacements,\n            leftoverMargins\n        };\n    }\n    function groupRectsByEachCol(rects, colCnt) {\n        let rectsByEachCol = [];\n        for(let col = 0; col < colCnt; col += 1){\n            rectsByEachCol.push([]);\n        }\n        for (let rect of rects){\n            for(let col = rect.span.start; col < rect.span.end; col += 1){\n                rectsByEachCol[col].push(rect);\n            }\n        }\n        return rectsByEachCol;\n    }\n    function resliceSeg(seg, spanStart, spanEnd, cells) {\n        if (seg.firstCol === spanStart && seg.lastCol === spanEnd - 1) {\n            return seg;\n        }\n        let eventRange = seg.eventRange;\n        let origRange = eventRange.range;\n        let slicedRange = intersectRanges(origRange, {\n            start: cells[spanStart].date,\n            end: addDays(cells[spanEnd - 1].date, 1)\n        });\n        return Object.assign(Object.assign({}, seg), {\n            firstCol: spanStart,\n            lastCol: spanEnd - 1,\n            eventRange: {\n                def: eventRange.def,\n                ui: Object.assign(Object.assign({}, eventRange.ui), {\n                    durationEditable: false\n                }),\n                instance: eventRange.instance,\n                range: slicedRange\n            },\n            isStart: seg.isStart && slicedRange.start.valueOf() === origRange.start.valueOf(),\n            isEnd: seg.isEnd && slicedRange.end.valueOf() === origRange.end.valueOf()\n        });\n    }\n    class DayGridSegHierarchy extends SegHierarchy {\n        constructor(){\n            super(...arguments);\n            // config\n            this.hiddenConsumes = false;\n            // allows us to keep hidden entries in the hierarchy so they take up space\n            this.forceHidden = {};\n        }\n        addSegs(segInputs) {\n            const hiddenSegs = super.addSegs(segInputs);\n            const { entriesByLevel } = this;\n            const excludeHidden = (entry)=>!this.forceHidden[buildEntryKey(entry)];\n            // remove the forced-hidden segs\n            for(let level = 0; level < entriesByLevel.length; level += 1){\n                entriesByLevel[level] = entriesByLevel[level].filter(excludeHidden);\n            }\n            return hiddenSegs;\n        }\n        handleInvalidInsertion(insertion, entry, hiddenEntries) {\n            const { entriesByLevel, forceHidden } = this;\n            const { touchingEntry, touchingLevel, touchingLateral } = insertion;\n            if (this.hiddenConsumes && touchingEntry) {\n                const touchingEntryId = buildEntryKey(touchingEntry);\n                // if not already hidden\n                if (!forceHidden[touchingEntryId]) {\n                    if (this.allowReslicing) {\n                        const placeholderEntry = Object.assign(Object.assign({}, touchingEntry), {\n                            span: intersectSpans(touchingEntry.span, entry.span)\n                        });\n                        const placeholderEntryId = buildEntryKey(placeholderEntry);\n                        forceHidden[placeholderEntryId] = true;\n                        entriesByLevel[touchingLevel][touchingLateral] = placeholderEntry; // replace touchingEntry with our placeholder\n                        this.splitEntry(touchingEntry, entry, hiddenEntries); // split up the touchingEntry, reinsert it\n                    } else {\n                        forceHidden[touchingEntryId] = true;\n                        hiddenEntries.push(touchingEntry);\n                    }\n                }\n            }\n            return super.handleInvalidInsertion(insertion, entry, hiddenEntries);\n        }\n    }\n    class TableRow extends DateComponent {\n        constructor(){\n            super(...arguments);\n            this.cellElRefs = new RefMap(); // the <td>\n            this.frameElRefs = new RefMap(); // the fc-daygrid-day-frame\n            this.fgElRefs = new RefMap(); // the fc-daygrid-day-events\n            this.segHarnessRefs = new RefMap(); // indexed by \"instanceId:firstCol\"\n            this.rootElRef = d();\n            this.state = {\n                framePositions: null,\n                maxContentHeight: null,\n                eventInstanceHeights: {}\n            };\n            this.handleResize = (isForced)=>{\n                if (isForced) {\n                    this.updateSizing(true); // isExternal=true\n                }\n            };\n        }\n        render() {\n            let { props, state, context } = this;\n            let { options } = context;\n            let colCnt = props.cells.length;\n            let businessHoursByCol = splitSegsByFirstCol(props.businessHourSegs, colCnt);\n            let bgEventSegsByCol = splitSegsByFirstCol(props.bgEventSegs, colCnt);\n            let highlightSegsByCol = splitSegsByFirstCol(this.getHighlightSegs(), colCnt);\n            let mirrorSegsByCol = splitSegsByFirstCol(this.getMirrorSegs(), colCnt);\n            let { singleColPlacements, multiColPlacements, moreCnts, moreMarginTops } = computeFgSegPlacement(sortEventSegs(props.fgEventSegs, options.eventOrder), props.dayMaxEvents, props.dayMaxEventRows, options.eventOrderStrict, state.eventInstanceHeights, state.maxContentHeight, props.cells);\n            let isForcedInvisible = props.eventDrag && props.eventDrag.affectedInstances || props.eventResize && props.eventResize.affectedInstances || {};\n            return y(\"tr\", {\n                ref: this.rootElRef,\n                role: \"row\"\n            }, props.renderIntro && props.renderIntro(), props.cells.map((cell, col)=>{\n                let normalFgNodes = this.renderFgSegs(col, props.forPrint ? singleColPlacements[col] : multiColPlacements[col], props.todayRange, isForcedInvisible);\n                let mirrorFgNodes = this.renderFgSegs(col, buildMirrorPlacements(mirrorSegsByCol[col], multiColPlacements), props.todayRange, {}, Boolean(props.eventDrag), Boolean(props.eventResize), false);\n                return y(TableCell, {\n                    key: cell.key,\n                    elRef: this.cellElRefs.createRef(cell.key),\n                    innerElRef: this.frameElRefs.createRef(cell.key),\n                    dateProfile: props.dateProfile,\n                    date: cell.date,\n                    showDayNumber: props.showDayNumbers,\n                    showWeekNumber: props.showWeekNumbers && col === 0,\n                    forceDayTop: props.showWeekNumbers /* even displaying weeknum for row, not necessarily day */ ,\n                    todayRange: props.todayRange,\n                    eventSelection: props.eventSelection,\n                    eventDrag: props.eventDrag,\n                    eventResize: props.eventResize,\n                    extraRenderProps: cell.extraRenderProps,\n                    extraDataAttrs: cell.extraDataAttrs,\n                    extraClassNames: cell.extraClassNames,\n                    extraDateSpan: cell.extraDateSpan,\n                    moreCnt: moreCnts[col],\n                    moreMarginTop: moreMarginTops[col],\n                    singlePlacements: singleColPlacements[col],\n                    fgContentElRef: this.fgElRefs.createRef(cell.key),\n                    fgContent: y(_, null, y(_, null, normalFgNodes), y(_, null, mirrorFgNodes)),\n                    bgContent: y(_, null, this.renderFillSegs(highlightSegsByCol[col], 'highlight'), this.renderFillSegs(businessHoursByCol[col], 'non-business'), this.renderFillSegs(bgEventSegsByCol[col], 'bg-event')),\n                    minHeight: props.cellMinHeight\n                });\n            }));\n        }\n        componentDidMount() {\n            this.updateSizing(true);\n            this.context.addResizeHandler(this.handleResize);\n        }\n        componentDidUpdate(prevProps, prevState) {\n            let currentProps = this.props;\n            this.updateSizing(!isPropsEqual(prevProps, currentProps));\n        }\n        componentWillUnmount() {\n            this.context.removeResizeHandler(this.handleResize);\n        }\n        getHighlightSegs() {\n            let { props } = this;\n            if (props.eventDrag && props.eventDrag.segs.length) {\n                return props.eventDrag.segs;\n            }\n            if (props.eventResize && props.eventResize.segs.length) {\n                return props.eventResize.segs;\n            }\n            return props.dateSelectionSegs;\n        }\n        getMirrorSegs() {\n            let { props } = this;\n            if (props.eventResize && props.eventResize.segs.length) {\n                return props.eventResize.segs;\n            }\n            return [];\n        }\n        renderFgSegs(col, segPlacements, todayRange, isForcedInvisible, isDragging, isResizing, isDateSelecting) {\n            let { context } = this;\n            let { eventSelection } = this.props;\n            let { framePositions } = this.state;\n            let defaultDisplayEventEnd = this.props.cells.length === 1; // colCnt === 1\n            let isMirror = isDragging || isResizing || isDateSelecting;\n            let nodes = [];\n            if (framePositions) {\n                for (let placement of segPlacements){\n                    let { seg } = placement;\n                    let { instanceId } = seg.eventRange.instance;\n                    let key = instanceId + ':' + col;\n                    let isVisible = placement.isVisible && !isForcedInvisible[instanceId];\n                    let isAbsolute = placement.isAbsolute;\n                    let left = '';\n                    let right = '';\n                    if (isAbsolute) {\n                        if (context.isRtl) {\n                            right = 0;\n                            left = framePositions.lefts[seg.lastCol] - framePositions.lefts[seg.firstCol];\n                        } else {\n                            left = 0;\n                            right = framePositions.rights[seg.firstCol] - framePositions.rights[seg.lastCol];\n                        }\n                    }\n                    /*\r\n                    known bug: events that are force to be list-item but span multiple days still take up space in later columns\r\n                    todo: in print view, for multi-day events, don't display title within non-start/end segs\r\n                    */ nodes.push(y(\"div\", {\n                        className: 'fc-daygrid-event-harness' + (isAbsolute ? ' fc-daygrid-event-harness-abs' : ''),\n                        key: key,\n                        ref: isMirror ? null : this.segHarnessRefs.createRef(key),\n                        style: {\n                            visibility: isVisible ? '' : 'hidden',\n                            marginTop: isAbsolute ? '' : placement.marginTop,\n                            top: isAbsolute ? placement.absoluteTop : '',\n                            left,\n                            right\n                        }\n                    }, hasListItemDisplay(seg) ? y(TableListItemEvent, Object.assign({\n                        seg: seg,\n                        isDragging: isDragging,\n                        isSelected: instanceId === eventSelection,\n                        defaultDisplayEventEnd: defaultDisplayEventEnd\n                    }, getSegMeta(seg, todayRange))) : y(TableBlockEvent, Object.assign({\n                        seg: seg,\n                        isDragging: isDragging,\n                        isResizing: isResizing,\n                        isDateSelecting: isDateSelecting,\n                        isSelected: instanceId === eventSelection,\n                        defaultDisplayEventEnd: defaultDisplayEventEnd\n                    }, getSegMeta(seg, todayRange)))));\n                }\n            }\n            return nodes;\n        }\n        renderFillSegs(segs, fillType) {\n            let { isRtl } = this.context;\n            let { todayRange } = this.props;\n            let { framePositions } = this.state;\n            let nodes = [];\n            if (framePositions) {\n                for (let seg of segs){\n                    let leftRightCss = isRtl ? {\n                        right: 0,\n                        left: framePositions.lefts[seg.lastCol] - framePositions.lefts[seg.firstCol]\n                    } : {\n                        left: 0,\n                        right: framePositions.rights[seg.firstCol] - framePositions.rights[seg.lastCol]\n                    };\n                    nodes.push(y(\"div\", {\n                        key: buildEventRangeKey(seg.eventRange),\n                        className: \"fc-daygrid-bg-harness\",\n                        style: leftRightCss\n                    }, fillType === 'bg-event' ? y(BgEvent, Object.assign({\n                        seg: seg\n                    }, getSegMeta(seg, todayRange))) : renderFill(fillType)));\n                }\n            }\n            return y(_, {}, ...nodes);\n        }\n        updateSizing(isExternalSizingChange) {\n            let { props, state, frameElRefs } = this;\n            if (!props.forPrint && props.clientWidth !== null // positioning ready?\n            ) {\n                if (isExternalSizingChange) {\n                    let frameEls = props.cells.map((cell)=>frameElRefs.currentMap[cell.key]);\n                    if (frameEls.length) {\n                        let originEl = this.rootElRef.current;\n                        let newPositionCache = new PositionCache(originEl, frameEls, true, false);\n                        if (!state.framePositions || !state.framePositions.similarTo(newPositionCache)) {\n                            this.setState({\n                                framePositions: new PositionCache(originEl, frameEls, true, false)\n                            });\n                        }\n                    }\n                }\n                const oldInstanceHeights = this.state.eventInstanceHeights;\n                const newInstanceHeights = this.queryEventInstanceHeights();\n                const limitByContentHeight = props.dayMaxEvents === true || props.dayMaxEventRows === true;\n                this.safeSetState({\n                    // HACK to prevent oscillations of events being shown/hidden from max-event-rows\n                    // Essentially, once you compute an element's height, never null-out.\n                    // TODO: always display all events, as visibility:hidden?\n                    eventInstanceHeights: Object.assign(Object.assign({}, oldInstanceHeights), newInstanceHeights),\n                    maxContentHeight: limitByContentHeight ? this.computeMaxContentHeight() : null\n                });\n            }\n        }\n        queryEventInstanceHeights() {\n            let segElMap = this.segHarnessRefs.currentMap;\n            let eventInstanceHeights = {};\n            // get the max height amongst instance segs\n            for(let key in segElMap){\n                let height = Math.round(segElMap[key].getBoundingClientRect().height);\n                let instanceId = key.split(':')[0]; // deconstruct how renderFgSegs makes the key\n                eventInstanceHeights[instanceId] = Math.max(eventInstanceHeights[instanceId] || 0, height);\n            }\n            return eventInstanceHeights;\n        }\n        computeMaxContentHeight() {\n            let firstKey = this.props.cells[0].key;\n            let cellEl = this.cellElRefs.currentMap[firstKey];\n            let fcContainerEl = this.fgElRefs.currentMap[firstKey];\n            return cellEl.getBoundingClientRect().bottom - fcContainerEl.getBoundingClientRect().top;\n        }\n        getCellEls() {\n            let elMap = this.cellElRefs.currentMap;\n            return this.props.cells.map((cell)=>elMap[cell.key]);\n        }\n    }\n    TableRow.addStateEquality({\n        eventInstanceHeights: isPropsEqual\n    });\n    function buildMirrorPlacements(mirrorSegs, colPlacements) {\n        if (!mirrorSegs.length) {\n            return [];\n        }\n        let topsByInstanceId = buildAbsoluteTopHash(colPlacements); // TODO: cache this at first render?\n        return mirrorSegs.map((seg)=>({\n                seg,\n                isVisible: true,\n                isAbsolute: true,\n                absoluteTop: topsByInstanceId[seg.eventRange.instance.instanceId],\n                marginTop: 0\n            }));\n    }\n    function buildAbsoluteTopHash(colPlacements) {\n        let topsByInstanceId = {};\n        for (let placements of colPlacements){\n            for (let placement of placements){\n                topsByInstanceId[placement.seg.eventRange.instance.instanceId] = placement.absoluteTop;\n            }\n        }\n        return topsByInstanceId;\n    }\n    class TableRows extends DateComponent {\n        constructor(){\n            super(...arguments);\n            this.splitBusinessHourSegs = memoize(splitSegsByRow);\n            this.splitBgEventSegs = memoize(splitSegsByRow);\n            this.splitFgEventSegs = memoize(splitSegsByRow);\n            this.splitDateSelectionSegs = memoize(splitSegsByRow);\n            this.splitEventDrag = memoize(splitInteractionByRow);\n            this.splitEventResize = memoize(splitInteractionByRow);\n            this.rowRefs = new RefMap();\n        }\n        render() {\n            let { props, context } = this;\n            let rowCnt = props.cells.length;\n            let businessHourSegsByRow = this.splitBusinessHourSegs(props.businessHourSegs, rowCnt);\n            let bgEventSegsByRow = this.splitBgEventSegs(props.bgEventSegs, rowCnt);\n            let fgEventSegsByRow = this.splitFgEventSegs(props.fgEventSegs, rowCnt);\n            let dateSelectionSegsByRow = this.splitDateSelectionSegs(props.dateSelectionSegs, rowCnt);\n            let eventDragByRow = this.splitEventDrag(props.eventDrag, rowCnt);\n            let eventResizeByRow = this.splitEventResize(props.eventResize, rowCnt);\n            // for DayGrid view with many rows, force a min-height on cells so doesn't appear squished\n            // choose 7 because a month view will have max 6 rows\n            let cellMinHeight = rowCnt >= 7 && props.clientWidth ? props.clientWidth / context.options.aspectRatio / 6 : null;\n            return y(NowTimer, {\n                unit: \"day\"\n            }, (nowDate, todayRange)=>y(_, null, props.cells.map((cells, row)=>y(TableRow, {\n                        ref: this.rowRefs.createRef(row),\n                        key: cells.length ? cells[0].date.toISOString() : row // in case there are no cells (like when resource view is loading)\n                        ,\n                        showDayNumbers: rowCnt > 1,\n                        showWeekNumbers: props.showWeekNumbers,\n                        todayRange: todayRange,\n                        dateProfile: props.dateProfile,\n                        cells: cells,\n                        renderIntro: props.renderRowIntro,\n                        businessHourSegs: businessHourSegsByRow[row],\n                        eventSelection: props.eventSelection,\n                        bgEventSegs: bgEventSegsByRow[row].filter(isSegAllDay),\n                        fgEventSegs: fgEventSegsByRow[row],\n                        dateSelectionSegs: dateSelectionSegsByRow[row],\n                        eventDrag: eventDragByRow[row],\n                        eventResize: eventResizeByRow[row],\n                        dayMaxEvents: props.dayMaxEvents,\n                        dayMaxEventRows: props.dayMaxEventRows,\n                        clientWidth: props.clientWidth,\n                        clientHeight: props.clientHeight,\n                        cellMinHeight: cellMinHeight,\n                        forPrint: props.forPrint\n                    }))));\n        }\n        componentDidMount() {\n            // HACK: need a daygrid wrapper parent to do positioning\n            // NOTE: a daygrid resource view w/o resources can have zero cells\n            const firstCellEl = this.rowRefs.currentMap[0].getCellEls()[0];\n            this.rootEl = firstCellEl ? firstCellEl.closest('.fc-daygrid-body') : null;\n            if (this.rootEl) {\n                this.context.registerInteractiveComponent(this, {\n                    el: this.rootEl,\n                    isHitComboAllowed: this.props.isHitComboAllowed\n                });\n            }\n        }\n        componentWillUnmount() {\n            if (this.rootEl) {\n                this.context.unregisterInteractiveComponent(this);\n                this.rootEl = null;\n            }\n        }\n        // Hit System\n        // ----------------------------------------------------------------------------------------------------\n        prepareHits() {\n            this.rowPositions = new PositionCache(this.rootEl, this.rowRefs.collect().map((rowObj)=>rowObj.getCellEls()[0]), false, true);\n            this.colPositions = new PositionCache(this.rootEl, this.rowRefs.currentMap[0].getCellEls(), true, false);\n        }\n        queryHit(positionLeft, positionTop) {\n            let { colPositions, rowPositions } = this;\n            let col = colPositions.leftToIndex(positionLeft);\n            let row = rowPositions.topToIndex(positionTop);\n            if (row != null && col != null) {\n                let cell = this.props.cells[row][col];\n                return {\n                    dateProfile: this.props.dateProfile,\n                    dateSpan: Object.assign({\n                        range: this.getCellRange(row, col),\n                        allDay: true\n                    }, cell.extraDateSpan),\n                    dayEl: this.getCellEl(row, col),\n                    rect: {\n                        left: colPositions.lefts[col],\n                        right: colPositions.rights[col],\n                        top: rowPositions.tops[row],\n                        bottom: rowPositions.bottoms[row]\n                    },\n                    layer: 0\n                };\n            }\n            return null;\n        }\n        getCellEl(row, col) {\n            return this.rowRefs.currentMap[row].getCellEls()[col]; // TODO: not optimal\n        }\n        getCellRange(row, col) {\n            let start = this.props.cells[row][col].date;\n            let end = addDays(start, 1);\n            return {\n                start,\n                end\n            };\n        }\n    }\n    function isSegAllDay(seg) {\n        return seg.eventRange.def.allDay;\n    }\n    class Table extends DateComponent {\n        constructor(){\n            super(...arguments);\n            this.elRef = d();\n            this.needsScrollReset = false;\n        }\n        render() {\n            let { props } = this;\n            let { dayMaxEventRows, dayMaxEvents, expandRows } = props;\n            let limitViaBalanced = dayMaxEvents === true || dayMaxEventRows === true;\n            // if rows can't expand to fill fixed height, can't do balanced-height event limit\n            // TODO: best place to normalize these options?\n            if (limitViaBalanced && !expandRows) {\n                limitViaBalanced = false;\n                dayMaxEventRows = null;\n                dayMaxEvents = null;\n            }\n            let classNames = [\n                'fc-daygrid-body',\n                limitViaBalanced ? 'fc-daygrid-body-balanced' : 'fc-daygrid-body-unbalanced',\n                expandRows ? '' : 'fc-daygrid-body-natural'\n            ];\n            return y(\"div\", {\n                ref: this.elRef,\n                className: classNames.join(' '),\n                style: {\n                    // these props are important to give this wrapper correct dimensions for interactions\n                    // TODO: if we set it here, can we avoid giving to inner tables?\n                    width: props.clientWidth,\n                    minWidth: props.tableMinWidth\n                }\n            }, y(\"table\", {\n                role: \"presentation\",\n                className: \"fc-scrollgrid-sync-table\",\n                style: {\n                    width: props.clientWidth,\n                    minWidth: props.tableMinWidth,\n                    height: expandRows ? props.clientHeight : ''\n                }\n            }, props.colGroupNode, y(\"tbody\", {\n                role: \"presentation\"\n            }, y(TableRows, {\n                dateProfile: props.dateProfile,\n                cells: props.cells,\n                renderRowIntro: props.renderRowIntro,\n                showWeekNumbers: props.showWeekNumbers,\n                clientWidth: props.clientWidth,\n                clientHeight: props.clientHeight,\n                businessHourSegs: props.businessHourSegs,\n                bgEventSegs: props.bgEventSegs,\n                fgEventSegs: props.fgEventSegs,\n                dateSelectionSegs: props.dateSelectionSegs,\n                eventSelection: props.eventSelection,\n                eventDrag: props.eventDrag,\n                eventResize: props.eventResize,\n                dayMaxEvents: dayMaxEvents,\n                dayMaxEventRows: dayMaxEventRows,\n                forPrint: props.forPrint,\n                isHitComboAllowed: props.isHitComboAllowed\n            }))));\n        }\n        componentDidMount() {\n            this.requestScrollReset();\n        }\n        componentDidUpdate(prevProps) {\n            if (prevProps.dateProfile !== this.props.dateProfile) {\n                this.requestScrollReset();\n            } else {\n                this.flushScrollReset();\n            }\n        }\n        requestScrollReset() {\n            this.needsScrollReset = true;\n            this.flushScrollReset();\n        }\n        flushScrollReset() {\n            if (this.needsScrollReset && this.props.clientWidth // sizes computed?\n            ) {\n                const subjectEl = getScrollSubjectEl(this.elRef.current, this.props.dateProfile);\n                if (subjectEl) {\n                    const originEl = subjectEl.closest('.fc-daygrid-body');\n                    const scrollEl = originEl.closest('.fc-scroller');\n                    const scrollTop = subjectEl.getBoundingClientRect().top - originEl.getBoundingClientRect().top;\n                    scrollEl.scrollTop = scrollTop ? scrollTop + 1 : 0; // overcome border\n                }\n                this.needsScrollReset = false;\n            }\n        }\n    }\n    function getScrollSubjectEl(containerEl, dateProfile) {\n        let el;\n        if (dateProfile.currentRangeUnit.match(/year|month/)) {\n            el = containerEl.querySelector(`[data-date=\"${formatIsoMonthStr(dateProfile.currentDate)}-01\"]`);\n        // even if view is month-based, first-of-month might be hidden...\n        }\n        if (!el) {\n            el = containerEl.querySelector(`[data-date=\"${formatDayString(dateProfile.currentDate)}\"]`);\n        // could still be hidden if an interior-view hidden day\n        }\n        return el;\n    }\n    class DayTableSlicer extends Slicer {\n        constructor(){\n            super(...arguments);\n            this.forceDayIfListItem = true;\n        }\n        sliceRange(dateRange, dayTableModel) {\n            return dayTableModel.sliceRange(dateRange);\n        }\n    }\n    class DayTable extends DateComponent {\n        constructor(){\n            super(...arguments);\n            this.slicer = new DayTableSlicer();\n            this.tableRef = d();\n        }\n        render() {\n            let { props, context } = this;\n            return y(Table, Object.assign({\n                ref: this.tableRef\n            }, this.slicer.sliceProps(props, props.dateProfile, props.nextDayThreshold, context, props.dayTableModel), {\n                dateProfile: props.dateProfile,\n                cells: props.dayTableModel.cells,\n                colGroupNode: props.colGroupNode,\n                tableMinWidth: props.tableMinWidth,\n                renderRowIntro: props.renderRowIntro,\n                dayMaxEvents: props.dayMaxEvents,\n                dayMaxEventRows: props.dayMaxEventRows,\n                showWeekNumbers: props.showWeekNumbers,\n                expandRows: props.expandRows,\n                headerAlignElRef: props.headerAlignElRef,\n                clientWidth: props.clientWidth,\n                clientHeight: props.clientHeight,\n                forPrint: props.forPrint\n            }));\n        }\n    }\n    class TableDateProfileGenerator extends DateProfileGenerator {\n        // Computes the date range that will be rendered\n        buildRenderRange(currentRange, currentRangeUnit, isRangeAllDay) {\n            let renderRange = super.buildRenderRange(currentRange, currentRangeUnit, isRangeAllDay);\n            let { props } = this;\n            return buildDayTableRenderRange({\n                currentRange: renderRange,\n                snapToWeek: /^(year|month)$/.test(currentRangeUnit),\n                fixedWeekCount: props.fixedWeekCount,\n                dateEnv: props.dateEnv\n            });\n        }\n    }\n    function buildDayTableRenderRange(props) {\n        let { dateEnv, currentRange } = props;\n        let { start, end } = currentRange;\n        let endOfWeek;\n        // year and month views should be aligned with weeks. this is already done for week\n        if (props.snapToWeek) {\n            start = dateEnv.startOfWeek(start);\n            // make end-of-week if not already\n            endOfWeek = dateEnv.startOfWeek(end);\n            if (endOfWeek.valueOf() !== end.valueOf()) {\n                end = addWeeks(endOfWeek, 1);\n            }\n        }\n        // ensure 6 weeks\n        if (props.fixedWeekCount) {\n            // TODO: instead of these date-math gymnastics (for multimonth view),\n            // compute dateprofiles of all months, then use start of first and end of last.\n            let lastMonthRenderStart = dateEnv.startOfWeek(dateEnv.startOfMonth(addDays(currentRange.end, -1)));\n            let rowCnt = Math.ceil(diffWeeks(lastMonthRenderStart, end));\n            end = addWeeks(end, 6 - rowCnt);\n        }\n        return {\n            start,\n            end\n        };\n    }\n    /* An abstract class for the daygrid views, as well as month view. Renders one or more rows of day cells.\r\n    ----------------------------------------------------------------------------------------------------------------------*/ // It is a manager for a Table subcomponent, which does most of the heavy lifting.\n    // It is responsible for managing width/height.\n    class TableView extends DateComponent {\n        constructor(){\n            super(...arguments);\n            this.headerElRef = d();\n        }\n        renderSimpleLayout(headerRowContent, bodyContent) {\n            let { props, context } = this;\n            let sections = [];\n            let stickyHeaderDates = getStickyHeaderDates(context.options);\n            if (headerRowContent) {\n                sections.push({\n                    type: 'header',\n                    key: 'header',\n                    isSticky: stickyHeaderDates,\n                    chunk: {\n                        elRef: this.headerElRef,\n                        tableClassName: 'fc-col-header',\n                        rowContent: headerRowContent\n                    }\n                });\n            }\n            sections.push({\n                type: 'body',\n                key: 'body',\n                liquid: true,\n                chunk: {\n                    content: bodyContent\n                }\n            });\n            return y(ViewContainer, {\n                elClasses: [\n                    'fc-daygrid'\n                ],\n                viewSpec: context.viewSpec\n            }, y(SimpleScrollGrid, {\n                liquid: !props.isHeightAuto && !props.forPrint,\n                collapsibleWidth: props.forPrint,\n                cols: [],\n                sections: sections\n            }));\n        }\n        renderHScrollLayout(headerRowContent, bodyContent, colCnt, dayMinWidth) {\n            let ScrollGrid = this.context.pluginHooks.scrollGridImpl;\n            if (!ScrollGrid) {\n                throw new Error('No ScrollGrid implementation');\n            }\n            let { props, context } = this;\n            let stickyHeaderDates = !props.forPrint && getStickyHeaderDates(context.options);\n            let stickyFooterScrollbar = !props.forPrint && getStickyFooterScrollbar(context.options);\n            let sections = [];\n            if (headerRowContent) {\n                sections.push({\n                    type: 'header',\n                    key: 'header',\n                    isSticky: stickyHeaderDates,\n                    chunks: [\n                        {\n                            key: 'main',\n                            elRef: this.headerElRef,\n                            tableClassName: 'fc-col-header',\n                            rowContent: headerRowContent\n                        }\n                    ]\n                });\n            }\n            sections.push({\n                type: 'body',\n                key: 'body',\n                liquid: true,\n                chunks: [\n                    {\n                        key: 'main',\n                        content: bodyContent\n                    }\n                ]\n            });\n            if (stickyFooterScrollbar) {\n                sections.push({\n                    type: 'footer',\n                    key: 'footer',\n                    isSticky: true,\n                    chunks: [\n                        {\n                            key: 'main',\n                            content: renderScrollShim\n                        }\n                    ]\n                });\n            }\n            return y(ViewContainer, {\n                elClasses: [\n                    'fc-daygrid'\n                ],\n                viewSpec: context.viewSpec\n            }, y(ScrollGrid, {\n                liquid: !props.isHeightAuto && !props.forPrint,\n                forPrint: props.forPrint,\n                collapsibleWidth: props.forPrint,\n                colGroups: [\n                    {\n                        cols: [\n                            {\n                                span: colCnt,\n                                minWidth: dayMinWidth\n                            }\n                        ]\n                    }\n                ],\n                sections: sections\n            }));\n        }\n    }\n    class DayTableView extends TableView {\n        constructor(){\n            super(...arguments);\n            this.buildDayTableModel = memoize(buildDayTableModel);\n            this.headerRef = d();\n            this.tableRef = d();\n        // can't override any lifecycle methods from parent\n        }\n        render() {\n            let { options, dateProfileGenerator } = this.context;\n            let { props } = this;\n            let dayTableModel = this.buildDayTableModel(props.dateProfile, dateProfileGenerator);\n            let headerContent = options.dayHeaders && y(DayHeader, {\n                ref: this.headerRef,\n                dateProfile: props.dateProfile,\n                dates: dayTableModel.headerDates,\n                datesRepDistinctDays: dayTableModel.rowCnt === 1\n            });\n            let bodyContent = (contentArg)=>y(DayTable, {\n                    ref: this.tableRef,\n                    dateProfile: props.dateProfile,\n                    dayTableModel: dayTableModel,\n                    businessHours: props.businessHours,\n                    dateSelection: props.dateSelection,\n                    eventStore: props.eventStore,\n                    eventUiBases: props.eventUiBases,\n                    eventSelection: props.eventSelection,\n                    eventDrag: props.eventDrag,\n                    eventResize: props.eventResize,\n                    nextDayThreshold: options.nextDayThreshold,\n                    colGroupNode: contentArg.tableColGroupNode,\n                    tableMinWidth: contentArg.tableMinWidth,\n                    dayMaxEvents: options.dayMaxEvents,\n                    dayMaxEventRows: options.dayMaxEventRows,\n                    showWeekNumbers: options.weekNumbers,\n                    expandRows: !props.isHeightAuto,\n                    headerAlignElRef: this.headerElRef,\n                    clientWidth: contentArg.clientWidth,\n                    clientHeight: contentArg.clientHeight,\n                    forPrint: props.forPrint\n                });\n            return options.dayMinWidth ? this.renderHScrollLayout(headerContent, bodyContent, dayTableModel.colCnt, options.dayMinWidth) : this.renderSimpleLayout(headerContent, bodyContent);\n        }\n    }\n    function buildDayTableModel(dateProfile, dateProfileGenerator) {\n        let daySeries = new DaySeriesModel(dateProfile.renderRange, dateProfileGenerator);\n        return new DayTableModel(daySeries, /year|month|week/.test(dateProfile.currentRangeUnit));\n    }\n    var index$3 = createPlugin({\n        name: '@fullcalendar/daygrid',\n        initialView: 'dayGridMonth',\n        views: {\n            dayGrid: {\n                component: DayTableView,\n                dateProfileGeneratorClass: TableDateProfileGenerator\n            },\n            dayGridDay: {\n                type: 'dayGrid',\n                duration: {\n                    days: 1\n                }\n            },\n            dayGridWeek: {\n                type: 'dayGrid',\n                duration: {\n                    weeks: 1\n                }\n            },\n            dayGridMonth: {\n                type: 'dayGrid',\n                duration: {\n                    months: 1\n                },\n                fixedWeekCount: true\n            },\n            dayGridYear: {\n                type: 'dayGrid',\n                duration: {\n                    years: 1\n                }\n            }\n        }\n    });\n    var css_248z$2 = \".fc-v-event{background-color:var(--fc-event-bg-color);border:1px solid var(--fc-event-border-color);display:block}.fc-v-event .fc-event-main{color:var(--fc-event-text-color);height:100%}.fc-v-event .fc-event-main-frame{display:flex;flex-direction:column;height:100%}.fc-v-event .fc-event-time{flex-grow:0;flex-shrink:0;max-height:100%;overflow:hidden}.fc-v-event .fc-event-title-container{flex-grow:1;flex-shrink:1;min-height:0}.fc-v-event .fc-event-title{bottom:0;max-height:100%;overflow:hidden;top:0}.fc-v-event:not(.fc-event-start){border-top-left-radius:0;border-top-right-radius:0;border-top-width:0}.fc-v-event:not(.fc-event-end){border-bottom-left-radius:0;border-bottom-right-radius:0;border-bottom-width:0}.fc-v-event.fc-event-selected:before{left:-10px;right:-10px}.fc-v-event .fc-event-resizer-start{cursor:n-resize}.fc-v-event .fc-event-resizer-end{cursor:s-resize}.fc-v-event:not(.fc-event-selected) .fc-event-resizer{height:var(--fc-event-resizer-thickness);left:0;right:0}.fc-v-event:not(.fc-event-selected) .fc-event-resizer-start{top:calc(var(--fc-event-resizer-thickness)/-2)}.fc-v-event:not(.fc-event-selected) .fc-event-resizer-end{bottom:calc(var(--fc-event-resizer-thickness)/-2)}.fc-v-event.fc-event-selected .fc-event-resizer{left:50%;margin-left:calc(var(--fc-event-resizer-dot-total-width)/-2)}.fc-v-event.fc-event-selected .fc-event-resizer-start{top:calc(var(--fc-event-resizer-dot-total-width)/-2)}.fc-v-event.fc-event-selected .fc-event-resizer-end{bottom:calc(var(--fc-event-resizer-dot-total-width)/-2)}.fc .fc-timegrid .fc-daygrid-body{z-index:2}.fc .fc-timegrid-divider{padding:0 0 2px}.fc .fc-timegrid-body{min-height:100%;position:relative;z-index:1}.fc .fc-timegrid-axis-chunk{position:relative}.fc .fc-timegrid-axis-chunk>table,.fc .fc-timegrid-slots{position:relative;z-index:1}.fc .fc-timegrid-slot{border-bottom:0;height:1.5em}.fc .fc-timegrid-slot:empty:before{content:\\\"\\\\00a0\\\"}.fc .fc-timegrid-slot-minor{border-top-style:dotted}.fc .fc-timegrid-slot-label-cushion{display:inline-block;white-space:nowrap}.fc .fc-timegrid-slot-label{vertical-align:middle}.fc .fc-timegrid-axis-cushion,.fc .fc-timegrid-slot-label-cushion{padding:0 4px}.fc .fc-timegrid-axis-frame-liquid{height:100%}.fc .fc-timegrid-axis-frame{align-items:center;display:flex;justify-content:flex-end;overflow:hidden}.fc .fc-timegrid-axis-cushion{flex-shrink:0;max-width:60px}.fc-direction-ltr .fc-timegrid-slot-label-frame{text-align:right}.fc-direction-rtl .fc-timegrid-slot-label-frame{text-align:left}.fc-liquid-hack .fc-timegrid-axis-frame-liquid{bottom:0;height:auto;left:0;position:absolute;right:0;top:0}.fc .fc-timegrid-col.fc-day-today{background-color:var(--fc-today-bg-color)}.fc .fc-timegrid-col-frame{min-height:100%;position:relative}.fc-media-screen.fc-liquid-hack .fc-timegrid-col-frame{bottom:0;height:auto;left:0;position:absolute;right:0;top:0}.fc-media-screen .fc-timegrid-cols{bottom:0;left:0;position:absolute;right:0;top:0}.fc-media-screen .fc-timegrid-cols>table{height:100%}.fc-media-screen .fc-timegrid-col-bg,.fc-media-screen .fc-timegrid-col-events,.fc-media-screen .fc-timegrid-now-indicator-container{left:0;position:absolute;right:0;top:0}.fc .fc-timegrid-col-bg{z-index:2}.fc .fc-timegrid-col-bg .fc-non-business{z-index:1}.fc .fc-timegrid-col-bg .fc-bg-event{z-index:2}.fc .fc-timegrid-col-bg .fc-highlight{z-index:3}.fc .fc-timegrid-bg-harness{left:0;position:absolute;right:0}.fc .fc-timegrid-col-events{z-index:3}.fc .fc-timegrid-now-indicator-container{bottom:0;overflow:hidden}.fc-direction-ltr .fc-timegrid-col-events{margin:0 2.5% 0 2px}.fc-direction-rtl .fc-timegrid-col-events{margin:0 2px 0 2.5%}.fc-timegrid-event-harness{position:absolute}.fc-timegrid-event-harness>.fc-timegrid-event{bottom:0;left:0;position:absolute;right:0;top:0}.fc-timegrid-event-harness-inset .fc-timegrid-event,.fc-timegrid-event.fc-event-mirror,.fc-timegrid-more-link{box-shadow:0 0 0 1px var(--fc-page-bg-color)}.fc-timegrid-event,.fc-timegrid-more-link{border-radius:3px;font-size:var(--fc-small-font-size)}.fc-timegrid-event{margin-bottom:1px}.fc-timegrid-event .fc-event-main{padding:1px 1px 0}.fc-timegrid-event .fc-event-time{font-size:var(--fc-small-font-size);margin-bottom:1px;white-space:nowrap}.fc-timegrid-event-short .fc-event-main-frame{flex-direction:row;overflow:hidden}.fc-timegrid-event-short .fc-event-time:after{content:\\\"\\\\00a0-\\\\00a0\\\"}.fc-timegrid-event-short .fc-event-title{font-size:var(--fc-small-font-size)}.fc-timegrid-more-link{background:var(--fc-more-link-bg-color);color:var(--fc-more-link-text-color);cursor:pointer;margin-bottom:1px;position:absolute;z-index:9999}.fc-timegrid-more-link-inner{padding:3px 2px;top:0}.fc-direction-ltr .fc-timegrid-more-link{right:0}.fc-direction-rtl .fc-timegrid-more-link{left:0}.fc .fc-timegrid-now-indicator-line{border-color:var(--fc-now-indicator-color);border-style:solid;border-width:1px 0 0;left:0;position:absolute;right:0;z-index:4}.fc .fc-timegrid-now-indicator-arrow{border-color:var(--fc-now-indicator-color);border-style:solid;margin-top:-5px;position:absolute;z-index:4}.fc-direction-ltr .fc-timegrid-now-indicator-arrow{border-bottom-color:transparent;border-top-color:transparent;border-width:5px 0 5px 6px;left:0}.fc-direction-rtl .fc-timegrid-now-indicator-arrow{border-bottom-color:transparent;border-top-color:transparent;border-width:5px 6px 5px 0;right:0}\";\n    injectStyles(css_248z$2);\n    class AllDaySplitter extends Splitter {\n        getKeyInfo() {\n            return {\n                allDay: {},\n                timed: {}\n            };\n        }\n        getKeysForDateSpan(dateSpan) {\n            if (dateSpan.allDay) {\n                return [\n                    'allDay'\n                ];\n            }\n            return [\n                'timed'\n            ];\n        }\n        getKeysForEventDef(eventDef) {\n            if (!eventDef.allDay) {\n                return [\n                    'timed'\n                ];\n            }\n            if (hasBgRendering(eventDef)) {\n                return [\n                    'timed',\n                    'allDay'\n                ];\n            }\n            return [\n                'allDay'\n            ];\n        }\n    }\n    const DEFAULT_SLAT_LABEL_FORMAT = createFormatter({\n        hour: 'numeric',\n        minute: '2-digit',\n        omitZeroMinute: true,\n        meridiem: 'short'\n    });\n    function TimeColsAxisCell(props) {\n        let classNames = [\n            'fc-timegrid-slot',\n            'fc-timegrid-slot-label',\n            props.isLabeled ? 'fc-scrollgrid-shrink' : 'fc-timegrid-slot-minor'\n        ];\n        return y(ViewContextType.Consumer, null, (context)=>{\n            if (!props.isLabeled) {\n                return y(\"td\", {\n                    className: classNames.join(' '),\n                    \"data-time\": props.isoTimeStr\n                });\n            }\n            let { dateEnv, options, viewApi } = context;\n            let labelFormat = options.slotLabelFormat == null ? DEFAULT_SLAT_LABEL_FORMAT : Array.isArray(options.slotLabelFormat) ? createFormatter(options.slotLabelFormat[0]) : createFormatter(options.slotLabelFormat);\n            let renderProps = {\n                level: 0,\n                time: props.time,\n                date: dateEnv.toDate(props.date),\n                view: viewApi,\n                text: dateEnv.format(props.date, labelFormat)\n            };\n            return y(ContentContainer, {\n                elTag: \"td\",\n                elClasses: classNames,\n                elAttrs: {\n                    'data-time': props.isoTimeStr\n                },\n                renderProps: renderProps,\n                generatorName: \"slotLabelContent\",\n                customGenerator: options.slotLabelContent,\n                defaultGenerator: renderInnerContent$1,\n                classNameGenerator: options.slotLabelClassNames,\n                didMount: options.slotLabelDidMount,\n                willUnmount: options.slotLabelWillUnmount\n            }, (InnerContent)=>y(\"div\", {\n                    className: \"fc-timegrid-slot-label-frame fc-scrollgrid-shrink-frame\"\n                }, y(InnerContent, {\n                    elTag: \"div\",\n                    elClasses: [\n                        'fc-timegrid-slot-label-cushion',\n                        'fc-scrollgrid-shrink-cushion'\n                    ]\n                })));\n        });\n    }\n    function renderInnerContent$1(props) {\n        return props.text;\n    }\n    class TimeBodyAxis extends BaseComponent {\n        render() {\n            return this.props.slatMetas.map((slatMeta)=>y(\"tr\", {\n                    key: slatMeta.key\n                }, y(TimeColsAxisCell, Object.assign({}, slatMeta))));\n        }\n    }\n    const DEFAULT_WEEK_NUM_FORMAT = createFormatter({\n        week: 'short'\n    });\n    const AUTO_ALL_DAY_MAX_EVENT_ROWS = 5;\n    class TimeColsView extends DateComponent {\n        constructor(){\n            super(...arguments);\n            this.allDaySplitter = new AllDaySplitter(); // for use by subclasses\n            this.headerElRef = d();\n            this.rootElRef = d();\n            this.scrollerElRef = d();\n            this.state = {\n                slatCoords: null\n            };\n            this.handleScrollTopRequest = (scrollTop)=>{\n                let scrollerEl = this.scrollerElRef.current;\n                if (scrollerEl) {\n                    scrollerEl.scrollTop = scrollTop;\n                }\n            };\n            /* Header Render Methods\r\n            ------------------------------------------------------------------------------------------------------------------*/ this.renderHeadAxis = (rowKey, frameHeight = '')=>{\n                let { options } = this.context;\n                let { dateProfile } = this.props;\n                let range = dateProfile.renderRange;\n                let dayCnt = diffDays(range.start, range.end);\n                // only do in day views (to avoid doing in week views that dont need it)\n                let navLinkAttrs = dayCnt === 1 ? buildNavLinkAttrs(this.context, range.start, 'week') : {};\n                if (options.weekNumbers && rowKey === 'day') {\n                    return y(WeekNumberContainer, {\n                        elTag: \"th\",\n                        elClasses: [\n                            'fc-timegrid-axis',\n                            'fc-scrollgrid-shrink'\n                        ],\n                        elAttrs: {\n                            'aria-hidden': true\n                        },\n                        date: range.start,\n                        defaultFormat: DEFAULT_WEEK_NUM_FORMAT\n                    }, (InnerContent)=>y(\"div\", {\n                            className: [\n                                'fc-timegrid-axis-frame',\n                                'fc-scrollgrid-shrink-frame',\n                                'fc-timegrid-axis-frame-liquid'\n                            ].join(' '),\n                            style: {\n                                height: frameHeight\n                            }\n                        }, y(InnerContent, {\n                            elTag: \"a\",\n                            elClasses: [\n                                'fc-timegrid-axis-cushion',\n                                'fc-scrollgrid-shrink-cushion',\n                                'fc-scrollgrid-sync-inner'\n                            ],\n                            elAttrs: navLinkAttrs\n                        })));\n                }\n                return y(\"th\", {\n                    \"aria-hidden\": true,\n                    className: \"fc-timegrid-axis\"\n                }, y(\"div\", {\n                    className: \"fc-timegrid-axis-frame\",\n                    style: {\n                        height: frameHeight\n                    }\n                }));\n            };\n            /* Table Component Render Methods\r\n            ------------------------------------------------------------------------------------------------------------------*/ // only a one-way height sync. we don't send the axis inner-content height to the DayGrid,\n            // but DayGrid still needs to have classNames on inner elements in order to measure.\n            this.renderTableRowAxis = (rowHeight)=>{\n                let { options, viewApi } = this.context;\n                let renderProps = {\n                    text: options.allDayText,\n                    view: viewApi\n                };\n                return(// TODO: make reusable hook. used in list view too\n                y(ContentContainer, {\n                    elTag: \"td\",\n                    elClasses: [\n                        'fc-timegrid-axis',\n                        'fc-scrollgrid-shrink'\n                    ],\n                    elAttrs: {\n                        'aria-hidden': true\n                    },\n                    renderProps: renderProps,\n                    generatorName: \"allDayContent\",\n                    customGenerator: options.allDayContent,\n                    defaultGenerator: renderAllDayInner$1,\n                    classNameGenerator: options.allDayClassNames,\n                    didMount: options.allDayDidMount,\n                    willUnmount: options.allDayWillUnmount\n                }, (InnerContent)=>y(\"div\", {\n                        className: [\n                            'fc-timegrid-axis-frame',\n                            'fc-scrollgrid-shrink-frame',\n                            rowHeight == null ? ' fc-timegrid-axis-frame-liquid' : ''\n                        ].join(' '),\n                        style: {\n                            height: rowHeight\n                        }\n                    }, y(InnerContent, {\n                        elTag: \"span\",\n                        elClasses: [\n                            'fc-timegrid-axis-cushion',\n                            'fc-scrollgrid-shrink-cushion',\n                            'fc-scrollgrid-sync-inner'\n                        ]\n                    }))));\n            };\n            this.handleSlatCoords = (slatCoords)=>{\n                this.setState({\n                    slatCoords\n                });\n            };\n        }\n        // rendering\n        // ----------------------------------------------------------------------------------------------------\n        renderSimpleLayout(headerRowContent, allDayContent, timeContent) {\n            let { context, props } = this;\n            let sections = [];\n            let stickyHeaderDates = getStickyHeaderDates(context.options);\n            if (headerRowContent) {\n                sections.push({\n                    type: 'header',\n                    key: 'header',\n                    isSticky: stickyHeaderDates,\n                    chunk: {\n                        elRef: this.headerElRef,\n                        tableClassName: 'fc-col-header',\n                        rowContent: headerRowContent\n                    }\n                });\n            }\n            if (allDayContent) {\n                sections.push({\n                    type: 'body',\n                    key: 'all-day',\n                    chunk: {\n                        content: allDayContent\n                    }\n                });\n                sections.push({\n                    type: 'body',\n                    key: 'all-day-divider',\n                    outerContent: y(\"tr\", {\n                        role: \"presentation\",\n                        className: \"fc-scrollgrid-section\"\n                    }, y(\"td\", {\n                        className: 'fc-timegrid-divider ' + context.theme.getClass('tableCellShaded')\n                    }))\n                });\n            }\n            sections.push({\n                type: 'body',\n                key: 'body',\n                liquid: true,\n                expandRows: Boolean(context.options.expandRows),\n                chunk: {\n                    scrollerElRef: this.scrollerElRef,\n                    content: timeContent\n                }\n            });\n            return y(ViewContainer, {\n                elRef: this.rootElRef,\n                elClasses: [\n                    'fc-timegrid'\n                ],\n                viewSpec: context.viewSpec\n            }, y(SimpleScrollGrid, {\n                liquid: !props.isHeightAuto && !props.forPrint,\n                collapsibleWidth: props.forPrint,\n                cols: [\n                    {\n                        width: 'shrink'\n                    }\n                ],\n                sections: sections\n            }));\n        }\n        renderHScrollLayout(headerRowContent, allDayContent, timeContent, colCnt, dayMinWidth, slatMetas, slatCoords) {\n            let ScrollGrid = this.context.pluginHooks.scrollGridImpl;\n            if (!ScrollGrid) {\n                throw new Error('No ScrollGrid implementation');\n            }\n            let { context, props } = this;\n            let stickyHeaderDates = !props.forPrint && getStickyHeaderDates(context.options);\n            let stickyFooterScrollbar = !props.forPrint && getStickyFooterScrollbar(context.options);\n            let sections = [];\n            if (headerRowContent) {\n                sections.push({\n                    type: 'header',\n                    key: 'header',\n                    isSticky: stickyHeaderDates,\n                    syncRowHeights: true,\n                    chunks: [\n                        {\n                            key: 'axis',\n                            rowContent: (arg)=>y(\"tr\", {\n                                    role: \"presentation\"\n                                }, this.renderHeadAxis('day', arg.rowSyncHeights[0]))\n                        },\n                        {\n                            key: 'cols',\n                            elRef: this.headerElRef,\n                            tableClassName: 'fc-col-header',\n                            rowContent: headerRowContent\n                        }\n                    ]\n                });\n            }\n            if (allDayContent) {\n                sections.push({\n                    type: 'body',\n                    key: 'all-day',\n                    syncRowHeights: true,\n                    chunks: [\n                        {\n                            key: 'axis',\n                            rowContent: (contentArg)=>y(\"tr\", {\n                                    role: \"presentation\"\n                                }, this.renderTableRowAxis(contentArg.rowSyncHeights[0]))\n                        },\n                        {\n                            key: 'cols',\n                            content: allDayContent\n                        }\n                    ]\n                });\n                sections.push({\n                    key: 'all-day-divider',\n                    type: 'body',\n                    outerContent: y(\"tr\", {\n                        role: \"presentation\",\n                        className: \"fc-scrollgrid-section\"\n                    }, y(\"td\", {\n                        colSpan: 2,\n                        className: 'fc-timegrid-divider ' + context.theme.getClass('tableCellShaded')\n                    }))\n                });\n            }\n            let isNowIndicator = context.options.nowIndicator;\n            sections.push({\n                type: 'body',\n                key: 'body',\n                liquid: true,\n                expandRows: Boolean(context.options.expandRows),\n                chunks: [\n                    {\n                        key: 'axis',\n                        content: (arg)=>// TODO: make this now-indicator arrow more DRY with TimeColsContent\n                            y(\"div\", {\n                                className: \"fc-timegrid-axis-chunk\"\n                            }, y(\"table\", {\n                                \"aria-hidden\": true,\n                                style: {\n                                    height: arg.expandRows ? arg.clientHeight : ''\n                                }\n                            }, arg.tableColGroupNode, y(\"tbody\", null, y(TimeBodyAxis, {\n                                slatMetas: slatMetas\n                            }))), y(\"div\", {\n                                className: \"fc-timegrid-now-indicator-container\"\n                            }, y(NowTimer, {\n                                unit: isNowIndicator ? 'minute' : 'day' /* hacky */ \n                            }, (nowDate)=>{\n                                let nowIndicatorTop = isNowIndicator && slatCoords && slatCoords.safeComputeTop(nowDate); // might return void\n                                if (typeof nowIndicatorTop === 'number') {\n                                    return y(NowIndicatorContainer, {\n                                        elClasses: [\n                                            'fc-timegrid-now-indicator-arrow'\n                                        ],\n                                        elStyle: {\n                                            top: nowIndicatorTop\n                                        },\n                                        isAxis: true,\n                                        date: nowDate\n                                    });\n                                }\n                                return null;\n                            })))\n                    },\n                    {\n                        key: 'cols',\n                        scrollerElRef: this.scrollerElRef,\n                        content: timeContent\n                    }\n                ]\n            });\n            if (stickyFooterScrollbar) {\n                sections.push({\n                    key: 'footer',\n                    type: 'footer',\n                    isSticky: true,\n                    chunks: [\n                        {\n                            key: 'axis',\n                            content: renderScrollShim\n                        },\n                        {\n                            key: 'cols',\n                            content: renderScrollShim\n                        }\n                    ]\n                });\n            }\n            return y(ViewContainer, {\n                elRef: this.rootElRef,\n                elClasses: [\n                    'fc-timegrid'\n                ],\n                viewSpec: context.viewSpec\n            }, y(ScrollGrid, {\n                liquid: !props.isHeightAuto && !props.forPrint,\n                forPrint: props.forPrint,\n                collapsibleWidth: false,\n                colGroups: [\n                    {\n                        width: 'shrink',\n                        cols: [\n                            {\n                                width: 'shrink'\n                            }\n                        ]\n                    },\n                    {\n                        cols: [\n                            {\n                                span: colCnt,\n                                minWidth: dayMinWidth\n                            }\n                        ]\n                    }\n                ],\n                sections: sections\n            }));\n        }\n        /* Dimensions\r\n        ------------------------------------------------------------------------------------------------------------------*/ getAllDayMaxEventProps() {\n            let { dayMaxEvents, dayMaxEventRows } = this.context.options;\n            if (dayMaxEvents === true || dayMaxEventRows === true) {\n                dayMaxEvents = undefined;\n                dayMaxEventRows = AUTO_ALL_DAY_MAX_EVENT_ROWS; // make sure \"auto\" goes to a real number\n            }\n            return {\n                dayMaxEvents,\n                dayMaxEventRows\n            };\n        }\n    }\n    function renderAllDayInner$1(renderProps) {\n        return renderProps.text;\n    }\n    class TimeColsSlatsCoords {\n        constructor(positions, dateProfile, slotDuration){\n            this.positions = positions;\n            this.dateProfile = dateProfile;\n            this.slotDuration = slotDuration;\n        }\n        safeComputeTop(date) {\n            let { dateProfile } = this;\n            if (rangeContainsMarker(dateProfile.currentRange, date)) {\n                let startOfDayDate = startOfDay(date);\n                let timeMs = date.valueOf() - startOfDayDate.valueOf();\n                if (timeMs >= asRoughMs(dateProfile.slotMinTime) && timeMs < asRoughMs(dateProfile.slotMaxTime)) {\n                    return this.computeTimeTop(createDuration(timeMs));\n                }\n            }\n            return null;\n        }\n        // Computes the top coordinate, relative to the bounds of the grid, of the given date.\n        // A `startOfDayDate` must be given for avoiding ambiguity over how to treat midnight.\n        computeDateTop(when, startOfDayDate) {\n            if (!startOfDayDate) {\n                startOfDayDate = startOfDay(when);\n            }\n            return this.computeTimeTop(createDuration(when.valueOf() - startOfDayDate.valueOf()));\n        }\n        // Computes the top coordinate, relative to the bounds of the grid, of the given time (a Duration).\n        // This is a makeshify way to compute the time-top. Assumes all slatMetas dates are uniform.\n        // Eventually allow computation with arbirary slat dates.\n        computeTimeTop(duration) {\n            let { positions, dateProfile } = this;\n            let len = positions.els.length;\n            // floating-point value of # of slots covered\n            let slatCoverage = (duration.milliseconds - asRoughMs(dateProfile.slotMinTime)) / asRoughMs(this.slotDuration);\n            let slatIndex;\n            let slatRemainder;\n            // compute a floating-point number for how many slats should be progressed through.\n            // from 0 to number of slats (inclusive)\n            // constrained because slotMinTime/slotMaxTime might be customized.\n            slatCoverage = Math.max(0, slatCoverage);\n            slatCoverage = Math.min(len, slatCoverage);\n            // an integer index of the furthest whole slat\n            // from 0 to number slats (*exclusive*, so len-1)\n            slatIndex = Math.floor(slatCoverage);\n            slatIndex = Math.min(slatIndex, len - 1);\n            // how much further through the slatIndex slat (from 0.0-1.0) must be covered in addition.\n            // could be 1.0 if slatCoverage is covering *all* the slots\n            slatRemainder = slatCoverage - slatIndex;\n            return positions.tops[slatIndex] + positions.getHeight(slatIndex) * slatRemainder;\n        }\n    }\n    class TimeColsSlatsBody extends BaseComponent {\n        render() {\n            let { props, context } = this;\n            let { options } = context;\n            let { slatElRefs } = props;\n            return y(\"tbody\", null, props.slatMetas.map((slatMeta, i)=>{\n                let renderProps = {\n                    time: slatMeta.time,\n                    date: context.dateEnv.toDate(slatMeta.date),\n                    view: context.viewApi\n                };\n                return y(\"tr\", {\n                    key: slatMeta.key,\n                    ref: slatElRefs.createRef(slatMeta.key)\n                }, props.axis && y(TimeColsAxisCell, Object.assign({}, slatMeta)), y(ContentContainer, {\n                    elTag: \"td\",\n                    elClasses: [\n                        'fc-timegrid-slot',\n                        'fc-timegrid-slot-lane',\n                        !slatMeta.isLabeled && 'fc-timegrid-slot-minor'\n                    ],\n                    elAttrs: {\n                        'data-time': slatMeta.isoTimeStr\n                    },\n                    renderProps: renderProps,\n                    generatorName: \"slotLaneContent\",\n                    customGenerator: options.slotLaneContent,\n                    classNameGenerator: options.slotLaneClassNames,\n                    didMount: options.slotLaneDidMount,\n                    willUnmount: options.slotLaneWillUnmount\n                }));\n            }));\n        }\n    }\n    /*\r\n    for the horizontal \"slats\" that run width-wise. Has a time axis on a side. Depends on RTL.\r\n    */ class TimeColsSlats extends BaseComponent {\n        constructor(){\n            super(...arguments);\n            this.rootElRef = d();\n            this.slatElRefs = new RefMap();\n        }\n        render() {\n            let { props, context } = this;\n            return y(\"div\", {\n                ref: this.rootElRef,\n                className: \"fc-timegrid-slots\"\n            }, y(\"table\", {\n                \"aria-hidden\": true,\n                className: context.theme.getClass('table'),\n                style: {\n                    minWidth: props.tableMinWidth,\n                    width: props.clientWidth,\n                    height: props.minHeight\n                }\n            }, props.tableColGroupNode /* relies on there only being a single <col> for the axis */ , y(TimeColsSlatsBody, {\n                slatElRefs: this.slatElRefs,\n                axis: props.axis,\n                slatMetas: props.slatMetas\n            })));\n        }\n        componentDidMount() {\n            this.updateSizing();\n        }\n        componentDidUpdate() {\n            this.updateSizing();\n        }\n        componentWillUnmount() {\n            if (this.props.onCoords) {\n                this.props.onCoords(null);\n            }\n        }\n        updateSizing() {\n            let { context, props } = this;\n            if (props.onCoords && props.clientWidth !== null // means sizing has stabilized\n            ) {\n                let rootEl = this.rootElRef.current;\n                if (rootEl.offsetHeight) {\n                    props.onCoords(new TimeColsSlatsCoords(new PositionCache(this.rootElRef.current, collectSlatEls(this.slatElRefs.currentMap, props.slatMetas), false, true), this.props.dateProfile, context.options.slotDuration));\n                }\n            }\n        }\n    }\n    function collectSlatEls(elMap, slatMetas) {\n        return slatMetas.map((slatMeta)=>elMap[slatMeta.key]);\n    }\n    function splitSegsByCol(segs, colCnt) {\n        let segsByCol = [];\n        let i;\n        for(i = 0; i < colCnt; i += 1){\n            segsByCol.push([]);\n        }\n        if (segs) {\n            for(i = 0; i < segs.length; i += 1){\n                segsByCol[segs[i].col].push(segs[i]);\n            }\n        }\n        return segsByCol;\n    }\n    function splitInteractionByCol(ui, colCnt) {\n        let byRow = [];\n        if (!ui) {\n            for(let i = 0; i < colCnt; i += 1){\n                byRow[i] = null;\n            }\n        } else {\n            for(let i = 0; i < colCnt; i += 1){\n                byRow[i] = {\n                    affectedInstances: ui.affectedInstances,\n                    isEvent: ui.isEvent,\n                    segs: []\n                };\n            }\n            for (let seg of ui.segs){\n                byRow[seg.col].segs.push(seg);\n            }\n        }\n        return byRow;\n    }\n    class TimeColMoreLink extends BaseComponent {\n        render() {\n            let { props } = this;\n            return y(MoreLinkContainer, {\n                elClasses: [\n                    'fc-timegrid-more-link'\n                ],\n                elStyle: {\n                    top: props.top,\n                    bottom: props.bottom\n                },\n                allDayDate: null,\n                moreCnt: props.hiddenSegs.length,\n                allSegs: props.hiddenSegs,\n                hiddenSegs: props.hiddenSegs,\n                extraDateSpan: props.extraDateSpan,\n                dateProfile: props.dateProfile,\n                todayRange: props.todayRange,\n                popoverContent: ()=>renderPlainFgSegs(props.hiddenSegs, props),\n                defaultGenerator: renderMoreLinkInner,\n                forceTimed: true\n            }, (InnerContent)=>y(InnerContent, {\n                    elTag: \"div\",\n                    elClasses: [\n                        'fc-timegrid-more-link-inner',\n                        'fc-sticky'\n                    ]\n                }));\n        }\n    }\n    function renderMoreLinkInner(props) {\n        return props.shortText;\n    }\n    // segInputs assumed sorted\n    function buildPositioning(segInputs, strictOrder, maxStackCnt) {\n        let hierarchy = new SegHierarchy();\n        if (strictOrder != null) {\n            hierarchy.strictOrder = strictOrder;\n        }\n        if (maxStackCnt != null) {\n            hierarchy.maxStackCnt = maxStackCnt;\n        }\n        let hiddenEntries = hierarchy.addSegs(segInputs);\n        let hiddenGroups = groupIntersectingEntries(hiddenEntries);\n        let web = buildWeb(hierarchy);\n        web = stretchWeb(web, 1); // all levelCoords/thickness will have 0.0-1.0\n        let segRects = webToRects(web);\n        return {\n            segRects,\n            hiddenGroups\n        };\n    }\n    function buildWeb(hierarchy) {\n        const { entriesByLevel } = hierarchy;\n        const buildNode = cacheable((level, lateral)=>level + ':' + lateral, (level, lateral)=>{\n            let siblingRange = findNextLevelSegs(hierarchy, level, lateral);\n            let nextLevelRes = buildNodes(siblingRange, buildNode);\n            let entry = entriesByLevel[level][lateral];\n            return [\n                Object.assign(Object.assign({}, entry), {\n                    nextLevelNodes: nextLevelRes[0]\n                }),\n                entry.thickness + nextLevelRes[1]\n            ];\n        });\n        return buildNodes(entriesByLevel.length ? {\n            level: 0,\n            lateralStart: 0,\n            lateralEnd: entriesByLevel[0].length\n        } : null, buildNode)[0];\n    }\n    function buildNodes(siblingRange, buildNode) {\n        if (!siblingRange) {\n            return [\n                [],\n                0\n            ];\n        }\n        let { level, lateralStart, lateralEnd } = siblingRange;\n        let lateral = lateralStart;\n        let pairs = [];\n        while(lateral < lateralEnd){\n            pairs.push(buildNode(level, lateral));\n            lateral += 1;\n        }\n        pairs.sort(cmpDescPressures);\n        return [\n            pairs.map(extractNode),\n            pairs[0][1]\n        ];\n    }\n    function cmpDescPressures(a, b) {\n        return b[1] - a[1];\n    }\n    function extractNode(a) {\n        return a[0];\n    }\n    function findNextLevelSegs(hierarchy, subjectLevel, subjectLateral) {\n        let { levelCoords, entriesByLevel } = hierarchy;\n        let subjectEntry = entriesByLevel[subjectLevel][subjectLateral];\n        let afterSubject = levelCoords[subjectLevel] + subjectEntry.thickness;\n        let levelCnt = levelCoords.length;\n        let level = subjectLevel;\n        // skip past levels that are too high up\n        for(; level < levelCnt && levelCoords[level] < afterSubject; level += 1); // do nothing\n        for(; level < levelCnt; level += 1){\n            let entries = entriesByLevel[level];\n            let entry;\n            let searchIndex = binarySearch(entries, subjectEntry.span.start, getEntrySpanEnd);\n            let lateralStart = searchIndex[0] + searchIndex[1]; // if exact match (which doesn't collide), go to next one\n            let lateralEnd = lateralStart;\n            while((entry = entries[lateralEnd]) && // but not past the whole seg list\n            entry.span.start < subjectEntry.span.end){\n                lateralEnd += 1;\n            }\n            if (lateralStart < lateralEnd) {\n                return {\n                    level,\n                    lateralStart,\n                    lateralEnd\n                };\n            }\n        }\n        return null;\n    }\n    function stretchWeb(topLevelNodes, totalThickness) {\n        const stretchNode = cacheable((node, startCoord, prevThickness)=>buildEntryKey(node), (node, startCoord, prevThickness)=>{\n            let { nextLevelNodes, thickness } = node;\n            let allThickness = thickness + prevThickness;\n            let thicknessFraction = thickness / allThickness;\n            let endCoord;\n            let newChildren = [];\n            if (!nextLevelNodes.length) {\n                endCoord = totalThickness;\n            } else {\n                for (let childNode of nextLevelNodes){\n                    if (endCoord === undefined) {\n                        let res = stretchNode(childNode, startCoord, allThickness);\n                        endCoord = res[0];\n                        newChildren.push(res[1]);\n                    } else {\n                        let res = stretchNode(childNode, endCoord, 0);\n                        newChildren.push(res[1]);\n                    }\n                }\n            }\n            let newThickness = (endCoord - startCoord) * thicknessFraction;\n            return [\n                endCoord - newThickness,\n                Object.assign(Object.assign({}, node), {\n                    thickness: newThickness,\n                    nextLevelNodes: newChildren\n                })\n            ];\n        });\n        return topLevelNodes.map((node)=>stretchNode(node, 0, 0)[1]);\n    }\n    // not sorted in any particular order\n    function webToRects(topLevelNodes) {\n        let rects = [];\n        const processNode = cacheable((node, levelCoord, stackDepth)=>buildEntryKey(node), (node, levelCoord, stackDepth)=>{\n            let rect = Object.assign(Object.assign({}, node), {\n                levelCoord,\n                stackDepth,\n                stackForward: 0\n            });\n            rects.push(rect);\n            return rect.stackForward = processNodes(node.nextLevelNodes, levelCoord + node.thickness, stackDepth + 1) + 1;\n        });\n        function processNodes(nodes, levelCoord, stackDepth) {\n            let stackForward = 0;\n            for (let node of nodes){\n                stackForward = Math.max(processNode(node, levelCoord, stackDepth), stackForward);\n            }\n            return stackForward;\n        }\n        processNodes(topLevelNodes, 0, 0);\n        return rects; // TODO: sort rects by levelCoord to be consistent with toRects?\n    }\n    // TODO: move to general util\n    function cacheable(keyFunc, workFunc) {\n        const cache = {};\n        return (...args)=>{\n            let key = keyFunc(...args);\n            return key in cache ? cache[key] : cache[key] = workFunc(...args);\n        };\n    }\n    function computeSegVCoords(segs, colDate, slatCoords = null, eventMinHeight = 0) {\n        let vcoords = [];\n        if (slatCoords) {\n            for(let i = 0; i < segs.length; i += 1){\n                let seg = segs[i];\n                let spanStart = slatCoords.computeDateTop(seg.start, colDate);\n                let spanEnd = Math.max(spanStart + (eventMinHeight || 0), slatCoords.computeDateTop(seg.end, colDate));\n                vcoords.push({\n                    start: Math.round(spanStart),\n                    end: Math.round(spanEnd)\n                });\n            }\n        }\n        return vcoords;\n    }\n    function computeFgSegPlacements(segs, segVCoords, eventOrderStrict, eventMaxStack) {\n        let segInputs = [];\n        let dumbSegs = []; // segs without coords\n        for(let i = 0; i < segs.length; i += 1){\n            let vcoords = segVCoords[i];\n            if (vcoords) {\n                segInputs.push({\n                    index: i,\n                    thickness: 1,\n                    span: vcoords\n                });\n            } else {\n                dumbSegs.push(segs[i]);\n            }\n        }\n        let { segRects, hiddenGroups } = buildPositioning(segInputs, eventOrderStrict, eventMaxStack);\n        let segPlacements = [];\n        for (let segRect of segRects){\n            segPlacements.push({\n                seg: segs[segRect.index],\n                rect: segRect\n            });\n        }\n        for (let dumbSeg of dumbSegs){\n            segPlacements.push({\n                seg: dumbSeg,\n                rect: null\n            });\n        }\n        return {\n            segPlacements,\n            hiddenGroups\n        };\n    }\n    const DEFAULT_TIME_FORMAT$1 = createFormatter({\n        hour: 'numeric',\n        minute: '2-digit',\n        meridiem: false\n    });\n    class TimeColEvent extends BaseComponent {\n        render() {\n            return y(StandardEvent, Object.assign({}, this.props, {\n                elClasses: [\n                    'fc-timegrid-event',\n                    'fc-v-event',\n                    this.props.isShort && 'fc-timegrid-event-short'\n                ],\n                defaultTimeFormat: DEFAULT_TIME_FORMAT$1\n            }));\n        }\n    }\n    class TimeCol extends BaseComponent {\n        constructor(){\n            super(...arguments);\n            this.sortEventSegs = memoize(sortEventSegs);\n        }\n        // TODO: memoize event-placement?\n        render() {\n            let { props, context } = this;\n            let { options } = context;\n            let isSelectMirror = options.selectMirror;\n            let mirrorSegs = props.eventDrag && props.eventDrag.segs || props.eventResize && props.eventResize.segs || isSelectMirror && props.dateSelectionSegs || [];\n            let interactionAffectedInstances = props.eventDrag && props.eventDrag.affectedInstances || props.eventResize && props.eventResize.affectedInstances || {};\n            let sortedFgSegs = this.sortEventSegs(props.fgEventSegs, options.eventOrder);\n            return y(DayCellContainer, {\n                elTag: \"td\",\n                elRef: props.elRef,\n                elClasses: [\n                    'fc-timegrid-col',\n                    ...props.extraClassNames || []\n                ],\n                elAttrs: Object.assign({\n                    role: 'gridcell'\n                }, props.extraDataAttrs),\n                date: props.date,\n                dateProfile: props.dateProfile,\n                todayRange: props.todayRange,\n                extraRenderProps: props.extraRenderProps\n            }, (InnerContent)=>y(\"div\", {\n                    className: \"fc-timegrid-col-frame\"\n                }, y(\"div\", {\n                    className: \"fc-timegrid-col-bg\"\n                }, this.renderFillSegs(props.businessHourSegs, 'non-business'), this.renderFillSegs(props.bgEventSegs, 'bg-event'), this.renderFillSegs(props.dateSelectionSegs, 'highlight')), y(\"div\", {\n                    className: \"fc-timegrid-col-events\"\n                }, this.renderFgSegs(sortedFgSegs, interactionAffectedInstances, false, false, false)), y(\"div\", {\n                    className: \"fc-timegrid-col-events\"\n                }, this.renderFgSegs(mirrorSegs, {}, Boolean(props.eventDrag), Boolean(props.eventResize), Boolean(isSelectMirror), 'mirror')), y(\"div\", {\n                    className: \"fc-timegrid-now-indicator-container\"\n                }, this.renderNowIndicator(props.nowIndicatorSegs)), hasCustomDayCellContent(options) && y(InnerContent, {\n                    elTag: \"div\",\n                    elClasses: [\n                        'fc-timegrid-col-misc'\n                    ]\n                })));\n        }\n        renderFgSegs(sortedFgSegs, segIsInvisible, isDragging, isResizing, isDateSelecting, forcedKey) {\n            let { props } = this;\n            if (props.forPrint) {\n                return renderPlainFgSegs(sortedFgSegs, props);\n            }\n            return this.renderPositionedFgSegs(sortedFgSegs, segIsInvisible, isDragging, isResizing, isDateSelecting, forcedKey);\n        }\n        renderPositionedFgSegs(segs, segIsInvisible, isDragging, isResizing, isDateSelecting, forcedKey) {\n            let { eventMaxStack, eventShortHeight, eventOrderStrict, eventMinHeight } = this.context.options;\n            let { date, slatCoords, eventSelection, todayRange, nowDate } = this.props;\n            let isMirror = isDragging || isResizing || isDateSelecting;\n            let segVCoords = computeSegVCoords(segs, date, slatCoords, eventMinHeight);\n            let { segPlacements, hiddenGroups } = computeFgSegPlacements(segs, segVCoords, eventOrderStrict, eventMaxStack);\n            return y(_, null, this.renderHiddenGroups(hiddenGroups, segs), segPlacements.map((segPlacement)=>{\n                let { seg, rect } = segPlacement;\n                let instanceId = seg.eventRange.instance.instanceId;\n                let isVisible = isMirror || Boolean(!segIsInvisible[instanceId] && rect);\n                let vStyle = computeSegVStyle(rect && rect.span);\n                let hStyle = !isMirror && rect ? this.computeSegHStyle(rect) : {\n                    left: 0,\n                    right: 0\n                };\n                let isInset = Boolean(rect) && rect.stackForward > 0;\n                let isShort = Boolean(rect) && rect.span.end - rect.span.start < eventShortHeight; // look at other places for this problem\n                return y(\"div\", {\n                    className: 'fc-timegrid-event-harness' + (isInset ? ' fc-timegrid-event-harness-inset' : ''),\n                    key: forcedKey || instanceId,\n                    style: Object.assign(Object.assign({\n                        visibility: isVisible ? '' : 'hidden'\n                    }, vStyle), hStyle)\n                }, y(TimeColEvent, Object.assign({\n                    seg: seg,\n                    isDragging: isDragging,\n                    isResizing: isResizing,\n                    isDateSelecting: isDateSelecting,\n                    isSelected: instanceId === eventSelection,\n                    isShort: isShort\n                }, getSegMeta(seg, todayRange, nowDate))));\n            }));\n        }\n        // will already have eventMinHeight applied because segInputs already had it\n        renderHiddenGroups(hiddenGroups, segs) {\n            let { extraDateSpan, dateProfile, todayRange, nowDate, eventSelection, eventDrag, eventResize } = this.props;\n            return y(_, null, hiddenGroups.map((hiddenGroup)=>{\n                let positionCss = computeSegVStyle(hiddenGroup.span);\n                let hiddenSegs = compileSegsFromEntries(hiddenGroup.entries, segs);\n                return y(TimeColMoreLink, {\n                    key: buildIsoString(computeEarliestSegStart(hiddenSegs)),\n                    hiddenSegs: hiddenSegs,\n                    top: positionCss.top,\n                    bottom: positionCss.bottom,\n                    extraDateSpan: extraDateSpan,\n                    dateProfile: dateProfile,\n                    todayRange: todayRange,\n                    nowDate: nowDate,\n                    eventSelection: eventSelection,\n                    eventDrag: eventDrag,\n                    eventResize: eventResize\n                });\n            }));\n        }\n        renderFillSegs(segs, fillType) {\n            let { props, context } = this;\n            let segVCoords = computeSegVCoords(segs, props.date, props.slatCoords, context.options.eventMinHeight); // don't assume all populated\n            let children = segVCoords.map((vcoords, i)=>{\n                let seg = segs[i];\n                return y(\"div\", {\n                    key: buildEventRangeKey(seg.eventRange),\n                    className: \"fc-timegrid-bg-harness\",\n                    style: computeSegVStyle(vcoords)\n                }, fillType === 'bg-event' ? y(BgEvent, Object.assign({\n                    seg: seg\n                }, getSegMeta(seg, props.todayRange, props.nowDate))) : renderFill(fillType));\n            });\n            return y(_, null, children);\n        }\n        renderNowIndicator(segs) {\n            let { slatCoords, date } = this.props;\n            if (!slatCoords) {\n                return null;\n            }\n            return segs.map((seg, i)=>y(NowIndicatorContainer, {\n                    // key doesn't matter. will only ever be one\n                    key: i,\n                    elClasses: [\n                        'fc-timegrid-now-indicator-line'\n                    ],\n                    elStyle: {\n                        top: slatCoords.computeDateTop(seg.start, date)\n                    },\n                    isAxis: false,\n                    date: date\n                }));\n        }\n        computeSegHStyle(segHCoords) {\n            let { isRtl, options } = this.context;\n            let shouldOverlap = options.slotEventOverlap;\n            let nearCoord = segHCoords.levelCoord; // the left side if LTR. the right side if RTL. floating-point\n            let farCoord = segHCoords.levelCoord + segHCoords.thickness; // the right side if LTR. the left side if RTL. floating-point\n            let left; // amount of space from left edge, a fraction of the total width\n            let right; // amount of space from right edge, a fraction of the total width\n            if (shouldOverlap) {\n                // double the width, but don't go beyond the maximum forward coordinate (1.0)\n                farCoord = Math.min(1, nearCoord + (farCoord - nearCoord) * 2);\n            }\n            if (isRtl) {\n                left = 1 - farCoord;\n                right = nearCoord;\n            } else {\n                left = nearCoord;\n                right = 1 - farCoord;\n            }\n            let props = {\n                zIndex: segHCoords.stackDepth + 1,\n                left: left * 100 + '%',\n                right: right * 100 + '%'\n            };\n            if (shouldOverlap && !segHCoords.stackForward) {\n                // add padding to the edge so that forward stacked events don't cover the resizer's icon\n                props[isRtl ? 'marginLeft' : 'marginRight'] = 10 * 2; // 10 is a guesstimate of the icon's width\n            }\n            return props;\n        }\n    }\n    function renderPlainFgSegs(sortedFgSegs, { todayRange, nowDate, eventSelection, eventDrag, eventResize }) {\n        let hiddenInstances = (eventDrag ? eventDrag.affectedInstances : null) || (eventResize ? eventResize.affectedInstances : null) || {};\n        return y(_, null, sortedFgSegs.map((seg)=>{\n            let instanceId = seg.eventRange.instance.instanceId;\n            return y(\"div\", {\n                key: instanceId,\n                style: {\n                    visibility: hiddenInstances[instanceId] ? 'hidden' : ''\n                }\n            }, y(TimeColEvent, Object.assign({\n                seg: seg,\n                isDragging: false,\n                isResizing: false,\n                isDateSelecting: false,\n                isSelected: instanceId === eventSelection,\n                isShort: false\n            }, getSegMeta(seg, todayRange, nowDate))));\n        }));\n    }\n    function computeSegVStyle(segVCoords) {\n        if (!segVCoords) {\n            return {\n                top: '',\n                bottom: ''\n            };\n        }\n        return {\n            top: segVCoords.start,\n            bottom: -segVCoords.end\n        };\n    }\n    function compileSegsFromEntries(segEntries, allSegs) {\n        return segEntries.map((segEntry)=>allSegs[segEntry.index]);\n    }\n    class TimeColsContent extends BaseComponent {\n        constructor(){\n            super(...arguments);\n            this.splitFgEventSegs = memoize(splitSegsByCol);\n            this.splitBgEventSegs = memoize(splitSegsByCol);\n            this.splitBusinessHourSegs = memoize(splitSegsByCol);\n            this.splitNowIndicatorSegs = memoize(splitSegsByCol);\n            this.splitDateSelectionSegs = memoize(splitSegsByCol);\n            this.splitEventDrag = memoize(splitInteractionByCol);\n            this.splitEventResize = memoize(splitInteractionByCol);\n            this.rootElRef = d();\n            this.cellElRefs = new RefMap();\n        }\n        render() {\n            let { props, context } = this;\n            let nowIndicatorTop = context.options.nowIndicator && props.slatCoords && props.slatCoords.safeComputeTop(props.nowDate); // might return void\n            let colCnt = props.cells.length;\n            let fgEventSegsByRow = this.splitFgEventSegs(props.fgEventSegs, colCnt);\n            let bgEventSegsByRow = this.splitBgEventSegs(props.bgEventSegs, colCnt);\n            let businessHourSegsByRow = this.splitBusinessHourSegs(props.businessHourSegs, colCnt);\n            let nowIndicatorSegsByRow = this.splitNowIndicatorSegs(props.nowIndicatorSegs, colCnt);\n            let dateSelectionSegsByRow = this.splitDateSelectionSegs(props.dateSelectionSegs, colCnt);\n            let eventDragByRow = this.splitEventDrag(props.eventDrag, colCnt);\n            let eventResizeByRow = this.splitEventResize(props.eventResize, colCnt);\n            return y(\"div\", {\n                className: \"fc-timegrid-cols\",\n                ref: this.rootElRef\n            }, y(\"table\", {\n                role: \"presentation\",\n                style: {\n                    minWidth: props.tableMinWidth,\n                    width: props.clientWidth\n                }\n            }, props.tableColGroupNode, y(\"tbody\", {\n                role: \"presentation\"\n            }, y(\"tr\", {\n                role: \"row\"\n            }, props.axis && y(\"td\", {\n                \"aria-hidden\": true,\n                className: \"fc-timegrid-col fc-timegrid-axis\"\n            }, y(\"div\", {\n                className: \"fc-timegrid-col-frame\"\n            }, y(\"div\", {\n                className: \"fc-timegrid-now-indicator-container\"\n            }, typeof nowIndicatorTop === 'number' && y(NowIndicatorContainer, {\n                elClasses: [\n                    'fc-timegrid-now-indicator-arrow'\n                ],\n                elStyle: {\n                    top: nowIndicatorTop\n                },\n                isAxis: true,\n                date: props.nowDate\n            })))), props.cells.map((cell, i)=>y(TimeCol, {\n                    key: cell.key,\n                    elRef: this.cellElRefs.createRef(cell.key),\n                    dateProfile: props.dateProfile,\n                    date: cell.date,\n                    nowDate: props.nowDate,\n                    todayRange: props.todayRange,\n                    extraRenderProps: cell.extraRenderProps,\n                    extraDataAttrs: cell.extraDataAttrs,\n                    extraClassNames: cell.extraClassNames,\n                    extraDateSpan: cell.extraDateSpan,\n                    fgEventSegs: fgEventSegsByRow[i],\n                    bgEventSegs: bgEventSegsByRow[i],\n                    businessHourSegs: businessHourSegsByRow[i],\n                    nowIndicatorSegs: nowIndicatorSegsByRow[i],\n                    dateSelectionSegs: dateSelectionSegsByRow[i],\n                    eventDrag: eventDragByRow[i],\n                    eventResize: eventResizeByRow[i],\n                    slatCoords: props.slatCoords,\n                    eventSelection: props.eventSelection,\n                    forPrint: props.forPrint\n                }))))));\n        }\n        componentDidMount() {\n            this.updateCoords();\n        }\n        componentDidUpdate() {\n            this.updateCoords();\n        }\n        updateCoords() {\n            let { props } = this;\n            if (props.onColCoords && props.clientWidth !== null // means sizing has stabilized\n            ) {\n                props.onColCoords(new PositionCache(this.rootElRef.current, collectCellEls(this.cellElRefs.currentMap, props.cells), true, false));\n            }\n        }\n    }\n    function collectCellEls(elMap, cells) {\n        return cells.map((cell)=>elMap[cell.key]);\n    }\n    /* A component that renders one or more columns of vertical time slots\r\n    ----------------------------------------------------------------------------------------------------------------------*/ class TimeCols extends DateComponent {\n        constructor(){\n            super(...arguments);\n            this.processSlotOptions = memoize(processSlotOptions);\n            this.state = {\n                slatCoords: null\n            };\n            this.handleRootEl = (el)=>{\n                if (el) {\n                    this.context.registerInteractiveComponent(this, {\n                        el,\n                        isHitComboAllowed: this.props.isHitComboAllowed\n                    });\n                } else {\n                    this.context.unregisterInteractiveComponent(this);\n                }\n            };\n            this.handleScrollRequest = (request)=>{\n                let { onScrollTopRequest } = this.props;\n                let { slatCoords } = this.state;\n                if (onScrollTopRequest && slatCoords) {\n                    if (request.time) {\n                        let top = slatCoords.computeTimeTop(request.time);\n                        top = Math.ceil(top); // zoom can give weird floating-point values. rather scroll a little bit further\n                        if (top) {\n                            top += 1; // to overcome top border that slots beyond the first have. looks better\n                        }\n                        onScrollTopRequest(top);\n                    }\n                    return true;\n                }\n                return false;\n            };\n            this.handleColCoords = (colCoords)=>{\n                this.colCoords = colCoords;\n            };\n            this.handleSlatCoords = (slatCoords)=>{\n                this.setState({\n                    slatCoords\n                });\n                if (this.props.onSlatCoords) {\n                    this.props.onSlatCoords(slatCoords);\n                }\n            };\n        }\n        render() {\n            let { props, state } = this;\n            return y(\"div\", {\n                className: \"fc-timegrid-body\",\n                ref: this.handleRootEl,\n                style: {\n                    // these props are important to give this wrapper correct dimensions for interactions\n                    // TODO: if we set it here, can we avoid giving to inner tables?\n                    width: props.clientWidth,\n                    minWidth: props.tableMinWidth\n                }\n            }, y(TimeColsSlats, {\n                axis: props.axis,\n                dateProfile: props.dateProfile,\n                slatMetas: props.slatMetas,\n                clientWidth: props.clientWidth,\n                minHeight: props.expandRows ? props.clientHeight : '',\n                tableMinWidth: props.tableMinWidth,\n                tableColGroupNode: props.axis ? props.tableColGroupNode : null,\n                onCoords: this.handleSlatCoords\n            }), y(TimeColsContent, {\n                cells: props.cells,\n                axis: props.axis,\n                dateProfile: props.dateProfile,\n                businessHourSegs: props.businessHourSegs,\n                bgEventSegs: props.bgEventSegs,\n                fgEventSegs: props.fgEventSegs,\n                dateSelectionSegs: props.dateSelectionSegs,\n                eventSelection: props.eventSelection,\n                eventDrag: props.eventDrag,\n                eventResize: props.eventResize,\n                todayRange: props.todayRange,\n                nowDate: props.nowDate,\n                nowIndicatorSegs: props.nowIndicatorSegs,\n                clientWidth: props.clientWidth,\n                tableMinWidth: props.tableMinWidth,\n                tableColGroupNode: props.tableColGroupNode,\n                slatCoords: state.slatCoords,\n                onColCoords: this.handleColCoords,\n                forPrint: props.forPrint\n            }));\n        }\n        componentDidMount() {\n            this.scrollResponder = this.context.createScrollResponder(this.handleScrollRequest);\n        }\n        componentDidUpdate(prevProps) {\n            this.scrollResponder.update(prevProps.dateProfile !== this.props.dateProfile);\n        }\n        componentWillUnmount() {\n            this.scrollResponder.detach();\n        }\n        queryHit(positionLeft, positionTop) {\n            let { dateEnv, options } = this.context;\n            let { colCoords } = this;\n            let { dateProfile } = this.props;\n            let { slatCoords } = this.state;\n            let { snapDuration, snapsPerSlot } = this.processSlotOptions(this.props.slotDuration, options.snapDuration);\n            let colIndex = colCoords.leftToIndex(positionLeft);\n            let slatIndex = slatCoords.positions.topToIndex(positionTop);\n            if (colIndex != null && slatIndex != null) {\n                let cell = this.props.cells[colIndex];\n                let slatTop = slatCoords.positions.tops[slatIndex];\n                let slatHeight = slatCoords.positions.getHeight(slatIndex);\n                let partial = (positionTop - slatTop) / slatHeight; // floating point number between 0 and 1\n                let localSnapIndex = Math.floor(partial * snapsPerSlot); // the snap # relative to start of slat\n                let snapIndex = slatIndex * snapsPerSlot + localSnapIndex;\n                let dayDate = this.props.cells[colIndex].date;\n                let time = addDurations(dateProfile.slotMinTime, multiplyDuration(snapDuration, snapIndex));\n                let start = dateEnv.add(dayDate, time);\n                let end = dateEnv.add(start, snapDuration);\n                return {\n                    dateProfile,\n                    dateSpan: Object.assign({\n                        range: {\n                            start,\n                            end\n                        },\n                        allDay: false\n                    }, cell.extraDateSpan),\n                    dayEl: colCoords.els[colIndex],\n                    rect: {\n                        left: colCoords.lefts[colIndex],\n                        right: colCoords.rights[colIndex],\n                        top: slatTop,\n                        bottom: slatTop + slatHeight\n                    },\n                    layer: 0\n                };\n            }\n            return null;\n        }\n    }\n    function processSlotOptions(slotDuration, snapDurationOverride) {\n        let snapDuration = snapDurationOverride || slotDuration;\n        let snapsPerSlot = wholeDivideDurations(slotDuration, snapDuration);\n        if (snapsPerSlot === null) {\n            snapDuration = slotDuration;\n            snapsPerSlot = 1;\n        // TODO: say warning?\n        }\n        return {\n            snapDuration,\n            snapsPerSlot\n        };\n    }\n    class DayTimeColsSlicer extends Slicer {\n        sliceRange(range, dayRanges) {\n            let segs = [];\n            for(let col = 0; col < dayRanges.length; col += 1){\n                let segRange = intersectRanges(range, dayRanges[col]);\n                if (segRange) {\n                    segs.push({\n                        start: segRange.start,\n                        end: segRange.end,\n                        isStart: segRange.start.valueOf() === range.start.valueOf(),\n                        isEnd: segRange.end.valueOf() === range.end.valueOf(),\n                        col\n                    });\n                }\n            }\n            return segs;\n        }\n    }\n    class DayTimeCols extends DateComponent {\n        constructor(){\n            super(...arguments);\n            this.buildDayRanges = memoize(buildDayRanges);\n            this.slicer = new DayTimeColsSlicer();\n            this.timeColsRef = d();\n        }\n        render() {\n            let { props, context } = this;\n            let { dateProfile, dayTableModel } = props;\n            let { nowIndicator, nextDayThreshold } = context.options;\n            let dayRanges = this.buildDayRanges(dayTableModel, dateProfile, context.dateEnv);\n            // give it the first row of cells\n            // TODO: would move this further down hierarchy, but sliceNowDate needs it\n            return y(NowTimer, {\n                unit: nowIndicator ? 'minute' : 'day'\n            }, (nowDate, todayRange)=>y(TimeCols, Object.assign({\n                    ref: this.timeColsRef\n                }, this.slicer.sliceProps(props, dateProfile, null, context, dayRanges), {\n                    forPrint: props.forPrint,\n                    axis: props.axis,\n                    dateProfile: dateProfile,\n                    slatMetas: props.slatMetas,\n                    slotDuration: props.slotDuration,\n                    cells: dayTableModel.cells[0],\n                    tableColGroupNode: props.tableColGroupNode,\n                    tableMinWidth: props.tableMinWidth,\n                    clientWidth: props.clientWidth,\n                    clientHeight: props.clientHeight,\n                    expandRows: props.expandRows,\n                    nowDate: nowDate,\n                    nowIndicatorSegs: nowIndicator && this.slicer.sliceNowDate(nowDate, dateProfile, nextDayThreshold, context, dayRanges),\n                    todayRange: todayRange,\n                    onScrollTopRequest: props.onScrollTopRequest,\n                    onSlatCoords: props.onSlatCoords\n                })));\n        }\n    }\n    function buildDayRanges(dayTableModel, dateProfile, dateEnv) {\n        let ranges = [];\n        for (let date of dayTableModel.headerDates){\n            ranges.push({\n                start: dateEnv.add(date, dateProfile.slotMinTime),\n                end: dateEnv.add(date, dateProfile.slotMaxTime)\n            });\n        }\n        return ranges;\n    }\n    // potential nice values for the slot-duration and interval-duration\n    // from largest to smallest\n    const STOCK_SUB_DURATIONS = [\n        {\n            hours: 1\n        },\n        {\n            minutes: 30\n        },\n        {\n            minutes: 15\n        },\n        {\n            seconds: 30\n        },\n        {\n            seconds: 15\n        }\n    ];\n    function buildSlatMetas(slotMinTime, slotMaxTime, explicitLabelInterval, slotDuration, dateEnv) {\n        let dayStart = new Date(0);\n        let slatTime = slotMinTime;\n        let slatIterator = createDuration(0);\n        let labelInterval = explicitLabelInterval || computeLabelInterval(slotDuration);\n        let metas = [];\n        while(asRoughMs(slatTime) < asRoughMs(slotMaxTime)){\n            let date = dateEnv.add(dayStart, slatTime);\n            let isLabeled = wholeDivideDurations(slatIterator, labelInterval) !== null;\n            metas.push({\n                date,\n                time: slatTime,\n                key: date.toISOString(),\n                isoTimeStr: formatIsoTimeString(date),\n                isLabeled\n            });\n            slatTime = addDurations(slatTime, slotDuration);\n            slatIterator = addDurations(slatIterator, slotDuration);\n        }\n        return metas;\n    }\n    // Computes an automatic value for slotLabelInterval\n    function computeLabelInterval(slotDuration) {\n        let i;\n        let labelInterval;\n        let slotsPerLabel;\n        // find the smallest stock label interval that results in more than one slots-per-label\n        for(i = STOCK_SUB_DURATIONS.length - 1; i >= 0; i -= 1){\n            labelInterval = createDuration(STOCK_SUB_DURATIONS[i]);\n            slotsPerLabel = wholeDivideDurations(labelInterval, slotDuration);\n            if (slotsPerLabel !== null && slotsPerLabel > 1) {\n                return labelInterval;\n            }\n        }\n        return slotDuration; // fall back\n    }\n    class DayTimeColsView extends TimeColsView {\n        constructor(){\n            super(...arguments);\n            this.buildTimeColsModel = memoize(buildTimeColsModel);\n            this.buildSlatMetas = memoize(buildSlatMetas);\n        }\n        render() {\n            let { options, dateEnv, dateProfileGenerator } = this.context;\n            let { props } = this;\n            let { dateProfile } = props;\n            let dayTableModel = this.buildTimeColsModel(dateProfile, dateProfileGenerator);\n            let splitProps = this.allDaySplitter.splitProps(props);\n            let slatMetas = this.buildSlatMetas(dateProfile.slotMinTime, dateProfile.slotMaxTime, options.slotLabelInterval, options.slotDuration, dateEnv);\n            let { dayMinWidth } = options;\n            let hasAttachedAxis = !dayMinWidth;\n            let hasDetachedAxis = dayMinWidth;\n            let headerContent = options.dayHeaders && y(DayHeader, {\n                dates: dayTableModel.headerDates,\n                dateProfile: dateProfile,\n                datesRepDistinctDays: true,\n                renderIntro: hasAttachedAxis ? this.renderHeadAxis : null\n            });\n            let allDayContent = options.allDaySlot !== false && ((contentArg)=>y(DayTable, Object.assign({}, splitProps.allDay, {\n                    dateProfile: dateProfile,\n                    dayTableModel: dayTableModel,\n                    nextDayThreshold: options.nextDayThreshold,\n                    tableMinWidth: contentArg.tableMinWidth,\n                    colGroupNode: contentArg.tableColGroupNode,\n                    renderRowIntro: hasAttachedAxis ? this.renderTableRowAxis : null,\n                    showWeekNumbers: false,\n                    expandRows: false,\n                    headerAlignElRef: this.headerElRef,\n                    clientWidth: contentArg.clientWidth,\n                    clientHeight: contentArg.clientHeight,\n                    forPrint: props.forPrint\n                }, this.getAllDayMaxEventProps())));\n            let timeGridContent = (contentArg)=>y(DayTimeCols, Object.assign({}, splitProps.timed, {\n                    dayTableModel: dayTableModel,\n                    dateProfile: dateProfile,\n                    axis: hasAttachedAxis,\n                    slotDuration: options.slotDuration,\n                    slatMetas: slatMetas,\n                    forPrint: props.forPrint,\n                    tableColGroupNode: contentArg.tableColGroupNode,\n                    tableMinWidth: contentArg.tableMinWidth,\n                    clientWidth: contentArg.clientWidth,\n                    clientHeight: contentArg.clientHeight,\n                    onSlatCoords: this.handleSlatCoords,\n                    expandRows: contentArg.expandRows,\n                    onScrollTopRequest: this.handleScrollTopRequest\n                }));\n            return hasDetachedAxis ? this.renderHScrollLayout(headerContent, allDayContent, timeGridContent, dayTableModel.colCnt, dayMinWidth, slatMetas, this.state.slatCoords) : this.renderSimpleLayout(headerContent, allDayContent, timeGridContent);\n        }\n    }\n    function buildTimeColsModel(dateProfile, dateProfileGenerator) {\n        let daySeries = new DaySeriesModel(dateProfile.renderRange, dateProfileGenerator);\n        return new DayTableModel(daySeries, false);\n    }\n    const OPTION_REFINERS$2 = {\n        allDaySlot: Boolean\n    };\n    var index$2 = createPlugin({\n        name: '@fullcalendar/timegrid',\n        initialView: 'timeGridWeek',\n        optionRefiners: OPTION_REFINERS$2,\n        views: {\n            timeGrid: {\n                component: DayTimeColsView,\n                usesMinMaxTime: true,\n                allDaySlot: true,\n                slotDuration: '00:30:00',\n                slotEventOverlap: true\n            },\n            timeGridDay: {\n                type: 'timeGrid',\n                duration: {\n                    days: 1\n                }\n            },\n            timeGridWeek: {\n                type: 'timeGrid',\n                duration: {\n                    weeks: 1\n                }\n            }\n        }\n    });\n    var css_248z$1 = \":root{--fc-list-event-dot-width:10px;--fc-list-event-hover-bg-color:#f5f5f5}.fc-theme-standard .fc-list{border:1px solid var(--fc-border-color)}.fc .fc-list-empty{align-items:center;background-color:var(--fc-neutral-bg-color);display:flex;height:100%;justify-content:center}.fc .fc-list-empty-cushion{margin:5em 0}.fc .fc-list-table{border-style:hidden;width:100%}.fc .fc-list-table tr>*{border-left:0;border-right:0}.fc .fc-list-sticky .fc-list-day>*{background:var(--fc-page-bg-color);position:sticky;top:0}.fc .fc-list-table thead{left:-10000px;position:absolute}.fc .fc-list-table tbody>tr:first-child th{border-top:0}.fc .fc-list-table th{padding:0}.fc .fc-list-day-cushion,.fc .fc-list-table td{padding:8px 14px}.fc .fc-list-day-cushion:after{clear:both;content:\\\"\\\";display:table}.fc-theme-standard .fc-list-day-cushion{background-color:var(--fc-neutral-bg-color)}.fc-direction-ltr .fc-list-day-text,.fc-direction-rtl .fc-list-day-side-text{float:left}.fc-direction-ltr .fc-list-day-side-text,.fc-direction-rtl .fc-list-day-text{float:right}.fc-direction-ltr .fc-list-table .fc-list-event-graphic{padding-right:0}.fc-direction-rtl .fc-list-table .fc-list-event-graphic{padding-left:0}.fc .fc-list-event.fc-event-forced-url{cursor:pointer}.fc .fc-list-event:hover td{background-color:var(--fc-list-event-hover-bg-color)}.fc .fc-list-event-graphic,.fc .fc-list-event-time{white-space:nowrap;width:1px}.fc .fc-list-event-dot{border:calc(var(--fc-list-event-dot-width)/2) solid var(--fc-event-border-color);border-radius:calc(var(--fc-list-event-dot-width)/2);box-sizing:content-box;display:inline-block;height:0;width:0}.fc .fc-list-event-title a{color:inherit;text-decoration:none}.fc .fc-list-event.fc-event-forced-url:hover a{text-decoration:underline}\";\n    injectStyles(css_248z$1);\n    class ListViewHeaderRow extends BaseComponent {\n        constructor(){\n            super(...arguments);\n            this.state = {\n                textId: getUniqueDomId()\n            };\n        }\n        render() {\n            let { theme, dateEnv, options, viewApi } = this.context;\n            let { cellId, dayDate, todayRange } = this.props;\n            let { textId } = this.state;\n            let dayMeta = getDateMeta(dayDate, todayRange);\n            // will ever be falsy?\n            let text = options.listDayFormat ? dateEnv.format(dayDate, options.listDayFormat) : '';\n            // will ever be falsy? also, BAD NAME \"alt\"\n            let sideText = options.listDaySideFormat ? dateEnv.format(dayDate, options.listDaySideFormat) : '';\n            let renderProps = Object.assign({\n                date: dateEnv.toDate(dayDate),\n                view: viewApi,\n                textId,\n                text,\n                sideText,\n                navLinkAttrs: buildNavLinkAttrs(this.context, dayDate),\n                sideNavLinkAttrs: buildNavLinkAttrs(this.context, dayDate, 'day', false)\n            }, dayMeta);\n            // TODO: make a reusable HOC for dayHeader (used in daygrid/timegrid too)\n            return y(ContentContainer, {\n                elTag: \"tr\",\n                elClasses: [\n                    'fc-list-day',\n                    ...getDayClassNames(dayMeta, theme)\n                ],\n                elAttrs: {\n                    'data-date': formatDayString(dayDate)\n                },\n                renderProps: renderProps,\n                generatorName: \"dayHeaderContent\",\n                customGenerator: options.dayHeaderContent,\n                defaultGenerator: renderInnerContent,\n                classNameGenerator: options.dayHeaderClassNames,\n                didMount: options.dayHeaderDidMount,\n                willUnmount: options.dayHeaderWillUnmount\n            }, (InnerContent)=>y(\"th\", {\n                    scope: \"colgroup\",\n                    colSpan: 3,\n                    id: cellId,\n                    \"aria-labelledby\": textId\n                }, y(InnerContent, {\n                    elTag: \"div\",\n                    elClasses: [\n                        'fc-list-day-cushion',\n                        theme.getClass('tableCellShaded')\n                    ]\n                })));\n        }\n    }\n    function renderInnerContent(props) {\n        return y(_, null, props.text && y(\"a\", Object.assign({\n            id: props.textId,\n            className: \"fc-list-day-text\"\n        }, props.navLinkAttrs), props.text), props.sideText && /* not keyboard tabbable */ y(\"a\", Object.assign({\n            \"aria-hidden\": true,\n            className: \"fc-list-day-side-text\"\n        }, props.sideNavLinkAttrs), props.sideText));\n    }\n    const DEFAULT_TIME_FORMAT = createFormatter({\n        hour: 'numeric',\n        minute: '2-digit',\n        meridiem: 'short'\n    });\n    class ListViewEventRow extends BaseComponent {\n        render() {\n            let { props, context } = this;\n            let { options } = context;\n            let { seg, timeHeaderId, eventHeaderId, dateHeaderId } = props;\n            let timeFormat = options.eventTimeFormat || DEFAULT_TIME_FORMAT;\n            return y(EventContainer, Object.assign({}, props, {\n                elTag: \"tr\",\n                elClasses: [\n                    'fc-list-event',\n                    seg.eventRange.def.url && 'fc-event-forced-url'\n                ],\n                defaultGenerator: ()=>renderEventInnerContent(seg, context),\n                seg: seg,\n                timeText: \"\",\n                disableDragging: true,\n                disableResizing: true\n            }), (InnerContent, eventContentArg)=>y(_, null, buildTimeContent(seg, timeFormat, context, timeHeaderId, dateHeaderId), y(\"td\", {\n                    \"aria-hidden\": true,\n                    className: \"fc-list-event-graphic\"\n                }, y(\"span\", {\n                    className: \"fc-list-event-dot\",\n                    style: {\n                        borderColor: eventContentArg.borderColor || eventContentArg.backgroundColor\n                    }\n                })), y(InnerContent, {\n                    elTag: \"td\",\n                    elClasses: [\n                        'fc-list-event-title'\n                    ],\n                    elAttrs: {\n                        headers: `${eventHeaderId} ${dateHeaderId}`\n                    }\n                })));\n        }\n    }\n    function renderEventInnerContent(seg, context) {\n        let interactiveAttrs = getSegAnchorAttrs(seg, context);\n        return y(\"a\", Object.assign({}, interactiveAttrs), seg.eventRange.def.title);\n    }\n    function buildTimeContent(seg, timeFormat, context, timeHeaderId, dateHeaderId) {\n        let { options } = context;\n        if (options.displayEventTime !== false) {\n            let eventDef = seg.eventRange.def;\n            let eventInstance = seg.eventRange.instance;\n            let doAllDay = false;\n            let timeText;\n            if (eventDef.allDay) {\n                doAllDay = true;\n            } else if (isMultiDayRange(seg.eventRange.range)) {\n                if (seg.isStart) {\n                    timeText = buildSegTimeText(seg, timeFormat, context, null, null, eventInstance.range.start, seg.end);\n                } else if (seg.isEnd) {\n                    timeText = buildSegTimeText(seg, timeFormat, context, null, null, seg.start, eventInstance.range.end);\n                } else {\n                    doAllDay = true;\n                }\n            } else {\n                timeText = buildSegTimeText(seg, timeFormat, context);\n            }\n            if (doAllDay) {\n                let renderProps = {\n                    text: context.options.allDayText,\n                    view: context.viewApi\n                };\n                return y(ContentContainer, {\n                    elTag: \"td\",\n                    elClasses: [\n                        'fc-list-event-time'\n                    ],\n                    elAttrs: {\n                        headers: `${timeHeaderId} ${dateHeaderId}`\n                    },\n                    renderProps: renderProps,\n                    generatorName: \"allDayContent\",\n                    customGenerator: options.allDayContent,\n                    defaultGenerator: renderAllDayInner,\n                    classNameGenerator: options.allDayClassNames,\n                    didMount: options.allDayDidMount,\n                    willUnmount: options.allDayWillUnmount\n                });\n            }\n            return y(\"td\", {\n                className: \"fc-list-event-time\"\n            }, timeText);\n        }\n        return null;\n    }\n    function renderAllDayInner(renderProps) {\n        return renderProps.text;\n    }\n    /*\r\n    Responsible for the scroller, and forwarding event-related actions into the \"grid\".\r\n    */ class ListView extends DateComponent {\n        constructor(){\n            super(...arguments);\n            this.computeDateVars = memoize(computeDateVars);\n            this.eventStoreToSegs = memoize(this._eventStoreToSegs);\n            this.state = {\n                timeHeaderId: getUniqueDomId(),\n                eventHeaderId: getUniqueDomId(),\n                dateHeaderIdRoot: getUniqueDomId()\n            };\n            this.setRootEl = (rootEl)=>{\n                if (rootEl) {\n                    this.context.registerInteractiveComponent(this, {\n                        el: rootEl\n                    });\n                } else {\n                    this.context.unregisterInteractiveComponent(this);\n                }\n            };\n        }\n        render() {\n            let { props, context } = this;\n            let { dayDates, dayRanges } = this.computeDateVars(props.dateProfile);\n            let eventSegs = this.eventStoreToSegs(props.eventStore, props.eventUiBases, dayRanges);\n            return y(ViewContainer, {\n                elRef: this.setRootEl,\n                elClasses: [\n                    'fc-list',\n                    context.theme.getClass('table'),\n                    context.options.stickyHeaderDates !== false ? 'fc-list-sticky' : ''\n                ],\n                viewSpec: context.viewSpec\n            }, y(Scroller, {\n                liquid: !props.isHeightAuto,\n                overflowX: props.isHeightAuto ? 'visible' : 'hidden',\n                overflowY: props.isHeightAuto ? 'visible' : 'auto'\n            }, eventSegs.length > 0 ? this.renderSegList(eventSegs, dayDates) : this.renderEmptyMessage()));\n        }\n        renderEmptyMessage() {\n            let { options, viewApi } = this.context;\n            let renderProps = {\n                text: options.noEventsText,\n                view: viewApi\n            };\n            return y(ContentContainer, {\n                elTag: \"div\",\n                elClasses: [\n                    'fc-list-empty'\n                ],\n                renderProps: renderProps,\n                generatorName: \"noEventsContent\",\n                customGenerator: options.noEventsContent,\n                defaultGenerator: renderNoEventsInner,\n                classNameGenerator: options.noEventsClassNames,\n                didMount: options.noEventsDidMount,\n                willUnmount: options.noEventsWillUnmount\n            }, (InnerContent)=>y(InnerContent, {\n                    elTag: \"div\",\n                    elClasses: [\n                        'fc-list-empty-cushion'\n                    ]\n                }));\n        }\n        renderSegList(allSegs, dayDates) {\n            let { theme, options } = this.context;\n            let { timeHeaderId, eventHeaderId, dateHeaderIdRoot } = this.state;\n            let segsByDay = groupSegsByDay(allSegs); // sparse array\n            return y(NowTimer, {\n                unit: \"day\"\n            }, (nowDate, todayRange)=>{\n                let innerNodes = [];\n                for(let dayIndex = 0; dayIndex < segsByDay.length; dayIndex += 1){\n                    let daySegs = segsByDay[dayIndex];\n                    if (daySegs) {\n                        let dayStr = formatDayString(dayDates[dayIndex]);\n                        let dateHeaderId = dateHeaderIdRoot + '-' + dayStr;\n                        // append a day header\n                        innerNodes.push(y(ListViewHeaderRow, {\n                            key: dayStr,\n                            cellId: dateHeaderId,\n                            dayDate: dayDates[dayIndex],\n                            todayRange: todayRange\n                        }));\n                        daySegs = sortEventSegs(daySegs, options.eventOrder);\n                        for (let seg of daySegs){\n                            innerNodes.push(y(ListViewEventRow, Object.assign({\n                                key: dayStr + ':' + seg.eventRange.instance.instanceId /* are multiple segs for an instanceId */ ,\n                                seg: seg,\n                                isDragging: false,\n                                isResizing: false,\n                                isDateSelecting: false,\n                                isSelected: false,\n                                timeHeaderId: timeHeaderId,\n                                eventHeaderId: eventHeaderId,\n                                dateHeaderId: dateHeaderId\n                            }, getSegMeta(seg, todayRange, nowDate))));\n                        }\n                    }\n                }\n                return y(\"table\", {\n                    className: 'fc-list-table ' + theme.getClass('table')\n                }, y(\"thead\", null, y(\"tr\", null, y(\"th\", {\n                    scope: \"col\",\n                    id: timeHeaderId\n                }, options.timeHint), y(\"th\", {\n                    scope: \"col\",\n                    \"aria-hidden\": true\n                }), y(\"th\", {\n                    scope: \"col\",\n                    id: eventHeaderId\n                }, options.eventHint))), y(\"tbody\", null, innerNodes));\n            });\n        }\n        _eventStoreToSegs(eventStore, eventUiBases, dayRanges) {\n            return this.eventRangesToSegs(sliceEventStore(eventStore, eventUiBases, this.props.dateProfile.activeRange, this.context.options.nextDayThreshold).fg, dayRanges);\n        }\n        eventRangesToSegs(eventRanges, dayRanges) {\n            let segs = [];\n            for (let eventRange of eventRanges){\n                segs.push(...this.eventRangeToSegs(eventRange, dayRanges));\n            }\n            return segs;\n        }\n        eventRangeToSegs(eventRange, dayRanges) {\n            let { dateEnv } = this.context;\n            let { nextDayThreshold } = this.context.options;\n            let range = eventRange.range;\n            let allDay = eventRange.def.allDay;\n            let dayIndex;\n            let segRange;\n            let seg;\n            let segs = [];\n            for(dayIndex = 0; dayIndex < dayRanges.length; dayIndex += 1){\n                segRange = intersectRanges(range, dayRanges[dayIndex]);\n                if (segRange) {\n                    seg = {\n                        component: this,\n                        eventRange,\n                        start: segRange.start,\n                        end: segRange.end,\n                        isStart: eventRange.isStart && segRange.start.valueOf() === range.start.valueOf(),\n                        isEnd: eventRange.isEnd && segRange.end.valueOf() === range.end.valueOf(),\n                        dayIndex\n                    };\n                    segs.push(seg);\n                    // detect when range won't go fully into the next day,\n                    // and mutate the latest seg to the be the end.\n                    if (!seg.isEnd && !allDay && dayIndex + 1 < dayRanges.length && range.end < dateEnv.add(dayRanges[dayIndex + 1].start, nextDayThreshold)) {\n                        seg.end = range.end;\n                        seg.isEnd = true;\n                        break;\n                    }\n                }\n            }\n            return segs;\n        }\n    }\n    function renderNoEventsInner(renderProps) {\n        return renderProps.text;\n    }\n    function computeDateVars(dateProfile) {\n        let dayStart = startOfDay(dateProfile.renderRange.start);\n        let viewEnd = dateProfile.renderRange.end;\n        let dayDates = [];\n        let dayRanges = [];\n        while(dayStart < viewEnd){\n            dayDates.push(dayStart);\n            dayRanges.push({\n                start: dayStart,\n                end: addDays(dayStart, 1)\n            });\n            dayStart = addDays(dayStart, 1);\n        }\n        return {\n            dayDates,\n            dayRanges\n        };\n    }\n    // Returns a sparse array of arrays, segs grouped by their dayIndex\n    function groupSegsByDay(segs) {\n        let segsByDay = []; // sparse array\n        let i;\n        let seg;\n        for(i = 0; i < segs.length; i += 1){\n            seg = segs[i];\n            (segsByDay[seg.dayIndex] || (segsByDay[seg.dayIndex] = [])).push(seg);\n        }\n        return segsByDay;\n    }\n    const OPTION_REFINERS$1 = {\n        listDayFormat: createFalsableFormatter,\n        listDaySideFormat: createFalsableFormatter,\n        noEventsClassNames: identity,\n        noEventsContent: identity,\n        noEventsDidMount: identity,\n        noEventsWillUnmount: identity\n    };\n    function createFalsableFormatter(input) {\n        return input === false ? null : createFormatter(input);\n    }\n    var index$1 = createPlugin({\n        name: '@fullcalendar/list',\n        optionRefiners: OPTION_REFINERS$1,\n        views: {\n            list: {\n                component: ListView,\n                buttonTextKey: 'list',\n                listDayFormat: {\n                    month: 'long',\n                    day: 'numeric',\n                    year: 'numeric'\n                }\n            },\n            listDay: {\n                type: 'list',\n                duration: {\n                    days: 1\n                },\n                listDayFormat: {\n                    weekday: 'long'\n                }\n            },\n            listWeek: {\n                type: 'list',\n                duration: {\n                    weeks: 1\n                },\n                listDayFormat: {\n                    weekday: 'long'\n                },\n                listDaySideFormat: {\n                    month: 'long',\n                    day: 'numeric',\n                    year: 'numeric'\n                }\n            },\n            listMonth: {\n                type: 'list',\n                duration: {\n                    month: 1\n                },\n                listDaySideFormat: {\n                    weekday: 'long'\n                }\n            },\n            listYear: {\n                type: 'list',\n                duration: {\n                    year: 1\n                },\n                listDaySideFormat: {\n                    weekday: 'long'\n                }\n            }\n        }\n    });\n    class SingleMonth extends DateComponent {\n        constructor(){\n            super(...arguments);\n            this.buildDayTableModel = memoize(buildDayTableModel);\n            this.slicer = new DayTableSlicer();\n            this.state = {\n                labelId: getUniqueDomId()\n            };\n        }\n        render() {\n            const { props, state, context } = this;\n            const { dateProfile, forPrint } = props;\n            const { options } = context;\n            const dayTableModel = this.buildDayTableModel(dateProfile, context.dateProfileGenerator);\n            const slicedProps = this.slicer.sliceProps(props, dateProfile, options.nextDayThreshold, context, dayTableModel);\n            // ensure single-month has aspect ratio\n            const tableHeight = props.tableWidth != null ? props.tableWidth / options.aspectRatio : null;\n            const rowCnt = dayTableModel.cells.length;\n            const rowHeight = tableHeight != null ? tableHeight / rowCnt : null;\n            return y(\"div\", {\n                ref: props.elRef,\n                \"data-date\": props.isoDateStr,\n                className: \"fc-multimonth-month\",\n                style: {\n                    width: props.width\n                },\n                role: \"grid\",\n                \"aria-labelledby\": state.labelId\n            }, y(\"div\", {\n                className: \"fc-multimonth-header\",\n                style: {\n                    marginBottom: rowHeight\n                },\n                role: \"presentation\"\n            }, y(\"div\", {\n                className: \"fc-multimonth-title\",\n                id: state.labelId\n            }, context.dateEnv.format(props.dateProfile.currentRange.start, props.titleFormat)), y(\"table\", {\n                className: [\n                    'fc-multimonth-header-table',\n                    context.theme.getClass('table')\n                ].join(' '),\n                role: \"presentation\"\n            }, y(\"thead\", {\n                role: \"rowgroup\"\n            }, y(DayHeader, {\n                dateProfile: props.dateProfile,\n                dates: dayTableModel.headerDates,\n                datesRepDistinctDays: false\n            })))), y(\"div\", {\n                className: [\n                    'fc-multimonth-daygrid',\n                    'fc-daygrid',\n                    'fc-daygrid-body',\n                    !forPrint && 'fc-daygrid-body-balanced',\n                    forPrint && 'fc-daygrid-body-unbalanced',\n                    forPrint && 'fc-daygrid-body-natural'\n                ].join(' '),\n                style: {\n                    marginTop: -rowHeight\n                }\n            }, y(\"table\", {\n                className: [\n                    'fc-multimonth-daygrid-table',\n                    context.theme.getClass('table')\n                ].join(' '),\n                style: {\n                    height: forPrint ? '' : tableHeight\n                },\n                role: \"presentation\"\n            }, y(\"tbody\", {\n                role: \"rowgroup\"\n            }, y(TableRows, Object.assign({}, slicedProps, {\n                dateProfile: dateProfile,\n                cells: dayTableModel.cells,\n                eventSelection: props.eventSelection,\n                dayMaxEvents: !forPrint,\n                dayMaxEventRows: !forPrint,\n                showWeekNumbers: options.weekNumbers,\n                clientWidth: props.clientWidth,\n                clientHeight: props.clientHeight,\n                forPrint: forPrint\n            }))))));\n        }\n    }\n    class MultiMonthView extends DateComponent {\n        constructor(){\n            super(...arguments);\n            this.splitDateProfileByMonth = memoize(splitDateProfileByMonth);\n            this.buildMonthFormat = memoize(buildMonthFormat);\n            this.scrollElRef = d();\n            this.firstMonthElRef = d();\n            this.needsScrollReset = false;\n            this.handleSizing = (isForced)=>{\n                if (isForced) {\n                    this.updateSize();\n                }\n            };\n        }\n        render() {\n            const { context, props, state } = this;\n            const { options } = context;\n            const { clientWidth, clientHeight } = state;\n            const monthHPadding = state.monthHPadding || 0;\n            const colCount = Math.min(clientWidth != null ? Math.floor(clientWidth / (options.multiMonthMinWidth + monthHPadding)) : 1, options.multiMonthMaxColumns) || 1;\n            const monthWidthPct = 100 / colCount + '%';\n            const monthTableWidth = clientWidth == null ? null : clientWidth / colCount - monthHPadding;\n            const isLegitSingleCol = clientWidth != null && colCount === 1;\n            const monthDateProfiles = this.splitDateProfileByMonth(context.dateProfileGenerator, props.dateProfile, context.dateEnv, isLegitSingleCol ? false : options.fixedWeekCount, options.showNonCurrentDates);\n            const monthTitleFormat = this.buildMonthFormat(options.multiMonthTitleFormat, monthDateProfiles);\n            const rootClassNames = [\n                'fc-multimonth',\n                isLegitSingleCol ? 'fc-multimonth-singlecol' : 'fc-multimonth-multicol',\n                monthTableWidth != null && monthTableWidth < 400 ? 'fc-multimonth-compact' : ''\n            ];\n            return y(ViewContainer, {\n                elRef: this.scrollElRef,\n                elClasses: rootClassNames,\n                viewSpec: context.viewSpec\n            }, monthDateProfiles.map((monthDateProfile, i)=>{\n                const monthStr = formatIsoMonthStr(monthDateProfile.currentRange.start);\n                return y(SingleMonth, Object.assign({}, props, {\n                    key: monthStr,\n                    isoDateStr: monthStr,\n                    elRef: i === 0 ? this.firstMonthElRef : undefined,\n                    titleFormat: monthTitleFormat,\n                    dateProfile: monthDateProfile,\n                    width: monthWidthPct,\n                    tableWidth: monthTableWidth,\n                    clientWidth: clientWidth,\n                    clientHeight: clientHeight\n                }));\n            }));\n        }\n        componentDidMount() {\n            this.updateSize();\n            this.context.addResizeHandler(this.handleSizing);\n            this.requestScrollReset();\n        }\n        componentDidUpdate(prevProps) {\n            if (!isPropsEqual(prevProps, this.props)) {\n                this.handleSizing(false);\n            }\n            if (prevProps.dateProfile !== this.props.dateProfile) {\n                this.requestScrollReset();\n            } else {\n                this.flushScrollReset();\n            }\n        }\n        componentWillUnmount() {\n            this.context.removeResizeHandler(this.handleSizing);\n        }\n        updateSize() {\n            const scrollEl = this.scrollElRef.current;\n            const firstMonthEl = this.firstMonthElRef.current;\n            if (scrollEl) {\n                this.setState({\n                    clientWidth: scrollEl.clientWidth,\n                    clientHeight: scrollEl.clientHeight\n                });\n            }\n            if (firstMonthEl && scrollEl) {\n                if (this.state.monthHPadding == null) {\n                    this.setState({\n                        monthHPadding: scrollEl.clientWidth - // go within padding\n                        firstMonthEl.firstChild.offsetWidth\n                    });\n                }\n            }\n        }\n        requestScrollReset() {\n            this.needsScrollReset = true;\n            this.flushScrollReset();\n        }\n        flushScrollReset() {\n            if (this.needsScrollReset && this.state.monthHPadding != null // indicates sizing already happened\n            ) {\n                const { currentDate } = this.props.dateProfile;\n                const scrollEl = this.scrollElRef.current;\n                const monthEl = scrollEl.querySelector(`[data-date=\"${formatIsoMonthStr(currentDate)}\"]`);\n                scrollEl.scrollTop = monthEl.getBoundingClientRect().top - this.firstMonthElRef.current.getBoundingClientRect().top;\n                this.needsScrollReset = false;\n            }\n        }\n        // workaround for when queued setState render (w/ clientWidth) gets cancelled because\n        // subsequent update and shouldComponentUpdate says not to render :(\n        shouldComponentUpdate() {\n            return true;\n        }\n    }\n    // date profile\n    // -------------------------------------------------------------------------------------------------\n    const oneMonthDuration = createDuration(1, 'month');\n    function splitDateProfileByMonth(dateProfileGenerator, dateProfile, dateEnv, fixedWeekCount, showNonCurrentDates) {\n        const { start, end } = dateProfile.currentRange;\n        let monthStart = start;\n        const monthDateProfiles = [];\n        while(monthStart.valueOf() < end.valueOf()){\n            const monthEnd = dateEnv.add(monthStart, oneMonthDuration);\n            const currentRange = {\n                // yuck\n                start: dateProfileGenerator.skipHiddenDays(monthStart),\n                end: dateProfileGenerator.skipHiddenDays(monthEnd, -1, true)\n            };\n            let renderRange = buildDayTableRenderRange({\n                currentRange,\n                snapToWeek: true,\n                fixedWeekCount,\n                dateEnv\n            });\n            renderRange = {\n                // yuck\n                start: dateProfileGenerator.skipHiddenDays(renderRange.start),\n                end: dateProfileGenerator.skipHiddenDays(renderRange.end, -1, true)\n            };\n            const activeRange = dateProfile.activeRange ? intersectRanges(dateProfile.activeRange, showNonCurrentDates ? renderRange : currentRange) : null;\n            monthDateProfiles.push({\n                currentDate: dateProfile.currentDate,\n                isValid: dateProfile.isValid,\n                validRange: dateProfile.validRange,\n                renderRange,\n                activeRange,\n                currentRange,\n                currentRangeUnit: 'month',\n                isRangeAllDay: true,\n                dateIncrement: dateProfile.dateIncrement,\n                slotMinTime: dateProfile.slotMaxTime,\n                slotMaxTime: dateProfile.slotMinTime\n            });\n            monthStart = monthEnd;\n        }\n        return monthDateProfiles;\n    }\n    // date formatting\n    // -------------------------------------------------------------------------------------------------\n    const YEAR_MONTH_FORMATTER = createFormatter({\n        year: 'numeric',\n        month: 'long'\n    });\n    const YEAR_FORMATTER = createFormatter({\n        month: 'long'\n    });\n    function buildMonthFormat(formatOverride, monthDateProfiles) {\n        return formatOverride || (monthDateProfiles[0].currentRange.start.getUTCFullYear() !== monthDateProfiles[monthDateProfiles.length - 1].currentRange.start.getUTCFullYear() ? YEAR_MONTH_FORMATTER : YEAR_FORMATTER);\n    }\n    const OPTION_REFINERS = {\n        multiMonthTitleFormat: createFormatter,\n        multiMonthMaxColumns: Number,\n        multiMonthMinWidth: Number\n    };\n    var css_248z = \".fc .fc-multimonth{border:1px solid var(--fc-border-color);display:flex;flex-wrap:wrap;overflow-x:hidden;overflow-y:auto}.fc .fc-multimonth-title{font-size:1.2em;font-weight:700;padding:1em 0;text-align:center}.fc .fc-multimonth-daygrid{background:var(--fc-page-bg-color)}.fc .fc-multimonth-daygrid-table,.fc .fc-multimonth-header-table{table-layout:fixed;width:100%}.fc .fc-multimonth-daygrid-table{border-top-style:hidden!important}.fc .fc-multimonth-singlecol .fc-multimonth{position:relative}.fc .fc-multimonth-singlecol .fc-multimonth-header{background:var(--fc-page-bg-color);position:relative;top:0;z-index:2}.fc .fc-multimonth-singlecol .fc-multimonth-daygrid{position:relative;z-index:1}.fc .fc-multimonth-singlecol .fc-multimonth-daygrid-table,.fc .fc-multimonth-singlecol .fc-multimonth-header-table{border-left-style:hidden;border-right-style:hidden}.fc .fc-multimonth-singlecol .fc-multimonth-month:last-child .fc-multimonth-daygrid-table{border-bottom-style:hidden}.fc .fc-multimonth-multicol{line-height:1}.fc .fc-multimonth-multicol .fc-multimonth-month{padding:0 1.2em 1.2em}.fc .fc-multimonth-multicol .fc-daygrid-more-link{border:1px solid var(--fc-event-border-color);display:block;float:none;padding:1px}.fc .fc-multimonth-compact{line-height:1}.fc .fc-multimonth-compact .fc-multimonth-daygrid-table,.fc .fc-multimonth-compact .fc-multimonth-header-table{font-size:.9em}.fc-media-screen .fc-multimonth-singlecol .fc-multimonth-header{position:sticky}.fc-media-print .fc-multimonth{overflow:visible}\";\n    injectStyles(css_248z);\n    var index = createPlugin({\n        name: '@fullcalendar/multimonth',\n        initialView: 'multiMonthYear',\n        optionRefiners: OPTION_REFINERS,\n        views: {\n            multiMonth: {\n                component: MultiMonthView,\n                dateProfileGeneratorClass: TableDateProfileGenerator,\n                multiMonthMinWidth: 350,\n                multiMonthMaxColumns: 3\n            },\n            multiMonthYear: {\n                type: 'multiMonth',\n                duration: {\n                    years: 1\n                },\n                fixedWeekCount: true,\n                showNonCurrentDates: false\n            }\n        }\n    });\n    globalPlugins.push(index$4, index$3, index$2, index$1, index);\n    exports.Calendar = Calendar;\n    exports.Draggable = ExternalDraggable;\n    exports.Internal = internal;\n    exports.JsonRequestError = JsonRequestError;\n    exports.Preact = preact;\n    exports.ThirdPartyDraggable = ThirdPartyDraggable;\n    exports.createPlugin = createPlugin;\n    exports.formatDate = formatDate;\n    exports.formatRange = formatRange;\n    exports.globalLocales = globalLocales;\n    exports.globalPlugins = globalPlugins;\n    exports.sliceEvents = sliceEvents;\n    exports.version = version;\n    Object.defineProperty(exports, '__esModule', {\n        value: true\n    });\n    return exports;\n}({});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkQ6XFxuZXh0XFxvcmdcXHNyY1xcdmVuZG9yXFxmdWxsY2FsZW5kYXJcXGdsb2JhbC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcclxuRnVsbENhbGVuZGFyIFN0YW5kYXJkIEJ1bmRsZSB2Ni4xLjhcclxuRG9jcyAmIExpY2Vuc2U6IGh0dHBzOi8vZnVsbGNhbGVuZGFyLmlvL2RvY3MvaW5pdGlhbGl6ZS1nbG9iYWxzXHJcbihjKSAyMDIzIEFkYW0gU2hhd1xyXG4qL1xyXG52YXIgRnVsbENhbGVuZGFyID0gKGZ1bmN0aW9uIChleHBvcnRzKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcblxyXG4gICAgdmFyIG4sbCQxLHUkMSxpJDEsdCxyJDEsbyxmJDEsZSQxLGMkMT17fSxzPVtdLGEkMT0vYWNpdHxleCg/OnN8Z3xufHB8JCl8cnBofGdyaWR8b3dzfG1uY3xudHd8aW5lW2NoXXx6b298Xm9yZHxpdGVyYS9pO2Z1bmN0aW9uIGgobixsKXtmb3IodmFyIHUgaW4gbCluW3VdPWxbdV07cmV0dXJuIG59ZnVuY3Rpb24gdiQxKG4pe3ZhciBsPW4ucGFyZW50Tm9kZTtsJiZsLnJlbW92ZUNoaWxkKG4pO31mdW5jdGlvbiB5KGwsdSxpKXt2YXIgdCxyLG8sZj17fTtmb3IobyBpbiB1KVwia2V5XCI9PW8/dD11W29dOlwicmVmXCI9PW8/cj11W29dOmZbb109dVtvXTtpZihhcmd1bWVudHMubGVuZ3RoPjImJihmLmNoaWxkcmVuPWFyZ3VtZW50cy5sZW5ndGg+Mz9uLmNhbGwoYXJndW1lbnRzLDIpOmkpLFwiZnVuY3Rpb25cIj09dHlwZW9mIGwmJm51bGwhPWwuZGVmYXVsdFByb3BzKWZvcihvIGluIGwuZGVmYXVsdFByb3BzKXZvaWQgMD09PWZbb10mJihmW29dPWwuZGVmYXVsdFByb3BzW29dKTtyZXR1cm4gcChsLGYsdCxyLG51bGwpfWZ1bmN0aW9uIHAobixpLHQscixvKXt2YXIgZj17dHlwZTpuLHByb3BzOmksa2V5OnQscmVmOnIsX19rOm51bGwsX186bnVsbCxfX2I6MCxfX2U6bnVsbCxfX2Q6dm9pZCAwLF9fYzpudWxsLF9faDpudWxsLGNvbnN0cnVjdG9yOnZvaWQgMCxfX3Y6bnVsbD09bz8rK3UkMTpvfTtyZXR1cm4gbnVsbD09byYmbnVsbCE9bCQxLnZub2RlJiZsJDEudm5vZGUoZiksZn1mdW5jdGlvbiBkKCl7cmV0dXJuIHtjdXJyZW50Om51bGx9fWZ1bmN0aW9uIF8obil7cmV0dXJuIG4uY2hpbGRyZW59ZnVuY3Rpb24gayQxKG4sbCx1LGksdCl7dmFyIHI7Zm9yKHIgaW4gdSlcImNoaWxkcmVuXCI9PT1yfHxcImtleVwiPT09cnx8ciBpbiBsfHxnJDIobixyLG51bGwsdVtyXSxpKTtmb3IociBpbiBsKXQmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIGxbcl18fFwiY2hpbGRyZW5cIj09PXJ8fFwia2V5XCI9PT1yfHxcInZhbHVlXCI9PT1yfHxcImNoZWNrZWRcIj09PXJ8fHVbcl09PT1sW3JdfHxnJDIobixyLGxbcl0sdVtyXSxpKTt9ZnVuY3Rpb24gYiQxKG4sbCx1KXtcIi1cIj09PWxbMF0/bi5zZXRQcm9wZXJ0eShsLG51bGw9PXU/XCJcIjp1KTpuW2xdPW51bGw9PXU/XCJcIjpcIm51bWJlclwiIT10eXBlb2YgdXx8YSQxLnRlc3QobCk/dTp1K1wicHhcIjt9ZnVuY3Rpb24gZyQyKG4sbCx1LGksdCl7dmFyIHI7bjppZihcInN0eWxlXCI9PT1sKWlmKFwic3RyaW5nXCI9PXR5cGVvZiB1KW4uc3R5bGUuY3NzVGV4dD11O2Vsc2Uge2lmKFwic3RyaW5nXCI9PXR5cGVvZiBpJiYobi5zdHlsZS5jc3NUZXh0PWk9XCJcIiksaSlmb3IobCBpbiBpKXUmJmwgaW4gdXx8YiQxKG4uc3R5bGUsbCxcIlwiKTtpZih1KWZvcihsIGluIHUpaSYmdVtsXT09PWlbbF18fGIkMShuLnN0eWxlLGwsdVtsXSk7fWVsc2UgaWYoXCJvXCI9PT1sWzBdJiZcIm5cIj09PWxbMV0pcj1sIT09KGw9bC5yZXBsYWNlKC9DYXB0dXJlJC8sXCJcIikpLGw9bC50b0xvd2VyQ2FzZSgpaW4gbj9sLnRvTG93ZXJDYXNlKCkuc2xpY2UoMik6bC5zbGljZSgyKSxuLmx8fChuLmw9e30pLG4ubFtsK3JdPXUsdT9pfHxuLmFkZEV2ZW50TGlzdGVuZXIobCxyP3ckMjptJDEscik6bi5yZW1vdmVFdmVudExpc3RlbmVyKGwscj93JDI6bSQxLHIpO2Vsc2UgaWYoXCJkYW5nZXJvdXNseVNldElubmVySFRNTFwiIT09bCl7aWYodClsPWwucmVwbGFjZSgveGxpbmsoSHw6aCkvLFwiaFwiKS5yZXBsYWNlKC9zTmFtZSQvLFwic1wiKTtlbHNlIGlmKFwid2lkdGhcIiE9PWwmJlwiaGVpZ2h0XCIhPT1sJiZcImhyZWZcIiE9PWwmJlwibGlzdFwiIT09bCYmXCJmb3JtXCIhPT1sJiZcInRhYkluZGV4XCIhPT1sJiZcImRvd25sb2FkXCIhPT1sJiZsIGluIG4pdHJ5e25bbF09bnVsbD09dT9cIlwiOnU7YnJlYWsgbn1jYXRjaChuKXt9XCJmdW5jdGlvblwiPT10eXBlb2YgdXx8KG51bGw9PXV8fCExPT09dSYmLTE9PWwuaW5kZXhPZihcIi1cIik/bi5yZW1vdmVBdHRyaWJ1dGUobCk6bi5zZXRBdHRyaWJ1dGUobCx1KSk7fX1mdW5jdGlvbiBtJDEobil7dD0hMDt0cnl7cmV0dXJuIHRoaXMubFtuLnR5cGUrITFdKGwkMS5ldmVudD9sJDEuZXZlbnQobik6bil9ZmluYWxseXt0PSExO319ZnVuY3Rpb24gdyQyKG4pe3Q9ITA7dHJ5e3JldHVybiB0aGlzLmxbbi50eXBlKyEwXShsJDEuZXZlbnQ/bCQxLmV2ZW50KG4pOm4pfWZpbmFsbHl7dD0hMTt9fWZ1bmN0aW9uIHgkMShuLGwpe3RoaXMucHJvcHM9bix0aGlzLmNvbnRleHQ9bDt9ZnVuY3Rpb24gQShuLGwpe2lmKG51bGw9PWwpcmV0dXJuIG4uX18/QShuLl9fLG4uX18uX19rLmluZGV4T2YobikrMSk6bnVsbDtmb3IodmFyIHU7bDxuLl9fay5sZW5ndGg7bCsrKWlmKG51bGwhPSh1PW4uX19rW2xdKSYmbnVsbCE9dS5fX2UpcmV0dXJuIHUuX19lO3JldHVybiBcImZ1bmN0aW9uXCI9PXR5cGVvZiBuLnR5cGU/QShuKTpudWxsfWZ1bmN0aW9uIFAkMShuKXt2YXIgbCx1O2lmKG51bGwhPShuPW4uX18pJiZudWxsIT1uLl9fYyl7Zm9yKG4uX19lPW4uX19jLmJhc2U9bnVsbCxsPTA7bDxuLl9fay5sZW5ndGg7bCsrKWlmKG51bGwhPSh1PW4uX19rW2xdKSYmbnVsbCE9dS5fX2Upe24uX19lPW4uX19jLmJhc2U9dS5fX2U7YnJlYWt9cmV0dXJuIFAkMShuKX19ZnVuY3Rpb24gQyQxKG4pe3Q/c2V0VGltZW91dChuKTpmJDEobik7fWZ1bmN0aW9uIFQkMShuKXsoIW4uX19kJiYobi5fX2Q9ITApJiZyJDEucHVzaChuKSYmISQkMS5fX3IrK3x8byE9PWwkMS5kZWJvdW5jZVJlbmRlcmluZykmJigobz1sJDEuZGVib3VuY2VSZW5kZXJpbmcpfHxDJDEpKCQkMSk7fWZ1bmN0aW9uICQkMSgpe3ZhciBuLGwsdSxpLHQsbyxmLGU7Zm9yKHIkMS5zb3J0KGZ1bmN0aW9uKG4sbCl7cmV0dXJuIG4uX192Ll9fYi1sLl9fdi5fX2J9KTtuPXIkMS5zaGlmdCgpOyluLl9fZCYmKGw9ciQxLmxlbmd0aCxpPXZvaWQgMCx0PXZvaWQgMCxmPShvPSh1PW4pLl9fdikuX19lLChlPXUuX19QKSYmKGk9W10sKHQ9aCh7fSxvKSkuX192PW8uX192KzEsTShlLG8sdCx1Ll9fbix2b2lkIDAhPT1lLm93bmVyU1ZHRWxlbWVudCxudWxsIT1vLl9faD9bZl06bnVsbCxpLG51bGw9PWY/QShvKTpmLG8uX19oKSxOKGksbyksby5fX2UhPWYmJlAkMShvKSksciQxLmxlbmd0aD5sJiZyJDEuc29ydChmdW5jdGlvbihuLGwpe3JldHVybiBuLl9fdi5fX2ItbC5fX3YuX19ifSkpOyQkMS5fX3I9MDt9ZnVuY3Rpb24gSCQxKG4sbCx1LGksdCxyLG8sZixlLGEpe3ZhciBoLHYseSxkLGssYixnLG09aSYmaS5fX2t8fHMsdz1tLmxlbmd0aDtmb3IodS5fX2s9W10saD0wO2g8bC5sZW5ndGg7aCsrKWlmKG51bGwhPShkPXUuX19rW2hdPW51bGw9PShkPWxbaF0pfHxcImJvb2xlYW5cIj09dHlwZW9mIGQ/bnVsbDpcInN0cmluZ1wiPT10eXBlb2YgZHx8XCJudW1iZXJcIj09dHlwZW9mIGR8fFwiYmlnaW50XCI9PXR5cGVvZiBkP3AobnVsbCxkLG51bGwsbnVsbCxkKTpBcnJheS5pc0FycmF5KGQpP3AoXyx7Y2hpbGRyZW46ZH0sbnVsbCxudWxsLG51bGwpOmQuX19iPjA/cChkLnR5cGUsZC5wcm9wcyxkLmtleSxkLnJlZj9kLnJlZjpudWxsLGQuX192KTpkKSl7aWYoZC5fXz11LGQuX19iPXUuX19iKzEsbnVsbD09PSh5PW1baF0pfHx5JiZkLmtleT09eS5rZXkmJmQudHlwZT09PXkudHlwZSltW2hdPXZvaWQgMDtlbHNlIGZvcih2PTA7djx3O3YrKyl7aWYoKHk9bVt2XSkmJmQua2V5PT15LmtleSYmZC50eXBlPT09eS50eXBlKXttW3ZdPXZvaWQgMDticmVha315PW51bGw7fU0obixkLHk9eXx8YyQxLHQscixvLGYsZSxhKSxrPWQuX19lLCh2PWQucmVmKSYmeS5yZWYhPXYmJihnfHwoZz1bXSkseS5yZWYmJmcucHVzaCh5LnJlZixudWxsLGQpLGcucHVzaCh2LGQuX19jfHxrLGQpKSxudWxsIT1rPyhudWxsPT1iJiYoYj1rKSxcImZ1bmN0aW9uXCI9PXR5cGVvZiBkLnR5cGUmJmQuX19rPT09eS5fX2s/ZC5fX2Q9ZT1JJDEoZCxlLG4pOmU9eiQxKG4sZCx5LG0sayxlKSxcImZ1bmN0aW9uXCI9PXR5cGVvZiB1LnR5cGUmJih1Ll9fZD1lKSk6ZSYmeS5fX2U9PWUmJmUucGFyZW50Tm9kZSE9biYmKGU9QSh5KSk7fWZvcih1Ll9fZT1iLGg9dztoLS07KW51bGwhPW1baF0mJihcImZ1bmN0aW9uXCI9PXR5cGVvZiB1LnR5cGUmJm51bGwhPW1baF0uX19lJiZtW2hdLl9fZT09dS5fX2QmJih1Ll9fZD1MJDEoaSkubmV4dFNpYmxpbmcpLHEobVtoXSxtW2hdKSk7aWYoZylmb3IoaD0wO2g8Zy5sZW5ndGg7aCsrKVMoZ1toXSxnWysraF0sZ1srK2hdKTt9ZnVuY3Rpb24gSSQxKG4sbCx1KXtmb3IodmFyIGksdD1uLl9fayxyPTA7dCYmcjx0Lmxlbmd0aDtyKyspKGk9dFtyXSkmJihpLl9fPW4sbD1cImZ1bmN0aW9uXCI9PXR5cGVvZiBpLnR5cGU/SSQxKGksbCx1KTp6JDEodSxpLGksdCxpLl9fZSxsKSk7cmV0dXJuIGx9ZnVuY3Rpb24gaiQyKG4sbCl7cmV0dXJuIGw9bHx8W10sbnVsbD09bnx8XCJib29sZWFuXCI9PXR5cGVvZiBufHwoQXJyYXkuaXNBcnJheShuKT9uLnNvbWUoZnVuY3Rpb24obil7aiQyKG4sbCk7fSk6bC5wdXNoKG4pKSxsfWZ1bmN0aW9uIHokMShuLGwsdSxpLHQscil7dmFyIG8sZixlO2lmKHZvaWQgMCE9PWwuX19kKW89bC5fX2QsbC5fX2Q9dm9pZCAwO2Vsc2UgaWYobnVsbD09dXx8dCE9cnx8bnVsbD09dC5wYXJlbnROb2RlKW46aWYobnVsbD09cnx8ci5wYXJlbnROb2RlIT09biluLmFwcGVuZENoaWxkKHQpLG89bnVsbDtlbHNlIHtmb3IoZj1yLGU9MDsoZj1mLm5leHRTaWJsaW5nKSYmZTxpLmxlbmd0aDtlKz0xKWlmKGY9PXQpYnJlYWsgbjtuLmluc2VydEJlZm9yZSh0LHIpLG89cjt9cmV0dXJuIHZvaWQgMCE9PW8/bzp0Lm5leHRTaWJsaW5nfWZ1bmN0aW9uIEwkMShuKXt2YXIgbCx1LGk7aWYobnVsbD09bi50eXBlfHxcInN0cmluZ1wiPT10eXBlb2Ygbi50eXBlKXJldHVybiBuLl9fZTtpZihuLl9faylmb3IobD1uLl9fay5sZW5ndGgtMTtsPj0wO2wtLSlpZigodT1uLl9fa1tsXSkmJihpPUwkMSh1KSkpcmV0dXJuIGk7cmV0dXJuIG51bGx9ZnVuY3Rpb24gTShuLHUsaSx0LHIsbyxmLGUsYyl7dmFyIHMsYSx2LHkscCxkLGssYixnLG0sdyxBLFAsQyxULCQ9dS50eXBlO2lmKHZvaWQgMCE9PXUuY29uc3RydWN0b3IpcmV0dXJuIG51bGw7bnVsbCE9aS5fX2gmJihjPWkuX19oLGU9dS5fX2U9aS5fX2UsdS5fX2g9bnVsbCxvPVtlXSksKHM9bCQxLl9fYikmJnModSk7dHJ5e246aWYoXCJmdW5jdGlvblwiPT10eXBlb2YgJCl7aWYoYj11LnByb3BzLGc9KHM9JC5jb250ZXh0VHlwZSkmJnRbcy5fX2NdLG09cz9nP2cucHJvcHMudmFsdWU6cy5fXzp0LGkuX19jP2s9KGE9dS5fX2M9aS5fX2MpLl9fPWEuX19FOihcInByb3RvdHlwZVwiaW4gJCYmJC5wcm90b3R5cGUucmVuZGVyP3UuX19jPWE9bmV3ICQoYixtKToodS5fX2M9YT1uZXcgeCQxKGIsbSksYS5jb25zdHJ1Y3Rvcj0kLGEucmVuZGVyPUIkMSksZyYmZy5zdWIoYSksYS5wcm9wcz1iLGEuc3RhdGV8fChhLnN0YXRlPXt9KSxhLmNvbnRleHQ9bSxhLl9fbj10LHY9YS5fX2Q9ITAsYS5fX2g9W10sYS5fc2I9W10pLG51bGw9PWEuX19zJiYoYS5fX3M9YS5zdGF0ZSksbnVsbCE9JC5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMmJihhLl9fcz09YS5zdGF0ZSYmKGEuX19zPWgoe30sYS5fX3MpKSxoKGEuX19zLCQuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKGIsYS5fX3MpKSkseT1hLnByb3BzLHA9YS5zdGF0ZSxhLl9fdj11LHYpbnVsbD09JC5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMmJm51bGwhPWEuY29tcG9uZW50V2lsbE1vdW50JiZhLmNvbXBvbmVudFdpbGxNb3VudCgpLG51bGwhPWEuY29tcG9uZW50RGlkTW91bnQmJmEuX19oLnB1c2goYS5jb21wb25lbnREaWRNb3VudCk7ZWxzZSB7aWYobnVsbD09JC5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMmJmIhPT15JiZudWxsIT1hLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMmJmEuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhiLG0pLCFhLl9fZSYmbnVsbCE9YS5zaG91bGRDb21wb25lbnRVcGRhdGUmJiExPT09YS5zaG91bGRDb21wb25lbnRVcGRhdGUoYixhLl9fcyxtKXx8dS5fX3Y9PT1pLl9fdil7Zm9yKHUuX192IT09aS5fX3YmJihhLnByb3BzPWIsYS5zdGF0ZT1hLl9fcyxhLl9fZD0hMSksdS5fX2U9aS5fX2UsdS5fX2s9aS5fX2ssdS5fX2suZm9yRWFjaChmdW5jdGlvbihuKXtuJiYobi5fXz11KTt9KSx3PTA7dzxhLl9zYi5sZW5ndGg7dysrKWEuX19oLnB1c2goYS5fc2Jbd10pO2EuX3NiPVtdLGEuX19oLmxlbmd0aCYmZi5wdXNoKGEpO2JyZWFrIG59bnVsbCE9YS5jb21wb25lbnRXaWxsVXBkYXRlJiZhLmNvbXBvbmVudFdpbGxVcGRhdGUoYixhLl9fcyxtKSxudWxsIT1hLmNvbXBvbmVudERpZFVwZGF0ZSYmYS5fX2gucHVzaChmdW5jdGlvbigpe2EuY29tcG9uZW50RGlkVXBkYXRlKHkscCxkKTt9KTt9aWYoYS5jb250ZXh0PW0sYS5wcm9wcz1iLGEuX19QPW4sQT1sJDEuX19yLFA9MCxcInByb3RvdHlwZVwiaW4gJCYmJC5wcm90b3R5cGUucmVuZGVyKXtmb3IoYS5zdGF0ZT1hLl9fcyxhLl9fZD0hMSxBJiZBKHUpLHM9YS5yZW5kZXIoYS5wcm9wcyxhLnN0YXRlLGEuY29udGV4dCksQz0wO0M8YS5fc2IubGVuZ3RoO0MrKylhLl9faC5wdXNoKGEuX3NiW0NdKTthLl9zYj1bXTt9ZWxzZSBkb3thLl9fZD0hMSxBJiZBKHUpLHM9YS5yZW5kZXIoYS5wcm9wcyxhLnN0YXRlLGEuY29udGV4dCksYS5zdGF0ZT1hLl9fczt9d2hpbGUoYS5fX2QmJisrUDwyNSk7YS5zdGF0ZT1hLl9fcyxudWxsIT1hLmdldENoaWxkQ29udGV4dCYmKHQ9aChoKHt9LHQpLGEuZ2V0Q2hpbGRDb250ZXh0KCkpKSx2fHxudWxsPT1hLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlfHwoZD1hLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlKHkscCkpLFQ9bnVsbCE9cyYmcy50eXBlPT09XyYmbnVsbD09cy5rZXk/cy5wcm9wcy5jaGlsZHJlbjpzLEgkMShuLEFycmF5LmlzQXJyYXkoVCk/VDpbVF0sdSxpLHQscixvLGYsZSxjKSxhLmJhc2U9dS5fX2UsdS5fX2g9bnVsbCxhLl9faC5sZW5ndGgmJmYucHVzaChhKSxrJiYoYS5fX0U9YS5fXz1udWxsKSxhLl9fZT0hMTt9ZWxzZSBudWxsPT1vJiZ1Ll9fdj09PWkuX192Pyh1Ll9faz1pLl9fayx1Ll9fZT1pLl9fZSk6dS5fX2U9TyhpLl9fZSx1LGksdCxyLG8sZixjKTsocz1sJDEuZGlmZmVkKSYmcyh1KTt9Y2F0Y2gobil7dS5fX3Y9bnVsbCwoY3x8bnVsbCE9bykmJih1Ll9fZT1lLHUuX19oPSEhYyxvW28uaW5kZXhPZihlKV09bnVsbCksbCQxLl9fZShuLHUsaSk7fX1mdW5jdGlvbiBOKG4sdSl7bCQxLl9fYyYmbCQxLl9fYyh1LG4pLG4uc29tZShmdW5jdGlvbih1KXt0cnl7bj11Ll9faCx1Ll9faD1bXSxuLnNvbWUoZnVuY3Rpb24obil7bi5jYWxsKHUpO30pO31jYXRjaChuKXtsJDEuX19lKG4sdS5fX3YpO319KTt9ZnVuY3Rpb24gTyhsLHUsaSx0LHIsbyxmLGUpe3ZhciBzLGEsaCx5PWkucHJvcHMscD11LnByb3BzLGQ9dS50eXBlLF89MDtpZihcInN2Z1wiPT09ZCYmKHI9ITApLG51bGwhPW8pZm9yKDtfPG8ubGVuZ3RoO18rKylpZigocz1vW19dKSYmXCJzZXRBdHRyaWJ1dGVcImluIHM9PSEhZCYmKGQ/cy5sb2NhbE5hbWU9PT1kOjM9PT1zLm5vZGVUeXBlKSl7bD1zLG9bX109bnVsbDticmVha31pZihudWxsPT1sKXtpZihudWxsPT09ZClyZXR1cm4gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUocCk7bD1yP2RvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsZCk6ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChkLHAuaXMmJnApLG89bnVsbCxlPSExO31pZihudWxsPT09ZCl5PT09cHx8ZSYmbC5kYXRhPT09cHx8KGwuZGF0YT1wKTtlbHNlIHtpZihvPW8mJm4uY2FsbChsLmNoaWxkTm9kZXMpLGE9KHk9aS5wcm9wc3x8YyQxKS5kYW5nZXJvdXNseVNldElubmVySFRNTCxoPXAuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwsIWUpe2lmKG51bGwhPW8pZm9yKHk9e30sXz0wO188bC5hdHRyaWJ1dGVzLmxlbmd0aDtfKyspeVtsLmF0dHJpYnV0ZXNbX10ubmFtZV09bC5hdHRyaWJ1dGVzW19dLnZhbHVlOyhofHxhKSYmKGgmJihhJiZoLl9faHRtbD09YS5fX2h0bWx8fGguX19odG1sPT09bC5pbm5lckhUTUwpfHwobC5pbm5lckhUTUw9aCYmaC5fX2h0bWx8fFwiXCIpKTt9aWYoayQxKGwscCx5LHIsZSksaCl1Ll9faz1bXTtlbHNlIGlmKF89dS5wcm9wcy5jaGlsZHJlbixIJDEobCxBcnJheS5pc0FycmF5KF8pP186W19dLHUsaSx0LHImJlwiZm9yZWlnbk9iamVjdFwiIT09ZCxvLGYsbz9vWzBdOmkuX19rJiZBKGksMCksZSksbnVsbCE9bylmb3IoXz1vLmxlbmd0aDtfLS07KW51bGwhPW9bX10mJnYkMShvW19dKTtlfHwoXCJ2YWx1ZVwiaW4gcCYmdm9pZCAwIT09KF89cC52YWx1ZSkmJihfIT09bC52YWx1ZXx8XCJwcm9ncmVzc1wiPT09ZCYmIV98fFwib3B0aW9uXCI9PT1kJiZfIT09eS52YWx1ZSkmJmckMihsLFwidmFsdWVcIixfLHkudmFsdWUsITEpLFwiY2hlY2tlZFwiaW4gcCYmdm9pZCAwIT09KF89cC5jaGVja2VkKSYmXyE9PWwuY2hlY2tlZCYmZyQyKGwsXCJjaGVja2VkXCIsXyx5LmNoZWNrZWQsITEpKTt9cmV0dXJuIGx9ZnVuY3Rpb24gUyhuLHUsaSl7dHJ5e1wiZnVuY3Rpb25cIj09dHlwZW9mIG4/bih1KTpuLmN1cnJlbnQ9dTt9Y2F0Y2gobil7bCQxLl9fZShuLGkpO319ZnVuY3Rpb24gcShuLHUsaSl7dmFyIHQscjtpZihsJDEudW5tb3VudCYmbCQxLnVubW91bnQobiksKHQ9bi5yZWYpJiYodC5jdXJyZW50JiZ0LmN1cnJlbnQhPT1uLl9fZXx8Uyh0LG51bGwsdSkpLG51bGwhPSh0PW4uX19jKSl7aWYodC5jb21wb25lbnRXaWxsVW5tb3VudCl0cnl7dC5jb21wb25lbnRXaWxsVW5tb3VudCgpO31jYXRjaChuKXtsJDEuX19lKG4sdSk7fXQuYmFzZT10Ll9fUD1udWxsLG4uX19jPXZvaWQgMDt9aWYodD1uLl9faylmb3Iocj0wO3I8dC5sZW5ndGg7cisrKXRbcl0mJnEodFtyXSx1LGl8fFwiZnVuY3Rpb25cIiE9dHlwZW9mIG4udHlwZSk7aXx8bnVsbD09bi5fX2V8fHYkMShuLl9fZSksbi5fXz1uLl9fZT1uLl9fZD12b2lkIDA7fWZ1bmN0aW9uIEIkMShuLGwsdSl7cmV0dXJuIHRoaXMuY29uc3RydWN0b3Iobix1KX1mdW5jdGlvbiBEJDEodSxpLHQpe3ZhciByLG8sZjtsJDEuX18mJmwkMS5fXyh1LGkpLG89KHI9XCJmdW5jdGlvblwiPT10eXBlb2YgdCk/bnVsbDp0JiZ0Ll9fa3x8aS5fX2ssZj1bXSxNKGksdT0oIXImJnR8fGkpLl9faz15KF8sbnVsbCxbdV0pLG98fGMkMSxjJDEsdm9pZCAwIT09aS5vd25lclNWR0VsZW1lbnQsIXImJnQ/W3RdOm8/bnVsbDppLmZpcnN0Q2hpbGQ/bi5jYWxsKGkuY2hpbGROb2Rlcyk6bnVsbCxmLCFyJiZ0P3Q6bz9vLl9fZTppLmZpcnN0Q2hpbGQsciksTihmLHUpO31mdW5jdGlvbiBFKG4sbCl7RCQxKG4sbCxFKTt9ZnVuY3Rpb24gRiQxKGwsdSxpKXt2YXIgdCxyLG8sZj1oKHt9LGwucHJvcHMpO2ZvcihvIGluIHUpXCJrZXlcIj09bz90PXVbb106XCJyZWZcIj09bz9yPXVbb106ZltvXT11W29dO3JldHVybiBhcmd1bWVudHMubGVuZ3RoPjImJihmLmNoaWxkcmVuPWFyZ3VtZW50cy5sZW5ndGg+Mz9uLmNhbGwoYXJndW1lbnRzLDIpOmkpLHAobC50eXBlLGYsdHx8bC5rZXkscnx8bC5yZWYsbnVsbCl9ZnVuY3Rpb24gRyQxKG4sbCl7dmFyIHU9e19fYzpsPVwiX19jQ1wiK2UkMSsrLF9fOm4sQ29uc3VtZXI6ZnVuY3Rpb24obixsKXtyZXR1cm4gbi5jaGlsZHJlbihsKX0sUHJvdmlkZXI6ZnVuY3Rpb24obil7dmFyIHUsaTtyZXR1cm4gdGhpcy5nZXRDaGlsZENvbnRleHR8fCh1PVtdLChpPXt9KVtsXT10aGlzLHRoaXMuZ2V0Q2hpbGRDb250ZXh0PWZ1bmN0aW9uKCl7cmV0dXJuIGl9LHRoaXMuc2hvdWxkQ29tcG9uZW50VXBkYXRlPWZ1bmN0aW9uKG4pe3RoaXMucHJvcHMudmFsdWUhPT1uLnZhbHVlJiZ1LnNvbWUoZnVuY3Rpb24obil7bi5fX2U9ITAsVCQxKG4pO30pO30sdGhpcy5zdWI9ZnVuY3Rpb24obil7dS5wdXNoKG4pO3ZhciBsPW4uY29tcG9uZW50V2lsbFVubW91bnQ7bi5jb21wb25lbnRXaWxsVW5tb3VudD1mdW5jdGlvbigpe3Uuc3BsaWNlKHUuaW5kZXhPZihuKSwxKSxsJiZsLmNhbGwobik7fTt9KSxuLmNoaWxkcmVufX07cmV0dXJuIHUuUHJvdmlkZXIuX189dS5Db25zdW1lci5jb250ZXh0VHlwZT11fW49cy5zbGljZSxsJDE9e19fZTpmdW5jdGlvbihuLGwsdSxpKXtmb3IodmFyIHQscixvO2w9bC5fXzspaWYoKHQ9bC5fX2MpJiYhdC5fXyl0cnl7aWYoKHI9dC5jb25zdHJ1Y3RvcikmJm51bGwhPXIuZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yJiYodC5zZXRTdGF0ZShyLmdldERlcml2ZWRTdGF0ZUZyb21FcnJvcihuKSksbz10Ll9fZCksbnVsbCE9dC5jb21wb25lbnREaWRDYXRjaCYmKHQuY29tcG9uZW50RGlkQ2F0Y2gobixpfHx7fSksbz10Ll9fZCksbylyZXR1cm4gdC5fX0U9dH1jYXRjaChsKXtuPWw7fXRocm93IG59fSx1JDE9MCxpJDE9ZnVuY3Rpb24obil7cmV0dXJuIG51bGwhPW4mJnZvaWQgMD09PW4uY29uc3RydWN0b3J9LHQ9ITEseCQxLnByb3RvdHlwZS5zZXRTdGF0ZT1mdW5jdGlvbihuLGwpe3ZhciB1O3U9bnVsbCE9dGhpcy5fX3MmJnRoaXMuX19zIT09dGhpcy5zdGF0ZT90aGlzLl9fczp0aGlzLl9fcz1oKHt9LHRoaXMuc3RhdGUpLFwiZnVuY3Rpb25cIj09dHlwZW9mIG4mJihuPW4oaCh7fSx1KSx0aGlzLnByb3BzKSksbiYmaCh1LG4pLG51bGwhPW4mJnRoaXMuX192JiYobCYmdGhpcy5fc2IucHVzaChsKSxUJDEodGhpcykpO30seCQxLnByb3RvdHlwZS5mb3JjZVVwZGF0ZT1mdW5jdGlvbihuKXt0aGlzLl9fdiYmKHRoaXMuX19lPSEwLG4mJnRoaXMuX19oLnB1c2gobiksVCQxKHRoaXMpKTt9LHgkMS5wcm90b3R5cGUucmVuZGVyPV8sciQxPVtdLGYkMT1cImZ1bmN0aW9uXCI9PXR5cGVvZiBQcm9taXNlP1Byb21pc2UucHJvdG90eXBlLnRoZW4uYmluZChQcm9taXNlLnJlc29sdmUoKSk6c2V0VGltZW91dCwkJDEuX19yPTAsZSQxPTA7XHJcblxyXG4gICAgdmFyIHIsdSxpLGY9W10sYz1bXSxlPWwkMS5fX2IsYT1sJDEuX19yLHY9bCQxLmRpZmZlZCxsPWwkMS5fX2MsbT1sJDEudW5tb3VudDtmdW5jdGlvbiBiKCl7Zm9yKHZhciB0O3Q9Zi5zaGlmdCgpOylpZih0Ll9fUCYmdC5fX0gpdHJ5e3QuX19ILl9faC5mb3JFYWNoKGspLHQuX19ILl9faC5mb3JFYWNoKHckMSksdC5fX0guX19oPVtdO31jYXRjaChyKXt0Ll9fSC5fX2g9W10sbCQxLl9fZShyLHQuX192KTt9fWwkMS5fX2I9ZnVuY3Rpb24obil7cj1udWxsLGUmJmUobik7fSxsJDEuX19yPWZ1bmN0aW9uKG4pe2EmJmEobik7dmFyIGk9KHI9bi5fX2MpLl9fSDtpJiYodT09PXI/KGkuX19oPVtdLHIuX19oPVtdLGkuX18uZm9yRWFjaChmdW5jdGlvbihuKXtuLl9fTiYmKG4uX189bi5fX04pLG4uX19WPWMsbi5fX049bi5pPXZvaWQgMDt9KSk6KGkuX19oLmZvckVhY2goayksaS5fX2guZm9yRWFjaCh3JDEpLGkuX19oPVtdKSksdT1yO30sbCQxLmRpZmZlZD1mdW5jdGlvbih0KXt2JiZ2KHQpO3ZhciBvPXQuX19jO28mJm8uX19IJiYoby5fX0guX19oLmxlbmd0aCYmKDEhPT1mLnB1c2gobykmJmk9PT1sJDEucmVxdWVzdEFuaW1hdGlvbkZyYW1lfHwoKGk9bCQxLnJlcXVlc3RBbmltYXRpb25GcmFtZSl8fGokMSkoYikpLG8uX19ILl9fLmZvckVhY2goZnVuY3Rpb24obil7bi5pJiYobi5fX0g9bi5pKSxuLl9fViE9PWMmJihuLl9fPW4uX19WKSxuLmk9dm9pZCAwLG4uX19WPWM7fSkpLHU9cj1udWxsO30sbCQxLl9fYz1mdW5jdGlvbih0LHIpe3Iuc29tZShmdW5jdGlvbih0KXt0cnl7dC5fX2guZm9yRWFjaChrKSx0Ll9faD10Ll9faC5maWx0ZXIoZnVuY3Rpb24obil7cmV0dXJuICFuLl9ffHx3JDEobil9KTt9Y2F0Y2godSl7ci5zb21lKGZ1bmN0aW9uKG4pe24uX19oJiYobi5fX2g9W10pO30pLHI9W10sbCQxLl9fZSh1LHQuX192KTt9fSksbCYmbCh0LHIpO30sbCQxLnVubW91bnQ9ZnVuY3Rpb24odCl7bSYmbSh0KTt2YXIgcix1PXQuX19jO3UmJnUuX19IJiYodS5fX0guX18uZm9yRWFjaChmdW5jdGlvbihuKXt0cnl7ayhuKTt9Y2F0Y2gobil7cj1uO319KSx1Ll9fSD12b2lkIDAsciYmbCQxLl9fZShyLHUuX192KSk7fTt2YXIgZyQxPVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVlc3RBbmltYXRpb25GcmFtZTtmdW5jdGlvbiBqJDEobil7dmFyIHQscj1mdW5jdGlvbigpe2NsZWFyVGltZW91dCh1KSxnJDEmJmNhbmNlbEFuaW1hdGlvbkZyYW1lKHQpLHNldFRpbWVvdXQobik7fSx1PXNldFRpbWVvdXQociwxMDApO2ckMSYmKHQ9cmVxdWVzdEFuaW1hdGlvbkZyYW1lKHIpKTt9ZnVuY3Rpb24gayhuKXt2YXIgdD1yLHU9bi5fX2M7XCJmdW5jdGlvblwiPT10eXBlb2YgdSYmKG4uX19jPXZvaWQgMCx1KCkpLHI9dDt9ZnVuY3Rpb24gdyQxKG4pe3ZhciB0PXI7bi5fX2M9bi5fXygpLHI9dDt9XHJcblxyXG4gICAgZnVuY3Rpb24gZyhuLHQpe2Zvcih2YXIgZSBpbiB0KW5bZV09dFtlXTtyZXR1cm4gbn1mdW5jdGlvbiBDKG4sdCl7Zm9yKHZhciBlIGluIG4paWYoXCJfX3NvdXJjZVwiIT09ZSYmIShlIGluIHQpKXJldHVybiAhMDtmb3IodmFyIHIgaW4gdClpZihcIl9fc291cmNlXCIhPT1yJiZuW3JdIT09dFtyXSlyZXR1cm4gITA7cmV0dXJuICExfWZ1bmN0aW9uIHcobil7dGhpcy5wcm9wcz1uO30ody5wcm90b3R5cGU9bmV3IHgkMSkuaXNQdXJlUmVhY3RDb21wb25lbnQ9ITAsdy5wcm90b3R5cGUuc2hvdWxkQ29tcG9uZW50VXBkYXRlPWZ1bmN0aW9uKG4sdCl7cmV0dXJuIEModGhpcy5wcm9wcyxuKXx8Qyh0aGlzLnN0YXRlLHQpfTt2YXIgeD1sJDEuX19iO2wkMS5fX2I9ZnVuY3Rpb24obil7bi50eXBlJiZuLnR5cGUuX19mJiZuLnJlZiYmKG4ucHJvcHMucmVmPW4ucmVmLG4ucmVmPW51bGwpLHgmJngobik7fTt2YXIgVD1sJDEuX19lO2wkMS5fX2U9ZnVuY3Rpb24obix0LGUscil7aWYobi50aGVuKWZvcih2YXIgdSxvPXQ7bz1vLl9fOylpZigodT1vLl9fYykmJnUuX19jKXJldHVybiBudWxsPT10Ll9fZSYmKHQuX19lPWUuX19lLHQuX19rPWUuX19rKSx1Ll9fYyhuLHQpO1Qobix0LGUscik7fTt2YXIgST1sJDEudW5tb3VudDtmdW5jdGlvbiBMKG4sdCxlKXtyZXR1cm4gbiYmKG4uX19jJiZuLl9fYy5fX0gmJihuLl9fYy5fX0guX18uZm9yRWFjaChmdW5jdGlvbihuKXtcImZ1bmN0aW9uXCI9PXR5cGVvZiBuLl9fYyYmbi5fX2MoKTt9KSxuLl9fYy5fX0g9bnVsbCksbnVsbCE9KG49Zyh7fSxuKSkuX19jJiYobi5fX2MuX19QPT09ZSYmKG4uX19jLl9fUD10KSxuLl9fYz1udWxsKSxuLl9faz1uLl9fayYmbi5fX2subWFwKGZ1bmN0aW9uKG4pe3JldHVybiBMKG4sdCxlKX0pKSxufWZ1bmN0aW9uIFUobix0LGUpe3JldHVybiBuJiYobi5fX3Y9bnVsbCxuLl9faz1uLl9fayYmbi5fX2subWFwKGZ1bmN0aW9uKG4pe3JldHVybiBVKG4sdCxlKX0pLG4uX19jJiZuLl9fYy5fX1A9PT10JiYobi5fX2UmJmUuaW5zZXJ0QmVmb3JlKG4uX19lLG4uX19kKSxuLl9fYy5fX2U9ITAsbi5fX2MuX19QPWUpKSxufWZ1bmN0aW9uIEQoKXt0aGlzLl9fdT0wLHRoaXMudD1udWxsLHRoaXMuX19iPW51bGw7fWZ1bmN0aW9uIEYobil7dmFyIHQ9bi5fXy5fX2M7cmV0dXJuIHQmJnQuX19hJiZ0Ll9fYShuKX1mdW5jdGlvbiBWKCl7dGhpcy51PW51bGwsdGhpcy5vPW51bGw7fWwkMS51bm1vdW50PWZ1bmN0aW9uKG4pe3ZhciB0PW4uX19jO3QmJnQuX19SJiZ0Ll9fUigpLHQmJiEwPT09bi5fX2gmJihuLnR5cGU9bnVsbCksSSYmSShuKTt9LChELnByb3RvdHlwZT1uZXcgeCQxKS5fX2M9ZnVuY3Rpb24obix0KXt2YXIgZT10Ll9fYyxyPXRoaXM7bnVsbD09ci50JiYoci50PVtdKSxyLnQucHVzaChlKTt2YXIgdT1GKHIuX192KSxvPSExLGk9ZnVuY3Rpb24oKXtvfHwobz0hMCxlLl9fUj1udWxsLHU/dShsKTpsKCkpO307ZS5fX1I9aTt2YXIgbD1mdW5jdGlvbigpe2lmKCEtLXIuX191KXtpZihyLnN0YXRlLl9fYSl7dmFyIG49ci5zdGF0ZS5fX2E7ci5fX3YuX19rWzBdPVUobixuLl9fYy5fX1Asbi5fX2MuX19PKTt9dmFyIHQ7Zm9yKHIuc2V0U3RhdGUoe19fYTpyLl9fYj1udWxsfSk7dD1yLnQucG9wKCk7KXQuZm9yY2VVcGRhdGUoKTt9fSxjPSEwPT09dC5fX2g7ci5fX3UrK3x8Y3x8ci5zZXRTdGF0ZSh7X19hOnIuX19iPXIuX192Ll9fa1swXX0pLG4udGhlbihpLGkpO30sRC5wcm90b3R5cGUuY29tcG9uZW50V2lsbFVubW91bnQ9ZnVuY3Rpb24oKXt0aGlzLnQ9W107fSxELnByb3RvdHlwZS5yZW5kZXI9ZnVuY3Rpb24obixlKXtpZih0aGlzLl9fYil7aWYodGhpcy5fX3YuX19rKXt2YXIgcj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLG89dGhpcy5fX3YuX19rWzBdLl9fYzt0aGlzLl9fdi5fX2tbMF09TCh0aGlzLl9fYixyLG8uX19PPW8uX19QKTt9dGhpcy5fX2I9bnVsbDt9dmFyIGk9ZS5fX2EmJnkoXyxudWxsLG4uZmFsbGJhY2spO3JldHVybiBpJiYoaS5fX2g9bnVsbCksW3koXyxudWxsLGUuX19hP251bGw6bi5jaGlsZHJlbiksaV19O3ZhciBXPWZ1bmN0aW9uKG4sdCxlKXtpZigrK2VbMV09PT1lWzBdJiZuLm8uZGVsZXRlKHQpLG4ucHJvcHMucmV2ZWFsT3JkZXImJihcInRcIiE9PW4ucHJvcHMucmV2ZWFsT3JkZXJbMF18fCFuLm8uc2l6ZSkpZm9yKGU9bi51O2U7KXtmb3IoO2UubGVuZ3RoPjM7KWUucG9wKCkoKTtpZihlWzFdPGVbMF0pYnJlYWs7bi51PWU9ZVsyXTt9fTtmdW5jdGlvbiBQKG4pe3JldHVybiB0aGlzLmdldENoaWxkQ29udGV4dD1mdW5jdGlvbigpe3JldHVybiBuLmNvbnRleHR9LG4uY2hpbGRyZW59ZnVuY3Rpb24gJChuKXt2YXIgZT10aGlzLHI9bi5pO2UuY29tcG9uZW50V2lsbFVubW91bnQ9ZnVuY3Rpb24oKXtEJDEobnVsbCxlLmwpLGUubD1udWxsLGUuaT1udWxsO30sZS5pJiZlLmkhPT1yJiZlLmNvbXBvbmVudFdpbGxVbm1vdW50KCksbi5fX3Y/KGUubHx8KGUuaT1yLGUubD17bm9kZVR5cGU6MSxwYXJlbnROb2RlOnIsY2hpbGROb2RlczpbXSxhcHBlbmRDaGlsZDpmdW5jdGlvbihuKXt0aGlzLmNoaWxkTm9kZXMucHVzaChuKSxlLmkuYXBwZW5kQ2hpbGQobik7fSxpbnNlcnRCZWZvcmU6ZnVuY3Rpb24obix0KXt0aGlzLmNoaWxkTm9kZXMucHVzaChuKSxlLmkuYXBwZW5kQ2hpbGQobik7fSxyZW1vdmVDaGlsZDpmdW5jdGlvbihuKXt0aGlzLmNoaWxkTm9kZXMuc3BsaWNlKHRoaXMuY2hpbGROb2Rlcy5pbmRleE9mKG4pPj4+MSwxKSxlLmkucmVtb3ZlQ2hpbGQobik7fX0pLEQkMSh5KFAse2NvbnRleHQ6ZS5jb250ZXh0fSxuLl9fdiksZS5sKSk6ZS5sJiZlLmNvbXBvbmVudFdpbGxVbm1vdW50KCk7fWZ1bmN0aW9uIGoobixlKXt2YXIgcj15KCQse19fdjpuLGk6ZX0pO3JldHVybiByLmNvbnRhaW5lckluZm89ZSxyfShWLnByb3RvdHlwZT1uZXcgeCQxKS5fX2E9ZnVuY3Rpb24obil7dmFyIHQ9dGhpcyxlPUYodC5fX3YpLHI9dC5vLmdldChuKTtyZXR1cm4gclswXSsrLGZ1bmN0aW9uKHUpe3ZhciBvPWZ1bmN0aW9uKCl7dC5wcm9wcy5yZXZlYWxPcmRlcj8oci5wdXNoKHUpLFcodCxuLHIpKTp1KCk7fTtlP2Uobyk6bygpO319LFYucHJvdG90eXBlLnJlbmRlcj1mdW5jdGlvbihuKXt0aGlzLnU9bnVsbCx0aGlzLm89bmV3IE1hcDt2YXIgdD1qJDIobi5jaGlsZHJlbik7bi5yZXZlYWxPcmRlciYmXCJiXCI9PT1uLnJldmVhbE9yZGVyWzBdJiZ0LnJldmVyc2UoKTtmb3IodmFyIGU9dC5sZW5ndGg7ZS0tOyl0aGlzLm8uc2V0KHRbZV0sdGhpcy51PVsxLDAsdGhpcy51XSk7cmV0dXJuIG4uY2hpbGRyZW59LFYucHJvdG90eXBlLmNvbXBvbmVudERpZFVwZGF0ZT1WLnByb3RvdHlwZS5jb21wb25lbnREaWRNb3VudD1mdW5jdGlvbigpe3ZhciBuPXRoaXM7dGhpcy5vLmZvckVhY2goZnVuY3Rpb24odCxlKXtXKG4sZSx0KTt9KTt9O3ZhciB6PVwidW5kZWZpbmVkXCIhPXR5cGVvZiBTeW1ib2wmJlN5bWJvbC5mb3ImJlN5bWJvbC5mb3IoXCJyZWFjdC5lbGVtZW50XCIpfHw2MDEwMyxCPS9eKD86YWNjZW50fGFsaWdubWVudHxhcmFiaWN8YmFzZWxpbmV8Y2FwfGNsaXAoPyFQYXRoVSl8Y29sb3J8ZG9taW5hbnR8ZmlsbHxmbG9vZHxmb250fGdseXBoKD8hUil8aG9yaXp8aW1hZ2V8bGV0dGVyfGxpZ2h0aW5nfG1hcmtlcig/IUh8V3xVKXxvdmVybGluZXxwYWludHxwb2ludGVyfHNoYXBlfHN0b3B8c3RyaWtldGhyb3VnaHxzdHJva2V8dGV4dCg/IUwpfHRyYW5zZm9ybXx1bmRlcmxpbmV8dW5pY29kZXx1bml0c3x2fHZlY3Rvcnx2ZXJ0fHdvcmR8d3JpdGluZ3x4KD8hQykpW0EtWl0vLEg9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGRvY3VtZW50LFo9ZnVuY3Rpb24obil7cmV0dXJuIChcInVuZGVmaW5lZFwiIT10eXBlb2YgU3ltYm9sJiZcInN5bWJvbFwiPT10eXBlb2YgU3ltYm9sKCk/L2ZpbHxjaGV8cmFkL2k6L2ZpbHxjaGV8cmEvaSkudGVzdChuKX07eCQxLnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50PXt9LFtcImNvbXBvbmVudFdpbGxNb3VudFwiLFwiY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1wiLFwiY29tcG9uZW50V2lsbFVwZGF0ZVwiXS5mb3JFYWNoKGZ1bmN0aW9uKHQpe09iamVjdC5kZWZpbmVQcm9wZXJ0eSh4JDEucHJvdG90eXBlLHQse2NvbmZpZ3VyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc1tcIlVOU0FGRV9cIit0XX0sc2V0OmZ1bmN0aW9uKG4pe09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLHQse2NvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpufSk7fX0pO30pO3ZhciBHPWwkMS5ldmVudDtmdW5jdGlvbiBKKCl7fWZ1bmN0aW9uIEsoKXtyZXR1cm4gdGhpcy5jYW5jZWxCdWJibGV9ZnVuY3Rpb24gUSgpe3JldHVybiB0aGlzLmRlZmF1bHRQcmV2ZW50ZWR9bCQxLmV2ZW50PWZ1bmN0aW9uKG4pe3JldHVybiBHJiYobj1HKG4pKSxuLnBlcnNpc3Q9SixuLmlzUHJvcGFnYXRpb25TdG9wcGVkPUssbi5pc0RlZmF1bHRQcmV2ZW50ZWQ9USxuLm5hdGl2ZUV2ZW50PW59O3ZhciBubj17Y29uZmlndXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNsYXNzfX0sdG49bCQxLnZub2RlO2wkMS52bm9kZT1mdW5jdGlvbihuKXt2YXIgdD1uLnR5cGUsZT1uLnByb3BzLHU9ZTtpZihcInN0cmluZ1wiPT10eXBlb2YgdCl7dmFyIG89LTE9PT10LmluZGV4T2YoXCItXCIpO2Zvcih2YXIgaSBpbiB1PXt9LGUpe3ZhciBsPWVbaV07SCYmXCJjaGlsZHJlblwiPT09aSYmXCJub3NjcmlwdFwiPT09dHx8XCJ2YWx1ZVwiPT09aSYmXCJkZWZhdWx0VmFsdWVcImluIGUmJm51bGw9PWx8fChcImRlZmF1bHRWYWx1ZVwiPT09aSYmXCJ2YWx1ZVwiaW4gZSYmbnVsbD09ZS52YWx1ZT9pPVwidmFsdWVcIjpcImRvd25sb2FkXCI9PT1pJiYhMD09PWw/bD1cIlwiOi9vbmRvdWJsZWNsaWNrL2kudGVzdChpKT9pPVwib25kYmxjbGlja1wiOi9eb25jaGFuZ2UodGV4dGFyZWF8aW5wdXQpL2kudGVzdChpK3QpJiYhWihlLnR5cGUpP2k9XCJvbmlucHV0XCI6L15vbmZvY3VzJC9pLnRlc3QoaSk/aT1cIm9uZm9jdXNpblwiOi9eb25ibHVyJC9pLnRlc3QoaSk/aT1cIm9uZm9jdXNvdXRcIjovXm9uKEFuaXxUcmF8VG91fEJlZm9yZUlucHxDb21wbykvLnRlc3QoaSk/aT1pLnRvTG93ZXJDYXNlKCk6byYmQi50ZXN0KGkpP2k9aS5yZXBsYWNlKC9bQS1aMC05XS9nLFwiLSQmXCIpLnRvTG93ZXJDYXNlKCk6bnVsbD09PWwmJihsPXZvaWQgMCksL15vbmlucHV0JC9pLnRlc3QoaSkmJihpPWkudG9Mb3dlckNhc2UoKSx1W2ldJiYoaT1cIm9uaW5wdXRDYXB0dXJlXCIpKSx1W2ldPWwpO31cInNlbGVjdFwiPT10JiZ1Lm11bHRpcGxlJiZBcnJheS5pc0FycmF5KHUudmFsdWUpJiYodS52YWx1ZT1qJDIoZS5jaGlsZHJlbikuZm9yRWFjaChmdW5jdGlvbihuKXtuLnByb3BzLnNlbGVjdGVkPS0xIT11LnZhbHVlLmluZGV4T2Yobi5wcm9wcy52YWx1ZSk7fSkpLFwic2VsZWN0XCI9PXQmJm51bGwhPXUuZGVmYXVsdFZhbHVlJiYodS52YWx1ZT1qJDIoZS5jaGlsZHJlbikuZm9yRWFjaChmdW5jdGlvbihuKXtuLnByb3BzLnNlbGVjdGVkPXUubXVsdGlwbGU/LTEhPXUuZGVmYXVsdFZhbHVlLmluZGV4T2Yobi5wcm9wcy52YWx1ZSk6dS5kZWZhdWx0VmFsdWU9PW4ucHJvcHMudmFsdWU7fSkpLG4ucHJvcHM9dSxlLmNsYXNzIT1lLmNsYXNzTmFtZSYmKG5uLmVudW1lcmFibGU9XCJjbGFzc05hbWVcImluIGUsbnVsbCE9ZS5jbGFzc05hbWUmJih1LmNsYXNzPWUuY2xhc3NOYW1lKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodSxcImNsYXNzTmFtZVwiLG5uKSk7fW4uJCR0eXBlb2Y9eix0biYmdG4obik7fTt2YXIgZW49bCQxLl9fcjtsJDEuX19yPWZ1bmN0aW9uKG4pe2VuJiZlbihuKSxuLl9fYzt9O1xyXG5cclxuICAgIGNvbnN0IHN0eWxlVGV4dHMgPSBbXTtcclxuICAgIGNvbnN0IHN0eWxlRWxzID0gbmV3IE1hcCgpO1xyXG4gICAgZnVuY3Rpb24gaW5qZWN0U3R5bGVzKHN0eWxlVGV4dCkge1xyXG4gICAgICAgIHN0eWxlVGV4dHMucHVzaChzdHlsZVRleHQpO1xyXG4gICAgICAgIHN0eWxlRWxzLmZvckVhY2goKHN0eWxlRWwpID0+IHtcclxuICAgICAgICAgICAgYXBwZW5kU3R5bGVzVG8oc3R5bGVFbCwgc3R5bGVUZXh0KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGVuc3VyZUVsSGFzU3R5bGVzKGVsKSB7XHJcbiAgICAgICAgaWYgKGVsLmlzQ29ubmVjdGVkKSB7XHJcbiAgICAgICAgICAgIHJlZ2lzdGVyU3R5bGVzUm9vdChlbC5nZXRSb290Tm9kZSgpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiByZWdpc3RlclN0eWxlc1Jvb3Qocm9vdE5vZGUpIHtcclxuICAgICAgICBsZXQgc3R5bGVFbCA9IHN0eWxlRWxzLmdldChyb290Tm9kZSk7XHJcbiAgICAgICAgaWYgKCFzdHlsZUVsIHx8ICFzdHlsZUVsLmlzQ29ubmVjdGVkKSB7XHJcbiAgICAgICAgICAgIHN0eWxlRWwgPSByb290Tm9kZS5xdWVyeVNlbGVjdG9yKCdzdHlsZVtkYXRhLWZ1bGxjYWxlbmRhcl0nKTtcclxuICAgICAgICAgICAgaWYgKCFzdHlsZUVsKSB7XHJcbiAgICAgICAgICAgICAgICBzdHlsZUVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcclxuICAgICAgICAgICAgICAgIHN0eWxlRWwuc2V0QXR0cmlidXRlKCdkYXRhLWZ1bGxjYWxlbmRhcicsICcnKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5vbmNlID0gZ2V0Tm9uY2VWYWx1ZSgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG5vbmNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVFbC5ub25jZSA9IG5vbmNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29uc3QgcGFyZW50RWwgPSByb290Tm9kZSA9PT0gZG9jdW1lbnQgPyBkb2N1bWVudC5oZWFkIDogcm9vdE5vZGU7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBpbnNlcnRCZWZvcmUgPSByb290Tm9kZSA9PT0gZG9jdW1lbnRcclxuICAgICAgICAgICAgICAgICAgICA/IHBhcmVudEVsLnF1ZXJ5U2VsZWN0b3IoJ3NjcmlwdCxsaW5rW3JlbD1zdHlsZXNoZWV0XSxsaW5rW2FzPXN0eWxlXSxzdHlsZScpXHJcbiAgICAgICAgICAgICAgICAgICAgOiBwYXJlbnRFbC5maXJzdENoaWxkO1xyXG4gICAgICAgICAgICAgICAgcGFyZW50RWwuaW5zZXJ0QmVmb3JlKHN0eWxlRWwsIGluc2VydEJlZm9yZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc3R5bGVFbHMuc2V0KHJvb3ROb2RlLCBzdHlsZUVsKTtcclxuICAgICAgICAgICAgaHlkcmF0ZVN0eWxlc1Jvb3Qoc3R5bGVFbCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gaHlkcmF0ZVN0eWxlc1Jvb3Qoc3R5bGVFbCkge1xyXG4gICAgICAgIGZvciAoY29uc3Qgc3R5bGVUZXh0IG9mIHN0eWxlVGV4dHMpIHtcclxuICAgICAgICAgICAgYXBwZW5kU3R5bGVzVG8oc3R5bGVFbCwgc3R5bGVUZXh0KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBhcHBlbmRTdHlsZXNUbyhzdHlsZUVsLCBzdHlsZVRleHQpIHtcclxuICAgICAgICBjb25zdCB7IHNoZWV0IH0gPSBzdHlsZUVsO1xyXG4gICAgICAgIGNvbnN0IHJ1bGVDbnQgPSBzaGVldC5jc3NSdWxlcy5sZW5ndGg7XHJcbiAgICAgICAgc3R5bGVUZXh0LnNwbGl0KCd9JykuZm9yRWFjaCgoc3R5bGVTdHIsIGkpID0+IHtcclxuICAgICAgICAgICAgc3R5bGVTdHIgPSBzdHlsZVN0ci50cmltKCk7XHJcbiAgICAgICAgICAgIGlmIChzdHlsZVN0cikge1xyXG4gICAgICAgICAgICAgICAgc2hlZXQuaW5zZXJ0UnVsZShzdHlsZVN0ciArICd9JywgcnVsZUNudCArIGkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvLyBub25jZVxyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgbGV0IHF1ZXJpZWROb25jZVZhbHVlO1xyXG4gICAgZnVuY3Rpb24gZ2V0Tm9uY2VWYWx1ZSgpIHtcclxuICAgICAgICBpZiAocXVlcmllZE5vbmNlVmFsdWUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBxdWVyaWVkTm9uY2VWYWx1ZSA9IHF1ZXJ5Tm9uY2VWYWx1ZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcXVlcmllZE5vbmNlVmFsdWU7XHJcbiAgICB9XHJcbiAgICAvKlxyXG4gICAgVE9ETzogZGlzY291cmFnZSBtZXRhIHRhZyBhbmQgaW5zdGVhZCBwdXQgbm9uY2UgYXR0cmlidXRlIG9uIHBsYWNlaG9sZGVyIDxzdHlsZT4gdGFnXHJcbiAgICAqL1xyXG4gICAgZnVuY3Rpb24gcXVlcnlOb25jZVZhbHVlKCkge1xyXG4gICAgICAgIGNvbnN0IG1ldGFXaXRoTm9uY2UgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdtZXRhW25hbWU9XCJjc3Atbm9uY2VcIl0nKTtcclxuICAgICAgICBpZiAobWV0YVdpdGhOb25jZSAmJiBtZXRhV2l0aE5vbmNlLmhhc0F0dHJpYnV0ZSgnY29udGVudCcpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBtZXRhV2l0aE5vbmNlLmdldEF0dHJpYnV0ZSgnY29udGVudCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBlbFdpdGhOb25jZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ3NjcmlwdFtub25jZV0nKTtcclxuICAgICAgICBpZiAoZWxXaXRoTm9uY2UpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGVsV2l0aE5vbmNlLm5vbmNlIHx8ICcnO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gJyc7XHJcbiAgICB9XHJcbiAgICAvLyBtYWluXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIHJlZ2lzdGVyU3R5bGVzUm9vdChkb2N1bWVudCk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGNzc18yNDh6JDQgPSBcIjpyb290ey0tZmMtc21hbGwtZm9udC1zaXplOi44NWVtOy0tZmMtcGFnZS1iZy1jb2xvcjojZmZmOy0tZmMtbmV1dHJhbC1iZy1jb2xvcjpoc2xhKDAsMCUsODIlLC4zKTstLWZjLW5ldXRyYWwtdGV4dC1jb2xvcjpncmV5Oy0tZmMtYm9yZGVyLWNvbG9yOiNkZGQ7LS1mYy1idXR0b24tdGV4dC1jb2xvcjojZmZmOy0tZmMtYnV0dG9uLWJnLWNvbG9yOiMyYzNlNTA7LS1mYy1idXR0b24tYm9yZGVyLWNvbG9yOiMyYzNlNTA7LS1mYy1idXR0b24taG92ZXItYmctY29sb3I6IzFlMmIzNzstLWZjLWJ1dHRvbi1ob3Zlci1ib3JkZXItY29sb3I6IzFhMjUyZjstLWZjLWJ1dHRvbi1hY3RpdmUtYmctY29sb3I6IzFhMjUyZjstLWZjLWJ1dHRvbi1hY3RpdmUtYm9yZGVyLWNvbG9yOiMxNTFlMjc7LS1mYy1ldmVudC1iZy1jb2xvcjojMzc4OGQ4Oy0tZmMtZXZlbnQtYm9yZGVyLWNvbG9yOiMzNzg4ZDg7LS1mYy1ldmVudC10ZXh0LWNvbG9yOiNmZmY7LS1mYy1ldmVudC1zZWxlY3RlZC1vdmVybGF5LWNvbG9yOnJnYmEoMCwwLDAsLjI1KTstLWZjLW1vcmUtbGluay1iZy1jb2xvcjojZDBkMGQwOy0tZmMtbW9yZS1saW5rLXRleHQtY29sb3I6aW5oZXJpdDstLWZjLWV2ZW50LXJlc2l6ZXItdGhpY2tuZXNzOjhweDstLWZjLWV2ZW50LXJlc2l6ZXItZG90LXRvdGFsLXdpZHRoOjhweDstLWZjLWV2ZW50LXJlc2l6ZXItZG90LWJvcmRlci13aWR0aDoxcHg7LS1mYy1ub24tYnVzaW5lc3MtY29sb3I6aHNsYSgwLDAlLDg0JSwuMyk7LS1mYy1iZy1ldmVudC1jb2xvcjojOGZkZjgyOy0tZmMtYmctZXZlbnQtb3BhY2l0eTowLjM7LS1mYy1oaWdobGlnaHQtY29sb3I6cmdiYSgxODgsMjMyLDI0MSwuMyk7LS1mYy10b2RheS1iZy1jb2xvcjpyZ2JhKDI1NSwyMjAsNDAsLjE1KTstLWZjLW5vdy1pbmRpY2F0b3ItY29sb3I6cmVkfS5mYy1ub3QtYWxsb3dlZCwuZmMtbm90LWFsbG93ZWQgLmZjLWV2ZW50e2N1cnNvcjpub3QtYWxsb3dlZH0uZmN7ZGlzcGxheTpmbGV4O2ZsZXgtZGlyZWN0aW9uOmNvbHVtbjtmb250LXNpemU6MWVtfS5mYywuZmMgKiwuZmMgOmFmdGVyLC5mYyA6YmVmb3Jle2JveC1zaXppbmc6Ym9yZGVyLWJveH0uZmMgdGFibGV7Ym9yZGVyLWNvbGxhcHNlOmNvbGxhcHNlO2JvcmRlci1zcGFjaW5nOjA7Zm9udC1zaXplOjFlbX0uZmMgdGh7dGV4dC1hbGlnbjpjZW50ZXJ9LmZjIHRkLC5mYyB0aHtwYWRkaW5nOjA7dmVydGljYWwtYWxpZ246dG9wfS5mYyBhW2RhdGEtbmF2bGlua117Y3Vyc29yOnBvaW50ZXJ9LmZjIGFbZGF0YS1uYXZsaW5rXTpob3Zlcnt0ZXh0LWRlY29yYXRpb246dW5kZXJsaW5lfS5mYy1kaXJlY3Rpb24tbHRye2RpcmVjdGlvbjpsdHI7dGV4dC1hbGlnbjpsZWZ0fS5mYy1kaXJlY3Rpb24tcnRse2RpcmVjdGlvbjpydGw7dGV4dC1hbGlnbjpyaWdodH0uZmMtdGhlbWUtc3RhbmRhcmQgdGQsLmZjLXRoZW1lLXN0YW5kYXJkIHRoe2JvcmRlcjoxcHggc29saWQgdmFyKC0tZmMtYm9yZGVyLWNvbG9yKX0uZmMtbGlxdWlkLWhhY2sgdGQsLmZjLWxpcXVpZC1oYWNrIHRoe3Bvc2l0aW9uOnJlbGF0aXZlfUBmb250LWZhY2V7Zm9udC1mYW1pbHk6ZmNpY29ucztmb250LXN0eWxlOm5vcm1hbDtmb250LXdlaWdodDo0MDA7c3JjOnVybChcXFwiZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtdHRmO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LEFBRUFBQUFMQUlBQUF3QXdUMU12TWc4U0JmQUFBQUM4QUFBQVlHTnRZWEFYVnRLTkFBQUJIQUFBQUZSbllYTndBQUFBRUFBQUFYQUFBQUFJWjJ4NVpnWXlkeElBQUFGNEFBQUZOR2hsWVdRVUo3Y0lBQUFHckFBQUFEWm9hR1ZoQjIwRHpBQUFCdVFBQUFBa2FHMTBlQ0lBQmhRQUFBY0lBQUFBTEd4dlkyRUQ0QVU2QUFBSE5BQUFBQmh0WVhod0FBOEFqQUFBQjB3QUFBQWdibUZ0WlhzcjY5MEFBQWRzQUFBQmhuQnZjM1FBQXdBQUFBQUk5QUFBQUNBQUF3UEFBWkFBQlFBQUFwa0N6QUFBQUk4Q21RTE1BQUFCNndBekFRa0FBQUFBQUFBQUFBQUFBQUFBQUFBQkVBQUFBQUFBQUFBQUFBQUFBQUFBQUFCQUFBRHBCZ1BBLzhBQVFBUEFBRUFBQUFBQkFBQUFBQUFBQUFBQUFBQWdBQUFBQUFBREFBQUFBd0FBQUJ3QUFRQURBQUFBSEFBREFBRUFBQUFjQUFRQU9BQUFBQW9BQ0FBQ0FBSUFBUUFnNlFiLy9mLy9BQUFBQUFBZzZRRC8vZi8vQUFILzR4Y0VBQU1BQVFBQUFBQUFBQUFBQUFBQUFRQUIvLzhBRHdBQkFBQUFBQUFBQUFBQUFnQUFOemtCQUFBQUFBRUFBQUFBQUFBQUFBQUNBQUEzT1FFQUFBQUFBUUFBQUFBQUFBQUFBQUlBQURjNUFRQUFBQUFCQVdJQWpRS2VBc2tBRXdBQUpTYzNOalFuSmlJSEFRWVVGd0VXTWpjMk5DY0NudUxpRFEwTUpBei9BQTBOQVFBTUpBd05EY25pNGd3akRRd00vd0FOSXd6L0FBME5EQ01OQUFBQUFRRmlBSTBDbmdMSkFCTUFBQ1VCTmpRbkFTWWlCd1lVSHdFSEJoUVhGakkzQVo0QkFBME4vd0FNSkF3TkRlTGlEUTBNSkF5TkFRQU1JdzBCQUF3TURTTU00dUlOSXd3TkRRQUFBQUlBNGdDM0F4NENuZ0FUQUNjQUFDVW5OelkwSnlZaUR3RUdGQjhCRmpJM05qUW5JU2MzTmpRbkppSVBBUVlVSHdFV01qYzJOQ2NCODdlM0RRME1JdzNWRFEzVkRTTU1EUTBCSzdlM0RRME1KQXpWRFEzVkRDUU1EUTN6dUxjTUpBd05EZFVOSXd6V0RBd05Jd3k0dHd3a0RBME4xUTBqRE5ZTURBMGpEQUFBQWdEaUFMY0RIZ0tlQUJNQUp3QUFKVGMyTkM4QkppSUhCaFFmQVFjR0ZCY1dNamNoTnpZMEx3RW1JZ2NHRkI4QkJ3WVVGeFl5TndKSjFRME4xUTBqREEwTnQ3Y05EUXdqRGY3VjFRME4xUXdrREEwTnQ3Y05EUXdrRExmV0RDTU4xUTBORENRTXQ3Z01JdzBNRE5ZTUl3M1ZEUTBNSkF5M3VBd2pEUXdNQUFBREFGVUFBQU9yQTFVQU13Qm9BSGNBQUJNaUJnY09BUWNPQVFjT0FSVVJGQllYSGdFWEhnRVhIZ0V6SVRJMk56NEJOejRCTno0Qk5SRTBKaWN1QVNjdUFTY3VBU01GSVRJV0Z4NEJGeDRCRng0QkZSRVVCZ2NPQVFjT0FRY09BU01oSWlZbkxnRW5MZ0VuTGdFMUVUUTJOejRCTno0Qk56NEJNeE1oTWpZMU5DWWpJU0lHRlJRV005VU5HQXdMRlFrSkRnVUZCUVVGQlE0SkNSVUxEQmdOQWxZTkdBd0xGUWtKRGdVRkJRVUZCUTRKQ1JVTERCZ04vYW9DVmdRSUJBUUhBd01GQVFJQkFRSUJCUU1EQndRRUNBVDlxZ1FJQkFRSEF3TUZBUUlCQVFJQkJRTURCd1FFQ0FTQUFWWVJHUmtSL3FvUkdSa1JBMVVGQkFVT0NRa1ZEQXNaRGYyckRSa0xEQlVKQ0E0RkJRVUZCUVVPQ1FnVkRBc1pEUUpWRFJrTERCVUpDUTRGQkFWVkFnRUNCUU1DQndRRUNBWDlxd1FKQXdRSEF3TUZBUUlDQWdJQkJRTURCd1FEQ1FRQ1ZRVUlCQVFIQWdNRkFnRUMvb0FaRWhFWkdSRVNHUUFBQUFBREFGVUFBQU9yQTFVQU13Qm9BSWtBQUJNaUJnY09BUWNPQVFjT0FSVVJGQllYSGdFWEhnRVhIZ0V6SVRJMk56NEJOejRCTno0Qk5SRTBKaWN1QVNjdUFTY3VBU01GSVRJV0Z4NEJGeDRCRng0QkZSRVVCZ2NPQVFjT0FRY09BU01oSWlZbkxnRW5MZ0VuTGdFMUVUUTJOejRCTno0Qk56NEJNeE16RlJRV016STJQUUV6TWpZMU5DWXJBVFUwSmlNaUJoMEJJeUlHRlJRV005VU5HQXdMRlFrSkRnVUZCUVVGQlE0SkNSVUxEQmdOQWxZTkdBd0xGUWtKRGdVRkJRVUZCUTRKQ1JVTERCZ04vYW9DVmdRSUJBUUhBd01GQVFJQkFRSUJCUU1EQndRRUNBVDlxZ1FJQkFRSEF3TUZBUUlCQVFJQkJRTURCd1FFQ0FTQWdCa1NFaG1BRVJrWkVZQVpFaElaZ0JFWkdSRURWUVVFQlE0SkNSVU1DeGtOL2FzTkdRc01GUWtJRGdVRkJRVUZCUTRKQ0JVTUN4a05BbFVOR1FzTUZRa0pEZ1VFQlZVQ0FRSUZBd0lIQkFRSUJmMnJCQWtEQkFjREF3VUJBZ0lDQWdFRkF3TUhCQU1KQkFKVkJRZ0VCQWNDQXdVQ0FRTCtnSUFTR1JrU2dCa1NFUm1BRWhrWkVvQVpFUklaQUFBQkFPSUFqUU1lQXNrQUlBQUFFeGNIQmhRWEZqSS9BUmNXTWpjMk5DOEJOelkwSnlZaUR3RW5KaUlIQmhRWDR1TGlEUTBNSkF6aTRnd2tEQTBONHVJTkRRd2tET0xpRENRTURRMENqZUxpRFNNTURRM2g0UTBORENNTjR1SU1JdzBNRE9MaURBd05Jd3dBQUFBQkFBQUFBUUFBYTVuMHkxOFBQUFVBQ3dRQUFBQUFBTml2T1ZzQUFBQUEySzg1V3dBQUFBQURxd05WQUFBQUNBQUNBQUFBQUFBQUFBRUFBQVBBLzhBQUFBUUFBQUFBQUFPckFBRUFBQUFBQUFBQUFBQUFBQUFBQUFBTEJBQUFBQUFBQUFBQUFBQUFBZ0FBQUFRQUFXSUVBQUZpQkFBQTRnUUFBT0lFQUFCVkJBQUFWUVFBQU9JQUFBQUFBQW9BRkFBZUFFUUFhZ0NxQU9vQm5nSmtBcG9BQVFBQUFBc0FpZ0FEQUFBQUFBQUNBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQTRBcmdBQkFBQUFBQUFCQUFjQUFBQUJBQUFBQUFBQ0FBY0FZQUFCQUFBQUFBQURBQWNBTmdBQkFBQUFBQUFFQUFjQWRRQUJBQUFBQUFBRkFBc0FGUUFCQUFBQUFBQUdBQWNBU3dBQkFBQUFBQUFLQUJvQWlnQURBQUVFQ1FBQkFBNEFCd0FEQUFFRUNRQUNBQTRBWndBREFBRUVDUUFEQUE0QVBRQURBQUVFQ1FBRUFBNEFmQUFEQUFFRUNRQUZBQllBSUFBREFBRUVDUUFHQUE0QVVnQURBQUVFQ1FBS0FEUUFwR1pqYVdOdmJuTUFaZ0JqQUdrQVl3QnZBRzRBYzFabGNuTnBiMjRnTVM0d0FGWUFaUUJ5QUhNQWFRQnZBRzRBSUFBeEFDNEFNR1pqYVdOdmJuTUFaZ0JqQUdrQVl3QnZBRzRBYzJaamFXTnZibk1BWmdCakFHa0FZd0J2QUc0QWMxSmxaM1ZzWVhJQVVnQmxBR2NBZFFCc0FHRUFjbVpqYVdOdmJuTUFaZ0JqQUdrQVl3QnZBRzRBYzBadmJuUWdaMlZ1WlhKaGRHVmtJR0o1SUVsamIwMXZiMjR1QUVZQWJ3QnVBSFFBSUFCbkFHVUFiZ0JsQUhJQVlRQjBBR1VBWkFBZ0FHSUFlUUFnQUVrQVl3QnZBRTBBYndCdkFHNEFMZ0FBQUFNQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQT1cXFwiKSBmb3JtYXQoXFxcInRydWV0eXBlXFxcIil9LmZjLWljb257c3BlYWs6bm9uZTstd2Via2l0LWZvbnQtc21vb3RoaW5nOmFudGlhbGlhc2VkOy1tb3otb3N4LWZvbnQtc21vb3RoaW5nOmdyYXlzY2FsZTtkaXNwbGF5OmlubGluZS1ibG9jaztmb250LWZhbWlseTpmY2ljb25zIWltcG9ydGFudDtmb250LXN0eWxlOm5vcm1hbDtmb250LXZhcmlhbnQ6bm9ybWFsO2ZvbnQtd2VpZ2h0OjQwMDtoZWlnaHQ6MWVtO2xpbmUtaGVpZ2h0OjE7dGV4dC1hbGlnbjpjZW50ZXI7dGV4dC10cmFuc2Zvcm06bm9uZTstd2Via2l0LXVzZXItc2VsZWN0Om5vbmU7LW1vei11c2VyLXNlbGVjdDpub25lO3VzZXItc2VsZWN0Om5vbmU7d2lkdGg6MWVtfS5mYy1pY29uLWNoZXZyb24tbGVmdDpiZWZvcmV7Y29udGVudDpcXFwiXFxcXGU5MDBcXFwifS5mYy1pY29uLWNoZXZyb24tcmlnaHQ6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxlOTAxXFxcIn0uZmMtaWNvbi1jaGV2cm9ucy1sZWZ0OmJlZm9yZXtjb250ZW50OlxcXCJcXFxcZTkwMlxcXCJ9LmZjLWljb24tY2hldnJvbnMtcmlnaHQ6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxlOTAzXFxcIn0uZmMtaWNvbi1taW51cy1zcXVhcmU6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxlOTA0XFxcIn0uZmMtaWNvbi1wbHVzLXNxdWFyZTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXGU5MDVcXFwifS5mYy1pY29uLXg6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxlOTA2XFxcIn0uZmMgLmZjLWJ1dHRvbntib3JkZXItcmFkaXVzOjA7Zm9udC1mYW1pbHk6aW5oZXJpdDtmb250LXNpemU6aW5oZXJpdDtsaW5lLWhlaWdodDppbmhlcml0O21hcmdpbjowO292ZXJmbG93OnZpc2libGU7dGV4dC10cmFuc2Zvcm06bm9uZX0uZmMgLmZjLWJ1dHRvbjpmb2N1c3tvdXRsaW5lOjFweCBkb3R0ZWQ7b3V0bGluZTo1cHggYXV0byAtd2Via2l0LWZvY3VzLXJpbmctY29sb3J9LmZjIC5mYy1idXR0b257LXdlYmtpdC1hcHBlYXJhbmNlOmJ1dHRvbn0uZmMgLmZjLWJ1dHRvbjpub3QoOmRpc2FibGVkKXtjdXJzb3I6cG9pbnRlcn0uZmMgLmZjLWJ1dHRvbntiYWNrZ3JvdW5kLWNvbG9yOnRyYW5zcGFyZW50O2JvcmRlcjoxcHggc29saWQgdHJhbnNwYXJlbnQ7Ym9yZGVyLXJhZGl1czouMjVlbTtkaXNwbGF5OmlubGluZS1ibG9jaztmb250LXNpemU6MWVtO2ZvbnQtd2VpZ2h0OjQwMDtsaW5lLWhlaWdodDoxLjU7cGFkZGluZzouNGVtIC42NWVtO3RleHQtYWxpZ246Y2VudGVyOy13ZWJraXQtdXNlci1zZWxlY3Q6bm9uZTstbW96LXVzZXItc2VsZWN0Om5vbmU7dXNlci1zZWxlY3Q6bm9uZTt2ZXJ0aWNhbC1hbGlnbjptaWRkbGV9LmZjIC5mYy1idXR0b246aG92ZXJ7dGV4dC1kZWNvcmF0aW9uOm5vbmV9LmZjIC5mYy1idXR0b246Zm9jdXN7Ym94LXNoYWRvdzowIDAgMCAuMnJlbSByZ2JhKDQ0LDYyLDgwLC4yNSk7b3V0bGluZTowfS5mYyAuZmMtYnV0dG9uOmRpc2FibGVke29wYWNpdHk6LjY1fS5mYyAuZmMtYnV0dG9uLXByaW1hcnl7YmFja2dyb3VuZC1jb2xvcjp2YXIoLS1mYy1idXR0b24tYmctY29sb3IpO2JvcmRlci1jb2xvcjp2YXIoLS1mYy1idXR0b24tYm9yZGVyLWNvbG9yKTtjb2xvcjp2YXIoLS1mYy1idXR0b24tdGV4dC1jb2xvcil9LmZjIC5mYy1idXR0b24tcHJpbWFyeTpob3ZlcntiYWNrZ3JvdW5kLWNvbG9yOnZhcigtLWZjLWJ1dHRvbi1ob3Zlci1iZy1jb2xvcik7Ym9yZGVyLWNvbG9yOnZhcigtLWZjLWJ1dHRvbi1ob3Zlci1ib3JkZXItY29sb3IpO2NvbG9yOnZhcigtLWZjLWJ1dHRvbi10ZXh0LWNvbG9yKX0uZmMgLmZjLWJ1dHRvbi1wcmltYXJ5OmRpc2FibGVke2JhY2tncm91bmQtY29sb3I6dmFyKC0tZmMtYnV0dG9uLWJnLWNvbG9yKTtib3JkZXItY29sb3I6dmFyKC0tZmMtYnV0dG9uLWJvcmRlci1jb2xvcik7Y29sb3I6dmFyKC0tZmMtYnV0dG9uLXRleHQtY29sb3IpfS5mYyAuZmMtYnV0dG9uLXByaW1hcnk6Zm9jdXN7Ym94LXNoYWRvdzowIDAgMCAuMnJlbSByZ2JhKDc2LDkxLDEwNiwuNSl9LmZjIC5mYy1idXR0b24tcHJpbWFyeTpub3QoOmRpc2FibGVkKS5mYy1idXR0b24tYWN0aXZlLC5mYyAuZmMtYnV0dG9uLXByaW1hcnk6bm90KDpkaXNhYmxlZCk6YWN0aXZle2JhY2tncm91bmQtY29sb3I6dmFyKC0tZmMtYnV0dG9uLWFjdGl2ZS1iZy1jb2xvcik7Ym9yZGVyLWNvbG9yOnZhcigtLWZjLWJ1dHRvbi1hY3RpdmUtYm9yZGVyLWNvbG9yKTtjb2xvcjp2YXIoLS1mYy1idXR0b24tdGV4dC1jb2xvcil9LmZjIC5mYy1idXR0b24tcHJpbWFyeTpub3QoOmRpc2FibGVkKS5mYy1idXR0b24tYWN0aXZlOmZvY3VzLC5mYyAuZmMtYnV0dG9uLXByaW1hcnk6bm90KDpkaXNhYmxlZCk6YWN0aXZlOmZvY3Vze2JveC1zaGFkb3c6MCAwIDAgLjJyZW0gcmdiYSg3Niw5MSwxMDYsLjUpfS5mYyAuZmMtYnV0dG9uIC5mYy1pY29ue2ZvbnQtc2l6ZToxLjVlbTt2ZXJ0aWNhbC1hbGlnbjptaWRkbGV9LmZjIC5mYy1idXR0b24tZ3JvdXB7ZGlzcGxheTppbmxpbmUtZmxleDtwb3NpdGlvbjpyZWxhdGl2ZTt2ZXJ0aWNhbC1hbGlnbjptaWRkbGV9LmZjIC5mYy1idXR0b24tZ3JvdXA+LmZjLWJ1dHRvbntmbGV4OjEgMSBhdXRvO3Bvc2l0aW9uOnJlbGF0aXZlfS5mYyAuZmMtYnV0dG9uLWdyb3VwPi5mYy1idXR0b24uZmMtYnV0dG9uLWFjdGl2ZSwuZmMgLmZjLWJ1dHRvbi1ncm91cD4uZmMtYnV0dG9uOmFjdGl2ZSwuZmMgLmZjLWJ1dHRvbi1ncm91cD4uZmMtYnV0dG9uOmZvY3VzLC5mYyAuZmMtYnV0dG9uLWdyb3VwPi5mYy1idXR0b246aG92ZXJ7ei1pbmRleDoxfS5mYy1kaXJlY3Rpb24tbHRyIC5mYy1idXR0b24tZ3JvdXA+LmZjLWJ1dHRvbjpub3QoOmZpcnN0LWNoaWxkKXtib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOjA7Ym9yZGVyLXRvcC1sZWZ0LXJhZGl1czowO21hcmdpbi1sZWZ0Oi0xcHh9LmZjLWRpcmVjdGlvbi1sdHIgLmZjLWJ1dHRvbi1ncm91cD4uZmMtYnV0dG9uOm5vdCg6bGFzdC1jaGlsZCl7Ym9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6MDtib3JkZXItdG9wLXJpZ2h0LXJhZGl1czowfS5mYy1kaXJlY3Rpb24tcnRsIC5mYy1idXR0b24tZ3JvdXA+LmZjLWJ1dHRvbjpub3QoOmZpcnN0LWNoaWxkKXtib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1czowO2JvcmRlci10b3AtcmlnaHQtcmFkaXVzOjA7bWFyZ2luLXJpZ2h0Oi0xcHh9LmZjLWRpcmVjdGlvbi1ydGwgLmZjLWJ1dHRvbi1ncm91cD4uZmMtYnV0dG9uOm5vdCg6bGFzdC1jaGlsZCl7Ym9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1czowO2JvcmRlci10b3AtbGVmdC1yYWRpdXM6MH0uZmMgLmZjLXRvb2xiYXJ7YWxpZ24taXRlbXM6Y2VudGVyO2Rpc3BsYXk6ZmxleDtqdXN0aWZ5LWNvbnRlbnQ6c3BhY2UtYmV0d2Vlbn0uZmMgLmZjLXRvb2xiYXIuZmMtaGVhZGVyLXRvb2xiYXJ7bWFyZ2luLWJvdHRvbToxLjVlbX0uZmMgLmZjLXRvb2xiYXIuZmMtZm9vdGVyLXRvb2xiYXJ7bWFyZ2luLXRvcDoxLjVlbX0uZmMgLmZjLXRvb2xiYXItdGl0bGV7Zm9udC1zaXplOjEuNzVlbTttYXJnaW46MH0uZmMtZGlyZWN0aW9uLWx0ciAuZmMtdG9vbGJhcj4qPjpub3QoOmZpcnN0LWNoaWxkKXttYXJnaW4tbGVmdDouNzVlbX0uZmMtZGlyZWN0aW9uLXJ0bCAuZmMtdG9vbGJhcj4qPjpub3QoOmZpcnN0LWNoaWxkKXttYXJnaW4tcmlnaHQ6Ljc1ZW19LmZjLWRpcmVjdGlvbi1ydGwgLmZjLXRvb2xiYXItbHRye2ZsZXgtZGlyZWN0aW9uOnJvdy1yZXZlcnNlfS5mYyAuZmMtc2Nyb2xsZXJ7LXdlYmtpdC1vdmVyZmxvdy1zY3JvbGxpbmc6dG91Y2g7cG9zaXRpb246cmVsYXRpdmV9LmZjIC5mYy1zY3JvbGxlci1saXF1aWR7aGVpZ2h0OjEwMCV9LmZjIC5mYy1zY3JvbGxlci1saXF1aWQtYWJzb2x1dGV7Ym90dG9tOjA7bGVmdDowO3Bvc2l0aW9uOmFic29sdXRlO3JpZ2h0OjA7dG9wOjB9LmZjIC5mYy1zY3JvbGxlci1oYXJuZXNze2RpcmVjdGlvbjpsdHI7b3ZlcmZsb3c6aGlkZGVuO3Bvc2l0aW9uOnJlbGF0aXZlfS5mYyAuZmMtc2Nyb2xsZXItaGFybmVzcy1saXF1aWR7aGVpZ2h0OjEwMCV9LmZjLWRpcmVjdGlvbi1ydGwgLmZjLXNjcm9sbGVyLWhhcm5lc3M+LmZjLXNjcm9sbGVye2RpcmVjdGlvbjpydGx9LmZjLXRoZW1lLXN0YW5kYXJkIC5mYy1zY3JvbGxncmlke2JvcmRlcjoxcHggc29saWQgdmFyKC0tZmMtYm9yZGVyLWNvbG9yKX0uZmMgLmZjLXNjcm9sbGdyaWQsLmZjIC5mYy1zY3JvbGxncmlkIHRhYmxle3RhYmxlLWxheW91dDpmaXhlZDt3aWR0aDoxMDAlfS5mYyAuZmMtc2Nyb2xsZ3JpZCB0YWJsZXtib3JkZXItbGVmdC1zdHlsZTpoaWRkZW47Ym9yZGVyLXJpZ2h0LXN0eWxlOmhpZGRlbjtib3JkZXItdG9wLXN0eWxlOmhpZGRlbn0uZmMgLmZjLXNjcm9sbGdyaWR7Ym9yZGVyLWJvdHRvbS13aWR0aDowO2JvcmRlci1jb2xsYXBzZTpzZXBhcmF0ZTtib3JkZXItcmlnaHQtd2lkdGg6MH0uZmMgLmZjLXNjcm9sbGdyaWQtbGlxdWlke2hlaWdodDoxMDAlfS5mYyAuZmMtc2Nyb2xsZ3JpZC1zZWN0aW9uLC5mYyAuZmMtc2Nyb2xsZ3JpZC1zZWN0aW9uIHRhYmxlLC5mYyAuZmMtc2Nyb2xsZ3JpZC1zZWN0aW9uPnRke2hlaWdodDoxcHh9LmZjIC5mYy1zY3JvbGxncmlkLXNlY3Rpb24tbGlxdWlkPnRke2hlaWdodDoxMDAlfS5mYyAuZmMtc2Nyb2xsZ3JpZC1zZWN0aW9uPip7Ym9yZGVyLWxlZnQtd2lkdGg6MDtib3JkZXItdG9wLXdpZHRoOjB9LmZjIC5mYy1zY3JvbGxncmlkLXNlY3Rpb24tZm9vdGVyPiosLmZjIC5mYy1zY3JvbGxncmlkLXNlY3Rpb24taGVhZGVyPip7Ym9yZGVyLWJvdHRvbS13aWR0aDowfS5mYyAuZmMtc2Nyb2xsZ3JpZC1zZWN0aW9uLWJvZHkgdGFibGUsLmZjIC5mYy1zY3JvbGxncmlkLXNlY3Rpb24tZm9vdGVyIHRhYmxle2JvcmRlci1ib3R0b20tc3R5bGU6aGlkZGVufS5mYyAuZmMtc2Nyb2xsZ3JpZC1zZWN0aW9uLXN0aWNreT4qe2JhY2tncm91bmQ6dmFyKC0tZmMtcGFnZS1iZy1jb2xvcik7cG9zaXRpb246c3RpY2t5O3otaW5kZXg6M30uZmMgLmZjLXNjcm9sbGdyaWQtc2VjdGlvbi1oZWFkZXIuZmMtc2Nyb2xsZ3JpZC1zZWN0aW9uLXN0aWNreT4qe3RvcDowfS5mYyAuZmMtc2Nyb2xsZ3JpZC1zZWN0aW9uLWZvb3Rlci5mYy1zY3JvbGxncmlkLXNlY3Rpb24tc3RpY2t5Pip7Ym90dG9tOjB9LmZjIC5mYy1zY3JvbGxncmlkLXN0aWNreS1zaGlte2hlaWdodDoxcHg7bWFyZ2luLWJvdHRvbTotMXB4fS5mYy1zdGlja3l7cG9zaXRpb246c3RpY2t5fS5mYyAuZmMtdmlldy1oYXJuZXNze2ZsZXgtZ3JvdzoxO3Bvc2l0aW9uOnJlbGF0aXZlfS5mYyAuZmMtdmlldy1oYXJuZXNzLWFjdGl2ZT4uZmMtdmlld3tib3R0b206MDtsZWZ0OjA7cG9zaXRpb246YWJzb2x1dGU7cmlnaHQ6MDt0b3A6MH0uZmMgLmZjLWNvbC1oZWFkZXItY2VsbC1jdXNoaW9ue2Rpc3BsYXk6aW5saW5lLWJsb2NrO3BhZGRpbmc6MnB4IDRweH0uZmMgLmZjLWJnLWV2ZW50LC5mYyAuZmMtaGlnaGxpZ2h0LC5mYyAuZmMtbm9uLWJ1c2luZXNze2JvdHRvbTowO2xlZnQ6MDtwb3NpdGlvbjphYnNvbHV0ZTtyaWdodDowO3RvcDowfS5mYyAuZmMtbm9uLWJ1c2luZXNze2JhY2tncm91bmQ6dmFyKC0tZmMtbm9uLWJ1c2luZXNzLWNvbG9yKX0uZmMgLmZjLWJnLWV2ZW50e2JhY2tncm91bmQ6dmFyKC0tZmMtYmctZXZlbnQtY29sb3IpO29wYWNpdHk6dmFyKC0tZmMtYmctZXZlbnQtb3BhY2l0eSl9LmZjIC5mYy1iZy1ldmVudCAuZmMtZXZlbnQtdGl0bGV7Zm9udC1zaXplOnZhcigtLWZjLXNtYWxsLWZvbnQtc2l6ZSk7Zm9udC1zdHlsZTppdGFsaWM7bWFyZ2luOi41ZW19LmZjIC5mYy1oaWdobGlnaHR7YmFja2dyb3VuZDp2YXIoLS1mYy1oaWdobGlnaHQtY29sb3IpfS5mYyAuZmMtY2VsbC1zaGFkZWQsLmZjIC5mYy1kYXktZGlzYWJsZWR7YmFja2dyb3VuZDp2YXIoLS1mYy1uZXV0cmFsLWJnLWNvbG9yKX1hLmZjLWV2ZW50LGEuZmMtZXZlbnQ6aG92ZXJ7dGV4dC1kZWNvcmF0aW9uOm5vbmV9LmZjLWV2ZW50LmZjLWV2ZW50LWRyYWdnYWJsZSwuZmMtZXZlbnRbaHJlZl17Y3Vyc29yOnBvaW50ZXJ9LmZjLWV2ZW50IC5mYy1ldmVudC1tYWlue3Bvc2l0aW9uOnJlbGF0aXZlO3otaW5kZXg6Mn0uZmMtZXZlbnQtZHJhZ2dpbmc6bm90KC5mYy1ldmVudC1zZWxlY3RlZCl7b3BhY2l0eTouNzV9LmZjLWV2ZW50LWRyYWdnaW5nLmZjLWV2ZW50LXNlbGVjdGVke2JveC1zaGFkb3c6MCAycHggN3B4IHJnYmEoMCwwLDAsLjMpfS5mYy1ldmVudCAuZmMtZXZlbnQtcmVzaXplcntkaXNwbGF5Om5vbmU7cG9zaXRpb246YWJzb2x1dGU7ei1pbmRleDo0fS5mYy1ldmVudC1zZWxlY3RlZCAuZmMtZXZlbnQtcmVzaXplciwuZmMtZXZlbnQ6aG92ZXIgLmZjLWV2ZW50LXJlc2l6ZXJ7ZGlzcGxheTpibG9ja30uZmMtZXZlbnQtc2VsZWN0ZWQgLmZjLWV2ZW50LXJlc2l6ZXJ7YmFja2dyb3VuZDp2YXIoLS1mYy1wYWdlLWJnLWNvbG9yKTtib3JkZXItY29sb3I6aW5oZXJpdDtib3JkZXItcmFkaXVzOmNhbGModmFyKC0tZmMtZXZlbnQtcmVzaXplci1kb3QtdG90YWwtd2lkdGgpLzIpO2JvcmRlci1zdHlsZTpzb2xpZDtib3JkZXItd2lkdGg6dmFyKC0tZmMtZXZlbnQtcmVzaXplci1kb3QtYm9yZGVyLXdpZHRoKTtoZWlnaHQ6dmFyKC0tZmMtZXZlbnQtcmVzaXplci1kb3QtdG90YWwtd2lkdGgpO3dpZHRoOnZhcigtLWZjLWV2ZW50LXJlc2l6ZXItZG90LXRvdGFsLXdpZHRoKX0uZmMtZXZlbnQtc2VsZWN0ZWQgLmZjLWV2ZW50LXJlc2l6ZXI6YmVmb3Jle2JvdHRvbTotMjBweDtjb250ZW50OlxcXCJcXFwiO2xlZnQ6LTIwcHg7cG9zaXRpb246YWJzb2x1dGU7cmlnaHQ6LTIwcHg7dG9wOi0yMHB4fS5mYy1ldmVudC1zZWxlY3RlZCwuZmMtZXZlbnQ6Zm9jdXN7Ym94LXNoYWRvdzowIDJweCA1cHggcmdiYSgwLDAsMCwuMil9LmZjLWV2ZW50LXNlbGVjdGVkOmJlZm9yZSwuZmMtZXZlbnQ6Zm9jdXM6YmVmb3Jle2JvdHRvbTowO2NvbnRlbnQ6XFxcIlxcXCI7bGVmdDowO3Bvc2l0aW9uOmFic29sdXRlO3JpZ2h0OjA7dG9wOjA7ei1pbmRleDozfS5mYy1ldmVudC1zZWxlY3RlZDphZnRlciwuZmMtZXZlbnQ6Zm9jdXM6YWZ0ZXJ7YmFja2dyb3VuZDp2YXIoLS1mYy1ldmVudC1zZWxlY3RlZC1vdmVybGF5LWNvbG9yKTtib3R0b206LTFweDtjb250ZW50OlxcXCJcXFwiO2xlZnQ6LTFweDtwb3NpdGlvbjphYnNvbHV0ZTtyaWdodDotMXB4O3RvcDotMXB4O3otaW5kZXg6MX0uZmMtaC1ldmVudHtiYWNrZ3JvdW5kLWNvbG9yOnZhcigtLWZjLWV2ZW50LWJnLWNvbG9yKTtib3JkZXI6MXB4IHNvbGlkIHZhcigtLWZjLWV2ZW50LWJvcmRlci1jb2xvcik7ZGlzcGxheTpibG9ja30uZmMtaC1ldmVudCAuZmMtZXZlbnQtbWFpbntjb2xvcjp2YXIoLS1mYy1ldmVudC10ZXh0LWNvbG9yKX0uZmMtaC1ldmVudCAuZmMtZXZlbnQtbWFpbi1mcmFtZXtkaXNwbGF5OmZsZXh9LmZjLWgtZXZlbnQgLmZjLWV2ZW50LXRpbWV7bWF4LXdpZHRoOjEwMCU7b3ZlcmZsb3c6aGlkZGVufS5mYy1oLWV2ZW50IC5mYy1ldmVudC10aXRsZS1jb250YWluZXJ7ZmxleC1ncm93OjE7ZmxleC1zaHJpbms6MTttaW4td2lkdGg6MH0uZmMtaC1ldmVudCAuZmMtZXZlbnQtdGl0bGV7ZGlzcGxheTppbmxpbmUtYmxvY2s7bGVmdDowO21heC13aWR0aDoxMDAlO292ZXJmbG93OmhpZGRlbjtyaWdodDowO3ZlcnRpY2FsLWFsaWduOnRvcH0uZmMtaC1ldmVudC5mYy1ldmVudC1zZWxlY3RlZDpiZWZvcmV7Ym90dG9tOi0xMHB4O3RvcDotMTBweH0uZmMtZGlyZWN0aW9uLWx0ciAuZmMtZGF5Z3JpZC1ibG9jay1ldmVudDpub3QoLmZjLWV2ZW50LXN0YXJ0KSwuZmMtZGlyZWN0aW9uLXJ0bCAuZmMtZGF5Z3JpZC1ibG9jay1ldmVudDpub3QoLmZjLWV2ZW50LWVuZCl7Ym9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1czowO2JvcmRlci1sZWZ0LXdpZHRoOjA7Ym9yZGVyLXRvcC1sZWZ0LXJhZGl1czowfS5mYy1kaXJlY3Rpb24tbHRyIC5mYy1kYXlncmlkLWJsb2NrLWV2ZW50Om5vdCguZmMtZXZlbnQtZW5kKSwuZmMtZGlyZWN0aW9uLXJ0bCAuZmMtZGF5Z3JpZC1ibG9jay1ldmVudDpub3QoLmZjLWV2ZW50LXN0YXJ0KXtib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1czowO2JvcmRlci1yaWdodC13aWR0aDowO2JvcmRlci10b3AtcmlnaHQtcmFkaXVzOjB9LmZjLWgtZXZlbnQ6bm90KC5mYy1ldmVudC1zZWxlY3RlZCkgLmZjLWV2ZW50LXJlc2l6ZXJ7Ym90dG9tOjA7dG9wOjA7d2lkdGg6dmFyKC0tZmMtZXZlbnQtcmVzaXplci10aGlja25lc3MpfS5mYy1kaXJlY3Rpb24tbHRyIC5mYy1oLWV2ZW50Om5vdCguZmMtZXZlbnQtc2VsZWN0ZWQpIC5mYy1ldmVudC1yZXNpemVyLXN0YXJ0LC5mYy1kaXJlY3Rpb24tcnRsIC5mYy1oLWV2ZW50Om5vdCguZmMtZXZlbnQtc2VsZWN0ZWQpIC5mYy1ldmVudC1yZXNpemVyLWVuZHtjdXJzb3I6dy1yZXNpemU7bGVmdDpjYWxjKHZhcigtLWZjLWV2ZW50LXJlc2l6ZXItdGhpY2tuZXNzKSotLjUpfS5mYy1kaXJlY3Rpb24tbHRyIC5mYy1oLWV2ZW50Om5vdCguZmMtZXZlbnQtc2VsZWN0ZWQpIC5mYy1ldmVudC1yZXNpemVyLWVuZCwuZmMtZGlyZWN0aW9uLXJ0bCAuZmMtaC1ldmVudDpub3QoLmZjLWV2ZW50LXNlbGVjdGVkKSAuZmMtZXZlbnQtcmVzaXplci1zdGFydHtjdXJzb3I6ZS1yZXNpemU7cmlnaHQ6Y2FsYyh2YXIoLS1mYy1ldmVudC1yZXNpemVyLXRoaWNrbmVzcykqLS41KX0uZmMtaC1ldmVudC5mYy1ldmVudC1zZWxlY3RlZCAuZmMtZXZlbnQtcmVzaXplcnttYXJnaW4tdG9wOmNhbGModmFyKC0tZmMtZXZlbnQtcmVzaXplci1kb3QtdG90YWwtd2lkdGgpKi0uNSk7dG9wOjUwJX0uZmMtZGlyZWN0aW9uLWx0ciAuZmMtaC1ldmVudC5mYy1ldmVudC1zZWxlY3RlZCAuZmMtZXZlbnQtcmVzaXplci1zdGFydCwuZmMtZGlyZWN0aW9uLXJ0bCAuZmMtaC1ldmVudC5mYy1ldmVudC1zZWxlY3RlZCAuZmMtZXZlbnQtcmVzaXplci1lbmR7bGVmdDpjYWxjKHZhcigtLWZjLWV2ZW50LXJlc2l6ZXItZG90LXRvdGFsLXdpZHRoKSotLjUpfS5mYy1kaXJlY3Rpb24tbHRyIC5mYy1oLWV2ZW50LmZjLWV2ZW50LXNlbGVjdGVkIC5mYy1ldmVudC1yZXNpemVyLWVuZCwuZmMtZGlyZWN0aW9uLXJ0bCAuZmMtaC1ldmVudC5mYy1ldmVudC1zZWxlY3RlZCAuZmMtZXZlbnQtcmVzaXplci1zdGFydHtyaWdodDpjYWxjKHZhcigtLWZjLWV2ZW50LXJlc2l6ZXItZG90LXRvdGFsLXdpZHRoKSotLjUpfS5mYyAuZmMtcG9wb3Zlcntib3gtc2hhZG93OjAgMnB4IDZweCByZ2JhKDAsMCwwLC4xNSk7cG9zaXRpb246YWJzb2x1dGU7ei1pbmRleDo5OTk5fS5mYyAuZmMtcG9wb3Zlci1oZWFkZXJ7YWxpZ24taXRlbXM6Y2VudGVyO2Rpc3BsYXk6ZmxleDtmbGV4LWRpcmVjdGlvbjpyb3c7anVzdGlmeS1jb250ZW50OnNwYWNlLWJldHdlZW47cGFkZGluZzozcHggNHB4fS5mYyAuZmMtcG9wb3Zlci10aXRsZXttYXJnaW46MCAycHh9LmZjIC5mYy1wb3BvdmVyLWNsb3Nle2N1cnNvcjpwb2ludGVyO2ZvbnQtc2l6ZToxLjFlbTtvcGFjaXR5Oi42NX0uZmMtdGhlbWUtc3RhbmRhcmQgLmZjLXBvcG92ZXJ7YmFja2dyb3VuZDp2YXIoLS1mYy1wYWdlLWJnLWNvbG9yKTtib3JkZXI6MXB4IHNvbGlkIHZhcigtLWZjLWJvcmRlci1jb2xvcil9LmZjLXRoZW1lLXN0YW5kYXJkIC5mYy1wb3BvdmVyLWhlYWRlcntiYWNrZ3JvdW5kOnZhcigtLWZjLW5ldXRyYWwtYmctY29sb3IpfVwiO1xyXG4gICAgaW5qZWN0U3R5bGVzKGNzc18yNDh6JDQpO1xyXG5cclxuICAgIGZ1bmN0aW9uIHJlbW92ZUVsZW1lbnQoZWwpIHtcclxuICAgICAgICBpZiAoZWwucGFyZW50Tm9kZSkge1xyXG4gICAgICAgICAgICBlbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBRdWVyeWluZ1xyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgZnVuY3Rpb24gZWxlbWVudENsb3Nlc3QoZWwsIHNlbGVjdG9yKSB7XHJcbiAgICAgICAgaWYgKGVsLmNsb3Nlc3QpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGVsLmNsb3Nlc3Qoc2VsZWN0b3IpO1xyXG4gICAgICAgICAgICAvLyByZWFsbHkgYmFkIGZhbGxiYWNrIGZvciBJRVxyXG4gICAgICAgICAgICAvLyBmcm9tIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FbGVtZW50L2Nsb3Nlc3RcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY29udGFpbnMoZWwpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgIGlmIChlbGVtZW50TWF0Y2hlcyhlbCwgc2VsZWN0b3IpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZWw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWwgPSAoZWwucGFyZW50RWxlbWVudCB8fCBlbC5wYXJlbnROb2RlKTtcclxuICAgICAgICB9IHdoaWxlIChlbCAhPT0gbnVsbCAmJiBlbC5ub2RlVHlwZSA9PT0gMSk7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBlbGVtZW50TWF0Y2hlcyhlbCwgc2VsZWN0b3IpIHtcclxuICAgICAgICBsZXQgbWV0aG9kID0gZWwubWF0Y2hlcyB8fCBlbC5tYXRjaGVzU2VsZWN0b3IgfHwgZWwubXNNYXRjaGVzU2VsZWN0b3I7XHJcbiAgICAgICAgcmV0dXJuIG1ldGhvZC5jYWxsKGVsLCBzZWxlY3Rvcik7XHJcbiAgICB9XHJcbiAgICAvLyBhY2NlcHRzIG11bHRpcGxlIHN1YmplY3QgZWxzXHJcbiAgICAvLyByZXR1cm5zIGEgcmVhbCBhcnJheS4gZ29vZCBmb3IgbWV0aG9kcyBsaWtlIGZvckVhY2hcclxuICAgIC8vIFRPRE86IGFjY2VwdCB0aGUgZG9jdW1lbnRcclxuICAgIGZ1bmN0aW9uIGZpbmRFbGVtZW50cyhjb250YWluZXIsIHNlbGVjdG9yKSB7XHJcbiAgICAgICAgbGV0IGNvbnRhaW5lcnMgPSBjb250YWluZXIgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCA/IFtjb250YWluZXJdIDogY29udGFpbmVyO1xyXG4gICAgICAgIGxldCBhbGxNYXRjaGVzID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb250YWluZXJzLmxlbmd0aDsgaSArPSAxKSB7XHJcbiAgICAgICAgICAgIGxldCBtYXRjaGVzID0gY29udGFpbmVyc1tpXS5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBtYXRjaGVzLmxlbmd0aDsgaiArPSAxKSB7XHJcbiAgICAgICAgICAgICAgICBhbGxNYXRjaGVzLnB1c2gobWF0Y2hlc1tqXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGFsbE1hdGNoZXM7XHJcbiAgICB9XHJcbiAgICAvLyBhY2NlcHRzIG11bHRpcGxlIHN1YmplY3QgZWxzXHJcbiAgICAvLyBvbmx5IHF1ZXJpZXMgZGlyZWN0IGNoaWxkIGVsZW1lbnRzIC8vIFRPRE86IHJlbmFtZSB0byBmaW5kRGlyZWN0Q2hpbGRyZW4hXHJcbiAgICBmdW5jdGlvbiBmaW5kRGlyZWN0Q2hpbGRyZW4ocGFyZW50LCBzZWxlY3Rvcikge1xyXG4gICAgICAgIGxldCBwYXJlbnRzID0gcGFyZW50IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgPyBbcGFyZW50XSA6IHBhcmVudDtcclxuICAgICAgICBsZXQgYWxsTWF0Y2hlcyA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFyZW50cy5sZW5ndGg7IGkgKz0gMSkge1xyXG4gICAgICAgICAgICBsZXQgY2hpbGROb2RlcyA9IHBhcmVudHNbaV0uY2hpbGRyZW47IC8vIG9ubHkgZXZlciBlbGVtZW50c1xyXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNoaWxkTm9kZXMubGVuZ3RoOyBqICs9IDEpIHtcclxuICAgICAgICAgICAgICAgIGxldCBjaGlsZE5vZGUgPSBjaGlsZE5vZGVzW2pdO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFzZWxlY3RvciB8fCBlbGVtZW50TWF0Y2hlcyhjaGlsZE5vZGUsIHNlbGVjdG9yKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGFsbE1hdGNoZXMucHVzaChjaGlsZE5vZGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhbGxNYXRjaGVzO1xyXG4gICAgfVxyXG4gICAgLy8gU3R5bGVcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIGNvbnN0IFBJWEVMX1BST1BfUkUgPSAvKHRvcHxsZWZ0fHJpZ2h0fGJvdHRvbXx3aWR0aHxoZWlnaHQpJC9pO1xyXG4gICAgZnVuY3Rpb24gYXBwbHlTdHlsZShlbCwgcHJvcHMpIHtcclxuICAgICAgICBmb3IgKGxldCBwcm9wTmFtZSBpbiBwcm9wcykge1xyXG4gICAgICAgICAgICBhcHBseVN0eWxlUHJvcChlbCwgcHJvcE5hbWUsIHByb3BzW3Byb3BOYW1lXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYXBwbHlTdHlsZVByb3AoZWwsIG5hbWUsIHZhbCkge1xyXG4gICAgICAgIGlmICh2YWwgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBlbC5zdHlsZVtuYW1lXSA9ICcnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJyAmJiBQSVhFTF9QUk9QX1JFLnRlc3QobmFtZSkpIHtcclxuICAgICAgICAgICAgZWwuc3R5bGVbbmFtZV0gPSBgJHt2YWx9cHhgO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZWwuc3R5bGVbbmFtZV0gPSB2YWw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gRXZlbnQgSGFuZGxpbmdcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIC8vIGlmIGludGVyY2VwdGluZyBidWJibGVkIGV2ZW50cyBhdCB0aGUgZG9jdW1lbnQvd2luZG93L2JvZHkgbGV2ZWwsXHJcbiAgICAvLyBhbmQgd2FudCB0byBzZWUgb3JpZ2luYXRpbmcgZWxlbWVudCAodGhlICd0YXJnZXQnKSwgdXNlIHRoaXMgdXRpbCBpbnN0ZWFkXHJcbiAgICAvLyBvZiBgZXYudGFyZ2V0YCBiZWNhdXNlIGl0IGdvZXMgd2l0aGluIHdlYi1jb21wb25lbnQgYm91bmRhcmllcy5cclxuICAgIGZ1bmN0aW9uIGdldEV2ZW50VGFyZ2V0VmlhUm9vdChldikge1xyXG4gICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgcmV0dXJuIChfYiA9IChfYSA9IGV2LmNvbXBvc2VkUGF0aCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwoZXYpWzBdKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBldi50YXJnZXQ7XHJcbiAgICB9XHJcbiAgICAvLyBVbmlxdWUgSUQgZm9yIERPTSBhdHRyaWJ1dGVcclxuICAgIGxldCBndWlkJDEgPSAwO1xyXG4gICAgZnVuY3Rpb24gZ2V0VW5pcXVlRG9tSWQoKSB7XHJcbiAgICAgICAgZ3VpZCQxICs9IDE7XHJcbiAgICAgICAgcmV0dXJuICdmYy1kb20tJyArIGd1aWQkMTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBTdG9wcyBhIG1vdXNlL3RvdWNoIGV2ZW50IGZyb20gZG9pbmcgaXQncyBuYXRpdmUgYnJvd3NlciBhY3Rpb25cclxuICAgIGZ1bmN0aW9uIHByZXZlbnREZWZhdWx0KGV2KSB7XHJcbiAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcclxuICAgIH1cclxuICAgIC8vIEV2ZW50IERlbGVnYXRpb25cclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIGZ1bmN0aW9uIGJ1aWxkRGVsZWdhdGlvbkhhbmRsZXIoc2VsZWN0b3IsIGhhbmRsZXIpIHtcclxuICAgICAgICByZXR1cm4gKGV2KSA9PiB7XHJcbiAgICAgICAgICAgIGxldCBtYXRjaGVkQ2hpbGQgPSBlbGVtZW50Q2xvc2VzdChldi50YXJnZXQsIHNlbGVjdG9yKTtcclxuICAgICAgICAgICAgaWYgKG1hdGNoZWRDaGlsZCkge1xyXG4gICAgICAgICAgICAgICAgaGFuZGxlci5jYWxsKG1hdGNoZWRDaGlsZCwgZXYsIG1hdGNoZWRDaGlsZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gbGlzdGVuQnlTZWxlY3Rvcihjb250YWluZXIsIGV2ZW50VHlwZSwgc2VsZWN0b3IsIGhhbmRsZXIpIHtcclxuICAgICAgICBsZXQgYXR0YWNoZWRIYW5kbGVyID0gYnVpbGREZWxlZ2F0aW9uSGFuZGxlcihzZWxlY3RvciwgaGFuZGxlcik7XHJcbiAgICAgICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBhdHRhY2hlZEhhbmRsZXIpO1xyXG4gICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgYXR0YWNoZWRIYW5kbGVyKTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gbGlzdGVuVG9Ib3ZlckJ5U2VsZWN0b3IoY29udGFpbmVyLCBzZWxlY3Rvciwgb25Nb3VzZUVudGVyLCBvbk1vdXNlTGVhdmUpIHtcclxuICAgICAgICBsZXQgY3VycmVudE1hdGNoZWRDaGlsZDtcclxuICAgICAgICByZXR1cm4gbGlzdGVuQnlTZWxlY3Rvcihjb250YWluZXIsICdtb3VzZW92ZXInLCBzZWxlY3RvciwgKG1vdXNlT3ZlckV2LCBtYXRjaGVkQ2hpbGQpID0+IHtcclxuICAgICAgICAgICAgaWYgKG1hdGNoZWRDaGlsZCAhPT0gY3VycmVudE1hdGNoZWRDaGlsZCkge1xyXG4gICAgICAgICAgICAgICAgY3VycmVudE1hdGNoZWRDaGlsZCA9IG1hdGNoZWRDaGlsZDtcclxuICAgICAgICAgICAgICAgIG9uTW91c2VFbnRlcihtb3VzZU92ZXJFdiwgbWF0Y2hlZENoaWxkKTtcclxuICAgICAgICAgICAgICAgIGxldCByZWFsT25Nb3VzZUxlYXZlID0gKG1vdXNlTGVhdmVFdikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRNYXRjaGVkQ2hpbGQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIG9uTW91c2VMZWF2ZShtb3VzZUxlYXZlRXYsIG1hdGNoZWRDaGlsZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZENoaWxkLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCByZWFsT25Nb3VzZUxlYXZlKTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAvLyBsaXN0ZW4gdG8gdGhlIG5leHQgbW91c2VsZWF2ZSwgYW5kIHRoZW4gdW5hdHRhY2hcclxuICAgICAgICAgICAgICAgIG1hdGNoZWRDaGlsZC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgcmVhbE9uTW91c2VMZWF2ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8vIEFuaW1hdGlvblxyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgY29uc3QgdHJhbnNpdGlvbkV2ZW50TmFtZXMgPSBbXHJcbiAgICAgICAgJ3dlYmtpdFRyYW5zaXRpb25FbmQnLFxyXG4gICAgICAgICdvdHJhbnNpdGlvbmVuZCcsXHJcbiAgICAgICAgJ29UcmFuc2l0aW9uRW5kJyxcclxuICAgICAgICAnbXNUcmFuc2l0aW9uRW5kJyxcclxuICAgICAgICAndHJhbnNpdGlvbmVuZCcsXHJcbiAgICBdO1xyXG4gICAgLy8gdHJpZ2dlcmVkIG9ubHkgd2hlbiB0aGUgbmV4dCBzaW5nbGUgc3Vic2VxdWVudCB0cmFuc2l0aW9uIGZpbmlzaGVzXHJcbiAgICBmdW5jdGlvbiB3aGVuVHJhbnNpdGlvbkRvbmUoZWwsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgbGV0IHJlYWxDYWxsYmFjayA9IChldikgPT4ge1xyXG4gICAgICAgICAgICBjYWxsYmFjayhldik7XHJcbiAgICAgICAgICAgIHRyYW5zaXRpb25FdmVudE5hbWVzLmZvckVhY2goKGV2ZW50TmFtZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIHJlYWxDYWxsYmFjayk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdHJhbnNpdGlvbkV2ZW50TmFtZXMuZm9yRWFjaCgoZXZlbnROYW1lKSA9PiB7XHJcbiAgICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCByZWFsQ2FsbGJhY2spOyAvLyBjcm9zcy1icm93c2VyIHdheSB0byBkZXRlcm1pbmUgd2hlbiB0aGUgdHJhbnNpdGlvbiBmaW5pc2hlc1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLy8gQVJJQSB3b3JrYXJvdW5kc1xyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgZnVuY3Rpb24gY3JlYXRlQXJpYUNsaWNrQXR0cnMoaGFuZGxlcikge1xyXG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHsgb25DbGljazogaGFuZGxlciB9LCBjcmVhdGVBcmlhS2V5Ym9hcmRBdHRycyhoYW5kbGVyKSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBjcmVhdGVBcmlhS2V5Ym9hcmRBdHRycyhoYW5kbGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdGFiSW5kZXg6IDAsXHJcbiAgICAgICAgICAgIG9uS2V5RG93bihldikge1xyXG4gICAgICAgICAgICAgICAgaWYgKGV2LmtleSA9PT0gJ0VudGVyJyB8fCBldi5rZXkgPT09ICcgJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZXIoZXYpO1xyXG4gICAgICAgICAgICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7IC8vIGlmIHNwYWNlLCBkb24ndCBzY3JvbGwgZG93biBwYWdlXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBsZXQgZ3VpZE51bWJlciA9IDA7XHJcbiAgICBmdW5jdGlvbiBndWlkKCkge1xyXG4gICAgICAgIGd1aWROdW1iZXIgKz0gMTtcclxuICAgICAgICByZXR1cm4gU3RyaW5nKGd1aWROdW1iZXIpO1xyXG4gICAgfVxyXG4gICAgLyogRnVsbENhbGVuZGFyLXNwZWNpZmljIERPTSBVdGlsaXRpZXNcclxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgLy8gTWFrZSB0aGUgbW91c2UgY3Vyc29yIGV4cHJlc3MgdGhhdCBhbiBldmVudCBpcyBub3QgYWxsb3dlZCBpbiB0aGUgY3VycmVudCBhcmVhXHJcbiAgICBmdW5jdGlvbiBkaXNhYmxlQ3Vyc29yKCkge1xyXG4gICAgICAgIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LmFkZCgnZmMtbm90LWFsbG93ZWQnKTtcclxuICAgIH1cclxuICAgIC8vIFJldHVybnMgdGhlIG1vdXNlIGN1cnNvciB0byBpdHMgb3JpZ2luYWwgbG9va1xyXG4gICAgZnVuY3Rpb24gZW5hYmxlQ3Vyc29yKCkge1xyXG4gICAgICAgIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LnJlbW92ZSgnZmMtbm90LWFsbG93ZWQnKTtcclxuICAgIH1cclxuICAgIC8qIFNlbGVjdGlvblxyXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbiAgICBmdW5jdGlvbiBwcmV2ZW50U2VsZWN0aW9uKGVsKSB7XHJcbiAgICAgICAgZWwuc3R5bGUudXNlclNlbGVjdCA9ICdub25lJztcclxuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdzZWxlY3RzdGFydCcsIHByZXZlbnREZWZhdWx0KTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGFsbG93U2VsZWN0aW9uKGVsKSB7XHJcbiAgICAgICAgZWwuc3R5bGUudXNlclNlbGVjdCA9ICcnO1xyXG4gICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3NlbGVjdHN0YXJ0JywgcHJldmVudERlZmF1bHQpO1xyXG4gICAgfVxyXG4gICAgLyogQ29udGV4dCBNZW51XHJcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgIGZ1bmN0aW9uIHByZXZlbnRDb250ZXh0TWVudShlbCkge1xyXG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NvbnRleHRtZW51JywgcHJldmVudERlZmF1bHQpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYWxsb3dDb250ZXh0TWVudShlbCkge1xyXG4gICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NvbnRleHRtZW51JywgcHJldmVudERlZmF1bHQpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gcGFyc2VGaWVsZFNwZWNzKGlucHV0KSB7XHJcbiAgICAgICAgbGV0IHNwZWNzID0gW107XHJcbiAgICAgICAgbGV0IHRva2VucyA9IFtdO1xyXG4gICAgICAgIGxldCBpO1xyXG4gICAgICAgIGxldCB0b2tlbjtcclxuICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICB0b2tlbnMgPSBpbnB1dC5zcGxpdCgvXFxzKixcXHMqLyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICB0b2tlbnMgPSBbaW5wdXRdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGlucHV0KSkge1xyXG4gICAgICAgICAgICB0b2tlbnMgPSBpbnB1dDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkgKz0gMSkge1xyXG4gICAgICAgICAgICB0b2tlbiA9IHRva2Vuc1tpXTtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB0b2tlbiA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgIHNwZWNzLnB1c2godG9rZW4uY2hhckF0KDApID09PSAnLScgP1xyXG4gICAgICAgICAgICAgICAgICAgIHsgZmllbGQ6IHRva2VuLnN1YnN0cmluZygxKSwgb3JkZXI6IC0xIH0gOlxyXG4gICAgICAgICAgICAgICAgICAgIHsgZmllbGQ6IHRva2VuLCBvcmRlcjogMSB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdG9rZW4gPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICAgIHNwZWNzLnB1c2goeyBmdW5jOiB0b2tlbiB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc3BlY3M7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBjb21wYXJlQnlGaWVsZFNwZWNzKG9iajAsIG9iajEsIGZpZWxkU3BlY3MpIHtcclxuICAgICAgICBsZXQgaTtcclxuICAgICAgICBsZXQgY21wO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBmaWVsZFNwZWNzLmxlbmd0aDsgaSArPSAxKSB7XHJcbiAgICAgICAgICAgIGNtcCA9IGNvbXBhcmVCeUZpZWxkU3BlYyhvYmowLCBvYmoxLCBmaWVsZFNwZWNzW2ldKTtcclxuICAgICAgICAgICAgaWYgKGNtcCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNtcDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gMDtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGNvbXBhcmVCeUZpZWxkU3BlYyhvYmowLCBvYmoxLCBmaWVsZFNwZWMpIHtcclxuICAgICAgICBpZiAoZmllbGRTcGVjLmZ1bmMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZpZWxkU3BlYy5mdW5jKG9iajAsIG9iajEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmxleGlibGVDb21wYXJlKG9iajBbZmllbGRTcGVjLmZpZWxkXSwgb2JqMVtmaWVsZFNwZWMuZmllbGRdKVxyXG4gICAgICAgICAgICAqIChmaWVsZFNwZWMub3JkZXIgfHwgMSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBmbGV4aWJsZUNvbXBhcmUoYSwgYikge1xyXG4gICAgICAgIGlmICghYSAmJiAhYikge1xyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGIgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChhID09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlb2YgYSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGIgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBTdHJpbmcoYSkubG9jYWxlQ29tcGFyZShTdHJpbmcoYikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYSAtIGI7XHJcbiAgICB9XHJcbiAgICAvKiBTdHJpbmcgVXRpbGl0aWVzXHJcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgIGZ1bmN0aW9uIHBhZFN0YXJ0KHZhbCwgbGVuKSB7XHJcbiAgICAgICAgbGV0IHMgPSBTdHJpbmcodmFsKTtcclxuICAgICAgICByZXR1cm4gJzAwMCcuc3Vic3RyKDAsIGxlbiAtIHMubGVuZ3RoKSArIHM7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBmb3JtYXRXaXRoT3JkaW5hbHMoZm9ybWF0dGVyLCBhcmdzLCBmYWxsYmFja1RleHQpIHtcclxuICAgICAgICBpZiAodHlwZW9mIGZvcm1hdHRlciA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0dGVyKC4uLmFyZ3MpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mIGZvcm1hdHRlciA9PT0gJ3N0cmluZycpIHsgLy8gbm9uLWJsYW5rIHN0cmluZ1xyXG4gICAgICAgICAgICByZXR1cm4gYXJncy5yZWR1Y2UoKHN0ciwgYXJnLCBpbmRleCkgPT4gKHN0ci5yZXBsYWNlKCckJyArIGluZGV4LCBhcmcgfHwgJycpKSwgZm9ybWF0dGVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbGxiYWNrVGV4dDtcclxuICAgIH1cclxuICAgIC8qIE51bWJlciBVdGlsaXRpZXNcclxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgZnVuY3Rpb24gY29tcGFyZU51bWJlcnMoYSwgYikge1xyXG4gICAgICAgIHJldHVybiBhIC0gYjtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGlzSW50KG4pIHtcclxuICAgICAgICByZXR1cm4gbiAlIDEgPT09IDA7XHJcbiAgICB9XHJcbiAgICAvKiBGQy1zcGVjaWZpYyBET00gZGltZW5zaW9uIHN0dWZmXHJcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgIGZ1bmN0aW9uIGNvbXB1dGVTbWFsbGVzdENlbGxXaWR0aChjZWxsRWwpIHtcclxuICAgICAgICBsZXQgYWxsV2lkdGhFbCA9IGNlbGxFbC5xdWVyeVNlbGVjdG9yKCcuZmMtc2Nyb2xsZ3JpZC1zaHJpbmstZnJhbWUnKTtcclxuICAgICAgICBsZXQgY29udGVudFdpZHRoRWwgPSBjZWxsRWwucXVlcnlTZWxlY3RvcignLmZjLXNjcm9sbGdyaWQtc2hyaW5rLWN1c2hpb24nKTtcclxuICAgICAgICBpZiAoIWFsbFdpZHRoRWwpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCduZWVkcyBmYy1zY3JvbGxncmlkLXNocmluay1mcmFtZSBjbGFzc05hbWUnKTsgLy8gVE9ETzogdXNlIGNvbnN0XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghY29udGVudFdpZHRoRWwpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCduZWVkcyBmYy1zY3JvbGxncmlkLXNocmluay1jdXNoaW9uIGNsYXNzTmFtZScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY2VsbEVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoIC0gYWxsV2lkdGhFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCArIC8vIHRoZSBjZWxsIHBhZGRpbmcrYm9yZGVyXHJcbiAgICAgICAgICAgIGNvbnRlbnRXaWR0aEVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IElOVEVSTkFMX1VOSVRTID0gWyd5ZWFycycsICdtb250aHMnLCAnZGF5cycsICdtaWxsaXNlY29uZHMnXTtcclxuICAgIGNvbnN0IFBBUlNFX1JFID0gL14oLT8pKD86KFxcZCspXFwuKT8oXFxkKyk6KFxcZFxcZCkoPzo6KFxcZFxcZCkoPzpcXC4oXFxkXFxkXFxkKSk/KT8vO1xyXG4gICAgLy8gUGFyc2luZyBhbmQgQ3JlYXRpb25cclxuICAgIGZ1bmN0aW9uIGNyZWF0ZUR1cmF0aW9uKGlucHV0LCB1bml0KSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlU3RyaW5nKGlucHV0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ29iamVjdCcgJiYgaW5wdXQpIHsgLy8gbm9uLW51bGwgb2JqZWN0XHJcbiAgICAgICAgICAgIHJldHVybiBwYXJzZU9iamVjdChpbnB1dCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBwYXJzZU9iamVjdCh7IFt1bml0IHx8ICdtaWxsaXNlY29uZHMnXTogaW5wdXQgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gcGFyc2VTdHJpbmcocykge1xyXG4gICAgICAgIGxldCBtID0gUEFSU0VfUkUuZXhlYyhzKTtcclxuICAgICAgICBpZiAobSkge1xyXG4gICAgICAgICAgICBsZXQgc2lnbiA9IG1bMV0gPyAtMSA6IDE7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICB5ZWFyczogMCxcclxuICAgICAgICAgICAgICAgIG1vbnRoczogMCxcclxuICAgICAgICAgICAgICAgIGRheXM6IHNpZ24gKiAobVsyXSA/IHBhcnNlSW50KG1bMl0sIDEwKSA6IDApLFxyXG4gICAgICAgICAgICAgICAgbWlsbGlzZWNvbmRzOiBzaWduICogKChtWzNdID8gcGFyc2VJbnQobVszXSwgMTApIDogMCkgKiA2MCAqIDYwICogMTAwMCArIC8vIGhvdXJzXHJcbiAgICAgICAgICAgICAgICAgICAgKG1bNF0gPyBwYXJzZUludChtWzRdLCAxMCkgOiAwKSAqIDYwICogMTAwMCArIC8vIG1pbnV0ZXNcclxuICAgICAgICAgICAgICAgICAgICAobVs1XSA/IHBhcnNlSW50KG1bNV0sIDEwKSA6IDApICogMTAwMCArIC8vIHNlY29uZHNcclxuICAgICAgICAgICAgICAgICAgICAobVs2XSA/IHBhcnNlSW50KG1bNl0sIDEwKSA6IDApIC8vIG1zXHJcbiAgICAgICAgICAgICAgICApLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHBhcnNlT2JqZWN0KG9iaikge1xyXG4gICAgICAgIGxldCBkdXJhdGlvbiA9IHtcclxuICAgICAgICAgICAgeWVhcnM6IG9iai55ZWFycyB8fCBvYmoueWVhciB8fCAwLFxyXG4gICAgICAgICAgICBtb250aHM6IG9iai5tb250aHMgfHwgb2JqLm1vbnRoIHx8IDAsXHJcbiAgICAgICAgICAgIGRheXM6IG9iai5kYXlzIHx8IG9iai5kYXkgfHwgMCxcclxuICAgICAgICAgICAgbWlsbGlzZWNvbmRzOiAob2JqLmhvdXJzIHx8IG9iai5ob3VyIHx8IDApICogNjAgKiA2MCAqIDEwMDAgKyAvLyBob3Vyc1xyXG4gICAgICAgICAgICAgICAgKG9iai5taW51dGVzIHx8IG9iai5taW51dGUgfHwgMCkgKiA2MCAqIDEwMDAgKyAvLyBtaW51dGVzXHJcbiAgICAgICAgICAgICAgICAob2JqLnNlY29uZHMgfHwgb2JqLnNlY29uZCB8fCAwKSAqIDEwMDAgKyAvLyBzZWNvbmRzXHJcbiAgICAgICAgICAgICAgICAob2JqLm1pbGxpc2Vjb25kcyB8fCBvYmoubWlsbGlzZWNvbmQgfHwgb2JqLm1zIHx8IDApLCAvLyBtc1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgbGV0IHdlZWtzID0gb2JqLndlZWtzIHx8IG9iai53ZWVrO1xyXG4gICAgICAgIGlmICh3ZWVrcykge1xyXG4gICAgICAgICAgICBkdXJhdGlvbi5kYXlzICs9IHdlZWtzICogNztcclxuICAgICAgICAgICAgZHVyYXRpb24uc3BlY2lmaWVkV2Vla3MgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZHVyYXRpb247XHJcbiAgICB9XHJcbiAgICAvLyBFcXVhbGl0eVxyXG4gICAgZnVuY3Rpb24gZHVyYXRpb25zRXF1YWwoZDAsIGQxKSB7XHJcbiAgICAgICAgcmV0dXJuIGQwLnllYXJzID09PSBkMS55ZWFycyAmJlxyXG4gICAgICAgICAgICBkMC5tb250aHMgPT09IGQxLm1vbnRocyAmJlxyXG4gICAgICAgICAgICBkMC5kYXlzID09PSBkMS5kYXlzICYmXHJcbiAgICAgICAgICAgIGQwLm1pbGxpc2Vjb25kcyA9PT0gZDEubWlsbGlzZWNvbmRzO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYXNDbGVhbkRheXMoZHVyKSB7XHJcbiAgICAgICAgaWYgKCFkdXIueWVhcnMgJiYgIWR1ci5tb250aHMgJiYgIWR1ci5taWxsaXNlY29uZHMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGR1ci5kYXlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gMDtcclxuICAgIH1cclxuICAgIC8vIFNpbXBsZSBNYXRoXHJcbiAgICBmdW5jdGlvbiBhZGREdXJhdGlvbnMoZDAsIGQxKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgeWVhcnM6IGQwLnllYXJzICsgZDEueWVhcnMsXHJcbiAgICAgICAgICAgIG1vbnRoczogZDAubW9udGhzICsgZDEubW9udGhzLFxyXG4gICAgICAgICAgICBkYXlzOiBkMC5kYXlzICsgZDEuZGF5cyxcclxuICAgICAgICAgICAgbWlsbGlzZWNvbmRzOiBkMC5taWxsaXNlY29uZHMgKyBkMS5taWxsaXNlY29uZHMsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHN1YnRyYWN0RHVyYXRpb25zKGQxLCBkMCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHllYXJzOiBkMS55ZWFycyAtIGQwLnllYXJzLFxyXG4gICAgICAgICAgICBtb250aHM6IGQxLm1vbnRocyAtIGQwLm1vbnRocyxcclxuICAgICAgICAgICAgZGF5czogZDEuZGF5cyAtIGQwLmRheXMsXHJcbiAgICAgICAgICAgIG1pbGxpc2Vjb25kczogZDEubWlsbGlzZWNvbmRzIC0gZDAubWlsbGlzZWNvbmRzLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBtdWx0aXBseUR1cmF0aW9uKGQsIG4pIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB5ZWFyczogZC55ZWFycyAqIG4sXHJcbiAgICAgICAgICAgIG1vbnRoczogZC5tb250aHMgKiBuLFxyXG4gICAgICAgICAgICBkYXlzOiBkLmRheXMgKiBuLFxyXG4gICAgICAgICAgICBtaWxsaXNlY29uZHM6IGQubWlsbGlzZWNvbmRzICogbixcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgLy8gQ29udmVyc2lvbnNcclxuICAgIC8vIFwiUm91Z2hcIiBiZWNhdXNlIHRoZXkgYXJlIGJhc2VkIG9uIGF2ZXJhZ2UtY2FzZSBHcmVnb3JpYW4gbW9udGhzL3llYXJzXHJcbiAgICBmdW5jdGlvbiBhc1JvdWdoWWVhcnMoZHVyKSB7XHJcbiAgICAgICAgcmV0dXJuIGFzUm91Z2hEYXlzKGR1cikgLyAzNjU7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBhc1JvdWdoTW9udGhzKGR1cikge1xyXG4gICAgICAgIHJldHVybiBhc1JvdWdoRGF5cyhkdXIpIC8gMzA7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBhc1JvdWdoRGF5cyhkdXIpIHtcclxuICAgICAgICByZXR1cm4gYXNSb3VnaE1zKGR1cikgLyA4NjRlNTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGFzUm91Z2hNaW51dGVzKGR1cikge1xyXG4gICAgICAgIHJldHVybiBhc1JvdWdoTXMoZHVyKSAvICgxMDAwICogNjApO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYXNSb3VnaFNlY29uZHMoZHVyKSB7XHJcbiAgICAgICAgcmV0dXJuIGFzUm91Z2hNcyhkdXIpIC8gMTAwMDtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGFzUm91Z2hNcyhkdXIpIHtcclxuICAgICAgICByZXR1cm4gZHVyLnllYXJzICogKDM2NSAqIDg2NGU1KSArXHJcbiAgICAgICAgICAgIGR1ci5tb250aHMgKiAoMzAgKiA4NjRlNSkgK1xyXG4gICAgICAgICAgICBkdXIuZGF5cyAqIDg2NGU1ICtcclxuICAgICAgICAgICAgZHVyLm1pbGxpc2Vjb25kcztcclxuICAgIH1cclxuICAgIC8vIEFkdmFuY2VkIE1hdGhcclxuICAgIGZ1bmN0aW9uIHdob2xlRGl2aWRlRHVyYXRpb25zKG51bWVyYXRvciwgZGVub21pbmF0b3IpIHtcclxuICAgICAgICBsZXQgcmVzID0gbnVsbDtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IElOVEVSTkFMX1VOSVRTLmxlbmd0aDsgaSArPSAxKSB7XHJcbiAgICAgICAgICAgIGxldCB1bml0ID0gSU5URVJOQUxfVU5JVFNbaV07XHJcbiAgICAgICAgICAgIGlmIChkZW5vbWluYXRvclt1bml0XSkge1xyXG4gICAgICAgICAgICAgICAgbGV0IGxvY2FsUmVzID0gbnVtZXJhdG9yW3VuaXRdIC8gZGVub21pbmF0b3JbdW5pdF07XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzSW50KGxvY2FsUmVzKSB8fCAocmVzICE9PSBudWxsICYmIHJlcyAhPT0gbG9jYWxSZXMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXMgPSBsb2NhbFJlcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChudW1lcmF0b3JbdW5pdF0pIHtcclxuICAgICAgICAgICAgICAgIC8vIG5lZWRzIHRvIGRpdmlkZSBieSBzb21ldGhpbmcgYnV0IGNhbid0IVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGdyZWF0ZXN0RHVyYXRpb25EZW5vbWluYXRvcihkdXIpIHtcclxuICAgICAgICBsZXQgbXMgPSBkdXIubWlsbGlzZWNvbmRzO1xyXG4gICAgICAgIGlmIChtcykge1xyXG4gICAgICAgICAgICBpZiAobXMgJSAxMDAwICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4geyB1bml0OiAnbWlsbGlzZWNvbmQnLCB2YWx1ZTogbXMgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobXMgJSAoMTAwMCAqIDYwKSAhPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdW5pdDogJ3NlY29uZCcsIHZhbHVlOiBtcyAvIDEwMDAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobXMgJSAoMTAwMCAqIDYwICogNjApICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4geyB1bml0OiAnbWludXRlJywgdmFsdWU6IG1zIC8gKDEwMDAgKiA2MCkgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobXMpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7IHVuaXQ6ICdob3VyJywgdmFsdWU6IG1zIC8gKDEwMDAgKiA2MCAqIDYwKSB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChkdXIuZGF5cykge1xyXG4gICAgICAgICAgICBpZiAoZHVyLnNwZWNpZmllZFdlZWtzICYmIGR1ci5kYXlzICUgNyA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdW5pdDogJ3dlZWsnLCB2YWx1ZTogZHVyLmRheXMgLyA3IH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHsgdW5pdDogJ2RheScsIHZhbHVlOiBkdXIuZGF5cyB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZHVyLm1vbnRocykge1xyXG4gICAgICAgICAgICByZXR1cm4geyB1bml0OiAnbW9udGgnLCB2YWx1ZTogZHVyLm1vbnRocyB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZHVyLnllYXJzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7IHVuaXQ6ICd5ZWFyJywgdmFsdWU6IGR1ci55ZWFycyB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4geyB1bml0OiAnbWlsbGlzZWNvbmQnLCB2YWx1ZTogMCB9O1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHsgaGFzT3duUHJvcGVydHkgfSA9IE9iamVjdC5wcm90b3R5cGU7XHJcbiAgICAvLyBNZXJnZXMgYW4gYXJyYXkgb2Ygb2JqZWN0cyBpbnRvIGEgc2luZ2xlIG9iamVjdC5cclxuICAgIC8vIFRoZSBzZWNvbmQgYXJndW1lbnQgYWxsb3dzIGZvciBhbiBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyB3aG8ncyBvYmplY3QgdmFsdWVzIHdpbGwgYmUgbWVyZ2VkIHRvZ2V0aGVyLlxyXG4gICAgZnVuY3Rpb24gbWVyZ2VQcm9wcyhwcm9wT2JqcywgY29tcGxleFByb3BzTWFwKSB7XHJcbiAgICAgICAgbGV0IGRlc3QgPSB7fTtcclxuICAgICAgICBpZiAoY29tcGxleFByb3BzTWFwKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IG5hbWUgaW4gY29tcGxleFByb3BzTWFwKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY29tcGxleFByb3BzTWFwW25hbWVdID09PSBpc01heWJlT2JqZWN0c0VxdWFsKSB7IC8vIGltcGxpZXMgdGhhdCBpdCdzIG9iamVjdC1tZXJnZWFibGVcclxuICAgICAgICAgICAgICAgICAgICBsZXQgY29tcGxleE9ianMgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBjb2xsZWN0IHRoZSB0cmFpbGluZyBvYmplY3QgdmFsdWVzLCBzdG9wcGluZyB3aGVuIGEgbm9uLW9iamVjdCBpcyBkaXNjb3ZlcmVkXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IHByb3BPYmpzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaSAtPSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB2YWwgPSBwcm9wT2Jqc1tpXVtuYW1lXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdvYmplY3QnICYmIHZhbCkgeyAvLyBub24tbnVsbCBvYmplY3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBsZXhPYmpzLnVuc2hpZnQodmFsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh2YWwgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVzdFtuYW1lXSA9IHZhbDsgLy8gaWYgdGhlcmUgd2VyZSBubyBvYmplY3RzLCB0aGlzIHZhbHVlIHdpbGwgYmUgdXNlZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIHRyYWlsaW5nIHZhbHVlcyB3ZXJlIG9iamVjdHMsIHVzZSB0aGUgbWVyZ2VkIHZhbHVlXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXBsZXhPYmpzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXN0W25hbWVdID0gbWVyZ2VQcm9wcyhjb21wbGV4T2Jqcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGNvcHkgdmFsdWVzIGludG8gdGhlIGRlc3RpbmF0aW9uLCBnb2luZyBmcm9tIGxhc3QgdG8gZmlyc3RcclxuICAgICAgICBmb3IgKGxldCBpID0gcHJvcE9ianMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpIC09IDEpIHtcclxuICAgICAgICAgICAgbGV0IHByb3BzID0gcHJvcE9ianNbaV07XHJcbiAgICAgICAgICAgIGZvciAobGV0IG5hbWUgaW4gcHJvcHMpIHtcclxuICAgICAgICAgICAgICAgIGlmICghKG5hbWUgaW4gZGVzdCkpIHsgLy8gaWYgYWxyZWFkeSBhc3NpZ25lZCBieSBwcmV2aW91cyBwcm9wcyBvciBjb21wbGV4IHByb3BzLCBkb24ndCByZWFzc2lnblxyXG4gICAgICAgICAgICAgICAgICAgIGRlc3RbbmFtZV0gPSBwcm9wc1tuYW1lXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZGVzdDtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGZpbHRlckhhc2goaGFzaCwgZnVuYykge1xyXG4gICAgICAgIGxldCBmaWx0ZXJlZCA9IHt9O1xyXG4gICAgICAgIGZvciAobGV0IGtleSBpbiBoYXNoKSB7XHJcbiAgICAgICAgICAgIGlmIChmdW5jKGhhc2hba2V5XSwga2V5KSkge1xyXG4gICAgICAgICAgICAgICAgZmlsdGVyZWRba2V5XSA9IGhhc2hba2V5XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmlsdGVyZWQ7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBtYXBIYXNoKGhhc2gsIGZ1bmMpIHtcclxuICAgICAgICBsZXQgbmV3SGFzaCA9IHt9O1xyXG4gICAgICAgIGZvciAobGV0IGtleSBpbiBoYXNoKSB7XHJcbiAgICAgICAgICAgIG5ld0hhc2hba2V5XSA9IGZ1bmMoaGFzaFtrZXldLCBrZXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3SGFzaDtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGFycmF5VG9IYXNoKGEpIHtcclxuICAgICAgICBsZXQgaGFzaCA9IHt9O1xyXG4gICAgICAgIGZvciAobGV0IGl0ZW0gb2YgYSkge1xyXG4gICAgICAgICAgICBoYXNoW2l0ZW1dID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGhhc2g7XHJcbiAgICB9XHJcbiAgICAvLyBUT0RPOiByZWFzc2VzcyBicm93c2VyIHN1cHBvcnRcclxuICAgIC8vIGh0dHBzOi8vY2FuaXVzZS5jb20vP3NlYXJjaD1vYmplY3QudmFsdWVzXHJcbiAgICBmdW5jdGlvbiBoYXNoVmFsdWVzVG9BcnJheShvYmopIHtcclxuICAgICAgICBsZXQgYSA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IGtleSBpbiBvYmopIHtcclxuICAgICAgICAgICAgYS5wdXNoKG9ialtrZXldKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGE7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBpc1Byb3BzRXF1YWwob2JqMCwgb2JqMSkge1xyXG4gICAgICAgIGlmIChvYmowID09PSBvYmoxKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGxldCBrZXkgaW4gb2JqMCkge1xyXG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmowLCBrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIShrZXkgaW4gb2JqMSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChsZXQga2V5IGluIG9iajEpIHtcclxuICAgICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqMSwga2V5KSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG9iajBba2V5XSAhPT0gb2JqMVtrZXldKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgY29uc3QgSEFORExFUl9SRSA9IC9eb25bQS1aXS87XHJcbiAgICBmdW5jdGlvbiBpc05vbkhhbmRsZXJQcm9wc0VxdWFsKG9iajAsIG9iajEpIHtcclxuICAgICAgICBjb25zdCBrZXlzID0gZ2V0VW5lcXVhbFByb3BzKG9iajAsIG9iajEpO1xyXG4gICAgICAgIGZvciAobGV0IGtleSBvZiBrZXlzKSB7XHJcbiAgICAgICAgICAgIGlmICghSEFORExFUl9SRS50ZXN0KGtleSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGdldFVuZXF1YWxQcm9wcyhvYmowLCBvYmoxKSB7XHJcbiAgICAgICAgbGV0IGtleXMgPSBbXTtcclxuICAgICAgICBmb3IgKGxldCBrZXkgaW4gb2JqMCkge1xyXG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmowLCBrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIShrZXkgaW4gb2JqMSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBrZXlzLnB1c2goa2V5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGxldCBrZXkgaW4gb2JqMSkge1xyXG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmoxLCBrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAob2JqMFtrZXldICE9PSBvYmoxW2tleV0pIHtcclxuICAgICAgICAgICAgICAgICAgICBrZXlzLnB1c2goa2V5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4ga2V5cztcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGNvbXBhcmVPYmpzKG9sZFByb3BzLCBuZXdQcm9wcywgZXF1YWxpdHlGdW5jcyA9IHt9KSB7XHJcbiAgICAgICAgaWYgKG9sZFByb3BzID09PSBuZXdQcm9wcykge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChsZXQga2V5IGluIG5ld1Byb3BzKSB7XHJcbiAgICAgICAgICAgIGlmIChrZXkgaW4gb2xkUHJvcHMgJiYgaXNPYmpWYWxzRXF1YWwob2xkUHJvcHNba2V5XSwgbmV3UHJvcHNba2V5XSwgZXF1YWxpdHlGdW5jc1trZXldKSkgO1xyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBjaGVjayBmb3IgcHJvcHMgdGhhdCB3ZXJlIG9taXR0ZWQgaW4gdGhlIG5ld1xyXG4gICAgICAgIGZvciAobGV0IGtleSBpbiBvbGRQcm9wcykge1xyXG4gICAgICAgICAgICBpZiAoIShrZXkgaW4gbmV3UHJvcHMpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICAvKlxyXG4gICAgYXNzdW1lZCBcInRydWVcIiBlcXVhbGl0eSBmb3IgaGFuZGxlciBuYW1lcyBsaWtlIFwib25SZWNlaXZlU29tZXRoaW5nXCJcclxuICAgICovXHJcbiAgICBmdW5jdGlvbiBpc09ialZhbHNFcXVhbCh2YWwwLCB2YWwxLCBjb21wYXJhdG9yKSB7XHJcbiAgICAgICAgaWYgKHZhbDAgPT09IHZhbDEgfHwgY29tcGFyYXRvciA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNvbXBhcmF0b3IpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmF0b3IodmFsMCwgdmFsMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGNvbGxlY3RGcm9tSGFzaChoYXNoLCBzdGFydEluZGV4ID0gMCwgZW5kSW5kZXgsIHN0ZXAgPSAxKSB7XHJcbiAgICAgICAgbGV0IHJlcyA9IFtdO1xyXG4gICAgICAgIGlmIChlbmRJbmRleCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGVuZEluZGV4ID0gT2JqZWN0LmtleXMoaGFzaCkubGVuZ3RoO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGxldCBpID0gc3RhcnRJbmRleDsgaSA8IGVuZEluZGV4OyBpICs9IHN0ZXApIHtcclxuICAgICAgICAgICAgbGV0IHZhbCA9IGhhc2hbaV07XHJcbiAgICAgICAgICAgIGlmICh2YWwgIT09IHVuZGVmaW5lZCkgeyAvLyB3aWxsIGRpc3JlZ2FyZCB1bmRlZmluZWQgZm9yIHNwYXJzZSBhcnJheXNcclxuICAgICAgICAgICAgICAgIHJlcy5wdXNoKHZhbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgIH1cclxuXHJcbiAgICAvLyBUT0RPOiBuZXcgdXRpbCBhcnJheWlmeT9cclxuICAgIGZ1bmN0aW9uIHJlbW92ZUV4YWN0KGFycmF5LCBleGFjdFZhbCkge1xyXG4gICAgICAgIGxldCByZW1vdmVDbnQgPSAwO1xyXG4gICAgICAgIGxldCBpID0gMDtcclxuICAgICAgICB3aGlsZSAoaSA8IGFycmF5Lmxlbmd0aCkge1xyXG4gICAgICAgICAgICBpZiAoYXJyYXlbaV0gPT09IGV4YWN0VmFsKSB7XHJcbiAgICAgICAgICAgICAgICBhcnJheS5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgICAgICAgICByZW1vdmVDbnQgKz0gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGkgKz0gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVtb3ZlQ250O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gaXNBcnJheXNFcXVhbChhMCwgYTEsIGVxdWFsaXR5RnVuYykge1xyXG4gICAgICAgIGlmIChhMCA9PT0gYTEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBsZW4gPSBhMC5sZW5ndGg7XHJcbiAgICAgICAgbGV0IGk7XHJcbiAgICAgICAgaWYgKGxlbiAhPT0gYTEubGVuZ3RoKSB7IC8vIG5vdCBhcnJheT8gb3Igbm90IHNhbWUgbGVuZ3RoP1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgICAgICAgICBpZiAoIShlcXVhbGl0eUZ1bmMgPyBlcXVhbGl0eUZ1bmMoYTBbaV0sIGExW2ldKSA6IGEwW2ldID09PSBhMVtpXSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBEQVlfSURTID0gWydzdW4nLCAnbW9uJywgJ3R1ZScsICd3ZWQnLCAndGh1JywgJ2ZyaScsICdzYXQnXTtcclxuICAgIC8vIEFkZGluZ1xyXG4gICAgZnVuY3Rpb24gYWRkV2Vla3MobSwgbikge1xyXG4gICAgICAgIGxldCBhID0gZGF0ZVRvVXRjQXJyYXkobSk7XHJcbiAgICAgICAgYVsyXSArPSBuICogNztcclxuICAgICAgICByZXR1cm4gYXJyYXlUb1V0Y0RhdGUoYSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBhZGREYXlzKG0sIG4pIHtcclxuICAgICAgICBsZXQgYSA9IGRhdGVUb1V0Y0FycmF5KG0pO1xyXG4gICAgICAgIGFbMl0gKz0gbjtcclxuICAgICAgICByZXR1cm4gYXJyYXlUb1V0Y0RhdGUoYSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBhZGRNcyhtLCBuKSB7XHJcbiAgICAgICAgbGV0IGEgPSBkYXRlVG9VdGNBcnJheShtKTtcclxuICAgICAgICBhWzZdICs9IG47XHJcbiAgICAgICAgcmV0dXJuIGFycmF5VG9VdGNEYXRlKGEpO1xyXG4gICAgfVxyXG4gICAgLy8gRGlmZmluZyAoYWxsIHJldHVybiBmbG9hdHMpXHJcbiAgICAvLyBUT0RPOiB3aHkgbm90IHVzZSByYW5nZXM/XHJcbiAgICBmdW5jdGlvbiBkaWZmV2Vla3MobTAsIG0xKSB7XHJcbiAgICAgICAgcmV0dXJuIGRpZmZEYXlzKG0wLCBtMSkgLyA3O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZGlmZkRheXMobTAsIG0xKSB7XHJcbiAgICAgICAgcmV0dXJuIChtMS52YWx1ZU9mKCkgLSBtMC52YWx1ZU9mKCkpIC8gKDEwMDAgKiA2MCAqIDYwICogMjQpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZGlmZkhvdXJzKG0wLCBtMSkge1xyXG4gICAgICAgIHJldHVybiAobTEudmFsdWVPZigpIC0gbTAudmFsdWVPZigpKSAvICgxMDAwICogNjAgKiA2MCk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBkaWZmTWludXRlcyhtMCwgbTEpIHtcclxuICAgICAgICByZXR1cm4gKG0xLnZhbHVlT2YoKSAtIG0wLnZhbHVlT2YoKSkgLyAoMTAwMCAqIDYwKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGRpZmZTZWNvbmRzKG0wLCBtMSkge1xyXG4gICAgICAgIHJldHVybiAobTEudmFsdWVPZigpIC0gbTAudmFsdWVPZigpKSAvIDEwMDA7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBkaWZmRGF5QW5kVGltZShtMCwgbTEpIHtcclxuICAgICAgICBsZXQgbTBkYXkgPSBzdGFydE9mRGF5KG0wKTtcclxuICAgICAgICBsZXQgbTFkYXkgPSBzdGFydE9mRGF5KG0xKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB5ZWFyczogMCxcclxuICAgICAgICAgICAgbW9udGhzOiAwLFxyXG4gICAgICAgICAgICBkYXlzOiBNYXRoLnJvdW5kKGRpZmZEYXlzKG0wZGF5LCBtMWRheSkpLFxyXG4gICAgICAgICAgICBtaWxsaXNlY29uZHM6IChtMS52YWx1ZU9mKCkgLSBtMWRheS52YWx1ZU9mKCkpIC0gKG0wLnZhbHVlT2YoKSAtIG0wZGF5LnZhbHVlT2YoKSksXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIC8vIERpZmZpbmcgV2hvbGUgVW5pdHNcclxuICAgIGZ1bmN0aW9uIGRpZmZXaG9sZVdlZWtzKG0wLCBtMSkge1xyXG4gICAgICAgIGxldCBkID0gZGlmZldob2xlRGF5cyhtMCwgbTEpO1xyXG4gICAgICAgIGlmIChkICE9PSBudWxsICYmIGQgJSA3ID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkIC8gNztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBkaWZmV2hvbGVEYXlzKG0wLCBtMSkge1xyXG4gICAgICAgIGlmICh0aW1lQXNNcyhtMCkgPT09IHRpbWVBc01zKG0xKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5yb3VuZChkaWZmRGF5cyhtMCwgbTEpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICAvLyBTdGFydC1PZlxyXG4gICAgZnVuY3Rpb24gc3RhcnRPZkRheShtKSB7XHJcbiAgICAgICAgcmV0dXJuIGFycmF5VG9VdGNEYXRlKFtcclxuICAgICAgICAgICAgbS5nZXRVVENGdWxsWWVhcigpLFxyXG4gICAgICAgICAgICBtLmdldFVUQ01vbnRoKCksXHJcbiAgICAgICAgICAgIG0uZ2V0VVRDRGF0ZSgpLFxyXG4gICAgICAgIF0pO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gc3RhcnRPZkhvdXIobSkge1xyXG4gICAgICAgIHJldHVybiBhcnJheVRvVXRjRGF0ZShbXHJcbiAgICAgICAgICAgIG0uZ2V0VVRDRnVsbFllYXIoKSxcclxuICAgICAgICAgICAgbS5nZXRVVENNb250aCgpLFxyXG4gICAgICAgICAgICBtLmdldFVUQ0RhdGUoKSxcclxuICAgICAgICAgICAgbS5nZXRVVENIb3VycygpLFxyXG4gICAgICAgIF0pO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gc3RhcnRPZk1pbnV0ZShtKSB7XHJcbiAgICAgICAgcmV0dXJuIGFycmF5VG9VdGNEYXRlKFtcclxuICAgICAgICAgICAgbS5nZXRVVENGdWxsWWVhcigpLFxyXG4gICAgICAgICAgICBtLmdldFVUQ01vbnRoKCksXHJcbiAgICAgICAgICAgIG0uZ2V0VVRDRGF0ZSgpLFxyXG4gICAgICAgICAgICBtLmdldFVUQ0hvdXJzKCksXHJcbiAgICAgICAgICAgIG0uZ2V0VVRDTWludXRlcygpLFxyXG4gICAgICAgIF0pO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gc3RhcnRPZlNlY29uZChtKSB7XHJcbiAgICAgICAgcmV0dXJuIGFycmF5VG9VdGNEYXRlKFtcclxuICAgICAgICAgICAgbS5nZXRVVENGdWxsWWVhcigpLFxyXG4gICAgICAgICAgICBtLmdldFVUQ01vbnRoKCksXHJcbiAgICAgICAgICAgIG0uZ2V0VVRDRGF0ZSgpLFxyXG4gICAgICAgICAgICBtLmdldFVUQ0hvdXJzKCksXHJcbiAgICAgICAgICAgIG0uZ2V0VVRDTWludXRlcygpLFxyXG4gICAgICAgICAgICBtLmdldFVUQ1NlY29uZHMoKSxcclxuICAgICAgICBdKTtcclxuICAgIH1cclxuICAgIC8vIFdlZWsgQ29tcHV0YXRpb25cclxuICAgIGZ1bmN0aW9uIHdlZWtPZlllYXIobWFya2VyLCBkb3csIGRveSkge1xyXG4gICAgICAgIGxldCB5ID0gbWFya2VyLmdldFVUQ0Z1bGxZZWFyKCk7XHJcbiAgICAgICAgbGV0IHcgPSB3ZWVrT2ZHaXZlblllYXIobWFya2VyLCB5LCBkb3csIGRveSk7XHJcbiAgICAgICAgaWYgKHcgPCAxKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB3ZWVrT2ZHaXZlblllYXIobWFya2VyLCB5IC0gMSwgZG93LCBkb3kpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgbmV4dFcgPSB3ZWVrT2ZHaXZlblllYXIobWFya2VyLCB5ICsgMSwgZG93LCBkb3kpO1xyXG4gICAgICAgIGlmIChuZXh0VyA+PSAxKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBNYXRoLm1pbih3LCBuZXh0Vyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB3O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gd2Vla09mR2l2ZW5ZZWFyKG1hcmtlciwgeWVhciwgZG93LCBkb3kpIHtcclxuICAgICAgICBsZXQgZmlyc3RXZWVrU3RhcnQgPSBhcnJheVRvVXRjRGF0ZShbeWVhciwgMCwgMSArIGZpcnN0V2Vla09mZnNldCh5ZWFyLCBkb3csIGRveSldKTtcclxuICAgICAgICBsZXQgZGF5U3RhcnQgPSBzdGFydE9mRGF5KG1hcmtlcik7XHJcbiAgICAgICAgbGV0IGRheXMgPSBNYXRoLnJvdW5kKGRpZmZEYXlzKGZpcnN0V2Vla1N0YXJ0LCBkYXlTdGFydCkpO1xyXG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKGRheXMgLyA3KSArIDE7IC8vIHplcm8taW5kZXhlZFxyXG4gICAgfVxyXG4gICAgLy8gc3RhcnQtb2YtZmlyc3Qtd2VlayAtIHN0YXJ0LW9mLXllYXJcclxuICAgIGZ1bmN0aW9uIGZpcnN0V2Vla09mZnNldCh5ZWFyLCBkb3csIGRveSkge1xyXG4gICAgICAgIC8vIGZpcnN0LXdlZWsgZGF5IC0tIHdoaWNoIGphbnVhcnkgaXMgYWx3YXlzIGluIHRoZSBmaXJzdCB3ZWVrICg0IGZvciBpc28sIDEgZm9yIG90aGVyKVxyXG4gICAgICAgIGxldCBmd2QgPSA3ICsgZG93IC0gZG95O1xyXG4gICAgICAgIC8vIGZpcnN0LXdlZWsgZGF5IGxvY2FsIHdlZWtkYXkgLS0gd2hpY2ggbG9jYWwgd2Vla2RheSBpcyBmd2RcclxuICAgICAgICBsZXQgZndkbHcgPSAoNyArIGFycmF5VG9VdGNEYXRlKFt5ZWFyLCAwLCBmd2RdKS5nZXRVVENEYXkoKSAtIGRvdykgJSA3O1xyXG4gICAgICAgIHJldHVybiAtZndkbHcgKyBmd2QgLSAxO1xyXG4gICAgfVxyXG4gICAgLy8gQXJyYXkgQ29udmVyc2lvblxyXG4gICAgZnVuY3Rpb24gZGF0ZVRvTG9jYWxBcnJheShkYXRlKSB7XHJcbiAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgZGF0ZS5nZXRGdWxsWWVhcigpLFxyXG4gICAgICAgICAgICBkYXRlLmdldE1vbnRoKCksXHJcbiAgICAgICAgICAgIGRhdGUuZ2V0RGF0ZSgpLFxyXG4gICAgICAgICAgICBkYXRlLmdldEhvdXJzKCksXHJcbiAgICAgICAgICAgIGRhdGUuZ2V0TWludXRlcygpLFxyXG4gICAgICAgICAgICBkYXRlLmdldFNlY29uZHMoKSxcclxuICAgICAgICAgICAgZGF0ZS5nZXRNaWxsaXNlY29uZHMoKSxcclxuICAgICAgICBdO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYXJyYXlUb0xvY2FsRGF0ZShhKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKGFbMF0sIGFbMV0gfHwgMCwgYVsyXSA9PSBudWxsID8gMSA6IGFbMl0sIC8vIGRheSBvZiBtb250aFxyXG4gICAgICAgIGFbM10gfHwgMCwgYVs0XSB8fCAwLCBhWzVdIHx8IDApO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZGF0ZVRvVXRjQXJyYXkoZGF0ZSkge1xyXG4gICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgIGRhdGUuZ2V0VVRDRnVsbFllYXIoKSxcclxuICAgICAgICAgICAgZGF0ZS5nZXRVVENNb250aCgpLFxyXG4gICAgICAgICAgICBkYXRlLmdldFVUQ0RhdGUoKSxcclxuICAgICAgICAgICAgZGF0ZS5nZXRVVENIb3VycygpLFxyXG4gICAgICAgICAgICBkYXRlLmdldFVUQ01pbnV0ZXMoKSxcclxuICAgICAgICAgICAgZGF0ZS5nZXRVVENTZWNvbmRzKCksXHJcbiAgICAgICAgICAgIGRhdGUuZ2V0VVRDTWlsbGlzZWNvbmRzKCksXHJcbiAgICAgICAgXTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGFycmF5VG9VdGNEYXRlKGEpIHtcclxuICAgICAgICAvLyBhY2NvcmRpbmcgdG8gd2ViIHN0YW5kYXJkcyAoYW5kIFNhZmFyaSksIGEgbW9udGggaW5kZXggaXMgcmVxdWlyZWQuXHJcbiAgICAgICAgLy8gbWFzc2FnZSBpZiBvbmx5IGdpdmVuIGEgeWVhci5cclxuICAgICAgICBpZiAoYS5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICAgICAgYSA9IGEuY29uY2F0KFswXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShEYXRlLlVUQyguLi5hKSk7XHJcbiAgICB9XHJcbiAgICAvLyBPdGhlciBVdGlsc1xyXG4gICAgZnVuY3Rpb24gaXNWYWxpZERhdGUobSkge1xyXG4gICAgICAgIHJldHVybiAhaXNOYU4obS52YWx1ZU9mKCkpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gdGltZUFzTXMobSkge1xyXG4gICAgICAgIHJldHVybiBtLmdldFVUQ0hvdXJzKCkgKiAxMDAwICogNjAgKiA2MCArXHJcbiAgICAgICAgICAgIG0uZ2V0VVRDTWludXRlcygpICogMTAwMCAqIDYwICtcclxuICAgICAgICAgICAgbS5nZXRVVENTZWNvbmRzKCkgKiAxMDAwICtcclxuICAgICAgICAgICAgbS5nZXRVVENNaWxsaXNlY29uZHMoKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyB0aW1lWm9uZU9mZnNldCBpcyBpbiBtaW51dGVzXHJcbiAgICBmdW5jdGlvbiBidWlsZElzb1N0cmluZyhtYXJrZXIsIHRpbWVab25lT2Zmc2V0LCBzdHJpcFplcm9UaW1lID0gZmFsc2UpIHtcclxuICAgICAgICBsZXQgcyA9IG1hcmtlci50b0lTT1N0cmluZygpO1xyXG4gICAgICAgIHMgPSBzLnJlcGxhY2UoJy4wMDAnLCAnJyk7XHJcbiAgICAgICAgaWYgKHN0cmlwWmVyb1RpbWUpIHtcclxuICAgICAgICAgICAgcyA9IHMucmVwbGFjZSgnVDAwOjAwOjAwWicsICcnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHMubGVuZ3RoID4gMTApIHsgLy8gdGltZSBwYXJ0IHdhc24ndCBzdHJpcHBlZCwgY2FuIGFkZCB0aW1lem9uZSBpbmZvXHJcbiAgICAgICAgICAgIGlmICh0aW1lWm9uZU9mZnNldCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBzID0gcy5yZXBsYWNlKCdaJywgJycpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHRpbWVab25lT2Zmc2V0ICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBzID0gcy5yZXBsYWNlKCdaJywgZm9ybWF0VGltZVpvbmVPZmZzZXQodGltZVpvbmVPZmZzZXQsIHRydWUpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBvdGhlcndpc2UsIGl0cyBVVEMtMCBhbmQgd2Ugd2FudCB0byBrZWVwIHRoZSBaXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzO1xyXG4gICAgfVxyXG4gICAgLy8gZm9ybWF0cyB0aGUgZGF0ZSwgYnV0IHdpdGggbm8gdGltZSBwYXJ0XHJcbiAgICAvLyBUT0RPOiBzb21laG93IG1lcmdlIHdpdGggYnVpbGRJc29TdHJpbmcgYW5kIHN0cmlwWmVyb1RpbWVcclxuICAgIC8vIFRPRE86IHJlbmFtZS4gb21pdCBcInN0cmluZ1wiXHJcbiAgICBmdW5jdGlvbiBmb3JtYXREYXlTdHJpbmcobWFya2VyKSB7XHJcbiAgICAgICAgcmV0dXJuIG1hcmtlci50b0lTT1N0cmluZygpLnJlcGxhY2UoL1QuKiQvLCAnJyk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBmb3JtYXRJc29Nb250aFN0cihtYXJrZXIpIHtcclxuICAgICAgICByZXR1cm4gbWFya2VyLnRvSVNPU3RyaW5nKCkubWF0Y2goL15cXGR7NH0tXFxkezJ9LylbMF07XHJcbiAgICB9XHJcbiAgICAvLyBUT0RPOiB1c2UgRGF0ZTo6dG9JU09TdHJpbmcgYW5kIHVzZSBldmVyeXRoaW5nIGFmdGVyIHRoZSBUP1xyXG4gICAgZnVuY3Rpb24gZm9ybWF0SXNvVGltZVN0cmluZyhtYXJrZXIpIHtcclxuICAgICAgICByZXR1cm4gcGFkU3RhcnQobWFya2VyLmdldFVUQ0hvdXJzKCksIDIpICsgJzonICtcclxuICAgICAgICAgICAgcGFkU3RhcnQobWFya2VyLmdldFVUQ01pbnV0ZXMoKSwgMikgKyAnOicgK1xyXG4gICAgICAgICAgICBwYWRTdGFydChtYXJrZXIuZ2V0VVRDU2Vjb25kcygpLCAyKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGZvcm1hdFRpbWVab25lT2Zmc2V0KG1pbnV0ZXMsIGRvSXNvID0gZmFsc2UpIHtcclxuICAgICAgICBsZXQgc2lnbiA9IG1pbnV0ZXMgPCAwID8gJy0nIDogJysnO1xyXG4gICAgICAgIGxldCBhYnMgPSBNYXRoLmFicyhtaW51dGVzKTtcclxuICAgICAgICBsZXQgaG91cnMgPSBNYXRoLmZsb29yKGFicyAvIDYwKTtcclxuICAgICAgICBsZXQgbWlucyA9IE1hdGgucm91bmQoYWJzICUgNjApO1xyXG4gICAgICAgIGlmIChkb0lzbykge1xyXG4gICAgICAgICAgICByZXR1cm4gYCR7c2lnbiArIHBhZFN0YXJ0KGhvdXJzLCAyKX06JHtwYWRTdGFydChtaW5zLCAyKX1gO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYEdNVCR7c2lnbn0ke2hvdXJzfSR7bWlucyA/IGA6JHtwYWRTdGFydChtaW5zLCAyKX1gIDogJyd9YDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBtZW1vaXplKHdvcmtlckZ1bmMsIHJlc0VxdWFsaXR5LCB0ZWFyZG93bkZ1bmMpIHtcclxuICAgICAgICBsZXQgY3VycmVudEFyZ3M7XHJcbiAgICAgICAgbGV0IGN1cnJlbnRSZXM7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICguLi5uZXdBcmdzKSB7XHJcbiAgICAgICAgICAgIGlmICghY3VycmVudEFyZ3MpIHtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRSZXMgPSB3b3JrZXJGdW5jLmFwcGx5KHRoaXMsIG5ld0FyZ3MpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCFpc0FycmF5c0VxdWFsKGN1cnJlbnRBcmdzLCBuZXdBcmdzKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRlYXJkb3duRnVuYykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRlYXJkb3duRnVuYyhjdXJyZW50UmVzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGxldCByZXMgPSB3b3JrZXJGdW5jLmFwcGx5KHRoaXMsIG5ld0FyZ3MpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFyZXNFcXVhbGl0eSB8fCAhcmVzRXF1YWxpdHkocmVzLCBjdXJyZW50UmVzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRSZXMgPSByZXM7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY3VycmVudEFyZ3MgPSBuZXdBcmdzO1xyXG4gICAgICAgICAgICByZXR1cm4gY3VycmVudFJlcztcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gbWVtb2l6ZU9iakFyZyh3b3JrZXJGdW5jLCByZXNFcXVhbGl0eSwgdGVhcmRvd25GdW5jKSB7XHJcbiAgICAgICAgbGV0IGN1cnJlbnRBcmc7XHJcbiAgICAgICAgbGV0IGN1cnJlbnRSZXM7XHJcbiAgICAgICAgcmV0dXJuIChuZXdBcmcpID0+IHtcclxuICAgICAgICAgICAgaWYgKCFjdXJyZW50QXJnKSB7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50UmVzID0gd29ya2VyRnVuYy5jYWxsKHRoaXMsIG5ld0FyZyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoIWlzUHJvcHNFcXVhbChjdXJyZW50QXJnLCBuZXdBcmcpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGVhcmRvd25GdW5jKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGVhcmRvd25GdW5jKGN1cnJlbnRSZXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbGV0IHJlcyA9IHdvcmtlckZ1bmMuY2FsbCh0aGlzLCBuZXdBcmcpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFyZXNFcXVhbGl0eSB8fCAhcmVzRXF1YWxpdHkocmVzLCBjdXJyZW50UmVzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRSZXMgPSByZXM7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY3VycmVudEFyZyA9IG5ld0FyZztcclxuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRSZXM7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIG1lbW9pemVBcnJheWxpa2UoLy8gdXNlZCBhdCBhbGw/XHJcbiAgICB3b3JrZXJGdW5jLCByZXNFcXVhbGl0eSwgdGVhcmRvd25GdW5jKSB7XHJcbiAgICAgICAgbGV0IGN1cnJlbnRBcmdTZXRzID0gW107XHJcbiAgICAgICAgbGV0IGN1cnJlbnRSZXN1bHRzID0gW107XHJcbiAgICAgICAgcmV0dXJuIChuZXdBcmdTZXRzKSA9PiB7XHJcbiAgICAgICAgICAgIGxldCBjdXJyZW50TGVuID0gY3VycmVudEFyZ1NldHMubGVuZ3RoO1xyXG4gICAgICAgICAgICBsZXQgbmV3TGVuID0gbmV3QXJnU2V0cy5sZW5ndGg7XHJcbiAgICAgICAgICAgIGxldCBpID0gMDtcclxuICAgICAgICAgICAgZm9yICg7IGkgPCBjdXJyZW50TGVuOyBpICs9IDEpIHtcclxuICAgICAgICAgICAgICAgIGlmICghbmV3QXJnU2V0c1tpXSkgeyAvLyBvbmUgb2YgdGhlIG9sZCBzZXRzIG5vIGxvbmdlciBleGlzdHNcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGVhcmRvd25GdW5jKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlYXJkb3duRnVuYyhjdXJyZW50UmVzdWx0c1tpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIWlzQXJyYXlzRXF1YWwoY3VycmVudEFyZ1NldHNbaV0sIG5ld0FyZ1NldHNbaV0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRlYXJkb3duRnVuYykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZWFyZG93bkZ1bmMoY3VycmVudFJlc3VsdHNbaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBsZXQgcmVzID0gd29ya2VyRnVuYy5hcHBseSh0aGlzLCBuZXdBcmdTZXRzW2ldKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXJlc0VxdWFsaXR5IHx8ICFyZXNFcXVhbGl0eShyZXMsIGN1cnJlbnRSZXN1bHRzW2ldKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UmVzdWx0c1tpXSA9IHJlcztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yICg7IGkgPCBuZXdMZW47IGkgKz0gMSkge1xyXG4gICAgICAgICAgICAgICAgY3VycmVudFJlc3VsdHNbaV0gPSB3b3JrZXJGdW5jLmFwcGx5KHRoaXMsIG5ld0FyZ1NldHNbaV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGN1cnJlbnRBcmdTZXRzID0gbmV3QXJnU2V0cztcclxuICAgICAgICAgICAgY3VycmVudFJlc3VsdHMuc3BsaWNlKG5ld0xlbik7IC8vIHJlbW92ZSBleGNlc3NcclxuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRSZXN1bHRzO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBtZW1vaXplSGFzaGxpa2Uod29ya2VyRnVuYywgcmVzRXF1YWxpdHksIHRlYXJkb3duRnVuYykge1xyXG4gICAgICAgIGxldCBjdXJyZW50QXJnSGFzaCA9IHt9O1xyXG4gICAgICAgIGxldCBjdXJyZW50UmVzSGFzaCA9IHt9O1xyXG4gICAgICAgIHJldHVybiAobmV3QXJnSGFzaCkgPT4ge1xyXG4gICAgICAgICAgICBsZXQgbmV3UmVzSGFzaCA9IHt9O1xyXG4gICAgICAgICAgICBmb3IgKGxldCBrZXkgaW4gbmV3QXJnSGFzaCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFjdXJyZW50UmVzSGFzaFtrZXldKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3UmVzSGFzaFtrZXldID0gd29ya2VyRnVuYy5hcHBseSh0aGlzLCBuZXdBcmdIYXNoW2tleV0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIWlzQXJyYXlzRXF1YWwoY3VycmVudEFyZ0hhc2hba2V5XSwgbmV3QXJnSGFzaFtrZXldKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ZWFyZG93bkZ1bmMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGVhcmRvd25GdW5jKGN1cnJlbnRSZXNIYXNoW2tleV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBsZXQgcmVzID0gd29ya2VyRnVuYy5hcHBseSh0aGlzLCBuZXdBcmdIYXNoW2tleV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld1Jlc0hhc2hba2V5XSA9IChyZXNFcXVhbGl0eSAmJiByZXNFcXVhbGl0eShyZXMsIGN1cnJlbnRSZXNIYXNoW2tleV0pKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGN1cnJlbnRSZXNIYXNoW2tleV1cclxuICAgICAgICAgICAgICAgICAgICAgICAgOiByZXM7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXdSZXNIYXNoW2tleV0gPSBjdXJyZW50UmVzSGFzaFtrZXldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGN1cnJlbnRBcmdIYXNoID0gbmV3QXJnSGFzaDtcclxuICAgICAgICAgICAgY3VycmVudFJlc0hhc2ggPSBuZXdSZXNIYXNoO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3UmVzSGFzaDtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IEVYVEVOREVEX1NFVFRJTkdTX0FORF9TRVZFUklUSUVTID0ge1xyXG4gICAgICAgIHdlZWs6IDMsXHJcbiAgICAgICAgc2VwYXJhdG9yOiAwLFxyXG4gICAgICAgIG9taXRaZXJvTWludXRlOiAwLFxyXG4gICAgICAgIG1lcmlkaWVtOiAwLFxyXG4gICAgICAgIG9taXRDb21tYXM6IDAsXHJcbiAgICB9O1xyXG4gICAgY29uc3QgU1RBTkRBUkRfREFURV9QUk9QX1NFVkVSSVRJRVMgPSB7XHJcbiAgICAgICAgdGltZVpvbmVOYW1lOiA3LFxyXG4gICAgICAgIGVyYTogNixcclxuICAgICAgICB5ZWFyOiA1LFxyXG4gICAgICAgIG1vbnRoOiA0LFxyXG4gICAgICAgIGRheTogMixcclxuICAgICAgICB3ZWVrZGF5OiAyLFxyXG4gICAgICAgIGhvdXI6IDEsXHJcbiAgICAgICAgbWludXRlOiAxLFxyXG4gICAgICAgIHNlY29uZDogMSxcclxuICAgIH07XHJcbiAgICBjb25zdCBNRVJJRElFTV9SRSA9IC9cXHMqKFthcF0pXFwuP21cXC4/L2k7IC8vIGVhdHMgdXAgbGVhZGluZyBzcGFjZXMgdG9vXHJcbiAgICBjb25zdCBDT01NQV9SRSA9IC8sL2c7IC8vIHdlIG5lZWQgcmUgZm9yIGdsb2JhbG5lc3NcclxuICAgIGNvbnN0IE1VTFRJX1NQQUNFX1JFID0gL1xccysvZztcclxuICAgIGNvbnN0IExUUl9SRSA9IC9cXHUyMDBlL2c7IC8vIGNvbnRyb2wgY2hhcmFjdGVyXHJcbiAgICBjb25zdCBVVENfUkUgPSAvVVRDfEdNVC87XHJcbiAgICBjbGFzcyBOYXRpdmVGb3JtYXR0ZXIge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yKGZvcm1hdFNldHRpbmdzKSB7XHJcbiAgICAgICAgICAgIGxldCBzdGFuZGFyZERhdGVQcm9wcyA9IHt9O1xyXG4gICAgICAgICAgICBsZXQgZXh0ZW5kZWRTZXR0aW5ncyA9IHt9O1xyXG4gICAgICAgICAgICBsZXQgc2V2ZXJpdHkgPSAwO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBuYW1lIGluIGZvcm1hdFNldHRpbmdzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobmFtZSBpbiBFWFRFTkRFRF9TRVRUSU5HU19BTkRfU0VWRVJJVElFUykge1xyXG4gICAgICAgICAgICAgICAgICAgIGV4dGVuZGVkU2V0dGluZ3NbbmFtZV0gPSBmb3JtYXRTZXR0aW5nc1tuYW1lXTtcclxuICAgICAgICAgICAgICAgICAgICBzZXZlcml0eSA9IE1hdGgubWF4KEVYVEVOREVEX1NFVFRJTkdTX0FORF9TRVZFUklUSUVTW25hbWVdLCBzZXZlcml0eSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBzdGFuZGFyZERhdGVQcm9wc1tuYW1lXSA9IGZvcm1hdFNldHRpbmdzW25hbWVdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChuYW1lIGluIFNUQU5EQVJEX0RBVEVfUFJPUF9TRVZFUklUSUVTKSB7IC8vIFRPRE86IHdoYXQgYWJvdXQgaG91cjEyPyBubyBzZXZlcml0eVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXZlcml0eSA9IE1hdGgubWF4KFNUQU5EQVJEX0RBVEVfUFJPUF9TRVZFUklUSUVTW25hbWVdLCBzZXZlcml0eSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuc3RhbmRhcmREYXRlUHJvcHMgPSBzdGFuZGFyZERhdGVQcm9wcztcclxuICAgICAgICAgICAgdGhpcy5leHRlbmRlZFNldHRpbmdzID0gZXh0ZW5kZWRTZXR0aW5ncztcclxuICAgICAgICAgICAgdGhpcy5zZXZlcml0eSA9IHNldmVyaXR5O1xyXG4gICAgICAgICAgICB0aGlzLmJ1aWxkRm9ybWF0dGluZ0Z1bmMgPSBtZW1vaXplKGJ1aWxkRm9ybWF0dGluZ0Z1bmMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3JtYXQoZGF0ZSwgY29udGV4dCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5idWlsZEZvcm1hdHRpbmdGdW5jKHRoaXMuc3RhbmRhcmREYXRlUHJvcHMsIHRoaXMuZXh0ZW5kZWRTZXR0aW5ncywgY29udGV4dCkoZGF0ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvcm1hdFJhbmdlKHN0YXJ0LCBlbmQsIGNvbnRleHQsIGJldHRlckRlZmF1bHRTZXBhcmF0b3IpIHtcclxuICAgICAgICAgICAgbGV0IHsgc3RhbmRhcmREYXRlUHJvcHMsIGV4dGVuZGVkU2V0dGluZ3MgfSA9IHRoaXM7XHJcbiAgICAgICAgICAgIGxldCBkaWZmU2V2ZXJpdHkgPSBjb21wdXRlTWFya2VyRGlmZlNldmVyaXR5KHN0YXJ0Lm1hcmtlciwgZW5kLm1hcmtlciwgY29udGV4dC5jYWxlbmRhclN5c3RlbSk7XHJcbiAgICAgICAgICAgIGlmICghZGlmZlNldmVyaXR5KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXQoc3RhcnQsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxldCBiaWdnZXN0VW5pdEZvclBhcnRpYWwgPSBkaWZmU2V2ZXJpdHk7XHJcbiAgICAgICAgICAgIGlmIChiaWdnZXN0VW5pdEZvclBhcnRpYWwgPiAxICYmIC8vIHRoZSB0d28gZGF0ZXMgYXJlIGRpZmZlcmVudCBpbiBhIHdheSB0aGF0J3MgbGFyZ2VyIHNjYWxlIHRoYW4gdGltZVxyXG4gICAgICAgICAgICAgICAgKHN0YW5kYXJkRGF0ZVByb3BzLnllYXIgPT09ICdudW1lcmljJyB8fCBzdGFuZGFyZERhdGVQcm9wcy55ZWFyID09PSAnMi1kaWdpdCcpICYmXHJcbiAgICAgICAgICAgICAgICAoc3RhbmRhcmREYXRlUHJvcHMubW9udGggPT09ICdudW1lcmljJyB8fCBzdGFuZGFyZERhdGVQcm9wcy5tb250aCA9PT0gJzItZGlnaXQnKSAmJlxyXG4gICAgICAgICAgICAgICAgKHN0YW5kYXJkRGF0ZVByb3BzLmRheSA9PT0gJ251bWVyaWMnIHx8IHN0YW5kYXJkRGF0ZVByb3BzLmRheSA9PT0gJzItZGlnaXQnKSkge1xyXG4gICAgICAgICAgICAgICAgYmlnZ2VzdFVuaXRGb3JQYXJ0aWFsID0gMTsgLy8gbWFrZSBpdCBsb29rIGxpa2UgdGhlIGRhdGVzIGFyZSBvbmx5IGRpZmZlcmVudCBpbiB0ZXJtcyBvZiB0aW1lXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IGZ1bGwwID0gdGhpcy5mb3JtYXQoc3RhcnQsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICBsZXQgZnVsbDEgPSB0aGlzLmZvcm1hdChlbmQsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICBpZiAoZnVsbDAgPT09IGZ1bGwxKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVsbDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IHBhcnRpYWxEYXRlUHJvcHMgPSBjb21wdXRlUGFydGlhbEZvcm1hdHRpbmdPcHRpb25zKHN0YW5kYXJkRGF0ZVByb3BzLCBiaWdnZXN0VW5pdEZvclBhcnRpYWwpO1xyXG4gICAgICAgICAgICBsZXQgcGFydGlhbEZvcm1hdHRpbmdGdW5jID0gYnVpbGRGb3JtYXR0aW5nRnVuYyhwYXJ0aWFsRGF0ZVByb3BzLCBleHRlbmRlZFNldHRpbmdzLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgbGV0IHBhcnRpYWwwID0gcGFydGlhbEZvcm1hdHRpbmdGdW5jKHN0YXJ0KTtcclxuICAgICAgICAgICAgbGV0IHBhcnRpYWwxID0gcGFydGlhbEZvcm1hdHRpbmdGdW5jKGVuZCk7XHJcbiAgICAgICAgICAgIGxldCBpbnNlcnRpb24gPSBmaW5kQ29tbW9uSW5zZXJ0aW9uKGZ1bGwwLCBwYXJ0aWFsMCwgZnVsbDEsIHBhcnRpYWwxKTtcclxuICAgICAgICAgICAgbGV0IHNlcGFyYXRvciA9IGV4dGVuZGVkU2V0dGluZ3Muc2VwYXJhdG9yIHx8IGJldHRlckRlZmF1bHRTZXBhcmF0b3IgfHwgY29udGV4dC5kZWZhdWx0U2VwYXJhdG9yIHx8ICcnO1xyXG4gICAgICAgICAgICBpZiAoaW5zZXJ0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5zZXJ0aW9uLmJlZm9yZSArIHBhcnRpYWwwICsgc2VwYXJhdG9yICsgcGFydGlhbDEgKyBpbnNlcnRpb24uYWZ0ZXI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGZ1bGwwICsgc2VwYXJhdG9yICsgZnVsbDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGdldExhcmdlc3RVbml0KCkge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMuc2V2ZXJpdHkpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgNzpcclxuICAgICAgICAgICAgICAgIGNhc2UgNjpcclxuICAgICAgICAgICAgICAgIGNhc2UgNTpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ3llYXInO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA0OlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnbW9udGgnO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnd2Vlayc7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdkYXknO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ3RpbWUnOyAvLyByZWFsbHk/XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBidWlsZEZvcm1hdHRpbmdGdW5jKHN0YW5kYXJkRGF0ZVByb3BzLCBleHRlbmRlZFNldHRpbmdzLCBjb250ZXh0KSB7XHJcbiAgICAgICAgbGV0IHN0YW5kYXJkRGF0ZVByb3BDbnQgPSBPYmplY3Qua2V5cyhzdGFuZGFyZERhdGVQcm9wcykubGVuZ3RoO1xyXG4gICAgICAgIGlmIChzdGFuZGFyZERhdGVQcm9wQ250ID09PSAxICYmIHN0YW5kYXJkRGF0ZVByb3BzLnRpbWVab25lTmFtZSA9PT0gJ3Nob3J0Jykge1xyXG4gICAgICAgICAgICByZXR1cm4gKGRhdGUpID0+IChmb3JtYXRUaW1lWm9uZU9mZnNldChkYXRlLnRpbWVab25lT2Zmc2V0KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzdGFuZGFyZERhdGVQcm9wQ250ID09PSAwICYmIGV4dGVuZGVkU2V0dGluZ3Mud2Vlaykge1xyXG4gICAgICAgICAgICByZXR1cm4gKGRhdGUpID0+IChmb3JtYXRXZWVrTnVtYmVyKGNvbnRleHQuY29tcHV0ZVdlZWtOdW1iZXIoZGF0ZS5tYXJrZXIpLCBjb250ZXh0LndlZWtUZXh0LCBjb250ZXh0LndlZWtUZXh0TG9uZywgY29udGV4dC5sb2NhbGUsIGV4dGVuZGVkU2V0dGluZ3Mud2VlaykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYnVpbGROYXRpdmVGb3JtYXR0aW5nRnVuYyhzdGFuZGFyZERhdGVQcm9wcywgZXh0ZW5kZWRTZXR0aW5ncywgY29udGV4dCk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBidWlsZE5hdGl2ZUZvcm1hdHRpbmdGdW5jKHN0YW5kYXJkRGF0ZVByb3BzLCBleHRlbmRlZFNldHRpbmdzLCBjb250ZXh0KSB7XHJcbiAgICAgICAgc3RhbmRhcmREYXRlUHJvcHMgPSBPYmplY3QuYXNzaWduKHt9LCBzdGFuZGFyZERhdGVQcm9wcyk7IC8vIGNvcHlcclxuICAgICAgICBleHRlbmRlZFNldHRpbmdzID0gT2JqZWN0LmFzc2lnbih7fSwgZXh0ZW5kZWRTZXR0aW5ncyk7IC8vIGNvcHlcclxuICAgICAgICBzYW5pdGl6ZVNldHRpbmdzKHN0YW5kYXJkRGF0ZVByb3BzLCBleHRlbmRlZFNldHRpbmdzKTtcclxuICAgICAgICBzdGFuZGFyZERhdGVQcm9wcy50aW1lWm9uZSA9ICdVVEMnOyAvLyB3ZSBsZXZlcmFnZSB0aGUgb25seSBndWFyYW50ZWVkIHRpbWVab25lIGZvciBvdXIgVVRDIG1hcmtlcnNcclxuICAgICAgICBsZXQgbm9ybWFsRm9ybWF0ID0gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQoY29udGV4dC5sb2NhbGUuY29kZXMsIHN0YW5kYXJkRGF0ZVByb3BzKTtcclxuICAgICAgICBsZXQgemVyb0Zvcm1hdDsgLy8gbmVlZGVkP1xyXG4gICAgICAgIGlmIChleHRlbmRlZFNldHRpbmdzLm9taXRaZXJvTWludXRlKSB7XHJcbiAgICAgICAgICAgIGxldCB6ZXJvUHJvcHMgPSBPYmplY3QuYXNzaWduKHt9LCBzdGFuZGFyZERhdGVQcm9wcyk7XHJcbiAgICAgICAgICAgIGRlbGV0ZSB6ZXJvUHJvcHMubWludXRlOyAvLyBzZWNvbmRzIGFuZCBtcyB3ZXJlIGFscmVhZHkgY29uc2lkZXJlZCBpbiBzYW5pdGl6ZVNldHRpbmdzXHJcbiAgICAgICAgICAgIHplcm9Gb3JtYXQgPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChjb250ZXh0LmxvY2FsZS5jb2RlcywgemVyb1Byb3BzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIChkYXRlKSA9PiB7XHJcbiAgICAgICAgICAgIGxldCB7IG1hcmtlciB9ID0gZGF0ZTtcclxuICAgICAgICAgICAgbGV0IGZvcm1hdDtcclxuICAgICAgICAgICAgaWYgKHplcm9Gb3JtYXQgJiYgIW1hcmtlci5nZXRVVENNaW51dGVzKCkpIHtcclxuICAgICAgICAgICAgICAgIGZvcm1hdCA9IHplcm9Gb3JtYXQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBmb3JtYXQgPSBub3JtYWxGb3JtYXQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IHMgPSBmb3JtYXQuZm9ybWF0KG1hcmtlcik7XHJcbiAgICAgICAgICAgIHJldHVybiBwb3N0UHJvY2VzcyhzLCBkYXRlLCBzdGFuZGFyZERhdGVQcm9wcywgZXh0ZW5kZWRTZXR0aW5ncywgY29udGV4dCk7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHNhbml0aXplU2V0dGluZ3Moc3RhbmRhcmREYXRlUHJvcHMsIGV4dGVuZGVkU2V0dGluZ3MpIHtcclxuICAgICAgICAvLyBkZWFsIHdpdGggYSBicm93c2VyIGluY29uc2lzdGVuY3kgd2hlcmUgZm9ybWF0dGluZyB0aGUgdGltZXpvbmVcclxuICAgICAgICAvLyByZXF1aXJlcyB0aGF0IHRoZSBob3VyL21pbnV0ZSBiZSBwcmVzZW50LlxyXG4gICAgICAgIGlmIChzdGFuZGFyZERhdGVQcm9wcy50aW1lWm9uZU5hbWUpIHtcclxuICAgICAgICAgICAgaWYgKCFzdGFuZGFyZERhdGVQcm9wcy5ob3VyKSB7XHJcbiAgICAgICAgICAgICAgICBzdGFuZGFyZERhdGVQcm9wcy5ob3VyID0gJzItZGlnaXQnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghc3RhbmRhcmREYXRlUHJvcHMubWludXRlKSB7XHJcbiAgICAgICAgICAgICAgICBzdGFuZGFyZERhdGVQcm9wcy5taW51dGUgPSAnMi1kaWdpdCc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gb25seSBzdXBwb3J0IHNob3J0IHRpbWV6b25lIG5hbWVzXHJcbiAgICAgICAgaWYgKHN0YW5kYXJkRGF0ZVByb3BzLnRpbWVab25lTmFtZSA9PT0gJ2xvbmcnKSB7XHJcbiAgICAgICAgICAgIHN0YW5kYXJkRGF0ZVByb3BzLnRpbWVab25lTmFtZSA9ICdzaG9ydCc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGlmIHJlcXVlc3RpbmcgdG8gZGlzcGxheSBzZWNvbmRzLCBNVVNUIGRpc3BsYXkgbWludXRlc1xyXG4gICAgICAgIGlmIChleHRlbmRlZFNldHRpbmdzLm9taXRaZXJvTWludXRlICYmIChzdGFuZGFyZERhdGVQcm9wcy5zZWNvbmQgfHwgc3RhbmRhcmREYXRlUHJvcHMubWlsbGlzZWNvbmQpKSB7XHJcbiAgICAgICAgICAgIGRlbGV0ZSBleHRlbmRlZFNldHRpbmdzLm9taXRaZXJvTWludXRlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHBvc3RQcm9jZXNzKHMsIGRhdGUsIHN0YW5kYXJkRGF0ZVByb3BzLCBleHRlbmRlZFNldHRpbmdzLCBjb250ZXh0KSB7XHJcbiAgICAgICAgcyA9IHMucmVwbGFjZShMVFJfUkUsICcnKTsgLy8gcmVtb3ZlIGxlZnQtdG8tcmlnaHQgY29udHJvbCBjaGFycy4gZG8gZmlyc3QuIGdvb2QgZm9yIG90aGVyIHJlZ2V4ZXNcclxuICAgICAgICBpZiAoc3RhbmRhcmREYXRlUHJvcHMudGltZVpvbmVOYW1lID09PSAnc2hvcnQnKSB7XHJcbiAgICAgICAgICAgIHMgPSBpbmplY3RUem9TdHIocywgKGNvbnRleHQudGltZVpvbmUgPT09ICdVVEMnIHx8IGRhdGUudGltZVpvbmVPZmZzZXQgPT0gbnVsbCkgP1xyXG4gICAgICAgICAgICAgICAgJ1VUQycgOiAvLyBpbXBvcnRhbnQgdG8gbm9ybWFsaXplIGZvciBJRSwgd2hpY2ggZG9lcyBcIkdNVFwiXHJcbiAgICAgICAgICAgICAgICBmb3JtYXRUaW1lWm9uZU9mZnNldChkYXRlLnRpbWVab25lT2Zmc2V0KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChleHRlbmRlZFNldHRpbmdzLm9taXRDb21tYXMpIHtcclxuICAgICAgICAgICAgcyA9IHMucmVwbGFjZShDT01NQV9SRSwgJycpLnRyaW0oKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGV4dGVuZGVkU2V0dGluZ3Mub21pdFplcm9NaW51dGUpIHtcclxuICAgICAgICAgICAgcyA9IHMucmVwbGFjZSgnOjAwJywgJycpOyAvLyB6ZXJvRm9ybWF0IGRvZXNuJ3QgYWx3YXlzIGFjaGlldmUgdGhpc1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBeIGRvIGFueXRoaW5nIHRoYXQgbWlnaHQgY3JlYXRlIGFkamFjZW50IHNwYWNlcyBiZWZvcmUgdGhpcyBwb2ludCxcclxuICAgICAgICAvLyBiZWNhdXNlIE1FUklESUVNX1JFIGxpa2VzIHRvIGVhdCB1cCBsb2FkaW5nIHNwYWNlc1xyXG4gICAgICAgIGlmIChleHRlbmRlZFNldHRpbmdzLm1lcmlkaWVtID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICBzID0gcy5yZXBsYWNlKE1FUklESUVNX1JFLCAnJykudHJpbSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChleHRlbmRlZFNldHRpbmdzLm1lcmlkaWVtID09PSAnbmFycm93JykgeyAvLyBhL3BcclxuICAgICAgICAgICAgcyA9IHMucmVwbGFjZShNRVJJRElFTV9SRSwgKG0wLCBtMSkgPT4gbTEudG9Mb2NhbGVMb3dlckNhc2UoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGV4dGVuZGVkU2V0dGluZ3MubWVyaWRpZW0gPT09ICdzaG9ydCcpIHsgLy8gYW0vcG1cclxuICAgICAgICAgICAgcyA9IHMucmVwbGFjZShNRVJJRElFTV9SRSwgKG0wLCBtMSkgPT4gYCR7bTEudG9Mb2NhbGVMb3dlckNhc2UoKX1tYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGV4dGVuZGVkU2V0dGluZ3MubWVyaWRpZW0gPT09ICdsb3dlcmNhc2UnKSB7IC8vIG90aGVyIG1lcmlkaWVtIHRyYW5zZm9ybWVycyBhbHJlYWR5IGNvbnZlcnRlZCB0byBsb3dlcmNhc2VcclxuICAgICAgICAgICAgcyA9IHMucmVwbGFjZShNRVJJRElFTV9SRSwgKG0wKSA9PiBtMC50b0xvY2FsZUxvd2VyQ2FzZSgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcyA9IHMucmVwbGFjZShNVUxUSV9TUEFDRV9SRSwgJyAnKTtcclxuICAgICAgICBzID0gcy50cmltKCk7XHJcbiAgICAgICAgcmV0dXJuIHM7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBpbmplY3RUem9TdHIocywgdHpvU3RyKSB7XHJcbiAgICAgICAgbGV0IHJlcGxhY2VkID0gZmFsc2U7XHJcbiAgICAgICAgcyA9IHMucmVwbGFjZShVVENfUkUsICgpID0+IHtcclxuICAgICAgICAgICAgcmVwbGFjZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICByZXR1cm4gdHpvU3RyO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIElFMTEgZG9lc24ndCBpbmNsdWRlIFVUQy9HTVQgaW4gdGhlIG9yaWdpbmFsIHN0cmluZywgc28gYXBwZW5kIHRvIGVuZFxyXG4gICAgICAgIGlmICghcmVwbGFjZWQpIHtcclxuICAgICAgICAgICAgcyArPSBgICR7dHpvU3RyfWA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZm9ybWF0V2Vla051bWJlcihudW0sIHdlZWtUZXh0LCB3ZWVrVGV4dExvbmcsIGxvY2FsZSwgZGlzcGxheSkge1xyXG4gICAgICAgIGxldCBwYXJ0cyA9IFtdO1xyXG4gICAgICAgIGlmIChkaXNwbGF5ID09PSAnbG9uZycpIHtcclxuICAgICAgICAgICAgcGFydHMucHVzaCh3ZWVrVGV4dExvbmcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChkaXNwbGF5ID09PSAnc2hvcnQnIHx8IGRpc3BsYXkgPT09ICduYXJyb3cnKSB7XHJcbiAgICAgICAgICAgIHBhcnRzLnB1c2god2Vla1RleHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZGlzcGxheSA9PT0gJ2xvbmcnIHx8IGRpc3BsYXkgPT09ICdzaG9ydCcpIHtcclxuICAgICAgICAgICAgcGFydHMucHVzaCgnICcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwYXJ0cy5wdXNoKGxvY2FsZS5zaW1wbGVOdW1iZXJGb3JtYXQuZm9ybWF0KG51bSkpO1xyXG4gICAgICAgIGlmIChsb2NhbGUub3B0aW9ucy5kaXJlY3Rpb24gPT09ICdydGwnKSB7IC8vIFRPRE86IHVzZSBjb250cm9sIGNoYXJhY3RlcnMgaW5zdGVhZD9cclxuICAgICAgICAgICAgcGFydHMucmV2ZXJzZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcGFydHMuam9pbignJyk7XHJcbiAgICB9XHJcbiAgICAvLyBSYW5nZSBGb3JtYXR0aW5nIFV0aWxzXHJcbiAgICAvLyAwID0gZXhhY3RseSB0aGUgc2FtZVxyXG4gICAgLy8gMSA9IGRpZmZlcmVudCBieSB0aW1lXHJcbiAgICAvLyBhbmQgYmlnZ2VyXHJcbiAgICBmdW5jdGlvbiBjb21wdXRlTWFya2VyRGlmZlNldmVyaXR5KGQwLCBkMSwgY2EpIHtcclxuICAgICAgICBpZiAoY2EuZ2V0TWFya2VyWWVhcihkMCkgIT09IGNhLmdldE1hcmtlclllYXIoZDEpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiA1O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY2EuZ2V0TWFya2VyTW9udGgoZDApICE9PSBjYS5nZXRNYXJrZXJNb250aChkMSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIDQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjYS5nZXRNYXJrZXJEYXkoZDApICE9PSBjYS5nZXRNYXJrZXJEYXkoZDEpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAyO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGltZUFzTXMoZDApICE9PSB0aW1lQXNNcyhkMSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gY29tcHV0ZVBhcnRpYWxGb3JtYXR0aW5nT3B0aW9ucyhvcHRpb25zLCBiaWdnZXN0VW5pdCkge1xyXG4gICAgICAgIGxldCBwYXJ0aWFsT3B0aW9ucyA9IHt9O1xyXG4gICAgICAgIGZvciAobGV0IG5hbWUgaW4gb3B0aW9ucykge1xyXG4gICAgICAgICAgICBpZiAoIShuYW1lIGluIFNUQU5EQVJEX0RBVEVfUFJPUF9TRVZFUklUSUVTKSB8fCAvLyBub3QgYSBkYXRlIHBhcnQgcHJvcCAobGlrZSB0aW1lWm9uZSlcclxuICAgICAgICAgICAgICAgIFNUQU5EQVJEX0RBVEVfUFJPUF9TRVZFUklUSUVTW25hbWVdIDw9IGJpZ2dlc3RVbml0KSB7XHJcbiAgICAgICAgICAgICAgICBwYXJ0aWFsT3B0aW9uc1tuYW1lXSA9IG9wdGlvbnNbbmFtZV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHBhcnRpYWxPcHRpb25zO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZmluZENvbW1vbkluc2VydGlvbihmdWxsMCwgcGFydGlhbDAsIGZ1bGwxLCBwYXJ0aWFsMSkge1xyXG4gICAgICAgIGxldCBpMCA9IDA7XHJcbiAgICAgICAgd2hpbGUgKGkwIDwgZnVsbDAubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGxldCBmb3VuZDAgPSBmdWxsMC5pbmRleE9mKHBhcnRpYWwwLCBpMCk7XHJcbiAgICAgICAgICAgIGlmIChmb3VuZDAgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgYmVmb3JlMCA9IGZ1bGwwLnN1YnN0cigwLCBmb3VuZDApO1xyXG4gICAgICAgICAgICBpMCA9IGZvdW5kMCArIHBhcnRpYWwwLmxlbmd0aDtcclxuICAgICAgICAgICAgbGV0IGFmdGVyMCA9IGZ1bGwwLnN1YnN0cihpMCk7XHJcbiAgICAgICAgICAgIGxldCBpMSA9IDA7XHJcbiAgICAgICAgICAgIHdoaWxlIChpMSA8IGZ1bGwxLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgbGV0IGZvdW5kMSA9IGZ1bGwxLmluZGV4T2YocGFydGlhbDEsIGkxKTtcclxuICAgICAgICAgICAgICAgIGlmIChmb3VuZDEgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBsZXQgYmVmb3JlMSA9IGZ1bGwxLnN1YnN0cigwLCBmb3VuZDEpO1xyXG4gICAgICAgICAgICAgICAgaTEgPSBmb3VuZDEgKyBwYXJ0aWFsMS5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBsZXQgYWZ0ZXIxID0gZnVsbDEuc3Vic3RyKGkxKTtcclxuICAgICAgICAgICAgICAgIGlmIChiZWZvcmUwID09PSBiZWZvcmUxICYmIGFmdGVyMCA9PT0gYWZ0ZXIxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYmVmb3JlOiBiZWZvcmUwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhZnRlcjogYWZ0ZXIwLFxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZXhwYW5kWm9uZWRNYXJrZXIoZGF0ZUluZm8sIGNhbGVuZGFyU3lzdGVtKSB7XHJcbiAgICAgICAgbGV0IGEgPSBjYWxlbmRhclN5c3RlbS5tYXJrZXJUb0FycmF5KGRhdGVJbmZvLm1hcmtlcik7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgbWFya2VyOiBkYXRlSW5mby5tYXJrZXIsXHJcbiAgICAgICAgICAgIHRpbWVab25lT2Zmc2V0OiBkYXRlSW5mby50aW1lWm9uZU9mZnNldCxcclxuICAgICAgICAgICAgYXJyYXk6IGEsXHJcbiAgICAgICAgICAgIHllYXI6IGFbMF0sXHJcbiAgICAgICAgICAgIG1vbnRoOiBhWzFdLFxyXG4gICAgICAgICAgICBkYXk6IGFbMl0sXHJcbiAgICAgICAgICAgIGhvdXI6IGFbM10sXHJcbiAgICAgICAgICAgIG1pbnV0ZTogYVs0XSxcclxuICAgICAgICAgICAgc2Vjb25kOiBhWzVdLFxyXG4gICAgICAgICAgICBtaWxsaXNlY29uZDogYVs2XSxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNyZWF0ZVZlcmJvc2VGb3JtYXR0aW5nQXJnKHN0YXJ0LCBlbmQsIGNvbnRleHQsIGJldHRlckRlZmF1bHRTZXBhcmF0b3IpIHtcclxuICAgICAgICBsZXQgc3RhcnRJbmZvID0gZXhwYW5kWm9uZWRNYXJrZXIoc3RhcnQsIGNvbnRleHQuY2FsZW5kYXJTeXN0ZW0pO1xyXG4gICAgICAgIGxldCBlbmRJbmZvID0gZW5kID8gZXhwYW5kWm9uZWRNYXJrZXIoZW5kLCBjb250ZXh0LmNhbGVuZGFyU3lzdGVtKSA6IG51bGw7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgZGF0ZTogc3RhcnRJbmZvLFxyXG4gICAgICAgICAgICBzdGFydDogc3RhcnRJbmZvLFxyXG4gICAgICAgICAgICBlbmQ6IGVuZEluZm8sXHJcbiAgICAgICAgICAgIHRpbWVab25lOiBjb250ZXh0LnRpbWVab25lLFxyXG4gICAgICAgICAgICBsb2NhbGVDb2RlczogY29udGV4dC5sb2NhbGUuY29kZXMsXHJcbiAgICAgICAgICAgIGRlZmF1bHRTZXBhcmF0b3I6IGJldHRlckRlZmF1bHRTZXBhcmF0b3IgfHwgY29udGV4dC5kZWZhdWx0U2VwYXJhdG9yLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgLypcclxuICAgIFRPRE86IGZpeCB0aGUgdGVybWlub2xvZ3kgb2YgXCJmb3JtYXR0ZXJcIiB2cyBcImZvcm1hdHRpbmcgZnVuY1wiXHJcbiAgICAqL1xyXG4gICAgLypcclxuICAgIEF0IHRoZSB0aW1lIG9mIGluc3RhbnRpYXRpb24sIHRoaXMgb2JqZWN0IGRvZXMgbm90IGtub3cgd2hpY2ggY21kLWZvcm1hdHRpbmcgc3lzdGVtIGl0IHdpbGwgdXNlLlxyXG4gICAgSXQgcmVjZWl2ZXMgdGhpcyBhdCB0aGUgdGltZSBvZiBmb3JtYXR0aW5nLCBhcyBhIHNldHRpbmcuXHJcbiAgICAqL1xyXG4gICAgY2xhc3MgQ21kRm9ybWF0dGVyIHtcclxuICAgICAgICBjb25zdHJ1Y3RvcihjbWRTdHIpIHtcclxuICAgICAgICAgICAgdGhpcy5jbWRTdHIgPSBjbWRTdHI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvcm1hdChkYXRlLCBjb250ZXh0LCBiZXR0ZXJEZWZhdWx0U2VwYXJhdG9yKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmNtZEZvcm1hdHRlcih0aGlzLmNtZFN0ciwgY3JlYXRlVmVyYm9zZUZvcm1hdHRpbmdBcmcoZGF0ZSwgbnVsbCwgY29udGV4dCwgYmV0dGVyRGVmYXVsdFNlcGFyYXRvcikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3JtYXRSYW5nZShzdGFydCwgZW5kLCBjb250ZXh0LCBiZXR0ZXJEZWZhdWx0U2VwYXJhdG9yKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmNtZEZvcm1hdHRlcih0aGlzLmNtZFN0ciwgY3JlYXRlVmVyYm9zZUZvcm1hdHRpbmdBcmcoc3RhcnQsIGVuZCwgY29udGV4dCwgYmV0dGVyRGVmYXVsdFNlcGFyYXRvcikpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBjbGFzcyBGdW5jRm9ybWF0dGVyIHtcclxuICAgICAgICBjb25zdHJ1Y3RvcihmdW5jKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZnVuYyA9IGZ1bmM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvcm1hdChkYXRlLCBjb250ZXh0LCBiZXR0ZXJEZWZhdWx0U2VwYXJhdG9yKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZ1bmMoY3JlYXRlVmVyYm9zZUZvcm1hdHRpbmdBcmcoZGF0ZSwgbnVsbCwgY29udGV4dCwgYmV0dGVyRGVmYXVsdFNlcGFyYXRvcikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3JtYXRSYW5nZShzdGFydCwgZW5kLCBjb250ZXh0LCBiZXR0ZXJEZWZhdWx0U2VwYXJhdG9yKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZ1bmMoY3JlYXRlVmVyYm9zZUZvcm1hdHRpbmdBcmcoc3RhcnQsIGVuZCwgY29udGV4dCwgYmV0dGVyRGVmYXVsdFNlcGFyYXRvcikpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjcmVhdGVGb3JtYXR0ZXIoaW5wdXQpIHtcclxuICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnb2JqZWN0JyAmJiBpbnB1dCkgeyAvLyBub24tbnVsbCBvYmplY3RcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBOYXRpdmVGb3JtYXR0ZXIoaW5wdXQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IENtZEZvcm1hdHRlcihpbnB1dCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBGdW5jRm9ybWF0dGVyKGlucHV0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gYmFzZSBvcHRpb25zXHJcbiAgICAvLyAtLS0tLS0tLS0tLS1cclxuICAgIGNvbnN0IEJBU0VfT1BUSU9OX1JFRklORVJTID0ge1xyXG4gICAgICAgIG5hdkxpbmtEYXlDbGljazogaWRlbnRpdHksXHJcbiAgICAgICAgbmF2TGlua1dlZWtDbGljazogaWRlbnRpdHksXHJcbiAgICAgICAgZHVyYXRpb246IGNyZWF0ZUR1cmF0aW9uLFxyXG4gICAgICAgIGJvb3RzdHJhcEZvbnRBd2Vzb21lOiBpZGVudGl0eSxcclxuICAgICAgICBidXR0b25JY29uczogaWRlbnRpdHksXHJcbiAgICAgICAgY3VzdG9tQnV0dG9uczogaWRlbnRpdHksXHJcbiAgICAgICAgZGVmYXVsdEFsbERheUV2ZW50RHVyYXRpb246IGNyZWF0ZUR1cmF0aW9uLFxyXG4gICAgICAgIGRlZmF1bHRUaW1lZEV2ZW50RHVyYXRpb246IGNyZWF0ZUR1cmF0aW9uLFxyXG4gICAgICAgIG5leHREYXlUaHJlc2hvbGQ6IGNyZWF0ZUR1cmF0aW9uLFxyXG4gICAgICAgIHNjcm9sbFRpbWU6IGNyZWF0ZUR1cmF0aW9uLFxyXG4gICAgICAgIHNjcm9sbFRpbWVSZXNldDogQm9vbGVhbixcclxuICAgICAgICBzbG90TWluVGltZTogY3JlYXRlRHVyYXRpb24sXHJcbiAgICAgICAgc2xvdE1heFRpbWU6IGNyZWF0ZUR1cmF0aW9uLFxyXG4gICAgICAgIGRheVBvcG92ZXJGb3JtYXQ6IGNyZWF0ZUZvcm1hdHRlcixcclxuICAgICAgICBzbG90RHVyYXRpb246IGNyZWF0ZUR1cmF0aW9uLFxyXG4gICAgICAgIHNuYXBEdXJhdGlvbjogY3JlYXRlRHVyYXRpb24sXHJcbiAgICAgICAgaGVhZGVyVG9vbGJhcjogaWRlbnRpdHksXHJcbiAgICAgICAgZm9vdGVyVG9vbGJhcjogaWRlbnRpdHksXHJcbiAgICAgICAgZGVmYXVsdFJhbmdlU2VwYXJhdG9yOiBTdHJpbmcsXHJcbiAgICAgICAgdGl0bGVSYW5nZVNlcGFyYXRvcjogU3RyaW5nLFxyXG4gICAgICAgIGZvcmNlRXZlbnREdXJhdGlvbjogQm9vbGVhbixcclxuICAgICAgICBkYXlIZWFkZXJzOiBCb29sZWFuLFxyXG4gICAgICAgIGRheUhlYWRlckZvcm1hdDogY3JlYXRlRm9ybWF0dGVyLFxyXG4gICAgICAgIGRheUhlYWRlckNsYXNzTmFtZXM6IGlkZW50aXR5LFxyXG4gICAgICAgIGRheUhlYWRlckNvbnRlbnQ6IGlkZW50aXR5LFxyXG4gICAgICAgIGRheUhlYWRlckRpZE1vdW50OiBpZGVudGl0eSxcclxuICAgICAgICBkYXlIZWFkZXJXaWxsVW5tb3VudDogaWRlbnRpdHksXHJcbiAgICAgICAgZGF5Q2VsbENsYXNzTmFtZXM6IGlkZW50aXR5LFxyXG4gICAgICAgIGRheUNlbGxDb250ZW50OiBpZGVudGl0eSxcclxuICAgICAgICBkYXlDZWxsRGlkTW91bnQ6IGlkZW50aXR5LFxyXG4gICAgICAgIGRheUNlbGxXaWxsVW5tb3VudDogaWRlbnRpdHksXHJcbiAgICAgICAgaW5pdGlhbFZpZXc6IFN0cmluZyxcclxuICAgICAgICBhc3BlY3RSYXRpbzogTnVtYmVyLFxyXG4gICAgICAgIHdlZWtlbmRzOiBCb29sZWFuLFxyXG4gICAgICAgIHdlZWtOdW1iZXJDYWxjdWxhdGlvbjogaWRlbnRpdHksXHJcbiAgICAgICAgd2Vla051bWJlcnM6IEJvb2xlYW4sXHJcbiAgICAgICAgd2Vla051bWJlckNsYXNzTmFtZXM6IGlkZW50aXR5LFxyXG4gICAgICAgIHdlZWtOdW1iZXJDb250ZW50OiBpZGVudGl0eSxcclxuICAgICAgICB3ZWVrTnVtYmVyRGlkTW91bnQ6IGlkZW50aXR5LFxyXG4gICAgICAgIHdlZWtOdW1iZXJXaWxsVW5tb3VudDogaWRlbnRpdHksXHJcbiAgICAgICAgZWRpdGFibGU6IEJvb2xlYW4sXHJcbiAgICAgICAgdmlld0NsYXNzTmFtZXM6IGlkZW50aXR5LFxyXG4gICAgICAgIHZpZXdEaWRNb3VudDogaWRlbnRpdHksXHJcbiAgICAgICAgdmlld1dpbGxVbm1vdW50OiBpZGVudGl0eSxcclxuICAgICAgICBub3dJbmRpY2F0b3I6IEJvb2xlYW4sXHJcbiAgICAgICAgbm93SW5kaWNhdG9yQ2xhc3NOYW1lczogaWRlbnRpdHksXHJcbiAgICAgICAgbm93SW5kaWNhdG9yQ29udGVudDogaWRlbnRpdHksXHJcbiAgICAgICAgbm93SW5kaWNhdG9yRGlkTW91bnQ6IGlkZW50aXR5LFxyXG4gICAgICAgIG5vd0luZGljYXRvcldpbGxVbm1vdW50OiBpZGVudGl0eSxcclxuICAgICAgICBzaG93Tm9uQ3VycmVudERhdGVzOiBCb29sZWFuLFxyXG4gICAgICAgIGxhenlGZXRjaGluZzogQm9vbGVhbixcclxuICAgICAgICBzdGFydFBhcmFtOiBTdHJpbmcsXHJcbiAgICAgICAgZW5kUGFyYW06IFN0cmluZyxcclxuICAgICAgICB0aW1lWm9uZVBhcmFtOiBTdHJpbmcsXHJcbiAgICAgICAgdGltZVpvbmU6IFN0cmluZyxcclxuICAgICAgICBsb2NhbGVzOiBpZGVudGl0eSxcclxuICAgICAgICBsb2NhbGU6IGlkZW50aXR5LFxyXG4gICAgICAgIHRoZW1lU3lzdGVtOiBTdHJpbmcsXHJcbiAgICAgICAgZHJhZ1JldmVydER1cmF0aW9uOiBOdW1iZXIsXHJcbiAgICAgICAgZHJhZ1Njcm9sbDogQm9vbGVhbixcclxuICAgICAgICBhbGxEYXlNYWludGFpbkR1cmF0aW9uOiBCb29sZWFuLFxyXG4gICAgICAgIHVuc2VsZWN0QXV0bzogQm9vbGVhbixcclxuICAgICAgICBkcm9wQWNjZXB0OiBpZGVudGl0eSxcclxuICAgICAgICBldmVudE9yZGVyOiBwYXJzZUZpZWxkU3BlY3MsXHJcbiAgICAgICAgZXZlbnRPcmRlclN0cmljdDogQm9vbGVhbixcclxuICAgICAgICBoYW5kbGVXaW5kb3dSZXNpemU6IEJvb2xlYW4sXHJcbiAgICAgICAgd2luZG93UmVzaXplRGVsYXk6IE51bWJlcixcclxuICAgICAgICBsb25nUHJlc3NEZWxheTogTnVtYmVyLFxyXG4gICAgICAgIGV2ZW50RHJhZ01pbkRpc3RhbmNlOiBOdW1iZXIsXHJcbiAgICAgICAgZXhwYW5kUm93czogQm9vbGVhbixcclxuICAgICAgICBoZWlnaHQ6IGlkZW50aXR5LFxyXG4gICAgICAgIGNvbnRlbnRIZWlnaHQ6IGlkZW50aXR5LFxyXG4gICAgICAgIGRpcmVjdGlvbjogU3RyaW5nLFxyXG4gICAgICAgIHdlZWtOdW1iZXJGb3JtYXQ6IGNyZWF0ZUZvcm1hdHRlcixcclxuICAgICAgICBldmVudFJlc2l6YWJsZUZyb21TdGFydDogQm9vbGVhbixcclxuICAgICAgICBkaXNwbGF5RXZlbnRUaW1lOiBCb29sZWFuLFxyXG4gICAgICAgIGRpc3BsYXlFdmVudEVuZDogQm9vbGVhbixcclxuICAgICAgICB3ZWVrVGV4dDogU3RyaW5nLFxyXG4gICAgICAgIHdlZWtUZXh0TG9uZzogU3RyaW5nLFxyXG4gICAgICAgIHByb2dyZXNzaXZlRXZlbnRSZW5kZXJpbmc6IEJvb2xlYW4sXHJcbiAgICAgICAgYnVzaW5lc3NIb3VyczogaWRlbnRpdHksXHJcbiAgICAgICAgaW5pdGlhbERhdGU6IGlkZW50aXR5LFxyXG4gICAgICAgIG5vdzogaWRlbnRpdHksXHJcbiAgICAgICAgZXZlbnREYXRhVHJhbnNmb3JtOiBpZGVudGl0eSxcclxuICAgICAgICBzdGlja3lIZWFkZXJEYXRlczogaWRlbnRpdHksXHJcbiAgICAgICAgc3RpY2t5Rm9vdGVyU2Nyb2xsYmFyOiBpZGVudGl0eSxcclxuICAgICAgICB2aWV3SGVpZ2h0OiBpZGVudGl0eSxcclxuICAgICAgICBkZWZhdWx0QWxsRGF5OiBCb29sZWFuLFxyXG4gICAgICAgIGV2ZW50U291cmNlRmFpbHVyZTogaWRlbnRpdHksXHJcbiAgICAgICAgZXZlbnRTb3VyY2VTdWNjZXNzOiBpZGVudGl0eSxcclxuICAgICAgICBldmVudERpc3BsYXk6IFN0cmluZyxcclxuICAgICAgICBldmVudFN0YXJ0RWRpdGFibGU6IEJvb2xlYW4sXHJcbiAgICAgICAgZXZlbnREdXJhdGlvbkVkaXRhYmxlOiBCb29sZWFuLFxyXG4gICAgICAgIGV2ZW50T3ZlcmxhcDogaWRlbnRpdHksXHJcbiAgICAgICAgZXZlbnRDb25zdHJhaW50OiBpZGVudGl0eSxcclxuICAgICAgICBldmVudEFsbG93OiBpZGVudGl0eSxcclxuICAgICAgICBldmVudEJhY2tncm91bmRDb2xvcjogU3RyaW5nLFxyXG4gICAgICAgIGV2ZW50Qm9yZGVyQ29sb3I6IFN0cmluZyxcclxuICAgICAgICBldmVudFRleHRDb2xvcjogU3RyaW5nLFxyXG4gICAgICAgIGV2ZW50Q29sb3I6IFN0cmluZyxcclxuICAgICAgICBldmVudENsYXNzTmFtZXM6IGlkZW50aXR5LFxyXG4gICAgICAgIGV2ZW50Q29udGVudDogaWRlbnRpdHksXHJcbiAgICAgICAgZXZlbnREaWRNb3VudDogaWRlbnRpdHksXHJcbiAgICAgICAgZXZlbnRXaWxsVW5tb3VudDogaWRlbnRpdHksXHJcbiAgICAgICAgc2VsZWN0Q29uc3RyYWludDogaWRlbnRpdHksXHJcbiAgICAgICAgc2VsZWN0T3ZlcmxhcDogaWRlbnRpdHksXHJcbiAgICAgICAgc2VsZWN0QWxsb3c6IGlkZW50aXR5LFxyXG4gICAgICAgIGRyb3BwYWJsZTogQm9vbGVhbixcclxuICAgICAgICB1bnNlbGVjdENhbmNlbDogU3RyaW5nLFxyXG4gICAgICAgIHNsb3RMYWJlbEZvcm1hdDogaWRlbnRpdHksXHJcbiAgICAgICAgc2xvdExhbmVDbGFzc05hbWVzOiBpZGVudGl0eSxcclxuICAgICAgICBzbG90TGFuZUNvbnRlbnQ6IGlkZW50aXR5LFxyXG4gICAgICAgIHNsb3RMYW5lRGlkTW91bnQ6IGlkZW50aXR5LFxyXG4gICAgICAgIHNsb3RMYW5lV2lsbFVubW91bnQ6IGlkZW50aXR5LFxyXG4gICAgICAgIHNsb3RMYWJlbENsYXNzTmFtZXM6IGlkZW50aXR5LFxyXG4gICAgICAgIHNsb3RMYWJlbENvbnRlbnQ6IGlkZW50aXR5LFxyXG4gICAgICAgIHNsb3RMYWJlbERpZE1vdW50OiBpZGVudGl0eSxcclxuICAgICAgICBzbG90TGFiZWxXaWxsVW5tb3VudDogaWRlbnRpdHksXHJcbiAgICAgICAgZGF5TWF4RXZlbnRzOiBpZGVudGl0eSxcclxuICAgICAgICBkYXlNYXhFdmVudFJvd3M6IGlkZW50aXR5LFxyXG4gICAgICAgIGRheU1pbldpZHRoOiBOdW1iZXIsXHJcbiAgICAgICAgc2xvdExhYmVsSW50ZXJ2YWw6IGNyZWF0ZUR1cmF0aW9uLFxyXG4gICAgICAgIGFsbERheVRleHQ6IFN0cmluZyxcclxuICAgICAgICBhbGxEYXlDbGFzc05hbWVzOiBpZGVudGl0eSxcclxuICAgICAgICBhbGxEYXlDb250ZW50OiBpZGVudGl0eSxcclxuICAgICAgICBhbGxEYXlEaWRNb3VudDogaWRlbnRpdHksXHJcbiAgICAgICAgYWxsRGF5V2lsbFVubW91bnQ6IGlkZW50aXR5LFxyXG4gICAgICAgIHNsb3RNaW5XaWR0aDogTnVtYmVyLFxyXG4gICAgICAgIG5hdkxpbmtzOiBCb29sZWFuLFxyXG4gICAgICAgIGV2ZW50VGltZUZvcm1hdDogY3JlYXRlRm9ybWF0dGVyLFxyXG4gICAgICAgIHJlcmVuZGVyRGVsYXk6IE51bWJlcixcclxuICAgICAgICBtb3JlTGlua1RleHQ6IGlkZW50aXR5LFxyXG4gICAgICAgIG1vcmVMaW5rSGludDogaWRlbnRpdHksXHJcbiAgICAgICAgc2VsZWN0TWluRGlzdGFuY2U6IE51bWJlcixcclxuICAgICAgICBzZWxlY3RhYmxlOiBCb29sZWFuLFxyXG4gICAgICAgIHNlbGVjdExvbmdQcmVzc0RlbGF5OiBOdW1iZXIsXHJcbiAgICAgICAgZXZlbnRMb25nUHJlc3NEZWxheTogTnVtYmVyLFxyXG4gICAgICAgIHNlbGVjdE1pcnJvcjogQm9vbGVhbixcclxuICAgICAgICBldmVudE1heFN0YWNrOiBOdW1iZXIsXHJcbiAgICAgICAgZXZlbnRNaW5IZWlnaHQ6IE51bWJlcixcclxuICAgICAgICBldmVudE1pbldpZHRoOiBOdW1iZXIsXHJcbiAgICAgICAgZXZlbnRTaG9ydEhlaWdodDogTnVtYmVyLFxyXG4gICAgICAgIHNsb3RFdmVudE92ZXJsYXA6IEJvb2xlYW4sXHJcbiAgICAgICAgcGx1Z2luczogaWRlbnRpdHksXHJcbiAgICAgICAgZmlyc3REYXk6IE51bWJlcixcclxuICAgICAgICBkYXlDb3VudDogTnVtYmVyLFxyXG4gICAgICAgIGRhdGVBbGlnbm1lbnQ6IFN0cmluZyxcclxuICAgICAgICBkYXRlSW5jcmVtZW50OiBjcmVhdGVEdXJhdGlvbixcclxuICAgICAgICBoaWRkZW5EYXlzOiBpZGVudGl0eSxcclxuICAgICAgICBmaXhlZFdlZWtDb3VudDogQm9vbGVhbixcclxuICAgICAgICB2YWxpZFJhbmdlOiBpZGVudGl0eSxcclxuICAgICAgICB2aXNpYmxlUmFuZ2U6IGlkZW50aXR5LFxyXG4gICAgICAgIHRpdGxlRm9ybWF0OiBpZGVudGl0eSxcclxuICAgICAgICBldmVudEludGVyYWN0aXZlOiBCb29sZWFuLFxyXG4gICAgICAgIC8vIG9ubHkgdXNlZCBieSBsaXN0LXZpZXcsIGJ1dCBsYW5ndWFnZXMgZGVmaW5lIHRoZSB2YWx1ZSwgc28gd2UgbmVlZCBpdCBpbiBiYXNlIG9wdGlvbnNcclxuICAgICAgICBub0V2ZW50c1RleHQ6IFN0cmluZyxcclxuICAgICAgICB2aWV3SGludDogaWRlbnRpdHksXHJcbiAgICAgICAgbmF2TGlua0hpbnQ6IGlkZW50aXR5LFxyXG4gICAgICAgIGNsb3NlSGludDogU3RyaW5nLFxyXG4gICAgICAgIHRpbWVIaW50OiBTdHJpbmcsXHJcbiAgICAgICAgZXZlbnRIaW50OiBTdHJpbmcsXHJcbiAgICAgICAgbW9yZUxpbmtDbGljazogaWRlbnRpdHksXHJcbiAgICAgICAgbW9yZUxpbmtDbGFzc05hbWVzOiBpZGVudGl0eSxcclxuICAgICAgICBtb3JlTGlua0NvbnRlbnQ6IGlkZW50aXR5LFxyXG4gICAgICAgIG1vcmVMaW5rRGlkTW91bnQ6IGlkZW50aXR5LFxyXG4gICAgICAgIG1vcmVMaW5rV2lsbFVubW91bnQ6IGlkZW50aXR5LFxyXG4gICAgICAgIG1vbnRoU3RhcnRGb3JtYXQ6IGNyZWF0ZUZvcm1hdHRlcixcclxuICAgICAgICAvLyBmb3IgY29ubmVjdG9yc1xyXG4gICAgICAgIC8vIChjYW4ndCBiZSBwYXJ0IG9mIHBsdWdpbiBzeXN0ZW0gYi9jIG11c3QgYmUgcHJvdmlkZWQgYXQgcnVudGltZSlcclxuICAgICAgICBoYW5kbGVDdXN0b21SZW5kZXJpbmc6IGlkZW50aXR5LFxyXG4gICAgICAgIGN1c3RvbVJlbmRlcmluZ01ldGFNYXA6IGlkZW50aXR5LFxyXG4gICAgICAgIGN1c3RvbVJlbmRlcmluZ1JlcGxhY2VzRWw6IEJvb2xlYW4sXHJcbiAgICB9O1xyXG4gICAgLy8gZG8gTk9UIGdpdmUgYSB0eXBlIGhlcmUuIG5lZWQgYHR5cGVvZiBCQVNFX09QVElPTl9ERUZBVUxUU2AgdG8gZ2l2ZSByZWFsIHJlc3VsdHMuXHJcbiAgICAvLyByYXcgdmFsdWVzLlxyXG4gICAgY29uc3QgQkFTRV9PUFRJT05fREVGQVVMVFMgPSB7XHJcbiAgICAgICAgZXZlbnREaXNwbGF5OiAnYXV0bycsXHJcbiAgICAgICAgZGVmYXVsdFJhbmdlU2VwYXJhdG9yOiAnIC0gJyxcclxuICAgICAgICB0aXRsZVJhbmdlU2VwYXJhdG9yOiAnIFxcdTIwMTMgJyxcclxuICAgICAgICBkZWZhdWx0VGltZWRFdmVudER1cmF0aW9uOiAnMDE6MDA6MDAnLFxyXG4gICAgICAgIGRlZmF1bHRBbGxEYXlFdmVudER1cmF0aW9uOiB7IGRheTogMSB9LFxyXG4gICAgICAgIGZvcmNlRXZlbnREdXJhdGlvbjogZmFsc2UsXHJcbiAgICAgICAgbmV4dERheVRocmVzaG9sZDogJzAwOjAwOjAwJyxcclxuICAgICAgICBkYXlIZWFkZXJzOiB0cnVlLFxyXG4gICAgICAgIGluaXRpYWxWaWV3OiAnJyxcclxuICAgICAgICBhc3BlY3RSYXRpbzogMS4zNSxcclxuICAgICAgICBoZWFkZXJUb29sYmFyOiB7XHJcbiAgICAgICAgICAgIHN0YXJ0OiAndGl0bGUnLFxyXG4gICAgICAgICAgICBjZW50ZXI6ICcnLFxyXG4gICAgICAgICAgICBlbmQ6ICd0b2RheSBwcmV2LG5leHQnLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgd2Vla2VuZHM6IHRydWUsXHJcbiAgICAgICAgd2Vla051bWJlcnM6IGZhbHNlLFxyXG4gICAgICAgIHdlZWtOdW1iZXJDYWxjdWxhdGlvbjogJ2xvY2FsJyxcclxuICAgICAgICBlZGl0YWJsZTogZmFsc2UsXHJcbiAgICAgICAgbm93SW5kaWNhdG9yOiBmYWxzZSxcclxuICAgICAgICBzY3JvbGxUaW1lOiAnMDY6MDA6MDAnLFxyXG4gICAgICAgIHNjcm9sbFRpbWVSZXNldDogdHJ1ZSxcclxuICAgICAgICBzbG90TWluVGltZTogJzAwOjAwOjAwJyxcclxuICAgICAgICBzbG90TWF4VGltZTogJzI0OjAwOjAwJyxcclxuICAgICAgICBzaG93Tm9uQ3VycmVudERhdGVzOiB0cnVlLFxyXG4gICAgICAgIGxhenlGZXRjaGluZzogdHJ1ZSxcclxuICAgICAgICBzdGFydFBhcmFtOiAnc3RhcnQnLFxyXG4gICAgICAgIGVuZFBhcmFtOiAnZW5kJyxcclxuICAgICAgICB0aW1lWm9uZVBhcmFtOiAndGltZVpvbmUnLFxyXG4gICAgICAgIHRpbWVab25lOiAnbG9jYWwnLFxyXG4gICAgICAgIGxvY2FsZXM6IFtdLFxyXG4gICAgICAgIGxvY2FsZTogJycsXHJcbiAgICAgICAgdGhlbWVTeXN0ZW06ICdzdGFuZGFyZCcsXHJcbiAgICAgICAgZHJhZ1JldmVydER1cmF0aW9uOiA1MDAsXHJcbiAgICAgICAgZHJhZ1Njcm9sbDogdHJ1ZSxcclxuICAgICAgICBhbGxEYXlNYWludGFpbkR1cmF0aW9uOiBmYWxzZSxcclxuICAgICAgICB1bnNlbGVjdEF1dG86IHRydWUsXHJcbiAgICAgICAgZHJvcEFjY2VwdDogJyonLFxyXG4gICAgICAgIGV2ZW50T3JkZXI6ICdzdGFydCwtZHVyYXRpb24sYWxsRGF5LHRpdGxlJyxcclxuICAgICAgICBkYXlQb3BvdmVyRm9ybWF0OiB7IG1vbnRoOiAnbG9uZycsIGRheTogJ251bWVyaWMnLCB5ZWFyOiAnbnVtZXJpYycgfSxcclxuICAgICAgICBoYW5kbGVXaW5kb3dSZXNpemU6IHRydWUsXHJcbiAgICAgICAgd2luZG93UmVzaXplRGVsYXk6IDEwMCxcclxuICAgICAgICBsb25nUHJlc3NEZWxheTogMTAwMCxcclxuICAgICAgICBldmVudERyYWdNaW5EaXN0YW5jZTogNSxcclxuICAgICAgICBleHBhbmRSb3dzOiBmYWxzZSxcclxuICAgICAgICBuYXZMaW5rczogZmFsc2UsXHJcbiAgICAgICAgc2VsZWN0YWJsZTogZmFsc2UsXHJcbiAgICAgICAgZXZlbnRNaW5IZWlnaHQ6IDE1LFxyXG4gICAgICAgIGV2ZW50TWluV2lkdGg6IDMwLFxyXG4gICAgICAgIGV2ZW50U2hvcnRIZWlnaHQ6IDMwLFxyXG4gICAgICAgIG1vbnRoU3RhcnRGb3JtYXQ6IHsgbW9udGg6ICdsb25nJywgZGF5OiAnbnVtZXJpYycgfSxcclxuICAgIH07XHJcbiAgICAvLyBjYWxlbmRhciBsaXN0ZW5lcnNcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgY29uc3QgQ0FMRU5EQVJfTElTVEVORVJfUkVGSU5FUlMgPSB7XHJcbiAgICAgICAgZGF0ZXNTZXQ6IGlkZW50aXR5LFxyXG4gICAgICAgIGV2ZW50c1NldDogaWRlbnRpdHksXHJcbiAgICAgICAgZXZlbnRBZGQ6IGlkZW50aXR5LFxyXG4gICAgICAgIGV2ZW50Q2hhbmdlOiBpZGVudGl0eSxcclxuICAgICAgICBldmVudFJlbW92ZTogaWRlbnRpdHksXHJcbiAgICAgICAgd2luZG93UmVzaXplOiBpZGVudGl0eSxcclxuICAgICAgICBldmVudENsaWNrOiBpZGVudGl0eSxcclxuICAgICAgICBldmVudE1vdXNlRW50ZXI6IGlkZW50aXR5LFxyXG4gICAgICAgIGV2ZW50TW91c2VMZWF2ZTogaWRlbnRpdHksXHJcbiAgICAgICAgc2VsZWN0OiBpZGVudGl0eSxcclxuICAgICAgICB1bnNlbGVjdDogaWRlbnRpdHksXHJcbiAgICAgICAgbG9hZGluZzogaWRlbnRpdHksXHJcbiAgICAgICAgLy8gaW50ZXJuYWxcclxuICAgICAgICBfdW5tb3VudDogaWRlbnRpdHksXHJcbiAgICAgICAgX2JlZm9yZXByaW50OiBpZGVudGl0eSxcclxuICAgICAgICBfYWZ0ZXJwcmludDogaWRlbnRpdHksXHJcbiAgICAgICAgX25vRXZlbnREcm9wOiBpZGVudGl0eSxcclxuICAgICAgICBfbm9FdmVudFJlc2l6ZTogaWRlbnRpdHksXHJcbiAgICAgICAgX3Jlc2l6ZTogaWRlbnRpdHksXHJcbiAgICAgICAgX3Njcm9sbFJlcXVlc3Q6IGlkZW50aXR5LFxyXG4gICAgfTtcclxuICAgIC8vIGNhbGVuZGFyLXNwZWNpZmljIG9wdGlvbnNcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIGNvbnN0IENBTEVOREFSX09QVElPTl9SRUZJTkVSUyA9IHtcclxuICAgICAgICBidXR0b25UZXh0OiBpZGVudGl0eSxcclxuICAgICAgICBidXR0b25IaW50czogaWRlbnRpdHksXHJcbiAgICAgICAgdmlld3M6IGlkZW50aXR5LFxyXG4gICAgICAgIHBsdWdpbnM6IGlkZW50aXR5LFxyXG4gICAgICAgIGluaXRpYWxFdmVudHM6IGlkZW50aXR5LFxyXG4gICAgICAgIGV2ZW50czogaWRlbnRpdHksXHJcbiAgICAgICAgZXZlbnRTb3VyY2VzOiBpZGVudGl0eSxcclxuICAgIH07XHJcbiAgICBjb25zdCBDT01QTEVYX09QVElPTl9DT01QQVJBVE9SUyA9IHtcclxuICAgICAgICBoZWFkZXJUb29sYmFyOiBpc01heWJlT2JqZWN0c0VxdWFsLFxyXG4gICAgICAgIGZvb3RlclRvb2xiYXI6IGlzTWF5YmVPYmplY3RzRXF1YWwsXHJcbiAgICAgICAgYnV0dG9uVGV4dDogaXNNYXliZU9iamVjdHNFcXVhbCxcclxuICAgICAgICBidXR0b25IaW50czogaXNNYXliZU9iamVjdHNFcXVhbCxcclxuICAgICAgICBidXR0b25JY29uczogaXNNYXliZU9iamVjdHNFcXVhbCxcclxuICAgICAgICBkYXRlSW5jcmVtZW50OiBpc01heWJlT2JqZWN0c0VxdWFsLFxyXG4gICAgICAgIHBsdWdpbnM6IGlzTWF5YmVBcnJheXNFcXVhbCxcclxuICAgICAgICBldmVudHM6IGlzTWF5YmVBcnJheXNFcXVhbCxcclxuICAgICAgICBldmVudFNvdXJjZXM6IGlzTWF5YmVBcnJheXNFcXVhbCxcclxuICAgICAgICBbJ3Jlc291cmNlcyddOiBpc01heWJlQXJyYXlzRXF1YWwsXHJcbiAgICB9O1xyXG4gICAgZnVuY3Rpb24gaXNNYXliZU9iamVjdHNFcXVhbChhLCBiKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBhID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgYiA9PT0gJ29iamVjdCcgJiYgYSAmJiBiKSB7IC8vIGJvdGggbm9uLW51bGwgb2JqZWN0c1xyXG4gICAgICAgICAgICByZXR1cm4gaXNQcm9wc0VxdWFsKGEsIGIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYSA9PT0gYjtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGlzTWF5YmVBcnJheXNFcXVhbChhLCBiKSB7XHJcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYSkgJiYgQXJyYXkuaXNBcnJheShiKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gaXNBcnJheXNFcXVhbChhLCBiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGEgPT09IGI7XHJcbiAgICB9XHJcbiAgICAvLyB2aWV3LXNwZWNpZmljIG9wdGlvbnNcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgY29uc3QgVklFV19PUFRJT05fUkVGSU5FUlMgPSB7XHJcbiAgICAgICAgdHlwZTogU3RyaW5nLFxyXG4gICAgICAgIGNvbXBvbmVudDogaWRlbnRpdHksXHJcbiAgICAgICAgYnV0dG9uVGV4dDogU3RyaW5nLFxyXG4gICAgICAgIGJ1dHRvblRleHRLZXk6IFN0cmluZyxcclxuICAgICAgICBkYXRlUHJvZmlsZUdlbmVyYXRvckNsYXNzOiBpZGVudGl0eSxcclxuICAgICAgICB1c2VzTWluTWF4VGltZTogQm9vbGVhbixcclxuICAgICAgICBjbGFzc05hbWVzOiBpZGVudGl0eSxcclxuICAgICAgICBjb250ZW50OiBpZGVudGl0eSxcclxuICAgICAgICBkaWRNb3VudDogaWRlbnRpdHksXHJcbiAgICAgICAgd2lsbFVubW91bnQ6IGlkZW50aXR5LFxyXG4gICAgfTtcclxuICAgIC8vIHV0aWwgZnVuY3NcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIGZ1bmN0aW9uIG1lcmdlUmF3T3B0aW9ucyhvcHRpb25TZXRzKSB7XHJcbiAgICAgICAgcmV0dXJuIG1lcmdlUHJvcHMob3B0aW9uU2V0cywgQ09NUExFWF9PUFRJT05fQ09NUEFSQVRPUlMpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gcmVmaW5lUHJvcHMoaW5wdXQsIHJlZmluZXJzKSB7XHJcbiAgICAgICAgbGV0IHJlZmluZWQgPSB7fTtcclxuICAgICAgICBsZXQgZXh0cmEgPSB7fTtcclxuICAgICAgICBmb3IgKGxldCBwcm9wTmFtZSBpbiByZWZpbmVycykge1xyXG4gICAgICAgICAgICBpZiAocHJvcE5hbWUgaW4gaW5wdXQpIHtcclxuICAgICAgICAgICAgICAgIHJlZmluZWRbcHJvcE5hbWVdID0gcmVmaW5lcnNbcHJvcE5hbWVdKGlucHV0W3Byb3BOYW1lXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChsZXQgcHJvcE5hbWUgaW4gaW5wdXQpIHtcclxuICAgICAgICAgICAgaWYgKCEocHJvcE5hbWUgaW4gcmVmaW5lcnMpKSB7XHJcbiAgICAgICAgICAgICAgICBleHRyYVtwcm9wTmFtZV0gPSBpbnB1dFtwcm9wTmFtZV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHsgcmVmaW5lZCwgZXh0cmEgfTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGlkZW50aXR5KHJhdykge1xyXG4gICAgICAgIHJldHVybiByYXc7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gY3JlYXRlRXZlbnRJbnN0YW5jZShkZWZJZCwgcmFuZ2UsIGZvcmNlZFN0YXJ0VHpvLCBmb3JjZWRFbmRUem8pIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBpbnN0YW5jZUlkOiBndWlkKCksXHJcbiAgICAgICAgICAgIGRlZklkLFxyXG4gICAgICAgICAgICByYW5nZSxcclxuICAgICAgICAgICAgZm9yY2VkU3RhcnRUem86IGZvcmNlZFN0YXJ0VHpvID09IG51bGwgPyBudWxsIDogZm9yY2VkU3RhcnRUem8sXHJcbiAgICAgICAgICAgIGZvcmNlZEVuZFR6bzogZm9yY2VkRW5kVHpvID09IG51bGwgPyBudWxsIDogZm9yY2VkRW5kVHpvLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcGFyc2VSZWN1cnJpbmcocmVmaW5lZCwgZGVmYXVsdEFsbERheSwgZGF0ZUVudiwgcmVjdXJyaW5nVHlwZXMpIHtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlY3VycmluZ1R5cGVzLmxlbmd0aDsgaSArPSAxKSB7XHJcbiAgICAgICAgICAgIGxldCBwYXJzZWQgPSByZWN1cnJpbmdUeXBlc1tpXS5wYXJzZShyZWZpbmVkLCBkYXRlRW52KTtcclxuICAgICAgICAgICAgaWYgKHBhcnNlZCkge1xyXG4gICAgICAgICAgICAgICAgbGV0IHsgYWxsRGF5IH0gPSByZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgaWYgKGFsbERheSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWxsRGF5ID0gZGVmYXVsdEFsbERheTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYWxsRGF5ID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWxsRGF5ID0gcGFyc2VkLmFsbERheUd1ZXNzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWxsRGF5ID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbERheSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICBhbGxEYXksXHJcbiAgICAgICAgICAgICAgICAgICAgZHVyYXRpb246IHBhcnNlZC5kdXJhdGlvbixcclxuICAgICAgICAgICAgICAgICAgICB0eXBlRGF0YTogcGFyc2VkLnR5cGVEYXRhLFxyXG4gICAgICAgICAgICAgICAgICAgIHR5cGVJZDogaSxcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBleHBhbmRSZWN1cnJpbmcoZXZlbnRTdG9yZSwgZnJhbWluZ1JhbmdlLCBjb250ZXh0KSB7XHJcbiAgICAgICAgbGV0IHsgZGF0ZUVudiwgcGx1Z2luSG9va3MsIG9wdGlvbnMgfSA9IGNvbnRleHQ7XHJcbiAgICAgICAgbGV0IHsgZGVmcywgaW5zdGFuY2VzIH0gPSBldmVudFN0b3JlO1xyXG4gICAgICAgIC8vIHJlbW92ZSBleGlzdGluZyByZWN1cnJpbmcgaW5zdGFuY2VzXHJcbiAgICAgICAgLy8gVE9ETzogYmFkLiBhbHdheXMgZXhwYW5kIGV2ZW50cyBhcyBhIHNlY29uZCBzdGVwXHJcbiAgICAgICAgaW5zdGFuY2VzID0gZmlsdGVySGFzaChpbnN0YW5jZXMsIChpbnN0YW5jZSkgPT4gIWRlZnNbaW5zdGFuY2UuZGVmSWRdLnJlY3VycmluZ0RlZik7XHJcbiAgICAgICAgZm9yIChsZXQgZGVmSWQgaW4gZGVmcykge1xyXG4gICAgICAgICAgICBsZXQgZGVmID0gZGVmc1tkZWZJZF07XHJcbiAgICAgICAgICAgIGlmIChkZWYucmVjdXJyaW5nRGVmKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgeyBkdXJhdGlvbiB9ID0gZGVmLnJlY3VycmluZ0RlZjtcclxuICAgICAgICAgICAgICAgIGlmICghZHVyYXRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbiA9IGRlZi5hbGxEYXkgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRlZmF1bHRBbGxEYXlFdmVudER1cmF0aW9uIDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kZWZhdWx0VGltZWRFdmVudER1cmF0aW9uO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbGV0IHN0YXJ0cyA9IGV4cGFuZFJlY3VycmluZ1JhbmdlcyhkZWYsIGR1cmF0aW9uLCBmcmFtaW5nUmFuZ2UsIGRhdGVFbnYsIHBsdWdpbkhvb2tzLnJlY3VycmluZ1R5cGVzKTtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IHN0YXJ0IG9mIHN0YXJ0cykge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBpbnN0YW5jZSA9IGNyZWF0ZUV2ZW50SW5zdGFuY2UoZGVmSWQsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogZGF0ZUVudi5hZGQoc3RhcnQsIGR1cmF0aW9uKSxcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZXNbaW5zdGFuY2UuaW5zdGFuY2VJZF0gPSBpbnN0YW5jZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4geyBkZWZzLCBpbnN0YW5jZXMgfTtcclxuICAgIH1cclxuICAgIC8qXHJcbiAgICBFdmVudCBNVVNUIGhhdmUgYSByZWN1cnJpbmdEZWZcclxuICAgICovXHJcbiAgICBmdW5jdGlvbiBleHBhbmRSZWN1cnJpbmdSYW5nZXMoZXZlbnREZWYsIGR1cmF0aW9uLCBmcmFtaW5nUmFuZ2UsIGRhdGVFbnYsIHJlY3VycmluZ1R5cGVzKSB7XHJcbiAgICAgICAgbGV0IHR5cGVEZWYgPSByZWN1cnJpbmdUeXBlc1tldmVudERlZi5yZWN1cnJpbmdEZWYudHlwZUlkXTtcclxuICAgICAgICBsZXQgbWFya2VycyA9IHR5cGVEZWYuZXhwYW5kKGV2ZW50RGVmLnJlY3VycmluZ0RlZi50eXBlRGF0YSwge1xyXG4gICAgICAgICAgICBzdGFydDogZGF0ZUVudi5zdWJ0cmFjdChmcmFtaW5nUmFuZ2Uuc3RhcnQsIGR1cmF0aW9uKSxcclxuICAgICAgICAgICAgZW5kOiBmcmFtaW5nUmFuZ2UuZW5kLFxyXG4gICAgICAgIH0sIGRhdGVFbnYpO1xyXG4gICAgICAgIC8vIHRoZSByZWN1cnJlbmNlIHBsdWdpbnMgZG9uJ3QgZ3VhcmFudGVlIHRoYXQgYWxsLWRheSBldmVudHMgYXJlIHN0YXJ0LW9mLWRheSwgc28gd2UgaGF2ZSB0b1xyXG4gICAgICAgIGlmIChldmVudERlZi5hbGxEYXkpIHtcclxuICAgICAgICAgICAgbWFya2VycyA9IG1hcmtlcnMubWFwKHN0YXJ0T2ZEYXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbWFya2VycztcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBwYXJzZUV2ZW50cyhyYXdFdmVudHMsIGV2ZW50U291cmNlLCBjb250ZXh0LCBhbGxvd09wZW5SYW5nZSwgZGVmSWRNYXAsIGluc3RhbmNlSWRNYXApIHtcclxuICAgICAgICBsZXQgZXZlbnRTdG9yZSA9IGNyZWF0ZUVtcHR5RXZlbnRTdG9yZSgpO1xyXG4gICAgICAgIGxldCBldmVudFJlZmluZXJzID0gYnVpbGRFdmVudFJlZmluZXJzKGNvbnRleHQpO1xyXG4gICAgICAgIGZvciAobGV0IHJhd0V2ZW50IG9mIHJhd0V2ZW50cykge1xyXG4gICAgICAgICAgICBsZXQgdHVwbGUgPSBwYXJzZUV2ZW50KHJhd0V2ZW50LCBldmVudFNvdXJjZSwgY29udGV4dCwgYWxsb3dPcGVuUmFuZ2UsIGV2ZW50UmVmaW5lcnMsIGRlZklkTWFwLCBpbnN0YW5jZUlkTWFwKTtcclxuICAgICAgICAgICAgaWYgKHR1cGxlKSB7XHJcbiAgICAgICAgICAgICAgICBldmVudFR1cGxlVG9TdG9yZSh0dXBsZSwgZXZlbnRTdG9yZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGV2ZW50U3RvcmU7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBldmVudFR1cGxlVG9TdG9yZSh0dXBsZSwgZXZlbnRTdG9yZSA9IGNyZWF0ZUVtcHR5RXZlbnRTdG9yZSgpKSB7XHJcbiAgICAgICAgZXZlbnRTdG9yZS5kZWZzW3R1cGxlLmRlZi5kZWZJZF0gPSB0dXBsZS5kZWY7XHJcbiAgICAgICAgaWYgKHR1cGxlLmluc3RhbmNlKSB7XHJcbiAgICAgICAgICAgIGV2ZW50U3RvcmUuaW5zdGFuY2VzW3R1cGxlLmluc3RhbmNlLmluc3RhbmNlSWRdID0gdHVwbGUuaW5zdGFuY2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBldmVudFN0b3JlO1xyXG4gICAgfVxyXG4gICAgLy8gcmV0cmlldmVzIGV2ZW50cyB0aGF0IGhhdmUgdGhlIHNhbWUgZ3JvdXBJZCBhcyB0aGUgaW5zdGFuY2Ugc3BlY2lmaWVkIGJ5IGBpbnN0YW5jZUlkYFxyXG4gICAgLy8gb3IgdGhleSBhcmUgdGhlIHNhbWUgYXMgdGhlIGluc3RhbmNlLlxyXG4gICAgLy8gd2h5IG1pZ2h0IGluc3RhbmNlSWQgbm90IGJlIGluIHRoZSBzdG9yZT8gYW4gZXZlbnQgZnJvbSBhbm90aGVyIGNhbGVuZGFyP1xyXG4gICAgZnVuY3Rpb24gZ2V0UmVsZXZhbnRFdmVudHMoZXZlbnRTdG9yZSwgaW5zdGFuY2VJZCkge1xyXG4gICAgICAgIGxldCBpbnN0YW5jZSA9IGV2ZW50U3RvcmUuaW5zdGFuY2VzW2luc3RhbmNlSWRdO1xyXG4gICAgICAgIGlmIChpbnN0YW5jZSkge1xyXG4gICAgICAgICAgICBsZXQgZGVmID0gZXZlbnRTdG9yZS5kZWZzW2luc3RhbmNlLmRlZklkXTtcclxuICAgICAgICAgICAgLy8gZ2V0IGV2ZW50cy9pbnN0YW5jZXMgd2l0aCBzYW1lIGdyb3VwXHJcbiAgICAgICAgICAgIGxldCBuZXdTdG9yZSA9IGZpbHRlckV2ZW50U3RvcmVEZWZzKGV2ZW50U3RvcmUsIChsb29rRGVmKSA9PiBpc0V2ZW50RGVmc0dyb3VwZWQoZGVmLCBsb29rRGVmKSk7XHJcbiAgICAgICAgICAgIC8vIGFkZCB0aGUgb3JpZ2luYWxcclxuICAgICAgICAgICAgLy8gVE9ETzogd2lzaCB3ZSBjb3VsZCB1c2UgZXZlbnRUdXBsZVRvU3RvcmUgb3Igc29tZXRoaW5nIGxpa2UgaXRcclxuICAgICAgICAgICAgbmV3U3RvcmUuZGVmc1tkZWYuZGVmSWRdID0gZGVmO1xyXG4gICAgICAgICAgICBuZXdTdG9yZS5pbnN0YW5jZXNbaW5zdGFuY2UuaW5zdGFuY2VJZF0gPSBpbnN0YW5jZTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ld1N0b3JlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY3JlYXRlRW1wdHlFdmVudFN0b3JlKCk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBpc0V2ZW50RGVmc0dyb3VwZWQoZGVmMCwgZGVmMSkge1xyXG4gICAgICAgIHJldHVybiBCb29sZWFuKGRlZjAuZ3JvdXBJZCAmJiBkZWYwLmdyb3VwSWQgPT09IGRlZjEuZ3JvdXBJZCk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBjcmVhdGVFbXB0eUV2ZW50U3RvcmUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHsgZGVmczoge30sIGluc3RhbmNlczoge30gfTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIG1lcmdlRXZlbnRTdG9yZXMoc3RvcmUwLCBzdG9yZTEpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBkZWZzOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHN0b3JlMC5kZWZzKSwgc3RvcmUxLmRlZnMpLFxyXG4gICAgICAgICAgICBpbnN0YW5jZXM6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc3RvcmUwLmluc3RhbmNlcyksIHN0b3JlMS5pbnN0YW5jZXMpLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBmaWx0ZXJFdmVudFN0b3JlRGVmcyhldmVudFN0b3JlLCBmaWx0ZXJGdW5jKSB7XHJcbiAgICAgICAgbGV0IGRlZnMgPSBmaWx0ZXJIYXNoKGV2ZW50U3RvcmUuZGVmcywgZmlsdGVyRnVuYyk7XHJcbiAgICAgICAgbGV0IGluc3RhbmNlcyA9IGZpbHRlckhhc2goZXZlbnRTdG9yZS5pbnN0YW5jZXMsIChpbnN0YW5jZSkgPT4gKGRlZnNbaW5zdGFuY2UuZGVmSWRdIC8vIHN0aWxsIGV4aXN0cz9cclxuICAgICAgICApKTtcclxuICAgICAgICByZXR1cm4geyBkZWZzLCBpbnN0YW5jZXMgfTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGV4Y2x1ZGVTdWJFdmVudFN0b3JlKG1hc3Rlciwgc3ViKSB7XHJcbiAgICAgICAgbGV0IHsgZGVmcywgaW5zdGFuY2VzIH0gPSBtYXN0ZXI7XHJcbiAgICAgICAgbGV0IGZpbHRlcmVkRGVmcyA9IHt9O1xyXG4gICAgICAgIGxldCBmaWx0ZXJlZEluc3RhbmNlcyA9IHt9O1xyXG4gICAgICAgIGZvciAobGV0IGRlZklkIGluIGRlZnMpIHtcclxuICAgICAgICAgICAgaWYgKCFzdWIuZGVmc1tkZWZJZF0pIHsgLy8gbm90IGV4cGxpY2l0bHkgZXhjbHVkZWRcclxuICAgICAgICAgICAgICAgIGZpbHRlcmVkRGVmc1tkZWZJZF0gPSBkZWZzW2RlZklkXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGxldCBpbnN0YW5jZUlkIGluIGluc3RhbmNlcykge1xyXG4gICAgICAgICAgICBpZiAoIXN1Yi5pbnN0YW5jZXNbaW5zdGFuY2VJZF0gJiYgLy8gbm90IGV4cGxpY2l0bHkgZXhjbHVkZWRcclxuICAgICAgICAgICAgICAgIGZpbHRlcmVkRGVmc1tpbnN0YW5jZXNbaW5zdGFuY2VJZF0uZGVmSWRdIC8vIGRlZiB3YXNuJ3QgZmlsdGVyZWQgYXdheVxyXG4gICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICAgIGZpbHRlcmVkSW5zdGFuY2VzW2luc3RhbmNlSWRdID0gaW5zdGFuY2VzW2luc3RhbmNlSWRdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGRlZnM6IGZpbHRlcmVkRGVmcyxcclxuICAgICAgICAgICAgaW5zdGFuY2VzOiBmaWx0ZXJlZEluc3RhbmNlcyxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZUNvbnN0cmFpbnQoaW5wdXQsIGNvbnRleHQpIHtcclxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlRXZlbnRzKGlucHV0LCBudWxsLCBjb250ZXh0LCB0cnVlKTsgLy8gYWxsb3dPcGVuUmFuZ2U9dHJ1ZVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnb2JqZWN0JyAmJiBpbnB1dCkgeyAvLyBub24tbnVsbCBvYmplY3RcclxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlRXZlbnRzKFtpbnB1dF0sIG51bGwsIGNvbnRleHQsIHRydWUpOyAvLyBhbGxvd09wZW5SYW5nZT10cnVlXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpbnB1dCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBTdHJpbmcoaW5wdXQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBwYXJzZUNsYXNzTmFtZXMocmF3KSB7XHJcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmF3KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gcmF3O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mIHJhdyA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJhdy5zcGxpdCgvXFxzKy8pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVE9ETzogYmV0dGVyIGNhbGxlZCBcIkV2ZW50U2V0dGluZ3NcIiBvciBcIkV2ZW50Q29uZmlnXCJcclxuICAgIC8vIFRPRE86IG1vdmUgdGhpcyBmaWxlIGludG8gc3RydWN0c1xyXG4gICAgLy8gVE9ETzogc2VwYXJhdGUgY29uc3RyYWludC9vdmVybGFwL2FsbG93LCBiZWNhdXNlIHNlbGVjdGlvbiB1c2VzIG9ubHkgdGhhdCwgbm90IG90aGVyIHByb3BzXHJcbiAgICBjb25zdCBFVkVOVF9VSV9SRUZJTkVSUyA9IHtcclxuICAgICAgICBkaXNwbGF5OiBTdHJpbmcsXHJcbiAgICAgICAgZWRpdGFibGU6IEJvb2xlYW4sXHJcbiAgICAgICAgc3RhcnRFZGl0YWJsZTogQm9vbGVhbixcclxuICAgICAgICBkdXJhdGlvbkVkaXRhYmxlOiBCb29sZWFuLFxyXG4gICAgICAgIGNvbnN0cmFpbnQ6IGlkZW50aXR5LFxyXG4gICAgICAgIG92ZXJsYXA6IGlkZW50aXR5LFxyXG4gICAgICAgIGFsbG93OiBpZGVudGl0eSxcclxuICAgICAgICBjbGFzc05hbWU6IHBhcnNlQ2xhc3NOYW1lcyxcclxuICAgICAgICBjbGFzc05hbWVzOiBwYXJzZUNsYXNzTmFtZXMsXHJcbiAgICAgICAgY29sb3I6IFN0cmluZyxcclxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFN0cmluZyxcclxuICAgICAgICBib3JkZXJDb2xvcjogU3RyaW5nLFxyXG4gICAgICAgIHRleHRDb2xvcjogU3RyaW5nLFxyXG4gICAgfTtcclxuICAgIGNvbnN0IEVNUFRZX0VWRU5UX1VJID0ge1xyXG4gICAgICAgIGRpc3BsYXk6IG51bGwsXHJcbiAgICAgICAgc3RhcnRFZGl0YWJsZTogbnVsbCxcclxuICAgICAgICBkdXJhdGlvbkVkaXRhYmxlOiBudWxsLFxyXG4gICAgICAgIGNvbnN0cmFpbnRzOiBbXSxcclxuICAgICAgICBvdmVybGFwOiBudWxsLFxyXG4gICAgICAgIGFsbG93czogW10sXHJcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiAnJyxcclxuICAgICAgICBib3JkZXJDb2xvcjogJycsXHJcbiAgICAgICAgdGV4dENvbG9yOiAnJyxcclxuICAgICAgICBjbGFzc05hbWVzOiBbXSxcclxuICAgIH07XHJcbiAgICBmdW5jdGlvbiBjcmVhdGVFdmVudFVpKHJlZmluZWQsIGNvbnRleHQpIHtcclxuICAgICAgICBsZXQgY29uc3RyYWludCA9IG5vcm1hbGl6ZUNvbnN0cmFpbnQocmVmaW5lZC5jb25zdHJhaW50LCBjb250ZXh0KTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBkaXNwbGF5OiByZWZpbmVkLmRpc3BsYXkgfHwgbnVsbCxcclxuICAgICAgICAgICAgc3RhcnRFZGl0YWJsZTogcmVmaW5lZC5zdGFydEVkaXRhYmxlICE9IG51bGwgPyByZWZpbmVkLnN0YXJ0RWRpdGFibGUgOiByZWZpbmVkLmVkaXRhYmxlLFxyXG4gICAgICAgICAgICBkdXJhdGlvbkVkaXRhYmxlOiByZWZpbmVkLmR1cmF0aW9uRWRpdGFibGUgIT0gbnVsbCA/IHJlZmluZWQuZHVyYXRpb25FZGl0YWJsZSA6IHJlZmluZWQuZWRpdGFibGUsXHJcbiAgICAgICAgICAgIGNvbnN0cmFpbnRzOiBjb25zdHJhaW50ICE9IG51bGwgPyBbY29uc3RyYWludF0gOiBbXSxcclxuICAgICAgICAgICAgb3ZlcmxhcDogcmVmaW5lZC5vdmVybGFwICE9IG51bGwgPyByZWZpbmVkLm92ZXJsYXAgOiBudWxsLFxyXG4gICAgICAgICAgICBhbGxvd3M6IHJlZmluZWQuYWxsb3cgIT0gbnVsbCA/IFtyZWZpbmVkLmFsbG93XSA6IFtdLFxyXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IHJlZmluZWQuYmFja2dyb3VuZENvbG9yIHx8IHJlZmluZWQuY29sb3IgfHwgJycsXHJcbiAgICAgICAgICAgIGJvcmRlckNvbG9yOiByZWZpbmVkLmJvcmRlckNvbG9yIHx8IHJlZmluZWQuY29sb3IgfHwgJycsXHJcbiAgICAgICAgICAgIHRleHRDb2xvcjogcmVmaW5lZC50ZXh0Q29sb3IgfHwgJycsXHJcbiAgICAgICAgICAgIGNsYXNzTmFtZXM6IChyZWZpbmVkLmNsYXNzTmFtZSB8fCBbXSkuY29uY2F0KHJlZmluZWQuY2xhc3NOYW1lcyB8fCBbXSksIC8vIGpvaW4gc2luZ3VsYXIgYW5kIHBsdXJhbFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICAvLyBUT0RPOiBwcmV2ZW50IGFnYWluc3QgcHJvYmxlbXMgd2l0aCA8MiBhcmdzIVxyXG4gICAgZnVuY3Rpb24gY29tYmluZUV2ZW50VWlzKHVpcykge1xyXG4gICAgICAgIHJldHVybiB1aXMucmVkdWNlKGNvbWJpbmVUd29FdmVudFVpcywgRU1QVFlfRVZFTlRfVUkpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gY29tYmluZVR3b0V2ZW50VWlzKGl0ZW0wLCBpdGVtMSkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGRpc3BsYXk6IGl0ZW0xLmRpc3BsYXkgIT0gbnVsbCA/IGl0ZW0xLmRpc3BsYXkgOiBpdGVtMC5kaXNwbGF5LFxyXG4gICAgICAgICAgICBzdGFydEVkaXRhYmxlOiBpdGVtMS5zdGFydEVkaXRhYmxlICE9IG51bGwgPyBpdGVtMS5zdGFydEVkaXRhYmxlIDogaXRlbTAuc3RhcnRFZGl0YWJsZSxcclxuICAgICAgICAgICAgZHVyYXRpb25FZGl0YWJsZTogaXRlbTEuZHVyYXRpb25FZGl0YWJsZSAhPSBudWxsID8gaXRlbTEuZHVyYXRpb25FZGl0YWJsZSA6IGl0ZW0wLmR1cmF0aW9uRWRpdGFibGUsXHJcbiAgICAgICAgICAgIGNvbnN0cmFpbnRzOiBpdGVtMC5jb25zdHJhaW50cy5jb25jYXQoaXRlbTEuY29uc3RyYWludHMpLFxyXG4gICAgICAgICAgICBvdmVybGFwOiB0eXBlb2YgaXRlbTEub3ZlcmxhcCA9PT0gJ2Jvb2xlYW4nID8gaXRlbTEub3ZlcmxhcCA6IGl0ZW0wLm92ZXJsYXAsXHJcbiAgICAgICAgICAgIGFsbG93czogaXRlbTAuYWxsb3dzLmNvbmNhdChpdGVtMS5hbGxvd3MpLFxyXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGl0ZW0xLmJhY2tncm91bmRDb2xvciB8fCBpdGVtMC5iYWNrZ3JvdW5kQ29sb3IsXHJcbiAgICAgICAgICAgIGJvcmRlckNvbG9yOiBpdGVtMS5ib3JkZXJDb2xvciB8fCBpdGVtMC5ib3JkZXJDb2xvcixcclxuICAgICAgICAgICAgdGV4dENvbG9yOiBpdGVtMS50ZXh0Q29sb3IgfHwgaXRlbTAudGV4dENvbG9yLFxyXG4gICAgICAgICAgICBjbGFzc05hbWVzOiBpdGVtMC5jbGFzc05hbWVzLmNvbmNhdChpdGVtMS5jbGFzc05hbWVzKSxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IEVWRU5UX05PTl9EQVRFX1JFRklORVJTID0ge1xyXG4gICAgICAgIGlkOiBTdHJpbmcsXHJcbiAgICAgICAgZ3JvdXBJZDogU3RyaW5nLFxyXG4gICAgICAgIHRpdGxlOiBTdHJpbmcsXHJcbiAgICAgICAgdXJsOiBTdHJpbmcsXHJcbiAgICAgICAgaW50ZXJhY3RpdmU6IEJvb2xlYW4sXHJcbiAgICB9O1xyXG4gICAgY29uc3QgRVZFTlRfREFURV9SRUZJTkVSUyA9IHtcclxuICAgICAgICBzdGFydDogaWRlbnRpdHksXHJcbiAgICAgICAgZW5kOiBpZGVudGl0eSxcclxuICAgICAgICBkYXRlOiBpZGVudGl0eSxcclxuICAgICAgICBhbGxEYXk6IEJvb2xlYW4sXHJcbiAgICB9O1xyXG4gICAgY29uc3QgRVZFTlRfUkVGSU5FUlMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgRVZFTlRfTk9OX0RBVEVfUkVGSU5FUlMpLCBFVkVOVF9EQVRFX1JFRklORVJTKSwgeyBleHRlbmRlZFByb3BzOiBpZGVudGl0eSB9KTtcclxuICAgIGZ1bmN0aW9uIHBhcnNlRXZlbnQocmF3LCBldmVudFNvdXJjZSwgY29udGV4dCwgYWxsb3dPcGVuUmFuZ2UsIHJlZmluZXJzID0gYnVpbGRFdmVudFJlZmluZXJzKGNvbnRleHQpLCBkZWZJZE1hcCwgaW5zdGFuY2VJZE1hcCkge1xyXG4gICAgICAgIGxldCB7IHJlZmluZWQsIGV4dHJhIH0gPSByZWZpbmVFdmVudERlZihyYXcsIGNvbnRleHQsIHJlZmluZXJzKTtcclxuICAgICAgICBsZXQgZGVmYXVsdEFsbERheSA9IGNvbXB1dGVJc0RlZmF1bHRBbGxEYXkoZXZlbnRTb3VyY2UsIGNvbnRleHQpO1xyXG4gICAgICAgIGxldCByZWN1cnJpbmdSZXMgPSBwYXJzZVJlY3VycmluZyhyZWZpbmVkLCBkZWZhdWx0QWxsRGF5LCBjb250ZXh0LmRhdGVFbnYsIGNvbnRleHQucGx1Z2luSG9va3MucmVjdXJyaW5nVHlwZXMpO1xyXG4gICAgICAgIGlmIChyZWN1cnJpbmdSZXMpIHtcclxuICAgICAgICAgICAgbGV0IGRlZiA9IHBhcnNlRXZlbnREZWYocmVmaW5lZCwgZXh0cmEsIGV2ZW50U291cmNlID8gZXZlbnRTb3VyY2Uuc291cmNlSWQgOiAnJywgcmVjdXJyaW5nUmVzLmFsbERheSwgQm9vbGVhbihyZWN1cnJpbmdSZXMuZHVyYXRpb24pLCBjb250ZXh0LCBkZWZJZE1hcCk7XHJcbiAgICAgICAgICAgIGRlZi5yZWN1cnJpbmdEZWYgPSB7XHJcbiAgICAgICAgICAgICAgICB0eXBlSWQ6IHJlY3VycmluZ1Jlcy50eXBlSWQsXHJcbiAgICAgICAgICAgICAgICB0eXBlRGF0YTogcmVjdXJyaW5nUmVzLnR5cGVEYXRhLFxyXG4gICAgICAgICAgICAgICAgZHVyYXRpb246IHJlY3VycmluZ1Jlcy5kdXJhdGlvbixcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIHsgZGVmLCBpbnN0YW5jZTogbnVsbCB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgc2luZ2xlUmVzID0gcGFyc2VTaW5nbGUocmVmaW5lZCwgZGVmYXVsdEFsbERheSwgY29udGV4dCwgYWxsb3dPcGVuUmFuZ2UpO1xyXG4gICAgICAgIGlmIChzaW5nbGVSZXMpIHtcclxuICAgICAgICAgICAgbGV0IGRlZiA9IHBhcnNlRXZlbnREZWYocmVmaW5lZCwgZXh0cmEsIGV2ZW50U291cmNlID8gZXZlbnRTb3VyY2Uuc291cmNlSWQgOiAnJywgc2luZ2xlUmVzLmFsbERheSwgc2luZ2xlUmVzLmhhc0VuZCwgY29udGV4dCwgZGVmSWRNYXApO1xyXG4gICAgICAgICAgICBsZXQgaW5zdGFuY2UgPSBjcmVhdGVFdmVudEluc3RhbmNlKGRlZi5kZWZJZCwgc2luZ2xlUmVzLnJhbmdlLCBzaW5nbGVSZXMuZm9yY2VkU3RhcnRUem8sIHNpbmdsZVJlcy5mb3JjZWRFbmRUem8pO1xyXG4gICAgICAgICAgICBpZiAoaW5zdGFuY2VJZE1hcCAmJiBkZWYucHVibGljSWQgJiYgaW5zdGFuY2VJZE1hcFtkZWYucHVibGljSWRdKSB7XHJcbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5pbnN0YW5jZUlkID0gaW5zdGFuY2VJZE1hcFtkZWYucHVibGljSWRdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB7IGRlZiwgaW5zdGFuY2UgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiByZWZpbmVFdmVudERlZihyYXcsIGNvbnRleHQsIHJlZmluZXJzID0gYnVpbGRFdmVudFJlZmluZXJzKGNvbnRleHQpKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlZmluZVByb3BzKHJhdywgcmVmaW5lcnMpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYnVpbGRFdmVudFJlZmluZXJzKGNvbnRleHQpIHtcclxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIEVWRU5UX1VJX1JFRklORVJTKSwgRVZFTlRfUkVGSU5FUlMpLCBjb250ZXh0LnBsdWdpbkhvb2tzLmV2ZW50UmVmaW5lcnMpO1xyXG4gICAgfVxyXG4gICAgLypcclxuICAgIFdpbGwgTk9UIHBvcHVsYXRlIGV4dGVuZGVkUHJvcHMgd2l0aCB0aGUgbGVmdG92ZXIgcHJvcGVydGllcy5cclxuICAgIFdpbGwgTk9UIHBvcHVsYXRlIGRhdGUtcmVsYXRlZCBwcm9wcy5cclxuICAgICovXHJcbiAgICBmdW5jdGlvbiBwYXJzZUV2ZW50RGVmKHJlZmluZWQsIGV4dHJhLCBzb3VyY2VJZCwgYWxsRGF5LCBoYXNFbmQsIGNvbnRleHQsIGRlZklkTWFwKSB7XHJcbiAgICAgICAgbGV0IGRlZiA9IHtcclxuICAgICAgICAgICAgdGl0bGU6IHJlZmluZWQudGl0bGUgfHwgJycsXHJcbiAgICAgICAgICAgIGdyb3VwSWQ6IHJlZmluZWQuZ3JvdXBJZCB8fCAnJyxcclxuICAgICAgICAgICAgcHVibGljSWQ6IHJlZmluZWQuaWQgfHwgJycsXHJcbiAgICAgICAgICAgIHVybDogcmVmaW5lZC51cmwgfHwgJycsXHJcbiAgICAgICAgICAgIHJlY3VycmluZ0RlZjogbnVsbCxcclxuICAgICAgICAgICAgZGVmSWQ6ICgoZGVmSWRNYXAgJiYgcmVmaW5lZC5pZCkgPyBkZWZJZE1hcFtyZWZpbmVkLmlkXSA6ICcnKSB8fCBndWlkKCksXHJcbiAgICAgICAgICAgIHNvdXJjZUlkLFxyXG4gICAgICAgICAgICBhbGxEYXksXHJcbiAgICAgICAgICAgIGhhc0VuZCxcclxuICAgICAgICAgICAgaW50ZXJhY3RpdmU6IHJlZmluZWQuaW50ZXJhY3RpdmUsXHJcbiAgICAgICAgICAgIHVpOiBjcmVhdGVFdmVudFVpKHJlZmluZWQsIGNvbnRleHQpLFxyXG4gICAgICAgICAgICBleHRlbmRlZFByb3BzOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIChyZWZpbmVkLmV4dGVuZGVkUHJvcHMgfHwge30pKSwgZXh0cmEpLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgZm9yIChsZXQgbWVtYmVyQWRkZXIgb2YgY29udGV4dC5wbHVnaW5Ib29rcy5ldmVudERlZk1lbWJlckFkZGVycykge1xyXG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKGRlZiwgbWVtYmVyQWRkZXIocmVmaW5lZCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBoZWxwIG91dCBFdmVudEltcGwgZnJvbSBoYXZpbmcgdXNlciBtb2RpZnkgcHJvcHNcclxuICAgICAgICBPYmplY3QuZnJlZXplKGRlZi51aS5jbGFzc05hbWVzKTtcclxuICAgICAgICBPYmplY3QuZnJlZXplKGRlZi5leHRlbmRlZFByb3BzKTtcclxuICAgICAgICByZXR1cm4gZGVmO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gcGFyc2VTaW5nbGUocmVmaW5lZCwgZGVmYXVsdEFsbERheSwgY29udGV4dCwgYWxsb3dPcGVuUmFuZ2UpIHtcclxuICAgICAgICBsZXQgeyBhbGxEYXkgfSA9IHJlZmluZWQ7XHJcbiAgICAgICAgbGV0IHN0YXJ0TWV0YTtcclxuICAgICAgICBsZXQgc3RhcnRNYXJrZXIgPSBudWxsO1xyXG4gICAgICAgIGxldCBoYXNFbmQgPSBmYWxzZTtcclxuICAgICAgICBsZXQgZW5kTWV0YTtcclxuICAgICAgICBsZXQgZW5kTWFya2VyID0gbnVsbDtcclxuICAgICAgICBsZXQgc3RhcnRJbnB1dCA9IHJlZmluZWQuc3RhcnQgIT0gbnVsbCA/IHJlZmluZWQuc3RhcnQgOiByZWZpbmVkLmRhdGU7XHJcbiAgICAgICAgc3RhcnRNZXRhID0gY29udGV4dC5kYXRlRW52LmNyZWF0ZU1hcmtlck1ldGEoc3RhcnRJbnB1dCk7XHJcbiAgICAgICAgaWYgKHN0YXJ0TWV0YSkge1xyXG4gICAgICAgICAgICBzdGFydE1hcmtlciA9IHN0YXJ0TWV0YS5tYXJrZXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKCFhbGxvd09wZW5SYW5nZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJlZmluZWQuZW5kICE9IG51bGwpIHtcclxuICAgICAgICAgICAgZW5kTWV0YSA9IGNvbnRleHQuZGF0ZUVudi5jcmVhdGVNYXJrZXJNZXRhKHJlZmluZWQuZW5kKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGFsbERheSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGlmIChkZWZhdWx0QWxsRGF5ICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGFsbERheSA9IGRlZmF1bHRBbGxEYXk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBmYWxsIGJhY2sgdG8gdGhlIGRhdGUgcHJvcHMgTEFTVFxyXG4gICAgICAgICAgICAgICAgYWxsRGF5ID0gKCFzdGFydE1ldGEgfHwgc3RhcnRNZXRhLmlzVGltZVVuc3BlY2lmaWVkKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICghZW5kTWV0YSB8fCBlbmRNZXRhLmlzVGltZVVuc3BlY2lmaWVkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYWxsRGF5ICYmIHN0YXJ0TWFya2VyKSB7XHJcbiAgICAgICAgICAgIHN0YXJ0TWFya2VyID0gc3RhcnRPZkRheShzdGFydE1hcmtlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChlbmRNZXRhKSB7XHJcbiAgICAgICAgICAgIGVuZE1hcmtlciA9IGVuZE1ldGEubWFya2VyO1xyXG4gICAgICAgICAgICBpZiAoYWxsRGF5KSB7XHJcbiAgICAgICAgICAgICAgICBlbmRNYXJrZXIgPSBzdGFydE9mRGF5KGVuZE1hcmtlcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHN0YXJ0TWFya2VyICYmIGVuZE1hcmtlciA8PSBzdGFydE1hcmtlcikge1xyXG4gICAgICAgICAgICAgICAgZW5kTWFya2VyID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZW5kTWFya2VyKSB7XHJcbiAgICAgICAgICAgIGhhc0VuZCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKCFhbGxvd09wZW5SYW5nZSkge1xyXG4gICAgICAgICAgICBoYXNFbmQgPSBjb250ZXh0Lm9wdGlvbnMuZm9yY2VFdmVudER1cmF0aW9uIHx8IGZhbHNlO1xyXG4gICAgICAgICAgICBlbmRNYXJrZXIgPSBjb250ZXh0LmRhdGVFbnYuYWRkKHN0YXJ0TWFya2VyLCBhbGxEYXkgP1xyXG4gICAgICAgICAgICAgICAgY29udGV4dC5vcHRpb25zLmRlZmF1bHRBbGxEYXlFdmVudER1cmF0aW9uIDpcclxuICAgICAgICAgICAgICAgIGNvbnRleHQub3B0aW9ucy5kZWZhdWx0VGltZWRFdmVudER1cmF0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgYWxsRGF5LFxyXG4gICAgICAgICAgICBoYXNFbmQsXHJcbiAgICAgICAgICAgIHJhbmdlOiB7IHN0YXJ0OiBzdGFydE1hcmtlciwgZW5kOiBlbmRNYXJrZXIgfSxcclxuICAgICAgICAgICAgZm9yY2VkU3RhcnRUem86IHN0YXJ0TWV0YSA/IHN0YXJ0TWV0YS5mb3JjZWRUem8gOiBudWxsLFxyXG4gICAgICAgICAgICBmb3JjZWRFbmRUem86IGVuZE1ldGEgPyBlbmRNZXRhLmZvcmNlZFR6byA6IG51bGwsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGNvbXB1dGVJc0RlZmF1bHRBbGxEYXkoZXZlbnRTb3VyY2UsIGNvbnRleHQpIHtcclxuICAgICAgICBsZXQgcmVzID0gbnVsbDtcclxuICAgICAgICBpZiAoZXZlbnRTb3VyY2UpIHtcclxuICAgICAgICAgICAgcmVzID0gZXZlbnRTb3VyY2UuZGVmYXVsdEFsbERheTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJlcyA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJlcyA9IGNvbnRleHQub3B0aW9ucy5kZWZhdWx0QWxsRGF5O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IERFRl9ERUZBVUxUUyA9IHtcclxuICAgICAgICBzdGFydFRpbWU6ICcwOTowMCcsXHJcbiAgICAgICAgZW5kVGltZTogJzE3OjAwJyxcclxuICAgICAgICBkYXlzT2ZXZWVrOiBbMSwgMiwgMywgNCwgNV0sXHJcbiAgICAgICAgZGlzcGxheTogJ2ludmVyc2UtYmFja2dyb3VuZCcsXHJcbiAgICAgICAgY2xhc3NOYW1lczogJ2ZjLW5vbi1idXNpbmVzcycsXHJcbiAgICAgICAgZ3JvdXBJZDogJ19idXNpbmVzc0hvdXJzJywgLy8gc28gbXVsdGlwbGUgZGVmcyBnZXQgZ3JvdXBlZFxyXG4gICAgfTtcclxuICAgIC8qXHJcbiAgICBUT0RPOiBwYXNzIGFyb3VuZCBhcyBFdmVudERlZkhhc2ghISFcclxuICAgICovXHJcbiAgICBmdW5jdGlvbiBwYXJzZUJ1c2luZXNzSG91cnMoaW5wdXQsIGNvbnRleHQpIHtcclxuICAgICAgICByZXR1cm4gcGFyc2VFdmVudHMocmVmaW5lSW5wdXRzKGlucHV0KSwgbnVsbCwgY29udGV4dCk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiByZWZpbmVJbnB1dHMoaW5wdXQpIHtcclxuICAgICAgICBsZXQgcmF3RGVmcztcclxuICAgICAgICBpZiAoaW5wdXQgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgcmF3RGVmcyA9IFt7fV07IC8vIHdpbGwgZ2V0IERFRl9ERUZBVUxUUyB2ZXJiYXRpbVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGlucHV0KSkge1xyXG4gICAgICAgICAgICAvLyBpZiBzcGVjaWZ5aW5nIGFuIGFycmF5LCBldmVyeSBzdWItZGVmaW5pdGlvbiBORUVEUyBhIGRheS1vZi13ZWVrXHJcbiAgICAgICAgICAgIHJhd0RlZnMgPSBpbnB1dC5maWx0ZXIoKHJhd0RlZikgPT4gcmF3RGVmLmRheXNPZldlZWspO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09ICdvYmplY3QnICYmIGlucHV0KSB7IC8vIG5vbi1udWxsIG9iamVjdFxyXG4gICAgICAgICAgICByYXdEZWZzID0gW2lucHV0XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7IC8vIGlzIHByb2JhYmx5IGZhbHNlXHJcbiAgICAgICAgICAgIHJhd0RlZnMgPSBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmF3RGVmcyA9IHJhd0RlZnMubWFwKChyYXdEZWYpID0+IChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIERFRl9ERUZBVUxUUyksIHJhd0RlZikpKTtcclxuICAgICAgICByZXR1cm4gcmF3RGVmcztcclxuICAgIH1cclxuXHJcbiAgICAvKiBEYXRlIHN0dWZmIHRoYXQgZG9lc24ndCBiZWxvbmcgaW4gZGF0ZWxpYiBjb3JlXHJcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgIC8vIGdpdmVuIGEgdGltZWQgcmFuZ2UsIGNvbXB1dGVzIGFuIGFsbC1kYXkgcmFuZ2UgdGhhdCBoYXMgdGhlIHNhbWUgZXhhY3QgZHVyYXRpb24sXHJcbiAgICAvLyBidXQgd2hvc2Ugc3RhcnQgdGltZSBpcyBhbGlnbmVkIHdpdGggdGhlIHN0YXJ0IG9mIHRoZSBkYXkuXHJcbiAgICBmdW5jdGlvbiBjb21wdXRlQWxpZ25lZERheVJhbmdlKHRpbWVkUmFuZ2UpIHtcclxuICAgICAgICBsZXQgZGF5Q250ID0gTWF0aC5mbG9vcihkaWZmRGF5cyh0aW1lZFJhbmdlLnN0YXJ0LCB0aW1lZFJhbmdlLmVuZCkpIHx8IDE7XHJcbiAgICAgICAgbGV0IHN0YXJ0ID0gc3RhcnRPZkRheSh0aW1lZFJhbmdlLnN0YXJ0KTtcclxuICAgICAgICBsZXQgZW5kID0gYWRkRGF5cyhzdGFydCwgZGF5Q250KTtcclxuICAgICAgICByZXR1cm4geyBzdGFydCwgZW5kIH07XHJcbiAgICB9XHJcbiAgICAvLyBnaXZlbiBhIHRpbWVkIHJhbmdlLCBjb21wdXRlcyBhbiBhbGwtZGF5IHJhbmdlIGJhc2VkIG9uIGhvdyBmb3IgdGhlIGVuZCBkYXRlIGJsZWVkcyBpbnRvIHRoZSBuZXh0IGRheVxyXG4gICAgLy8gVE9ETzogZ2l2ZSBuZXh0RGF5VGhyZXNob2xkIGEgZGVmYXVsdCBhcmdcclxuICAgIGZ1bmN0aW9uIGNvbXB1dGVWaXNpYmxlRGF5UmFuZ2UodGltZWRSYW5nZSwgbmV4dERheVRocmVzaG9sZCA9IGNyZWF0ZUR1cmF0aW9uKDApKSB7XHJcbiAgICAgICAgbGV0IHN0YXJ0RGF5ID0gbnVsbDtcclxuICAgICAgICBsZXQgZW5kRGF5ID0gbnVsbDtcclxuICAgICAgICBpZiAodGltZWRSYW5nZS5lbmQpIHtcclxuICAgICAgICAgICAgZW5kRGF5ID0gc3RhcnRPZkRheSh0aW1lZFJhbmdlLmVuZCk7XHJcbiAgICAgICAgICAgIGxldCBlbmRUaW1lTVMgPSB0aW1lZFJhbmdlLmVuZC52YWx1ZU9mKCkgLSBlbmREYXkudmFsdWVPZigpOyAvLyAjIG9mIG1pbGxpc2Vjb25kcyBpbnRvIGBlbmREYXlgXHJcbiAgICAgICAgICAgIC8vIElmIHRoZSBlbmQgdGltZSBpcyBhY3R1YWxseSBpbmNsdXNpdmVseSBwYXJ0IG9mIHRoZSBuZXh0IGRheSBhbmQgaXMgZXF1YWwgdG8gb3JcclxuICAgICAgICAgICAgLy8gYmV5b25kIHRoZSBuZXh0IGRheSB0aHJlc2hvbGQsIGFkanVzdCB0aGUgZW5kIHRvIGJlIHRoZSBleGNsdXNpdmUgZW5kIG9mIGBlbmREYXlgLlxyXG4gICAgICAgICAgICAvLyBPdGhlcndpc2UsIGxlYXZpbmcgaXQgYXMgaW5jbHVzaXZlIHdpbGwgY2F1c2UgaXQgdG8gZXhjbHVkZSBgZW5kRGF5YC5cclxuICAgICAgICAgICAgaWYgKGVuZFRpbWVNUyAmJiBlbmRUaW1lTVMgPj0gYXNSb3VnaE1zKG5leHREYXlUaHJlc2hvbGQpKSB7XHJcbiAgICAgICAgICAgICAgICBlbmREYXkgPSBhZGREYXlzKGVuZERheSwgMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRpbWVkUmFuZ2Uuc3RhcnQpIHtcclxuICAgICAgICAgICAgc3RhcnREYXkgPSBzdGFydE9mRGF5KHRpbWVkUmFuZ2Uuc3RhcnQpOyAvLyB0aGUgYmVnaW5uaW5nIG9mIHRoZSBkYXkgdGhlIHJhbmdlIHN0YXJ0c1xyXG4gICAgICAgICAgICAvLyBJZiBlbmQgaXMgd2l0aGluIGBzdGFydERheWAgYnV0IG5vdCBwYXN0IG5leHREYXlUaHJlc2hvbGQsIGFzc2lnbiB0aGUgZGVmYXVsdCBkdXJhdGlvbiBvZiBvbmUgZGF5LlxyXG4gICAgICAgICAgICBpZiAoZW5kRGF5ICYmIGVuZERheSA8PSBzdGFydERheSkge1xyXG4gICAgICAgICAgICAgICAgZW5kRGF5ID0gYWRkRGF5cyhzdGFydERheSwgMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHsgc3RhcnQ6IHN0YXJ0RGF5LCBlbmQ6IGVuZERheSB9O1xyXG4gICAgfVxyXG4gICAgLy8gc3BhbnMgZnJvbSBvbmUgZGF5IGludG8gYW5vdGhlcj9cclxuICAgIGZ1bmN0aW9uIGlzTXVsdGlEYXlSYW5nZShyYW5nZSkge1xyXG4gICAgICAgIGxldCB2aXNpYmxlUmFuZ2UgPSBjb21wdXRlVmlzaWJsZURheVJhbmdlKHJhbmdlKTtcclxuICAgICAgICByZXR1cm4gZGlmZkRheXModmlzaWJsZVJhbmdlLnN0YXJ0LCB2aXNpYmxlUmFuZ2UuZW5kKSA+IDE7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBkaWZmRGF0ZXMoZGF0ZTAsIGRhdGUxLCBkYXRlRW52LCBsYXJnZVVuaXQpIHtcclxuICAgICAgICBpZiAobGFyZ2VVbml0ID09PSAneWVhcicpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUR1cmF0aW9uKGRhdGVFbnYuZGlmZldob2xlWWVhcnMoZGF0ZTAsIGRhdGUxKSwgJ3llYXInKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxhcmdlVW5pdCA9PT0gJ21vbnRoJykge1xyXG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlRHVyYXRpb24oZGF0ZUVudi5kaWZmV2hvbGVNb250aHMoZGF0ZTAsIGRhdGUxKSwgJ21vbnRoJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkaWZmRGF5QW5kVGltZShkYXRlMCwgZGF0ZTEpOyAvLyByZXR1cm5zIGEgZHVyYXRpb25cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBwb2ludEluc2lkZVJlY3QocG9pbnQsIHJlY3QpIHtcclxuICAgICAgICByZXR1cm4gcG9pbnQubGVmdCA+PSByZWN0LmxlZnQgJiZcclxuICAgICAgICAgICAgcG9pbnQubGVmdCA8IHJlY3QucmlnaHQgJiZcclxuICAgICAgICAgICAgcG9pbnQudG9wID49IHJlY3QudG9wICYmXHJcbiAgICAgICAgICAgIHBvaW50LnRvcCA8IHJlY3QuYm90dG9tO1xyXG4gICAgfVxyXG4gICAgLy8gUmV0dXJucyBhIG5ldyByZWN0YW5nbGUgdGhhdCBpcyB0aGUgaW50ZXJzZWN0aW9uIG9mIHRoZSB0d28gcmVjdGFuZ2xlcy4gSWYgdGhleSBkb24ndCBpbnRlcnNlY3QsIHJldHVybnMgZmFsc2VcclxuICAgIGZ1bmN0aW9uIGludGVyc2VjdFJlY3RzKHJlY3QxLCByZWN0Mikge1xyXG4gICAgICAgIGxldCByZXMgPSB7XHJcbiAgICAgICAgICAgIGxlZnQ6IE1hdGgubWF4KHJlY3QxLmxlZnQsIHJlY3QyLmxlZnQpLFxyXG4gICAgICAgICAgICByaWdodDogTWF0aC5taW4ocmVjdDEucmlnaHQsIHJlY3QyLnJpZ2h0KSxcclxuICAgICAgICAgICAgdG9wOiBNYXRoLm1heChyZWN0MS50b3AsIHJlY3QyLnRvcCksXHJcbiAgICAgICAgICAgIGJvdHRvbTogTWF0aC5taW4ocmVjdDEuYm90dG9tLCByZWN0Mi5ib3R0b20pLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKHJlcy5sZWZ0IDwgcmVzLnJpZ2h0ICYmIHJlcy50b3AgPCByZXMuYm90dG9tKSB7XHJcbiAgICAgICAgICAgIHJldHVybiByZXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHRyYW5zbGF0ZVJlY3QocmVjdCwgZGVsdGFYLCBkZWx0YVkpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBsZWZ0OiByZWN0LmxlZnQgKyBkZWx0YVgsXHJcbiAgICAgICAgICAgIHJpZ2h0OiByZWN0LnJpZ2h0ICsgZGVsdGFYLFxyXG4gICAgICAgICAgICB0b3A6IHJlY3QudG9wICsgZGVsdGFZLFxyXG4gICAgICAgICAgICBib3R0b206IHJlY3QuYm90dG9tICsgZGVsdGFZLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICAvLyBSZXR1cm5zIGEgbmV3IHBvaW50IHRoYXQgd2lsbCBoYXZlIGJlZW4gbW92ZWQgdG8gcmVzaWRlIHdpdGhpbiB0aGUgZ2l2ZW4gcmVjdGFuZ2xlXHJcbiAgICBmdW5jdGlvbiBjb25zdHJhaW5Qb2ludChwb2ludCwgcmVjdCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGxlZnQ6IE1hdGgubWluKE1hdGgubWF4KHBvaW50LmxlZnQsIHJlY3QubGVmdCksIHJlY3QucmlnaHQpLFxyXG4gICAgICAgICAgICB0b3A6IE1hdGgubWluKE1hdGgubWF4KHBvaW50LnRvcCwgcmVjdC50b3ApLCByZWN0LmJvdHRvbSksXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIC8vIFJldHVybnMgYSBwb2ludCB0aGF0IGlzIHRoZSBjZW50ZXIgb2YgdGhlIGdpdmVuIHJlY3RhbmdsZVxyXG4gICAgZnVuY3Rpb24gZ2V0UmVjdENlbnRlcihyZWN0KSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgbGVmdDogKHJlY3QubGVmdCArIHJlY3QucmlnaHQpIC8gMixcclxuICAgICAgICAgICAgdG9wOiAocmVjdC50b3AgKyByZWN0LmJvdHRvbSkgLyAyLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICAvLyBTdWJ0cmFjdHMgcG9pbnQyJ3MgY29vcmRpbmF0ZXMgZnJvbSBwb2ludDEncyBjb29yZGluYXRlcywgcmV0dXJuaW5nIGEgZGVsdGFcclxuICAgIGZ1bmN0aW9uIGRpZmZQb2ludHMocG9pbnQxLCBwb2ludDIpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBsZWZ0OiBwb2ludDEubGVmdCAtIHBvaW50Mi5sZWZ0LFxyXG4gICAgICAgICAgICB0b3A6IHBvaW50MS50b3AgLSBwb2ludDIudG9wLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IGNhblZHcm93V2l0aGluQ2VsbDtcclxuICAgIGZ1bmN0aW9uIGdldENhblZHcm93V2l0aGluQ2VsbCgpIHtcclxuICAgICAgICBpZiAoY2FuVkdyb3dXaXRoaW5DZWxsID09IG51bGwpIHtcclxuICAgICAgICAgICAgY2FuVkdyb3dXaXRoaW5DZWxsID0gY29tcHV0ZUNhblZHcm93V2l0aGluQ2VsbCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY2FuVkdyb3dXaXRoaW5DZWxsO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gY29tcHV0ZUNhblZHcm93V2l0aGluQ2VsbCgpIHtcclxuICAgICAgICAvLyBmb3IgU1NSLCBiZWNhdXNlIHRoaXMgZnVuY3Rpb24gaXMgY2FsbCBpbW1lZGlhdGVseSBhdCB0b3AtbGV2ZWxcclxuICAgICAgICAvLyBUT0RPOiBqdXN0IG1ha2UgdGhpcyBsb2dpYyBleGVjdXRlIHRvcC1sZXZlbCwgaW1tZWRpYXRlbHksIGluc3RlYWQgb2YgZG9pbmcgbGF6aWx5XHJcbiAgICAgICAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgICAgIGVsLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcclxuICAgICAgICBlbC5zdHlsZS50b3AgPSAnMHB4JztcclxuICAgICAgICBlbC5zdHlsZS5sZWZ0ID0gJzBweCc7XHJcbiAgICAgICAgZWwuaW5uZXJIVE1MID0gJzx0YWJsZT48dHI+PHRkPjxkaXY+PC9kaXY+PC90ZD48L3RyPjwvdGFibGU+JztcclxuICAgICAgICBlbC5xdWVyeVNlbGVjdG9yKCd0YWJsZScpLnN0eWxlLmhlaWdodCA9ICcxMDBweCc7XHJcbiAgICAgICAgZWwucXVlcnlTZWxlY3RvcignZGl2Jykuc3R5bGUuaGVpZ2h0ID0gJzEwMCUnO1xyXG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZWwpO1xyXG4gICAgICAgIGxldCBkaXYgPSBlbC5xdWVyeVNlbGVjdG9yKCdkaXYnKTtcclxuICAgICAgICBsZXQgcG9zc2libGUgPSBkaXYub2Zmc2V0SGVpZ2h0ID4gMDtcclxuICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGVsKTtcclxuICAgICAgICByZXR1cm4gcG9zc2libGU7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgRU1QVFlfRVZFTlRfU1RPUkUgPSBjcmVhdGVFbXB0eUV2ZW50U3RvcmUoKTsgLy8gZm9yIHB1cmVjb21wb25lbnRzLiBUT0RPOiBrZWVwIGVsc2V3aGVyZVxyXG4gICAgY2xhc3MgU3BsaXR0ZXIge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgICAgICB0aGlzLmdldEtleXNGb3JFdmVudERlZnMgPSBtZW1vaXplKHRoaXMuX2dldEtleXNGb3JFdmVudERlZnMpO1xyXG4gICAgICAgICAgICB0aGlzLnNwbGl0RGF0ZVNlbGVjdGlvbiA9IG1lbW9pemUodGhpcy5fc3BsaXREYXRlU3Bhbik7XHJcbiAgICAgICAgICAgIHRoaXMuc3BsaXRFdmVudFN0b3JlID0gbWVtb2l6ZSh0aGlzLl9zcGxpdEV2ZW50U3RvcmUpO1xyXG4gICAgICAgICAgICB0aGlzLnNwbGl0SW5kaXZpZHVhbFVpID0gbWVtb2l6ZSh0aGlzLl9zcGxpdEluZGl2aWR1YWxVaSk7XHJcbiAgICAgICAgICAgIHRoaXMuc3BsaXRFdmVudERyYWcgPSBtZW1vaXplKHRoaXMuX3NwbGl0SW50ZXJhY3Rpb24pO1xyXG4gICAgICAgICAgICB0aGlzLnNwbGl0RXZlbnRSZXNpemUgPSBtZW1vaXplKHRoaXMuX3NwbGl0SW50ZXJhY3Rpb24pO1xyXG4gICAgICAgICAgICB0aGlzLmV2ZW50VWlCdWlsZGVycyA9IHt9OyAvLyBUT0RPOiB0eXBlc2NyaXB0IHByb3RlY3Rpb25cclxuICAgICAgICB9XHJcbiAgICAgICAgc3BsaXRQcm9wcyhwcm9wcykge1xyXG4gICAgICAgICAgICBsZXQga2V5SW5mb3MgPSB0aGlzLmdldEtleUluZm8ocHJvcHMpO1xyXG4gICAgICAgICAgICBsZXQgZGVmS2V5cyA9IHRoaXMuZ2V0S2V5c0ZvckV2ZW50RGVmcyhwcm9wcy5ldmVudFN0b3JlKTtcclxuICAgICAgICAgICAgbGV0IGRhdGVTZWxlY3Rpb25zID0gdGhpcy5zcGxpdERhdGVTZWxlY3Rpb24ocHJvcHMuZGF0ZVNlbGVjdGlvbik7XHJcbiAgICAgICAgICAgIGxldCBpbmRpdmlkdWFsVWkgPSB0aGlzLnNwbGl0SW5kaXZpZHVhbFVpKHByb3BzLmV2ZW50VWlCYXNlcywgZGVmS2V5cyk7IC8vIHRoZSBpbmRpdmlkdWFsICpiYXNlcypcclxuICAgICAgICAgICAgbGV0IGV2ZW50U3RvcmVzID0gdGhpcy5zcGxpdEV2ZW50U3RvcmUocHJvcHMuZXZlbnRTdG9yZSwgZGVmS2V5cyk7XHJcbiAgICAgICAgICAgIGxldCBldmVudERyYWdzID0gdGhpcy5zcGxpdEV2ZW50RHJhZyhwcm9wcy5ldmVudERyYWcpO1xyXG4gICAgICAgICAgICBsZXQgZXZlbnRSZXNpemVzID0gdGhpcy5zcGxpdEV2ZW50UmVzaXplKHByb3BzLmV2ZW50UmVzaXplKTtcclxuICAgICAgICAgICAgbGV0IHNwbGl0UHJvcHMgPSB7fTtcclxuICAgICAgICAgICAgdGhpcy5ldmVudFVpQnVpbGRlcnMgPSBtYXBIYXNoKGtleUluZm9zLCAoaW5mbywga2V5KSA9PiB0aGlzLmV2ZW50VWlCdWlsZGVyc1trZXldIHx8IG1lbW9pemUoYnVpbGRFdmVudFVpRm9yS2V5KSk7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGtleSBpbiBrZXlJbmZvcykge1xyXG4gICAgICAgICAgICAgICAgbGV0IGtleUluZm8gPSBrZXlJbmZvc1trZXldO1xyXG4gICAgICAgICAgICAgICAgbGV0IGV2ZW50U3RvcmUgPSBldmVudFN0b3Jlc1trZXldIHx8IEVNUFRZX0VWRU5UX1NUT1JFO1xyXG4gICAgICAgICAgICAgICAgbGV0IGJ1aWxkRXZlbnRVaSA9IHRoaXMuZXZlbnRVaUJ1aWxkZXJzW2tleV07XHJcbiAgICAgICAgICAgICAgICBzcGxpdFByb3BzW2tleV0gPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnVzaW5lc3NIb3Vyczoga2V5SW5mby5idXNpbmVzc0hvdXJzIHx8IHByb3BzLmJ1c2luZXNzSG91cnMsXHJcbiAgICAgICAgICAgICAgICAgICAgZGF0ZVNlbGVjdGlvbjogZGF0ZVNlbGVjdGlvbnNba2V5XSB8fCBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50U3RvcmUsXHJcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRVaUJhc2VzOiBidWlsZEV2ZW50VWkocHJvcHMuZXZlbnRVaUJhc2VzWycnXSwga2V5SW5mby51aSwgaW5kaXZpZHVhbFVpW2tleV0pLFxyXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50U2VsZWN0aW9uOiBldmVudFN0b3JlLmluc3RhbmNlc1twcm9wcy5ldmVudFNlbGVjdGlvbl0gPyBwcm9wcy5ldmVudFNlbGVjdGlvbiA6ICcnLFxyXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50RHJhZzogZXZlbnREcmFnc1trZXldIHx8IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRSZXNpemU6IGV2ZW50UmVzaXplc1trZXldIHx8IG51bGwsXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBzcGxpdFByb3BzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBfc3BsaXREYXRlU3BhbihkYXRlU3Bhbikge1xyXG4gICAgICAgICAgICBsZXQgZGF0ZVNwYW5zID0ge307XHJcbiAgICAgICAgICAgIGlmIChkYXRlU3Bhbikge1xyXG4gICAgICAgICAgICAgICAgbGV0IGtleXMgPSB0aGlzLmdldEtleXNGb3JEYXRlU3BhbihkYXRlU3Bhbik7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBrZXkgb2Yga2V5cykge1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGVTcGFuc1trZXldID0gZGF0ZVNwYW47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGRhdGVTcGFucztcclxuICAgICAgICB9XHJcbiAgICAgICAgX2dldEtleXNGb3JFdmVudERlZnMoZXZlbnRTdG9yZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbWFwSGFzaChldmVudFN0b3JlLmRlZnMsIChldmVudERlZikgPT4gdGhpcy5nZXRLZXlzRm9yRXZlbnREZWYoZXZlbnREZWYpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgX3NwbGl0RXZlbnRTdG9yZShldmVudFN0b3JlLCBkZWZLZXlzKSB7XHJcbiAgICAgICAgICAgIGxldCB7IGRlZnMsIGluc3RhbmNlcyB9ID0gZXZlbnRTdG9yZTtcclxuICAgICAgICAgICAgbGV0IHNwbGl0U3RvcmVzID0ge307XHJcbiAgICAgICAgICAgIGZvciAobGV0IGRlZklkIGluIGRlZnMpIHtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGtleSBvZiBkZWZLZXlzW2RlZklkXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghc3BsaXRTdG9yZXNba2V5XSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzcGxpdFN0b3Jlc1trZXldID0gY3JlYXRlRW1wdHlFdmVudFN0b3JlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHNwbGl0U3RvcmVzW2tleV0uZGVmc1tkZWZJZF0gPSBkZWZzW2RlZklkXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKGxldCBpbnN0YW5jZUlkIGluIGluc3RhbmNlcykge1xyXG4gICAgICAgICAgICAgICAgbGV0IGluc3RhbmNlID0gaW5zdGFuY2VzW2luc3RhbmNlSWRdO1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQga2V5IG9mIGRlZktleXNbaW5zdGFuY2UuZGVmSWRdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNwbGl0U3RvcmVzW2tleV0pIHsgLy8gbXVzdCBoYXZlIGFscmVhZHkgYmVlbiBjcmVhdGVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwbGl0U3RvcmVzW2tleV0uaW5zdGFuY2VzW2luc3RhbmNlSWRdID0gaW5zdGFuY2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBzcGxpdFN0b3JlcztcclxuICAgICAgICB9XHJcbiAgICAgICAgX3NwbGl0SW5kaXZpZHVhbFVpKGV2ZW50VWlCYXNlcywgZGVmS2V5cykge1xyXG4gICAgICAgICAgICBsZXQgc3BsaXRIYXNoZXMgPSB7fTtcclxuICAgICAgICAgICAgZm9yIChsZXQgZGVmSWQgaW4gZXZlbnRVaUJhc2VzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGVmSWQpIHsgLy8gbm90IHRoZSAnJyBrZXlcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBrZXkgb2YgZGVmS2V5c1tkZWZJZF0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzcGxpdEhhc2hlc1trZXldKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcGxpdEhhc2hlc1trZXldID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgc3BsaXRIYXNoZXNba2V5XVtkZWZJZF0gPSBldmVudFVpQmFzZXNbZGVmSWRdO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gc3BsaXRIYXNoZXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9zcGxpdEludGVyYWN0aW9uKGludGVyYWN0aW9uKSB7XHJcbiAgICAgICAgICAgIGxldCBzcGxpdFN0YXRlcyA9IHt9O1xyXG4gICAgICAgICAgICBpZiAoaW50ZXJhY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgIGxldCBhZmZlY3RlZFN0b3JlcyA9IHRoaXMuX3NwbGl0RXZlbnRTdG9yZShpbnRlcmFjdGlvbi5hZmZlY3RlZEV2ZW50cywgdGhpcy5fZ2V0S2V5c0ZvckV2ZW50RGVmcyhpbnRlcmFjdGlvbi5hZmZlY3RlZEV2ZW50cykpO1xyXG4gICAgICAgICAgICAgICAgLy8gY2FuJ3QgcmVseSBvbiBkZWZLZXlzIGJlY2F1c2UgZXZlbnQgZGF0YSBpcyBtdXRhdGVkXHJcbiAgICAgICAgICAgICAgICBsZXQgbXV0YXRlZEtleXNCeURlZklkID0gdGhpcy5fZ2V0S2V5c0ZvckV2ZW50RGVmcyhpbnRlcmFjdGlvbi5tdXRhdGVkRXZlbnRzKTtcclxuICAgICAgICAgICAgICAgIGxldCBtdXRhdGVkU3RvcmVzID0gdGhpcy5fc3BsaXRFdmVudFN0b3JlKGludGVyYWN0aW9uLm11dGF0ZWRFdmVudHMsIG11dGF0ZWRLZXlzQnlEZWZJZCk7XHJcbiAgICAgICAgICAgICAgICBsZXQgcG9wdWxhdGUgPSAoa2V5KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzcGxpdFN0YXRlc1trZXldKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwbGl0U3RhdGVzW2tleV0gPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZmZlY3RlZEV2ZW50czogYWZmZWN0ZWRTdG9yZXNba2V5XSB8fCBFTVBUWV9FVkVOVF9TVE9SRSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG11dGF0ZWRFdmVudHM6IG11dGF0ZWRTdG9yZXNba2V5XSB8fCBFTVBUWV9FVkVOVF9TVE9SRSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzRXZlbnQ6IGludGVyYWN0aW9uLmlzRXZlbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGtleSBpbiBhZmZlY3RlZFN0b3Jlcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHBvcHVsYXRlKGtleSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBrZXkgaW4gbXV0YXRlZFN0b3Jlcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHBvcHVsYXRlKGtleSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHNwbGl0U3RhdGVzO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGJ1aWxkRXZlbnRVaUZvcktleShhbGxVaSwgZXZlbnRVaUZvcktleSwgaW5kaXZpZHVhbFVpKSB7XHJcbiAgICAgICAgbGV0IGJhc2VQYXJ0cyA9IFtdO1xyXG4gICAgICAgIGlmIChhbGxVaSkge1xyXG4gICAgICAgICAgICBiYXNlUGFydHMucHVzaChhbGxVaSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChldmVudFVpRm9yS2V5KSB7XHJcbiAgICAgICAgICAgIGJhc2VQYXJ0cy5wdXNoKGV2ZW50VWlGb3JLZXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgc3R1ZmYgPSB7XHJcbiAgICAgICAgICAgICcnOiBjb21iaW5lRXZlbnRVaXMoYmFzZVBhcnRzKSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmIChpbmRpdmlkdWFsVWkpIHtcclxuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihzdHVmZiwgaW5kaXZpZHVhbFVpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHN0dWZmO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHBhcnNlUmFuZ2UoaW5wdXQsIGRhdGVFbnYpIHtcclxuICAgICAgICBsZXQgc3RhcnQgPSBudWxsO1xyXG4gICAgICAgIGxldCBlbmQgPSBudWxsO1xyXG4gICAgICAgIGlmIChpbnB1dC5zdGFydCkge1xyXG4gICAgICAgICAgICBzdGFydCA9IGRhdGVFbnYuY3JlYXRlTWFya2VyKGlucHV0LnN0YXJ0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlucHV0LmVuZCkge1xyXG4gICAgICAgICAgICBlbmQgPSBkYXRlRW52LmNyZWF0ZU1hcmtlcihpbnB1dC5lbmQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXN0YXJ0ICYmICFlbmQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzdGFydCAmJiBlbmQgJiYgZW5kIDwgc3RhcnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7IHN0YXJ0LCBlbmQgfTtcclxuICAgIH1cclxuICAgIC8vIFNJREUtRUZGRUNUOiB3aWxsIG11dGF0ZSByYW5nZXMuXHJcbiAgICAvLyBXaWxsIHJldHVybiBhIG5ldyBhcnJheSByZXN1bHQuXHJcbiAgICBmdW5jdGlvbiBpbnZlcnRSYW5nZXMocmFuZ2VzLCBjb25zdHJhaW50UmFuZ2UpIHtcclxuICAgICAgICBsZXQgaW52ZXJ0ZWRSYW5nZXMgPSBbXTtcclxuICAgICAgICBsZXQgeyBzdGFydCB9ID0gY29uc3RyYWludFJhbmdlOyAvLyB0aGUgZW5kIG9mIHRoZSBwcmV2aW91cyByYW5nZS4gdGhlIHN0YXJ0IG9mIHRoZSBuZXcgcmFuZ2VcclxuICAgICAgICBsZXQgaTtcclxuICAgICAgICBsZXQgZGF0ZVJhbmdlO1xyXG4gICAgICAgIC8vIHJhbmdlcyBuZWVkIHRvIGJlIGluIG9yZGVyLiByZXF1aXJlZCBmb3Igb3VyIGRhdGUtd2Fsa2luZyBhbGdvcml0aG1cclxuICAgICAgICByYW5nZXMuc29ydChjb21wYXJlUmFuZ2VzKTtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSArPSAxKSB7XHJcbiAgICAgICAgICAgIGRhdGVSYW5nZSA9IHJhbmdlc1tpXTtcclxuICAgICAgICAgICAgLy8gYWRkIHRoZSBzcGFuIG9mIHRpbWUgYmVmb3JlIHRoZSBldmVudCAoaWYgdGhlcmUgaXMgYW55KVxyXG4gICAgICAgICAgICBpZiAoZGF0ZVJhbmdlLnN0YXJ0ID4gc3RhcnQpIHsgLy8gY29tcGFyZSBtaWxsaXNlY29uZCB0aW1lIChza2lwIGFueSBhbWJpZyBsb2dpYylcclxuICAgICAgICAgICAgICAgIGludmVydGVkUmFuZ2VzLnB1c2goeyBzdGFydCwgZW5kOiBkYXRlUmFuZ2Uuc3RhcnQgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGRhdGVSYW5nZS5lbmQgPiBzdGFydCkge1xyXG4gICAgICAgICAgICAgICAgc3RhcnQgPSBkYXRlUmFuZ2UuZW5kO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGFkZCB0aGUgc3BhbiBvZiB0aW1lIGFmdGVyIHRoZSBsYXN0IGV2ZW50IChpZiB0aGVyZSBpcyBhbnkpXHJcbiAgICAgICAgaWYgKHN0YXJ0IDwgY29uc3RyYWludFJhbmdlLmVuZCkgeyAvLyBjb21wYXJlIG1pbGxpc2Vjb25kIHRpbWUgKHNraXAgYW55IGFtYmlnIGxvZ2ljKVxyXG4gICAgICAgICAgICBpbnZlcnRlZFJhbmdlcy5wdXNoKHsgc3RhcnQsIGVuZDogY29uc3RyYWludFJhbmdlLmVuZCB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGludmVydGVkUmFuZ2VzO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gY29tcGFyZVJhbmdlcyhyYW5nZTAsIHJhbmdlMSkge1xyXG4gICAgICAgIHJldHVybiByYW5nZTAuc3RhcnQudmFsdWVPZigpIC0gcmFuZ2UxLnN0YXJ0LnZhbHVlT2YoKTsgLy8gZWFybGllciByYW5nZXMgZ28gZmlyc3RcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGludGVyc2VjdFJhbmdlcyhyYW5nZTAsIHJhbmdlMSkge1xyXG4gICAgICAgIGxldCB7IHN0YXJ0LCBlbmQgfSA9IHJhbmdlMDtcclxuICAgICAgICBsZXQgbmV3UmFuZ2UgPSBudWxsO1xyXG4gICAgICAgIGlmIChyYW5nZTEuc3RhcnQgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgaWYgKHN0YXJ0ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBzdGFydCA9IHJhbmdlMS5zdGFydDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHN0YXJ0ID0gbmV3IERhdGUoTWF0aC5tYXgoc3RhcnQudmFsdWVPZigpLCByYW5nZTEuc3RhcnQudmFsdWVPZigpKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJhbmdlMS5lbmQgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICBpZiAoZW5kID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBlbmQgPSByYW5nZTEuZW5kO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZW5kID0gbmV3IERhdGUoTWF0aC5taW4oZW5kLnZhbHVlT2YoKSwgcmFuZ2UxLmVuZC52YWx1ZU9mKCkpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc3RhcnQgPT09IG51bGwgfHwgZW5kID09PSBudWxsIHx8IHN0YXJ0IDwgZW5kKSB7XHJcbiAgICAgICAgICAgIG5ld1JhbmdlID0geyBzdGFydCwgZW5kIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXdSYW5nZTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHJhbmdlc0VxdWFsKHJhbmdlMCwgcmFuZ2UxKSB7XHJcbiAgICAgICAgcmV0dXJuIChyYW5nZTAuc3RhcnQgPT09IG51bGwgPyBudWxsIDogcmFuZ2UwLnN0YXJ0LnZhbHVlT2YoKSkgPT09IChyYW5nZTEuc3RhcnQgPT09IG51bGwgPyBudWxsIDogcmFuZ2UxLnN0YXJ0LnZhbHVlT2YoKSkgJiZcclxuICAgICAgICAgICAgKHJhbmdlMC5lbmQgPT09IG51bGwgPyBudWxsIDogcmFuZ2UwLmVuZC52YWx1ZU9mKCkpID09PSAocmFuZ2UxLmVuZCA9PT0gbnVsbCA/IG51bGwgOiByYW5nZTEuZW5kLnZhbHVlT2YoKSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiByYW5nZXNJbnRlcnNlY3QocmFuZ2UwLCByYW5nZTEpIHtcclxuICAgICAgICByZXR1cm4gKHJhbmdlMC5lbmQgPT09IG51bGwgfHwgcmFuZ2UxLnN0YXJ0ID09PSBudWxsIHx8IHJhbmdlMC5lbmQgPiByYW5nZTEuc3RhcnQpICYmXHJcbiAgICAgICAgICAgIChyYW5nZTAuc3RhcnQgPT09IG51bGwgfHwgcmFuZ2UxLmVuZCA9PT0gbnVsbCB8fCByYW5nZTAuc3RhcnQgPCByYW5nZTEuZW5kKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHJhbmdlQ29udGFpbnNSYW5nZShvdXRlclJhbmdlLCBpbm5lclJhbmdlKSB7XHJcbiAgICAgICAgcmV0dXJuIChvdXRlclJhbmdlLnN0YXJ0ID09PSBudWxsIHx8IChpbm5lclJhbmdlLnN0YXJ0ICE9PSBudWxsICYmIGlubmVyUmFuZ2Uuc3RhcnQgPj0gb3V0ZXJSYW5nZS5zdGFydCkpICYmXHJcbiAgICAgICAgICAgIChvdXRlclJhbmdlLmVuZCA9PT0gbnVsbCB8fCAoaW5uZXJSYW5nZS5lbmQgIT09IG51bGwgJiYgaW5uZXJSYW5nZS5lbmQgPD0gb3V0ZXJSYW5nZS5lbmQpKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHJhbmdlQ29udGFpbnNNYXJrZXIocmFuZ2UsIGRhdGUpIHtcclxuICAgICAgICByZXR1cm4gKHJhbmdlLnN0YXJ0ID09PSBudWxsIHx8IGRhdGUgPj0gcmFuZ2Uuc3RhcnQpICYmXHJcbiAgICAgICAgICAgIChyYW5nZS5lbmQgPT09IG51bGwgfHwgZGF0ZSA8IHJhbmdlLmVuZCk7XHJcbiAgICB9XHJcbiAgICAvLyBJZiB0aGUgZ2l2ZW4gZGF0ZSBpcyBub3Qgd2l0aGluIHRoZSBnaXZlbiByYW5nZSwgbW92ZSBpdCBpbnNpZGUuXHJcbiAgICAvLyAoSWYgaXQncyBwYXN0IHRoZSBlbmQsIG1ha2UgaXQgb25lIG1pbGxpc2Vjb25kIGJlZm9yZSB0aGUgZW5kKS5cclxuICAgIGZ1bmN0aW9uIGNvbnN0cmFpbk1hcmtlclRvUmFuZ2UoZGF0ZSwgcmFuZ2UpIHtcclxuICAgICAgICBpZiAocmFuZ2Uuc3RhcnQgIT0gbnVsbCAmJiBkYXRlIDwgcmFuZ2Uuc3RhcnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJhbmdlLnN0YXJ0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocmFuZ2UuZW5kICE9IG51bGwgJiYgZGF0ZSA+PSByYW5nZS5lbmQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHJhbmdlLmVuZC52YWx1ZU9mKCkgLSAxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGRhdGU7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0RGF0ZU1ldGEoZGF0ZSwgdG9kYXlSYW5nZSwgbm93RGF0ZSwgZGF0ZVByb2ZpbGUpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBkb3c6IGRhdGUuZ2V0VVRDRGF5KCksXHJcbiAgICAgICAgICAgIGlzRGlzYWJsZWQ6IEJvb2xlYW4oZGF0ZVByb2ZpbGUgJiYgIXJhbmdlQ29udGFpbnNNYXJrZXIoZGF0ZVByb2ZpbGUuYWN0aXZlUmFuZ2UsIGRhdGUpKSxcclxuICAgICAgICAgICAgaXNPdGhlcjogQm9vbGVhbihkYXRlUHJvZmlsZSAmJiAhcmFuZ2VDb250YWluc01hcmtlcihkYXRlUHJvZmlsZS5jdXJyZW50UmFuZ2UsIGRhdGUpKSxcclxuICAgICAgICAgICAgaXNUb2RheTogQm9vbGVhbih0b2RheVJhbmdlICYmIHJhbmdlQ29udGFpbnNNYXJrZXIodG9kYXlSYW5nZSwgZGF0ZSkpLFxyXG4gICAgICAgICAgICBpc1Bhc3Q6IEJvb2xlYW4obm93RGF0ZSA/IChkYXRlIDwgbm93RGF0ZSkgOiB0b2RheVJhbmdlID8gKGRhdGUgPCB0b2RheVJhbmdlLnN0YXJ0KSA6IGZhbHNlKSxcclxuICAgICAgICAgICAgaXNGdXR1cmU6IEJvb2xlYW4obm93RGF0ZSA/IChkYXRlID4gbm93RGF0ZSkgOiB0b2RheVJhbmdlID8gKGRhdGUgPj0gdG9kYXlSYW5nZS5lbmQpIDogZmFsc2UpLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBnZXREYXlDbGFzc05hbWVzKG1ldGEsIHRoZW1lKSB7XHJcbiAgICAgICAgbGV0IGNsYXNzTmFtZXMgPSBbXHJcbiAgICAgICAgICAgICdmYy1kYXknLFxyXG4gICAgICAgICAgICBgZmMtZGF5LSR7REFZX0lEU1ttZXRhLmRvd119YCxcclxuICAgICAgICBdO1xyXG4gICAgICAgIGlmIChtZXRhLmlzRGlzYWJsZWQpIHtcclxuICAgICAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1kYXktZGlzYWJsZWQnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChtZXRhLmlzVG9kYXkpIHtcclxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtZGF5LXRvZGF5Jyk7XHJcbiAgICAgICAgICAgICAgICBjbGFzc05hbWVzLnB1c2godGhlbWUuZ2V0Q2xhc3MoJ3RvZGF5JykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChtZXRhLmlzUGFzdCkge1xyXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1kYXktcGFzdCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChtZXRhLmlzRnV0dXJlKSB7XHJcbiAgICAgICAgICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLWRheS1mdXR1cmUnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobWV0YS5pc090aGVyKSB7XHJcbiAgICAgICAgICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLWRheS1vdGhlcicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjbGFzc05hbWVzO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZ2V0U2xvdENsYXNzTmFtZXMobWV0YSwgdGhlbWUpIHtcclxuICAgICAgICBsZXQgY2xhc3NOYW1lcyA9IFtcclxuICAgICAgICAgICAgJ2ZjLXNsb3QnLFxyXG4gICAgICAgICAgICBgZmMtc2xvdC0ke0RBWV9JRFNbbWV0YS5kb3ddfWAsXHJcbiAgICAgICAgXTtcclxuICAgICAgICBpZiAobWV0YS5pc0Rpc2FibGVkKSB7XHJcbiAgICAgICAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtc2xvdC1kaXNhYmxlZCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKG1ldGEuaXNUb2RheSkge1xyXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1zbG90LXRvZGF5Jyk7XHJcbiAgICAgICAgICAgICAgICBjbGFzc05hbWVzLnB1c2godGhlbWUuZ2V0Q2xhc3MoJ3RvZGF5JykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChtZXRhLmlzUGFzdCkge1xyXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1zbG90LXBhc3QnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobWV0YS5pc0Z1dHVyZSkge1xyXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1zbG90LWZ1dHVyZScpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjbGFzc05hbWVzO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IERBWV9GT1JNQVQgPSBjcmVhdGVGb3JtYXR0ZXIoeyB5ZWFyOiAnbnVtZXJpYycsIG1vbnRoOiAnbG9uZycsIGRheTogJ251bWVyaWMnIH0pO1xyXG4gICAgY29uc3QgV0VFS19GT1JNQVQgPSBjcmVhdGVGb3JtYXR0ZXIoeyB3ZWVrOiAnbG9uZycgfSk7XHJcbiAgICBmdW5jdGlvbiBidWlsZE5hdkxpbmtBdHRycyhjb250ZXh0LCBkYXRlTWFya2VyLCB2aWV3VHlwZSA9ICdkYXknLCBpc1RhYmJhYmxlID0gdHJ1ZSkge1xyXG4gICAgICAgIGNvbnN0IHsgZGF0ZUVudiwgb3B0aW9ucywgY2FsZW5kYXJBcGkgfSA9IGNvbnRleHQ7XHJcbiAgICAgICAgbGV0IGRhdGVTdHIgPSBkYXRlRW52LmZvcm1hdChkYXRlTWFya2VyLCB2aWV3VHlwZSA9PT0gJ3dlZWsnID8gV0VFS19GT1JNQVQgOiBEQVlfRk9STUFUKTtcclxuICAgICAgICBpZiAob3B0aW9ucy5uYXZMaW5rcykge1xyXG4gICAgICAgICAgICBsZXQgem9uZWREYXRlID0gZGF0ZUVudi50b0RhdGUoZGF0ZU1hcmtlcik7XHJcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZUludGVyYWN0aW9uID0gKGV2KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBsZXQgY3VzdG9tQWN0aW9uID0gdmlld1R5cGUgPT09ICdkYXknID8gb3B0aW9ucy5uYXZMaW5rRGF5Q2xpY2sgOlxyXG4gICAgICAgICAgICAgICAgICAgIHZpZXdUeXBlID09PSAnd2VlaycgPyBvcHRpb25zLm5hdkxpbmtXZWVrQ2xpY2sgOiBudWxsO1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjdXN0b21BY3Rpb24gPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICAgICAgICBjdXN0b21BY3Rpb24uY2FsbChjYWxlbmRhckFwaSwgZGF0ZUVudi50b0RhdGUoZGF0ZU1hcmtlciksIGV2KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY3VzdG9tQWN0aW9uID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2aWV3VHlwZSA9IGN1c3RvbUFjdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY2FsZW5kYXJBcGkuem9vbVRvKGRhdGVNYXJrZXIsIHZpZXdUeXBlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oeyB0aXRsZTogZm9ybWF0V2l0aE9yZGluYWxzKG9wdGlvbnMubmF2TGlua0hpbnQsIFtkYXRlU3RyLCB6b25lZERhdGVdLCBkYXRlU3RyKSwgJ2RhdGEtbmF2bGluayc6ICcnIH0sIChpc1RhYmJhYmxlXHJcbiAgICAgICAgICAgICAgICA/IGNyZWF0ZUFyaWFDbGlja0F0dHJzKGhhbmRsZUludGVyYWN0aW9uKVxyXG4gICAgICAgICAgICAgICAgOiB7IG9uQ2xpY2s6IGhhbmRsZUludGVyYWN0aW9uIH0pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHsgJ2FyaWEtbGFiZWwnOiBkYXRlU3RyIH07XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IF9pc1J0bFNjcm9sbGJhck9uTGVmdCA9IG51bGw7XHJcbiAgICBmdW5jdGlvbiBnZXRJc1J0bFNjcm9sbGJhck9uTGVmdCgpIHtcclxuICAgICAgICBpZiAoX2lzUnRsU2Nyb2xsYmFyT25MZWZ0ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIF9pc1J0bFNjcm9sbGJhck9uTGVmdCA9IGNvbXB1dGVJc1J0bFNjcm9sbGJhck9uTGVmdCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gX2lzUnRsU2Nyb2xsYmFyT25MZWZ0O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gY29tcHV0ZUlzUnRsU2Nyb2xsYmFyT25MZWZ0KCkge1xyXG4gICAgICAgIGxldCBvdXRlckVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgYXBwbHlTdHlsZShvdXRlckVsLCB7XHJcbiAgICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxyXG4gICAgICAgICAgICB0b3A6IC0xMDAwLFxyXG4gICAgICAgICAgICBsZWZ0OiAwLFxyXG4gICAgICAgICAgICBib3JkZXI6IDAsXHJcbiAgICAgICAgICAgIHBhZGRpbmc6IDAsXHJcbiAgICAgICAgICAgIG92ZXJmbG93OiAnc2Nyb2xsJyxcclxuICAgICAgICAgICAgZGlyZWN0aW9uOiAncnRsJyxcclxuICAgICAgICB9KTtcclxuICAgICAgICBvdXRlckVsLmlubmVySFRNTCA9ICc8ZGl2PjwvZGl2Pic7XHJcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChvdXRlckVsKTtcclxuICAgICAgICBsZXQgaW5uZXJFbCA9IG91dGVyRWwuZmlyc3RDaGlsZDtcclxuICAgICAgICBsZXQgcmVzID0gaW5uZXJFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0ID4gb3V0ZXJFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0O1xyXG4gICAgICAgIHJlbW92ZUVsZW1lbnQob3V0ZXJFbCk7XHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgIH1cclxuXHJcbiAgICBsZXQgX3Njcm9sbGJhcldpZHRocztcclxuICAgIGZ1bmN0aW9uIGdldFNjcm9sbGJhcldpZHRocygpIHtcclxuICAgICAgICBpZiAoIV9zY3JvbGxiYXJXaWR0aHMpIHtcclxuICAgICAgICAgICAgX3Njcm9sbGJhcldpZHRocyA9IGNvbXB1dGVTY3JvbGxiYXJXaWR0aHMoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIF9zY3JvbGxiYXJXaWR0aHM7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBjb21wdXRlU2Nyb2xsYmFyV2lkdGhzKCkge1xyXG4gICAgICAgIGxldCBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgICAgIGVsLnN0eWxlLm92ZXJmbG93ID0gJ3Njcm9sbCc7XHJcbiAgICAgICAgZWwuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xyXG4gICAgICAgIGVsLnN0eWxlLnRvcCA9ICctOTk5OXB4JztcclxuICAgICAgICBlbC5zdHlsZS5sZWZ0ID0gJy05OTk5cHgnO1xyXG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZWwpO1xyXG4gICAgICAgIGxldCByZXMgPSBjb21wdXRlU2Nyb2xsYmFyV2lkdGhzRm9yRWwoZWwpO1xyXG4gICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoZWwpO1xyXG4gICAgICAgIHJldHVybiByZXM7XHJcbiAgICB9XHJcbiAgICAvLyBXQVJOSU5HOiB3aWxsIGluY2x1ZGUgYm9yZGVyXHJcbiAgICBmdW5jdGlvbiBjb21wdXRlU2Nyb2xsYmFyV2lkdGhzRm9yRWwoZWwpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB4OiBlbC5vZmZzZXRIZWlnaHQgLSBlbC5jbGllbnRIZWlnaHQsXHJcbiAgICAgICAgICAgIHk6IGVsLm9mZnNldFdpZHRoIC0gZWwuY2xpZW50V2lkdGgsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjb21wdXRlRWRnZXMoZWwsIGdldFBhZGRpbmcgPSBmYWxzZSkge1xyXG4gICAgICAgIGxldCBjb21wdXRlZFN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpO1xyXG4gICAgICAgIGxldCBib3JkZXJMZWZ0ID0gcGFyc2VJbnQoY29tcHV0ZWRTdHlsZS5ib3JkZXJMZWZ0V2lkdGgsIDEwKSB8fCAwO1xyXG4gICAgICAgIGxldCBib3JkZXJSaWdodCA9IHBhcnNlSW50KGNvbXB1dGVkU3R5bGUuYm9yZGVyUmlnaHRXaWR0aCwgMTApIHx8IDA7XHJcbiAgICAgICAgbGV0IGJvcmRlclRvcCA9IHBhcnNlSW50KGNvbXB1dGVkU3R5bGUuYm9yZGVyVG9wV2lkdGgsIDEwKSB8fCAwO1xyXG4gICAgICAgIGxldCBib3JkZXJCb3R0b20gPSBwYXJzZUludChjb21wdXRlZFN0eWxlLmJvcmRlckJvdHRvbVdpZHRoLCAxMCkgfHwgMDtcclxuICAgICAgICBsZXQgYmFkU2Nyb2xsYmFyV2lkdGhzID0gY29tcHV0ZVNjcm9sbGJhcldpZHRoc0ZvckVsKGVsKTsgLy8gaW5jbHVkZXMgYm9yZGVyIVxyXG4gICAgICAgIGxldCBzY3JvbGxiYXJMZWZ0UmlnaHQgPSBiYWRTY3JvbGxiYXJXaWR0aHMueSAtIGJvcmRlckxlZnQgLSBib3JkZXJSaWdodDtcclxuICAgICAgICBsZXQgc2Nyb2xsYmFyQm90dG9tID0gYmFkU2Nyb2xsYmFyV2lkdGhzLnggLSBib3JkZXJUb3AgLSBib3JkZXJCb3R0b207XHJcbiAgICAgICAgbGV0IHJlcyA9IHtcclxuICAgICAgICAgICAgYm9yZGVyTGVmdCxcclxuICAgICAgICAgICAgYm9yZGVyUmlnaHQsXHJcbiAgICAgICAgICAgIGJvcmRlclRvcCxcclxuICAgICAgICAgICAgYm9yZGVyQm90dG9tLFxyXG4gICAgICAgICAgICBzY3JvbGxiYXJCb3R0b20sXHJcbiAgICAgICAgICAgIHNjcm9sbGJhckxlZnQ6IDAsXHJcbiAgICAgICAgICAgIHNjcm9sbGJhclJpZ2h0OiAwLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKGdldElzUnRsU2Nyb2xsYmFyT25MZWZ0KCkgJiYgY29tcHV0ZWRTdHlsZS5kaXJlY3Rpb24gPT09ICdydGwnKSB7IC8vIGlzIHRoZSBzY3JvbGxiYXIgb24gdGhlIGxlZnQgc2lkZT9cclxuICAgICAgICAgICAgcmVzLnNjcm9sbGJhckxlZnQgPSBzY3JvbGxiYXJMZWZ0UmlnaHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXMuc2Nyb2xsYmFyUmlnaHQgPSBzY3JvbGxiYXJMZWZ0UmlnaHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChnZXRQYWRkaW5nKSB7XHJcbiAgICAgICAgICAgIHJlcy5wYWRkaW5nTGVmdCA9IHBhcnNlSW50KGNvbXB1dGVkU3R5bGUucGFkZGluZ0xlZnQsIDEwKSB8fCAwO1xyXG4gICAgICAgICAgICByZXMucGFkZGluZ1JpZ2h0ID0gcGFyc2VJbnQoY29tcHV0ZWRTdHlsZS5wYWRkaW5nUmlnaHQsIDEwKSB8fCAwO1xyXG4gICAgICAgICAgICByZXMucGFkZGluZ1RvcCA9IHBhcnNlSW50KGNvbXB1dGVkU3R5bGUucGFkZGluZ1RvcCwgMTApIHx8IDA7XHJcbiAgICAgICAgICAgIHJlcy5wYWRkaW5nQm90dG9tID0gcGFyc2VJbnQoY29tcHV0ZWRTdHlsZS5wYWRkaW5nQm90dG9tLCAxMCkgfHwgMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGNvbXB1dGVJbm5lclJlY3QoZWwsIGdvV2l0aGluUGFkZGluZyA9IGZhbHNlLCBkb0Zyb21XaW5kb3dWaWV3cG9ydCkge1xyXG4gICAgICAgIGxldCBvdXRlclJlY3QgPSBkb0Zyb21XaW5kb3dWaWV3cG9ydCA/IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIDogY29tcHV0ZVJlY3QoZWwpO1xyXG4gICAgICAgIGxldCBlZGdlcyA9IGNvbXB1dGVFZGdlcyhlbCwgZ29XaXRoaW5QYWRkaW5nKTtcclxuICAgICAgICBsZXQgcmVzID0ge1xyXG4gICAgICAgICAgICBsZWZ0OiBvdXRlclJlY3QubGVmdCArIGVkZ2VzLmJvcmRlckxlZnQgKyBlZGdlcy5zY3JvbGxiYXJMZWZ0LFxyXG4gICAgICAgICAgICByaWdodDogb3V0ZXJSZWN0LnJpZ2h0IC0gZWRnZXMuYm9yZGVyUmlnaHQgLSBlZGdlcy5zY3JvbGxiYXJSaWdodCxcclxuICAgICAgICAgICAgdG9wOiBvdXRlclJlY3QudG9wICsgZWRnZXMuYm9yZGVyVG9wLFxyXG4gICAgICAgICAgICBib3R0b206IG91dGVyUmVjdC5ib3R0b20gLSBlZGdlcy5ib3JkZXJCb3R0b20gLSBlZGdlcy5zY3JvbGxiYXJCb3R0b20sXHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAoZ29XaXRoaW5QYWRkaW5nKSB7XHJcbiAgICAgICAgICAgIHJlcy5sZWZ0ICs9IGVkZ2VzLnBhZGRpbmdMZWZ0O1xyXG4gICAgICAgICAgICByZXMucmlnaHQgLT0gZWRnZXMucGFkZGluZ1JpZ2h0O1xyXG4gICAgICAgICAgICByZXMudG9wICs9IGVkZ2VzLnBhZGRpbmdUb3A7XHJcbiAgICAgICAgICAgIHJlcy5ib3R0b20gLT0gZWRnZXMucGFkZGluZ0JvdHRvbTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGNvbXB1dGVSZWN0KGVsKSB7XHJcbiAgICAgICAgbGV0IHJlY3QgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBsZWZ0OiByZWN0LmxlZnQgKyB3aW5kb3cucGFnZVhPZmZzZXQsXHJcbiAgICAgICAgICAgIHRvcDogcmVjdC50b3AgKyB3aW5kb3cucGFnZVlPZmZzZXQsXHJcbiAgICAgICAgICAgIHJpZ2h0OiByZWN0LnJpZ2h0ICsgd2luZG93LnBhZ2VYT2Zmc2V0LFxyXG4gICAgICAgICAgICBib3R0b206IHJlY3QuYm90dG9tICsgd2luZG93LnBhZ2VZT2Zmc2V0LFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBjb21wdXRlQ2xpcHBlZENsaWVudFJlY3QoZWwpIHtcclxuICAgICAgICBsZXQgY2xpcHBpbmdQYXJlbnRzID0gZ2V0Q2xpcHBpbmdQYXJlbnRzKGVsKTtcclxuICAgICAgICBsZXQgcmVjdCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgICAgIGZvciAobGV0IGNsaXBwaW5nUGFyZW50IG9mIGNsaXBwaW5nUGFyZW50cykge1xyXG4gICAgICAgICAgICBsZXQgaW50ZXJzZWN0aW9uID0gaW50ZXJzZWN0UmVjdHMocmVjdCwgY2xpcHBpbmdQYXJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkpO1xyXG4gICAgICAgICAgICBpZiAoaW50ZXJzZWN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICByZWN0ID0gaW50ZXJzZWN0aW9uO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlY3Q7XHJcbiAgICB9XHJcbiAgICAvLyBkb2VzIG5vdCByZXR1cm4gd2luZG93XHJcbiAgICBmdW5jdGlvbiBnZXRDbGlwcGluZ1BhcmVudHMoZWwpIHtcclxuICAgICAgICBsZXQgcGFyZW50cyA9IFtdO1xyXG4gICAgICAgIHdoaWxlIChlbCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7IC8vIHdpbGwgc3RvcCB3aGVuIGdldHMgdG8gZG9jdW1lbnQgb3IgbnVsbFxyXG4gICAgICAgICAgICBsZXQgY29tcHV0ZWRTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsKTtcclxuICAgICAgICAgICAgaWYgKGNvbXB1dGVkU3R5bGUucG9zaXRpb24gPT09ICdmaXhlZCcpIHtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICgoLyhhdXRvfHNjcm9sbCkvKS50ZXN0KGNvbXB1dGVkU3R5bGUub3ZlcmZsb3cgKyBjb21wdXRlZFN0eWxlLm92ZXJmbG93WSArIGNvbXB1dGVkU3R5bGUub3ZlcmZsb3dYKSkge1xyXG4gICAgICAgICAgICAgICAgcGFyZW50cy5wdXNoKGVsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbCA9IGVsLnBhcmVudE5vZGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwYXJlbnRzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qXHJcbiAgICBnaXZlbiBhIGZ1bmN0aW9uIHRoYXQgcmVzb2x2ZXMgYSByZXN1bHQgYXN5bmNocm9ub3VzbHkuXHJcbiAgICB0aGUgZnVuY3Rpb24gY2FuIGVpdGhlciBjYWxsIHBhc3NlZC1pbiBzdWNjZXNzIGFuZCBmYWlsdXJlIGNhbGxiYWNrcyxcclxuICAgIG9yIGl0IGNhbiByZXR1cm4gYSBwcm9taXNlLlxyXG4gICAgaWYgeW91IG5lZWQgdG8gcGFzcyBhZGRpdGlvbmFsIHBhcmFtcyB0byBmdW5jLCBiaW5kIHRoZW0gZmlyc3QuXHJcbiAgICAqL1xyXG4gICAgZnVuY3Rpb24gdW5wcm9taXNpZnkoZnVuYywgbm9ybWFsaXplZFN1Y2Nlc3NDYWxsYmFjaywgbm9ybWFsaXplZEZhaWx1cmVDYWxsYmFjaykge1xyXG4gICAgICAgIC8vIGd1YXJkIGFnYWluc3Qgc3VjY2Vzcy9mYWlsdXJlIGNhbGxiYWNrcyBiZWluZyBjYWxsZWQgbW9yZSB0aGFuIG9uY2VcclxuICAgICAgICAvLyBhbmQgZ3VhcmQgYWdhaW5zdCBhIHByb21pc2UgQU5EIGNhbGxiYWNrIGJlaW5nIHVzZWQgdG9nZXRoZXIuXHJcbiAgICAgICAgbGV0IGlzUmVzb2x2ZWQgPSBmYWxzZTtcclxuICAgICAgICBsZXQgd3JhcHBlZFN1Y2Nlc3MgPSBmdW5jdGlvbiAocmVzKSB7XHJcbiAgICAgICAgICAgIGlmICghaXNSZXNvbHZlZCkge1xyXG4gICAgICAgICAgICAgICAgaXNSZXNvbHZlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBub3JtYWxpemVkU3VjY2Vzc0NhbGxiYWNrKHJlcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIGxldCB3cmFwcGVkRmFpbHVyZSA9IGZ1bmN0aW9uIChlcnJvcikge1xyXG4gICAgICAgICAgICBpZiAoIWlzUmVzb2x2ZWQpIHtcclxuICAgICAgICAgICAgICAgIGlzUmVzb2x2ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgbm9ybWFsaXplZEZhaWx1cmVDYWxsYmFjayhlcnJvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIGxldCByZXMgPSBmdW5jKHdyYXBwZWRTdWNjZXNzLCB3cmFwcGVkRmFpbHVyZSk7XHJcbiAgICAgICAgaWYgKHJlcyAmJiB0eXBlb2YgcmVzLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgcmVzLnRoZW4od3JhcHBlZFN1Y2Nlc3MsIHdyYXBwZWRGYWlsdXJlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY2xhc3MgRW1pdHRlciB7XHJcbiAgICAgICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlcnMgPSB7fTtcclxuICAgICAgICAgICAgdGhpcy50aGlzQ29udGV4dCA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNldFRoaXNDb250ZXh0KHRoaXNDb250ZXh0KSB7XHJcbiAgICAgICAgICAgIHRoaXMudGhpc0NvbnRleHQgPSB0aGlzQ29udGV4dDtcclxuICAgICAgICB9XHJcbiAgICAgICAgc2V0T3B0aW9ucyhvcHRpb25zKSB7XHJcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG9uKHR5cGUsIGhhbmRsZXIpIHtcclxuICAgICAgICAgICAgYWRkVG9IYXNoKHRoaXMuaGFuZGxlcnMsIHR5cGUsIGhhbmRsZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBvZmYodHlwZSwgaGFuZGxlcikge1xyXG4gICAgICAgICAgICByZW1vdmVGcm9tSGFzaCh0aGlzLmhhbmRsZXJzLCB0eXBlLCBoYW5kbGVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdHJpZ2dlcih0eXBlLCAuLi5hcmdzKSB7XHJcbiAgICAgICAgICAgIGxldCBhdHRhY2hlZEhhbmRsZXJzID0gdGhpcy5oYW5kbGVyc1t0eXBlXSB8fCBbXTtcclxuICAgICAgICAgICAgbGV0IG9wdGlvbkhhbmRsZXIgPSB0aGlzLm9wdGlvbnMgJiYgdGhpcy5vcHRpb25zW3R5cGVdO1xyXG4gICAgICAgICAgICBsZXQgaGFuZGxlcnMgPSBbXS5jb25jYXQob3B0aW9uSGFuZGxlciB8fCBbXSwgYXR0YWNoZWRIYW5kbGVycyk7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGhhbmRsZXIgb2YgaGFuZGxlcnMpIHtcclxuICAgICAgICAgICAgICAgIGhhbmRsZXIuYXBwbHkodGhpcy50aGlzQ29udGV4dCwgYXJncyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaGFzSGFuZGxlcnModHlwZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gQm9vbGVhbigodGhpcy5oYW5kbGVyc1t0eXBlXSAmJiB0aGlzLmhhbmRsZXJzW3R5cGVdLmxlbmd0aCkgfHxcclxuICAgICAgICAgICAgICAgICh0aGlzLm9wdGlvbnMgJiYgdGhpcy5vcHRpb25zW3R5cGVdKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYWRkVG9IYXNoKGhhc2gsIHR5cGUsIGhhbmRsZXIpIHtcclxuICAgICAgICAoaGFzaFt0eXBlXSB8fCAoaGFzaFt0eXBlXSA9IFtdKSlcclxuICAgICAgICAgICAgLnB1c2goaGFuZGxlcik7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiByZW1vdmVGcm9tSGFzaChoYXNoLCB0eXBlLCBoYW5kbGVyKSB7XHJcbiAgICAgICAgaWYgKGhhbmRsZXIpIHtcclxuICAgICAgICAgICAgaWYgKGhhc2hbdHlwZV0pIHtcclxuICAgICAgICAgICAgICAgIGhhc2hbdHlwZV0gPSBoYXNoW3R5cGVdLmZpbHRlcigoZnVuYykgPT4gZnVuYyAhPT0gaGFuZGxlcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGRlbGV0ZSBoYXNoW3R5cGVdOyAvLyByZW1vdmUgYWxsIGhhbmRsZXIgZnVuY3MgZm9yIHRoaXMgdHlwZVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKlxyXG4gICAgUmVjb3JkcyBvZmZzZXQgaW5mb3JtYXRpb24gZm9yIGEgc2V0IG9mIGVsZW1lbnRzLCByZWxhdGl2ZSB0byBhbiBvcmlnaW4gZWxlbWVudC5cclxuICAgIENhbiByZWNvcmQgdGhlIGxlZnQvcmlnaHQgT1IgdGhlIHRvcC9ib3R0b20gT1IgYm90aC5cclxuICAgIFByb3ZpZGVzIG1ldGhvZHMgZm9yIHF1ZXJ5aW5nIHRoZSBjYWNoZSBieSBwb3NpdGlvbi5cclxuICAgICovXHJcbiAgICBjbGFzcyBQb3NpdGlvbkNhY2hlIHtcclxuICAgICAgICBjb25zdHJ1Y3RvcihvcmlnaW5FbCwgZWxzLCBpc0hvcml6b250YWwsIGlzVmVydGljYWwpIHtcclxuICAgICAgICAgICAgdGhpcy5lbHMgPSBlbHM7XHJcbiAgICAgICAgICAgIGxldCBvcmlnaW5DbGllbnRSZWN0ID0gdGhpcy5vcmlnaW5DbGllbnRSZWN0ID0gb3JpZ2luRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7IC8vIHJlbGF0aXZlIHRvIHZpZXdwb3J0IHRvcC1sZWZ0XHJcbiAgICAgICAgICAgIGlmIChpc0hvcml6b250YWwpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYnVpbGRFbEhvcml6b250YWxzKG9yaWdpbkNsaWVudFJlY3QubGVmdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGlzVmVydGljYWwpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYnVpbGRFbFZlcnRpY2FscyhvcmlnaW5DbGllbnRSZWN0LnRvcCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gUG9wdWxhdGVzIHRoZSBsZWZ0L3JpZ2h0IGludGVybmFsIGNvb3JkaW5hdGUgYXJyYXlzXHJcbiAgICAgICAgYnVpbGRFbEhvcml6b250YWxzKG9yaWdpbkNsaWVudExlZnQpIHtcclxuICAgICAgICAgICAgbGV0IGxlZnRzID0gW107XHJcbiAgICAgICAgICAgIGxldCByaWdodHMgPSBbXTtcclxuICAgICAgICAgICAgZm9yIChsZXQgZWwgb2YgdGhpcy5lbHMpIHtcclxuICAgICAgICAgICAgICAgIGxldCByZWN0ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICAgICAgICAgICAgICBsZWZ0cy5wdXNoKHJlY3QubGVmdCAtIG9yaWdpbkNsaWVudExlZnQpO1xyXG4gICAgICAgICAgICAgICAgcmlnaHRzLnB1c2gocmVjdC5yaWdodCAtIG9yaWdpbkNsaWVudExlZnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMubGVmdHMgPSBsZWZ0cztcclxuICAgICAgICAgICAgdGhpcy5yaWdodHMgPSByaWdodHM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFBvcHVsYXRlcyB0aGUgdG9wL2JvdHRvbSBpbnRlcm5hbCBjb29yZGluYXRlIGFycmF5c1xyXG4gICAgICAgIGJ1aWxkRWxWZXJ0aWNhbHMob3JpZ2luQ2xpZW50VG9wKSB7XHJcbiAgICAgICAgICAgIGxldCB0b3BzID0gW107XHJcbiAgICAgICAgICAgIGxldCBib3R0b21zID0gW107XHJcbiAgICAgICAgICAgIGZvciAobGV0IGVsIG9mIHRoaXMuZWxzKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgcmVjdCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgICAgICAgICAgICAgdG9wcy5wdXNoKHJlY3QudG9wIC0gb3JpZ2luQ2xpZW50VG9wKTtcclxuICAgICAgICAgICAgICAgIGJvdHRvbXMucHVzaChyZWN0LmJvdHRvbSAtIG9yaWdpbkNsaWVudFRvcCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy50b3BzID0gdG9wcztcclxuICAgICAgICAgICAgdGhpcy5ib3R0b21zID0gYm90dG9tcztcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gR2l2ZW4gYSBsZWZ0IG9mZnNldCAoZnJvbSBkb2N1bWVudCBsZWZ0KSwgcmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGVsIHRoYXQgaXQgaG9yaXpvbnRhbGx5IGludGVyc2VjdHMuXHJcbiAgICAgICAgLy8gSWYgbm8gaW50ZXJzZWN0aW9uIGlzIG1hZGUsIHJldHVybnMgdW5kZWZpbmVkLlxyXG4gICAgICAgIGxlZnRUb0luZGV4KGxlZnRQb3NpdGlvbikge1xyXG4gICAgICAgICAgICBsZXQgeyBsZWZ0cywgcmlnaHRzIH0gPSB0aGlzO1xyXG4gICAgICAgICAgICBsZXQgbGVuID0gbGVmdHMubGVuZ3RoO1xyXG4gICAgICAgICAgICBsZXQgaTtcclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobGVmdFBvc2l0aW9uID49IGxlZnRzW2ldICYmIGxlZnRQb3NpdGlvbiA8IHJpZ2h0c1tpXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7IC8vIFRPRE86IGJldHRlclxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBHaXZlbiBhIHRvcCBvZmZzZXQgKGZyb20gZG9jdW1lbnQgdG9wKSwgcmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGVsIHRoYXQgaXQgdmVydGljYWxseSBpbnRlcnNlY3RzLlxyXG4gICAgICAgIC8vIElmIG5vIGludGVyc2VjdGlvbiBpcyBtYWRlLCByZXR1cm5zIHVuZGVmaW5lZC5cclxuICAgICAgICB0b3BUb0luZGV4KHRvcFBvc2l0aW9uKSB7XHJcbiAgICAgICAgICAgIGxldCB7IHRvcHMsIGJvdHRvbXMgfSA9IHRoaXM7XHJcbiAgICAgICAgICAgIGxldCBsZW4gPSB0b3BzLmxlbmd0aDtcclxuICAgICAgICAgICAgbGV0IGk7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRvcFBvc2l0aW9uID49IHRvcHNbaV0gJiYgdG9wUG9zaXRpb24gPCBib3R0b21zW2ldKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDsgLy8gVE9ETzogYmV0dGVyXHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEdldHMgdGhlIHdpZHRoIG9mIHRoZSBlbGVtZW50IGF0IHRoZSBnaXZlbiBpbmRleFxyXG4gICAgICAgIGdldFdpZHRoKGxlZnRJbmRleCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yaWdodHNbbGVmdEluZGV4XSAtIHRoaXMubGVmdHNbbGVmdEluZGV4XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gR2V0cyB0aGUgaGVpZ2h0IG9mIHRoZSBlbGVtZW50IGF0IHRoZSBnaXZlbiBpbmRleFxyXG4gICAgICAgIGdldEhlaWdodCh0b3BJbmRleCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ib3R0b21zW3RvcEluZGV4XSAtIHRoaXMudG9wc1t0b3BJbmRleF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNpbWlsYXJUbyhvdGhlckNhY2hlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzaW1pbGFyTnVtQXJyYXlzKHRoaXMudG9wcyB8fCBbXSwgb3RoZXJDYWNoZS50b3BzIHx8IFtdKSAmJlxyXG4gICAgICAgICAgICAgICAgc2ltaWxhck51bUFycmF5cyh0aGlzLmJvdHRvbXMgfHwgW10sIG90aGVyQ2FjaGUuYm90dG9tcyB8fCBbXSkgJiZcclxuICAgICAgICAgICAgICAgIHNpbWlsYXJOdW1BcnJheXModGhpcy5sZWZ0cyB8fCBbXSwgb3RoZXJDYWNoZS5sZWZ0cyB8fCBbXSkgJiZcclxuICAgICAgICAgICAgICAgIHNpbWlsYXJOdW1BcnJheXModGhpcy5yaWdodHMgfHwgW10sIG90aGVyQ2FjaGUucmlnaHRzIHx8IFtdKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBzaW1pbGFyTnVtQXJyYXlzKGEsIGIpIHtcclxuICAgICAgICBjb25zdCBsZW4gPSBhLmxlbmd0aDtcclxuICAgICAgICBpZiAobGVuICE9PSBiLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKE1hdGgucm91bmQoYVtpXSkgIT09IE1hdGgucm91bmQoYltpXSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKiBlc2xpbnQgbWF4LWNsYXNzZXMtcGVyLWZpbGU6IFwib2ZmXCIgKi9cclxuICAgIC8qXHJcbiAgICBBbiBvYmplY3QgZm9yIGdldHRpbmcvc2V0dGluZyBzY3JvbGwtcmVsYXRlZCBpbmZvcm1hdGlvbiBmb3IgYW4gZWxlbWVudC5cclxuICAgIEludGVybmFsbHksIHRoaXMgaXMgZG9uZSB2ZXJ5IGRpZmZlcmVudGx5IGZvciB3aW5kb3cgdmVyc3VzIERPTSBlbGVtZW50LFxyXG4gICAgc28gdGhpcyBvYmplY3Qgc2VydmVzIGFzIGEgY29tbW9uIGludGVyZmFjZS5cclxuICAgICovXHJcbiAgICBjbGFzcyBTY3JvbGxDb250cm9sbGVyIHtcclxuICAgICAgICBnZXRNYXhTY3JvbGxUb3AoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFNjcm9sbEhlaWdodCgpIC0gdGhpcy5nZXRDbGllbnRIZWlnaHQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZ2V0TWF4U2Nyb2xsTGVmdCgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U2Nyb2xsV2lkdGgoKSAtIHRoaXMuZ2V0Q2xpZW50V2lkdGgoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2FuU2Nyb2xsVmVydGljYWxseSgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TWF4U2Nyb2xsVG9wKCkgPiAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYW5TY3JvbGxIb3Jpem9udGFsbHkoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldE1heFNjcm9sbExlZnQoKSA+IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhblNjcm9sbFVwKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRTY3JvbGxUb3AoKSA+IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhblNjcm9sbERvd24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFNjcm9sbFRvcCgpIDwgdGhpcy5nZXRNYXhTY3JvbGxUb3AoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2FuU2Nyb2xsTGVmdCgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U2Nyb2xsTGVmdCgpID4gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2FuU2Nyb2xsUmlnaHQoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFNjcm9sbExlZnQoKSA8IHRoaXMuZ2V0TWF4U2Nyb2xsTGVmdCgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNsYXNzIEVsZW1lbnRTY3JvbGxDb250cm9sbGVyIGV4dGVuZHMgU2Nyb2xsQ29udHJvbGxlciB7XHJcbiAgICAgICAgY29uc3RydWN0b3IoZWwpIHtcclxuICAgICAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICAgICAgdGhpcy5lbCA9IGVsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBnZXRTY3JvbGxUb3AoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVsLnNjcm9sbFRvcDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZ2V0U2Nyb2xsTGVmdCgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWwuc2Nyb2xsTGVmdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgc2V0U2Nyb2xsVG9wKHRvcCkge1xyXG4gICAgICAgICAgICB0aGlzLmVsLnNjcm9sbFRvcCA9IHRvcDtcclxuICAgICAgICB9XHJcbiAgICAgICAgc2V0U2Nyb2xsTGVmdChsZWZ0KSB7XHJcbiAgICAgICAgICAgIHRoaXMuZWwuc2Nyb2xsTGVmdCA9IGxlZnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGdldFNjcm9sbFdpZHRoKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbC5zY3JvbGxXaWR0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZ2V0U2Nyb2xsSGVpZ2h0KCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbC5zY3JvbGxIZWlnaHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGdldENsaWVudEhlaWdodCgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWwuY2xpZW50SGVpZ2h0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBnZXRDbGllbnRXaWR0aCgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWwuY2xpZW50V2lkdGg7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY2xhc3MgV2luZG93U2Nyb2xsQ29udHJvbGxlciBleHRlbmRzIFNjcm9sbENvbnRyb2xsZXIge1xyXG4gICAgICAgIGdldFNjcm9sbFRvcCgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy5wYWdlWU9mZnNldDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZ2V0U2Nyb2xsTGVmdCgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy5wYWdlWE9mZnNldDtcclxuICAgICAgICB9XHJcbiAgICAgICAgc2V0U2Nyb2xsVG9wKG4pIHtcclxuICAgICAgICAgICAgd2luZG93LnNjcm9sbCh3aW5kb3cucGFnZVhPZmZzZXQsIG4pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzZXRTY3JvbGxMZWZ0KG4pIHtcclxuICAgICAgICAgICAgd2luZG93LnNjcm9sbChuLCB3aW5kb3cucGFnZVlPZmZzZXQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBnZXRTY3JvbGxXaWR0aCgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxXaWR0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZ2V0U2Nyb2xsSGVpZ2h0KCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbEhlaWdodDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZ2V0Q2xpZW50SGVpZ2h0KCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZ2V0Q2xpZW50V2lkdGgoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGg7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNsYXNzIFRoZW1lIHtcclxuICAgICAgICBjb25zdHJ1Y3RvcihjYWxlbmRhck9wdGlvbnMpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaWNvbk92ZXJyaWRlT3B0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldEljb25PdmVycmlkZShjYWxlbmRhck9wdGlvbnNbdGhpcy5pY29uT3ZlcnJpZGVPcHRpb25dKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBzZXRJY29uT3ZlcnJpZGUoaWNvbk92ZXJyaWRlSGFzaCkge1xyXG4gICAgICAgICAgICBsZXQgaWNvbkNsYXNzZXNDb3B5O1xyXG4gICAgICAgICAgICBsZXQgYnV0dG9uTmFtZTtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBpY29uT3ZlcnJpZGVIYXNoID09PSAnb2JqZWN0JyAmJiBpY29uT3ZlcnJpZGVIYXNoKSB7IC8vIG5vbi1udWxsIG9iamVjdFxyXG4gICAgICAgICAgICAgICAgaWNvbkNsYXNzZXNDb3B5ID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5pY29uQ2xhc3Nlcyk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGJ1dHRvbk5hbWUgaW4gaWNvbk92ZXJyaWRlSGFzaCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGljb25DbGFzc2VzQ29weVtidXR0b25OYW1lXSA9IHRoaXMuYXBwbHlJY29uT3ZlcnJpZGVQcmVmaXgoaWNvbk92ZXJyaWRlSGFzaFtidXR0b25OYW1lXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLmljb25DbGFzc2VzID0gaWNvbkNsYXNzZXNDb3B5O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGljb25PdmVycmlkZUhhc2ggPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmljb25DbGFzc2VzID0ge307XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgYXBwbHlJY29uT3ZlcnJpZGVQcmVmaXgoY2xhc3NOYW1lKSB7XHJcbiAgICAgICAgICAgIGxldCBwcmVmaXggPSB0aGlzLmljb25PdmVycmlkZVByZWZpeDtcclxuICAgICAgICAgICAgaWYgKHByZWZpeCAmJiBjbGFzc05hbWUuaW5kZXhPZihwcmVmaXgpICE9PSAwKSB7IC8vIGlmIG5vdCBhbHJlYWR5IHByZXNlbnRcclxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZSA9IHByZWZpeCArIGNsYXNzTmFtZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gY2xhc3NOYW1lO1xyXG4gICAgICAgIH1cclxuICAgICAgICBnZXRDbGFzcyhrZXkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xhc3Nlc1trZXldIHx8ICcnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBnZXRJY29uQ2xhc3MoYnV0dG9uTmFtZSwgaXNSdGwpIHtcclxuICAgICAgICAgICAgbGV0IGNsYXNzTmFtZTtcclxuICAgICAgICAgICAgaWYgKGlzUnRsICYmIHRoaXMucnRsSWNvbkNsYXNzZXMpIHtcclxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZSA9IHRoaXMucnRsSWNvbkNsYXNzZXNbYnV0dG9uTmFtZV0gfHwgdGhpcy5pY29uQ2xhc3Nlc1tidXR0b25OYW1lXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZSA9IHRoaXMuaWNvbkNsYXNzZXNbYnV0dG9uTmFtZV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGNsYXNzTmFtZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGAke3RoaXMuYmFzZUljb25DbGFzc30gJHtjbGFzc05hbWV9YDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gJyc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGdldEN1c3RvbUJ1dHRvbkljb25DbGFzcyhjdXN0b21CdXR0b25Qcm9wcykge1xyXG4gICAgICAgICAgICBsZXQgY2xhc3NOYW1lO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5pY29uT3ZlcnJpZGVDdXN0b21CdXR0b25PcHRpb24pIHtcclxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZSA9IGN1c3RvbUJ1dHRvblByb3BzW3RoaXMuaWNvbk92ZXJyaWRlQ3VzdG9tQnV0dG9uT3B0aW9uXTtcclxuICAgICAgICAgICAgICAgIGlmIChjbGFzc05hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYCR7dGhpcy5iYXNlSWNvbkNsYXNzfSAke3RoaXMuYXBwbHlJY29uT3ZlcnJpZGVQcmVmaXgoY2xhc3NOYW1lKX1gO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiAnJztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBUaGVtZS5wcm90b3R5cGUuY2xhc3NlcyA9IHt9O1xyXG4gICAgVGhlbWUucHJvdG90eXBlLmljb25DbGFzc2VzID0ge307XHJcbiAgICBUaGVtZS5wcm90b3R5cGUuYmFzZUljb25DbGFzcyA9ICcnO1xyXG4gICAgVGhlbWUucHJvdG90eXBlLmljb25PdmVycmlkZVByZWZpeCA9ICcnO1xyXG5cclxuICAgIC8qXHJcbiAgICBOT1RFOiB0aGlzIGNhbiBiZSBhIHB1YmxpYyBBUEksIGVzcGVjaWFsbHkgY3JlYXRlRWxlbWVudCBmb3IgaG9va3MuXHJcbiAgICBTZWUgZXhhbXBsZXMvdHlwZXNjcmlwdC1zY2hlZHVsZXIvc3JjL2luZGV4LnRzXHJcbiAgICAqL1xyXG4gICAgZnVuY3Rpb24gZmx1c2hTeW5jKHJ1bkJlZm9yZUZsdXNoKSB7XHJcbiAgICAgICAgcnVuQmVmb3JlRmx1c2goKTtcclxuICAgICAgICBsZXQgb2xkRGVib3VuY2VSZW5kZXJpbmcgPSBsJDEuZGVib3VuY2VSZW5kZXJpbmc7IC8vIG9yaWdcclxuICAgICAgICBsZXQgY2FsbGJhY2tRID0gW107XHJcbiAgICAgICAgZnVuY3Rpb24gZXhlY0NhbGxiYWNrU3luYyhjYWxsYmFjaykge1xyXG4gICAgICAgICAgICBjYWxsYmFja1EucHVzaChjYWxsYmFjayk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGwkMS5kZWJvdW5jZVJlbmRlcmluZyA9IGV4ZWNDYWxsYmFja1N5bmM7XHJcbiAgICAgICAgRCQxKHkoRmFrZUNvbXBvbmVudCwge30pLCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSk7XHJcbiAgICAgICAgd2hpbGUgKGNhbGxiYWNrUS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgY2FsbGJhY2tRLnNoaWZ0KCkoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbCQxLmRlYm91bmNlUmVuZGVyaW5nID0gb2xkRGVib3VuY2VSZW5kZXJpbmc7XHJcbiAgICB9XHJcbiAgICBjbGFzcyBGYWtlQ29tcG9uZW50IGV4dGVuZHMgeCQxIHtcclxuICAgICAgICByZW5kZXIoKSB7IHJldHVybiB5KCdkaXYnLCB7fSk7IH1cclxuICAgICAgICBjb21wb25lbnREaWRNb3VudCgpIHsgdGhpcy5zZXRTdGF0ZSh7fSk7IH1cclxuICAgIH1cclxuICAgIC8vIFRPRE86IHVzZSBwcmVhY3QvY29tcGF0IGluc3RlYWQ/XHJcbiAgICBmdW5jdGlvbiBjcmVhdGVDb250ZXh0KGRlZmF1bHRWYWx1ZSkge1xyXG4gICAgICAgIGxldCBDb250ZXh0VHlwZSA9IEckMShkZWZhdWx0VmFsdWUpO1xyXG4gICAgICAgIGxldCBvcmlnUHJvdmlkZXIgPSBDb250ZXh0VHlwZS5Qcm92aWRlcjtcclxuICAgICAgICBDb250ZXh0VHlwZS5Qcm92aWRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgbGV0IGlzTmV3ID0gIXRoaXMuZ2V0Q2hpbGRDb250ZXh0O1xyXG4gICAgICAgICAgICBsZXQgY2hpbGRyZW4gPSBvcmlnUHJvdmlkZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBwcmVmZXItcmVzdC1wYXJhbXNcclxuICAgICAgICAgICAgaWYgKGlzTmV3KSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgc3VicyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zaG91bGRDb21wb25lbnRVcGRhdGUgPSAoX3Byb3BzKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucHJvcHMudmFsdWUgIT09IF9wcm9wcy52YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJzLmZvckVhY2goKGMpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuY29udGV4dCA9IF9wcm9wcy52YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuZm9yY2VVcGRhdGUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3ViID0gKGMpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBzdWJzLnB1c2goYyk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IG9sZCA9IGMuY29tcG9uZW50V2lsbFVubW91bnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgYy5jb21wb25lbnRXaWxsVW5tb3VudCA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3Vicy5zcGxpY2Uoc3Vicy5pbmRleE9mKGMpLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb2xkICYmIG9sZC5jYWxsKGMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBjaGlsZHJlbjtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBDb250ZXh0VHlwZTtcclxuICAgIH1cclxuXHJcbiAgICBjbGFzcyBTY3JvbGxSZXNwb25kZXIge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yKGV4ZWNGdW5jLCBlbWl0dGVyLCBzY3JvbGxUaW1lLCBzY3JvbGxUaW1lUmVzZXQpIHtcclxuICAgICAgICAgICAgdGhpcy5leGVjRnVuYyA9IGV4ZWNGdW5jO1xyXG4gICAgICAgICAgICB0aGlzLmVtaXR0ZXIgPSBlbWl0dGVyO1xyXG4gICAgICAgICAgICB0aGlzLnNjcm9sbFRpbWUgPSBzY3JvbGxUaW1lO1xyXG4gICAgICAgICAgICB0aGlzLnNjcm9sbFRpbWVSZXNldCA9IHNjcm9sbFRpbWVSZXNldDtcclxuICAgICAgICAgICAgdGhpcy5oYW5kbGVTY3JvbGxSZXF1ZXN0ID0gKHJlcXVlc3QpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMucXVldWVkUmVxdWVzdCA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMucXVldWVkUmVxdWVzdCB8fCB7fSwgcmVxdWVzdCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRyYWluKCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGVtaXR0ZXIub24oJ19zY3JvbGxSZXF1ZXN0JywgdGhpcy5oYW5kbGVTY3JvbGxSZXF1ZXN0KTtcclxuICAgICAgICAgICAgdGhpcy5maXJlSW5pdGlhbFNjcm9sbCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkZXRhY2goKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZW1pdHRlci5vZmYoJ19zY3JvbGxSZXF1ZXN0JywgdGhpcy5oYW5kbGVTY3JvbGxSZXF1ZXN0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdXBkYXRlKGlzRGF0ZXNOZXcpIHtcclxuICAgICAgICAgICAgaWYgKGlzRGF0ZXNOZXcgJiYgdGhpcy5zY3JvbGxUaW1lUmVzZXQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZmlyZUluaXRpYWxTY3JvbGwoKTsgLy8gd2lsbCBkcmFpblxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kcmFpbigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZpcmVJbml0aWFsU2Nyb2xsKCkge1xyXG4gICAgICAgICAgICB0aGlzLmhhbmRsZVNjcm9sbFJlcXVlc3Qoe1xyXG4gICAgICAgICAgICAgICAgdGltZTogdGhpcy5zY3JvbGxUaW1lLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZHJhaW4oKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnF1ZXVlZFJlcXVlc3QgJiYgdGhpcy5leGVjRnVuYyh0aGlzLnF1ZXVlZFJlcXVlc3QpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnF1ZXVlZFJlcXVlc3QgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IFZpZXdDb250ZXh0VHlwZSA9IGNyZWF0ZUNvbnRleHQoe30pOyAvLyBmb3IgQ29tcG9uZW50c1xyXG4gICAgZnVuY3Rpb24gYnVpbGRWaWV3Q29udGV4dCh2aWV3U3BlYywgdmlld0FwaSwgdmlld09wdGlvbnMsIGRhdGVQcm9maWxlR2VuZXJhdG9yLCBkYXRlRW52LCB0aGVtZSwgcGx1Z2luSG9va3MsIGRpc3BhdGNoLCBnZXRDdXJyZW50RGF0YSwgZW1pdHRlciwgY2FsZW5kYXJBcGksIHJlZ2lzdGVySW50ZXJhY3RpdmVDb21wb25lbnQsIHVucmVnaXN0ZXJJbnRlcmFjdGl2ZUNvbXBvbmVudCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGRhdGVFbnYsXHJcbiAgICAgICAgICAgIG9wdGlvbnM6IHZpZXdPcHRpb25zLFxyXG4gICAgICAgICAgICBwbHVnaW5Ib29rcyxcclxuICAgICAgICAgICAgZW1pdHRlcixcclxuICAgICAgICAgICAgZGlzcGF0Y2gsXHJcbiAgICAgICAgICAgIGdldEN1cnJlbnREYXRhLFxyXG4gICAgICAgICAgICBjYWxlbmRhckFwaSxcclxuICAgICAgICAgICAgdmlld1NwZWMsXHJcbiAgICAgICAgICAgIHZpZXdBcGksXHJcbiAgICAgICAgICAgIGRhdGVQcm9maWxlR2VuZXJhdG9yLFxyXG4gICAgICAgICAgICB0aGVtZSxcclxuICAgICAgICAgICAgaXNSdGw6IHZpZXdPcHRpb25zLmRpcmVjdGlvbiA9PT0gJ3J0bCcsXHJcbiAgICAgICAgICAgIGFkZFJlc2l6ZUhhbmRsZXIoaGFuZGxlcikge1xyXG4gICAgICAgICAgICAgICAgZW1pdHRlci5vbignX3Jlc2l6ZScsIGhhbmRsZXIpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICByZW1vdmVSZXNpemVIYW5kbGVyKGhhbmRsZXIpIHtcclxuICAgICAgICAgICAgICAgIGVtaXR0ZXIub2ZmKCdfcmVzaXplJywgaGFuZGxlcik7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGNyZWF0ZVNjcm9sbFJlc3BvbmRlcihleGVjRnVuYykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTY3JvbGxSZXNwb25kZXIoZXhlY0Z1bmMsIGVtaXR0ZXIsIGNyZWF0ZUR1cmF0aW9uKHZpZXdPcHRpb25zLnNjcm9sbFRpbWUpLCB2aWV3T3B0aW9ucy5zY3JvbGxUaW1lUmVzZXQpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICByZWdpc3RlckludGVyYWN0aXZlQ29tcG9uZW50LFxyXG4gICAgICAgICAgICB1bnJlZ2lzdGVySW50ZXJhY3RpdmVDb21wb25lbnQsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICAvKiBlc2xpbnQgbWF4LWNsYXNzZXMtcGVyLWZpbGU6IG9mZiAqL1xyXG4gICAgY2xhc3MgUHVyZUNvbXBvbmVudCBleHRlbmRzIHgkMSB7XHJcbiAgICAgICAgc2hvdWxkQ29tcG9uZW50VXBkYXRlKG5leHRQcm9wcywgbmV4dFN0YXRlKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmRlYnVnKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coZ2V0VW5lcXVhbFByb3BzKG5leHRQcm9wcywgdGhpcy5wcm9wcyksIGdldFVuZXF1YWxQcm9wcyhuZXh0U3RhdGUsIHRoaXMuc3RhdGUpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gIWNvbXBhcmVPYmpzKHRoaXMucHJvcHMsIG5leHRQcm9wcywgdGhpcy5wcm9wRXF1YWxpdHkpIHx8XHJcbiAgICAgICAgICAgICAgICAhY29tcGFyZU9ianModGhpcy5zdGF0ZSwgbmV4dFN0YXRlLCB0aGlzLnN0YXRlRXF1YWxpdHkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBIQUNLIGZvciBmcmVha2luJyBSZWFjdCBTdHJpY3RNb2RlXHJcbiAgICAgICAgc2FmZVNldFN0YXRlKG5ld1N0YXRlKSB7XHJcbiAgICAgICAgICAgIGlmICghY29tcGFyZU9ianModGhpcy5zdGF0ZSwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLnN0YXRlKSwgbmV3U3RhdGUpLCB0aGlzLnN0YXRlRXF1YWxpdHkpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKG5ld1N0YXRlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIFB1cmVDb21wb25lbnQuYWRkUHJvcHNFcXVhbGl0eSA9IGFkZFByb3BzRXF1YWxpdHk7XHJcbiAgICBQdXJlQ29tcG9uZW50LmFkZFN0YXRlRXF1YWxpdHkgPSBhZGRTdGF0ZUVxdWFsaXR5O1xyXG4gICAgUHVyZUNvbXBvbmVudC5jb250ZXh0VHlwZSA9IFZpZXdDb250ZXh0VHlwZTtcclxuICAgIFB1cmVDb21wb25lbnQucHJvdG90eXBlLnByb3BFcXVhbGl0eSA9IHt9O1xyXG4gICAgUHVyZUNvbXBvbmVudC5wcm90b3R5cGUuc3RhdGVFcXVhbGl0eSA9IHt9O1xyXG4gICAgY2xhc3MgQmFzZUNvbXBvbmVudCBleHRlbmRzIFB1cmVDb21wb25lbnQge1xyXG4gICAgfVxyXG4gICAgQmFzZUNvbXBvbmVudC5jb250ZXh0VHlwZSA9IFZpZXdDb250ZXh0VHlwZTtcclxuICAgIGZ1bmN0aW9uIGFkZFByb3BzRXF1YWxpdHkocHJvcEVxdWFsaXR5KSB7XHJcbiAgICAgICAgbGV0IGhhc2ggPSBPYmplY3QuY3JlYXRlKHRoaXMucHJvdG90eXBlLnByb3BFcXVhbGl0eSk7XHJcbiAgICAgICAgT2JqZWN0LmFzc2lnbihoYXNoLCBwcm9wRXF1YWxpdHkpO1xyXG4gICAgICAgIHRoaXMucHJvdG90eXBlLnByb3BFcXVhbGl0eSA9IGhhc2g7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBhZGRTdGF0ZUVxdWFsaXR5KHN0YXRlRXF1YWxpdHkpIHtcclxuICAgICAgICBsZXQgaGFzaCA9IE9iamVjdC5jcmVhdGUodGhpcy5wcm90b3R5cGUuc3RhdGVFcXVhbGl0eSk7XHJcbiAgICAgICAgT2JqZWN0LmFzc2lnbihoYXNoLCBzdGF0ZUVxdWFsaXR5KTtcclxuICAgICAgICB0aGlzLnByb3RvdHlwZS5zdGF0ZUVxdWFsaXR5ID0gaGFzaDtcclxuICAgIH1cclxuICAgIC8vIHVzZSBvdGhlciBvbmVcclxuICAgIGZ1bmN0aW9uIHNldFJlZihyZWYsIGN1cnJlbnQpIHtcclxuICAgICAgICBpZiAodHlwZW9mIHJlZiA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICByZWYoY3VycmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHJlZikge1xyXG4gICAgICAgICAgICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMzAyOVxyXG4gICAgICAgICAgICByZWYuY3VycmVudCA9IGN1cnJlbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qXHJcbiAgICBhbiBJTlRFUkFDVEFCTEUgZGF0ZSBjb21wb25lbnRcclxuXHJcbiAgICBQVVJQT1NFUzpcclxuICAgIC0gaG9vayB1cCB0byBmZywgZmlsbCwgYW5kIG1pcnJvciByZW5kZXJlcnNcclxuICAgIC0gaW50ZXJmYWNlIGZvciBkcmFnZ2luZyBhbmQgaGl0c1xyXG4gICAgKi9cclxuICAgIGNsYXNzIERhdGVDb21wb25lbnQgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcclxuICAgICAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgdGhpcy51aWQgPSBndWlkKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEhpdCBTeXN0ZW1cclxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgICAgIHByZXBhcmVIaXRzKCkge1xyXG4gICAgICAgIH1cclxuICAgICAgICBxdWVyeUhpdChwb3NpdGlvbkxlZnQsIHBvc2l0aW9uVG9wLCBlbFdpZHRoLCBlbEhlaWdodCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDsgLy8gdGhpcyBzaG91bGQgYmUgYWJzdHJhY3RcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gUG9pbnRlciBJbnRlcmFjdGlvbiBVdGlsc1xyXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAgICAgaXNWYWxpZFNlZ0Rvd25FbChlbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gIXRoaXMucHJvcHMuZXZlbnREcmFnICYmIC8vIEhBQ0tcclxuICAgICAgICAgICAgICAgICF0aGlzLnByb3BzLmV2ZW50UmVzaXplICYmIC8vIEhBQ0tcclxuICAgICAgICAgICAgICAgICFlbGVtZW50Q2xvc2VzdChlbCwgJy5mYy1ldmVudC1taXJyb3InKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaXNWYWxpZERhdGVEb3duRWwoZWwpIHtcclxuICAgICAgICAgICAgcmV0dXJuICFlbGVtZW50Q2xvc2VzdChlbCwgJy5mYy1ldmVudDpub3QoLmZjLWJnLWV2ZW50KScpICYmXHJcbiAgICAgICAgICAgICAgICAhZWxlbWVudENsb3Nlc3QoZWwsICcuZmMtbW9yZS1saW5rJykgJiYgLy8gYSBcIm1vcmUuLlwiIGxpbmtcclxuICAgICAgICAgICAgICAgICFlbGVtZW50Q2xvc2VzdChlbCwgJ2FbZGF0YS1uYXZsaW5rXScpICYmIC8vIGEgY2xpY2thYmxlIG5hdiBsaW5rXHJcbiAgICAgICAgICAgICAgICAhZWxlbWVudENsb3Nlc3QoZWwsICcuZmMtcG9wb3ZlcicpOyAvLyBoYWNrXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHJlZHVjZUN1cnJlbnREYXRlKGN1cnJlbnREYXRlLCBhY3Rpb24pIHtcclxuICAgICAgICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgJ0NIQU5HRV9EQVRFJzpcclxuICAgICAgICAgICAgICAgIHJldHVybiBhY3Rpb24uZGF0ZU1hcmtlcjtcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHJldHVybiBjdXJyZW50RGF0ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBnZXRJbml0aWFsRGF0ZShvcHRpb25zLCBkYXRlRW52KSB7XHJcbiAgICAgICAgbGV0IGluaXRpYWxEYXRlSW5wdXQgPSBvcHRpb25zLmluaXRpYWxEYXRlO1xyXG4gICAgICAgIC8vIGNvbXB1dGUgdGhlIGluaXRpYWwgYW1iaWctdGltZXpvbmUgZGF0ZVxyXG4gICAgICAgIGlmIChpbml0aWFsRGF0ZUlucHV0ICE9IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGRhdGVFbnYuY3JlYXRlTWFya2VyKGluaXRpYWxEYXRlSW5wdXQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZ2V0Tm93KG9wdGlvbnMubm93LCBkYXRlRW52KTsgLy8gZ2V0Tm93IGFscmVhZHkgcmV0dXJucyB1bnpvbmVkXHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBnZXROb3cobm93SW5wdXQsIGRhdGVFbnYpIHtcclxuICAgICAgICBpZiAodHlwZW9mIG5vd0lucHV0ID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIG5vd0lucHV0ID0gbm93SW5wdXQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG5vd0lucHV0ID09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGRhdGVFbnYuY3JlYXRlTm93TWFya2VyKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkYXRlRW52LmNyZWF0ZU1hcmtlcihub3dJbnB1dCk7XHJcbiAgICB9XHJcblxyXG4gICAgY2xhc3MgRGF0ZVByb2ZpbGVHZW5lcmF0b3Ige1xyXG4gICAgICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJvcHMgPSBwcm9wcztcclxuICAgICAgICAgICAgdGhpcy5ub3dEYXRlID0gZ2V0Tm93KHByb3BzLm5vd0lucHV0LCBwcm9wcy5kYXRlRW52KTtcclxuICAgICAgICAgICAgdGhpcy5pbml0SGlkZGVuRGF5cygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKiBEYXRlIFJhbmdlIENvbXB1dGF0aW9uXHJcbiAgICAgICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgICAgICAvLyBCdWlsZHMgYSBzdHJ1Y3R1cmUgd2l0aCBpbmZvIGFib3V0IHdoYXQgdGhlIGRhdGVzL3JhbmdlcyB3aWxsIGJlIGZvciB0aGUgXCJwcmV2XCIgdmlldy5cclxuICAgICAgICBidWlsZFByZXYoY3VycmVudERhdGVQcm9maWxlLCBjdXJyZW50RGF0ZSwgZm9yY2VUb1ZhbGlkKSB7XHJcbiAgICAgICAgICAgIGxldCB7IGRhdGVFbnYgfSA9IHRoaXMucHJvcHM7XHJcbiAgICAgICAgICAgIGxldCBwcmV2RGF0ZSA9IGRhdGVFbnYuc3VidHJhY3QoZGF0ZUVudi5zdGFydE9mKGN1cnJlbnREYXRlLCBjdXJyZW50RGF0ZVByb2ZpbGUuY3VycmVudFJhbmdlVW5pdCksIC8vIGltcG9ydGFudCBmb3Igc3RhcnQtb2YtbW9udGhcclxuICAgICAgICAgICAgY3VycmVudERhdGVQcm9maWxlLmRhdGVJbmNyZW1lbnQpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5idWlsZChwcmV2RGF0ZSwgLTEsIGZvcmNlVG9WYWxpZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEJ1aWxkcyBhIHN0cnVjdHVyZSB3aXRoIGluZm8gYWJvdXQgd2hhdCB0aGUgZGF0ZXMvcmFuZ2VzIHdpbGwgYmUgZm9yIHRoZSBcIm5leHRcIiB2aWV3LlxyXG4gICAgICAgIGJ1aWxkTmV4dChjdXJyZW50RGF0ZVByb2ZpbGUsIGN1cnJlbnREYXRlLCBmb3JjZVRvVmFsaWQpIHtcclxuICAgICAgICAgICAgbGV0IHsgZGF0ZUVudiB9ID0gdGhpcy5wcm9wcztcclxuICAgICAgICAgICAgbGV0IG5leHREYXRlID0gZGF0ZUVudi5hZGQoZGF0ZUVudi5zdGFydE9mKGN1cnJlbnREYXRlLCBjdXJyZW50RGF0ZVByb2ZpbGUuY3VycmVudFJhbmdlVW5pdCksIC8vIGltcG9ydGFudCBmb3Igc3RhcnQtb2YtbW9udGhcclxuICAgICAgICAgICAgY3VycmVudERhdGVQcm9maWxlLmRhdGVJbmNyZW1lbnQpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5idWlsZChuZXh0RGF0ZSwgMSwgZm9yY2VUb1ZhbGlkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQnVpbGRzIGEgc3RydWN0dXJlIGhvbGRpbmcgZGF0ZXMvcmFuZ2VzIGZvciByZW5kZXJpbmcgYXJvdW5kIHRoZSBnaXZlbiBkYXRlLlxyXG4gICAgICAgIC8vIE9wdGlvbmFsIGRpcmVjdGlvbiBwYXJhbSBpbmRpY2F0ZXMgd2hldGhlciB0aGUgZGF0ZSBpcyBiZWluZyBpbmNyZW1lbnRlZC9kZWNyZW1lbnRlZFxyXG4gICAgICAgIC8vIGZyb20gaXRzIHByZXZpb3VzIHZhbHVlLiBkZWNyZW1lbnRlZCA9IC0xLCBpbmNyZW1lbnRlZCA9IDEgKGRlZmF1bHQpLlxyXG4gICAgICAgIGJ1aWxkKGN1cnJlbnREYXRlLCBkaXJlY3Rpb24sIGZvcmNlVG9WYWxpZCA9IHRydWUpIHtcclxuICAgICAgICAgICAgbGV0IHsgcHJvcHMgfSA9IHRoaXM7XHJcbiAgICAgICAgICAgIGxldCB2YWxpZFJhbmdlO1xyXG4gICAgICAgICAgICBsZXQgY3VycmVudEluZm87XHJcbiAgICAgICAgICAgIGxldCBpc1JhbmdlQWxsRGF5O1xyXG4gICAgICAgICAgICBsZXQgcmVuZGVyUmFuZ2U7XHJcbiAgICAgICAgICAgIGxldCBhY3RpdmVSYW5nZTtcclxuICAgICAgICAgICAgbGV0IGlzVmFsaWQ7XHJcbiAgICAgICAgICAgIHZhbGlkUmFuZ2UgPSB0aGlzLmJ1aWxkVmFsaWRSYW5nZSgpO1xyXG4gICAgICAgICAgICB2YWxpZFJhbmdlID0gdGhpcy50cmltSGlkZGVuRGF5cyh2YWxpZFJhbmdlKTtcclxuICAgICAgICAgICAgaWYgKGZvcmNlVG9WYWxpZCkge1xyXG4gICAgICAgICAgICAgICAgY3VycmVudERhdGUgPSBjb25zdHJhaW5NYXJrZXJUb1JhbmdlKGN1cnJlbnREYXRlLCB2YWxpZFJhbmdlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjdXJyZW50SW5mbyA9IHRoaXMuYnVpbGRDdXJyZW50UmFuZ2VJbmZvKGN1cnJlbnREYXRlLCBkaXJlY3Rpb24pO1xyXG4gICAgICAgICAgICBpc1JhbmdlQWxsRGF5ID0gL14oeWVhcnxtb250aHx3ZWVrfGRheSkkLy50ZXN0KGN1cnJlbnRJbmZvLnVuaXQpO1xyXG4gICAgICAgICAgICByZW5kZXJSYW5nZSA9IHRoaXMuYnVpbGRSZW5kZXJSYW5nZSh0aGlzLnRyaW1IaWRkZW5EYXlzKGN1cnJlbnRJbmZvLnJhbmdlKSwgY3VycmVudEluZm8udW5pdCwgaXNSYW5nZUFsbERheSk7XHJcbiAgICAgICAgICAgIHJlbmRlclJhbmdlID0gdGhpcy50cmltSGlkZGVuRGF5cyhyZW5kZXJSYW5nZSk7XHJcbiAgICAgICAgICAgIGFjdGl2ZVJhbmdlID0gcmVuZGVyUmFuZ2U7XHJcbiAgICAgICAgICAgIGlmICghcHJvcHMuc2hvd05vbkN1cnJlbnREYXRlcykge1xyXG4gICAgICAgICAgICAgICAgYWN0aXZlUmFuZ2UgPSBpbnRlcnNlY3RSYW5nZXMoYWN0aXZlUmFuZ2UsIGN1cnJlbnRJbmZvLnJhbmdlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBhY3RpdmVSYW5nZSA9IHRoaXMuYWRqdXN0QWN0aXZlUmFuZ2UoYWN0aXZlUmFuZ2UpO1xyXG4gICAgICAgICAgICBhY3RpdmVSYW5nZSA9IGludGVyc2VjdFJhbmdlcyhhY3RpdmVSYW5nZSwgdmFsaWRSYW5nZSk7IC8vIG1pZ2h0IHJldHVybiBudWxsXHJcbiAgICAgICAgICAgIC8vIGl0J3MgaW52YWxpZCBpZiB0aGUgb3JpZ2luYWxseSByZXF1ZXN0ZWQgZGF0ZSBpcyBub3QgY29udGFpbmVkLFxyXG4gICAgICAgICAgICAvLyBvciBpZiB0aGUgcmFuZ2UgaXMgY29tcGxldGVseSBvdXRzaWRlIG9mIHRoZSB2YWxpZCByYW5nZS5cclxuICAgICAgICAgICAgaXNWYWxpZCA9IHJhbmdlc0ludGVyc2VjdChjdXJyZW50SW5mby5yYW5nZSwgdmFsaWRSYW5nZSk7XHJcbiAgICAgICAgICAgIC8vIEhBQ0s6IGNvbnN0cmFpbiB0byByZW5kZXItcmFuZ2Ugc28gYGN1cnJlbnREYXRlYCBpcyBtb3JlIHVzZWZ1bCB0byB2aWV3IHJlbmRlcmluZ1xyXG4gICAgICAgICAgICBpZiAoIXJhbmdlQ29udGFpbnNNYXJrZXIocmVuZGVyUmFuZ2UsIGN1cnJlbnREYXRlKSkge1xyXG4gICAgICAgICAgICAgICAgY3VycmVudERhdGUgPSByZW5kZXJSYW5nZS5zdGFydDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgY3VycmVudERhdGUsXHJcbiAgICAgICAgICAgICAgICAvLyBjb25zdHJhaW50IGZvciB3aGVyZSBwcmV2L25leHQgb3BlcmF0aW9ucyBjYW4gZ28gYW5kIHdoZXJlIGV2ZW50cyBjYW4gYmUgZHJhZ2dlZC9yZXNpemVkIHRvLlxyXG4gICAgICAgICAgICAgICAgLy8gYW4gb2JqZWN0IHdpdGggb3B0aW9uYWwgc3RhcnQgYW5kIGVuZCBwcm9wZXJ0aWVzLlxyXG4gICAgICAgICAgICAgICAgdmFsaWRSYW5nZSxcclxuICAgICAgICAgICAgICAgIC8vIHJhbmdlIHRoZSB2aWV3IGlzIGZvcm1hbGx5IHJlc3BvbnNpYmxlIGZvci5cclxuICAgICAgICAgICAgICAgIC8vIGZvciBleGFtcGxlLCBhIG1vbnRoIHZpZXcgbWlnaHQgaGF2ZSAxc3QtMzFzdCwgZXhjbHVkaW5nIHBhZGRlZCBkYXRlc1xyXG4gICAgICAgICAgICAgICAgY3VycmVudFJhbmdlOiBjdXJyZW50SW5mby5yYW5nZSxcclxuICAgICAgICAgICAgICAgIC8vIG5hbWUgb2YgbGFyZ2VzdCB1bml0IGJlaW5nIGRpc3BsYXllZCwgbGlrZSBcIm1vbnRoXCIgb3IgXCJ3ZWVrXCJcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRSYW5nZVVuaXQ6IGN1cnJlbnRJbmZvLnVuaXQsXHJcbiAgICAgICAgICAgICAgICBpc1JhbmdlQWxsRGF5LFxyXG4gICAgICAgICAgICAgICAgLy8gZGF0ZXMgdGhhdCBkaXNwbGF5IGV2ZW50cyBhbmQgYWNjZXB0IGRyYWctbi1kcm9wXHJcbiAgICAgICAgICAgICAgICAvLyB3aWxsIGJlIGBudWxsYCBpZiBubyBkYXRlcyBhY2NlcHQgZXZlbnRzXHJcbiAgICAgICAgICAgICAgICBhY3RpdmVSYW5nZSxcclxuICAgICAgICAgICAgICAgIC8vIGRhdGUgcmFuZ2Ugd2l0aCBhIHJlbmRlcmVkIHNrZWxldG9uXHJcbiAgICAgICAgICAgICAgICAvLyBpbmNsdWRlcyBub3QtYWN0aXZlIGRheXMgdGhhdCBuZWVkIHNvbWUgc29ydCBvZiBET01cclxuICAgICAgICAgICAgICAgIHJlbmRlclJhbmdlLFxyXG4gICAgICAgICAgICAgICAgLy8gRHVyYXRpb24gb2JqZWN0IHRoYXQgZGVub3RlcyB0aGUgZmlyc3QgdmlzaWJsZSB0aW1lIG9mIGFueSBnaXZlbiBkYXlcclxuICAgICAgICAgICAgICAgIHNsb3RNaW5UaW1lOiBwcm9wcy5zbG90TWluVGltZSxcclxuICAgICAgICAgICAgICAgIC8vIER1cmF0aW9uIG9iamVjdCB0aGF0IGRlbm90ZXMgdGhlIGV4Y2x1c2l2ZSB2aXNpYmxlIGVuZCB0aW1lIG9mIGFueSBnaXZlbiBkYXlcclxuICAgICAgICAgICAgICAgIHNsb3RNYXhUaW1lOiBwcm9wcy5zbG90TWF4VGltZSxcclxuICAgICAgICAgICAgICAgIGlzVmFsaWQsXHJcbiAgICAgICAgICAgICAgICAvLyBob3cgZmFyIHRoZSBjdXJyZW50IGRhdGUgd2lsbCBtb3ZlIGZvciBhIHByZXYvbmV4dCBvcGVyYXRpb25cclxuICAgICAgICAgICAgICAgIGRhdGVJbmNyZW1lbnQ6IHRoaXMuYnVpbGREYXRlSW5jcmVtZW50KGN1cnJlbnRJbmZvLmR1cmF0aW9uKSxcclxuICAgICAgICAgICAgICAgIC8vIHBhc3MgYSBmYWxsYmFjayAobWlnaHQgYmUgbnVsbCkgXlxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBCdWlsZHMgYW4gb2JqZWN0IHdpdGggb3B0aW9uYWwgc3RhcnQvZW5kIHByb3BlcnRpZXMuXHJcbiAgICAgICAgLy8gSW5kaWNhdGVzIHRoZSBtaW5pbXVtL21heGltdW0gZGF0ZXMgdG8gZGlzcGxheS5cclxuICAgICAgICAvLyBub3QgcmVzcG9uc2libGUgZm9yIHRyaW1taW5nIGhpZGRlbiBkYXlzLlxyXG4gICAgICAgIGJ1aWxkVmFsaWRSYW5nZSgpIHtcclxuICAgICAgICAgICAgbGV0IGlucHV0ID0gdGhpcy5wcm9wcy52YWxpZFJhbmdlSW5wdXQ7XHJcbiAgICAgICAgICAgIGxldCBzaW1wbGVJbnB1dCA9IHR5cGVvZiBpbnB1dCA9PT0gJ2Z1bmN0aW9uJ1xyXG4gICAgICAgICAgICAgICAgPyBpbnB1dC5jYWxsKHRoaXMucHJvcHMuY2FsZW5kYXJBcGksIHRoaXMubm93RGF0ZSlcclxuICAgICAgICAgICAgICAgIDogaW5wdXQ7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlZmluZVJhbmdlKHNpbXBsZUlucHV0KSB8fFxyXG4gICAgICAgICAgICAgICAgeyBzdGFydDogbnVsbCwgZW5kOiBudWxsIH07IC8vIGNvbXBsZXRlbHkgb3Blbi1lbmRlZFxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBCdWlsZHMgYSBzdHJ1Y3R1cmUgd2l0aCBpbmZvIGFib3V0IHRoZSBcImN1cnJlbnRcIiByYW5nZSwgdGhlIHJhbmdlIHRoYXQgaXNcclxuICAgICAgICAvLyBoaWdobGlnaHRlZCBhcyBiZWluZyB0aGUgY3VycmVudCBtb250aCBmb3IgZXhhbXBsZS5cclxuICAgICAgICAvLyBTZWUgYnVpbGQoKSBmb3IgYSBkZXNjcmlwdGlvbiBvZiBgZGlyZWN0aW9uYC5cclxuICAgICAgICAvLyBHdWFyYW50ZWVkIHRvIGhhdmUgYHJhbmdlYCBhbmQgYHVuaXRgIHByb3BlcnRpZXMuIGBkdXJhdGlvbmAgaXMgb3B0aW9uYWwuXHJcbiAgICAgICAgYnVpbGRDdXJyZW50UmFuZ2VJbmZvKGRhdGUsIGRpcmVjdGlvbikge1xyXG4gICAgICAgICAgICBsZXQgeyBwcm9wcyB9ID0gdGhpcztcclxuICAgICAgICAgICAgbGV0IGR1cmF0aW9uID0gbnVsbDtcclxuICAgICAgICAgICAgbGV0IHVuaXQgPSBudWxsO1xyXG4gICAgICAgICAgICBsZXQgcmFuZ2UgPSBudWxsO1xyXG4gICAgICAgICAgICBsZXQgZGF5Q291bnQ7XHJcbiAgICAgICAgICAgIGlmIChwcm9wcy5kdXJhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgZHVyYXRpb24gPSBwcm9wcy5kdXJhdGlvbjtcclxuICAgICAgICAgICAgICAgIHVuaXQgPSBwcm9wcy5kdXJhdGlvblVuaXQ7XHJcbiAgICAgICAgICAgICAgICByYW5nZSA9IHRoaXMuYnVpbGRSYW5nZUZyb21EdXJhdGlvbihkYXRlLCBkaXJlY3Rpb24sIGR1cmF0aW9uLCB1bml0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICgoZGF5Q291bnQgPSB0aGlzLnByb3BzLmRheUNvdW50KSkge1xyXG4gICAgICAgICAgICAgICAgdW5pdCA9ICdkYXknO1xyXG4gICAgICAgICAgICAgICAgcmFuZ2UgPSB0aGlzLmJ1aWxkUmFuZ2VGcm9tRGF5Q291bnQoZGF0ZSwgZGlyZWN0aW9uLCBkYXlDb3VudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoKHJhbmdlID0gdGhpcy5idWlsZEN1c3RvbVZpc2libGVSYW5nZShkYXRlKSkpIHtcclxuICAgICAgICAgICAgICAgIHVuaXQgPSBwcm9wcy5kYXRlRW52LmdyZWF0ZXN0V2hvbGVVbml0KHJhbmdlLnN0YXJ0LCByYW5nZS5lbmQpLnVuaXQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBkdXJhdGlvbiA9IHRoaXMuZ2V0RmFsbGJhY2tEdXJhdGlvbigpO1xyXG4gICAgICAgICAgICAgICAgdW5pdCA9IGdyZWF0ZXN0RHVyYXRpb25EZW5vbWluYXRvcihkdXJhdGlvbikudW5pdDtcclxuICAgICAgICAgICAgICAgIHJhbmdlID0gdGhpcy5idWlsZFJhbmdlRnJvbUR1cmF0aW9uKGRhdGUsIGRpcmVjdGlvbiwgZHVyYXRpb24sIHVuaXQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB7IGR1cmF0aW9uLCB1bml0LCByYW5nZSB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBnZXRGYWxsYmFja0R1cmF0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlRHVyYXRpb24oeyBkYXk6IDEgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFJldHVybnMgYSBuZXcgYWN0aXZlUmFuZ2UgdG8gaGF2ZSB0aW1lIHZhbHVlcyAodW4tYW1iaWd1YXRlKVxyXG4gICAgICAgIC8vIHNsb3RNaW5UaW1lIG9yIHNsb3RNYXhUaW1lIGNhdXNlcyB0aGUgcmFuZ2UgdG8gZXhwYW5kLlxyXG4gICAgICAgIGFkanVzdEFjdGl2ZVJhbmdlKHJhbmdlKSB7XHJcbiAgICAgICAgICAgIGxldCB7IGRhdGVFbnYsIHVzZXNNaW5NYXhUaW1lLCBzbG90TWluVGltZSwgc2xvdE1heFRpbWUgfSA9IHRoaXMucHJvcHM7XHJcbiAgICAgICAgICAgIGxldCB7IHN0YXJ0LCBlbmQgfSA9IHJhbmdlO1xyXG4gICAgICAgICAgICBpZiAodXNlc01pbk1heFRpbWUpIHtcclxuICAgICAgICAgICAgICAgIC8vIGV4cGFuZCBhY3RpdmUgcmFuZ2UgaWYgc2xvdE1pblRpbWUgaXMgbmVnYXRpdmUgKHdoeSBub3Qgd2hlbiBwb3NpdGl2ZT8pXHJcbiAgICAgICAgICAgICAgICBpZiAoYXNSb3VnaERheXMoc2xvdE1pblRpbWUpIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gc3RhcnRPZkRheShzdGFydCk7IC8vIG5lY2Vzc2FyeT9cclxuICAgICAgICAgICAgICAgICAgICBzdGFydCA9IGRhdGVFbnYuYWRkKHN0YXJ0LCBzbG90TWluVGltZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBleHBhbmQgYWN0aXZlIHJhbmdlIGlmIHNsb3RNYXhUaW1lIGlzIGJleW9uZCBvbmUgZGF5ICh3aHkgbm90IHdoZW4gbmVnYXRpdmU/KVxyXG4gICAgICAgICAgICAgICAgaWYgKGFzUm91Z2hEYXlzKHNsb3RNYXhUaW1lKSA+IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICBlbmQgPSBzdGFydE9mRGF5KGVuZCk7IC8vIG5lY2Vzc2FyeT9cclxuICAgICAgICAgICAgICAgICAgICBlbmQgPSBhZGREYXlzKGVuZCwgLTEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGVuZCA9IGRhdGVFbnYuYWRkKGVuZCwgc2xvdE1heFRpbWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB7IHN0YXJ0LCBlbmQgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQnVpbGRzIHRoZSBcImN1cnJlbnRcIiByYW5nZSB3aGVuIGl0IGlzIHNwZWNpZmllZCBhcyBhbiBleHBsaWNpdCBkdXJhdGlvbi5cclxuICAgICAgICAvLyBgdW5pdGAgaXMgdGhlIGFscmVhZHktY29tcHV0ZWQgZ3JlYXRlc3REdXJhdGlvbkRlbm9taW5hdG9yIHVuaXQgb2YgZHVyYXRpb24uXHJcbiAgICAgICAgYnVpbGRSYW5nZUZyb21EdXJhdGlvbihkYXRlLCBkaXJlY3Rpb24sIGR1cmF0aW9uLCB1bml0KSB7XHJcbiAgICAgICAgICAgIGxldCB7IGRhdGVFbnYsIGRhdGVBbGlnbm1lbnQgfSA9IHRoaXMucHJvcHM7XHJcbiAgICAgICAgICAgIGxldCBzdGFydDtcclxuICAgICAgICAgICAgbGV0IGVuZDtcclxuICAgICAgICAgICAgbGV0IHJlcztcclxuICAgICAgICAgICAgLy8gY29tcHV0ZSB3aGF0IHRoZSBhbGlnbm1lbnQgc2hvdWxkIGJlXHJcbiAgICAgICAgICAgIGlmICghZGF0ZUFsaWdubWVudCkge1xyXG4gICAgICAgICAgICAgICAgbGV0IHsgZGF0ZUluY3JlbWVudCB9ID0gdGhpcy5wcm9wcztcclxuICAgICAgICAgICAgICAgIGlmIChkYXRlSW5jcmVtZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdXNlIHRoZSBzbWFsbGVyIG9mIHRoZSB0d28gdW5pdHNcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYXNSb3VnaE1zKGRhdGVJbmNyZW1lbnQpIDwgYXNSb3VnaE1zKGR1cmF0aW9uKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRlQWxpZ25tZW50ID0gZ3JlYXRlc3REdXJhdGlvbkRlbm9taW5hdG9yKGRhdGVJbmNyZW1lbnQpLnVuaXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRlQWxpZ25tZW50ID0gdW5pdDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBkYXRlQWxpZ25tZW50ID0gdW5pdDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBpZiB0aGUgdmlldyBkaXNwbGF5cyBhIHNpbmdsZSBkYXkgb3Igc21hbGxlclxyXG4gICAgICAgICAgICBpZiAoYXNSb3VnaERheXMoZHVyYXRpb24pIDw9IDEpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzSGlkZGVuRGF5KHN0YXJ0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gdGhpcy5za2lwSGlkZGVuRGF5cyhzdGFydCwgZGlyZWN0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICBzdGFydCA9IHN0YXJ0T2ZEYXkoc3RhcnQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGNvbXB1dGVSZXMoKSB7XHJcbiAgICAgICAgICAgICAgICBzdGFydCA9IGRhdGVFbnYuc3RhcnRPZihkYXRlLCBkYXRlQWxpZ25tZW50KTtcclxuICAgICAgICAgICAgICAgIGVuZCA9IGRhdGVFbnYuYWRkKHN0YXJ0LCBkdXJhdGlvbik7XHJcbiAgICAgICAgICAgICAgICByZXMgPSB7IHN0YXJ0LCBlbmQgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb21wdXRlUmVzKCk7XHJcbiAgICAgICAgICAgIC8vIGlmIHJhbmdlIGlzIGNvbXBsZXRlbHkgZW52ZWxvcGVkIGJ5IGhpZGRlbiBkYXlzLCBnbyBwYXN0IHRoZSBoaWRkZW4gZGF5c1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMudHJpbUhpZGRlbkRheXMocmVzKSkge1xyXG4gICAgICAgICAgICAgICAgZGF0ZSA9IHRoaXMuc2tpcEhpZGRlbkRheXMoZGF0ZSwgZGlyZWN0aW9uKTtcclxuICAgICAgICAgICAgICAgIGNvbXB1dGVSZXMoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBCdWlsZHMgdGhlIFwiY3VycmVudFwiIHJhbmdlIHdoZW4gYSBkYXlDb3VudCBpcyBzcGVjaWZpZWQuXHJcbiAgICAgICAgYnVpbGRSYW5nZUZyb21EYXlDb3VudChkYXRlLCBkaXJlY3Rpb24sIGRheUNvdW50KSB7XHJcbiAgICAgICAgICAgIGxldCB7IGRhdGVFbnYsIGRhdGVBbGlnbm1lbnQgfSA9IHRoaXMucHJvcHM7XHJcbiAgICAgICAgICAgIGxldCBydW5uaW5nQ291bnQgPSAwO1xyXG4gICAgICAgICAgICBsZXQgc3RhcnQgPSBkYXRlO1xyXG4gICAgICAgICAgICBsZXQgZW5kO1xyXG4gICAgICAgICAgICBpZiAoZGF0ZUFsaWdubWVudCkge1xyXG4gICAgICAgICAgICAgICAgc3RhcnQgPSBkYXRlRW52LnN0YXJ0T2Yoc3RhcnQsIGRhdGVBbGlnbm1lbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHN0YXJ0ID0gc3RhcnRPZkRheShzdGFydCk7XHJcbiAgICAgICAgICAgIHN0YXJ0ID0gdGhpcy5za2lwSGlkZGVuRGF5cyhzdGFydCwgZGlyZWN0aW9uKTtcclxuICAgICAgICAgICAgZW5kID0gc3RhcnQ7XHJcbiAgICAgICAgICAgIGRvIHtcclxuICAgICAgICAgICAgICAgIGVuZCA9IGFkZERheXMoZW5kLCAxKTtcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5pc0hpZGRlbkRheShlbmQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcnVubmluZ0NvdW50ICs9IDE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gd2hpbGUgKHJ1bm5pbmdDb3VudCA8IGRheUNvdW50KTtcclxuICAgICAgICAgICAgcmV0dXJuIHsgc3RhcnQsIGVuZCB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBCdWlsZHMgYSBub3JtYWxpemVkIHJhbmdlIG9iamVjdCBmb3IgdGhlIFwidmlzaWJsZVwiIHJhbmdlLFxyXG4gICAgICAgIC8vIHdoaWNoIGlzIGEgd2F5IHRvIGRlZmluZSB0aGUgY3VycmVudFJhbmdlIGFuZCBhY3RpdmVSYW5nZSBhdCB0aGUgc2FtZSB0aW1lLlxyXG4gICAgICAgIGJ1aWxkQ3VzdG9tVmlzaWJsZVJhbmdlKGRhdGUpIHtcclxuICAgICAgICAgICAgbGV0IHsgcHJvcHMgfSA9IHRoaXM7XHJcbiAgICAgICAgICAgIGxldCBpbnB1dCA9IHByb3BzLnZpc2libGVSYW5nZUlucHV0O1xyXG4gICAgICAgICAgICBsZXQgc2ltcGxlSW5wdXQgPSB0eXBlb2YgaW5wdXQgPT09ICdmdW5jdGlvbidcclxuICAgICAgICAgICAgICAgID8gaW5wdXQuY2FsbChwcm9wcy5jYWxlbmRhckFwaSwgcHJvcHMuZGF0ZUVudi50b0RhdGUoZGF0ZSkpXHJcbiAgICAgICAgICAgICAgICA6IGlucHV0O1xyXG4gICAgICAgICAgICBsZXQgcmFuZ2UgPSB0aGlzLnJlZmluZVJhbmdlKHNpbXBsZUlucHV0KTtcclxuICAgICAgICAgICAgaWYgKHJhbmdlICYmIChyYW5nZS5zdGFydCA9PSBudWxsIHx8IHJhbmdlLmVuZCA9PSBudWxsKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJhbmdlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBDb21wdXRlcyB0aGUgcmFuZ2UgdGhhdCB3aWxsIHJlcHJlc2VudCB0aGUgZWxlbWVudC9jZWxscyBmb3IgKnJlbmRlcmluZyosXHJcbiAgICAgICAgLy8gYnV0IHdoaWNoIG1heSBoYXZlIHZvaWRlZCBkYXlzL3RpbWVzLlxyXG4gICAgICAgIC8vIG5vdCByZXNwb25zaWJsZSBmb3IgdHJpbW1pbmcgaGlkZGVuIGRheXMuXHJcbiAgICAgICAgYnVpbGRSZW5kZXJSYW5nZShjdXJyZW50UmFuZ2UsIGN1cnJlbnRSYW5nZVVuaXQsIGlzUmFuZ2VBbGxEYXkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRSYW5nZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQ29tcHV0ZSB0aGUgZHVyYXRpb24gdmFsdWUgdGhhdCBzaG91bGQgYmUgYWRkZWQvc3Vic3RyYWN0ZWQgdG8gdGhlIGN1cnJlbnQgZGF0ZVxyXG4gICAgICAgIC8vIHdoZW4gYSBwcmV2L25leHQgb3BlcmF0aW9uIGhhcHBlbnMuXHJcbiAgICAgICAgYnVpbGREYXRlSW5jcmVtZW50KGZhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgIGxldCB7IGRhdGVJbmNyZW1lbnQgfSA9IHRoaXMucHJvcHM7XHJcbiAgICAgICAgICAgIGxldCBjdXN0b21BbGlnbm1lbnQ7XHJcbiAgICAgICAgICAgIGlmIChkYXRlSW5jcmVtZW50KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0ZUluY3JlbWVudDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoKGN1c3RvbUFsaWdubWVudCA9IHRoaXMucHJvcHMuZGF0ZUFsaWdubWVudCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVEdXJhdGlvbigxLCBjdXN0b21BbGlnbm1lbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChmYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbGxiYWNrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVEdXJhdGlvbih7IGRheXM6IDEgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlZmluZVJhbmdlKHJhbmdlSW5wdXQpIHtcclxuICAgICAgICAgICAgaWYgKHJhbmdlSW5wdXQpIHtcclxuICAgICAgICAgICAgICAgIGxldCByYW5nZSA9IHBhcnNlUmFuZ2UocmFuZ2VJbnB1dCwgdGhpcy5wcm9wcy5kYXRlRW52KTtcclxuICAgICAgICAgICAgICAgIGlmIChyYW5nZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlID0gY29tcHV0ZVZpc2libGVEYXlSYW5nZShyYW5nZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmFuZ2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qIEhpZGRlbiBEYXlzXHJcbiAgICAgICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgICAgICAvLyBJbml0aWFsaXplcyBpbnRlcm5hbCB2YXJpYWJsZXMgcmVsYXRlZCB0byBjYWxjdWxhdGluZyBoaWRkZW4gZGF5cy1vZi13ZWVrXHJcbiAgICAgICAgaW5pdEhpZGRlbkRheXMoKSB7XHJcbiAgICAgICAgICAgIGxldCBoaWRkZW5EYXlzID0gdGhpcy5wcm9wcy5oaWRkZW5EYXlzIHx8IFtdOyAvLyBhcnJheSBvZiBkYXktb2Ytd2VlayBpbmRpY2VzIHRoYXQgYXJlIGhpZGRlblxyXG4gICAgICAgICAgICBsZXQgaXNIaWRkZW5EYXlIYXNoID0gW107IC8vIGlzIHRoZSBkYXktb2Ytd2VlayBoaWRkZW4/IChoYXNoIHdpdGggZGF5LW9mLXdlZWstaW5kZXggLT4gYm9vbClcclxuICAgICAgICAgICAgbGV0IGRheUNudCA9IDA7XHJcbiAgICAgICAgICAgIGxldCBpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5wcm9wcy53ZWVrZW5kcyA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgIGhpZGRlbkRheXMucHVzaCgwLCA2KTsgLy8gMD1zdW5kYXksIDY9c2F0dXJkYXlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNzsgaSArPSAxKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIShpc0hpZGRlbkRheUhhc2hbaV0gPSBoaWRkZW5EYXlzLmluZGV4T2YoaSkgIT09IC0xKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRheUNudCArPSAxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghZGF5Q250KSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgaGlkZGVuRGF5cycpOyAvLyBhbGwgZGF5cyB3ZXJlIGhpZGRlbj8gYmFkLlxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuaXNIaWRkZW5EYXlIYXNoID0gaXNIaWRkZW5EYXlIYXNoO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBSZW1vdmUgZGF5cyBmcm9tIHRoZSBiZWdpbm5pbmcgYW5kIGVuZCBvZiB0aGUgcmFuZ2UgdGhhdCBhcmUgY29tcHV0ZWQgYXMgaGlkZGVuLlxyXG4gICAgICAgIC8vIElmIHRoZSB3aG9sZSByYW5nZSBpcyB0cmltbWVkIG9mZiwgcmV0dXJucyBudWxsXHJcbiAgICAgICAgdHJpbUhpZGRlbkRheXMocmFuZ2UpIHtcclxuICAgICAgICAgICAgbGV0IHsgc3RhcnQsIGVuZCB9ID0gcmFuZ2U7XHJcbiAgICAgICAgICAgIGlmIChzdGFydCkge1xyXG4gICAgICAgICAgICAgICAgc3RhcnQgPSB0aGlzLnNraXBIaWRkZW5EYXlzKHN0YXJ0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZW5kKSB7XHJcbiAgICAgICAgICAgICAgICBlbmQgPSB0aGlzLnNraXBIaWRkZW5EYXlzKGVuZCwgLTEsIHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChzdGFydCA9PSBudWxsIHx8IGVuZCA9PSBudWxsIHx8IHN0YXJ0IDwgZW5kKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4geyBzdGFydCwgZW5kIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIElzIHRoZSBjdXJyZW50IGRheSBoaWRkZW4/XHJcbiAgICAgICAgLy8gYGRheWAgaXMgYSBkYXktb2Ytd2VlayBpbmRleCAoMC02KSwgb3IgYSBEYXRlICh1c2VkIGZvciBVVEMpXHJcbiAgICAgICAgaXNIaWRkZW5EYXkoZGF5KSB7XHJcbiAgICAgICAgICAgIGlmIChkYXkgaW5zdGFuY2VvZiBEYXRlKSB7XHJcbiAgICAgICAgICAgICAgICBkYXkgPSBkYXkuZ2V0VVRDRGF5KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXNIaWRkZW5EYXlIYXNoW2RheV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEluY3JlbWVudGluZyB0aGUgY3VycmVudCBkYXkgdW50aWwgaXQgaXMgbm8gbG9uZ2VyIGEgaGlkZGVuIGRheSwgcmV0dXJuaW5nIGEgY29weS5cclxuICAgICAgICAvLyBET0VTIE5PVCBDT05TSURFUiB2YWxpZFJhbmdlIVxyXG4gICAgICAgIC8vIElmIHRoZSBpbml0aWFsIHZhbHVlIG9mIGBkYXRlYCBpcyBub3QgYSBoaWRkZW4gZGF5LCBkb24ndCBkbyBhbnl0aGluZy5cclxuICAgICAgICAvLyBQYXNzIGBpc0V4Y2x1c2l2ZWAgYXMgYHRydWVgIGlmIHlvdSBhcmUgZGVhbGluZyB3aXRoIGFuIGVuZCBkYXRlLlxyXG4gICAgICAgIC8vIGBpbmNgIGRlZmF1bHRzIHRvIGAxYCAoaW5jcmVtZW50IG9uZSBkYXkgZm9yd2FyZCBlYWNoIHRpbWUpXHJcbiAgICAgICAgc2tpcEhpZGRlbkRheXMoZGF0ZSwgaW5jID0gMSwgaXNFeGNsdXNpdmUgPSBmYWxzZSkge1xyXG4gICAgICAgICAgICB3aGlsZSAodGhpcy5pc0hpZGRlbkRheUhhc2hbKGRhdGUuZ2V0VVRDRGF5KCkgKyAoaXNFeGNsdXNpdmUgPyBpbmMgOiAwKSArIDcpICUgN10pIHtcclxuICAgICAgICAgICAgICAgIGRhdGUgPSBhZGREYXlzKGRhdGUsIGluYyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGRhdGU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHRyaWdnZXJEYXRlU2VsZWN0KHNlbGVjdGlvbiwgcGV2LCBjb250ZXh0KSB7XHJcbiAgICAgICAgY29udGV4dC5lbWl0dGVyLnRyaWdnZXIoJ3NlbGVjdCcsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgYnVpbGREYXRlU3BhbkFwaVdpdGhDb250ZXh0KHNlbGVjdGlvbiwgY29udGV4dCkpLCB7IGpzRXZlbnQ6IHBldiA/IHBldi5vcmlnRXZlbnQgOiBudWxsLCB2aWV3OiBjb250ZXh0LnZpZXdBcGkgfHwgY29udGV4dC5jYWxlbmRhckFwaS52aWV3IH0pKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHRyaWdnZXJEYXRlVW5zZWxlY3QocGV2LCBjb250ZXh0KSB7XHJcbiAgICAgICAgY29udGV4dC5lbWl0dGVyLnRyaWdnZXIoJ3Vuc2VsZWN0Jywge1xyXG4gICAgICAgICAgICBqc0V2ZW50OiBwZXYgPyBwZXYub3JpZ0V2ZW50IDogbnVsbCxcclxuICAgICAgICAgICAgdmlldzogY29udGV4dC52aWV3QXBpIHx8IGNvbnRleHQuY2FsZW5kYXJBcGkudmlldyxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGJ1aWxkRGF0ZVNwYW5BcGlXaXRoQ29udGV4dChkYXRlU3BhbiwgY29udGV4dCkge1xyXG4gICAgICAgIGxldCBwcm9wcyA9IHt9O1xyXG4gICAgICAgIGZvciAobGV0IHRyYW5zZm9ybSBvZiBjb250ZXh0LnBsdWdpbkhvb2tzLmRhdGVTcGFuVHJhbnNmb3Jtcykge1xyXG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHByb3BzLCB0cmFuc2Zvcm0oZGF0ZVNwYW4sIGNvbnRleHQpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgT2JqZWN0LmFzc2lnbihwcm9wcywgYnVpbGREYXRlU3BhbkFwaShkYXRlU3BhbiwgY29udGV4dC5kYXRlRW52KSk7XHJcbiAgICAgICAgcmV0dXJuIHByb3BzO1xyXG4gICAgfVxyXG4gICAgLy8gR2l2ZW4gYW4gZXZlbnQncyBhbGxEYXkgc3RhdHVzIGFuZCBzdGFydCBkYXRlLCByZXR1cm4gd2hhdCBpdHMgZmFsbGJhY2sgZW5kIGRhdGUgc2hvdWxkIGJlLlxyXG4gICAgLy8gVE9ETzogcmVuYW1lIHRvIGNvbXB1dGVEZWZhdWx0RXZlbnRFbmRcclxuICAgIGZ1bmN0aW9uIGdldERlZmF1bHRFdmVudEVuZChhbGxEYXksIG1hcmtlciwgY29udGV4dCkge1xyXG4gICAgICAgIGxldCB7IGRhdGVFbnYsIG9wdGlvbnMgfSA9IGNvbnRleHQ7XHJcbiAgICAgICAgbGV0IGVuZCA9IG1hcmtlcjtcclxuICAgICAgICBpZiAoYWxsRGF5KSB7XHJcbiAgICAgICAgICAgIGVuZCA9IHN0YXJ0T2ZEYXkoZW5kKTtcclxuICAgICAgICAgICAgZW5kID0gZGF0ZUVudi5hZGQoZW5kLCBvcHRpb25zLmRlZmF1bHRBbGxEYXlFdmVudER1cmF0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGVuZCA9IGRhdGVFbnYuYWRkKGVuZCwgb3B0aW9ucy5kZWZhdWx0VGltZWRFdmVudER1cmF0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGVuZDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBhcHBsaWVzIHRoZSBtdXRhdGlvbiB0byBBTEwgZGVmcy9pbnN0YW5jZXMgd2l0aGluIHRoZSBldmVudCBzdG9yZVxyXG4gICAgZnVuY3Rpb24gYXBwbHlNdXRhdGlvblRvRXZlbnRTdG9yZShldmVudFN0b3JlLCBldmVudENvbmZpZ0Jhc2UsIG11dGF0aW9uLCBjb250ZXh0KSB7XHJcbiAgICAgICAgbGV0IGV2ZW50Q29uZmlncyA9IGNvbXBpbGVFdmVudFVpcyhldmVudFN0b3JlLmRlZnMsIGV2ZW50Q29uZmlnQmFzZSk7XHJcbiAgICAgICAgbGV0IGRlc3QgPSBjcmVhdGVFbXB0eUV2ZW50U3RvcmUoKTtcclxuICAgICAgICBmb3IgKGxldCBkZWZJZCBpbiBldmVudFN0b3JlLmRlZnMpIHtcclxuICAgICAgICAgICAgbGV0IGRlZiA9IGV2ZW50U3RvcmUuZGVmc1tkZWZJZF07XHJcbiAgICAgICAgICAgIGRlc3QuZGVmc1tkZWZJZF0gPSBhcHBseU11dGF0aW9uVG9FdmVudERlZihkZWYsIGV2ZW50Q29uZmlnc1tkZWZJZF0sIG11dGF0aW9uLCBjb250ZXh0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChsZXQgaW5zdGFuY2VJZCBpbiBldmVudFN0b3JlLmluc3RhbmNlcykge1xyXG4gICAgICAgICAgICBsZXQgaW5zdGFuY2UgPSBldmVudFN0b3JlLmluc3RhbmNlc1tpbnN0YW5jZUlkXTtcclxuICAgICAgICAgICAgbGV0IGRlZiA9IGRlc3QuZGVmc1tpbnN0YW5jZS5kZWZJZF07IC8vIGltcG9ydGFudCB0byBncmFiIHRoZSBuZXdseSBtb2RpZmllZCBkZWZcclxuICAgICAgICAgICAgZGVzdC5pbnN0YW5jZXNbaW5zdGFuY2VJZF0gPSBhcHBseU11dGF0aW9uVG9FdmVudEluc3RhbmNlKGluc3RhbmNlLCBkZWYsIGV2ZW50Q29uZmlnc1tpbnN0YW5jZS5kZWZJZF0sIG11dGF0aW9uLCBjb250ZXh0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGRlc3Q7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBhcHBseU11dGF0aW9uVG9FdmVudERlZihldmVudERlZiwgZXZlbnRDb25maWcsIG11dGF0aW9uLCBjb250ZXh0KSB7XHJcbiAgICAgICAgbGV0IHN0YW5kYXJkUHJvcHMgPSBtdXRhdGlvbi5zdGFuZGFyZFByb3BzIHx8IHt9O1xyXG4gICAgICAgIC8vIGlmIGhhc0VuZCBoYXMgbm90IGJlZW4gc3BlY2lmaWVkLCBndWVzcyBhIGdvb2QgdmFsdWUgYmFzZWQgb24gZGVsdGFzLlxyXG4gICAgICAgIC8vIGlmIGR1cmF0aW9uIHdpbGwgY2hhbmdlLCB0aGVyZSdzIG5vIHdheSB0aGUgZGVmYXVsdCBkdXJhdGlvbiB3aWxsIHBlcnNpc3QsXHJcbiAgICAgICAgLy8gYW5kIHRodXMsIHdlIG5lZWQgdG8gbWFyayB0aGUgZXZlbnQgYXMgaGF2aW5nIGEgcmVhbCBlbmRcclxuICAgICAgICBpZiAoc3RhbmRhcmRQcm9wcy5oYXNFbmQgPT0gbnVsbCAmJlxyXG4gICAgICAgICAgICBldmVudENvbmZpZy5kdXJhdGlvbkVkaXRhYmxlICYmXHJcbiAgICAgICAgICAgIChtdXRhdGlvbi5zdGFydERlbHRhIHx8IG11dGF0aW9uLmVuZERlbHRhKSkge1xyXG4gICAgICAgICAgICBzdGFuZGFyZFByb3BzLmhhc0VuZCA9IHRydWU7IC8vIFRPRE86IGlzIHRoaXMgbXV0YXRpb24gb2theT9cclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGNvcHkgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZXZlbnREZWYpLCBzdGFuZGFyZFByb3BzKSwgeyB1aTogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBldmVudERlZi51aSksIHN0YW5kYXJkUHJvcHMudWkpIH0pO1xyXG4gICAgICAgIGlmIChtdXRhdGlvbi5leHRlbmRlZFByb3BzKSB7XHJcbiAgICAgICAgICAgIGNvcHkuZXh0ZW5kZWRQcm9wcyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY29weS5leHRlbmRlZFByb3BzKSwgbXV0YXRpb24uZXh0ZW5kZWRQcm9wcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAobGV0IGFwcGxpZXIgb2YgY29udGV4dC5wbHVnaW5Ib29rcy5ldmVudERlZk11dGF0aW9uQXBwbGllcnMpIHtcclxuICAgICAgICAgICAgYXBwbGllcihjb3B5LCBtdXRhdGlvbiwgY29udGV4dCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghY29weS5oYXNFbmQgJiYgY29udGV4dC5vcHRpb25zLmZvcmNlRXZlbnREdXJhdGlvbikge1xyXG4gICAgICAgICAgICBjb3B5Lmhhc0VuZCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjb3B5O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYXBwbHlNdXRhdGlvblRvRXZlbnRJbnN0YW5jZShldmVudEluc3RhbmNlLCBldmVudERlZiwgLy8gbXVzdCBmaXJzdCBiZSBtb2RpZmllZCBieSBhcHBseU11dGF0aW9uVG9FdmVudERlZlxyXG4gICAgZXZlbnRDb25maWcsIG11dGF0aW9uLCBjb250ZXh0KSB7XHJcbiAgICAgICAgbGV0IHsgZGF0ZUVudiB9ID0gY29udGV4dDtcclxuICAgICAgICBsZXQgZm9yY2VBbGxEYXkgPSBtdXRhdGlvbi5zdGFuZGFyZFByb3BzICYmIG11dGF0aW9uLnN0YW5kYXJkUHJvcHMuYWxsRGF5ID09PSB0cnVlO1xyXG4gICAgICAgIGxldCBjbGVhckVuZCA9IG11dGF0aW9uLnN0YW5kYXJkUHJvcHMgJiYgbXV0YXRpb24uc3RhbmRhcmRQcm9wcy5oYXNFbmQgPT09IGZhbHNlO1xyXG4gICAgICAgIGxldCBjb3B5ID0gT2JqZWN0LmFzc2lnbih7fSwgZXZlbnRJbnN0YW5jZSk7XHJcbiAgICAgICAgaWYgKGZvcmNlQWxsRGF5KSB7XHJcbiAgICAgICAgICAgIGNvcHkucmFuZ2UgPSBjb21wdXRlQWxpZ25lZERheVJhbmdlKGNvcHkucmFuZ2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobXV0YXRpb24uZGF0ZXNEZWx0YSAmJiBldmVudENvbmZpZy5zdGFydEVkaXRhYmxlKSB7XHJcbiAgICAgICAgICAgIGNvcHkucmFuZ2UgPSB7XHJcbiAgICAgICAgICAgICAgICBzdGFydDogZGF0ZUVudi5hZGQoY29weS5yYW5nZS5zdGFydCwgbXV0YXRpb24uZGF0ZXNEZWx0YSksXHJcbiAgICAgICAgICAgICAgICBlbmQ6IGRhdGVFbnYuYWRkKGNvcHkucmFuZ2UuZW5kLCBtdXRhdGlvbi5kYXRlc0RlbHRhKSxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG11dGF0aW9uLnN0YXJ0RGVsdGEgJiYgZXZlbnRDb25maWcuZHVyYXRpb25FZGl0YWJsZSkge1xyXG4gICAgICAgICAgICBjb3B5LnJhbmdlID0ge1xyXG4gICAgICAgICAgICAgICAgc3RhcnQ6IGRhdGVFbnYuYWRkKGNvcHkucmFuZ2Uuc3RhcnQsIG11dGF0aW9uLnN0YXJ0RGVsdGEpLFxyXG4gICAgICAgICAgICAgICAgZW5kOiBjb3B5LnJhbmdlLmVuZCxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG11dGF0aW9uLmVuZERlbHRhICYmIGV2ZW50Q29uZmlnLmR1cmF0aW9uRWRpdGFibGUpIHtcclxuICAgICAgICAgICAgY29weS5yYW5nZSA9IHtcclxuICAgICAgICAgICAgICAgIHN0YXJ0OiBjb3B5LnJhbmdlLnN0YXJ0LFxyXG4gICAgICAgICAgICAgICAgZW5kOiBkYXRlRW52LmFkZChjb3B5LnJhbmdlLmVuZCwgbXV0YXRpb24uZW5kRGVsdGEpLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY2xlYXJFbmQpIHtcclxuICAgICAgICAgICAgY29weS5yYW5nZSA9IHtcclxuICAgICAgICAgICAgICAgIHN0YXJ0OiBjb3B5LnJhbmdlLnN0YXJ0LFxyXG4gICAgICAgICAgICAgICAgZW5kOiBnZXREZWZhdWx0RXZlbnRFbmQoZXZlbnREZWYuYWxsRGF5LCBjb3B5LnJhbmdlLnN0YXJ0LCBjb250ZXh0KSxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gaW4gY2FzZSBldmVudCB3YXMgYWxsLWRheSBidXQgdGhlIHN1cHBsaWVkIGRlbHRhcyB3ZXJlIG5vdFxyXG4gICAgICAgIC8vIGJldHRlciB1dGlsIGZvciB0aGlzP1xyXG4gICAgICAgIGlmIChldmVudERlZi5hbGxEYXkpIHtcclxuICAgICAgICAgICAgY29weS5yYW5nZSA9IHtcclxuICAgICAgICAgICAgICAgIHN0YXJ0OiBzdGFydE9mRGF5KGNvcHkucmFuZ2Uuc3RhcnQpLFxyXG4gICAgICAgICAgICAgICAgZW5kOiBzdGFydE9mRGF5KGNvcHkucmFuZ2UuZW5kKSxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gaGFuZGxlIGludmFsaWQgZHVyYXRpb25zXHJcbiAgICAgICAgaWYgKGNvcHkucmFuZ2UuZW5kIDwgY29weS5yYW5nZS5zdGFydCkge1xyXG4gICAgICAgICAgICBjb3B5LnJhbmdlLmVuZCA9IGdldERlZmF1bHRFdmVudEVuZChldmVudERlZi5hbGxEYXksIGNvcHkucmFuZ2Uuc3RhcnQsIGNvbnRleHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY29weTtcclxuICAgIH1cclxuXHJcbiAgICBjbGFzcyBFdmVudFNvdXJjZUltcGwge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yKGNvbnRleHQsIGludGVybmFsRXZlbnRTb3VyY2UpIHtcclxuICAgICAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcclxuICAgICAgICAgICAgdGhpcy5pbnRlcm5hbEV2ZW50U291cmNlID0gaW50ZXJuYWxFdmVudFNvdXJjZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVtb3ZlKCkge1xyXG4gICAgICAgICAgICB0aGlzLmNvbnRleHQuZGlzcGF0Y2goe1xyXG4gICAgICAgICAgICAgICAgdHlwZTogJ1JFTU9WRV9FVkVOVF9TT1VSQ0UnLFxyXG4gICAgICAgICAgICAgICAgc291cmNlSWQ6IHRoaXMuaW50ZXJuYWxFdmVudFNvdXJjZS5zb3VyY2VJZCxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlZmV0Y2goKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5kaXNwYXRjaCh7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiAnRkVUQ0hfRVZFTlRfU09VUkNFUycsXHJcbiAgICAgICAgICAgICAgICBzb3VyY2VJZHM6IFt0aGlzLmludGVybmFsRXZlbnRTb3VyY2Uuc291cmNlSWRdLFxyXG4gICAgICAgICAgICAgICAgaXNSZWZldGNoOiB0cnVlLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZ2V0IGlkKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbEV2ZW50U291cmNlLnB1YmxpY0lkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBnZXQgdXJsKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbEV2ZW50U291cmNlLm1ldGEudXJsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBnZXQgZm9ybWF0KCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbEV2ZW50U291cmNlLm1ldGEuZm9ybWF0OyAvLyBUT0RPOiBiYWQuIG5vdCBndWFyYW50ZWVkXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNsYXNzIEV2ZW50SW1wbCB7XHJcbiAgICAgICAgLy8gaW5zdGFuY2Ugd2lsbCBiZSBudWxsIGlmIGV4cHJlc3NpbmcgYSByZWN1cnJpbmcgZXZlbnQgdGhhdCBoYXMgbm8gY3VycmVudCBpbnN0YW5jZXMsXHJcbiAgICAgICAgLy8gT1IgaWYgdHJ5aW5nIHRvIHZhbGlkYXRlIGFuIGluY29taW5nIGV4dGVybmFsIGV2ZW50IHRoYXQgaGFzIG5vIGRhdGVzIGFzc2lnbmVkXHJcbiAgICAgICAgY29uc3RydWN0b3IoY29udGV4dCwgZGVmLCBpbnN0YW5jZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcclxuICAgICAgICAgICAgdGhpcy5fZGVmID0gZGVmO1xyXG4gICAgICAgICAgICB0aGlzLl9pbnN0YW5jZSA9IGluc3RhbmNlIHx8IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgVE9ETzogbWFrZSBldmVudCBzdHJ1Y3QgbW9yZSByZXNwb25zaWJsZSBmb3IgdGhpc1xyXG4gICAgICAgICovXHJcbiAgICAgICAgc2V0UHJvcChuYW1lLCB2YWwpIHtcclxuICAgICAgICAgICAgaWYgKG5hbWUgaW4gRVZFTlRfREFURV9SRUZJTkVSUykge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdDb3VsZCBub3Qgc2V0IGRhdGUtcmVsYXRlZCBwcm9wIFxcJ25hbWVcXCcuIFVzZSBvbmUgb2YgdGhlIGRhdGUtcmVsYXRlZCBtZXRob2RzIGluc3RlYWQuJyk7XHJcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBtYWtlIHByb3BlciBhbGlhc2luZyBzeXN0ZW0/XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAobmFtZSA9PT0gJ2lkJykge1xyXG4gICAgICAgICAgICAgICAgdmFsID0gRVZFTlRfTk9OX0RBVEVfUkVGSU5FUlNbbmFtZV0odmFsKTtcclxuICAgICAgICAgICAgICAgIHRoaXMubXV0YXRlKHtcclxuICAgICAgICAgICAgICAgICAgICBzdGFuZGFyZFByb3BzOiB7IHB1YmxpY0lkOiB2YWwgfSwgLy8gaGFyZGNvZGVkIGludGVybmFsIG5hbWVcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKG5hbWUgaW4gRVZFTlRfTk9OX0RBVEVfUkVGSU5FUlMpIHtcclxuICAgICAgICAgICAgICAgIHZhbCA9IEVWRU5UX05PTl9EQVRFX1JFRklORVJTW25hbWVdKHZhbCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm11dGF0ZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhbmRhcmRQcm9wczogeyBbbmFtZV06IHZhbCB9LFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAobmFtZSBpbiBFVkVOVF9VSV9SRUZJTkVSUykge1xyXG4gICAgICAgICAgICAgICAgbGV0IHVpID0gRVZFTlRfVUlfUkVGSU5FUlNbbmFtZV0odmFsKTtcclxuICAgICAgICAgICAgICAgIGlmIChuYW1lID09PSAnY29sb3InKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdWkgPSB7IGJhY2tncm91bmRDb2xvcjogdmFsLCBib3JkZXJDb2xvcjogdmFsIH07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChuYW1lID09PSAnZWRpdGFibGUnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdWkgPSB7IHN0YXJ0RWRpdGFibGU6IHZhbCwgZHVyYXRpb25FZGl0YWJsZTogdmFsIH07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB1aSA9IHsgW25hbWVdOiB2YWwgfTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMubXV0YXRlKHtcclxuICAgICAgICAgICAgICAgICAgICBzdGFuZGFyZFByb3BzOiB7IHVpIH0sXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgQ291bGQgbm90IHNldCBwcm9wICcke25hbWV9Jy4gVXNlIHNldEV4dGVuZGVkUHJvcCBpbnN0ZWFkLmApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNldEV4dGVuZGVkUHJvcChuYW1lLCB2YWwpIHtcclxuICAgICAgICAgICAgdGhpcy5tdXRhdGUoe1xyXG4gICAgICAgICAgICAgICAgZXh0ZW5kZWRQcm9wczogeyBbbmFtZV06IHZhbCB9LFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc2V0U3RhcnQoc3RhcnRJbnB1dCwgb3B0aW9ucyA9IHt9KSB7XHJcbiAgICAgICAgICAgIGxldCB7IGRhdGVFbnYgfSA9IHRoaXMuX2NvbnRleHQ7XHJcbiAgICAgICAgICAgIGxldCBzdGFydCA9IGRhdGVFbnYuY3JlYXRlTWFya2VyKHN0YXJ0SW5wdXQpO1xyXG4gICAgICAgICAgICBpZiAoc3RhcnQgJiYgdGhpcy5faW5zdGFuY2UpIHsgLy8gVE9ETzogd2FybmluZyBpZiBwYXJzZWQgYmFkXHJcbiAgICAgICAgICAgICAgICBsZXQgaW5zdGFuY2VSYW5nZSA9IHRoaXMuX2luc3RhbmNlLnJhbmdlO1xyXG4gICAgICAgICAgICAgICAgbGV0IHN0YXJ0RGVsdGEgPSBkaWZmRGF0ZXMoaW5zdGFuY2VSYW5nZS5zdGFydCwgc3RhcnQsIGRhdGVFbnYsIG9wdGlvbnMuZ3JhbnVsYXJpdHkpOyAvLyB3aGF0IGlmIHBhcnNlZCBiYWQhP1xyXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMubWFpbnRhaW5EdXJhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubXV0YXRlKHsgZGF0ZXNEZWx0YTogc3RhcnREZWx0YSB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubXV0YXRlKHsgc3RhcnREZWx0YSB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBzZXRFbmQoZW5kSW5wdXQsIG9wdGlvbnMgPSB7fSkge1xyXG4gICAgICAgICAgICBsZXQgeyBkYXRlRW52IH0gPSB0aGlzLl9jb250ZXh0O1xyXG4gICAgICAgICAgICBsZXQgZW5kO1xyXG4gICAgICAgICAgICBpZiAoZW5kSW5wdXQgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgZW5kID0gZGF0ZUVudi5jcmVhdGVNYXJrZXIoZW5kSW5wdXQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFlbmQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47IC8vIFRPRE86IHdhcm5pbmcgaWYgcGFyc2VkIGJhZFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9pbnN0YW5jZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVuZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBlbmREZWx0YSA9IGRpZmZEYXRlcyh0aGlzLl9pbnN0YW5jZS5yYW5nZS5lbmQsIGVuZCwgZGF0ZUVudiwgb3B0aW9ucy5ncmFudWxhcml0eSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tdXRhdGUoeyBlbmREZWx0YSB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubXV0YXRlKHsgc3RhbmRhcmRQcm9wczogeyBoYXNFbmQ6IGZhbHNlIH0gfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgc2V0RGF0ZXMoc3RhcnRJbnB1dCwgZW5kSW5wdXQsIG9wdGlvbnMgPSB7fSkge1xyXG4gICAgICAgICAgICBsZXQgeyBkYXRlRW52IH0gPSB0aGlzLl9jb250ZXh0O1xyXG4gICAgICAgICAgICBsZXQgc3RhbmRhcmRQcm9wcyA9IHsgYWxsRGF5OiBvcHRpb25zLmFsbERheSB9O1xyXG4gICAgICAgICAgICBsZXQgc3RhcnQgPSBkYXRlRW52LmNyZWF0ZU1hcmtlcihzdGFydElucHV0KTtcclxuICAgICAgICAgICAgbGV0IGVuZDtcclxuICAgICAgICAgICAgaWYgKCFzdGFydCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBUT0RPOiB3YXJuaW5nIGlmIHBhcnNlZCBiYWRcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZW5kSW5wdXQgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgZW5kID0gZGF0ZUVudi5jcmVhdGVNYXJrZXIoZW5kSW5wdXQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFlbmQpIHsgLy8gVE9ETzogd2FybmluZyBpZiBwYXJzZWQgYmFkXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9pbnN0YW5jZSkge1xyXG4gICAgICAgICAgICAgICAgbGV0IGluc3RhbmNlUmFuZ2UgPSB0aGlzLl9pbnN0YW5jZS5yYW5nZTtcclxuICAgICAgICAgICAgICAgIC8vIHdoZW4gY29tcHV0aW5nIHRoZSBkaWZmIGZvciBhbiBldmVudCBiZWluZyBjb252ZXJ0ZWQgdG8gYWxsLWRheSxcclxuICAgICAgICAgICAgICAgIC8vIGNvbXB1dGUgZGlmZiBvZmYgb2YgdGhlIGFsbC1kYXkgdmFsdWVzIHRoZSB3YXkgZXZlbnQtbXV0YXRpb24gZG9lcy5cclxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmFsbERheSA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlUmFuZ2UgPSBjb21wdXRlQWxpZ25lZERheVJhbmdlKGluc3RhbmNlUmFuZ2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbGV0IHN0YXJ0RGVsdGEgPSBkaWZmRGF0ZXMoaW5zdGFuY2VSYW5nZS5zdGFydCwgc3RhcnQsIGRhdGVFbnYsIG9wdGlvbnMuZ3JhbnVsYXJpdHkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGVuZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBlbmREZWx0YSA9IGRpZmZEYXRlcyhpbnN0YW5jZVJhbmdlLmVuZCwgZW5kLCBkYXRlRW52LCBvcHRpb25zLmdyYW51bGFyaXR5KTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZHVyYXRpb25zRXF1YWwoc3RhcnREZWx0YSwgZW5kRGVsdGEpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubXV0YXRlKHsgZGF0ZXNEZWx0YTogc3RhcnREZWx0YSwgc3RhbmRhcmRQcm9wcyB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubXV0YXRlKHsgc3RhcnREZWx0YSwgZW5kRGVsdGEsIHN0YW5kYXJkUHJvcHMgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7IC8vIG1lYW5zIFwiY2xlYXIgdGhlIGVuZFwiXHJcbiAgICAgICAgICAgICAgICAgICAgc3RhbmRhcmRQcm9wcy5oYXNFbmQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm11dGF0ZSh7IGRhdGVzRGVsdGE6IHN0YXJ0RGVsdGEsIHN0YW5kYXJkUHJvcHMgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgbW92ZVN0YXJ0KGRlbHRhSW5wdXQpIHtcclxuICAgICAgICAgICAgbGV0IGRlbHRhID0gY3JlYXRlRHVyYXRpb24oZGVsdGFJbnB1dCk7XHJcbiAgICAgICAgICAgIGlmIChkZWx0YSkgeyAvLyBUT0RPOiB3YXJuaW5nIGlmIHBhcnNlZCBiYWRcclxuICAgICAgICAgICAgICAgIHRoaXMubXV0YXRlKHsgc3RhcnREZWx0YTogZGVsdGEgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgbW92ZUVuZChkZWx0YUlucHV0KSB7XHJcbiAgICAgICAgICAgIGxldCBkZWx0YSA9IGNyZWF0ZUR1cmF0aW9uKGRlbHRhSW5wdXQpO1xyXG4gICAgICAgICAgICBpZiAoZGVsdGEpIHsgLy8gVE9ETzogd2FybmluZyBpZiBwYXJzZWQgYmFkXHJcbiAgICAgICAgICAgICAgICB0aGlzLm11dGF0ZSh7IGVuZERlbHRhOiBkZWx0YSB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBtb3ZlRGF0ZXMoZGVsdGFJbnB1dCkge1xyXG4gICAgICAgICAgICBsZXQgZGVsdGEgPSBjcmVhdGVEdXJhdGlvbihkZWx0YUlucHV0KTtcclxuICAgICAgICAgICAgaWYgKGRlbHRhKSB7IC8vIFRPRE86IHdhcm5pbmcgaWYgcGFyc2VkIGJhZFxyXG4gICAgICAgICAgICAgICAgdGhpcy5tdXRhdGUoeyBkYXRlc0RlbHRhOiBkZWx0YSB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBzZXRBbGxEYXkoYWxsRGF5LCBvcHRpb25zID0ge30pIHtcclxuICAgICAgICAgICAgbGV0IHN0YW5kYXJkUHJvcHMgPSB7IGFsbERheSB9O1xyXG4gICAgICAgICAgICBsZXQgeyBtYWludGFpbkR1cmF0aW9uIH0gPSBvcHRpb25zO1xyXG4gICAgICAgICAgICBpZiAobWFpbnRhaW5EdXJhdGlvbiA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBtYWludGFpbkR1cmF0aW9uID0gdGhpcy5fY29udGV4dC5vcHRpb25zLmFsbERheU1haW50YWluRHVyYXRpb247XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuX2RlZi5hbGxEYXkgIT09IGFsbERheSkge1xyXG4gICAgICAgICAgICAgICAgc3RhbmRhcmRQcm9wcy5oYXNFbmQgPSBtYWludGFpbkR1cmF0aW9uO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMubXV0YXRlKHsgc3RhbmRhcmRQcm9wcyB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9ybWF0UmFuZ2UoZm9ybWF0SW5wdXQpIHtcclxuICAgICAgICAgICAgbGV0IHsgZGF0ZUVudiB9ID0gdGhpcy5fY29udGV4dDtcclxuICAgICAgICAgICAgbGV0IGluc3RhbmNlID0gdGhpcy5faW5zdGFuY2U7XHJcbiAgICAgICAgICAgIGxldCBmb3JtYXR0ZXIgPSBjcmVhdGVGb3JtYXR0ZXIoZm9ybWF0SW5wdXQpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fZGVmLmhhc0VuZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGVFbnYuZm9ybWF0UmFuZ2UoaW5zdGFuY2UucmFuZ2Uuc3RhcnQsIGluc3RhbmNlLnJhbmdlLmVuZCwgZm9ybWF0dGVyLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yY2VkU3RhcnRUem86IGluc3RhbmNlLmZvcmNlZFN0YXJ0VHpvLFxyXG4gICAgICAgICAgICAgICAgICAgIGZvcmNlZEVuZFR6bzogaW5zdGFuY2UuZm9yY2VkRW5kVHpvLFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGRhdGVFbnYuZm9ybWF0KGluc3RhbmNlLnJhbmdlLnN0YXJ0LCBmb3JtYXR0ZXIsIHtcclxuICAgICAgICAgICAgICAgIGZvcmNlZFR6bzogaW5zdGFuY2UuZm9yY2VkU3RhcnRUem8sXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBtdXRhdGUobXV0YXRpb24pIHtcclxuICAgICAgICAgICAgbGV0IGluc3RhbmNlID0gdGhpcy5faW5zdGFuY2U7XHJcbiAgICAgICAgICAgIGlmIChpbnN0YW5jZSkge1xyXG4gICAgICAgICAgICAgICAgbGV0IGRlZiA9IHRoaXMuX2RlZjtcclxuICAgICAgICAgICAgICAgIGxldCBjb250ZXh0ID0gdGhpcy5fY29udGV4dDtcclxuICAgICAgICAgICAgICAgIGxldCB7IGV2ZW50U3RvcmUgfSA9IGNvbnRleHQuZ2V0Q3VycmVudERhdGEoKTtcclxuICAgICAgICAgICAgICAgIGxldCByZWxldmFudEV2ZW50cyA9IGdldFJlbGV2YW50RXZlbnRzKGV2ZW50U3RvcmUsIGluc3RhbmNlLmluc3RhbmNlSWQpO1xyXG4gICAgICAgICAgICAgICAgbGV0IGV2ZW50Q29uZmlnQmFzZSA9IHtcclxuICAgICAgICAgICAgICAgICAgICAnJzoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5OiAnJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRFZGl0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZHVyYXRpb25FZGl0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3RyYWludHM6IFtdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvdmVybGFwOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxvd3M6IFtdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICcnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBib3JkZXJDb2xvcjogJycsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHRDb2xvcjogJycsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZXM6IFtdLFxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgcmVsZXZhbnRFdmVudHMgPSBhcHBseU11dGF0aW9uVG9FdmVudFN0b3JlKHJlbGV2YW50RXZlbnRzLCBldmVudENvbmZpZ0Jhc2UsIG11dGF0aW9uLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgICAgIGxldCBvbGRFdmVudCA9IG5ldyBFdmVudEltcGwoY29udGV4dCwgZGVmLCBpbnN0YW5jZSk7IC8vIHNuYXBzaG90XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9kZWYgPSByZWxldmFudEV2ZW50cy5kZWZzW2RlZi5kZWZJZF07XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9pbnN0YW5jZSA9IHJlbGV2YW50RXZlbnRzLmluc3RhbmNlc1tpbnN0YW5jZS5pbnN0YW5jZUlkXTtcclxuICAgICAgICAgICAgICAgIGNvbnRleHQuZGlzcGF0Y2goe1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdNRVJHRV9FVkVOVFMnLFxyXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50U3RvcmU6IHJlbGV2YW50RXZlbnRzLFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LmVtaXR0ZXIudHJpZ2dlcignZXZlbnRDaGFuZ2UnLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgb2xkRXZlbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IHRoaXMsXHJcbiAgICAgICAgICAgICAgICAgICAgcmVsYXRlZEV2ZW50czogYnVpbGRFdmVudEFwaXMocmVsZXZhbnRFdmVudHMsIGNvbnRleHQsIGluc3RhbmNlKSxcclxuICAgICAgICAgICAgICAgICAgICByZXZlcnQoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQuZGlzcGF0Y2goe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ1JFU0VUX0VWRU5UUycsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudFN0b3JlLCAvLyB0aGUgT1JJR0lOQUwgc3RvcmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlbW92ZSgpIHtcclxuICAgICAgICAgICAgbGV0IGNvbnRleHQgPSB0aGlzLl9jb250ZXh0O1xyXG4gICAgICAgICAgICBsZXQgYXNTdG9yZSA9IGV2ZW50QXBpVG9TdG9yZSh0aGlzKTtcclxuICAgICAgICAgICAgY29udGV4dC5kaXNwYXRjaCh7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiAnUkVNT1ZFX0VWRU5UUycsXHJcbiAgICAgICAgICAgICAgICBldmVudFN0b3JlOiBhc1N0b3JlLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgY29udGV4dC5lbWl0dGVyLnRyaWdnZXIoJ2V2ZW50UmVtb3ZlJywge1xyXG4gICAgICAgICAgICAgICAgZXZlbnQ6IHRoaXMsXHJcbiAgICAgICAgICAgICAgICByZWxhdGVkRXZlbnRzOiBbXSxcclxuICAgICAgICAgICAgICAgIHJldmVydCgpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmRpc3BhdGNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ01FUkdFX0VWRU5UUycsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50U3RvcmU6IGFzU3RvcmUsXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZ2V0IHNvdXJjZSgpIHtcclxuICAgICAgICAgICAgbGV0IHsgc291cmNlSWQgfSA9IHRoaXMuX2RlZjtcclxuICAgICAgICAgICAgaWYgKHNvdXJjZUlkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEV2ZW50U291cmNlSW1wbCh0aGlzLl9jb250ZXh0LCB0aGlzLl9jb250ZXh0LmdldEN1cnJlbnREYXRhKCkuZXZlbnRTb3VyY2VzW3NvdXJjZUlkXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGdldCBzdGFydCgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2luc3RhbmNlID9cclxuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuZGF0ZUVudi50b0RhdGUodGhpcy5faW5zdGFuY2UucmFuZ2Uuc3RhcnQpIDpcclxuICAgICAgICAgICAgICAgIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGdldCBlbmQoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5faW5zdGFuY2UgJiYgdGhpcy5fZGVmLmhhc0VuZCkgP1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY29udGV4dC5kYXRlRW52LnRvRGF0ZSh0aGlzLl9pbnN0YW5jZS5yYW5nZS5lbmQpIDpcclxuICAgICAgICAgICAgICAgIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGdldCBzdGFydFN0cigpIHtcclxuICAgICAgICAgICAgbGV0IGluc3RhbmNlID0gdGhpcy5faW5zdGFuY2U7XHJcbiAgICAgICAgICAgIGlmIChpbnN0YW5jZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRleHQuZGF0ZUVudi5mb3JtYXRJc28oaW5zdGFuY2UucmFuZ2Uuc3RhcnQsIHtcclxuICAgICAgICAgICAgICAgICAgICBvbWl0VGltZTogdGhpcy5fZGVmLmFsbERheSxcclxuICAgICAgICAgICAgICAgICAgICBmb3JjZWRUem86IGluc3RhbmNlLmZvcmNlZFN0YXJ0VHpvLFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBnZXQgZW5kU3RyKCkge1xyXG4gICAgICAgICAgICBsZXQgaW5zdGFuY2UgPSB0aGlzLl9pbnN0YW5jZTtcclxuICAgICAgICAgICAgaWYgKGluc3RhbmNlICYmIHRoaXMuX2RlZi5oYXNFbmQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb250ZXh0LmRhdGVFbnYuZm9ybWF0SXNvKGluc3RhbmNlLnJhbmdlLmVuZCwge1xyXG4gICAgICAgICAgICAgICAgICAgIG9taXRUaW1lOiB0aGlzLl9kZWYuYWxsRGF5LFxyXG4gICAgICAgICAgICAgICAgICAgIGZvcmNlZFR6bzogaW5zdGFuY2UuZm9yY2VkRW5kVHpvLFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBjb21wdXRhYmxlIHByb3BzIHRoYXQgYWxsIGFjY2VzcyB0aGUgZGVmXHJcbiAgICAgICAgLy8gVE9ETzogZmluZCBhIFR5cGVTY3JpcHQtY29tcGF0aWJsZSB3YXkgdG8gZG8gdGhpcyBhdCBzY2FsZVxyXG4gICAgICAgIGdldCBpZCgpIHsgcmV0dXJuIHRoaXMuX2RlZi5wdWJsaWNJZDsgfVxyXG4gICAgICAgIGdldCBncm91cElkKCkgeyByZXR1cm4gdGhpcy5fZGVmLmdyb3VwSWQ7IH1cclxuICAgICAgICBnZXQgYWxsRGF5KCkgeyByZXR1cm4gdGhpcy5fZGVmLmFsbERheTsgfVxyXG4gICAgICAgIGdldCB0aXRsZSgpIHsgcmV0dXJuIHRoaXMuX2RlZi50aXRsZTsgfVxyXG4gICAgICAgIGdldCB1cmwoKSB7IHJldHVybiB0aGlzLl9kZWYudXJsOyB9XHJcbiAgICAgICAgZ2V0IGRpc3BsYXkoKSB7IHJldHVybiB0aGlzLl9kZWYudWkuZGlzcGxheSB8fCAnYXV0byc7IH0gLy8gYmFkLiBqdXN0IG5vcm1hbGl6ZSB0aGUgdHlwZSBlYXJsaWVyXHJcbiAgICAgICAgZ2V0IHN0YXJ0RWRpdGFibGUoKSB7IHJldHVybiB0aGlzLl9kZWYudWkuc3RhcnRFZGl0YWJsZTsgfVxyXG4gICAgICAgIGdldCBkdXJhdGlvbkVkaXRhYmxlKCkgeyByZXR1cm4gdGhpcy5fZGVmLnVpLmR1cmF0aW9uRWRpdGFibGU7IH1cclxuICAgICAgICBnZXQgY29uc3RyYWludCgpIHsgcmV0dXJuIHRoaXMuX2RlZi51aS5jb25zdHJhaW50c1swXSB8fCBudWxsOyB9XHJcbiAgICAgICAgZ2V0IG92ZXJsYXAoKSB7IHJldHVybiB0aGlzLl9kZWYudWkub3ZlcmxhcDsgfVxyXG4gICAgICAgIGdldCBhbGxvdygpIHsgcmV0dXJuIHRoaXMuX2RlZi51aS5hbGxvd3NbMF0gfHwgbnVsbDsgfVxyXG4gICAgICAgIGdldCBiYWNrZ3JvdW5kQ29sb3IoKSB7IHJldHVybiB0aGlzLl9kZWYudWkuYmFja2dyb3VuZENvbG9yOyB9XHJcbiAgICAgICAgZ2V0IGJvcmRlckNvbG9yKCkgeyByZXR1cm4gdGhpcy5fZGVmLnVpLmJvcmRlckNvbG9yOyB9XHJcbiAgICAgICAgZ2V0IHRleHRDb2xvcigpIHsgcmV0dXJuIHRoaXMuX2RlZi51aS50ZXh0Q29sb3I7IH1cclxuICAgICAgICAvLyBOT1RFOiB1c2VyIGNhbid0IG1vZGlmeSB0aGVzZSBiZWNhdXNlIE9iamVjdC5mcmVlemUgd2FzIGNhbGxlZCBpbiBldmVudC1kZWYgcGFyc2luZ1xyXG4gICAgICAgIGdldCBjbGFzc05hbWVzKCkgeyByZXR1cm4gdGhpcy5fZGVmLnVpLmNsYXNzTmFtZXM7IH1cclxuICAgICAgICBnZXQgZXh0ZW5kZWRQcm9wcygpIHsgcmV0dXJuIHRoaXMuX2RlZi5leHRlbmRlZFByb3BzOyB9XHJcbiAgICAgICAgdG9QbGFpbk9iamVjdChzZXR0aW5ncyA9IHt9KSB7XHJcbiAgICAgICAgICAgIGxldCBkZWYgPSB0aGlzLl9kZWY7XHJcbiAgICAgICAgICAgIGxldCB7IHVpIH0gPSBkZWY7XHJcbiAgICAgICAgICAgIGxldCB7IHN0YXJ0U3RyLCBlbmRTdHIgfSA9IHRoaXM7XHJcbiAgICAgICAgICAgIGxldCByZXMgPSB7XHJcbiAgICAgICAgICAgICAgICBhbGxEYXk6IGRlZi5hbGxEYXksXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGlmIChkZWYudGl0bGUpIHtcclxuICAgICAgICAgICAgICAgIHJlcy50aXRsZSA9IGRlZi50aXRsZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoc3RhcnRTdHIpIHtcclxuICAgICAgICAgICAgICAgIHJlcy5zdGFydCA9IHN0YXJ0U3RyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChlbmRTdHIpIHtcclxuICAgICAgICAgICAgICAgIHJlcy5lbmQgPSBlbmRTdHI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGRlZi5wdWJsaWNJZCkge1xyXG4gICAgICAgICAgICAgICAgcmVzLmlkID0gZGVmLnB1YmxpY0lkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChkZWYuZ3JvdXBJZCkge1xyXG4gICAgICAgICAgICAgICAgcmVzLmdyb3VwSWQgPSBkZWYuZ3JvdXBJZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZGVmLnVybCkge1xyXG4gICAgICAgICAgICAgICAgcmVzLnVybCA9IGRlZi51cmw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHVpLmRpc3BsYXkgJiYgdWkuZGlzcGxheSAhPT0gJ2F1dG8nKSB7XHJcbiAgICAgICAgICAgICAgICByZXMuZGlzcGxheSA9IHVpLmRpc3BsYXk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gVE9ETzogd2hhdCBhYm91dCByZWN1cnJpbmctZXZlbnQgcHJvcGVydGllcz8/P1xyXG4gICAgICAgICAgICAvLyBUT0RPOiBpbmNsdWRlIHN0YXJ0RWRpdGFibGUvZHVyYXRpb25FZGl0YWJsZS9jb25zdHJhaW50L292ZXJsYXAvYWxsb3dcclxuICAgICAgICAgICAgaWYgKHNldHRpbmdzLmNvbGxhcHNlQ29sb3IgJiYgdWkuYmFja2dyb3VuZENvbG9yICYmIHVpLmJhY2tncm91bmRDb2xvciA9PT0gdWkuYm9yZGVyQ29sb3IpIHtcclxuICAgICAgICAgICAgICAgIHJlcy5jb2xvciA9IHVpLmJhY2tncm91bmRDb2xvcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmICh1aS5iYWNrZ3JvdW5kQ29sb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXMuYmFja2dyb3VuZENvbG9yID0gdWkuYmFja2dyb3VuZENvbG9yO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHVpLmJvcmRlckNvbG9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzLmJvcmRlckNvbG9yID0gdWkuYm9yZGVyQ29sb3I7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHVpLnRleHRDb2xvcikge1xyXG4gICAgICAgICAgICAgICAgcmVzLnRleHRDb2xvciA9IHVpLnRleHRDb2xvcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodWkuY2xhc3NOYW1lcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHJlcy5jbGFzc05hbWVzID0gdWkuY2xhc3NOYW1lcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMoZGVmLmV4dGVuZGVkUHJvcHMpLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLmNvbGxhcHNlRXh0ZW5kZWRQcm9wcykge1xyXG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ocmVzLCBkZWYuZXh0ZW5kZWRQcm9wcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXMuZXh0ZW5kZWRQcm9wcyA9IGRlZi5leHRlbmRlZFByb3BzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRvSlNPTigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9QbGFpbk9iamVjdCgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGV2ZW50QXBpVG9TdG9yZShldmVudEFwaSkge1xyXG4gICAgICAgIGxldCBkZWYgPSBldmVudEFwaS5fZGVmO1xyXG4gICAgICAgIGxldCBpbnN0YW5jZSA9IGV2ZW50QXBpLl9pbnN0YW5jZTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBkZWZzOiB7IFtkZWYuZGVmSWRdOiBkZWYgfSxcclxuICAgICAgICAgICAgaW5zdGFuY2VzOiBpbnN0YW5jZVxyXG4gICAgICAgICAgICAgICAgPyB7IFtpbnN0YW5jZS5pbnN0YW5jZUlkXTogaW5zdGFuY2UgfVxyXG4gICAgICAgICAgICAgICAgOiB7fSxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYnVpbGRFdmVudEFwaXMoZXZlbnRTdG9yZSwgY29udGV4dCwgZXhjbHVkZUluc3RhbmNlKSB7XHJcbiAgICAgICAgbGV0IHsgZGVmcywgaW5zdGFuY2VzIH0gPSBldmVudFN0b3JlO1xyXG4gICAgICAgIGxldCBldmVudEFwaXMgPSBbXTtcclxuICAgICAgICBsZXQgZXhjbHVkZUluc3RhbmNlSWQgPSBleGNsdWRlSW5zdGFuY2UgPyBleGNsdWRlSW5zdGFuY2UuaW5zdGFuY2VJZCA6ICcnO1xyXG4gICAgICAgIGZvciAobGV0IGlkIGluIGluc3RhbmNlcykge1xyXG4gICAgICAgICAgICBsZXQgaW5zdGFuY2UgPSBpbnN0YW5jZXNbaWRdO1xyXG4gICAgICAgICAgICBsZXQgZGVmID0gZGVmc1tpbnN0YW5jZS5kZWZJZF07XHJcbiAgICAgICAgICAgIGlmIChpbnN0YW5jZS5pbnN0YW5jZUlkICE9PSBleGNsdWRlSW5zdGFuY2VJZCkge1xyXG4gICAgICAgICAgICAgICAgZXZlbnRBcGlzLnB1c2gobmV3IEV2ZW50SW1wbChjb250ZXh0LCBkZWYsIGluc3RhbmNlKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGV2ZW50QXBpcztcclxuICAgIH1cclxuXHJcbiAgICAvKlxyXG4gICAgU3BlY2lmeWluZyBuZXh0RGF5VGhyZXNob2xkIHNpZ25hbHMgdGhhdCBhbGwtZGF5IHJhbmdlcyBzaG91bGQgYmUgc2xpY2VkLlxyXG4gICAgKi9cclxuICAgIGZ1bmN0aW9uIHNsaWNlRXZlbnRTdG9yZShldmVudFN0b3JlLCBldmVudFVpQmFzZXMsIGZyYW1pbmdSYW5nZSwgbmV4dERheVRocmVzaG9sZCkge1xyXG4gICAgICAgIGxldCBpbnZlcnNlQmdCeUdyb3VwSWQgPSB7fTtcclxuICAgICAgICBsZXQgaW52ZXJzZUJnQnlEZWZJZCA9IHt9O1xyXG4gICAgICAgIGxldCBkZWZCeUdyb3VwSWQgPSB7fTtcclxuICAgICAgICBsZXQgYmdSYW5nZXMgPSBbXTtcclxuICAgICAgICBsZXQgZmdSYW5nZXMgPSBbXTtcclxuICAgICAgICBsZXQgZXZlbnRVaXMgPSBjb21waWxlRXZlbnRVaXMoZXZlbnRTdG9yZS5kZWZzLCBldmVudFVpQmFzZXMpO1xyXG4gICAgICAgIGZvciAobGV0IGRlZklkIGluIGV2ZW50U3RvcmUuZGVmcykge1xyXG4gICAgICAgICAgICBsZXQgZGVmID0gZXZlbnRTdG9yZS5kZWZzW2RlZklkXTtcclxuICAgICAgICAgICAgbGV0IHVpID0gZXZlbnRVaXNbZGVmLmRlZklkXTtcclxuICAgICAgICAgICAgaWYgKHVpLmRpc3BsYXkgPT09ICdpbnZlcnNlLWJhY2tncm91bmQnKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGVmLmdyb3VwSWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBpbnZlcnNlQmdCeUdyb3VwSWRbZGVmLmdyb3VwSWRdID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkZWZCeUdyb3VwSWRbZGVmLmdyb3VwSWRdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZkJ5R3JvdXBJZFtkZWYuZ3JvdXBJZF0gPSBkZWY7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW52ZXJzZUJnQnlEZWZJZFtkZWZJZF0gPSBbXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGxldCBpbnN0YW5jZUlkIGluIGV2ZW50U3RvcmUuaW5zdGFuY2VzKSB7XHJcbiAgICAgICAgICAgIGxldCBpbnN0YW5jZSA9IGV2ZW50U3RvcmUuaW5zdGFuY2VzW2luc3RhbmNlSWRdO1xyXG4gICAgICAgICAgICBsZXQgZGVmID0gZXZlbnRTdG9yZS5kZWZzW2luc3RhbmNlLmRlZklkXTtcclxuICAgICAgICAgICAgbGV0IHVpID0gZXZlbnRVaXNbZGVmLmRlZklkXTtcclxuICAgICAgICAgICAgbGV0IG9yaWdSYW5nZSA9IGluc3RhbmNlLnJhbmdlO1xyXG4gICAgICAgICAgICBsZXQgbm9ybWFsUmFuZ2UgPSAoIWRlZi5hbGxEYXkgJiYgbmV4dERheVRocmVzaG9sZCkgP1xyXG4gICAgICAgICAgICAgICAgY29tcHV0ZVZpc2libGVEYXlSYW5nZShvcmlnUmFuZ2UsIG5leHREYXlUaHJlc2hvbGQpIDpcclxuICAgICAgICAgICAgICAgIG9yaWdSYW5nZTtcclxuICAgICAgICAgICAgbGV0IHNsaWNlZFJhbmdlID0gaW50ZXJzZWN0UmFuZ2VzKG5vcm1hbFJhbmdlLCBmcmFtaW5nUmFuZ2UpO1xyXG4gICAgICAgICAgICBpZiAoc2xpY2VkUmFuZ2UpIHtcclxuICAgICAgICAgICAgICAgIGlmICh1aS5kaXNwbGF5ID09PSAnaW52ZXJzZS1iYWNrZ3JvdW5kJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkZWYuZ3JvdXBJZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnZlcnNlQmdCeUdyb3VwSWRbZGVmLmdyb3VwSWRdLnB1c2goc2xpY2VkUmFuZ2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW52ZXJzZUJnQnlEZWZJZFtpbnN0YW5jZS5kZWZJZF0ucHVzaChzbGljZWRSYW5nZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodWkuZGlzcGxheSAhPT0gJ25vbmUnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgKHVpLmRpc3BsYXkgPT09ICdiYWNrZ3JvdW5kJyA/IGJnUmFuZ2VzIDogZmdSYW5nZXMpLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWYsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IHNsaWNlZFJhbmdlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpc1N0YXJ0OiBub3JtYWxSYW5nZS5zdGFydCAmJiBub3JtYWxSYW5nZS5zdGFydC52YWx1ZU9mKCkgPT09IHNsaWNlZFJhbmdlLnN0YXJ0LnZhbHVlT2YoKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXNFbmQ6IG5vcm1hbFJhbmdlLmVuZCAmJiBub3JtYWxSYW5nZS5lbmQudmFsdWVPZigpID09PSBzbGljZWRSYW5nZS5lbmQudmFsdWVPZigpLFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAobGV0IGdyb3VwSWQgaW4gaW52ZXJzZUJnQnlHcm91cElkKSB7IC8vIEJZIEdST1VQXHJcbiAgICAgICAgICAgIGxldCByYW5nZXMgPSBpbnZlcnNlQmdCeUdyb3VwSWRbZ3JvdXBJZF07XHJcbiAgICAgICAgICAgIGxldCBpbnZlcnRlZFJhbmdlcyA9IGludmVydFJhbmdlcyhyYW5nZXMsIGZyYW1pbmdSYW5nZSk7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGludmVydGVkUmFuZ2Ugb2YgaW52ZXJ0ZWRSYW5nZXMpIHtcclxuICAgICAgICAgICAgICAgIGxldCBkZWYgPSBkZWZCeUdyb3VwSWRbZ3JvdXBJZF07XHJcbiAgICAgICAgICAgICAgICBsZXQgdWkgPSBldmVudFVpc1tkZWYuZGVmSWRdO1xyXG4gICAgICAgICAgICAgICAgYmdSYW5nZXMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVmLFxyXG4gICAgICAgICAgICAgICAgICAgIHVpLFxyXG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlOiBpbnZlcnRlZFJhbmdlLFxyXG4gICAgICAgICAgICAgICAgICAgIGlzU3RhcnQ6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgIGlzRW5kOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAobGV0IGRlZklkIGluIGludmVyc2VCZ0J5RGVmSWQpIHtcclxuICAgICAgICAgICAgbGV0IHJhbmdlcyA9IGludmVyc2VCZ0J5RGVmSWRbZGVmSWRdO1xyXG4gICAgICAgICAgICBsZXQgaW52ZXJ0ZWRSYW5nZXMgPSBpbnZlcnRSYW5nZXMocmFuZ2VzLCBmcmFtaW5nUmFuZ2UpO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpbnZlcnRlZFJhbmdlIG9mIGludmVydGVkUmFuZ2VzKSB7XHJcbiAgICAgICAgICAgICAgICBiZ1Jhbmdlcy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICBkZWY6IGV2ZW50U3RvcmUuZGVmc1tkZWZJZF0sXHJcbiAgICAgICAgICAgICAgICAgICAgdWk6IGV2ZW50VWlzW2RlZklkXSxcclxuICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZTogbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICByYW5nZTogaW52ZXJ0ZWRSYW5nZSxcclxuICAgICAgICAgICAgICAgICAgICBpc1N0YXJ0OiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICBpc0VuZDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4geyBiZzogYmdSYW5nZXMsIGZnOiBmZ1JhbmdlcyB9O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gaGFzQmdSZW5kZXJpbmcoZGVmKSB7XHJcbiAgICAgICAgcmV0dXJuIGRlZi51aS5kaXNwbGF5ID09PSAnYmFja2dyb3VuZCcgfHwgZGVmLnVpLmRpc3BsYXkgPT09ICdpbnZlcnNlLWJhY2tncm91bmQnO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gc2V0RWxTZWcoZWwsIHNlZykge1xyXG4gICAgICAgIGVsLmZjU2VnID0gc2VnO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZ2V0RWxTZWcoZWwpIHtcclxuICAgICAgICByZXR1cm4gZWwuZmNTZWcgfHxcclxuICAgICAgICAgICAgZWwucGFyZW50Tm9kZS5mY1NlZyB8fCAvLyBmb3IgdGhlIGhhcm5lc3NcclxuICAgICAgICAgICAgbnVsbDtcclxuICAgIH1cclxuICAgIC8vIGV2ZW50IHVpIGNvbXB1dGF0aW9uXHJcbiAgICBmdW5jdGlvbiBjb21waWxlRXZlbnRVaXMoZXZlbnREZWZzLCBldmVudFVpQmFzZXMpIHtcclxuICAgICAgICByZXR1cm4gbWFwSGFzaChldmVudERlZnMsIChldmVudERlZikgPT4gY29tcGlsZUV2ZW50VWkoZXZlbnREZWYsIGV2ZW50VWlCYXNlcykpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gY29tcGlsZUV2ZW50VWkoZXZlbnREZWYsIGV2ZW50VWlCYXNlcykge1xyXG4gICAgICAgIGxldCB1aXMgPSBbXTtcclxuICAgICAgICBpZiAoZXZlbnRVaUJhc2VzWycnXSkge1xyXG4gICAgICAgICAgICB1aXMucHVzaChldmVudFVpQmFzZXNbJyddKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGV2ZW50VWlCYXNlc1tldmVudERlZi5kZWZJZF0pIHtcclxuICAgICAgICAgICAgdWlzLnB1c2goZXZlbnRVaUJhc2VzW2V2ZW50RGVmLmRlZklkXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHVpcy5wdXNoKGV2ZW50RGVmLnVpKTtcclxuICAgICAgICByZXR1cm4gY29tYmluZUV2ZW50VWlzKHVpcyk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBzb3J0RXZlbnRTZWdzKHNlZ3MsIGV2ZW50T3JkZXJTcGVjcykge1xyXG4gICAgICAgIGxldCBvYmpzID0gc2Vncy5tYXAoYnVpbGRTZWdDb21wYXJlT2JqKTtcclxuICAgICAgICBvYmpzLnNvcnQoKG9iajAsIG9iajEpID0+IGNvbXBhcmVCeUZpZWxkU3BlY3Mob2JqMCwgb2JqMSwgZXZlbnRPcmRlclNwZWNzKSk7XHJcbiAgICAgICAgcmV0dXJuIG9ianMubWFwKChjKSA9PiBjLl9zZWcpO1xyXG4gICAgfVxyXG4gICAgLy8gcmV0dXJucyBhIG9iamVjdCB3aXRoIGFsbCBwcmltaXRpdmUgcHJvcHMgdGhhdCBjYW4gYmUgY29tcGFyZWRcclxuICAgIGZ1bmN0aW9uIGJ1aWxkU2VnQ29tcGFyZU9iaihzZWcpIHtcclxuICAgICAgICBsZXQgeyBldmVudFJhbmdlIH0gPSBzZWc7XHJcbiAgICAgICAgbGV0IGV2ZW50RGVmID0gZXZlbnRSYW5nZS5kZWY7XHJcbiAgICAgICAgbGV0IHJhbmdlID0gZXZlbnRSYW5nZS5pbnN0YW5jZSA/IGV2ZW50UmFuZ2UuaW5zdGFuY2UucmFuZ2UgOiBldmVudFJhbmdlLnJhbmdlO1xyXG4gICAgICAgIGxldCBzdGFydCA9IHJhbmdlLnN0YXJ0ID8gcmFuZ2Uuc3RhcnQudmFsdWVPZigpIDogMDsgLy8gVE9ETzogYmV0dGVyIHN1cHBvcnQgZm9yIG9wZW4tcmFuZ2UgZXZlbnRzXHJcbiAgICAgICAgbGV0IGVuZCA9IHJhbmdlLmVuZCA/IHJhbmdlLmVuZC52YWx1ZU9mKCkgOiAwOyAvLyBcIlxyXG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZXZlbnREZWYuZXh0ZW5kZWRQcm9wcyksIGV2ZW50RGVmKSwgeyBpZDogZXZlbnREZWYucHVibGljSWQsIHN0YXJ0LFxyXG4gICAgICAgICAgICBlbmQsIGR1cmF0aW9uOiBlbmQgLSBzdGFydCwgYWxsRGF5OiBOdW1iZXIoZXZlbnREZWYuYWxsRGF5KSwgX3NlZzogc2VnIH0pO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gY29tcHV0ZVNlZ0RyYWdnYWJsZShzZWcsIGNvbnRleHQpIHtcclxuICAgICAgICBsZXQgeyBwbHVnaW5Ib29rcyB9ID0gY29udGV4dDtcclxuICAgICAgICBsZXQgdHJhbnNmb3JtZXJzID0gcGx1Z2luSG9va3MuaXNEcmFnZ2FibGVUcmFuc2Zvcm1lcnM7XHJcbiAgICAgICAgbGV0IHsgZGVmLCB1aSB9ID0gc2VnLmV2ZW50UmFuZ2U7XHJcbiAgICAgICAgbGV0IHZhbCA9IHVpLnN0YXJ0RWRpdGFibGU7XHJcbiAgICAgICAgZm9yIChsZXQgdHJhbnNmb3JtZXIgb2YgdHJhbnNmb3JtZXJzKSB7XHJcbiAgICAgICAgICAgIHZhbCA9IHRyYW5zZm9ybWVyKHZhbCwgZGVmLCB1aSwgY29udGV4dCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB2YWw7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBjb21wdXRlU2VnU3RhcnRSZXNpemFibGUoc2VnLCBjb250ZXh0KSB7XHJcbiAgICAgICAgcmV0dXJuIHNlZy5pc1N0YXJ0ICYmIHNlZy5ldmVudFJhbmdlLnVpLmR1cmF0aW9uRWRpdGFibGUgJiYgY29udGV4dC5vcHRpb25zLmV2ZW50UmVzaXphYmxlRnJvbVN0YXJ0O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gY29tcHV0ZVNlZ0VuZFJlc2l6YWJsZShzZWcsIGNvbnRleHQpIHtcclxuICAgICAgICByZXR1cm4gc2VnLmlzRW5kICYmIHNlZy5ldmVudFJhbmdlLnVpLmR1cmF0aW9uRWRpdGFibGU7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBidWlsZFNlZ1RpbWVUZXh0KHNlZywgdGltZUZvcm1hdCwgY29udGV4dCwgZGVmYXVsdERpc3BsYXlFdmVudFRpbWUsIC8vIGRlZmF1bHRzIHRvIHRydWVcclxuICAgIGRlZmF1bHREaXNwbGF5RXZlbnRFbmQsIC8vIGRlZmF1bHRzIHRvIHRydWVcclxuICAgIHN0YXJ0T3ZlcnJpZGUsIGVuZE92ZXJyaWRlKSB7XHJcbiAgICAgICAgbGV0IHsgZGF0ZUVudiwgb3B0aW9ucyB9ID0gY29udGV4dDtcclxuICAgICAgICBsZXQgeyBkaXNwbGF5RXZlbnRUaW1lLCBkaXNwbGF5RXZlbnRFbmQgfSA9IG9wdGlvbnM7XHJcbiAgICAgICAgbGV0IGV2ZW50RGVmID0gc2VnLmV2ZW50UmFuZ2UuZGVmO1xyXG4gICAgICAgIGxldCBldmVudEluc3RhbmNlID0gc2VnLmV2ZW50UmFuZ2UuaW5zdGFuY2U7XHJcbiAgICAgICAgaWYgKGRpc3BsYXlFdmVudFRpbWUgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBkaXNwbGF5RXZlbnRUaW1lID0gZGVmYXVsdERpc3BsYXlFdmVudFRpbWUgIT09IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZGlzcGxheUV2ZW50RW5kID09IG51bGwpIHtcclxuICAgICAgICAgICAgZGlzcGxheUV2ZW50RW5kID0gZGVmYXVsdERpc3BsYXlFdmVudEVuZCAhPT0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCB3aG9sZUV2ZW50U3RhcnQgPSBldmVudEluc3RhbmNlLnJhbmdlLnN0YXJ0O1xyXG4gICAgICAgIGxldCB3aG9sZUV2ZW50RW5kID0gZXZlbnRJbnN0YW5jZS5yYW5nZS5lbmQ7XHJcbiAgICAgICAgbGV0IHNlZ1N0YXJ0ID0gc3RhcnRPdmVycmlkZSB8fCBzZWcuc3RhcnQgfHwgc2VnLmV2ZW50UmFuZ2UucmFuZ2Uuc3RhcnQ7XHJcbiAgICAgICAgbGV0IHNlZ0VuZCA9IGVuZE92ZXJyaWRlIHx8IHNlZy5lbmQgfHwgc2VnLmV2ZW50UmFuZ2UucmFuZ2UuZW5kO1xyXG4gICAgICAgIGxldCBpc1N0YXJ0RGF5ID0gc3RhcnRPZkRheSh3aG9sZUV2ZW50U3RhcnQpLnZhbHVlT2YoKSA9PT0gc3RhcnRPZkRheShzZWdTdGFydCkudmFsdWVPZigpO1xyXG4gICAgICAgIGxldCBpc0VuZERheSA9IHN0YXJ0T2ZEYXkoYWRkTXMod2hvbGVFdmVudEVuZCwgLTEpKS52YWx1ZU9mKCkgPT09IHN0YXJ0T2ZEYXkoYWRkTXMoc2VnRW5kLCAtMSkpLnZhbHVlT2YoKTtcclxuICAgICAgICBpZiAoZGlzcGxheUV2ZW50VGltZSAmJiAhZXZlbnREZWYuYWxsRGF5ICYmIChpc1N0YXJ0RGF5IHx8IGlzRW5kRGF5KSkge1xyXG4gICAgICAgICAgICBzZWdTdGFydCA9IGlzU3RhcnREYXkgPyB3aG9sZUV2ZW50U3RhcnQgOiBzZWdTdGFydDtcclxuICAgICAgICAgICAgc2VnRW5kID0gaXNFbmREYXkgPyB3aG9sZUV2ZW50RW5kIDogc2VnRW5kO1xyXG4gICAgICAgICAgICBpZiAoZGlzcGxheUV2ZW50RW5kICYmIGV2ZW50RGVmLmhhc0VuZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGVFbnYuZm9ybWF0UmFuZ2Uoc2VnU3RhcnQsIHNlZ0VuZCwgdGltZUZvcm1hdCwge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvcmNlZFN0YXJ0VHpvOiBzdGFydE92ZXJyaWRlID8gbnVsbCA6IGV2ZW50SW5zdGFuY2UuZm9yY2VkU3RhcnRUem8sXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yY2VkRW5kVHpvOiBlbmRPdmVycmlkZSA/IG51bGwgOiBldmVudEluc3RhbmNlLmZvcmNlZEVuZFR6byxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBkYXRlRW52LmZvcm1hdChzZWdTdGFydCwgdGltZUZvcm1hdCwge1xyXG4gICAgICAgICAgICAgICAgZm9yY2VkVHpvOiBzdGFydE92ZXJyaWRlID8gbnVsbCA6IGV2ZW50SW5zdGFuY2UuZm9yY2VkU3RhcnRUem8sIC8vIG5vb29vbywgc2FtZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZ2V0U2VnTWV0YShzZWcsIHRvZGF5UmFuZ2UsIG5vd0RhdGUpIHtcclxuICAgICAgICBsZXQgc2VnUmFuZ2UgPSBzZWcuZXZlbnRSYW5nZS5yYW5nZTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBpc1Bhc3Q6IHNlZ1JhbmdlLmVuZCA8IChub3dEYXRlIHx8IHRvZGF5UmFuZ2Uuc3RhcnQpLFxyXG4gICAgICAgICAgICBpc0Z1dHVyZTogc2VnUmFuZ2Uuc3RhcnQgPj0gKG5vd0RhdGUgfHwgdG9kYXlSYW5nZS5lbmQpLFxyXG4gICAgICAgICAgICBpc1RvZGF5OiB0b2RheVJhbmdlICYmIHJhbmdlQ29udGFpbnNNYXJrZXIodG9kYXlSYW5nZSwgc2VnUmFuZ2Uuc3RhcnQpLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBnZXRFdmVudENsYXNzTmFtZXMocHJvcHMpIHtcclxuICAgICAgICBsZXQgY2xhc3NOYW1lcyA9IFsnZmMtZXZlbnQnXTtcclxuICAgICAgICBpZiAocHJvcHMuaXNNaXJyb3IpIHtcclxuICAgICAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1ldmVudC1taXJyb3InKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHByb3BzLmlzRHJhZ2dhYmxlKSB7XHJcbiAgICAgICAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtZXZlbnQtZHJhZ2dhYmxlJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwcm9wcy5pc1N0YXJ0UmVzaXphYmxlIHx8IHByb3BzLmlzRW5kUmVzaXphYmxlKSB7XHJcbiAgICAgICAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtZXZlbnQtcmVzaXphYmxlJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwcm9wcy5pc0RyYWdnaW5nKSB7XHJcbiAgICAgICAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtZXZlbnQtZHJhZ2dpbmcnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHByb3BzLmlzUmVzaXppbmcpIHtcclxuICAgICAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1ldmVudC1yZXNpemluZycpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocHJvcHMuaXNTZWxlY3RlZCkge1xyXG4gICAgICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLWV2ZW50LXNlbGVjdGVkJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwcm9wcy5pc1N0YXJ0KSB7XHJcbiAgICAgICAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtZXZlbnQtc3RhcnQnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHByb3BzLmlzRW5kKSB7XHJcbiAgICAgICAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtZXZlbnQtZW5kJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwcm9wcy5pc1Bhc3QpIHtcclxuICAgICAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1ldmVudC1wYXN0Jyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwcm9wcy5pc1RvZGF5KSB7XHJcbiAgICAgICAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtZXZlbnQtdG9kYXknKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHByb3BzLmlzRnV0dXJlKSB7XHJcbiAgICAgICAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtZXZlbnQtZnV0dXJlJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjbGFzc05hbWVzO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYnVpbGRFdmVudFJhbmdlS2V5KGV2ZW50UmFuZ2UpIHtcclxuICAgICAgICByZXR1cm4gZXZlbnRSYW5nZS5pbnN0YW5jZVxyXG4gICAgICAgICAgICA/IGV2ZW50UmFuZ2UuaW5zdGFuY2UuaW5zdGFuY2VJZFxyXG4gICAgICAgICAgICA6IGAke2V2ZW50UmFuZ2UuZGVmLmRlZklkfToke2V2ZW50UmFuZ2UucmFuZ2Uuc3RhcnQudG9JU09TdHJpbmcoKX1gO1xyXG4gICAgICAgIC8vIGludmVyc2UtYmFja2dyb3VuZCBldmVudHMgZG9uJ3QgaGF2ZSBzcGVjaWZpYyBpbnN0YW5jZXMuIFRPRE86IGJldHRlciBzb2x1dGlvblxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZ2V0U2VnQW5jaG9yQXR0cnMoc2VnLCBjb250ZXh0KSB7XHJcbiAgICAgICAgbGV0IHsgZGVmLCBpbnN0YW5jZSB9ID0gc2VnLmV2ZW50UmFuZ2U7XHJcbiAgICAgICAgbGV0IHsgdXJsIH0gPSBkZWY7XHJcbiAgICAgICAgaWYgKHVybCkge1xyXG4gICAgICAgICAgICByZXR1cm4geyBocmVmOiB1cmwgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHsgZW1pdHRlciwgb3B0aW9ucyB9ID0gY29udGV4dDtcclxuICAgICAgICBsZXQgeyBldmVudEludGVyYWN0aXZlIH0gPSBvcHRpb25zO1xyXG4gICAgICAgIGlmIChldmVudEludGVyYWN0aXZlID09IG51bGwpIHtcclxuICAgICAgICAgICAgZXZlbnRJbnRlcmFjdGl2ZSA9IGRlZi5pbnRlcmFjdGl2ZTtcclxuICAgICAgICAgICAgaWYgKGV2ZW50SW50ZXJhY3RpdmUgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgZXZlbnRJbnRlcmFjdGl2ZSA9IEJvb2xlYW4oZW1pdHRlci5oYXNIYW5kbGVycygnZXZlbnRDbGljaycpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBtb2NrIHdoYXQgaGFwcGVucyBpbiBFdmVudENsaWNraW5nXHJcbiAgICAgICAgaWYgKGV2ZW50SW50ZXJhY3RpdmUpIHtcclxuICAgICAgICAgICAgLy8gb25seSBhdHRhY2gga2V5Ym9hcmQtcmVsYXRlZCBoYW5kbGVycyBiZWNhdXNlIGNsaWNrIGhhbmRsZXIgaXMgYWxyZWFkeSBkb25lIGluIEV2ZW50Q2xpY2tpbmdcclxuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUFyaWFLZXlib2FyZEF0dHJzKChldikgPT4ge1xyXG4gICAgICAgICAgICAgICAgZW1pdHRlci50cmlnZ2VyKCdldmVudENsaWNrJywge1xyXG4gICAgICAgICAgICAgICAgICAgIGVsOiBldi50YXJnZXQsXHJcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IG5ldyBFdmVudEltcGwoY29udGV4dCwgZGVmLCBpbnN0YW5jZSksXHJcbiAgICAgICAgICAgICAgICAgICAganNFdmVudDogZXYsXHJcbiAgICAgICAgICAgICAgICAgICAgdmlldzogY29udGV4dC52aWV3QXBpLFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4ge307XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgU1RBTkRBUkRfUFJPUFMgPSB7XHJcbiAgICAgICAgc3RhcnQ6IGlkZW50aXR5LFxyXG4gICAgICAgIGVuZDogaWRlbnRpdHksXHJcbiAgICAgICAgYWxsRGF5OiBCb29sZWFuLFxyXG4gICAgfTtcclxuICAgIGZ1bmN0aW9uIHBhcnNlRGF0ZVNwYW4ocmF3LCBkYXRlRW52LCBkZWZhdWx0RHVyYXRpb24pIHtcclxuICAgICAgICBsZXQgc3BhbiA9IHBhcnNlT3BlbkRhdGVTcGFuKHJhdywgZGF0ZUVudik7XHJcbiAgICAgICAgbGV0IHsgcmFuZ2UgfSA9IHNwYW47XHJcbiAgICAgICAgaWYgKCFyYW5nZS5zdGFydCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFyYW5nZS5lbmQpIHtcclxuICAgICAgICAgICAgaWYgKGRlZmF1bHREdXJhdGlvbiA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByYW5nZS5lbmQgPSBkYXRlRW52LmFkZChyYW5nZS5zdGFydCwgZGVmYXVsdER1cmF0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHNwYW47XHJcbiAgICB9XHJcbiAgICAvKlxyXG4gICAgVE9ETzogc29tZWhvdyBjb21iaW5lIHdpdGggcGFyc2VSYW5nZT9cclxuICAgIFdpbGwgcmV0dXJuIG51bGwgaWYgdGhlIHN0YXJ0L2VuZCBwcm9wcyB3ZXJlIHByZXNlbnQgYnV0IHBhcnNlZCBpbnZhbGlkbHkuXHJcbiAgICAqL1xyXG4gICAgZnVuY3Rpb24gcGFyc2VPcGVuRGF0ZVNwYW4ocmF3LCBkYXRlRW52KSB7XHJcbiAgICAgICAgbGV0IHsgcmVmaW5lZDogc3RhbmRhcmRQcm9wcywgZXh0cmEgfSA9IHJlZmluZVByb3BzKHJhdywgU1RBTkRBUkRfUFJPUFMpO1xyXG4gICAgICAgIGxldCBzdGFydE1ldGEgPSBzdGFuZGFyZFByb3BzLnN0YXJ0ID8gZGF0ZUVudi5jcmVhdGVNYXJrZXJNZXRhKHN0YW5kYXJkUHJvcHMuc3RhcnQpIDogbnVsbDtcclxuICAgICAgICBsZXQgZW5kTWV0YSA9IHN0YW5kYXJkUHJvcHMuZW5kID8gZGF0ZUVudi5jcmVhdGVNYXJrZXJNZXRhKHN0YW5kYXJkUHJvcHMuZW5kKSA6IG51bGw7XHJcbiAgICAgICAgbGV0IHsgYWxsRGF5IH0gPSBzdGFuZGFyZFByb3BzO1xyXG4gICAgICAgIGlmIChhbGxEYXkgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBhbGxEYXkgPSAoc3RhcnRNZXRhICYmIHN0YXJ0TWV0YS5pc1RpbWVVbnNwZWNpZmllZCkgJiZcclxuICAgICAgICAgICAgICAgICghZW5kTWV0YSB8fCBlbmRNZXRhLmlzVGltZVVuc3BlY2lmaWVkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oeyByYW5nZToge1xyXG4gICAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0TWV0YSA/IHN0YXJ0TWV0YS5tYXJrZXIgOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgZW5kOiBlbmRNZXRhID8gZW5kTWV0YS5tYXJrZXIgOiBudWxsLFxyXG4gICAgICAgICAgICB9LCBhbGxEYXkgfSwgZXh0cmEpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gaXNEYXRlU3BhbnNFcXVhbChzcGFuMCwgc3BhbjEpIHtcclxuICAgICAgICByZXR1cm4gcmFuZ2VzRXF1YWwoc3BhbjAucmFuZ2UsIHNwYW4xLnJhbmdlKSAmJlxyXG4gICAgICAgICAgICBzcGFuMC5hbGxEYXkgPT09IHNwYW4xLmFsbERheSAmJlxyXG4gICAgICAgICAgICBpc1NwYW5Qcm9wc0VxdWFsKHNwYW4wLCBzcGFuMSk7XHJcbiAgICB9XHJcbiAgICAvLyB0aGUgTk9OLURBVEUtUkVMQVRFRCBwcm9wc1xyXG4gICAgZnVuY3Rpb24gaXNTcGFuUHJvcHNFcXVhbChzcGFuMCwgc3BhbjEpIHtcclxuICAgICAgICBmb3IgKGxldCBwcm9wTmFtZSBpbiBzcGFuMSkge1xyXG4gICAgICAgICAgICBpZiAocHJvcE5hbWUgIT09ICdyYW5nZScgJiYgcHJvcE5hbWUgIT09ICdhbGxEYXknKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3BhbjBbcHJvcE5hbWVdICE9PSBzcGFuMVtwcm9wTmFtZV0pIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gYXJlIHRoZXJlIGFueSBwcm9wcyB0aGF0IHNwYW4wIGhhcyB0aGF0IHNwYW4xIERPRVNOJ1QgaGF2ZT9cclxuICAgICAgICAvLyBib3RoIGhhdmUgcmFuZ2UvYWxsRGF5LCBzbyBubyBuZWVkIHRvIHNwZWNpYWwtY2FzZS5cclxuICAgICAgICBmb3IgKGxldCBwcm9wTmFtZSBpbiBzcGFuMCkge1xyXG4gICAgICAgICAgICBpZiAoIShwcm9wTmFtZSBpbiBzcGFuMSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGJ1aWxkRGF0ZVNwYW5BcGkoc3BhbiwgZGF0ZUVudikge1xyXG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGJ1aWxkUmFuZ2VBcGkoc3Bhbi5yYW5nZSwgZGF0ZUVudiwgc3Bhbi5hbGxEYXkpKSwgeyBhbGxEYXk6IHNwYW4uYWxsRGF5IH0pO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYnVpbGRSYW5nZUFwaVdpdGhUaW1lWm9uZShyYW5nZSwgZGF0ZUVudiwgb21pdFRpbWUpIHtcclxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBidWlsZFJhbmdlQXBpKHJhbmdlLCBkYXRlRW52LCBvbWl0VGltZSkpLCB7IHRpbWVab25lOiBkYXRlRW52LnRpbWVab25lIH0pO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYnVpbGRSYW5nZUFwaShyYW5nZSwgZGF0ZUVudiwgb21pdFRpbWUpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBzdGFydDogZGF0ZUVudi50b0RhdGUocmFuZ2Uuc3RhcnQpLFxyXG4gICAgICAgICAgICBlbmQ6IGRhdGVFbnYudG9EYXRlKHJhbmdlLmVuZCksXHJcbiAgICAgICAgICAgIHN0YXJ0U3RyOiBkYXRlRW52LmZvcm1hdElzbyhyYW5nZS5zdGFydCwgeyBvbWl0VGltZSB9KSxcclxuICAgICAgICAgICAgZW5kU3RyOiBkYXRlRW52LmZvcm1hdElzbyhyYW5nZS5lbmQsIHsgb21pdFRpbWUgfSksXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGZhYnJpY2F0ZUV2ZW50UmFuZ2UoZGF0ZVNwYW4sIGV2ZW50VWlCYXNlcywgY29udGV4dCkge1xyXG4gICAgICAgIGxldCByZXMgPSByZWZpbmVFdmVudERlZih7IGVkaXRhYmxlOiBmYWxzZSB9LCBjb250ZXh0KTtcclxuICAgICAgICBsZXQgZGVmID0gcGFyc2VFdmVudERlZihyZXMucmVmaW5lZCwgcmVzLmV4dHJhLCAnJywgLy8gc291cmNlSWRcclxuICAgICAgICBkYXRlU3Bhbi5hbGxEYXksIHRydWUsIC8vIGhhc0VuZFxyXG4gICAgICAgIGNvbnRleHQpO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGRlZixcclxuICAgICAgICAgICAgdWk6IGNvbXBpbGVFdmVudFVpKGRlZiwgZXZlbnRVaUJhc2VzKSxcclxuICAgICAgICAgICAgaW5zdGFuY2U6IGNyZWF0ZUV2ZW50SW5zdGFuY2UoZGVmLmRlZklkLCBkYXRlU3Bhbi5yYW5nZSksXHJcbiAgICAgICAgICAgIHJhbmdlOiBkYXRlU3Bhbi5yYW5nZSxcclxuICAgICAgICAgICAgaXNTdGFydDogdHJ1ZSxcclxuICAgICAgICAgICAgaXNFbmQ6IHRydWUsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBsZXQgY2FsZW5kYXJTeXN0ZW1DbGFzc01hcCA9IHt9O1xyXG4gICAgZnVuY3Rpb24gcmVnaXN0ZXJDYWxlbmRhclN5c3RlbShuYW1lLCB0aGVDbGFzcykge1xyXG4gICAgICAgIGNhbGVuZGFyU3lzdGVtQ2xhc3NNYXBbbmFtZV0gPSB0aGVDbGFzcztcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGNyZWF0ZUNhbGVuZGFyU3lzdGVtKG5hbWUpIHtcclxuICAgICAgICByZXR1cm4gbmV3IGNhbGVuZGFyU3lzdGVtQ2xhc3NNYXBbbmFtZV0oKTtcclxuICAgIH1cclxuICAgIGNsYXNzIEdyZWdvcmlhbkNhbGVuZGFyU3lzdGVtIHtcclxuICAgICAgICBnZXRNYXJrZXJZZWFyKGQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGQuZ2V0VVRDRnVsbFllYXIoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZ2V0TWFya2VyTW9udGgoZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZC5nZXRVVENNb250aCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBnZXRNYXJrZXJEYXkoZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZC5nZXRVVENEYXRlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGFycmF5VG9NYXJrZXIoYXJyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhcnJheVRvVXRjRGF0ZShhcnIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBtYXJrZXJUb0FycmF5KG1hcmtlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gZGF0ZVRvVXRjQXJyYXkobWFya2VyKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZWdpc3RlckNhbGVuZGFyU3lzdGVtKCdncmVnb3J5JywgR3JlZ29yaWFuQ2FsZW5kYXJTeXN0ZW0pO1xyXG5cclxuICAgIGNvbnN0IElTT19SRSA9IC9eXFxzKihcXGR7NH0pKC0/KFxcZHsyfSkoLT8oXFxkezJ9KShbVCBdKFxcZHsyfSk6PyhcXGR7Mn0pKDo/KFxcZHsyfSkoXFwuKFxcZCspKT8pPyhafCgoWy0rXSkoXFxkezJ9KSg6PyhcXGR7Mn0pKT8pKT8pPyk/KT8kLztcclxuICAgIGZ1bmN0aW9uIHBhcnNlKHN0cikge1xyXG4gICAgICAgIGxldCBtID0gSVNPX1JFLmV4ZWMoc3RyKTtcclxuICAgICAgICBpZiAobSkge1xyXG4gICAgICAgICAgICBsZXQgbWFya2VyID0gbmV3IERhdGUoRGF0ZS5VVEMoTnVtYmVyKG1bMV0pLCBtWzNdID8gTnVtYmVyKG1bM10pIC0gMSA6IDAsIE51bWJlcihtWzVdIHx8IDEpLCBOdW1iZXIobVs3XSB8fCAwKSwgTnVtYmVyKG1bOF0gfHwgMCksIE51bWJlcihtWzEwXSB8fCAwKSwgbVsxMl0gPyBOdW1iZXIoYDAuJHttWzEyXX1gKSAqIDEwMDAgOiAwKSk7XHJcbiAgICAgICAgICAgIGlmIChpc1ZhbGlkRGF0ZShtYXJrZXIpKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgdGltZVpvbmVPZmZzZXQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgaWYgKG1bMTNdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGltZVpvbmVPZmZzZXQgPSAobVsxNV0gPT09ICctJyA/IC0xIDogMSkgKiAoTnVtYmVyKG1bMTZdIHx8IDApICogNjAgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBOdW1iZXIobVsxOF0gfHwgMCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICBtYXJrZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgaXNUaW1lVW5zcGVjaWZpZWQ6ICFtWzZdLFxyXG4gICAgICAgICAgICAgICAgICAgIHRpbWVab25lT2Zmc2V0LFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBjbGFzcyBEYXRlRW52IHtcclxuICAgICAgICBjb25zdHJ1Y3RvcihzZXR0aW5ncykge1xyXG4gICAgICAgICAgICBsZXQgdGltZVpvbmUgPSB0aGlzLnRpbWVab25lID0gc2V0dGluZ3MudGltZVpvbmU7XHJcbiAgICAgICAgICAgIGxldCBpc05hbWVkVGltZVpvbmUgPSB0aW1lWm9uZSAhPT0gJ2xvY2FsJyAmJiB0aW1lWm9uZSAhPT0gJ1VUQyc7XHJcbiAgICAgICAgICAgIGlmIChzZXR0aW5ncy5uYW1lZFRpbWVab25lSW1wbCAmJiBpc05hbWVkVGltZVpvbmUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubmFtZWRUaW1lWm9uZUltcGwgPSBuZXcgc2V0dGluZ3MubmFtZWRUaW1lWm9uZUltcGwodGltZVpvbmUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuY2FuQ29tcHV0ZU9mZnNldCA9IEJvb2xlYW4oIWlzTmFtZWRUaW1lWm9uZSB8fCB0aGlzLm5hbWVkVGltZVpvbmVJbXBsKTtcclxuICAgICAgICAgICAgdGhpcy5jYWxlbmRhclN5c3RlbSA9IGNyZWF0ZUNhbGVuZGFyU3lzdGVtKHNldHRpbmdzLmNhbGVuZGFyU3lzdGVtKTtcclxuICAgICAgICAgICAgdGhpcy5sb2NhbGUgPSBzZXR0aW5ncy5sb2NhbGU7XHJcbiAgICAgICAgICAgIHRoaXMud2Vla0RvdyA9IHNldHRpbmdzLmxvY2FsZS53ZWVrLmRvdztcclxuICAgICAgICAgICAgdGhpcy53ZWVrRG95ID0gc2V0dGluZ3MubG9jYWxlLndlZWsuZG95O1xyXG4gICAgICAgICAgICBpZiAoc2V0dGluZ3Mud2Vla051bWJlckNhbGN1bGF0aW9uID09PSAnSVNPJykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy53ZWVrRG93ID0gMTtcclxuICAgICAgICAgICAgICAgIHRoaXMud2Vla0RveSA9IDQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBzZXR0aW5ncy5maXJzdERheSA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMud2Vla0RvdyA9IHNldHRpbmdzLmZpcnN0RGF5O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2V0dGluZ3Mud2Vla051bWJlckNhbGN1bGF0aW9uID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLndlZWtOdW1iZXJGdW5jID0gc2V0dGluZ3Mud2Vla051bWJlckNhbGN1bGF0aW9uO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMud2Vla1RleHQgPSBzZXR0aW5ncy53ZWVrVGV4dCAhPSBudWxsID8gc2V0dGluZ3Mud2Vla1RleHQgOiBzZXR0aW5ncy5sb2NhbGUub3B0aW9ucy53ZWVrVGV4dDtcclxuICAgICAgICAgICAgdGhpcy53ZWVrVGV4dExvbmcgPSAoc2V0dGluZ3Mud2Vla1RleHRMb25nICE9IG51bGwgPyBzZXR0aW5ncy53ZWVrVGV4dExvbmcgOiBzZXR0aW5ncy5sb2NhbGUub3B0aW9ucy53ZWVrVGV4dExvbmcpIHx8IHRoaXMud2Vla1RleHQ7XHJcbiAgICAgICAgICAgIHRoaXMuY21kRm9ybWF0dGVyID0gc2V0dGluZ3MuY21kRm9ybWF0dGVyO1xyXG4gICAgICAgICAgICB0aGlzLmRlZmF1bHRTZXBhcmF0b3IgPSBzZXR0aW5ncy5kZWZhdWx0U2VwYXJhdG9yO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBDcmVhdGluZyAvIFBhcnNpbmdcclxuICAgICAgICBjcmVhdGVNYXJrZXIoaW5wdXQpIHtcclxuICAgICAgICAgICAgbGV0IG1ldGEgPSB0aGlzLmNyZWF0ZU1hcmtlck1ldGEoaW5wdXQpO1xyXG4gICAgICAgICAgICBpZiAobWV0YSA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG1ldGEubWFya2VyO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjcmVhdGVOb3dNYXJrZXIoKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNhbkNvbXB1dGVPZmZzZXQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRpbWVzdGFtcFRvTWFya2VyKG5ldyBEYXRlKCkudmFsdWVPZigpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBpZiB3ZSBjYW4ndCBjb21wdXRlIHRoZSBjdXJyZW50IGRhdGUgdmFsIGZvciBhIHRpbWV6b25lLFxyXG4gICAgICAgICAgICAvLyBiZXR0ZXIgdG8gZ2l2ZSB0aGUgY3VycmVudCBsb2NhbCBkYXRlIHZhbHMgdGhhbiBVVENcclxuICAgICAgICAgICAgcmV0dXJuIGFycmF5VG9VdGNEYXRlKGRhdGVUb0xvY2FsQXJyYXkobmV3IERhdGUoKSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjcmVhdGVNYXJrZXJNZXRhKGlucHV0KSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZShpbnB1dCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IG1hcmtlciA9IG51bGw7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgICAgICBtYXJrZXIgPSB0aGlzLnRpbWVzdGFtcFRvTWFya2VyKGlucHV0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChpbnB1dCBpbnN0YW5jZW9mIERhdGUpIHtcclxuICAgICAgICAgICAgICAgIGlucHV0ID0gaW5wdXQudmFsdWVPZigpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc05hTihpbnB1dCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBtYXJrZXIgPSB0aGlzLnRpbWVzdGFtcFRvTWFya2VyKGlucHV0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGlucHV0KSkge1xyXG4gICAgICAgICAgICAgICAgbWFya2VyID0gYXJyYXlUb1V0Y0RhdGUoaW5wdXQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChtYXJrZXIgPT09IG51bGwgfHwgIWlzVmFsaWREYXRlKG1hcmtlcikpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB7IG1hcmtlciwgaXNUaW1lVW5zcGVjaWZpZWQ6IGZhbHNlLCBmb3JjZWRUem86IG51bGwgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcGFyc2Uocykge1xyXG4gICAgICAgICAgICBsZXQgcGFydHMgPSBwYXJzZShzKTtcclxuICAgICAgICAgICAgaWYgKHBhcnRzID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgeyBtYXJrZXIgfSA9IHBhcnRzO1xyXG4gICAgICAgICAgICBsZXQgZm9yY2VkVHpvID0gbnVsbDtcclxuICAgICAgICAgICAgaWYgKHBhcnRzLnRpbWVab25lT2Zmc2V0ICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jYW5Db21wdXRlT2Zmc2V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWFya2VyID0gdGhpcy50aW1lc3RhbXBUb01hcmtlcihtYXJrZXIudmFsdWVPZigpIC0gcGFydHMudGltZVpvbmVPZmZzZXQgKiA2MCAqIDEwMDApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yY2VkVHpvID0gcGFydHMudGltZVpvbmVPZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHsgbWFya2VyLCBpc1RpbWVVbnNwZWNpZmllZDogcGFydHMuaXNUaW1lVW5zcGVjaWZpZWQsIGZvcmNlZFR6byB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBBY2Nlc3NvcnNcclxuICAgICAgICBnZXRZZWFyKG1hcmtlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJZZWFyKG1hcmtlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGdldE1vbnRoKG1hcmtlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJNb250aChtYXJrZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBnZXREYXkobWFya2VyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNhbGVuZGFyU3lzdGVtLmdldE1hcmtlckRheShtYXJrZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBBZGRpbmcgLyBTdWJ0cmFjdGluZ1xyXG4gICAgICAgIGFkZChtYXJrZXIsIGR1cikge1xyXG4gICAgICAgICAgICBsZXQgYSA9IHRoaXMuY2FsZW5kYXJTeXN0ZW0ubWFya2VyVG9BcnJheShtYXJrZXIpO1xyXG4gICAgICAgICAgICBhWzBdICs9IGR1ci55ZWFycztcclxuICAgICAgICAgICAgYVsxXSArPSBkdXIubW9udGhzO1xyXG4gICAgICAgICAgICBhWzJdICs9IGR1ci5kYXlzO1xyXG4gICAgICAgICAgICBhWzZdICs9IGR1ci5taWxsaXNlY29uZHM7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNhbGVuZGFyU3lzdGVtLmFycmF5VG9NYXJrZXIoYSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN1YnRyYWN0KG1hcmtlciwgZHVyKSB7XHJcbiAgICAgICAgICAgIGxldCBhID0gdGhpcy5jYWxlbmRhclN5c3RlbS5tYXJrZXJUb0FycmF5KG1hcmtlcik7XHJcbiAgICAgICAgICAgIGFbMF0gLT0gZHVyLnllYXJzO1xyXG4gICAgICAgICAgICBhWzFdIC09IGR1ci5tb250aHM7XHJcbiAgICAgICAgICAgIGFbMl0gLT0gZHVyLmRheXM7XHJcbiAgICAgICAgICAgIGFbNl0gLT0gZHVyLm1pbGxpc2Vjb25kcztcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2FsZW5kYXJTeXN0ZW0uYXJyYXlUb01hcmtlcihhKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYWRkWWVhcnMobWFya2VyLCBuKSB7XHJcbiAgICAgICAgICAgIGxldCBhID0gdGhpcy5jYWxlbmRhclN5c3RlbS5tYXJrZXJUb0FycmF5KG1hcmtlcik7XHJcbiAgICAgICAgICAgIGFbMF0gKz0gbjtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2FsZW5kYXJTeXN0ZW0uYXJyYXlUb01hcmtlcihhKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYWRkTW9udGhzKG1hcmtlciwgbikge1xyXG4gICAgICAgICAgICBsZXQgYSA9IHRoaXMuY2FsZW5kYXJTeXN0ZW0ubWFya2VyVG9BcnJheShtYXJrZXIpO1xyXG4gICAgICAgICAgICBhWzFdICs9IG47XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNhbGVuZGFyU3lzdGVtLmFycmF5VG9NYXJrZXIoYSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIERpZmZpbmcgV2hvbGUgVW5pdHNcclxuICAgICAgICBkaWZmV2hvbGVZZWFycyhtMCwgbTEpIHtcclxuICAgICAgICAgICAgbGV0IHsgY2FsZW5kYXJTeXN0ZW0gfSA9IHRoaXM7XHJcbiAgICAgICAgICAgIGlmICh0aW1lQXNNcyhtMCkgPT09IHRpbWVBc01zKG0xKSAmJlxyXG4gICAgICAgICAgICAgICAgY2FsZW5kYXJTeXN0ZW0uZ2V0TWFya2VyRGF5KG0wKSA9PT0gY2FsZW5kYXJTeXN0ZW0uZ2V0TWFya2VyRGF5KG0xKSAmJlxyXG4gICAgICAgICAgICAgICAgY2FsZW5kYXJTeXN0ZW0uZ2V0TWFya2VyTW9udGgobTApID09PSBjYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJNb250aChtMSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJZZWFyKG0xKSAtIGNhbGVuZGFyU3lzdGVtLmdldE1hcmtlclllYXIobTApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkaWZmV2hvbGVNb250aHMobTAsIG0xKSB7XHJcbiAgICAgICAgICAgIGxldCB7IGNhbGVuZGFyU3lzdGVtIH0gPSB0aGlzO1xyXG4gICAgICAgICAgICBpZiAodGltZUFzTXMobTApID09PSB0aW1lQXNNcyhtMSkgJiZcclxuICAgICAgICAgICAgICAgIGNhbGVuZGFyU3lzdGVtLmdldE1hcmtlckRheShtMCkgPT09IGNhbGVuZGFyU3lzdGVtLmdldE1hcmtlckRheShtMSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAoY2FsZW5kYXJTeXN0ZW0uZ2V0TWFya2VyTW9udGgobTEpIC0gY2FsZW5kYXJTeXN0ZW0uZ2V0TWFya2VyTW9udGgobTApKSArXHJcbiAgICAgICAgICAgICAgICAgICAgKGNhbGVuZGFyU3lzdGVtLmdldE1hcmtlclllYXIobTEpIC0gY2FsZW5kYXJTeXN0ZW0uZ2V0TWFya2VyWWVhcihtMCkpICogMTI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFJhbmdlIC8gRHVyYXRpb25cclxuICAgICAgICBncmVhdGVzdFdob2xlVW5pdChtMCwgbTEpIHtcclxuICAgICAgICAgICAgbGV0IG4gPSB0aGlzLmRpZmZXaG9sZVllYXJzKG0wLCBtMSk7XHJcbiAgICAgICAgICAgIGlmIChuICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4geyB1bml0OiAneWVhcicsIHZhbHVlOiBuIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbiA9IHRoaXMuZGlmZldob2xlTW9udGhzKG0wLCBtMSk7XHJcbiAgICAgICAgICAgIGlmIChuICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4geyB1bml0OiAnbW9udGgnLCB2YWx1ZTogbiB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG4gPSBkaWZmV2hvbGVXZWVrcyhtMCwgbTEpO1xyXG4gICAgICAgICAgICBpZiAobiAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdW5pdDogJ3dlZWsnLCB2YWx1ZTogbiB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG4gPSBkaWZmV2hvbGVEYXlzKG0wLCBtMSk7XHJcbiAgICAgICAgICAgIGlmIChuICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4geyB1bml0OiAnZGF5JywgdmFsdWU6IG4gfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBuID0gZGlmZkhvdXJzKG0wLCBtMSk7XHJcbiAgICAgICAgICAgIGlmIChpc0ludChuKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdW5pdDogJ2hvdXInLCB2YWx1ZTogbiB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG4gPSBkaWZmTWludXRlcyhtMCwgbTEpO1xyXG4gICAgICAgICAgICBpZiAoaXNJbnQobikpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7IHVuaXQ6ICdtaW51dGUnLCB2YWx1ZTogbiB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG4gPSBkaWZmU2Vjb25kcyhtMCwgbTEpO1xyXG4gICAgICAgICAgICBpZiAoaXNJbnQobikpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7IHVuaXQ6ICdzZWNvbmQnLCB2YWx1ZTogbiB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB7IHVuaXQ6ICdtaWxsaXNlY29uZCcsIHZhbHVlOiBtMS52YWx1ZU9mKCkgLSBtMC52YWx1ZU9mKCkgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY291bnREdXJhdGlvbnNCZXR3ZWVuKG0wLCBtMSwgZCkge1xyXG4gICAgICAgICAgICAvLyBUT0RPOiBjYW4gdXNlIGdyZWF0ZXN0V2hvbGVVbml0XHJcbiAgICAgICAgICAgIGxldCBkaWZmO1xyXG4gICAgICAgICAgICBpZiAoZC55ZWFycykge1xyXG4gICAgICAgICAgICAgICAgZGlmZiA9IHRoaXMuZGlmZldob2xlWWVhcnMobTAsIG0xKTtcclxuICAgICAgICAgICAgICAgIGlmIChkaWZmICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRpZmYgLyBhc1JvdWdoWWVhcnMoZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGQubW9udGhzKSB7XHJcbiAgICAgICAgICAgICAgICBkaWZmID0gdGhpcy5kaWZmV2hvbGVNb250aHMobTAsIG0xKTtcclxuICAgICAgICAgICAgICAgIGlmIChkaWZmICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRpZmYgLyBhc1JvdWdoTW9udGhzKGQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChkLmRheXMpIHtcclxuICAgICAgICAgICAgICAgIGRpZmYgPSBkaWZmV2hvbGVEYXlzKG0wLCBtMSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGlmZiAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkaWZmIC8gYXNSb3VnaERheXMoZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIChtMS52YWx1ZU9mKCkgLSBtMC52YWx1ZU9mKCkpIC8gYXNSb3VnaE1zKGQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBTdGFydC1PZlxyXG4gICAgICAgIC8vIHRoZXNlIERPTidUIHJldHVybiB6b25lZC1kYXRlcy4gb25seSBVVEMgc3RhcnQtb2YgZGF0ZXNcclxuICAgICAgICBzdGFydE9mKG0sIHVuaXQpIHtcclxuICAgICAgICAgICAgaWYgKHVuaXQgPT09ICd5ZWFyJykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnRPZlllYXIobSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHVuaXQgPT09ICdtb250aCcpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YXJ0T2ZNb250aChtKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodW5pdCA9PT0gJ3dlZWsnKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zdGFydE9mV2VlayhtKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodW5pdCA9PT0gJ2RheScpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzdGFydE9mRGF5KG0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh1bml0ID09PSAnaG91cicpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzdGFydE9mSG91cihtKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodW5pdCA9PT0gJ21pbnV0ZScpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzdGFydE9mTWludXRlKG0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh1bml0ID09PSAnc2Vjb25kJykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXJ0T2ZTZWNvbmQobSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN0YXJ0T2ZZZWFyKG0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2FsZW5kYXJTeXN0ZW0uYXJyYXlUb01hcmtlcihbXHJcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGVuZGFyU3lzdGVtLmdldE1hcmtlclllYXIobSksXHJcbiAgICAgICAgICAgIF0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzdGFydE9mTW9udGgobSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jYWxlbmRhclN5c3RlbS5hcnJheVRvTWFya2VyKFtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2FsZW5kYXJTeXN0ZW0uZ2V0TWFya2VyWWVhcihtKSxcclxuICAgICAgICAgICAgICAgIHRoaXMuY2FsZW5kYXJTeXN0ZW0uZ2V0TWFya2VyTW9udGgobSksXHJcbiAgICAgICAgICAgIF0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzdGFydE9mV2VlayhtKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNhbGVuZGFyU3lzdGVtLmFycmF5VG9NYXJrZXIoW1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJZZWFyKG0pLFxyXG4gICAgICAgICAgICAgICAgdGhpcy5jYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJNb250aChtKSxcclxuICAgICAgICAgICAgICAgIG0uZ2V0VVRDRGF0ZSgpIC0gKChtLmdldFVUQ0RheSgpIC0gdGhpcy53ZWVrRG93ICsgNykgJSA3KSxcclxuICAgICAgICAgICAgXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFdlZWsgTnVtYmVyXHJcbiAgICAgICAgY29tcHV0ZVdlZWtOdW1iZXIobWFya2VyKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLndlZWtOdW1iZXJGdW5jKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy53ZWVrTnVtYmVyRnVuYyh0aGlzLnRvRGF0ZShtYXJrZXIpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gd2Vla09mWWVhcihtYXJrZXIsIHRoaXMud2Vla0RvdywgdGhpcy53ZWVrRG95KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVE9ETzogY2hva2Ugb24gdGltZVpvbmVOYW1lOiBsb25nXHJcbiAgICAgICAgZm9ybWF0KG1hcmtlciwgZm9ybWF0dGVyLCBkYXRlT3B0aW9ucyA9IHt9KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmb3JtYXR0ZXIuZm9ybWF0KHtcclxuICAgICAgICAgICAgICAgIG1hcmtlcixcclxuICAgICAgICAgICAgICAgIHRpbWVab25lT2Zmc2V0OiBkYXRlT3B0aW9ucy5mb3JjZWRUem8gIT0gbnVsbCA/XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0ZU9wdGlvbnMuZm9yY2VkVHpvIDpcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9mZnNldEZvck1hcmtlcihtYXJrZXIpLFxyXG4gICAgICAgICAgICB9LCB0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9ybWF0UmFuZ2Uoc3RhcnQsIGVuZCwgZm9ybWF0dGVyLCBkYXRlT3B0aW9ucyA9IHt9KSB7XHJcbiAgICAgICAgICAgIGlmIChkYXRlT3B0aW9ucy5pc0VuZEV4Y2x1c2l2ZSkge1xyXG4gICAgICAgICAgICAgICAgZW5kID0gYWRkTXMoZW5kLCAtMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdHRlci5mb3JtYXRSYW5nZSh7XHJcbiAgICAgICAgICAgICAgICBtYXJrZXI6IHN0YXJ0LFxyXG4gICAgICAgICAgICAgICAgdGltZVpvbmVPZmZzZXQ6IGRhdGVPcHRpb25zLmZvcmNlZFN0YXJ0VHpvICE9IG51bGwgP1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGVPcHRpb25zLmZvcmNlZFN0YXJ0VHpvIDpcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9mZnNldEZvck1hcmtlcihzdGFydCksXHJcbiAgICAgICAgICAgIH0sIHtcclxuICAgICAgICAgICAgICAgIG1hcmtlcjogZW5kLFxyXG4gICAgICAgICAgICAgICAgdGltZVpvbmVPZmZzZXQ6IGRhdGVPcHRpb25zLmZvcmNlZEVuZFR6byAhPSBudWxsID9cclxuICAgICAgICAgICAgICAgICAgICBkYXRlT3B0aW9ucy5mb3JjZWRFbmRUem8gOlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub2Zmc2V0Rm9yTWFya2VyKGVuZCksXHJcbiAgICAgICAgICAgIH0sIHRoaXMsIGRhdGVPcHRpb25zLmRlZmF1bHRTZXBhcmF0b3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKlxyXG4gICAgICAgIERVTUI6IHRoZSBvbWl0VGltZSBhcmcgaXMgZHVtYi4gaWYgd2Ugb21pdCB0aGUgdGltZSwgd2Ugd2FudCB0byBvbWl0IHRoZSB0aW1lem9uZSBvZmZzZXQuIGFuZCBpZiB3ZSBkbyB0aGF0LFxyXG4gICAgICAgIG1pZ2h0IGFzIHdlbGwgdXNlIGJ1aWxkSXNvU3RyaW5nIG9yIHNvbWUgb3RoZXIgdXRpbCBkaXJlY3RseVxyXG4gICAgICAgICovXHJcbiAgICAgICAgZm9ybWF0SXNvKG1hcmtlciwgZXh0cmFPcHRpb25zID0ge30pIHtcclxuICAgICAgICAgICAgbGV0IHRpbWVab25lT2Zmc2V0ID0gbnVsbDtcclxuICAgICAgICAgICAgaWYgKCFleHRyYU9wdGlvbnMub21pdFRpbWVab25lT2Zmc2V0KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXh0cmFPcHRpb25zLmZvcmNlZFR6byAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGltZVpvbmVPZmZzZXQgPSBleHRyYU9wdGlvbnMuZm9yY2VkVHpvO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGltZVpvbmVPZmZzZXQgPSB0aGlzLm9mZnNldEZvck1hcmtlcihtYXJrZXIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBidWlsZElzb1N0cmluZyhtYXJrZXIsIHRpbWVab25lT2Zmc2V0LCBleHRyYU9wdGlvbnMub21pdFRpbWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBUaW1lWm9uZVxyXG4gICAgICAgIHRpbWVzdGFtcFRvTWFya2VyKG1zKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnRpbWVab25lID09PSAnbG9jYWwnKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJyYXlUb1V0Y0RhdGUoZGF0ZVRvTG9jYWxBcnJheShuZXcgRGF0ZShtcykpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy50aW1lWm9uZSA9PT0gJ1VUQycgfHwgIXRoaXMubmFtZWRUaW1lWm9uZUltcGwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZShtcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGFycmF5VG9VdGNEYXRlKHRoaXMubmFtZWRUaW1lWm9uZUltcGwudGltZXN0YW1wVG9BcnJheShtcykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBvZmZzZXRGb3JNYXJrZXIobSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy50aW1lWm9uZSA9PT0gJ2xvY2FsJykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIC1hcnJheVRvTG9jYWxEYXRlKGRhdGVUb1V0Y0FycmF5KG0pKS5nZXRUaW1lem9uZU9mZnNldCgpOyAvLyBjb252ZXJ0IFwiaW52ZXJzZVwiIG9mZnNldCB0byBcIm5vcm1hbFwiIG9mZnNldFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnRpbWVab25lID09PSAnVVRDJykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMubmFtZWRUaW1lWm9uZUltcGwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm5hbWVkVGltZVpvbmVJbXBsLm9mZnNldEZvckFycmF5KGRhdGVUb1V0Y0FycmF5KG0pKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQ29udmVyc2lvblxyXG4gICAgICAgIHRvRGF0ZShtLCBmb3JjZWRUem8pIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMudGltZVpvbmUgPT09ICdsb2NhbCcpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhcnJheVRvTG9jYWxEYXRlKGRhdGVUb1V0Y0FycmF5KG0pKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy50aW1lWm9uZSA9PT0gJ1VUQycpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZShtLnZhbHVlT2YoKSk7IC8vIG1ha2Ugc3VyZSBpdCdzIGEgY29weVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5uYW1lZFRpbWVab25lSW1wbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKG0udmFsdWVPZigpIC0gKGZvcmNlZFR6byB8fCAwKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKG0udmFsdWVPZigpIC1cclxuICAgICAgICAgICAgICAgIHRoaXMubmFtZWRUaW1lWm9uZUltcGwub2Zmc2V0Rm9yQXJyYXkoZGF0ZVRvVXRjQXJyYXkobSkpICogMTAwMCAqIDYwKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY2xhc3MgTmFtZWRUaW1lWm9uZUltcGwge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yKHRpbWVab25lTmFtZSkge1xyXG4gICAgICAgICAgICB0aGlzLnRpbWVab25lTmFtZSA9IHRpbWVab25lTmFtZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY2xhc3MgU2VnSGllcmFyY2h5IHtcclxuICAgICAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICAgICAgLy8gc2V0dGluZ3NcclxuICAgICAgICAgICAgdGhpcy5zdHJpY3RPcmRlciA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLmFsbG93UmVzbGljaW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMubWF4Q29vcmQgPSAtMTsgLy8gLTEgbWVhbnMgbm8gbWF4XHJcbiAgICAgICAgICAgIHRoaXMubWF4U3RhY2tDbnQgPSAtMTsgLy8gLTEgbWVhbnMgbm8gbWF4XHJcbiAgICAgICAgICAgIHRoaXMubGV2ZWxDb29yZHMgPSBbXTsgLy8gb3JkZXJlZFxyXG4gICAgICAgICAgICB0aGlzLmVudHJpZXNCeUxldmVsID0gW107IC8vIHBhcmFsbGVsIHdpdGggbGV2ZWxDb29yZHNcclxuICAgICAgICAgICAgdGhpcy5zdGFja0NudHMgPSB7fTsgLy8gVE9ETzogdXNlIGJldHRlciB0ZWNobmlxdWUhP1xyXG4gICAgICAgIH1cclxuICAgICAgICBhZGRTZWdzKGlucHV0cykge1xyXG4gICAgICAgICAgICBsZXQgaGlkZGVuRW50cmllcyA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpbnB1dCBvZiBpbnB1dHMpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaW5zZXJ0RW50cnkoaW5wdXQsIGhpZGRlbkVudHJpZXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBoaWRkZW5FbnRyaWVzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpbnNlcnRFbnRyeShlbnRyeSwgaGlkZGVuRW50cmllcykge1xyXG4gICAgICAgICAgICBsZXQgaW5zZXJ0aW9uID0gdGhpcy5maW5kSW5zZXJ0aW9uKGVudHJ5KTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaXNJbnNlcnRpb25WYWxpZChpbnNlcnRpb24sIGVudHJ5KSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbnNlcnRFbnRyeUF0KGVudHJ5LCBpbnNlcnRpb24pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlSW52YWxpZEluc2VydGlvbihpbnNlcnRpb24sIGVudHJ5LCBoaWRkZW5FbnRyaWVzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaXNJbnNlcnRpb25WYWxpZChpbnNlcnRpb24sIGVudHJ5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5tYXhDb29yZCA9PT0gLTEgfHwgaW5zZXJ0aW9uLmxldmVsQ29vcmQgKyBlbnRyeS50aGlja25lc3MgPD0gdGhpcy5tYXhDb29yZCkgJiZcclxuICAgICAgICAgICAgICAgICh0aGlzLm1heFN0YWNrQ250ID09PSAtMSB8fCBpbnNlcnRpb24uc3RhY2tDbnQgPCB0aGlzLm1heFN0YWNrQ250KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gcmV0dXJucyBudW1iZXIgb2YgbmV3IGVudHJpZXMgaW5zZXJ0ZWRcclxuICAgICAgICBoYW5kbGVJbnZhbGlkSW5zZXJ0aW9uKGluc2VydGlvbiwgZW50cnksIGhpZGRlbkVudHJpZXMpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuYWxsb3dSZXNsaWNpbmcgJiYgaW5zZXJ0aW9uLnRvdWNoaW5nRW50cnkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNwbGl0RW50cnkoZW50cnksIGluc2VydGlvbi50b3VjaGluZ0VudHJ5LCBoaWRkZW5FbnRyaWVzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBoaWRkZW5FbnRyaWVzLnB1c2goZW50cnkpO1xyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgc3BsaXRFbnRyeShlbnRyeSwgYmFycmllciwgaGlkZGVuRW50cmllcykge1xyXG4gICAgICAgICAgICBsZXQgcGFydENudCA9IDA7XHJcbiAgICAgICAgICAgIGxldCBzcGxpdEhpZGRlbkVudHJpZXMgPSBbXTtcclxuICAgICAgICAgICAgbGV0IGVudHJ5U3BhbiA9IGVudHJ5LnNwYW47XHJcbiAgICAgICAgICAgIGxldCBiYXJyaWVyU3BhbiA9IGJhcnJpZXIuc3BhbjtcclxuICAgICAgICAgICAgaWYgKGVudHJ5U3Bhbi5zdGFydCA8IGJhcnJpZXJTcGFuLnN0YXJ0KSB7XHJcbiAgICAgICAgICAgICAgICBwYXJ0Q250ICs9IHRoaXMuaW5zZXJ0RW50cnkoe1xyXG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiBlbnRyeS5pbmRleCxcclxuICAgICAgICAgICAgICAgICAgICB0aGlja25lc3M6IGVudHJ5LnRoaWNrbmVzcyxcclxuICAgICAgICAgICAgICAgICAgICBzcGFuOiB7IHN0YXJ0OiBlbnRyeVNwYW4uc3RhcnQsIGVuZDogYmFycmllclNwYW4uc3RhcnQgfSxcclxuICAgICAgICAgICAgICAgIH0sIHNwbGl0SGlkZGVuRW50cmllcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGVudHJ5U3Bhbi5lbmQgPiBiYXJyaWVyU3Bhbi5lbmQpIHtcclxuICAgICAgICAgICAgICAgIHBhcnRDbnQgKz0gdGhpcy5pbnNlcnRFbnRyeSh7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGVudHJ5LmluZGV4LFxyXG4gICAgICAgICAgICAgICAgICAgIHRoaWNrbmVzczogZW50cnkudGhpY2tuZXNzLFxyXG4gICAgICAgICAgICAgICAgICAgIHNwYW46IHsgc3RhcnQ6IGJhcnJpZXJTcGFuLmVuZCwgZW5kOiBlbnRyeVNwYW4uZW5kIH0sXHJcbiAgICAgICAgICAgICAgICB9LCBzcGxpdEhpZGRlbkVudHJpZXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChwYXJ0Q250KSB7XHJcbiAgICAgICAgICAgICAgICBoaWRkZW5FbnRyaWVzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiBlbnRyeS5pbmRleCxcclxuICAgICAgICAgICAgICAgICAgICB0aGlja25lc3M6IGVudHJ5LnRoaWNrbmVzcyxcclxuICAgICAgICAgICAgICAgICAgICBzcGFuOiBpbnRlcnNlY3RTcGFucyhiYXJyaWVyU3BhbiwgZW50cnlTcGFuKSwgLy8gZ3VhcmFudGVlZCB0byBpbnRlcnNlY3RcclxuICAgICAgICAgICAgICAgIH0sIC4uLnNwbGl0SGlkZGVuRW50cmllcyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFydENudDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBoaWRkZW5FbnRyaWVzLnB1c2goZW50cnkpO1xyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaW5zZXJ0RW50cnlBdChlbnRyeSwgaW5zZXJ0aW9uKSB7XHJcbiAgICAgICAgICAgIGxldCB7IGVudHJpZXNCeUxldmVsLCBsZXZlbENvb3JkcyB9ID0gdGhpcztcclxuICAgICAgICAgICAgaWYgKGluc2VydGlvbi5sYXRlcmFsID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgLy8gY3JlYXRlIGEgbmV3IGxldmVsXHJcbiAgICAgICAgICAgICAgICBpbnNlcnRBdChsZXZlbENvb3JkcywgaW5zZXJ0aW9uLmxldmVsLCBpbnNlcnRpb24ubGV2ZWxDb29yZCk7XHJcbiAgICAgICAgICAgICAgICBpbnNlcnRBdChlbnRyaWVzQnlMZXZlbCwgaW5zZXJ0aW9uLmxldmVsLCBbZW50cnldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIGluc2VydCBpbnRvIGV4aXN0aW5nIGxldmVsXHJcbiAgICAgICAgICAgICAgICBpbnNlcnRBdChlbnRyaWVzQnlMZXZlbFtpbnNlcnRpb24ubGV2ZWxdLCBpbnNlcnRpb24ubGF0ZXJhbCwgZW50cnkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuc3RhY2tDbnRzW2J1aWxkRW50cnlLZXkoZW50cnkpXSA9IGluc2VydGlvbi5zdGFja0NudDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZmluZEluc2VydGlvbihuZXdFbnRyeSkge1xyXG4gICAgICAgICAgICBsZXQgeyBsZXZlbENvb3JkcywgZW50cmllc0J5TGV2ZWwsIHN0cmljdE9yZGVyLCBzdGFja0NudHMgfSA9IHRoaXM7XHJcbiAgICAgICAgICAgIGxldCBsZXZlbENudCA9IGxldmVsQ29vcmRzLmxlbmd0aDtcclxuICAgICAgICAgICAgbGV0IGNhbmRpZGF0ZUNvb3JkID0gMDtcclxuICAgICAgICAgICAgbGV0IHRvdWNoaW5nTGV2ZWwgPSAtMTtcclxuICAgICAgICAgICAgbGV0IHRvdWNoaW5nTGF0ZXJhbCA9IC0xO1xyXG4gICAgICAgICAgICBsZXQgdG91Y2hpbmdFbnRyeSA9IG51bGw7XHJcbiAgICAgICAgICAgIGxldCBzdGFja0NudCA9IDA7XHJcbiAgICAgICAgICAgIGZvciAobGV0IHRyYWNraW5nTGV2ZWwgPSAwOyB0cmFja2luZ0xldmVsIDwgbGV2ZWxDbnQ7IHRyYWNraW5nTGV2ZWwgKz0gMSkge1xyXG4gICAgICAgICAgICAgICAgbGV0IHRyYWNraW5nQ29vcmQgPSBsZXZlbENvb3Jkc1t0cmFja2luZ0xldmVsXTtcclxuICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBjdXJyZW50IGxldmVsIGlzIHBhc3QgdGhlIHBsYWNlZCBlbnRyeSwgd2UgaGF2ZSBmb3VuZCBhIGdvb2QgZW1wdHkgc3BhY2UgYW5kIGNhbiBzdG9wLlxyXG4gICAgICAgICAgICAgICAgLy8gaWYgc3RyaWN0T3JkZXIsIGtlZXAgZmluZGluZyBtb3JlIGxhdGVyYWwgaW50ZXJzZWN0aW9ucy5cclxuICAgICAgICAgICAgICAgIGlmICghc3RyaWN0T3JkZXIgJiYgdHJhY2tpbmdDb29yZCA+PSBjYW5kaWRhdGVDb29yZCArIG5ld0VudHJ5LnRoaWNrbmVzcykge1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbGV0IHRyYWNraW5nRW50cmllcyA9IGVudHJpZXNCeUxldmVsW3RyYWNraW5nTGV2ZWxdO1xyXG4gICAgICAgICAgICAgICAgbGV0IHRyYWNraW5nRW50cnk7XHJcbiAgICAgICAgICAgICAgICBsZXQgc2VhcmNoUmVzID0gYmluYXJ5U2VhcmNoKHRyYWNraW5nRW50cmllcywgbmV3RW50cnkuc3Bhbi5zdGFydCwgZ2V0RW50cnlTcGFuRW5kKTsgLy8gZmluZCBmaXJzdCBlbnRyeSBhZnRlciBuZXdFbnRyeSdzIGVuZFxyXG4gICAgICAgICAgICAgICAgbGV0IGxhdGVyYWxJbmRleCA9IHNlYXJjaFJlc1swXSArIHNlYXJjaFJlc1sxXTsgLy8gaWYgZXhhY3QgbWF0Y2ggKHdoaWNoIGRvZXNuJ3QgY29sbGlkZSksIGdvIHRvIG5leHQgb25lXHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoIC8vIGxvb3AgdGhyb3VnaCBlbnRyaWVzIHRoYXQgaG9yaXpvbnRhbGx5IGludGVyc2VjdFxyXG4gICAgICAgICAgICAgICAgKHRyYWNraW5nRW50cnkgPSB0cmFja2luZ0VudHJpZXNbbGF0ZXJhbEluZGV4XSkgJiYgLy8gYnV0IG5vdCBwYXN0IHRoZSB3aG9sZSBlbnRyeSBsaXN0XHJcbiAgICAgICAgICAgICAgICAgICAgdHJhY2tpbmdFbnRyeS5zcGFuLnN0YXJ0IDwgbmV3RW50cnkuc3Bhbi5lbmQgLy8gYW5kIG5vdCBlbnRpcmVseSBwYXN0IG5ld0VudHJ5XHJcbiAgICAgICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgdHJhY2tpbmdFbnRyeUJvdHRvbSA9IHRyYWNraW5nQ29vcmQgKyB0cmFja2luZ0VudHJ5LnRoaWNrbmVzcztcclxuICAgICAgICAgICAgICAgICAgICAvLyBpbnRlcnNlY3RzIGludG8gdGhlIHRvcCBvZiB0aGUgY2FuZGlkYXRlP1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0cmFja2luZ0VudHJ5Qm90dG9tID4gY2FuZGlkYXRlQ29vcmQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FuZGlkYXRlQ29vcmQgPSB0cmFja2luZ0VudHJ5Qm90dG9tO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3VjaGluZ0VudHJ5ID0gdHJhY2tpbmdFbnRyeTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdG91Y2hpbmdMZXZlbCA9IHRyYWNraW5nTGV2ZWw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvdWNoaW5nTGF0ZXJhbCA9IGxhdGVyYWxJbmRleDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYnV0dHMgdXAgYWdhaW5zdCB0b3Agb2YgY2FuZGlkYXRlPyAod2lsbCBoYXBwZW4gaWYganVzdCBpbnRlcnNlY3RlZCBhcyB3ZWxsKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0cmFja2luZ0VudHJ5Qm90dG9tID09PSBjYW5kaWRhdGVDb29yZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhY2N1bXVsYXRlIHRoZSBoaWdoZXN0IHBvc3NpYmxlIHN0YWNrQ250IG9mIHRoZSB0cmFja2luZ0VudHJpZXMgdGhhdCBidXR0IHVwXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrQ250ID0gTWF0aC5tYXgoc3RhY2tDbnQsIHN0YWNrQ250c1tidWlsZEVudHJ5S2V5KHRyYWNraW5nRW50cnkpXSArIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBsYXRlcmFsSW5kZXggKz0gMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyB0aGUgZGVzdGluYXRpb24gbGV2ZWwgd2lsbCBiZSBhZnRlciB0b3VjaGluZ0VudHJ5J3MgbGV2ZWwuIGZpbmQgaXRcclxuICAgICAgICAgICAgbGV0IGRlc3RMZXZlbCA9IDA7XHJcbiAgICAgICAgICAgIGlmICh0b3VjaGluZ0VudHJ5KSB7XHJcbiAgICAgICAgICAgICAgICBkZXN0TGV2ZWwgPSB0b3VjaGluZ0xldmVsICsgMTtcclxuICAgICAgICAgICAgICAgIHdoaWxlIChkZXN0TGV2ZWwgPCBsZXZlbENudCAmJiBsZXZlbENvb3Jkc1tkZXN0TGV2ZWxdIDwgY2FuZGlkYXRlQ29vcmQpIHtcclxuICAgICAgICAgICAgICAgICAgICBkZXN0TGV2ZWwgKz0gMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBpZiBhZGRpbmcgdG8gYW4gZXhpc3RpbmcgbGV2ZWwsIGZpbmQgd2hlcmUgdG8gaW5zZXJ0XHJcbiAgICAgICAgICAgIGxldCBkZXN0TGF0ZXJhbCA9IC0xO1xyXG4gICAgICAgICAgICBpZiAoZGVzdExldmVsIDwgbGV2ZWxDbnQgJiYgbGV2ZWxDb29yZHNbZGVzdExldmVsXSA9PT0gY2FuZGlkYXRlQ29vcmQpIHtcclxuICAgICAgICAgICAgICAgIGRlc3RMYXRlcmFsID0gYmluYXJ5U2VhcmNoKGVudHJpZXNCeUxldmVsW2Rlc3RMZXZlbF0sIG5ld0VudHJ5LnNwYW4uZW5kLCBnZXRFbnRyeVNwYW5FbmQpWzBdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICB0b3VjaGluZ0xldmVsLFxyXG4gICAgICAgICAgICAgICAgdG91Y2hpbmdMYXRlcmFsLFxyXG4gICAgICAgICAgICAgICAgdG91Y2hpbmdFbnRyeSxcclxuICAgICAgICAgICAgICAgIHN0YWNrQ250LFxyXG4gICAgICAgICAgICAgICAgbGV2ZWxDb29yZDogY2FuZGlkYXRlQ29vcmQsXHJcbiAgICAgICAgICAgICAgICBsZXZlbDogZGVzdExldmVsLFxyXG4gICAgICAgICAgICAgICAgbGF0ZXJhbDogZGVzdExhdGVyYWwsXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHNvcnRlZCBieSBsZXZlbENvb3JkIChsb3dlc3QgdG8gaGlnaGVzdClcclxuICAgICAgICB0b1JlY3RzKCkge1xyXG4gICAgICAgICAgICBsZXQgeyBlbnRyaWVzQnlMZXZlbCwgbGV2ZWxDb29yZHMgfSA9IHRoaXM7XHJcbiAgICAgICAgICAgIGxldCBsZXZlbENudCA9IGVudHJpZXNCeUxldmVsLmxlbmd0aDtcclxuICAgICAgICAgICAgbGV0IHJlY3RzID0gW107XHJcbiAgICAgICAgICAgIGZvciAobGV0IGxldmVsID0gMDsgbGV2ZWwgPCBsZXZlbENudDsgbGV2ZWwgKz0gMSkge1xyXG4gICAgICAgICAgICAgICAgbGV0IGVudHJpZXMgPSBlbnRyaWVzQnlMZXZlbFtsZXZlbF07XHJcbiAgICAgICAgICAgICAgICBsZXQgbGV2ZWxDb29yZCA9IGxldmVsQ29vcmRzW2xldmVsXTtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGVudHJ5IG9mIGVudHJpZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICByZWN0cy5wdXNoKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZW50cnkpLCB7IGxldmVsQ29vcmQgfSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZWN0cztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBnZXRFbnRyeVNwYW5FbmQoZW50cnkpIHtcclxuICAgICAgICByZXR1cm4gZW50cnkuc3Bhbi5lbmQ7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBidWlsZEVudHJ5S2V5KGVudHJ5KSB7XHJcbiAgICAgICAgcmV0dXJuIGVudHJ5LmluZGV4ICsgJzonICsgZW50cnkuc3Bhbi5zdGFydDtcclxuICAgIH1cclxuICAgIC8vIHJldHVybnMgZ3JvdXBzIHdpdGggZW50cmllcyBzb3J0ZWQgYnkgaW5wdXQgb3JkZXJcclxuICAgIGZ1bmN0aW9uIGdyb3VwSW50ZXJzZWN0aW5nRW50cmllcyhlbnRyaWVzKSB7XHJcbiAgICAgICAgbGV0IG1lcmdlcyA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IGVudHJ5IG9mIGVudHJpZXMpIHtcclxuICAgICAgICAgICAgbGV0IGZpbHRlcmVkTWVyZ2VzID0gW107XHJcbiAgICAgICAgICAgIGxldCBodW5ncnlNZXJnZSA9IHtcclxuICAgICAgICAgICAgICAgIHNwYW46IGVudHJ5LnNwYW4sXHJcbiAgICAgICAgICAgICAgICBlbnRyaWVzOiBbZW50cnldLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBmb3IgKGxldCBtZXJnZSBvZiBtZXJnZXMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpbnRlcnNlY3RTcGFucyhtZXJnZS5zcGFuLCBodW5ncnlNZXJnZS5zcGFuKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGh1bmdyeU1lcmdlID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbnRyaWVzOiBtZXJnZS5lbnRyaWVzLmNvbmNhdChodW5ncnlNZXJnZS5lbnRyaWVzKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3Bhbjogam9pblNwYW5zKG1lcmdlLnNwYW4sIGh1bmdyeU1lcmdlLnNwYW4pLFxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXJlZE1lcmdlcy5wdXNoKG1lcmdlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmaWx0ZXJlZE1lcmdlcy5wdXNoKGh1bmdyeU1lcmdlKTtcclxuICAgICAgICAgICAgbWVyZ2VzID0gZmlsdGVyZWRNZXJnZXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBtZXJnZXM7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBqb2luU3BhbnMoc3BhbjAsIHNwYW4xKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgc3RhcnQ6IE1hdGgubWluKHNwYW4wLnN0YXJ0LCBzcGFuMS5zdGFydCksXHJcbiAgICAgICAgICAgIGVuZDogTWF0aC5tYXgoc3BhbjAuZW5kLCBzcGFuMS5lbmQpLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBpbnRlcnNlY3RTcGFucyhzcGFuMCwgc3BhbjEpIHtcclxuICAgICAgICBsZXQgc3RhcnQgPSBNYXRoLm1heChzcGFuMC5zdGFydCwgc3BhbjEuc3RhcnQpO1xyXG4gICAgICAgIGxldCBlbmQgPSBNYXRoLm1pbihzcGFuMC5lbmQsIHNwYW4xLmVuZCk7XHJcbiAgICAgICAgaWYgKHN0YXJ0IDwgZW5kKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7IHN0YXJ0LCBlbmQgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICAvLyBnZW5lcmFsIHV0aWxcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgZnVuY3Rpb24gaW5zZXJ0QXQoYXJyLCBpbmRleCwgaXRlbSkge1xyXG4gICAgICAgIGFyci5zcGxpY2UoaW5kZXgsIDAsIGl0ZW0pO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYmluYXJ5U2VhcmNoKGEsIHNlYXJjaFZhbCwgZ2V0SXRlbVZhbCkge1xyXG4gICAgICAgIGxldCBzdGFydEluZGV4ID0gMDtcclxuICAgICAgICBsZXQgZW5kSW5kZXggPSBhLmxlbmd0aDsgLy8gZXhjbHVzaXZlXHJcbiAgICAgICAgaWYgKCFlbmRJbmRleCB8fCBzZWFyY2hWYWwgPCBnZXRJdGVtVmFsKGFbc3RhcnRJbmRleF0pKSB7IC8vIG5vIGl0ZW1zIE9SIGJlZm9yZSBmaXJzdCBpdGVtXHJcbiAgICAgICAgICAgIHJldHVybiBbMCwgMF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzZWFyY2hWYWwgPiBnZXRJdGVtVmFsKGFbZW5kSW5kZXggLSAxXSkpIHsgLy8gYWZ0ZXIgbGFzdCBpdGVtXHJcbiAgICAgICAgICAgIHJldHVybiBbZW5kSW5kZXgsIDBdO1xyXG4gICAgICAgIH1cclxuICAgICAgICB3aGlsZSAoc3RhcnRJbmRleCA8IGVuZEluZGV4KSB7XHJcbiAgICAgICAgICAgIGxldCBtaWRkbGVJbmRleCA9IE1hdGguZmxvb3Ioc3RhcnRJbmRleCArIChlbmRJbmRleCAtIHN0YXJ0SW5kZXgpIC8gMik7XHJcbiAgICAgICAgICAgIGxldCBtaWRkbGVWYWwgPSBnZXRJdGVtVmFsKGFbbWlkZGxlSW5kZXhdKTtcclxuICAgICAgICAgICAgaWYgKHNlYXJjaFZhbCA8IG1pZGRsZVZhbCkge1xyXG4gICAgICAgICAgICAgICAgZW5kSW5kZXggPSBtaWRkbGVJbmRleDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChzZWFyY2hWYWwgPiBtaWRkbGVWYWwpIHtcclxuICAgICAgICAgICAgICAgIHN0YXJ0SW5kZXggPSBtaWRkbGVJbmRleCArIDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7IC8vIGVxdWFsIVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFttaWRkbGVJbmRleCwgMV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFtzdGFydEluZGV4LCAwXTtcclxuICAgIH1cclxuXHJcbiAgICBjbGFzcyBJbnRlcmFjdGlvbiB7XHJcbiAgICAgICAgY29uc3RydWN0b3Ioc2V0dGluZ3MpIHtcclxuICAgICAgICAgICAgdGhpcy5jb21wb25lbnQgPSBzZXR0aW5ncy5jb21wb25lbnQ7XHJcbiAgICAgICAgICAgIHRoaXMuaXNIaXRDb21ib0FsbG93ZWQgPSBzZXR0aW5ncy5pc0hpdENvbWJvQWxsb3dlZCB8fCBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkZXN0cm95KCkge1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHBhcnNlSW50ZXJhY3Rpb25TZXR0aW5ncyhjb21wb25lbnQsIGlucHV0KSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgY29tcG9uZW50LFxyXG4gICAgICAgICAgICBlbDogaW5wdXQuZWwsXHJcbiAgICAgICAgICAgIHVzZUV2ZW50Q2VudGVyOiBpbnB1dC51c2VFdmVudENlbnRlciAhPSBudWxsID8gaW5wdXQudXNlRXZlbnRDZW50ZXIgOiB0cnVlLFxyXG4gICAgICAgICAgICBpc0hpdENvbWJvQWxsb3dlZDogaW5wdXQuaXNIaXRDb21ib0FsbG93ZWQgfHwgbnVsbCxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gaW50ZXJhY3Rpb25TZXR0aW5nc1RvU3RvcmUoc2V0dGluZ3MpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBbc2V0dGluZ3MuY29tcG9uZW50LnVpZF06IHNldHRpbmdzLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICAvLyBnbG9iYWwgc3RhdGVcclxuICAgIGNvbnN0IGludGVyYWN0aW9uU2V0dGluZ3NTdG9yZSA9IHt9O1xyXG5cclxuICAgIC8qXHJcbiAgICBBbiBhYnN0cmFjdGlvbiBmb3IgYSBkcmFnZ2luZyBpbnRlcmFjdGlvbiBvcmlnaW5hdGluZyBvbiBhbiBldmVudC5cclxuICAgIERvZXMgaGlnaGVyLWxldmVsIHRoaW5ncyB0aGFuIFBvaW50ZXJEcmFnZ2VyLCBzdWNoIGFzIHBvc3NpYmx5OlxyXG4gICAgLSBhIFwibWlycm9yXCIgdGhhdCBtb3ZlcyB3aXRoIHRoZSBwb2ludGVyXHJcbiAgICAtIGEgbWluaW11bSBudW1iZXIgb2YgcGl4ZWxzIG9yIG90aGVyIGNyaXRlcmlhIGZvciBhIHRydWUgZHJhZyB0byBiZWdpblxyXG5cclxuICAgIHN1YmNsYXNzZXMgbXVzdCBlbWl0OlxyXG4gICAgLSBwb2ludGVyZG93blxyXG4gICAgLSBkcmFnc3RhcnRcclxuICAgIC0gZHJhZ21vdmVcclxuICAgIC0gcG9pbnRlcnVwXHJcbiAgICAtIGRyYWdlbmRcclxuICAgICovXHJcbiAgICBjbGFzcyBFbGVtZW50RHJhZ2dpbmcge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yKGVsLCBzZWxlY3Rvcikge1xyXG4gICAgICAgICAgICB0aGlzLmVtaXR0ZXIgPSBuZXcgRW1pdHRlcigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkZXN0cm95KCkge1xyXG4gICAgICAgIH1cclxuICAgICAgICBzZXRNaXJyb3JJc1Zpc2libGUoYm9vbCkge1xyXG4gICAgICAgICAgICAvLyBvcHRpb25hbCBpZiBzdWJjbGFzcyBkb2Vzbid0IHdhbnQgdG8gc3VwcG9ydCBhIG1pcnJvclxyXG4gICAgICAgIH1cclxuICAgICAgICBzZXRNaXJyb3JOZWVkc1JldmVydChib29sKSB7XHJcbiAgICAgICAgICAgIC8vIG9wdGlvbmFsIGlmIHN1YmNsYXNzIGRvZXNuJ3Qgd2FudCB0byBzdXBwb3J0IGEgbWlycm9yXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNldEF1dG9TY3JvbGxFbmFibGVkKGJvb2wpIHtcclxuICAgICAgICAgICAgLy8gb3B0aW9uYWxcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVE9ETzogZ2V0IHJpZCBvZiB0aGlzIGluIGZhdm9yIG9mIG9wdGlvbnMgc3lzdGVtLFxyXG4gICAgLy8gdGhvIGl0J3MgcmVhbGx5IGVhc3kgdG8gYWNjZXNzIHRoaXMgZ2xvYmFsbHkgcmF0aGVyIHRoYW4gcGFzcyB0aHJ1IG9wdGlvbnMuXHJcbiAgICBjb25zdCBjb25maWcgPSB7fTtcclxuXHJcbiAgICAvKlxyXG4gICAgSW5mb3JtYXRpb24gYWJvdXQgd2hhdCB3aWxsIGhhcHBlbiB3aGVuIGFuIGV4dGVybmFsIGVsZW1lbnQgaXMgZHJhZ2dlZC1hbmQtZHJvcHBlZFxyXG4gICAgb250byBhIGNhbGVuZGFyLiBDb250YWlucyBpbmZvcm1hdGlvbiBmb3IgY3JlYXRpbmcgYW4gZXZlbnQuXHJcbiAgICAqL1xyXG4gICAgY29uc3QgRFJBR19NRVRBX1JFRklORVJTID0ge1xyXG4gICAgICAgIHN0YXJ0VGltZTogY3JlYXRlRHVyYXRpb24sXHJcbiAgICAgICAgZHVyYXRpb246IGNyZWF0ZUR1cmF0aW9uLFxyXG4gICAgICAgIGNyZWF0ZTogQm9vbGVhbixcclxuICAgICAgICBzb3VyY2VJZDogU3RyaW5nLFxyXG4gICAgfTtcclxuICAgIGZ1bmN0aW9uIHBhcnNlRHJhZ01ldGEocmF3KSB7XHJcbiAgICAgICAgbGV0IHsgcmVmaW5lZCwgZXh0cmEgfSA9IHJlZmluZVByb3BzKHJhdywgRFJBR19NRVRBX1JFRklORVJTKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBzdGFydFRpbWU6IHJlZmluZWQuc3RhcnRUaW1lIHx8IG51bGwsXHJcbiAgICAgICAgICAgIGR1cmF0aW9uOiByZWZpbmVkLmR1cmF0aW9uIHx8IG51bGwsXHJcbiAgICAgICAgICAgIGNyZWF0ZTogcmVmaW5lZC5jcmVhdGUgIT0gbnVsbCA/IHJlZmluZWQuY3JlYXRlIDogdHJ1ZSxcclxuICAgICAgICAgICAgc291cmNlSWQ6IHJlZmluZWQuc291cmNlSWQsXHJcbiAgICAgICAgICAgIGxlZnRvdmVyUHJvcHM6IGV4dHJhLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgY2xhc3MgQ2FsZW5kYXJSb290IGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XHJcbiAgICAgICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSB7XHJcbiAgICAgICAgICAgICAgICBmb3JQcmludDogZmFsc2UsXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlQmVmb3JlUHJpbnQgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKHsgZm9yUHJpbnQ6IHRydWUgfSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlQWZ0ZXJQcmludCA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoeyBmb3JQcmludDogZmFsc2UgfSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlbmRlcigpIHtcclxuICAgICAgICAgICAgbGV0IHsgcHJvcHMgfSA9IHRoaXM7XHJcbiAgICAgICAgICAgIGxldCB7IG9wdGlvbnMgfSA9IHByb3BzO1xyXG4gICAgICAgICAgICBsZXQgeyBmb3JQcmludCB9ID0gdGhpcy5zdGF0ZTtcclxuICAgICAgICAgICAgbGV0IGlzSGVpZ2h0QXV0byA9IGZvclByaW50IHx8IG9wdGlvbnMuaGVpZ2h0ID09PSAnYXV0bycgfHwgb3B0aW9ucy5jb250ZW50SGVpZ2h0ID09PSAnYXV0byc7XHJcbiAgICAgICAgICAgIGxldCBoZWlnaHQgPSAoIWlzSGVpZ2h0QXV0byAmJiBvcHRpb25zLmhlaWdodCAhPSBudWxsKSA/IG9wdGlvbnMuaGVpZ2h0IDogJyc7XHJcbiAgICAgICAgICAgIGxldCBjbGFzc05hbWVzID0gW1xyXG4gICAgICAgICAgICAgICAgJ2ZjJyxcclxuICAgICAgICAgICAgICAgIGZvclByaW50ID8gJ2ZjLW1lZGlhLXByaW50JyA6ICdmYy1tZWRpYS1zY3JlZW4nLFxyXG4gICAgICAgICAgICAgICAgYGZjLWRpcmVjdGlvbi0ke29wdGlvbnMuZGlyZWN0aW9ufWAsXHJcbiAgICAgICAgICAgICAgICBwcm9wcy50aGVtZS5nZXRDbGFzcygncm9vdCcpLFxyXG4gICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICBpZiAoIWdldENhblZHcm93V2l0aGluQ2VsbCgpKSB7XHJcbiAgICAgICAgICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLWxpcXVpZC1oYWNrJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHByb3BzLmNoaWxkcmVuKGNsYXNzTmFtZXMsIGhlaWdodCwgaXNIZWlnaHRBdXRvLCBmb3JQcmludCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xyXG4gICAgICAgICAgICBsZXQgeyBlbWl0dGVyIH0gPSB0aGlzLnByb3BzO1xyXG4gICAgICAgICAgICBlbWl0dGVyLm9uKCdfYmVmb3JlcHJpbnQnLCB0aGlzLmhhbmRsZUJlZm9yZVByaW50KTtcclxuICAgICAgICAgICAgZW1pdHRlci5vbignX2FmdGVycHJpbnQnLCB0aGlzLmhhbmRsZUFmdGVyUHJpbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcclxuICAgICAgICAgICAgbGV0IHsgZW1pdHRlciB9ID0gdGhpcy5wcm9wcztcclxuICAgICAgICAgICAgZW1pdHRlci5vZmYoJ19iZWZvcmVwcmludCcsIHRoaXMuaGFuZGxlQmVmb3JlUHJpbnQpO1xyXG4gICAgICAgICAgICBlbWl0dGVyLm9mZignX2FmdGVycHJpbnQnLCB0aGlzLmhhbmRsZUFmdGVyUHJpbnQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBDb21wdXRlcyBhIGRlZmF1bHQgY29sdW1uIGhlYWRlciBmb3JtYXR0aW5nIHN0cmluZyBpZiBgY29sRm9ybWF0YCBpcyBub3QgZXhwbGljaXRseSBkZWZpbmVkXHJcbiAgICBmdW5jdGlvbiBjb21wdXRlRmFsbGJhY2tIZWFkZXJGb3JtYXQoZGF0ZXNSZXBEaXN0aW5jdERheXMsIGRheUNudCkge1xyXG4gICAgICAgIC8vIGlmIG1vcmUgdGhhbiBvbmUgd2VlayByb3csIG9yIGlmIHRoZXJlIGFyZSBhIGxvdCBvZiBjb2x1bW5zIHdpdGggbm90IG11Y2ggc3BhY2UsXHJcbiAgICAgICAgLy8gcHV0IGp1c3QgdGhlIGRheSBudW1iZXJzIHdpbGwgYmUgaW4gZWFjaCBjZWxsXHJcbiAgICAgICAgaWYgKCFkYXRlc1JlcERpc3RpbmN0RGF5cyB8fCBkYXlDbnQgPiAxMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlRm9ybWF0dGVyKHsgd2Vla2RheTogJ3Nob3J0JyB9KTsgLy8gXCJTYXRcIlxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZGF5Q250ID4gMSkge1xyXG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlRm9ybWF0dGVyKHsgd2Vla2RheTogJ3Nob3J0JywgbW9udGg6ICdudW1lcmljJywgZGF5OiAnbnVtZXJpYycsIG9taXRDb21tYXM6IHRydWUgfSk7IC8vIFwiU2F0IDExLzEyXCJcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUZvcm1hdHRlcih7IHdlZWtkYXk6ICdsb25nJyB9KTsgLy8gXCJTYXR1cmRheVwiXHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgQ0xBU1NfTkFNRSA9ICdmYy1jb2wtaGVhZGVyLWNlbGwnOyAvLyBkbyB0aGUgY3VzaGlvbiB0b28/IG5vXHJcbiAgICBmdW5jdGlvbiByZW5kZXJJbm5lciQxKHJlbmRlclByb3BzKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlbmRlclByb3BzLnRleHQ7XHJcbiAgICB9XHJcblxyXG4gICAgY2xhc3MgQ29udGVudEluamVjdG9yIGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XHJcbiAgICAgICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgIHRoaXMuaWQgPSBndWlkKCk7XHJcbiAgICAgICAgICAgIHRoaXMucXVldWVkRG9tTm9kZXMgPSBbXTtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50RG9tTm9kZXMgPSBbXTtcclxuICAgICAgICAgICAgdGhpcy5oYW5kbGVFbCA9IChlbCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucHJvcHMuZWxSZWYpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZXRSZWYodGhpcy5wcm9wcy5lbFJlZiwgZWwpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZW5kZXIoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgcHJvcHMsIGNvbnRleHQgfSA9IHRoaXM7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgb3B0aW9ucyB9ID0gY29udGV4dDtcclxuICAgICAgICAgICAgY29uc3QgeyBjdXN0b21HZW5lcmF0b3IsIGRlZmF1bHRHZW5lcmF0b3IsIHJlbmRlclByb3BzIH0gPSBwcm9wcztcclxuICAgICAgICAgICAgY29uc3QgYXR0cnMgPSBidWlsZEVsQXR0cnMocHJvcHMpO1xyXG4gICAgICAgICAgICBsZXQgdXNlRGVmYXVsdCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBsZXQgaW5uZXJDb250ZW50O1xyXG4gICAgICAgICAgICBsZXQgcXVldWVkRG9tTm9kZXMgPSBbXTtcclxuICAgICAgICAgICAgbGV0IGN1cnJlbnRHZW5lcmF0b3JNZXRhO1xyXG4gICAgICAgICAgICBpZiAoY3VzdG9tR2VuZXJhdG9yICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGN1c3RvbUdlbmVyYXRvclJlcyA9IHR5cGVvZiBjdXN0b21HZW5lcmF0b3IgPT09ICdmdW5jdGlvbicgP1xyXG4gICAgICAgICAgICAgICAgICAgIGN1c3RvbUdlbmVyYXRvcihyZW5kZXJQcm9wcywgeSkgOlxyXG4gICAgICAgICAgICAgICAgICAgIGN1c3RvbUdlbmVyYXRvcjtcclxuICAgICAgICAgICAgICAgIGlmIChjdXN0b21HZW5lcmF0b3JSZXMgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgICAgICB1c2VEZWZhdWx0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlzT2JqZWN0ID0gY3VzdG9tR2VuZXJhdG9yUmVzICYmIHR5cGVvZiBjdXN0b21HZW5lcmF0b3JSZXMgPT09ICdvYmplY3QnOyAvLyBub24tbnVsbFxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc09iamVjdCAmJiAoJ2h0bWwnIGluIGN1c3RvbUdlbmVyYXRvclJlcykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cnMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgPSB7IF9faHRtbDogY3VzdG9tR2VuZXJhdG9yUmVzLmh0bWwgfTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNPYmplY3QgJiYgKCdkb21Ob2RlcycgaW4gY3VzdG9tR2VuZXJhdG9yUmVzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBxdWV1ZWREb21Ob2RlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGN1c3RvbUdlbmVyYXRvclJlcy5kb21Ob2Rlcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFpc09iamVjdCAmJiB0eXBlb2YgY3VzdG9tR2VuZXJhdG9yUmVzICE9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHByaW1pdGl2ZSB2YWx1ZSAobGlrZSBzdHJpbmcgb3IgbnVtYmVyKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbm5lckNvbnRlbnQgPSBjdXN0b21HZW5lcmF0b3JSZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhbiBleG90aWMgb2JqZWN0IGZvciBoYW5kbGVDdXN0b21SZW5kZXJpbmdcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEdlbmVyYXRvck1ldGEgPSBjdXN0b21HZW5lcmF0b3JSZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdXNlRGVmYXVsdCA9ICFoYXNDdXN0b21SZW5kZXJpbmdIYW5kbGVyKHByb3BzLmdlbmVyYXRvck5hbWUsIG9wdGlvbnMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh1c2VEZWZhdWx0ICYmIGRlZmF1bHRHZW5lcmF0b3IpIHtcclxuICAgICAgICAgICAgICAgIGlubmVyQ29udGVudCA9IGRlZmF1bHRHZW5lcmF0b3IocmVuZGVyUHJvcHMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMucXVldWVkRG9tTm9kZXMgPSBxdWV1ZWREb21Ob2RlcztcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50R2VuZXJhdG9yTWV0YSA9IGN1cnJlbnRHZW5lcmF0b3JNZXRhO1xyXG4gICAgICAgICAgICByZXR1cm4geShwcm9wcy5lbFRhZywgYXR0cnMsIGlubmVyQ29udGVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xyXG4gICAgICAgICAgICB0aGlzLmFwcGx5UXVldWV1ZERvbU5vZGVzKCk7XHJcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlckN1c3RvbVJlbmRlcmluZyh0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29tcG9uZW50RGlkVXBkYXRlKCkge1xyXG4gICAgICAgICAgICB0aGlzLmFwcGx5UXVldWV1ZERvbU5vZGVzKCk7XHJcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlckN1c3RvbVJlbmRlcmluZyh0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XHJcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlckN1c3RvbVJlbmRlcmluZyhmYWxzZSk7IC8vIFRPRE86IGRpZmZlcmVudCBBUEkgZm9yIHJlbW92YWw/XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRyaWdnZXJDdXN0b21SZW5kZXJpbmcoaXNBY3RpdmUpIHtcclxuICAgICAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgICAgICBjb25zdCB7IHByb3BzLCBjb250ZXh0IH0gPSB0aGlzO1xyXG4gICAgICAgICAgICBjb25zdCB7IGhhbmRsZUN1c3RvbVJlbmRlcmluZywgY3VzdG9tUmVuZGVyaW5nTWV0YU1hcCB9ID0gY29udGV4dC5vcHRpb25zO1xyXG4gICAgICAgICAgICBpZiAoaGFuZGxlQ3VzdG9tUmVuZGVyaW5nKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBnZW5lcmF0b3JNZXRhID0gKF9hID0gdGhpcy5jdXJyZW50R2VuZXJhdG9yTWV0YSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogY3VzdG9tUmVuZGVyaW5nTWV0YU1hcCA9PT0gbnVsbCB8fCBjdXN0b21SZW5kZXJpbmdNZXRhTWFwID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdXN0b21SZW5kZXJpbmdNZXRhTWFwW3Byb3BzLmdlbmVyYXRvck5hbWVdO1xyXG4gICAgICAgICAgICAgICAgaWYgKGdlbmVyYXRvck1ldGEpIHtcclxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVDdXN0b21SZW5kZXJpbmcoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgaWQ6IHRoaXMuaWQsIGlzQWN0aXZlLCBjb250YWluZXJFbDogdGhpcy5iYXNlLCByZXBvcnROZXdDb250YWluZXJFbDogdGhpcy5oYW5kbGVFbCwgLy8gZm9yIGN1c3RvbVJlbmRlcmluZ1JlcGxhY2VzRWxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdG9yTWV0YSB9LCBwcm9wcyksIHsgZWxDbGFzc2VzOiAocHJvcHMuZWxDbGFzc2VzIHx8IFtdKS5maWx0ZXIoaXNUcnV0aHkpIH0pKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBhcHBseVF1ZXVldWREb21Ob2RlcygpIHtcclxuICAgICAgICAgICAgY29uc3QgeyBxdWV1ZWREb21Ob2RlcywgY3VycmVudERvbU5vZGVzIH0gPSB0aGlzO1xyXG4gICAgICAgICAgICBjb25zdCBlbCA9IHRoaXMuYmFzZTtcclxuICAgICAgICAgICAgaWYgKCFpc0FycmF5c0VxdWFsKHF1ZXVlZERvbU5vZGVzLCBjdXJyZW50RG9tTm9kZXMpKSB7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50RG9tTm9kZXMuZm9yRWFjaChyZW1vdmVFbGVtZW50KTtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IG5ld05vZGUgb2YgcXVldWVkRG9tTm9kZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICBlbC5hcHBlbmRDaGlsZChuZXdOb2RlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudERvbU5vZGVzID0gcXVldWVkRG9tTm9kZXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBDb250ZW50SW5qZWN0b3IuYWRkUHJvcHNFcXVhbGl0eSh7XHJcbiAgICAgICAgZWxDbGFzc2VzOiBpc0FycmF5c0VxdWFsLFxyXG4gICAgICAgIGVsU3R5bGU6IGlzUHJvcHNFcXVhbCxcclxuICAgICAgICBlbEF0dHJzOiBpc05vbkhhbmRsZXJQcm9wc0VxdWFsLFxyXG4gICAgICAgIHJlbmRlclByb3BzOiBpc1Byb3BzRXF1YWwsXHJcbiAgICB9KTtcclxuICAgIC8vIFV0aWxcclxuICAgIC8qXHJcbiAgICBEb2VzIFVJLWZyYW1ld29yayBwcm92aWRlIGN1c3RvbSB3YXkgb2YgcmVuZGVyaW5nP1xyXG4gICAgKi9cclxuICAgIGZ1bmN0aW9uIGhhc0N1c3RvbVJlbmRlcmluZ0hhbmRsZXIoZ2VuZXJhdG9yTmFtZSwgb3B0aW9ucykge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICByZXR1cm4gQm9vbGVhbihvcHRpb25zLmhhbmRsZUN1c3RvbVJlbmRlcmluZyAmJlxyXG4gICAgICAgICAgICBnZW5lcmF0b3JOYW1lICYmXHJcbiAgICAgICAgICAgICgoX2EgPSBvcHRpb25zLmN1c3RvbVJlbmRlcmluZ01ldGFNYXApID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVtnZW5lcmF0b3JOYW1lXSkpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYnVpbGRFbEF0dHJzKHByb3BzLCBleHRyYUNsYXNzTmFtZXMpIHtcclxuICAgICAgICBjb25zdCBhdHRycyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcHJvcHMuZWxBdHRycyksIHsgcmVmOiBwcm9wcy5lbFJlZiB9KTtcclxuICAgICAgICBpZiAocHJvcHMuZWxDbGFzc2VzIHx8IGV4dHJhQ2xhc3NOYW1lcykge1xyXG4gICAgICAgICAgICBhdHRycy5jbGFzc05hbWUgPSAocHJvcHMuZWxDbGFzc2VzIHx8IFtdKVxyXG4gICAgICAgICAgICAgICAgLmNvbmNhdChleHRyYUNsYXNzTmFtZXMgfHwgW10pXHJcbiAgICAgICAgICAgICAgICAuY29uY2F0KGF0dHJzLmNsYXNzTmFtZSB8fCBbXSlcclxuICAgICAgICAgICAgICAgIC5maWx0ZXIoQm9vbGVhbilcclxuICAgICAgICAgICAgICAgIC5qb2luKCcgJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwcm9wcy5lbFN0eWxlKSB7XHJcbiAgICAgICAgICAgIGF0dHJzLnN0eWxlID0gcHJvcHMuZWxTdHlsZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGF0dHJzO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gaXNUcnV0aHkodmFsKSB7XHJcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4odmFsKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBSZW5kZXJJZCA9IGNyZWF0ZUNvbnRleHQoMCk7XHJcblxyXG4gICAgY2xhc3MgQ29udGVudENvbnRhaW5lciBleHRlbmRzIHgkMSB7XHJcbiAgICAgICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgIHRoaXMuSW5uZXJDb250ZW50ID0gSW5uZXJDb250ZW50SW5qZWN0b3IuYmluZCh1bmRlZmluZWQsIHRoaXMpO1xyXG4gICAgICAgICAgICB0aGlzLmhhbmRsZVJvb3RFbCA9IChlbCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yb290RWwgPSBlbDtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnByb3BzLmVsUmVmKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0UmVmKHRoaXMucHJvcHMuZWxSZWYsIGVsKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVuZGVyKCkge1xyXG4gICAgICAgICAgICBjb25zdCB7IHByb3BzIH0gPSB0aGlzO1xyXG4gICAgICAgICAgICBjb25zdCBnZW5lcmF0ZWRDbGFzc05hbWVzID0gZ2VuZXJhdGVDbGFzc05hbWVzKHByb3BzLmNsYXNzTmFtZUdlbmVyYXRvciwgcHJvcHMucmVuZGVyUHJvcHMpO1xyXG4gICAgICAgICAgICBpZiAocHJvcHMuY2hpbGRyZW4pIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGVsQXR0cnMgPSBidWlsZEVsQXR0cnMocHJvcHMsIGdlbmVyYXRlZENsYXNzTmFtZXMpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbih0aGlzLklubmVyQ29udGVudCwgcHJvcHMucmVuZGVyUHJvcHMsIGVsQXR0cnMpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHByb3BzLmVsVGFnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHkocHJvcHMuZWxUYWcsIGVsQXR0cnMsIGNoaWxkcmVuKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZHJlbjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB5KChDb250ZW50SW5qZWN0b3IpLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHByb3BzKSwgeyBlbFJlZjogdGhpcy5oYW5kbGVSb290RWwsIGVsVGFnOiBwcm9wcy5lbFRhZyB8fCAnZGl2JywgZWxDbGFzc2VzOiAocHJvcHMuZWxDbGFzc2VzIHx8IFtdKS5jb25jYXQoZ2VuZXJhdGVkQ2xhc3NOYW1lcyksIHJlbmRlcklkOiB0aGlzLmNvbnRleHQgfSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xyXG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgICAgICAoX2IgPSAoX2EgPSB0aGlzLnByb3BzKS5kaWRNb3VudCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5wcm9wcy5yZW5kZXJQcm9wcyksIHsgZWw6IHRoaXMucm9vdEVsIHx8IHRoaXMuYmFzZSB9KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xyXG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgICAgICAoX2IgPSAoX2EgPSB0aGlzLnByb3BzKS53aWxsVW5tb3VudCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5wcm9wcy5yZW5kZXJQcm9wcyksIHsgZWw6IHRoaXMucm9vdEVsIHx8IHRoaXMuYmFzZSB9KSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgQ29udGVudENvbnRhaW5lci5jb250ZXh0VHlwZSA9IFJlbmRlcklkO1xyXG4gICAgZnVuY3Rpb24gSW5uZXJDb250ZW50SW5qZWN0b3IoY29udGFpbmVyQ29tcG9uZW50LCBwcm9wcykge1xyXG4gICAgICAgIGNvbnN0IHBhcmVudFByb3BzID0gY29udGFpbmVyQ29tcG9uZW50LnByb3BzO1xyXG4gICAgICAgIHJldHVybiB5KChDb250ZW50SW5qZWN0b3IpLCBPYmplY3QuYXNzaWduKHsgcmVuZGVyUHJvcHM6IHBhcmVudFByb3BzLnJlbmRlclByb3BzLCBnZW5lcmF0b3JOYW1lOiBwYXJlbnRQcm9wcy5nZW5lcmF0b3JOYW1lLCBjdXN0b21HZW5lcmF0b3I6IHBhcmVudFByb3BzLmN1c3RvbUdlbmVyYXRvciwgZGVmYXVsdEdlbmVyYXRvcjogcGFyZW50UHJvcHMuZGVmYXVsdEdlbmVyYXRvciwgcmVuZGVySWQ6IGNvbnRhaW5lckNvbXBvbmVudC5jb250ZXh0IH0sIHByb3BzKSk7XHJcbiAgICB9XHJcbiAgICAvLyBVdGlsc1xyXG4gICAgZnVuY3Rpb24gZ2VuZXJhdGVDbGFzc05hbWVzKGNsYXNzTmFtZUdlbmVyYXRvciwgcmVuZGVyUHJvcHMpIHtcclxuICAgICAgICBjb25zdCBjbGFzc05hbWVzID0gdHlwZW9mIGNsYXNzTmFtZUdlbmVyYXRvciA9PT0gJ2Z1bmN0aW9uJyA/XHJcbiAgICAgICAgICAgIGNsYXNzTmFtZUdlbmVyYXRvcihyZW5kZXJQcm9wcykgOlxyXG4gICAgICAgICAgICBjbGFzc05hbWVHZW5lcmF0b3IgfHwgW107XHJcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBjbGFzc05hbWVzID09PSAnc3RyaW5nJyA/IFtjbGFzc05hbWVzXSA6IGNsYXNzTmFtZXM7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQkFEIG5hbWUgZm9yIHRoaXMgY2xhc3Mgbm93LiB1c2VkIGluIHRoZSBIZWFkZXJcclxuICAgIGNsYXNzIFRhYmxlRGF0ZUNlbGwgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcclxuICAgICAgICByZW5kZXIoKSB7XHJcbiAgICAgICAgICAgIGxldCB7IGRhdGVFbnYsIG9wdGlvbnMsIHRoZW1lLCB2aWV3QXBpIH0gPSB0aGlzLmNvbnRleHQ7XHJcbiAgICAgICAgICAgIGxldCB7IHByb3BzIH0gPSB0aGlzO1xyXG4gICAgICAgICAgICBsZXQgeyBkYXRlLCBkYXRlUHJvZmlsZSB9ID0gcHJvcHM7XHJcbiAgICAgICAgICAgIGxldCBkYXlNZXRhID0gZ2V0RGF0ZU1ldGEoZGF0ZSwgcHJvcHMudG9kYXlSYW5nZSwgbnVsbCwgZGF0ZVByb2ZpbGUpO1xyXG4gICAgICAgICAgICBsZXQgY2xhc3NOYW1lcyA9IFtDTEFTU19OQU1FXS5jb25jYXQoZ2V0RGF5Q2xhc3NOYW1lcyhkYXlNZXRhLCB0aGVtZSkpO1xyXG4gICAgICAgICAgICBsZXQgdGV4dCA9IGRhdGVFbnYuZm9ybWF0KGRhdGUsIHByb3BzLmRheUhlYWRlckZvcm1hdCk7XHJcbiAgICAgICAgICAgIC8vIGlmIGNvbENudCBpcyAxLCB3ZSBhcmUgYWxyZWFkeSBpbiBhIGRheS12aWV3IGFuZCBkb24ndCBuZWVkIGEgbmF2bGlua1xyXG4gICAgICAgICAgICBsZXQgbmF2TGlua0F0dHJzID0gKCFkYXlNZXRhLmlzRGlzYWJsZWQgJiYgcHJvcHMuY29sQ250ID4gMSlcclxuICAgICAgICAgICAgICAgID8gYnVpbGROYXZMaW5rQXR0cnModGhpcy5jb250ZXh0LCBkYXRlKVxyXG4gICAgICAgICAgICAgICAgOiB7fTtcclxuICAgICAgICAgICAgbGV0IHJlbmRlclByb3BzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyBkYXRlOiBkYXRlRW52LnRvRGF0ZShkYXRlKSwgdmlldzogdmlld0FwaSB9LCBwcm9wcy5leHRyYVJlbmRlclByb3BzKSwgeyB0ZXh0IH0pLCBkYXlNZXRhKTtcclxuICAgICAgICAgICAgcmV0dXJuICh5KENvbnRlbnRDb250YWluZXIsIHsgZWxUYWc6IFwidGhcIiwgZWxDbGFzc2VzOiBjbGFzc05hbWVzLCBlbEF0dHJzOiBPYmplY3QuYXNzaWduKHsgcm9sZTogJ2NvbHVtbmhlYWRlcicsIGNvbFNwYW46IHByb3BzLmNvbFNwYW4sICdkYXRhLWRhdGUnOiAhZGF5TWV0YS5pc0Rpc2FibGVkID8gZm9ybWF0RGF5U3RyaW5nKGRhdGUpIDogdW5kZWZpbmVkIH0sIHByb3BzLmV4dHJhRGF0YUF0dHJzKSwgcmVuZGVyUHJvcHM6IHJlbmRlclByb3BzLCBnZW5lcmF0b3JOYW1lOiBcImRheUhlYWRlckNvbnRlbnRcIiwgY3VzdG9tR2VuZXJhdG9yOiBvcHRpb25zLmRheUhlYWRlckNvbnRlbnQsIGRlZmF1bHRHZW5lcmF0b3I6IHJlbmRlcklubmVyJDEsIGNsYXNzTmFtZUdlbmVyYXRvcjogb3B0aW9ucy5kYXlIZWFkZXJDbGFzc05hbWVzLCBkaWRNb3VudDogb3B0aW9ucy5kYXlIZWFkZXJEaWRNb3VudCwgd2lsbFVubW91bnQ6IG9wdGlvbnMuZGF5SGVhZGVyV2lsbFVubW91bnQgfSwgKElubmVyQ29udGFpbmVyKSA9PiAoeShcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy1zY3JvbGxncmlkLXN5bmMtaW5uZXJcIiB9LCAhZGF5TWV0YS5pc0Rpc2FibGVkICYmICh5KElubmVyQ29udGFpbmVyLCB7IGVsVGFnOiBcImFcIiwgZWxBdHRyczogbmF2TGlua0F0dHJzLCBlbENsYXNzZXM6IFtcclxuICAgICAgICAgICAgICAgICAgICAnZmMtY29sLWhlYWRlci1jZWxsLWN1c2hpb24nLFxyXG4gICAgICAgICAgICAgICAgICAgIHByb3BzLmlzU3RpY2t5ICYmICdmYy1zdGlja3knLFxyXG4gICAgICAgICAgICAgICAgXSB9KSkpKSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBXRUVLREFZX0ZPUk1BVCA9IGNyZWF0ZUZvcm1hdHRlcih7IHdlZWtkYXk6ICdsb25nJyB9KTtcclxuICAgIGNsYXNzIFRhYmxlRG93Q2VsbCBleHRlbmRzIEJhc2VDb21wb25lbnQge1xyXG4gICAgICAgIHJlbmRlcigpIHtcclxuICAgICAgICAgICAgbGV0IHsgcHJvcHMgfSA9IHRoaXM7XHJcbiAgICAgICAgICAgIGxldCB7IGRhdGVFbnYsIHRoZW1lLCB2aWV3QXBpLCBvcHRpb25zIH0gPSB0aGlzLmNvbnRleHQ7XHJcbiAgICAgICAgICAgIGxldCBkYXRlID0gYWRkRGF5cyhuZXcgRGF0ZSgyNTkyMDAwMDApLCBwcm9wcy5kb3cpOyAvLyBzdGFydCB3aXRoIFN1biwgMDQgSmFuIDE5NzAgMDA6MDA6MDAgR01UXHJcbiAgICAgICAgICAgIGxldCBkYXRlTWV0YSA9IHtcclxuICAgICAgICAgICAgICAgIGRvdzogcHJvcHMuZG93LFxyXG4gICAgICAgICAgICAgICAgaXNEaXNhYmxlZDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBpc0Z1dHVyZTogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBpc1Bhc3Q6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgaXNUb2RheTogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBpc090aGVyOiBmYWxzZSxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgbGV0IHRleHQgPSBkYXRlRW52LmZvcm1hdChkYXRlLCBwcm9wcy5kYXlIZWFkZXJGb3JtYXQpO1xyXG4gICAgICAgICAgICBsZXQgcmVuZGVyUHJvcHMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgLy8gVE9ETzogbWFrZSB0aGlzIHB1YmxpYz9cclxuICAgICAgICAgICAgICAgIGRhdGUgfSwgZGF0ZU1ldGEpLCB7IHZpZXc6IHZpZXdBcGkgfSksIHByb3BzLmV4dHJhUmVuZGVyUHJvcHMpLCB7IHRleHQgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiAoeShDb250ZW50Q29udGFpbmVyLCB7IGVsVGFnOiBcInRoXCIsIGVsQ2xhc3NlczogW1xyXG4gICAgICAgICAgICAgICAgICAgIENMQVNTX05BTUUsXHJcbiAgICAgICAgICAgICAgICAgICAgLi4uZ2V0RGF5Q2xhc3NOYW1lcyhkYXRlTWV0YSwgdGhlbWUpLFxyXG4gICAgICAgICAgICAgICAgICAgIC4uLihwcm9wcy5leHRyYUNsYXNzTmFtZXMgfHwgW10pLFxyXG4gICAgICAgICAgICAgICAgXSwgZWxBdHRyczogT2JqZWN0LmFzc2lnbih7IHJvbGU6ICdjb2x1bW5oZWFkZXInLCBjb2xTcGFuOiBwcm9wcy5jb2xTcGFuIH0sIHByb3BzLmV4dHJhRGF0YUF0dHJzKSwgcmVuZGVyUHJvcHM6IHJlbmRlclByb3BzLCBnZW5lcmF0b3JOYW1lOiBcImRheUhlYWRlckNvbnRlbnRcIiwgY3VzdG9tR2VuZXJhdG9yOiBvcHRpb25zLmRheUhlYWRlckNvbnRlbnQsIGRlZmF1bHRHZW5lcmF0b3I6IHJlbmRlcklubmVyJDEsIGNsYXNzTmFtZUdlbmVyYXRvcjogb3B0aW9ucy5kYXlIZWFkZXJDbGFzc05hbWVzLCBkaWRNb3VudDogb3B0aW9ucy5kYXlIZWFkZXJEaWRNb3VudCwgd2lsbFVubW91bnQ6IG9wdGlvbnMuZGF5SGVhZGVyV2lsbFVubW91bnQgfSwgKElubmVyQ29udGVudCkgPT4gKHkoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtc2Nyb2xsZ3JpZC1zeW5jLWlubmVyXCIgfSxcclxuICAgICAgICAgICAgICAgIHkoSW5uZXJDb250ZW50LCB7IGVsVGFnOiBcImFcIiwgZWxDbGFzc2VzOiBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdmYy1jb2wtaGVhZGVyLWNlbGwtY3VzaGlvbicsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzLmlzU3RpY2t5ICYmICdmYy1zdGlja3knLFxyXG4gICAgICAgICAgICAgICAgICAgIF0sIGVsQXR0cnM6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ2FyaWEtbGFiZWwnOiBkYXRlRW52LmZvcm1hdChkYXRlLCBXRUVLREFZX0ZPUk1BVCksXHJcbiAgICAgICAgICAgICAgICAgICAgfSB9KSkpKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNsYXNzIE5vd1RpbWVyIGV4dGVuZHMgeCQxIHtcclxuICAgICAgICBjb25zdHJ1Y3Rvcihwcm9wcywgY29udGV4dCkge1xyXG4gICAgICAgICAgICBzdXBlcihwcm9wcywgY29udGV4dCk7XHJcbiAgICAgICAgICAgIHRoaXMuaW5pdGlhbE5vd0RhdGUgPSBnZXROb3coY29udGV4dC5vcHRpb25zLm5vdywgY29udGV4dC5kYXRlRW52KTtcclxuICAgICAgICAgICAgdGhpcy5pbml0aWFsTm93UXVlcmllZE1zID0gbmV3IERhdGUoKS52YWx1ZU9mKCk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSB0aGlzLmNvbXB1dGVUaW1pbmcoKS5jdXJyZW50U3RhdGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlbmRlcigpIHtcclxuICAgICAgICAgICAgbGV0IHsgcHJvcHMsIHN0YXRlIH0gPSB0aGlzO1xyXG4gICAgICAgICAgICByZXR1cm4gcHJvcHMuY2hpbGRyZW4oc3RhdGUubm93RGF0ZSwgc3RhdGUudG9kYXlSYW5nZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xyXG4gICAgICAgICAgICB0aGlzLnNldFRpbWVvdXQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcykge1xyXG4gICAgICAgICAgICBpZiAocHJldlByb3BzLnVuaXQgIT09IHRoaXMucHJvcHMudW5pdCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhclRpbWVvdXQoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0VGltZW91dCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xyXG4gICAgICAgICAgICB0aGlzLmNsZWFyVGltZW91dCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb21wdXRlVGltaW5nKCkge1xyXG4gICAgICAgICAgICBsZXQgeyBwcm9wcywgY29udGV4dCB9ID0gdGhpcztcclxuICAgICAgICAgICAgbGV0IHVucm91bmRlZE5vdyA9IGFkZE1zKHRoaXMuaW5pdGlhbE5vd0RhdGUsIG5ldyBEYXRlKCkudmFsdWVPZigpIC0gdGhpcy5pbml0aWFsTm93UXVlcmllZE1zKTtcclxuICAgICAgICAgICAgbGV0IGN1cnJlbnRVbml0U3RhcnQgPSBjb250ZXh0LmRhdGVFbnYuc3RhcnRPZih1bnJvdW5kZWROb3csIHByb3BzLnVuaXQpO1xyXG4gICAgICAgICAgICBsZXQgbmV4dFVuaXRTdGFydCA9IGNvbnRleHQuZGF0ZUVudi5hZGQoY3VycmVudFVuaXRTdGFydCwgY3JlYXRlRHVyYXRpb24oMSwgcHJvcHMudW5pdCkpO1xyXG4gICAgICAgICAgICBsZXQgd2FpdE1zID0gbmV4dFVuaXRTdGFydC52YWx1ZU9mKCkgLSB1bnJvdW5kZWROb3cudmFsdWVPZigpO1xyXG4gICAgICAgICAgICAvLyB0aGVyZSBpcyBhIG1heCBzZXRUaW1lb3V0IG1zIHZhbHVlIChodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzQ2ODY1MC85NjM0MilcclxuICAgICAgICAgICAgLy8gZW5zdXJlIG5vIGxvbmdlciB0aGFuIGEgZGF5XHJcbiAgICAgICAgICAgIHdhaXRNcyA9IE1hdGgubWluKDEwMDAgKiA2MCAqIDYwICogMjQsIHdhaXRNcyk7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50U3RhdGU6IHsgbm93RGF0ZTogY3VycmVudFVuaXRTdGFydCwgdG9kYXlSYW5nZTogYnVpbGREYXlSYW5nZShjdXJyZW50VW5pdFN0YXJ0KSB9LFxyXG4gICAgICAgICAgICAgICAgbmV4dFN0YXRlOiB7IG5vd0RhdGU6IG5leHRVbml0U3RhcnQsIHRvZGF5UmFuZ2U6IGJ1aWxkRGF5UmFuZ2UobmV4dFVuaXRTdGFydCkgfSxcclxuICAgICAgICAgICAgICAgIHdhaXRNcyxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc2V0VGltZW91dCgpIHtcclxuICAgICAgICAgICAgbGV0IHsgbmV4dFN0YXRlLCB3YWl0TXMgfSA9IHRoaXMuY29tcHV0ZVRpbWluZygpO1xyXG4gICAgICAgICAgICB0aGlzLnRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZShuZXh0U3RhdGUsICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFRpbWVvdXQoKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9LCB3YWl0TXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjbGVhclRpbWVvdXQoKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnRpbWVvdXRJZCkge1xyXG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dElkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIE5vd1RpbWVyLmNvbnRleHRUeXBlID0gVmlld0NvbnRleHRUeXBlO1xyXG4gICAgZnVuY3Rpb24gYnVpbGREYXlSYW5nZShkYXRlKSB7XHJcbiAgICAgICAgbGV0IHN0YXJ0ID0gc3RhcnRPZkRheShkYXRlKTtcclxuICAgICAgICBsZXQgZW5kID0gYWRkRGF5cyhzdGFydCwgMSk7XHJcbiAgICAgICAgcmV0dXJuIHsgc3RhcnQsIGVuZCB9O1xyXG4gICAgfVxyXG5cclxuICAgIGNsYXNzIERheUhlYWRlciBleHRlbmRzIEJhc2VDb21wb25lbnQge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgICAgICB0aGlzLmNyZWF0ZURheUhlYWRlckZvcm1hdHRlciA9IG1lbW9pemUoY3JlYXRlRGF5SGVhZGVyRm9ybWF0dGVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVuZGVyKCkge1xyXG4gICAgICAgICAgICBsZXQgeyBjb250ZXh0IH0gPSB0aGlzO1xyXG4gICAgICAgICAgICBsZXQgeyBkYXRlcywgZGF0ZVByb2ZpbGUsIGRhdGVzUmVwRGlzdGluY3REYXlzLCByZW5kZXJJbnRybyB9ID0gdGhpcy5wcm9wcztcclxuICAgICAgICAgICAgbGV0IGRheUhlYWRlckZvcm1hdCA9IHRoaXMuY3JlYXRlRGF5SGVhZGVyRm9ybWF0dGVyKGNvbnRleHQub3B0aW9ucy5kYXlIZWFkZXJGb3JtYXQsIGRhdGVzUmVwRGlzdGluY3REYXlzLCBkYXRlcy5sZW5ndGgpO1xyXG4gICAgICAgICAgICByZXR1cm4gKHkoTm93VGltZXIsIHsgdW5pdDogXCJkYXlcIiB9LCAobm93RGF0ZSwgdG9kYXlSYW5nZSkgPT4gKHkoXCJ0clwiLCB7IHJvbGU6IFwicm93XCIgfSxcclxuICAgICAgICAgICAgICAgIHJlbmRlckludHJvICYmIHJlbmRlckludHJvKCdkYXknKSxcclxuICAgICAgICAgICAgICAgIGRhdGVzLm1hcCgoZGF0ZSkgPT4gKGRhdGVzUmVwRGlzdGluY3REYXlzID8gKHkoVGFibGVEYXRlQ2VsbCwgeyBrZXk6IGRhdGUudG9JU09TdHJpbmcoKSwgZGF0ZTogZGF0ZSwgZGF0ZVByb2ZpbGU6IGRhdGVQcm9maWxlLCB0b2RheVJhbmdlOiB0b2RheVJhbmdlLCBjb2xDbnQ6IGRhdGVzLmxlbmd0aCwgZGF5SGVhZGVyRm9ybWF0OiBkYXlIZWFkZXJGb3JtYXQgfSkpIDogKHkoVGFibGVEb3dDZWxsLCB7IGtleTogZGF0ZS5nZXRVVENEYXkoKSwgZG93OiBkYXRlLmdldFVUQ0RheSgpLCBkYXlIZWFkZXJGb3JtYXQ6IGRheUhlYWRlckZvcm1hdCB9KSkpKSkpKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gY3JlYXRlRGF5SGVhZGVyRm9ybWF0dGVyKGV4cGxpY2l0Rm9ybWF0LCBkYXRlc1JlcERpc3RpbmN0RGF5cywgZGF0ZUNudCkge1xyXG4gICAgICAgIHJldHVybiBleHBsaWNpdEZvcm1hdCB8fCBjb21wdXRlRmFsbGJhY2tIZWFkZXJGb3JtYXQoZGF0ZXNSZXBEaXN0aW5jdERheXMsIGRhdGVDbnQpO1xyXG4gICAgfVxyXG5cclxuICAgIGNsYXNzIERheVNlcmllc01vZGVsIHtcclxuICAgICAgICBjb25zdHJ1Y3RvcihyYW5nZSwgZGF0ZVByb2ZpbGVHZW5lcmF0b3IpIHtcclxuICAgICAgICAgICAgbGV0IGRhdGUgPSByYW5nZS5zdGFydDtcclxuICAgICAgICAgICAgbGV0IHsgZW5kIH0gPSByYW5nZTtcclxuICAgICAgICAgICAgbGV0IGluZGljZXMgPSBbXTtcclxuICAgICAgICAgICAgbGV0IGRhdGVzID0gW107XHJcbiAgICAgICAgICAgIGxldCBkYXlJbmRleCA9IC0xO1xyXG4gICAgICAgICAgICB3aGlsZSAoZGF0ZSA8IGVuZCkgeyAvLyBsb29wIGVhY2ggZGF5IGZyb20gc3RhcnQgdG8gZW5kXHJcbiAgICAgICAgICAgICAgICBpZiAoZGF0ZVByb2ZpbGVHZW5lcmF0b3IuaXNIaWRkZW5EYXkoZGF0ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpbmRpY2VzLnB1c2goZGF5SW5kZXggKyAwLjUpOyAvLyBtYXJrIHRoYXQgaXQncyBiZXR3ZWVuIGluZGljZXNcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGRheUluZGV4ICs9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5kaWNlcy5wdXNoKGRheUluZGV4KTtcclxuICAgICAgICAgICAgICAgICAgICBkYXRlcy5wdXNoKGRhdGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZGF0ZSA9IGFkZERheXMoZGF0ZSwgMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5kYXRlcyA9IGRhdGVzO1xyXG4gICAgICAgICAgICB0aGlzLmluZGljZXMgPSBpbmRpY2VzO1xyXG4gICAgICAgICAgICB0aGlzLmNudCA9IGRhdGVzLmxlbmd0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgc2xpY2VSYW5nZShyYW5nZSkge1xyXG4gICAgICAgICAgICBsZXQgZmlyc3RJbmRleCA9IHRoaXMuZ2V0RGF0ZURheUluZGV4KHJhbmdlLnN0YXJ0KTsgLy8gaW5jbHVzaXZlIGZpcnN0IGluZGV4XHJcbiAgICAgICAgICAgIGxldCBsYXN0SW5kZXggPSB0aGlzLmdldERhdGVEYXlJbmRleChhZGREYXlzKHJhbmdlLmVuZCwgLTEpKTsgLy8gaW5jbHVzaXZlIGxhc3QgaW5kZXhcclxuICAgICAgICAgICAgbGV0IGNsaXBwZWRGaXJzdEluZGV4ID0gTWF0aC5tYXgoMCwgZmlyc3RJbmRleCk7XHJcbiAgICAgICAgICAgIGxldCBjbGlwcGVkTGFzdEluZGV4ID0gTWF0aC5taW4odGhpcy5jbnQgLSAxLCBsYXN0SW5kZXgpO1xyXG4gICAgICAgICAgICAvLyBkZWFsIHdpdGggaW4tYmV0d2VlbiBpbmRpY2VzXHJcbiAgICAgICAgICAgIGNsaXBwZWRGaXJzdEluZGV4ID0gTWF0aC5jZWlsKGNsaXBwZWRGaXJzdEluZGV4KTsgLy8gaW4tYmV0d2VlbiBzdGFydHMgcm91bmQgdG8gbmV4dCBjZWxsXHJcbiAgICAgICAgICAgIGNsaXBwZWRMYXN0SW5kZXggPSBNYXRoLmZsb29yKGNsaXBwZWRMYXN0SW5kZXgpOyAvLyBpbi1iZXR3ZWVuIGVuZHMgcm91bmQgdG8gcHJldiBjZWxsXHJcbiAgICAgICAgICAgIGlmIChjbGlwcGVkRmlyc3RJbmRleCA8PSBjbGlwcGVkTGFzdEluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGZpcnN0SW5kZXg6IGNsaXBwZWRGaXJzdEluZGV4LFxyXG4gICAgICAgICAgICAgICAgICAgIGxhc3RJbmRleDogY2xpcHBlZExhc3RJbmRleCxcclxuICAgICAgICAgICAgICAgICAgICBpc1N0YXJ0OiBmaXJzdEluZGV4ID09PSBjbGlwcGVkRmlyc3RJbmRleCxcclxuICAgICAgICAgICAgICAgICAgICBpc0VuZDogbGFzdEluZGV4ID09PSBjbGlwcGVkTGFzdEluZGV4LFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gR2l2ZW4gYSBkYXRlLCByZXR1cm5zIGl0cyBjaHJvbm9sb2NpYWwgY2VsbC1pbmRleCBmcm9tIHRoZSBmaXJzdCBjZWxsIG9mIHRoZSBncmlkLlxyXG4gICAgICAgIC8vIElmIHRoZSBkYXRlIGxpZXMgYmV0d2VlbiBjZWxscyAoYmVjYXVzZSBvZiBoaWRkZW5EYXlzKSwgcmV0dXJucyBhIGZsb2F0aW5nLXBvaW50IHZhbHVlIGJldHdlZW4gb2Zmc2V0cy5cclxuICAgICAgICAvLyBJZiBiZWZvcmUgdGhlIGZpcnN0IG9mZnNldCwgcmV0dXJucyBhIG5lZ2F0aXZlIG51bWJlci5cclxuICAgICAgICAvLyBJZiBhZnRlciB0aGUgbGFzdCBvZmZzZXQsIHJldHVybnMgYW4gb2Zmc2V0IHBhc3QgdGhlIGxhc3QgY2VsbCBvZmZzZXQuXHJcbiAgICAgICAgLy8gT25seSB3b3JrcyBmb3IgKnN0YXJ0KiBkYXRlcyBvZiBjZWxscy4gV2lsbCBub3Qgd29yayBmb3IgZXhjbHVzaXZlIGVuZCBkYXRlcyBmb3IgY2VsbHMuXHJcbiAgICAgICAgZ2V0RGF0ZURheUluZGV4KGRhdGUpIHtcclxuICAgICAgICAgICAgbGV0IHsgaW5kaWNlcyB9ID0gdGhpcztcclxuICAgICAgICAgICAgbGV0IGRheU9mZnNldCA9IE1hdGguZmxvb3IoZGlmZkRheXModGhpcy5kYXRlc1swXSwgZGF0ZSkpO1xyXG4gICAgICAgICAgICBpZiAoZGF5T2Zmc2V0IDwgMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGluZGljZXNbMF0gLSAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChkYXlPZmZzZXQgPj0gaW5kaWNlcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpbmRpY2VzW2luZGljZXMubGVuZ3RoIC0gMV0gKyAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBpbmRpY2VzW2RheU9mZnNldF07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNsYXNzIERheVRhYmxlTW9kZWwge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yKGRheVNlcmllcywgYnJlYWtPbldlZWtzKSB7XHJcbiAgICAgICAgICAgIGxldCB7IGRhdGVzIH0gPSBkYXlTZXJpZXM7XHJcbiAgICAgICAgICAgIGxldCBkYXlzUGVyUm93O1xyXG4gICAgICAgICAgICBsZXQgZmlyc3REYXk7XHJcbiAgICAgICAgICAgIGxldCByb3dDbnQ7XHJcbiAgICAgICAgICAgIGlmIChicmVha09uV2Vla3MpIHtcclxuICAgICAgICAgICAgICAgIC8vIGNvdW50IGNvbHVtbnMgdW50aWwgdGhlIGRheS1vZi13ZWVrIHJlcGVhdHNcclxuICAgICAgICAgICAgICAgIGZpcnN0RGF5ID0gZGF0ZXNbMF0uZ2V0VVRDRGF5KCk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGRheXNQZXJSb3cgPSAxOyBkYXlzUGVyUm93IDwgZGF0ZXMubGVuZ3RoOyBkYXlzUGVyUm93ICs9IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0ZXNbZGF5c1BlclJvd10uZ2V0VVRDRGF5KCkgPT09IGZpcnN0RGF5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJvd0NudCA9IE1hdGguY2VpbChkYXRlcy5sZW5ndGggLyBkYXlzUGVyUm93KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJvd0NudCA9IDE7XHJcbiAgICAgICAgICAgICAgICBkYXlzUGVyUm93ID0gZGF0ZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMucm93Q250ID0gcm93Q250O1xyXG4gICAgICAgICAgICB0aGlzLmNvbENudCA9IGRheXNQZXJSb3c7XHJcbiAgICAgICAgICAgIHRoaXMuZGF5U2VyaWVzID0gZGF5U2VyaWVzO1xyXG4gICAgICAgICAgICB0aGlzLmNlbGxzID0gdGhpcy5idWlsZENlbGxzKCk7XHJcbiAgICAgICAgICAgIHRoaXMuaGVhZGVyRGF0ZXMgPSB0aGlzLmJ1aWxkSGVhZGVyRGF0ZXMoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYnVpbGRDZWxscygpIHtcclxuICAgICAgICAgICAgbGV0IHJvd3MgPSBbXTtcclxuICAgICAgICAgICAgZm9yIChsZXQgcm93ID0gMDsgcm93IDwgdGhpcy5yb3dDbnQ7IHJvdyArPSAxKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgY2VsbHMgPSBbXTtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGNvbCA9IDA7IGNvbCA8IHRoaXMuY29sQ250OyBjb2wgKz0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNlbGxzLnB1c2godGhpcy5idWlsZENlbGwocm93LCBjb2wpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJvd3MucHVzaChjZWxscyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJvd3M7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJ1aWxkQ2VsbChyb3csIGNvbCkge1xyXG4gICAgICAgICAgICBsZXQgZGF0ZSA9IHRoaXMuZGF5U2VyaWVzLmRhdGVzW3JvdyAqIHRoaXMuY29sQ250ICsgY29sXTtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGtleTogZGF0ZS50b0lTT1N0cmluZygpLFxyXG4gICAgICAgICAgICAgICAgZGF0ZSxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYnVpbGRIZWFkZXJEYXRlcygpIHtcclxuICAgICAgICAgICAgbGV0IGRhdGVzID0gW107XHJcbiAgICAgICAgICAgIGZvciAobGV0IGNvbCA9IDA7IGNvbCA8IHRoaXMuY29sQ250OyBjb2wgKz0gMSkge1xyXG4gICAgICAgICAgICAgICAgZGF0ZXMucHVzaCh0aGlzLmNlbGxzWzBdW2NvbF0uZGF0ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGRhdGVzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzbGljZVJhbmdlKHJhbmdlKSB7XHJcbiAgICAgICAgICAgIGxldCB7IGNvbENudCB9ID0gdGhpcztcclxuICAgICAgICAgICAgbGV0IHNlcmllc1NlZyA9IHRoaXMuZGF5U2VyaWVzLnNsaWNlUmFuZ2UocmFuZ2UpO1xyXG4gICAgICAgICAgICBsZXQgc2VncyA9IFtdO1xyXG4gICAgICAgICAgICBpZiAoc2VyaWVzU2VnKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgeyBmaXJzdEluZGV4LCBsYXN0SW5kZXggfSA9IHNlcmllc1NlZztcclxuICAgICAgICAgICAgICAgIGxldCBpbmRleCA9IGZpcnN0SW5kZXg7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoaW5kZXggPD0gbGFzdEluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJvdyA9IE1hdGguZmxvb3IoaW5kZXggLyBjb2xDbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBuZXh0SW5kZXggPSBNYXRoLm1pbigocm93ICsgMSkgKiBjb2xDbnQsIGxhc3RJbmRleCArIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNlZ3MucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3RDb2w6IGluZGV4ICUgY29sQ250LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0Q29sOiAobmV4dEluZGV4IC0gMSkgJSBjb2xDbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzU3RhcnQ6IHNlcmllc1NlZy5pc1N0YXJ0ICYmIGluZGV4ID09PSBmaXJzdEluZGV4LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0VuZDogc2VyaWVzU2VnLmlzRW5kICYmIChuZXh0SW5kZXggLSAxKSA9PT0gbGFzdEluZGV4LFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gbmV4dEluZGV4O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBzZWdzO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBjbGFzcyBTbGljZXIge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgICAgICB0aGlzLnNsaWNlQnVzaW5lc3NIb3VycyA9IG1lbW9pemUodGhpcy5fc2xpY2VCdXNpbmVzc0hvdXJzKTtcclxuICAgICAgICAgICAgdGhpcy5zbGljZURhdGVTZWxlY3Rpb24gPSBtZW1vaXplKHRoaXMuX3NsaWNlRGF0ZVNwYW4pO1xyXG4gICAgICAgICAgICB0aGlzLnNsaWNlRXZlbnRTdG9yZSA9IG1lbW9pemUodGhpcy5fc2xpY2VFdmVudFN0b3JlKTtcclxuICAgICAgICAgICAgdGhpcy5zbGljZUV2ZW50RHJhZyA9IG1lbW9pemUodGhpcy5fc2xpY2VJbnRlcmFjdGlvbik7XHJcbiAgICAgICAgICAgIHRoaXMuc2xpY2VFdmVudFJlc2l6ZSA9IG1lbW9pemUodGhpcy5fc2xpY2VJbnRlcmFjdGlvbik7XHJcbiAgICAgICAgICAgIHRoaXMuZm9yY2VEYXlJZkxpc3RJdGVtID0gZmFsc2U7IC8vIGhhY2tcclxuICAgICAgICB9XHJcbiAgICAgICAgc2xpY2VQcm9wcyhwcm9wcywgZGF0ZVByb2ZpbGUsIG5leHREYXlUaHJlc2hvbGQsIGNvbnRleHQsIC4uLmV4dHJhQXJncykge1xyXG4gICAgICAgICAgICBsZXQgeyBldmVudFVpQmFzZXMgfSA9IHByb3BzO1xyXG4gICAgICAgICAgICBsZXQgZXZlbnRTZWdzID0gdGhpcy5zbGljZUV2ZW50U3RvcmUocHJvcHMuZXZlbnRTdG9yZSwgZXZlbnRVaUJhc2VzLCBkYXRlUHJvZmlsZSwgbmV4dERheVRocmVzaG9sZCwgLi4uZXh0cmFBcmdzKTtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGRhdGVTZWxlY3Rpb25TZWdzOiB0aGlzLnNsaWNlRGF0ZVNlbGVjdGlvbihwcm9wcy5kYXRlU2VsZWN0aW9uLCBkYXRlUHJvZmlsZSwgbmV4dERheVRocmVzaG9sZCwgZXZlbnRVaUJhc2VzLCBjb250ZXh0LCAuLi5leHRyYUFyZ3MpLFxyXG4gICAgICAgICAgICAgICAgYnVzaW5lc3NIb3VyU2VnczogdGhpcy5zbGljZUJ1c2luZXNzSG91cnMocHJvcHMuYnVzaW5lc3NIb3VycywgZGF0ZVByb2ZpbGUsIG5leHREYXlUaHJlc2hvbGQsIGNvbnRleHQsIC4uLmV4dHJhQXJncyksXHJcbiAgICAgICAgICAgICAgICBmZ0V2ZW50U2VnczogZXZlbnRTZWdzLmZnLFxyXG4gICAgICAgICAgICAgICAgYmdFdmVudFNlZ3M6IGV2ZW50U2Vncy5iZyxcclxuICAgICAgICAgICAgICAgIGV2ZW50RHJhZzogdGhpcy5zbGljZUV2ZW50RHJhZyhwcm9wcy5ldmVudERyYWcsIGV2ZW50VWlCYXNlcywgZGF0ZVByb2ZpbGUsIG5leHREYXlUaHJlc2hvbGQsIC4uLmV4dHJhQXJncyksXHJcbiAgICAgICAgICAgICAgICBldmVudFJlc2l6ZTogdGhpcy5zbGljZUV2ZW50UmVzaXplKHByb3BzLmV2ZW50UmVzaXplLCBldmVudFVpQmFzZXMsIGRhdGVQcm9maWxlLCBuZXh0RGF5VGhyZXNob2xkLCAuLi5leHRyYUFyZ3MpLFxyXG4gICAgICAgICAgICAgICAgZXZlbnRTZWxlY3Rpb246IHByb3BzLmV2ZW50U2VsZWN0aW9uLFxyXG4gICAgICAgICAgICB9OyAvLyBUT0RPOiBnaXZlIGludGVyYWN0aW9uU2Vncz9cclxuICAgICAgICB9XHJcbiAgICAgICAgc2xpY2VOb3dEYXRlKC8vIGRvZXMgbm90IG1lbW9pemVcclxuICAgICAgICBkYXRlLCBkYXRlUHJvZmlsZSwgbmV4dERheVRocmVzaG9sZCwgY29udGV4dCwgLi4uZXh0cmFBcmdzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zbGljZURhdGVTcGFuKHsgcmFuZ2U6IHsgc3RhcnQ6IGRhdGUsIGVuZDogYWRkTXMoZGF0ZSwgMSkgfSwgYWxsRGF5OiBmYWxzZSB9LCAvLyBhZGQgMSBtcywgcHJvdGVjdCBhZ2FpbnN0IG51bGwgcmFuZ2VcclxuICAgICAgICAgICAgZGF0ZVByb2ZpbGUsIG5leHREYXlUaHJlc2hvbGQsIHt9LCBjb250ZXh0LCAuLi5leHRyYUFyZ3MpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBfc2xpY2VCdXNpbmVzc0hvdXJzKGJ1c2luZXNzSG91cnMsIGRhdGVQcm9maWxlLCBuZXh0RGF5VGhyZXNob2xkLCBjb250ZXh0LCAuLi5leHRyYUFyZ3MpIHtcclxuICAgICAgICAgICAgaWYgKCFidXNpbmVzc0hvdXJzKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NsaWNlRXZlbnRTdG9yZShleHBhbmRSZWN1cnJpbmcoYnVzaW5lc3NIb3VycywgY29tcHV0ZUFjdGl2ZVJhbmdlKGRhdGVQcm9maWxlLCBCb29sZWFuKG5leHREYXlUaHJlc2hvbGQpKSwgY29udGV4dCksIHt9LCBkYXRlUHJvZmlsZSwgbmV4dERheVRocmVzaG9sZCwgLi4uZXh0cmFBcmdzKS5iZztcclxuICAgICAgICB9XHJcbiAgICAgICAgX3NsaWNlRXZlbnRTdG9yZShldmVudFN0b3JlLCBldmVudFVpQmFzZXMsIGRhdGVQcm9maWxlLCBuZXh0RGF5VGhyZXNob2xkLCAuLi5leHRyYUFyZ3MpIHtcclxuICAgICAgICAgICAgaWYgKGV2ZW50U3RvcmUpIHtcclxuICAgICAgICAgICAgICAgIGxldCByYW5nZVJlcyA9IHNsaWNlRXZlbnRTdG9yZShldmVudFN0b3JlLCBldmVudFVpQmFzZXMsIGNvbXB1dGVBY3RpdmVSYW5nZShkYXRlUHJvZmlsZSwgQm9vbGVhbihuZXh0RGF5VGhyZXNob2xkKSksIG5leHREYXlUaHJlc2hvbGQpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICBiZzogdGhpcy5zbGljZUV2ZW50UmFuZ2VzKHJhbmdlUmVzLmJnLCBleHRyYUFyZ3MpLFxyXG4gICAgICAgICAgICAgICAgICAgIGZnOiB0aGlzLnNsaWNlRXZlbnRSYW5nZXMocmFuZ2VSZXMuZmcsIGV4dHJhQXJncyksXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB7IGJnOiBbXSwgZmc6IFtdIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9zbGljZUludGVyYWN0aW9uKGludGVyYWN0aW9uLCBldmVudFVpQmFzZXMsIGRhdGVQcm9maWxlLCBuZXh0RGF5VGhyZXNob2xkLCAuLi5leHRyYUFyZ3MpIHtcclxuICAgICAgICAgICAgaWYgKCFpbnRlcmFjdGlvbikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IHJhbmdlUmVzID0gc2xpY2VFdmVudFN0b3JlKGludGVyYWN0aW9uLm11dGF0ZWRFdmVudHMsIGV2ZW50VWlCYXNlcywgY29tcHV0ZUFjdGl2ZVJhbmdlKGRhdGVQcm9maWxlLCBCb29sZWFuKG5leHREYXlUaHJlc2hvbGQpKSwgbmV4dERheVRocmVzaG9sZCk7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBzZWdzOiB0aGlzLnNsaWNlRXZlbnRSYW5nZXMocmFuZ2VSZXMuZmcsIGV4dHJhQXJncyksXHJcbiAgICAgICAgICAgICAgICBhZmZlY3RlZEluc3RhbmNlczogaW50ZXJhY3Rpb24uYWZmZWN0ZWRFdmVudHMuaW5zdGFuY2VzLFxyXG4gICAgICAgICAgICAgICAgaXNFdmVudDogaW50ZXJhY3Rpb24uaXNFdmVudCxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgX3NsaWNlRGF0ZVNwYW4oZGF0ZVNwYW4sIGRhdGVQcm9maWxlLCBuZXh0RGF5VGhyZXNob2xkLCBldmVudFVpQmFzZXMsIGNvbnRleHQsIC4uLmV4dHJhQXJncykge1xyXG4gICAgICAgICAgICBpZiAoIWRhdGVTcGFuKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IGFjdGl2ZVJhbmdlID0gY29tcHV0ZUFjdGl2ZVJhbmdlKGRhdGVQcm9maWxlLCBCb29sZWFuKG5leHREYXlUaHJlc2hvbGQpKTtcclxuICAgICAgICAgICAgbGV0IGFjdGl2ZURhdGVTcGFuUmFuZ2UgPSBpbnRlcnNlY3RSYW5nZXMoZGF0ZVNwYW4ucmFuZ2UsIGFjdGl2ZVJhbmdlKTtcclxuICAgICAgICAgICAgaWYgKGFjdGl2ZURhdGVTcGFuUmFuZ2UpIHtcclxuICAgICAgICAgICAgICAgIGRhdGVTcGFuID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkYXRlU3BhbiksIHsgcmFuZ2U6IGFjdGl2ZURhdGVTcGFuUmFuZ2UgfSk7XHJcbiAgICAgICAgICAgICAgICBsZXQgZXZlbnRSYW5nZSA9IGZhYnJpY2F0ZUV2ZW50UmFuZ2UoZGF0ZVNwYW4sIGV2ZW50VWlCYXNlcywgY29udGV4dCk7XHJcbiAgICAgICAgICAgICAgICBsZXQgc2VncyA9IHRoaXMuc2xpY2VSYW5nZShkYXRlU3Bhbi5yYW5nZSwgLi4uZXh0cmFBcmdzKTtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IHNlZyBvZiBzZWdzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VnLmV2ZW50UmFuZ2UgPSBldmVudFJhbmdlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlZ3M7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKlxyXG4gICAgICAgIFwiY29tcGxldGVcIiBzZWcgbWVhbnMgaXQgaGFzIGNvbXBvbmVudCBhbmQgZXZlbnRSYW5nZVxyXG4gICAgICAgICovXHJcbiAgICAgICAgc2xpY2VFdmVudFJhbmdlcyhldmVudFJhbmdlcywgZXh0cmFBcmdzKSB7XHJcbiAgICAgICAgICAgIGxldCBzZWdzID0gW107XHJcbiAgICAgICAgICAgIGZvciAobGV0IGV2ZW50UmFuZ2Ugb2YgZXZlbnRSYW5nZXMpIHtcclxuICAgICAgICAgICAgICAgIHNlZ3MucHVzaCguLi50aGlzLnNsaWNlRXZlbnRSYW5nZShldmVudFJhbmdlLCBleHRyYUFyZ3MpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gc2VncztcclxuICAgICAgICB9XHJcbiAgICAgICAgLypcclxuICAgICAgICBcImNvbXBsZXRlXCIgc2VnIG1lYW5zIGl0IGhhcyBjb21wb25lbnQgYW5kIGV2ZW50UmFuZ2VcclxuICAgICAgICAqL1xyXG4gICAgICAgIHNsaWNlRXZlbnRSYW5nZShldmVudFJhbmdlLCBleHRyYUFyZ3MpIHtcclxuICAgICAgICAgICAgbGV0IGRhdGVSYW5nZSA9IGV2ZW50UmFuZ2UucmFuZ2U7XHJcbiAgICAgICAgICAgIC8vIGhhY2sgdG8gbWFrZSBtdWx0aS1kYXkgZXZlbnRzIHRoYXQgYXJlIGJlaW5nIGZvcmNlLWRpc3BsYXllZCBhcyBsaXN0LWl0ZW1zIHRvIHRha2UgdXAgb25seSBvbmUgZGF5XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmZvcmNlRGF5SWZMaXN0SXRlbSAmJiBldmVudFJhbmdlLnVpLmRpc3BsYXkgPT09ICdsaXN0LWl0ZW0nKSB7XHJcbiAgICAgICAgICAgICAgICBkYXRlUmFuZ2UgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IGRhdGVSYW5nZS5zdGFydCxcclxuICAgICAgICAgICAgICAgICAgICBlbmQ6IGFkZERheXMoZGF0ZVJhbmdlLnN0YXJ0LCAxKSxcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IHNlZ3MgPSB0aGlzLnNsaWNlUmFuZ2UoZGF0ZVJhbmdlLCAuLi5leHRyYUFyZ3MpO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBzZWcgb2Ygc2Vncykge1xyXG4gICAgICAgICAgICAgICAgc2VnLmV2ZW50UmFuZ2UgPSBldmVudFJhbmdlO1xyXG4gICAgICAgICAgICAgICAgc2VnLmlzU3RhcnQgPSBldmVudFJhbmdlLmlzU3RhcnQgJiYgc2VnLmlzU3RhcnQ7XHJcbiAgICAgICAgICAgICAgICBzZWcuaXNFbmQgPSBldmVudFJhbmdlLmlzRW5kICYmIHNlZy5pc0VuZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gc2VncztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKlxyXG4gICAgZm9yIGluY29ycG9yYXRpbmcgc2xvdE1pblRpbWUvc2xvdE1heFRpbWUgaWYgYXBwcm9wcmlhdGVcclxuICAgIFRPRE86IHNob3VsZCBiZSBwYXJ0IG9mIERhdGVQcm9maWxlIVxyXG4gICAgVGltZWxpbmVEYXRlUHJvZmlsZSBhbHJlYWR5IGRvZXMgdGhpcyBidHdcclxuICAgICovXHJcbiAgICBmdW5jdGlvbiBjb21wdXRlQWN0aXZlUmFuZ2UoZGF0ZVByb2ZpbGUsIGlzQ29tcG9uZW50QWxsRGF5KSB7XHJcbiAgICAgICAgbGV0IHJhbmdlID0gZGF0ZVByb2ZpbGUuYWN0aXZlUmFuZ2U7XHJcbiAgICAgICAgaWYgKGlzQ29tcG9uZW50QWxsRGF5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiByYW5nZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgc3RhcnQ6IGFkZE1zKHJhbmdlLnN0YXJ0LCBkYXRlUHJvZmlsZS5zbG90TWluVGltZS5taWxsaXNlY29uZHMpLFxyXG4gICAgICAgICAgICBlbmQ6IGFkZE1zKHJhbmdlLmVuZCwgZGF0ZVByb2ZpbGUuc2xvdE1heFRpbWUubWlsbGlzZWNvbmRzIC0gODY0ZTUpLCAvLyA4NjRlNSA9IG1zIGluIGEgZGF5XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiByZWR1Y2VFdmVudFN0b3JlKGV2ZW50U3RvcmUsIGFjdGlvbiwgZXZlbnRTb3VyY2VzLCBkYXRlUHJvZmlsZSwgY29udGV4dCkge1xyXG4gICAgICAgIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcclxuICAgICAgICAgICAgY2FzZSAnUkVDRUlWRV9FVkVOVFMnOiAvLyByYXdcclxuICAgICAgICAgICAgICAgIHJldHVybiByZWNlaXZlUmF3RXZlbnRzKGV2ZW50U3RvcmUsIGV2ZW50U291cmNlc1thY3Rpb24uc291cmNlSWRdLCBhY3Rpb24uZmV0Y2hJZCwgYWN0aW9uLmZldGNoUmFuZ2UsIGFjdGlvbi5yYXdFdmVudHMsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICBjYXNlICdSRVNFVF9SQVdfRVZFTlRTJzpcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXNldFJhd0V2ZW50cyhldmVudFN0b3JlLCBldmVudFNvdXJjZXNbYWN0aW9uLnNvdXJjZUlkXSwgYWN0aW9uLnJhd0V2ZW50cywgZGF0ZVByb2ZpbGUuYWN0aXZlUmFuZ2UsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICBjYXNlICdBRERfRVZFTlRTJzogLy8gYWxyZWFkeSBwYXJzZWQsIGJ1dCBub3QgZXhwYW5kZWRcclxuICAgICAgICAgICAgICAgIHJldHVybiBhZGRFdmVudChldmVudFN0b3JlLCBhY3Rpb24uZXZlbnRTdG9yZSwgLy8gbmV3IG9uZXNcclxuICAgICAgICAgICAgICAgIGRhdGVQcm9maWxlID8gZGF0ZVByb2ZpbGUuYWN0aXZlUmFuZ2UgOiBudWxsLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgY2FzZSAnUkVTRVRfRVZFTlRTJzpcclxuICAgICAgICAgICAgICAgIHJldHVybiBhY3Rpb24uZXZlbnRTdG9yZTtcclxuICAgICAgICAgICAgY2FzZSAnTUVSR0VfRVZFTlRTJzogLy8gYWxyZWFkeSBwYXJzZWQgYW5kIGV4cGFuZGVkXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbWVyZ2VFdmVudFN0b3JlcyhldmVudFN0b3JlLCBhY3Rpb24uZXZlbnRTdG9yZSk7XHJcbiAgICAgICAgICAgIGNhc2UgJ1BSRVYnOiAvLyBUT0RPOiBob3cgZG8gd2UgdHJhY2sgYWxsIGFjdGlvbnMgdGhhdCBhZmZlY3QgZGF0ZVByb2ZpbGUgOihcclxuICAgICAgICAgICAgY2FzZSAnTkVYVCc6XHJcbiAgICAgICAgICAgIGNhc2UgJ0NIQU5HRV9EQVRFJzpcclxuICAgICAgICAgICAgY2FzZSAnQ0hBTkdFX1ZJRVdfVFlQRSc6XHJcbiAgICAgICAgICAgICAgICBpZiAoZGF0ZVByb2ZpbGUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXhwYW5kUmVjdXJyaW5nKGV2ZW50U3RvcmUsIGRhdGVQcm9maWxlLmFjdGl2ZVJhbmdlLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBldmVudFN0b3JlO1xyXG4gICAgICAgICAgICBjYXNlICdSRU1PVkVfRVZFTlRTJzpcclxuICAgICAgICAgICAgICAgIHJldHVybiBleGNsdWRlU3ViRXZlbnRTdG9yZShldmVudFN0b3JlLCBhY3Rpb24uZXZlbnRTdG9yZSk7XHJcbiAgICAgICAgICAgIGNhc2UgJ1JFTU9WRV9FVkVOVF9TT1VSQ0UnOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4Y2x1ZGVFdmVudHNCeVNvdXJjZUlkKGV2ZW50U3RvcmUsIGFjdGlvbi5zb3VyY2VJZCk7XHJcbiAgICAgICAgICAgIGNhc2UgJ1JFTU9WRV9BTExfRVZFTlRfU09VUkNFUyc6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmlsdGVyRXZlbnRTdG9yZURlZnMoZXZlbnRTdG9yZSwgKGV2ZW50RGVmKSA9PiAoIWV2ZW50RGVmLnNvdXJjZUlkIC8vIG9ubHkga2VlcCBldmVudHMgd2l0aCBubyBzb3VyY2UgaWRcclxuICAgICAgICAgICAgICAgICkpO1xyXG4gICAgICAgICAgICBjYXNlICdSRU1PVkVfQUxMX0VWRU5UUyc6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlRW1wdHlFdmVudFN0b3JlKCk7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZXZlbnRTdG9yZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiByZWNlaXZlUmF3RXZlbnRzKGV2ZW50U3RvcmUsIGV2ZW50U291cmNlLCBmZXRjaElkLCBmZXRjaFJhbmdlLCByYXdFdmVudHMsIGNvbnRleHQpIHtcclxuICAgICAgICBpZiAoZXZlbnRTb3VyY2UgJiYgLy8gbm90IGFscmVhZHkgcmVtb3ZlZFxyXG4gICAgICAgICAgICBmZXRjaElkID09PSBldmVudFNvdXJjZS5sYXRlc3RGZXRjaElkIC8vIFRPRE86IHdpc2ggdGhpcyBsb2dpYyB3YXMgYWx3YXlzIGluIGV2ZW50LXNvdXJjZXNcclxuICAgICAgICApIHtcclxuICAgICAgICAgICAgbGV0IHN1YnNldCA9IHBhcnNlRXZlbnRzKHRyYW5zZm9ybVJhd0V2ZW50cyhyYXdFdmVudHMsIGV2ZW50U291cmNlLCBjb250ZXh0KSwgZXZlbnRTb3VyY2UsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICBpZiAoZmV0Y2hSYW5nZSkge1xyXG4gICAgICAgICAgICAgICAgc3Vic2V0ID0gZXhwYW5kUmVjdXJyaW5nKHN1YnNldCwgZmV0Y2hSYW5nZSwgY29udGV4dCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG1lcmdlRXZlbnRTdG9yZXMoZXhjbHVkZUV2ZW50c0J5U291cmNlSWQoZXZlbnRTdG9yZSwgZXZlbnRTb3VyY2Uuc291cmNlSWQpLCBzdWJzZXQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZXZlbnRTdG9yZTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHJlc2V0UmF3RXZlbnRzKGV4aXN0aW5nRXZlbnRTdG9yZSwgZXZlbnRTb3VyY2UsIHJhd0V2ZW50cywgYWN0aXZlUmFuZ2UsIGNvbnRleHQpIHtcclxuICAgICAgICBjb25zdCB7IGRlZklkTWFwLCBpbnN0YW5jZUlkTWFwIH0gPSBidWlsZFB1YmxpY0lkTWFwcyhleGlzdGluZ0V2ZW50U3RvcmUpO1xyXG4gICAgICAgIGxldCBuZXdFdmVudFN0b3JlID0gcGFyc2VFdmVudHModHJhbnNmb3JtUmF3RXZlbnRzKHJhd0V2ZW50cywgZXZlbnRTb3VyY2UsIGNvbnRleHQpLCBldmVudFNvdXJjZSwgY29udGV4dCwgZmFsc2UsIGRlZklkTWFwLCBpbnN0YW5jZUlkTWFwKTtcclxuICAgICAgICByZXR1cm4gZXhwYW5kUmVjdXJyaW5nKG5ld0V2ZW50U3RvcmUsIGFjdGl2ZVJhbmdlLCBjb250ZXh0KTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHRyYW5zZm9ybVJhd0V2ZW50cyhyYXdFdmVudHMsIGV2ZW50U291cmNlLCBjb250ZXh0KSB7XHJcbiAgICAgICAgbGV0IGNhbEVhY2hUcmFuc2Zvcm0gPSBjb250ZXh0Lm9wdGlvbnMuZXZlbnREYXRhVHJhbnNmb3JtO1xyXG4gICAgICAgIGxldCBzb3VyY2VFYWNoVHJhbnNmb3JtID0gZXZlbnRTb3VyY2UgPyBldmVudFNvdXJjZS5ldmVudERhdGFUcmFuc2Zvcm0gOiBudWxsO1xyXG4gICAgICAgIGlmIChzb3VyY2VFYWNoVHJhbnNmb3JtKSB7XHJcbiAgICAgICAgICAgIHJhd0V2ZW50cyA9IHRyYW5zZm9ybUVhY2hSYXdFdmVudChyYXdFdmVudHMsIHNvdXJjZUVhY2hUcmFuc2Zvcm0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY2FsRWFjaFRyYW5zZm9ybSkge1xyXG4gICAgICAgICAgICByYXdFdmVudHMgPSB0cmFuc2Zvcm1FYWNoUmF3RXZlbnQocmF3RXZlbnRzLCBjYWxFYWNoVHJhbnNmb3JtKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJhd0V2ZW50cztcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHRyYW5zZm9ybUVhY2hSYXdFdmVudChyYXdFdmVudHMsIGZ1bmMpIHtcclxuICAgICAgICBsZXQgcmVmaW5lZEV2ZW50cztcclxuICAgICAgICBpZiAoIWZ1bmMpIHtcclxuICAgICAgICAgICAgcmVmaW5lZEV2ZW50cyA9IHJhd0V2ZW50cztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJlZmluZWRFdmVudHMgPSBbXTtcclxuICAgICAgICAgICAgZm9yIChsZXQgcmF3RXZlbnQgb2YgcmF3RXZlbnRzKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgcmVmaW5lZEV2ZW50ID0gZnVuYyhyYXdFdmVudCk7XHJcbiAgICAgICAgICAgICAgICBpZiAocmVmaW5lZEV2ZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVmaW5lZEV2ZW50cy5wdXNoKHJlZmluZWRFdmVudCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyZWZpbmVkRXZlbnQgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlZmluZWRFdmVudHMucHVzaChyYXdFdmVudCk7XHJcbiAgICAgICAgICAgICAgICB9IC8vIGlmIGEgZGlmZmVyZW50IGZhbHN5IHZhbHVlLCBkbyBub3RoaW5nXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlZmluZWRFdmVudHM7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBhZGRFdmVudChldmVudFN0b3JlLCBzdWJzZXQsIGV4cGFuZFJhbmdlLCBjb250ZXh0KSB7XHJcbiAgICAgICAgaWYgKGV4cGFuZFJhbmdlKSB7XHJcbiAgICAgICAgICAgIHN1YnNldCA9IGV4cGFuZFJlY3VycmluZyhzdWJzZXQsIGV4cGFuZFJhbmdlLCBjb250ZXh0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG1lcmdlRXZlbnRTdG9yZXMoZXZlbnRTdG9yZSwgc3Vic2V0KTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHJlem9uZUV2ZW50U3RvcmVEYXRlcyhldmVudFN0b3JlLCBvbGREYXRlRW52LCBuZXdEYXRlRW52KSB7XHJcbiAgICAgICAgbGV0IHsgZGVmcyB9ID0gZXZlbnRTdG9yZTtcclxuICAgICAgICBsZXQgaW5zdGFuY2VzID0gbWFwSGFzaChldmVudFN0b3JlLmluc3RhbmNlcywgKGluc3RhbmNlKSA9PiB7XHJcbiAgICAgICAgICAgIGxldCBkZWYgPSBkZWZzW2luc3RhbmNlLmRlZklkXTtcclxuICAgICAgICAgICAgaWYgKGRlZi5hbGxEYXkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpbnN0YW5jZTsgLy8gaXNuJ3QgZGVwZW5kZW50IG9uIHRpbWV6b25lXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgaW5zdGFuY2UpLCB7IHJhbmdlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IG5ld0RhdGVFbnYuY3JlYXRlTWFya2VyKG9sZERhdGVFbnYudG9EYXRlKGluc3RhbmNlLnJhbmdlLnN0YXJ0LCBpbnN0YW5jZS5mb3JjZWRTdGFydFR6bykpLFxyXG4gICAgICAgICAgICAgICAgICAgIGVuZDogbmV3RGF0ZUVudi5jcmVhdGVNYXJrZXIob2xkRGF0ZUVudi50b0RhdGUoaW5zdGFuY2UucmFuZ2UuZW5kLCBpbnN0YW5jZS5mb3JjZWRFbmRUem8pKSxcclxuICAgICAgICAgICAgICAgIH0sIGZvcmNlZFN0YXJ0VHpvOiBuZXdEYXRlRW52LmNhbkNvbXB1dGVPZmZzZXQgPyBudWxsIDogaW5zdGFuY2UuZm9yY2VkU3RhcnRUem8sIGZvcmNlZEVuZFR6bzogbmV3RGF0ZUVudi5jYW5Db21wdXRlT2Zmc2V0ID8gbnVsbCA6IGluc3RhbmNlLmZvcmNlZEVuZFR6byB9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4geyBkZWZzLCBpbnN0YW5jZXMgfTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGV4Y2x1ZGVFdmVudHNCeVNvdXJjZUlkKGV2ZW50U3RvcmUsIHNvdXJjZUlkKSB7XHJcbiAgICAgICAgcmV0dXJuIGZpbHRlckV2ZW50U3RvcmVEZWZzKGV2ZW50U3RvcmUsIChldmVudERlZikgPT4gZXZlbnREZWYuc291cmNlSWQgIT09IHNvdXJjZUlkKTtcclxuICAgIH1cclxuICAgIC8vIFFVRVNUSU9OOiB3aHkgbm90IGp1c3QgcmV0dXJuIGluc3RhbmNlcz8gZG8gYSBnZW5lcmFsIG9iamVjdC1wcm9wZXJ0eS1leGNsdXNpb24gdXRpbFxyXG4gICAgZnVuY3Rpb24gZXhjbHVkZUluc3RhbmNlcyhldmVudFN0b3JlLCByZW1vdmFscykge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGRlZnM6IGV2ZW50U3RvcmUuZGVmcyxcclxuICAgICAgICAgICAgaW5zdGFuY2VzOiBmaWx0ZXJIYXNoKGV2ZW50U3RvcmUuaW5zdGFuY2VzLCAoaW5zdGFuY2UpID0+ICFyZW1vdmFsc1tpbnN0YW5jZS5pbnN0YW5jZUlkXSksXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGJ1aWxkUHVibGljSWRNYXBzKGV2ZW50U3RvcmUpIHtcclxuICAgICAgICBjb25zdCB7IGRlZnMsIGluc3RhbmNlcyB9ID0gZXZlbnRTdG9yZTtcclxuICAgICAgICBjb25zdCBkZWZJZE1hcCA9IHt9O1xyXG4gICAgICAgIGNvbnN0IGluc3RhbmNlSWRNYXAgPSB7fTtcclxuICAgICAgICBmb3IgKGxldCBkZWZJZCBpbiBkZWZzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRlZiA9IGRlZnNbZGVmSWRdO1xyXG4gICAgICAgICAgICBjb25zdCB7IHB1YmxpY0lkIH0gPSBkZWY7XHJcbiAgICAgICAgICAgIGlmIChwdWJsaWNJZCkge1xyXG4gICAgICAgICAgICAgICAgZGVmSWRNYXBbcHVibGljSWRdID0gZGVmSWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChsZXQgaW5zdGFuY2VJZCBpbiBpbnN0YW5jZXMpIHtcclxuICAgICAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBpbnN0YW5jZXNbaW5zdGFuY2VJZF07XHJcbiAgICAgICAgICAgIGNvbnN0IGRlZiA9IGRlZnNbaW5zdGFuY2UuZGVmSWRdO1xyXG4gICAgICAgICAgICBjb25zdCB7IHB1YmxpY0lkIH0gPSBkZWY7XHJcbiAgICAgICAgICAgIGlmIChwdWJsaWNJZCkge1xyXG4gICAgICAgICAgICAgICAgaW5zdGFuY2VJZE1hcFtwdWJsaWNJZF0gPSBpbnN0YW5jZUlkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7IGRlZklkTWFwLCBpbnN0YW5jZUlkTWFwIH07XHJcbiAgICB9XHJcblxyXG4gICAgLy8gaGlnaC1sZXZlbCBzZWdtZW50aW5nLWF3YXJlIHRlc3RlciBmdW5jdGlvbnNcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgZnVuY3Rpb24gaXNJbnRlcmFjdGlvblZhbGlkKGludGVyYWN0aW9uLCBkYXRlUHJvZmlsZSwgY29udGV4dCkge1xyXG4gICAgICAgIGxldCB7IGluc3RhbmNlcyB9ID0gaW50ZXJhY3Rpb24ubXV0YXRlZEV2ZW50cztcclxuICAgICAgICBmb3IgKGxldCBpbnN0YW5jZUlkIGluIGluc3RhbmNlcykge1xyXG4gICAgICAgICAgICBpZiAoIXJhbmdlQ29udGFpbnNSYW5nZShkYXRlUHJvZmlsZS52YWxpZFJhbmdlLCBpbnN0YW5jZXNbaW5zdGFuY2VJZF0ucmFuZ2UpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGlzTmV3UHJvcHNWYWxpZCh7IGV2ZW50RHJhZzogaW50ZXJhY3Rpb24gfSwgY29udGV4dCk7IC8vIEhBQ0s6IHRoZSBldmVudERyYWcgcHJvcHMgaXMgdXNlZCBmb3IgQUxMIGludGVyYWN0aW9uc1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gaXNEYXRlU2VsZWN0aW9uVmFsaWQoZGF0ZVNlbGVjdGlvbiwgZGF0ZVByb2ZpbGUsIGNvbnRleHQpIHtcclxuICAgICAgICBpZiAoIXJhbmdlQ29udGFpbnNSYW5nZShkYXRlUHJvZmlsZS52YWxpZFJhbmdlLCBkYXRlU2VsZWN0aW9uLnJhbmdlKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBpc05ld1Byb3BzVmFsaWQoeyBkYXRlU2VsZWN0aW9uIH0sIGNvbnRleHQpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gaXNOZXdQcm9wc1ZhbGlkKG5ld1Byb3BzLCBjb250ZXh0KSB7XHJcbiAgICAgICAgbGV0IGNhbGVuZGFyU3RhdGUgPSBjb250ZXh0LmdldEN1cnJlbnREYXRhKCk7XHJcbiAgICAgICAgbGV0IHByb3BzID0gT2JqZWN0LmFzc2lnbih7IGJ1c2luZXNzSG91cnM6IGNhbGVuZGFyU3RhdGUuYnVzaW5lc3NIb3VycywgZGF0ZVNlbGVjdGlvbjogJycsIGV2ZW50U3RvcmU6IGNhbGVuZGFyU3RhdGUuZXZlbnRTdG9yZSwgZXZlbnRVaUJhc2VzOiBjYWxlbmRhclN0YXRlLmV2ZW50VWlCYXNlcywgZXZlbnRTZWxlY3Rpb246ICcnLCBldmVudERyYWc6IG51bGwsIGV2ZW50UmVzaXplOiBudWxsIH0sIG5ld1Byb3BzKTtcclxuICAgICAgICByZXR1cm4gKGNvbnRleHQucGx1Z2luSG9va3MuaXNQcm9wc1ZhbGlkIHx8IGlzUHJvcHNWYWxpZCkocHJvcHMsIGNvbnRleHQpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gaXNQcm9wc1ZhbGlkKHN0YXRlLCBjb250ZXh0LCBkYXRlU3Bhbk1ldGEgPSB7fSwgZmlsdGVyQ29uZmlnKSB7XHJcbiAgICAgICAgaWYgKHN0YXRlLmV2ZW50RHJhZyAmJiAhaXNJbnRlcmFjdGlvblByb3BzVmFsaWQoc3RhdGUsIGNvbnRleHQsIGRhdGVTcGFuTWV0YSwgZmlsdGVyQ29uZmlnKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzdGF0ZS5kYXRlU2VsZWN0aW9uICYmICFpc0RhdGVTZWxlY3Rpb25Qcm9wc1ZhbGlkKHN0YXRlLCBjb250ZXh0LCBkYXRlU3Bhbk1ldGEsIGZpbHRlckNvbmZpZykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIC8vIE1vdmluZyBFdmVudCBWYWxpZGF0aW9uXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIGZ1bmN0aW9uIGlzSW50ZXJhY3Rpb25Qcm9wc1ZhbGlkKHN0YXRlLCBjb250ZXh0LCBkYXRlU3Bhbk1ldGEsIGZpbHRlckNvbmZpZykge1xyXG4gICAgICAgIGxldCBjdXJyZW50U3RhdGUgPSBjb250ZXh0LmdldEN1cnJlbnREYXRhKCk7XHJcbiAgICAgICAgbGV0IGludGVyYWN0aW9uID0gc3RhdGUuZXZlbnREcmFnOyAvLyBIQUNLOiB0aGUgZXZlbnREcmFnIHByb3BzIGlzIHVzZWQgZm9yIEFMTCBpbnRlcmFjdGlvbnNcclxuICAgICAgICBsZXQgc3ViamVjdEV2ZW50U3RvcmUgPSBpbnRlcmFjdGlvbi5tdXRhdGVkRXZlbnRzO1xyXG4gICAgICAgIGxldCBzdWJqZWN0RGVmcyA9IHN1YmplY3RFdmVudFN0b3JlLmRlZnM7XHJcbiAgICAgICAgbGV0IHN1YmplY3RJbnN0YW5jZXMgPSBzdWJqZWN0RXZlbnRTdG9yZS5pbnN0YW5jZXM7XHJcbiAgICAgICAgbGV0IHN1YmplY3RDb25maWdzID0gY29tcGlsZUV2ZW50VWlzKHN1YmplY3REZWZzLCBpbnRlcmFjdGlvbi5pc0V2ZW50ID9cclxuICAgICAgICAgICAgc3RhdGUuZXZlbnRVaUJhc2VzIDpcclxuICAgICAgICAgICAgeyAnJzogY3VycmVudFN0YXRlLnNlbGVjdGlvbkNvbmZpZyB9KTtcclxuICAgICAgICBpZiAoZmlsdGVyQ29uZmlnKSB7XHJcbiAgICAgICAgICAgIHN1YmplY3RDb25maWdzID0gbWFwSGFzaChzdWJqZWN0Q29uZmlncywgZmlsdGVyQ29uZmlnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gZXhjbHVkZSB0aGUgc3ViamVjdCBldmVudHMuIFRPRE86IGV4Y2x1ZGUgZGVmcyB0b28/XHJcbiAgICAgICAgbGV0IG90aGVyRXZlbnRTdG9yZSA9IGV4Y2x1ZGVJbnN0YW5jZXMoc3RhdGUuZXZlbnRTdG9yZSwgaW50ZXJhY3Rpb24uYWZmZWN0ZWRFdmVudHMuaW5zdGFuY2VzKTtcclxuICAgICAgICBsZXQgb3RoZXJEZWZzID0gb3RoZXJFdmVudFN0b3JlLmRlZnM7XHJcbiAgICAgICAgbGV0IG90aGVySW5zdGFuY2VzID0gb3RoZXJFdmVudFN0b3JlLmluc3RhbmNlcztcclxuICAgICAgICBsZXQgb3RoZXJDb25maWdzID0gY29tcGlsZUV2ZW50VWlzKG90aGVyRGVmcywgc3RhdGUuZXZlbnRVaUJhc2VzKTtcclxuICAgICAgICBmb3IgKGxldCBzdWJqZWN0SW5zdGFuY2VJZCBpbiBzdWJqZWN0SW5zdGFuY2VzKSB7XHJcbiAgICAgICAgICAgIGxldCBzdWJqZWN0SW5zdGFuY2UgPSBzdWJqZWN0SW5zdGFuY2VzW3N1YmplY3RJbnN0YW5jZUlkXTtcclxuICAgICAgICAgICAgbGV0IHN1YmplY3RSYW5nZSA9IHN1YmplY3RJbnN0YW5jZS5yYW5nZTtcclxuICAgICAgICAgICAgbGV0IHN1YmplY3RDb25maWcgPSBzdWJqZWN0Q29uZmlnc1tzdWJqZWN0SW5zdGFuY2UuZGVmSWRdO1xyXG4gICAgICAgICAgICBsZXQgc3ViamVjdERlZiA9IHN1YmplY3REZWZzW3N1YmplY3RJbnN0YW5jZS5kZWZJZF07XHJcbiAgICAgICAgICAgIC8vIGNvbnN0cmFpbnRcclxuICAgICAgICAgICAgaWYgKCFhbGxDb25zdHJhaW50c1Bhc3Moc3ViamVjdENvbmZpZy5jb25zdHJhaW50cywgc3ViamVjdFJhbmdlLCBvdGhlckV2ZW50U3RvcmUsIHN0YXRlLmJ1c2luZXNzSG91cnMsIGNvbnRleHQpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gb3ZlcmxhcFxyXG4gICAgICAgICAgICBsZXQgeyBldmVudE92ZXJsYXAgfSA9IGNvbnRleHQub3B0aW9ucztcclxuICAgICAgICAgICAgbGV0IGV2ZW50T3ZlcmxhcEZ1bmMgPSB0eXBlb2YgZXZlbnRPdmVybGFwID09PSAnZnVuY3Rpb24nID8gZXZlbnRPdmVybGFwIDogbnVsbDtcclxuICAgICAgICAgICAgZm9yIChsZXQgb3RoZXJJbnN0YW5jZUlkIGluIG90aGVySW5zdGFuY2VzKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgb3RoZXJJbnN0YW5jZSA9IG90aGVySW5zdGFuY2VzW290aGVySW5zdGFuY2VJZF07XHJcbiAgICAgICAgICAgICAgICAvLyBpbnRlcnNlY3QhIGV2YWx1YXRlXHJcbiAgICAgICAgICAgICAgICBpZiAocmFuZ2VzSW50ZXJzZWN0KHN1YmplY3RSYW5nZSwgb3RoZXJJbnN0YW5jZS5yYW5nZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgb3RoZXJPdmVybGFwID0gb3RoZXJDb25maWdzW290aGVySW5zdGFuY2UuZGVmSWRdLm92ZXJsYXA7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gY29uc2lkZXIgdGhlIG90aGVyIGV2ZW50J3Mgb3ZlcmxhcC4gb25seSBkbyB0aGlzIGlmIHRoZSBzdWJqZWN0IGV2ZW50IGlzIGEgXCJyZWFsXCIgZXZlbnRcclxuICAgICAgICAgICAgICAgICAgICBpZiAob3RoZXJPdmVybGFwID09PSBmYWxzZSAmJiBpbnRlcmFjdGlvbi5pc0V2ZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN1YmplY3RDb25maWcub3ZlcmxhcCA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnRPdmVybGFwRnVuYyAmJiAhZXZlbnRPdmVybGFwRnVuYyhuZXcgRXZlbnRJbXBsKGNvbnRleHQsIG90aGVyRGVmc1tvdGhlckluc3RhbmNlLmRlZklkXSwgb3RoZXJJbnN0YW5jZSksIC8vIHN0aWxsIGV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3IEV2ZW50SW1wbChjb250ZXh0LCBzdWJqZWN0RGVmLCBzdWJqZWN0SW5zdGFuY2UpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGFsbG93IChhIGZ1bmN0aW9uKVxyXG4gICAgICAgICAgICBsZXQgY2FsZW5kYXJFdmVudFN0b3JlID0gY3VycmVudFN0YXRlLmV2ZW50U3RvcmU7IC8vIG5lZWQgZ2xvYmFsLXRvLWNhbGVuZGFyLCBub3QgbG9jYWwgdG8gY29tcG9uZW50IChzcGxpdHRhYmxlKXN0YXRlXHJcbiAgICAgICAgICAgIGZvciAobGV0IHN1YmplY3RBbGxvdyBvZiBzdWJqZWN0Q29uZmlnLmFsbG93cykge1xyXG4gICAgICAgICAgICAgICAgbGV0IHN1YmplY3REYXRlU3BhbiA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZGF0ZVNwYW5NZXRhKSwgeyByYW5nZTogc3ViamVjdEluc3RhbmNlLnJhbmdlLCBhbGxEYXk6IHN1YmplY3REZWYuYWxsRGF5IH0pO1xyXG4gICAgICAgICAgICAgICAgbGV0IG9yaWdEZWYgPSBjYWxlbmRhckV2ZW50U3RvcmUuZGVmc1tzdWJqZWN0RGVmLmRlZklkXTtcclxuICAgICAgICAgICAgICAgIGxldCBvcmlnSW5zdGFuY2UgPSBjYWxlbmRhckV2ZW50U3RvcmUuaW5zdGFuY2VzW3N1YmplY3RJbnN0YW5jZUlkXTtcclxuICAgICAgICAgICAgICAgIGxldCBldmVudEFwaTtcclxuICAgICAgICAgICAgICAgIGlmIChvcmlnRGVmKSB7IC8vIHdhcyBwcmV2aW91c2x5IGluIHRoZSBjYWxlbmRhclxyXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50QXBpID0gbmV3IEV2ZW50SW1wbChjb250ZXh0LCBvcmlnRGVmLCBvcmlnSW5zdGFuY2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7IC8vIHdhcyBhbiBleHRlcm5hbCBldmVudFxyXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50QXBpID0gbmV3IEV2ZW50SW1wbChjb250ZXh0LCBzdWJqZWN0RGVmKTsgLy8gbm8gaW5zdGFuY2UsIGJlY2F1c2UgaGFkIG5vIGRhdGVzXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoIXN1YmplY3RBbGxvdyhidWlsZERhdGVTcGFuQXBpV2l0aENvbnRleHQoc3ViamVjdERhdGVTcGFuLCBjb250ZXh0KSwgZXZlbnRBcGkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgLy8gRGF0ZSBTZWxlY3Rpb24gVmFsaWRhdGlvblxyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICBmdW5jdGlvbiBpc0RhdGVTZWxlY3Rpb25Qcm9wc1ZhbGlkKHN0YXRlLCBjb250ZXh0LCBkYXRlU3Bhbk1ldGEsIGZpbHRlckNvbmZpZykge1xyXG4gICAgICAgIGxldCByZWxldmFudEV2ZW50U3RvcmUgPSBzdGF0ZS5ldmVudFN0b3JlO1xyXG4gICAgICAgIGxldCByZWxldmFudERlZnMgPSByZWxldmFudEV2ZW50U3RvcmUuZGVmcztcclxuICAgICAgICBsZXQgcmVsZXZhbnRJbnN0YW5jZXMgPSByZWxldmFudEV2ZW50U3RvcmUuaW5zdGFuY2VzO1xyXG4gICAgICAgIGxldCBzZWxlY3Rpb24gPSBzdGF0ZS5kYXRlU2VsZWN0aW9uO1xyXG4gICAgICAgIGxldCBzZWxlY3Rpb25SYW5nZSA9IHNlbGVjdGlvbi5yYW5nZTtcclxuICAgICAgICBsZXQgeyBzZWxlY3Rpb25Db25maWcgfSA9IGNvbnRleHQuZ2V0Q3VycmVudERhdGEoKTtcclxuICAgICAgICBpZiAoZmlsdGVyQ29uZmlnKSB7XHJcbiAgICAgICAgICAgIHNlbGVjdGlvbkNvbmZpZyA9IGZpbHRlckNvbmZpZyhzZWxlY3Rpb25Db25maWcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBjb25zdHJhaW50XHJcbiAgICAgICAgaWYgKCFhbGxDb25zdHJhaW50c1Bhc3Moc2VsZWN0aW9uQ29uZmlnLmNvbnN0cmFpbnRzLCBzZWxlY3Rpb25SYW5nZSwgcmVsZXZhbnRFdmVudFN0b3JlLCBzdGF0ZS5idXNpbmVzc0hvdXJzLCBjb250ZXh0KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIG92ZXJsYXBcclxuICAgICAgICBsZXQgeyBzZWxlY3RPdmVybGFwIH0gPSBjb250ZXh0Lm9wdGlvbnM7XHJcbiAgICAgICAgbGV0IHNlbGVjdE92ZXJsYXBGdW5jID0gdHlwZW9mIHNlbGVjdE92ZXJsYXAgPT09ICdmdW5jdGlvbicgPyBzZWxlY3RPdmVybGFwIDogbnVsbDtcclxuICAgICAgICBmb3IgKGxldCByZWxldmFudEluc3RhbmNlSWQgaW4gcmVsZXZhbnRJbnN0YW5jZXMpIHtcclxuICAgICAgICAgICAgbGV0IHJlbGV2YW50SW5zdGFuY2UgPSByZWxldmFudEluc3RhbmNlc1tyZWxldmFudEluc3RhbmNlSWRdO1xyXG4gICAgICAgICAgICAvLyBpbnRlcnNlY3QhIGV2YWx1YXRlXHJcbiAgICAgICAgICAgIGlmIChyYW5nZXNJbnRlcnNlY3Qoc2VsZWN0aW9uUmFuZ2UsIHJlbGV2YW50SW5zdGFuY2UucmFuZ2UpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2VsZWN0aW9uQ29uZmlnLm92ZXJsYXAgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdE92ZXJsYXBGdW5jICYmICFzZWxlY3RPdmVybGFwRnVuYyhuZXcgRXZlbnRJbXBsKGNvbnRleHQsIHJlbGV2YW50RGVmc1tyZWxldmFudEluc3RhbmNlLmRlZklkXSwgcmVsZXZhbnRJbnN0YW5jZSksIG51bGwpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGFsbG93IChhIGZ1bmN0aW9uKVxyXG4gICAgICAgIGZvciAobGV0IHNlbGVjdGlvbkFsbG93IG9mIHNlbGVjdGlvbkNvbmZpZy5hbGxvd3MpIHtcclxuICAgICAgICAgICAgbGV0IGZ1bGxEYXRlU3BhbiA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZGF0ZVNwYW5NZXRhKSwgc2VsZWN0aW9uKTtcclxuICAgICAgICAgICAgaWYgKCFzZWxlY3Rpb25BbGxvdyhidWlsZERhdGVTcGFuQXBpV2l0aENvbnRleHQoZnVsbERhdGVTcGFuLCBjb250ZXh0KSwgbnVsbCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIC8vIENvbnN0cmFpbnQgVXRpbHNcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgZnVuY3Rpb24gYWxsQ29uc3RyYWludHNQYXNzKGNvbnN0cmFpbnRzLCBzdWJqZWN0UmFuZ2UsIG90aGVyRXZlbnRTdG9yZSwgYnVzaW5lc3NIb3Vyc1VuZXhwYW5kZWQsIGNvbnRleHQpIHtcclxuICAgICAgICBmb3IgKGxldCBjb25zdHJhaW50IG9mIGNvbnN0cmFpbnRzKSB7XHJcbiAgICAgICAgICAgIGlmICghYW55UmFuZ2VzQ29udGFpblJhbmdlKGNvbnN0cmFpbnRUb1Jhbmdlcyhjb25zdHJhaW50LCBzdWJqZWN0UmFuZ2UsIG90aGVyRXZlbnRTdG9yZSwgYnVzaW5lc3NIb3Vyc1VuZXhwYW5kZWQsIGNvbnRleHQpLCBzdWJqZWN0UmFuZ2UpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBjb25zdHJhaW50VG9SYW5nZXMoY29uc3RyYWludCwgc3ViamVjdFJhbmdlLCAvLyBmb3IgZXhwYW5kaW5nIGEgcmVjdXJyaW5nIGNvbnN0cmFpbnQsIG9yIGV4cGFuZGluZyBidXNpbmVzcyBob3Vyc1xyXG4gICAgb3RoZXJFdmVudFN0b3JlLCAvLyBmb3IgaWYgY29uc3RyYWludCBpcyBhbiBldmVuIGdyb3VwIElEXHJcbiAgICBidXNpbmVzc0hvdXJzVW5leHBhbmRlZCwgLy8gZm9yIGlmIGNvbnN0cmFpbnQgaXMgJ2J1c2luZXNzSG91cnMnXHJcbiAgICBjb250ZXh0KSB7XHJcbiAgICAgICAgaWYgKGNvbnN0cmFpbnQgPT09ICdidXNpbmVzc0hvdXJzJykge1xyXG4gICAgICAgICAgICByZXR1cm4gZXZlbnRTdG9yZVRvUmFuZ2VzKGV4cGFuZFJlY3VycmluZyhidXNpbmVzc0hvdXJzVW5leHBhbmRlZCwgc3ViamVjdFJhbmdlLCBjb250ZXh0KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlb2YgY29uc3RyYWludCA9PT0gJ3N0cmluZycpIHsgLy8gYW4gZ3JvdXAgSURcclxuICAgICAgICAgICAgcmV0dXJuIGV2ZW50U3RvcmVUb1JhbmdlcyhmaWx0ZXJFdmVudFN0b3JlRGVmcyhvdGhlckV2ZW50U3RvcmUsIChldmVudERlZikgPT4gZXZlbnREZWYuZ3JvdXBJZCA9PT0gY29uc3RyYWludCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mIGNvbnN0cmFpbnQgPT09ICdvYmplY3QnICYmIGNvbnN0cmFpbnQpIHsgLy8gbm9uLW51bGwgb2JqZWN0XHJcbiAgICAgICAgICAgIHJldHVybiBldmVudFN0b3JlVG9SYW5nZXMoZXhwYW5kUmVjdXJyaW5nKGNvbnN0cmFpbnQsIHN1YmplY3RSYW5nZSwgY29udGV4dCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gW107IC8vIGlmIGl0J3MgZmFsc2VcclxuICAgIH1cclxuICAgIC8vIFRPRE86IG1vdmUgdG8gZXZlbnQtc3RvcmUgZmlsZT9cclxuICAgIGZ1bmN0aW9uIGV2ZW50U3RvcmVUb1JhbmdlcyhldmVudFN0b3JlKSB7XHJcbiAgICAgICAgbGV0IHsgaW5zdGFuY2VzIH0gPSBldmVudFN0b3JlO1xyXG4gICAgICAgIGxldCByYW5nZXMgPSBbXTtcclxuICAgICAgICBmb3IgKGxldCBpbnN0YW5jZUlkIGluIGluc3RhbmNlcykge1xyXG4gICAgICAgICAgICByYW5nZXMucHVzaChpbnN0YW5jZXNbaW5zdGFuY2VJZF0ucmFuZ2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmFuZ2VzO1xyXG4gICAgfVxyXG4gICAgLy8gVE9ETzogbW92ZSB0byBnZW9tIGZpbGU/XHJcbiAgICBmdW5jdGlvbiBhbnlSYW5nZXNDb250YWluUmFuZ2Uob3V0ZXJSYW5nZXMsIGlubmVyUmFuZ2UpIHtcclxuICAgICAgICBmb3IgKGxldCBvdXRlclJhbmdlIG9mIG91dGVyUmFuZ2VzKSB7XHJcbiAgICAgICAgICAgIGlmIChyYW5nZUNvbnRhaW5zUmFuZ2Uob3V0ZXJSYW5nZSwgaW5uZXJSYW5nZSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBjbGFzcyBKc29uUmVxdWVzdEVycm9yIGV4dGVuZHMgRXJyb3Ige1xyXG4gICAgICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHJlc3BvbnNlKSB7XHJcbiAgICAgICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xyXG4gICAgICAgICAgICB0aGlzLnJlc3BvbnNlID0gcmVzcG9uc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gcmVxdWVzdEpzb24obWV0aG9kLCB1cmwsIHBhcmFtcykge1xyXG4gICAgICAgIG1ldGhvZCA9IG1ldGhvZC50b1VwcGVyQ2FzZSgpO1xyXG4gICAgICAgIGNvbnN0IGZldGNoT3B0aW9ucyA9IHtcclxuICAgICAgICAgICAgbWV0aG9kLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gJ0dFVCcpIHtcclxuICAgICAgICAgICAgdXJsICs9ICh1cmwuaW5kZXhPZignPycpID09PSAtMSA/ICc/JyA6ICcmJykgK1xyXG4gICAgICAgICAgICAgICAgbmV3IFVSTFNlYXJjaFBhcmFtcyhwYXJhbXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZmV0Y2hPcHRpb25zLmJvZHkgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHBhcmFtcyk7XHJcbiAgICAgICAgICAgIGZldGNoT3B0aW9ucy5oZWFkZXJzID0ge1xyXG4gICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmV0Y2godXJsLCBmZXRjaE9wdGlvbnMpLnRoZW4oKGZldGNoUmVzKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChmZXRjaFJlcy5vaykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZldGNoUmVzLmpzb24oKS50aGVuKChwYXJzZWRSZXNwb25zZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbcGFyc2VkUmVzcG9uc2UsIGZldGNoUmVzXTtcclxuICAgICAgICAgICAgICAgIH0sICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSnNvblJlcXVlc3RFcnJvcignRmFpbHVyZSBwYXJzaW5nIEpTT04nLCBmZXRjaFJlcyk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBKc29uUmVxdWVzdEVycm9yKCdSZXF1ZXN0IGZhaWxlZCcsIGZldGNoUmVzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGNsYXNzIERlbGF5ZWRSdW5uZXIge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yKGRyYWluZWRPcHRpb24pIHtcclxuICAgICAgICAgICAgdGhpcy5kcmFpbmVkT3B0aW9uID0gZHJhaW5lZE9wdGlvbjtcclxuICAgICAgICAgICAgdGhpcy5pc1J1bm5pbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5pc0RpcnR5ID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMucGF1c2VEZXB0aHMgPSB7fTtcclxuICAgICAgICAgICAgdGhpcy50aW1lb3V0SWQgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXF1ZXN0KGRlbGF5KSB7XHJcbiAgICAgICAgICAgIHRoaXMuaXNEaXJ0eSA9IHRydWU7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5pc1BhdXNlZCgpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNsZWFyVGltZW91dCgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGRlbGF5ID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyeURyYWluKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRpbWVvdXRJZCA9IHNldFRpbWVvdXQoLy8gTk9UIE9QVElNQUwhIFRPRE86IGxvb2sgYXQgZGVib3VuY2VcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyeURyYWluLmJpbmQodGhpcyksIGRlbGF5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBwYXVzZShzY29wZSA9ICcnKSB7XHJcbiAgICAgICAgICAgIGxldCB7IHBhdXNlRGVwdGhzIH0gPSB0aGlzO1xyXG4gICAgICAgICAgICBwYXVzZURlcHRoc1tzY29wZV0gPSAocGF1c2VEZXB0aHNbc2NvcGVdIHx8IDApICsgMTtcclxuICAgICAgICAgICAgdGhpcy5jbGVhclRpbWVvdXQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVzdW1lKHNjb3BlID0gJycsIGZvcmNlKSB7XHJcbiAgICAgICAgICAgIGxldCB7IHBhdXNlRGVwdGhzIH0gPSB0aGlzO1xyXG4gICAgICAgICAgICBpZiAoc2NvcGUgaW4gcGF1c2VEZXB0aHMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChmb3JjZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBwYXVzZURlcHRoc1tzY29wZV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBwYXVzZURlcHRoc1tzY29wZV0gLT0gMTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgZGVwdGggPSBwYXVzZURlcHRoc1tzY29wZV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlcHRoIDw9IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHBhdXNlRGVwdGhzW3Njb3BlXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRyeURyYWluKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaXNQYXVzZWQoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLnBhdXNlRGVwdGhzKS5sZW5ndGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRyeURyYWluKCkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNSdW5uaW5nICYmICF0aGlzLmlzUGF1c2VkKCkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaXNSdW5uaW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHdoaWxlICh0aGlzLmlzRGlydHkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmlzRGlydHkgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYWluZWQoKTsgLy8gbWlnaHQgc2V0IGlzRGlydHkgdG8gdHJ1ZSBhZ2FpblxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5pc1J1bm5pbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjbGVhcigpIHtcclxuICAgICAgICAgICAgdGhpcy5jbGVhclRpbWVvdXQoKTtcclxuICAgICAgICAgICAgdGhpcy5pc0RpcnR5ID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMucGF1c2VEZXB0aHMgPSB7fTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2xlYXJUaW1lb3V0KCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy50aW1lb3V0SWQpIHtcclxuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXRJZCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRpbWVvdXRJZCA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZHJhaW5lZCgpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuZHJhaW5lZE9wdGlvbikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kcmFpbmVkT3B0aW9uKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgVklTSUJMRV9ISURERU5fUkUgPSAvXih2aXNpYmxlfGhpZGRlbikkLztcclxuICAgIGNsYXNzIFNjcm9sbGVyIGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XHJcbiAgICAgICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlRWwgPSAoZWwpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZWwgPSBlbDtcclxuICAgICAgICAgICAgICAgIHNldFJlZih0aGlzLnByb3BzLmVsUmVmLCBlbCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlbmRlcigpIHtcclxuICAgICAgICAgICAgbGV0IHsgcHJvcHMgfSA9IHRoaXM7XHJcbiAgICAgICAgICAgIGxldCB7IGxpcXVpZCwgbGlxdWlkSXNBYnNvbHV0ZSB9ID0gcHJvcHM7XHJcbiAgICAgICAgICAgIGxldCBpc0Fic29sdXRlID0gbGlxdWlkICYmIGxpcXVpZElzQWJzb2x1dGU7XHJcbiAgICAgICAgICAgIGxldCBjbGFzc05hbWUgPSBbJ2ZjLXNjcm9sbGVyJ107XHJcbiAgICAgICAgICAgIGlmIChsaXF1aWQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChsaXF1aWRJc0Fic29sdXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lLnB1c2goJ2ZjLXNjcm9sbGVyLWxpcXVpZC1hYnNvbHV0ZScpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lLnB1c2goJ2ZjLXNjcm9sbGVyLWxpcXVpZCcpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiAoeShcImRpdlwiLCB7IHJlZjogdGhpcy5oYW5kbGVFbCwgY2xhc3NOYW1lOiBjbGFzc05hbWUuam9pbignICcpLCBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgICAgIG92ZXJmbG93WDogcHJvcHMub3ZlcmZsb3dYLFxyXG4gICAgICAgICAgICAgICAgICAgIG92ZXJmbG93WTogcHJvcHMub3ZlcmZsb3dZLFxyXG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6IChpc0Fic29sdXRlICYmIC0ocHJvcHMub3ZlcmNvbWVMZWZ0IHx8IDApKSB8fCAnJyxcclxuICAgICAgICAgICAgICAgICAgICByaWdodDogKGlzQWJzb2x1dGUgJiYgLShwcm9wcy5vdmVyY29tZVJpZ2h0IHx8IDApKSB8fCAnJyxcclxuICAgICAgICAgICAgICAgICAgICBib3R0b206IChpc0Fic29sdXRlICYmIC0ocHJvcHMub3ZlcmNvbWVCb3R0b20gfHwgMCkpIHx8ICcnLFxyXG4gICAgICAgICAgICAgICAgICAgIG1hcmdpbkxlZnQ6ICghaXNBYnNvbHV0ZSAmJiAtKHByb3BzLm92ZXJjb21lTGVmdCB8fCAwKSkgfHwgJycsXHJcbiAgICAgICAgICAgICAgICAgICAgbWFyZ2luUmlnaHQ6ICghaXNBYnNvbHV0ZSAmJiAtKHByb3BzLm92ZXJjb21lUmlnaHQgfHwgMCkpIHx8ICcnLFxyXG4gICAgICAgICAgICAgICAgICAgIG1hcmdpbkJvdHRvbTogKCFpc0Fic29sdXRlICYmIC0ocHJvcHMub3ZlcmNvbWVCb3R0b20gfHwgMCkpIHx8ICcnLFxyXG4gICAgICAgICAgICAgICAgICAgIG1heEhlaWdodDogcHJvcHMubWF4SGVpZ2h0IHx8ICcnLFxyXG4gICAgICAgICAgICAgICAgfSB9LCBwcm9wcy5jaGlsZHJlbikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBuZWVkc1hTY3JvbGxpbmcoKSB7XHJcbiAgICAgICAgICAgIGlmIChWSVNJQkxFX0hJRERFTl9SRS50ZXN0KHRoaXMucHJvcHMub3ZlcmZsb3dYKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHRlc3Rpbmcgc2Nyb2xsV2lkdGg+Y2xpZW50V2lkdGggaXMgdW5yZWxpYWJsZSBjcm9zcy1icm93c2VyIHdoZW4gcGl4ZWwgaGVpZ2h0cyBhcmVuJ3QgaW50ZWdlcnMuXHJcbiAgICAgICAgICAgIC8vIG11Y2ggbW9yZSByZWxpYWJsZSB0byBzZWUgaWYgY2hpbGRyZW4gYXJlIHRhbGxlciB0aGFuIHRoZSBzY3JvbGxlciwgZXZlbiB0aG8gZG9lc24ndCBhY2NvdW50IGZvclxyXG4gICAgICAgICAgICAvLyBpbm5lci1jaGlsZCBtYXJnaW5zIGFuZCBhYnNvbHV0ZSBwb3NpdGlvbmluZ1xyXG4gICAgICAgICAgICBsZXQgeyBlbCB9ID0gdGhpcztcclxuICAgICAgICAgICAgbGV0IHJlYWxDbGllbnRXaWR0aCA9IHRoaXMuZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggLSB0aGlzLmdldFlTY3JvbGxiYXJXaWR0aCgpO1xyXG4gICAgICAgICAgICBsZXQgeyBjaGlsZHJlbiB9ID0gZWw7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpICs9IDEpIHtcclxuICAgICAgICAgICAgICAgIGxldCBjaGlsZEVsID0gY2hpbGRyZW5baV07XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGRFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCA+IHJlYWxDbGllbnRXaWR0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbmVlZHNZU2Nyb2xsaW5nKCkge1xyXG4gICAgICAgICAgICBpZiAoVklTSUJMRV9ISURERU5fUkUudGVzdCh0aGlzLnByb3BzLm92ZXJmbG93WSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyB0ZXN0aW5nIHNjcm9sbEhlaWdodD5jbGllbnRIZWlnaHQgaXMgdW5yZWxpYWJsZSBjcm9zcy1icm93c2VyIHdoZW4gcGl4ZWwgaGVpZ2h0cyBhcmVuJ3QgaW50ZWdlcnMuXHJcbiAgICAgICAgICAgIC8vIG11Y2ggbW9yZSByZWxpYWJsZSB0byBzZWUgaWYgY2hpbGRyZW4gYXJlIHRhbGxlciB0aGFuIHRoZSBzY3JvbGxlciwgZXZlbiB0aG8gZG9lc24ndCBhY2NvdW50IGZvclxyXG4gICAgICAgICAgICAvLyBpbm5lci1jaGlsZCBtYXJnaW5zIGFuZCBhYnNvbHV0ZSBwb3NpdGlvbmluZ1xyXG4gICAgICAgICAgICBsZXQgeyBlbCB9ID0gdGhpcztcclxuICAgICAgICAgICAgbGV0IHJlYWxDbGllbnRIZWlnaHQgPSB0aGlzLmVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodCAtIHRoaXMuZ2V0WFNjcm9sbGJhcldpZHRoKCk7XHJcbiAgICAgICAgICAgIGxldCB7IGNoaWxkcmVuIH0gPSBlbDtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkgKz0gMSkge1xyXG4gICAgICAgICAgICAgICAgbGV0IGNoaWxkRWwgPSBjaGlsZHJlbltpXTtcclxuICAgICAgICAgICAgICAgIGlmIChjaGlsZEVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodCA+IHJlYWxDbGllbnRIZWlnaHQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGdldFhTY3JvbGxiYXJXaWR0aCgpIHtcclxuICAgICAgICAgICAgaWYgKFZJU0lCTEVfSElEREVOX1JFLnRlc3QodGhpcy5wcm9wcy5vdmVyZmxvd1gpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbC5vZmZzZXRIZWlnaHQgLSB0aGlzLmVsLmNsaWVudEhlaWdodDsgLy8gb25seSB3b3JrcyBiZWNhdXNlIHdlIGd1YXJhbnRlZSBubyBib3JkZXJzLiBUT0RPOiBhZGQgdG8gQ1NTIHdpdGggaW1wb3J0YW50P1xyXG4gICAgICAgIH1cclxuICAgICAgICBnZXRZU2Nyb2xsYmFyV2lkdGgoKSB7XHJcbiAgICAgICAgICAgIGlmIChWSVNJQkxFX0hJRERFTl9SRS50ZXN0KHRoaXMucHJvcHMub3ZlcmZsb3dZKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWwub2Zmc2V0V2lkdGggLSB0aGlzLmVsLmNsaWVudFdpZHRoOyAvLyBvbmx5IHdvcmtzIGJlY2F1c2Ugd2UgZ3VhcmFudGVlIG5vIGJvcmRlcnMuIFRPRE86IGFkZCB0byBDU1Mgd2l0aCBpbXBvcnRhbnQ/XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qXHJcbiAgICBUT0RPOiBzb21laG93IGluZmVyIE90aGVyQXJncyBmcm9tIG1hc3RlckNhbGxiYWNrP1xyXG4gICAgVE9ETzogaW5mZXIgUmVmVHlwZSBmcm9tIG1hc3RlckNhbGxiYWNrIGlmIHByb3ZpZGVkXHJcbiAgICAqL1xyXG4gICAgY2xhc3MgUmVmTWFwIHtcclxuICAgICAgICBjb25zdHJ1Y3RvcihtYXN0ZXJDYWxsYmFjaykge1xyXG4gICAgICAgICAgICB0aGlzLm1hc3RlckNhbGxiYWNrID0gbWFzdGVyQ2FsbGJhY2s7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudE1hcCA9IHt9O1xyXG4gICAgICAgICAgICB0aGlzLmRlcHRocyA9IHt9O1xyXG4gICAgICAgICAgICB0aGlzLmNhbGxiYWNrTWFwID0ge307XHJcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlVmFsdWUgPSAodmFsLCBrZXkpID0+IHtcclxuICAgICAgICAgICAgICAgIGxldCB7IGRlcHRocywgY3VycmVudE1hcCB9ID0gdGhpcztcclxuICAgICAgICAgICAgICAgIGxldCByZW1vdmVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBsZXQgYWRkZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGlmICh2YWwgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBmb3IgYnVnLi4uIEFDVFVBTExZOiBjYW4gcHJvYmFibHkgZG8gYXdheSB3aXRoIHRoaXMgbm93IHRoYXQgY2FsbGVycyBkb24ndCBzaGFyZSBudW1lcmljIGluZGljZXMgYW55bW9yZVxyXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZWQgPSAoa2V5IGluIGN1cnJlbnRNYXApO1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRNYXBba2V5XSA9IHZhbDtcclxuICAgICAgICAgICAgICAgICAgICBkZXB0aHNba2V5XSA9IChkZXB0aHNba2V5XSB8fCAwKSArIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgYWRkZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVwdGhzW2tleV0gLT0gMTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWRlcHRoc1trZXldKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBjdXJyZW50TWFwW2tleV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmNhbGxiYWNrTWFwW2tleV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm1hc3RlckNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlbW92ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXN0ZXJDYWxsYmFjayhudWxsLCBTdHJpbmcoa2V5KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhZGRlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1hc3RlckNhbGxiYWNrKHZhbCwgU3RyaW5nKGtleSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY3JlYXRlUmVmKGtleSkge1xyXG4gICAgICAgICAgICBsZXQgcmVmQ2FsbGJhY2sgPSB0aGlzLmNhbGxiYWNrTWFwW2tleV07XHJcbiAgICAgICAgICAgIGlmICghcmVmQ2FsbGJhY2spIHtcclxuICAgICAgICAgICAgICAgIHJlZkNhbGxiYWNrID0gdGhpcy5jYWxsYmFja01hcFtrZXldID0gKHZhbCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlVmFsdWUodmFsLCBTdHJpbmcoa2V5KSk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZWZDYWxsYmFjaztcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVE9ETzogY2hlY2sgY2FsbGVycyB0aGF0IGRvbid0IGNhcmUgYWJvdXQgb3JkZXIuIHNob3VsZCB1c2UgZ2V0QWxsIGluc3RlYWRcclxuICAgICAgICAvLyBOT1RFOiB0aGlzIG1ldGhvZCBoYXMgYmVjb21lIGxlc3MgdmFsdWFibGUgbm93IHRoYXQgd2UgYXJlIGVuY291cmFnZWQgdG8gbWFwIG9yZGVyIGJ5IHNvbWUgb3RoZXIgaW5kZXhcclxuICAgICAgICAvLyBUT0RPOiBwcm92aWRlIE9ORSBhcnJheS1leHBvcnQgZnVuY3Rpb24sIGJ1aWxkQXJyYXksIHdoaWNoIGZhaWxzIG9uIG5vbi1udW1lcmljIGluZGV4ZXMuIGNhbGxlciBjYW4gbWFuaXB1bGF0ZSBhbmQgXCJjb2xsZWN0XCJcclxuICAgICAgICBjb2xsZWN0KHN0YXJ0SW5kZXgsIGVuZEluZGV4LCBzdGVwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjb2xsZWN0RnJvbUhhc2godGhpcy5jdXJyZW50TWFwLCBzdGFydEluZGV4LCBlbmRJbmRleCwgc3RlcCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGdldEFsbCgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGhhc2hWYWx1ZXNUb0FycmF5KHRoaXMuY3VycmVudE1hcCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNvbXB1dGVTaHJpbmtXaWR0aChjaHVua0Vscykge1xyXG4gICAgICAgIGxldCBzaHJpbmtDZWxscyA9IGZpbmRFbGVtZW50cyhjaHVua0VscywgJy5mYy1zY3JvbGxncmlkLXNocmluaycpO1xyXG4gICAgICAgIGxldCBsYXJnZXN0V2lkdGggPSAwO1xyXG4gICAgICAgIGZvciAobGV0IHNocmlua0NlbGwgb2Ygc2hyaW5rQ2VsbHMpIHtcclxuICAgICAgICAgICAgbGFyZ2VzdFdpZHRoID0gTWF0aC5tYXgobGFyZ2VzdFdpZHRoLCBjb21wdXRlU21hbGxlc3RDZWxsV2lkdGgoc2hyaW5rQ2VsbCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gTWF0aC5jZWlsKGxhcmdlc3RXaWR0aCk7IC8vIDx0YWJsZT4gZWxlbWVudHMgd29yayBiZXN0IHdpdGggaW50ZWdlcnMuIHJvdW5kIHVwIHRvIGVuc3VyZSBjb250ZW50cyBmaXRzXHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBnZXRTZWN0aW9uSGFzTGlxdWlkSGVpZ2h0KHByb3BzLCBzZWN0aW9uQ29uZmlnKSB7XHJcbiAgICAgICAgcmV0dXJuIHByb3BzLmxpcXVpZCAmJiBzZWN0aW9uQ29uZmlnLmxpcXVpZDsgLy8gZG9lcyB0aGUgc2VjdGlvbiBkbyBsaXF1aWQtaGVpZ2h0PyAobmVlZCB0byBoYXZlIHdob2xlIHNjcm9sbGdyaWQgbGlxdWlkLWhlaWdodCBhcyB3ZWxsKVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZ2V0QWxsb3dZU2Nyb2xsaW5nKHByb3BzLCBzZWN0aW9uQ29uZmlnKSB7XHJcbiAgICAgICAgcmV0dXJuIHNlY3Rpb25Db25maWcubWF4SGVpZ2h0ICE9IG51bGwgfHwgLy8gaWYgaXRzIHBvc3NpYmxlIGZvciB0aGUgaGVpZ2h0IHRvIG1heCBvdXQsIHdlIG1pZ2h0IG5lZWQgc2Nyb2xsYmFyc1xyXG4gICAgICAgICAgICBnZXRTZWN0aW9uSGFzTGlxdWlkSGVpZ2h0KHByb3BzLCBzZWN0aW9uQ29uZmlnKTsgLy8gaWYgdGhlIHNlY3Rpb24gaXMgbGlxdWlkIGhlaWdodCwgaXQgbWlnaHQgY29uZGVuc2UgZW5vdWdoIHRvIHJlcXVpcmUgc2Nyb2xsYmFyc1xyXG4gICAgfVxyXG4gICAgLy8gVE9ETzogT05MWSB1c2UgYGFyZ2AuIGZvcmNlIG91dCBpbnRlcm5hbCBmdW5jdGlvbiB0byB1c2Ugc2FtZSBBUElcclxuICAgIGZ1bmN0aW9uIHJlbmRlckNodW5rQ29udGVudChzZWN0aW9uQ29uZmlnLCBjaHVua0NvbmZpZywgYXJnLCBpc0hlYWRlcikge1xyXG4gICAgICAgIGxldCB7IGV4cGFuZFJvd3MgfSA9IGFyZztcclxuICAgICAgICBsZXQgY29udGVudCA9IHR5cGVvZiBjaHVua0NvbmZpZy5jb250ZW50ID09PSAnZnVuY3Rpb24nID9cclxuICAgICAgICAgICAgY2h1bmtDb25maWcuY29udGVudChhcmcpIDpcclxuICAgICAgICAgICAgeSgndGFibGUnLCB7XHJcbiAgICAgICAgICAgICAgICByb2xlOiAncHJlc2VudGF0aW9uJyxcclxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogW1xyXG4gICAgICAgICAgICAgICAgICAgIGNodW5rQ29uZmlnLnRhYmxlQ2xhc3NOYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgIHNlY3Rpb25Db25maWcuc3luY1Jvd0hlaWdodHMgPyAnZmMtc2Nyb2xsZ3JpZC1zeW5jLXRhYmxlJyA6ICcnLFxyXG4gICAgICAgICAgICAgICAgXS5qb2luKCcgJyksXHJcbiAgICAgICAgICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgICAgIG1pbldpZHRoOiBhcmcudGFibGVNaW5XaWR0aCxcclxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogYXJnLmNsaWVudFdpZHRoLFxyXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogZXhwYW5kUm93cyA/IGFyZy5jbGllbnRIZWlnaHQgOiAnJywgLy8gY3NzIGBoZWlnaHRgIG9uIGEgPHRhYmxlPiBzZXJ2ZXMgYXMgYSBtaW4taGVpZ2h0XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB9LCBhcmcudGFibGVDb2xHcm91cE5vZGUsIHkoaXNIZWFkZXIgPyAndGhlYWQnIDogJ3Rib2R5Jywge1xyXG4gICAgICAgICAgICAgICAgcm9sZTogJ3ByZXNlbnRhdGlvbicsXHJcbiAgICAgICAgICAgIH0sIHR5cGVvZiBjaHVua0NvbmZpZy5yb3dDb250ZW50ID09PSAnZnVuY3Rpb24nXHJcbiAgICAgICAgICAgICAgICA/IGNodW5rQ29uZmlnLnJvd0NvbnRlbnQoYXJnKVxyXG4gICAgICAgICAgICAgICAgOiBjaHVua0NvbmZpZy5yb3dDb250ZW50KSk7XHJcbiAgICAgICAgcmV0dXJuIGNvbnRlbnQ7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBpc0NvbFByb3BzRXF1YWwoY29sczAsIGNvbHMxKSB7XHJcbiAgICAgICAgcmV0dXJuIGlzQXJyYXlzRXF1YWwoY29sczAsIGNvbHMxLCBpc1Byb3BzRXF1YWwpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gcmVuZGVyTWljcm9Db2xHcm91cChjb2xzLCBzaHJpbmtXaWR0aCkge1xyXG4gICAgICAgIGxldCBjb2xOb2RlcyA9IFtdO1xyXG4gICAgICAgIC8qXHJcbiAgICAgICAgZm9yIENvbFByb3BzIHdpdGggc3BhbnMsIGl0IHdvdWxkIGhhdmUgYmVlbiBncmVhdCB0byBtYWtlIGEgc2luZ2xlIDxjb2wgc3Bhbj1cIlwiPlxyXG4gICAgICAgIEhPV0VWRVIsIENocm9tZSB3YXMgZ2V0dGluZyBtZXNzaW5nIHVwIGRpc3RyaWJ1dGluZyB0aGUgd2lkdGggdG8gPHRkPi88dGg+IGVsZW1lbnRzIHdpdGggY29sc3BhbnMuXHJcbiAgICAgICAgU09MVVRJT046IG1ha2luZyBpbmRpdmlkdWFsIDxjb2w+IGVsZW1lbnRzIG1ha2VzIENocm9tZSBiZWhhdmUuXHJcbiAgICAgICAgKi9cclxuICAgICAgICBmb3IgKGxldCBjb2xQcm9wcyBvZiBjb2xzKSB7XHJcbiAgICAgICAgICAgIGxldCBzcGFuID0gY29sUHJvcHMuc3BhbiB8fCAxO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNwYW47IGkgKz0gMSkge1xyXG4gICAgICAgICAgICAgICAgY29sTm9kZXMucHVzaCh5KFwiY29sXCIsIHsgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IGNvbFByb3BzLndpZHRoID09PSAnc2hyaW5rJyA/IHNhbml0aXplU2hyaW5rV2lkdGgoc2hyaW5rV2lkdGgpIDogKGNvbFByb3BzLndpZHRoIHx8ICcnKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWluV2lkdGg6IGNvbFByb3BzLm1pbldpZHRoIHx8ICcnLFxyXG4gICAgICAgICAgICAgICAgICAgIH0gfSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB5KCdjb2xncm91cCcsIHt9LCAuLi5jb2xOb2Rlcyk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBzYW5pdGl6ZVNocmlua1dpZHRoKHNocmlua1dpZHRoKSB7XHJcbiAgICAgICAgLyogd2h5IDQ/IGlmIHdlIGRvIDAsIGl0IHdpbGwga2lsbCBhbnkgYm9yZGVyLCB3aGljaCBhcmUgbmVlZGVkIGZvciBjb21wdXRlU21hbGxlc3RDZWxsV2lkdGhcclxuICAgICAgICA0IGFjY291bnRzIGZvciAyIDItcGl4ZWwgYm9yZGVycy4gVE9ETzogYmV0dGVyIHNvbHV0aW9uPyAqL1xyXG4gICAgICAgIHJldHVybiBzaHJpbmtXaWR0aCA9PSBudWxsID8gNCA6IHNocmlua1dpZHRoO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gaGFzU2hyaW5rV2lkdGgoY29scykge1xyXG4gICAgICAgIGZvciAobGV0IGNvbCBvZiBjb2xzKSB7XHJcbiAgICAgICAgICAgIGlmIChjb2wud2lkdGggPT09ICdzaHJpbmsnKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBnZXRTY3JvbGxHcmlkQ2xhc3NOYW1lcyhsaXF1aWQsIGNvbnRleHQpIHtcclxuICAgICAgICBsZXQgY2xhc3NOYW1lcyA9IFtcclxuICAgICAgICAgICAgJ2ZjLXNjcm9sbGdyaWQnLFxyXG4gICAgICAgICAgICBjb250ZXh0LnRoZW1lLmdldENsYXNzKCd0YWJsZScpLFxyXG4gICAgICAgIF07XHJcbiAgICAgICAgaWYgKGxpcXVpZCkge1xyXG4gICAgICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLXNjcm9sbGdyaWQtbGlxdWlkJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjbGFzc05hbWVzO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZ2V0U2VjdGlvbkNsYXNzTmFtZXMoc2VjdGlvbkNvbmZpZywgd2hvbGVUYWJsZVZHcm93KSB7XHJcbiAgICAgICAgbGV0IGNsYXNzTmFtZXMgPSBbXHJcbiAgICAgICAgICAgICdmYy1zY3JvbGxncmlkLXNlY3Rpb24nLFxyXG4gICAgICAgICAgICBgZmMtc2Nyb2xsZ3JpZC1zZWN0aW9uLSR7c2VjdGlvbkNvbmZpZy50eXBlfWAsXHJcbiAgICAgICAgICAgIHNlY3Rpb25Db25maWcuY2xhc3NOYW1lLCAvLyB1c2VkP1xyXG4gICAgICAgIF07XHJcbiAgICAgICAgaWYgKHdob2xlVGFibGVWR3JvdyAmJiBzZWN0aW9uQ29uZmlnLmxpcXVpZCAmJiBzZWN0aW9uQ29uZmlnLm1heEhlaWdodCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtc2Nyb2xsZ3JpZC1zZWN0aW9uLWxpcXVpZCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc2VjdGlvbkNvbmZpZy5pc1N0aWNreSkge1xyXG4gICAgICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLXNjcm9sbGdyaWQtc2VjdGlvbi1zdGlja3knKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNsYXNzTmFtZXM7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiByZW5kZXJTY3JvbGxTaGltKGFyZykge1xyXG4gICAgICAgIHJldHVybiAoeShcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy1zY3JvbGxncmlkLXN0aWNreS1zaGltXCIsIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICB3aWR0aDogYXJnLmNsaWVudFdpZHRoLFxyXG4gICAgICAgICAgICAgICAgbWluV2lkdGg6IGFyZy50YWJsZU1pbldpZHRoLFxyXG4gICAgICAgICAgICB9IH0pKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGdldFN0aWNreUhlYWRlckRhdGVzKG9wdGlvbnMpIHtcclxuICAgICAgICBsZXQgeyBzdGlja3lIZWFkZXJEYXRlcyB9ID0gb3B0aW9ucztcclxuICAgICAgICBpZiAoc3RpY2t5SGVhZGVyRGF0ZXMgPT0gbnVsbCB8fCBzdGlja3lIZWFkZXJEYXRlcyA9PT0gJ2F1dG8nKSB7XHJcbiAgICAgICAgICAgIHN0aWNreUhlYWRlckRhdGVzID0gb3B0aW9ucy5oZWlnaHQgPT09ICdhdXRvJyB8fCBvcHRpb25zLnZpZXdIZWlnaHQgPT09ICdhdXRvJztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHN0aWNreUhlYWRlckRhdGVzO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZ2V0U3RpY2t5Rm9vdGVyU2Nyb2xsYmFyKG9wdGlvbnMpIHtcclxuICAgICAgICBsZXQgeyBzdGlja3lGb290ZXJTY3JvbGxiYXIgfSA9IG9wdGlvbnM7XHJcbiAgICAgICAgaWYgKHN0aWNreUZvb3RlclNjcm9sbGJhciA9PSBudWxsIHx8IHN0aWNreUZvb3RlclNjcm9sbGJhciA9PT0gJ2F1dG8nKSB7XHJcbiAgICAgICAgICAgIHN0aWNreUZvb3RlclNjcm9sbGJhciA9IG9wdGlvbnMuaGVpZ2h0ID09PSAnYXV0bycgfHwgb3B0aW9ucy52aWV3SGVpZ2h0ID09PSAnYXV0byc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzdGlja3lGb290ZXJTY3JvbGxiYXI7XHJcbiAgICB9XHJcblxyXG4gICAgY2xhc3MgU2ltcGxlU2Nyb2xsR3JpZCBleHRlbmRzIEJhc2VDb21wb25lbnQge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NDb2xzID0gbWVtb2l6ZSgoYSkgPT4gYSwgaXNDb2xQcm9wc0VxdWFsKTsgLy8gc28gd2UgZ2V0IHNhbWUgYGNvbHNgIHByb3BzIGV2ZXJ5IHRpbWVcclxuICAgICAgICAgICAgLy8geXVja3kgdG8gbWVtb2l6ZSBWTm9kZXMsIGJ1dCBtdWNoIG1vcmUgZWZmaWNpZW50IGZvciBjb25zdW1lcnNcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJNaWNyb0NvbEdyb3VwID0gbWVtb2l6ZShyZW5kZXJNaWNyb0NvbEdyb3VwKTtcclxuICAgICAgICAgICAgdGhpcy5zY3JvbGxlclJlZnMgPSBuZXcgUmVmTWFwKCk7XHJcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsZXJFbFJlZnMgPSBuZXcgUmVmTWFwKHRoaXMuX2hhbmRsZVNjcm9sbGVyRWwuYmluZCh0aGlzKSk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSB7XHJcbiAgICAgICAgICAgICAgICBzaHJpbmtXaWR0aDogbnVsbCxcclxuICAgICAgICAgICAgICAgIGZvcmNlWVNjcm9sbGJhcnM6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgc2Nyb2xsZXJDbGllbnRXaWR0aHM6IHt9LFxyXG4gICAgICAgICAgICAgICAgc2Nyb2xsZXJDbGllbnRIZWlnaHRzOiB7fSxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLy8gVE9ETzogY2FuIGRvIGEgcmVhbGx5IHNpbXBsZSBwcmludC12aWV3LiBkb250IG5lZWQgdG8gam9pbiByb3dzXHJcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlU2l6aW5nID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zYWZlU2V0U3RhdGUoT2JqZWN0LmFzc2lnbih7IHNocmlua1dpZHRoOiB0aGlzLmNvbXB1dGVTaHJpbmtXaWR0aCgpIH0sIHRoaXMuY29tcHV0ZVNjcm9sbGVyRGltcygpKSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlbmRlcigpIHtcclxuICAgICAgICAgICAgbGV0IHsgcHJvcHMsIHN0YXRlLCBjb250ZXh0IH0gPSB0aGlzO1xyXG4gICAgICAgICAgICBsZXQgc2VjdGlvbkNvbmZpZ3MgPSBwcm9wcy5zZWN0aW9ucyB8fCBbXTtcclxuICAgICAgICAgICAgbGV0IGNvbHMgPSB0aGlzLnByb2Nlc3NDb2xzKHByb3BzLmNvbHMpO1xyXG4gICAgICAgICAgICBsZXQgbWljcm9Db2xHcm91cE5vZGUgPSB0aGlzLnJlbmRlck1pY3JvQ29sR3JvdXAoY29scywgc3RhdGUuc2hyaW5rV2lkdGgpO1xyXG4gICAgICAgICAgICBsZXQgY2xhc3NOYW1lcyA9IGdldFNjcm9sbEdyaWRDbGFzc05hbWVzKHByb3BzLmxpcXVpZCwgY29udGV4dCk7XHJcbiAgICAgICAgICAgIGlmIChwcm9wcy5jb2xsYXBzaWJsZVdpZHRoKSB7XHJcbiAgICAgICAgICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLXNjcm9sbGdyaWQtY29sbGFwc2libGUnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBUT0RPOiBtYWtlIERSWVxyXG4gICAgICAgICAgICBsZXQgY29uZmlnQ250ID0gc2VjdGlvbkNvbmZpZ3MubGVuZ3RoO1xyXG4gICAgICAgICAgICBsZXQgY29uZmlnSSA9IDA7XHJcbiAgICAgICAgICAgIGxldCBjdXJyZW50Q29uZmlnO1xyXG4gICAgICAgICAgICBsZXQgaGVhZFNlY3Rpb25Ob2RlcyA9IFtdO1xyXG4gICAgICAgICAgICBsZXQgYm9keVNlY3Rpb25Ob2RlcyA9IFtdO1xyXG4gICAgICAgICAgICBsZXQgZm9vdFNlY3Rpb25Ob2RlcyA9IFtdO1xyXG4gICAgICAgICAgICB3aGlsZSAoY29uZmlnSSA8IGNvbmZpZ0NudCAmJiAoY3VycmVudENvbmZpZyA9IHNlY3Rpb25Db25maWdzW2NvbmZpZ0ldKS50eXBlID09PSAnaGVhZGVyJykge1xyXG4gICAgICAgICAgICAgICAgaGVhZFNlY3Rpb25Ob2Rlcy5wdXNoKHRoaXMucmVuZGVyU2VjdGlvbihjdXJyZW50Q29uZmlnLCBtaWNyb0NvbEdyb3VwTm9kZSwgdHJ1ZSkpO1xyXG4gICAgICAgICAgICAgICAgY29uZmlnSSArPSAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHdoaWxlIChjb25maWdJIDwgY29uZmlnQ250ICYmIChjdXJyZW50Q29uZmlnID0gc2VjdGlvbkNvbmZpZ3NbY29uZmlnSV0pLnR5cGUgPT09ICdib2R5Jykge1xyXG4gICAgICAgICAgICAgICAgYm9keVNlY3Rpb25Ob2Rlcy5wdXNoKHRoaXMucmVuZGVyU2VjdGlvbihjdXJyZW50Q29uZmlnLCBtaWNyb0NvbEdyb3VwTm9kZSwgZmFsc2UpKTtcclxuICAgICAgICAgICAgICAgIGNvbmZpZ0kgKz0gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB3aGlsZSAoY29uZmlnSSA8IGNvbmZpZ0NudCAmJiAoY3VycmVudENvbmZpZyA9IHNlY3Rpb25Db25maWdzW2NvbmZpZ0ldKS50eXBlID09PSAnZm9vdGVyJykge1xyXG4gICAgICAgICAgICAgICAgZm9vdFNlY3Rpb25Ob2Rlcy5wdXNoKHRoaXMucmVuZGVyU2VjdGlvbihjdXJyZW50Q29uZmlnLCBtaWNyb0NvbEdyb3VwTm9kZSwgdHJ1ZSkpO1xyXG4gICAgICAgICAgICAgICAgY29uZmlnSSArPSAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGZpcmVmb3ggYnVnOiB3aGVuIHNldHRpbmcgaGVpZ2h0IG9uIHRhYmxlIGFuZCB0aGVyZSBpcyBhIHRoZWFkIG9yIHRmb290LFxyXG4gICAgICAgICAgICAvLyB0aGUgbmVjZXNzYXJ5IGhlaWdodDoxMDAlIG9uIHRoZSBsaXF1aWQtaGVpZ2h0IGJvZHkgc2VjdGlvbiBmb3JjZXMgdGhlICp3aG9sZSogdGFibGUgdG8gYmUgdGFsbGVyLiAoYnVnICM1NTI0KVxyXG4gICAgICAgICAgICAvLyB1c2UgZ2V0Q2FuVkdyb3dXaXRoaW5DZWxsIGFzIGEgd2F5IHRvIGRldGVjdCB0YWJsZS1zdHVwaWQgZmlyZWZveC5cclxuICAgICAgICAgICAgLy8gaWYgc28sIHVzZSBhIHNpbXBsZXIgZG9tIHN0cnVjdHVyZSwgamFtIGV2ZXJ5dGhpbmcgaW50byBhIGxvbmUgdGJvZHkuXHJcbiAgICAgICAgICAgIGxldCBpc0J1Z2d5ID0gIWdldENhblZHcm93V2l0aGluQ2VsbCgpO1xyXG4gICAgICAgICAgICBjb25zdCByb2xlQXR0cnMgPSB7IHJvbGU6ICdyb3dncm91cCcgfTtcclxuICAgICAgICAgICAgcmV0dXJuIHkoJ3RhYmxlJywge1xyXG4gICAgICAgICAgICAgICAgcm9sZTogJ2dyaWQnLFxyXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWVzLmpvaW4oJyAnKSxcclxuICAgICAgICAgICAgICAgIHN0eWxlOiB7IGhlaWdodDogcHJvcHMuaGVpZ2h0IH0sXHJcbiAgICAgICAgICAgIH0sIEJvb2xlYW4oIWlzQnVnZ3kgJiYgaGVhZFNlY3Rpb25Ob2Rlcy5sZW5ndGgpICYmIHkoJ3RoZWFkJywgcm9sZUF0dHJzLCAuLi5oZWFkU2VjdGlvbk5vZGVzKSwgQm9vbGVhbighaXNCdWdneSAmJiBib2R5U2VjdGlvbk5vZGVzLmxlbmd0aCkgJiYgeSgndGJvZHknLCByb2xlQXR0cnMsIC4uLmJvZHlTZWN0aW9uTm9kZXMpLCBCb29sZWFuKCFpc0J1Z2d5ICYmIGZvb3RTZWN0aW9uTm9kZXMubGVuZ3RoKSAmJiB5KCd0Zm9vdCcsIHJvbGVBdHRycywgLi4uZm9vdFNlY3Rpb25Ob2RlcyksIGlzQnVnZ3kgJiYgeSgndGJvZHknLCByb2xlQXR0cnMsIC4uLmhlYWRTZWN0aW9uTm9kZXMsIC4uLmJvZHlTZWN0aW9uTm9kZXMsIC4uLmZvb3RTZWN0aW9uTm9kZXMpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVuZGVyU2VjdGlvbihzZWN0aW9uQ29uZmlnLCBtaWNyb0NvbEdyb3VwTm9kZSwgaXNIZWFkZXIpIHtcclxuICAgICAgICAgICAgaWYgKCdvdXRlckNvbnRlbnQnIGluIHNlY3Rpb25Db25maWcpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAoeShfLCB7IGtleTogc2VjdGlvbkNvbmZpZy5rZXkgfSwgc2VjdGlvbkNvbmZpZy5vdXRlckNvbnRlbnQpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gKHkoXCJ0clwiLCB7IGtleTogc2VjdGlvbkNvbmZpZy5rZXksIHJvbGU6IFwicHJlc2VudGF0aW9uXCIsIGNsYXNzTmFtZTogZ2V0U2VjdGlvbkNsYXNzTmFtZXMoc2VjdGlvbkNvbmZpZywgdGhpcy5wcm9wcy5saXF1aWQpLmpvaW4oJyAnKSB9LCB0aGlzLnJlbmRlckNodW5rVGQoc2VjdGlvbkNvbmZpZywgbWljcm9Db2xHcm91cE5vZGUsIHNlY3Rpb25Db25maWcuY2h1bmssIGlzSGVhZGVyKSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZW5kZXJDaHVua1RkKHNlY3Rpb25Db25maWcsIG1pY3JvQ29sR3JvdXBOb2RlLCBjaHVua0NvbmZpZywgaXNIZWFkZXIpIHtcclxuICAgICAgICAgICAgaWYgKCdvdXRlckNvbnRlbnQnIGluIGNodW5rQ29uZmlnKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2h1bmtDb25maWcub3V0ZXJDb250ZW50O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxldCB7IHByb3BzIH0gPSB0aGlzO1xyXG4gICAgICAgICAgICBsZXQgeyBmb3JjZVlTY3JvbGxiYXJzLCBzY3JvbGxlckNsaWVudFdpZHRocywgc2Nyb2xsZXJDbGllbnRIZWlnaHRzIH0gPSB0aGlzLnN0YXRlO1xyXG4gICAgICAgICAgICBsZXQgbmVlZHNZU2Nyb2xsaW5nID0gZ2V0QWxsb3dZU2Nyb2xsaW5nKHByb3BzLCBzZWN0aW9uQ29uZmlnKTsgLy8gVE9ETzogZG8gbGF6aWx5LiBkbyBpbiBzZWN0aW9uIGNvbmZpZz9cclxuICAgICAgICAgICAgbGV0IGlzTGlxdWlkID0gZ2V0U2VjdGlvbkhhc0xpcXVpZEhlaWdodChwcm9wcywgc2VjdGlvbkNvbmZpZyk7XHJcbiAgICAgICAgICAgIC8vIGZvciBgIXByb3BzLmxpcXVpZGAgLSBpcyBXSE9MRSBzY3JvbGxncmlkIG5hdHVyYWwgaGVpZ2h0P1xyXG4gICAgICAgICAgICAvLyBUT0RPOiBkbyBzYW1lIHRoaW5nIGluIGFkdmFuY2VkIHNjcm9sbGdyaWQ/IHByb2xseSBub3QgYi9jIGFsd2F5cyBoYXMgaG9yaXpvbnRhbCBzY3JvbGxiYXJzXHJcbiAgICAgICAgICAgIGxldCBvdmVyZmxvd1kgPSAhcHJvcHMubGlxdWlkID8gJ3Zpc2libGUnIDpcclxuICAgICAgICAgICAgICAgIGZvcmNlWVNjcm9sbGJhcnMgPyAnc2Nyb2xsJyA6XHJcbiAgICAgICAgICAgICAgICAgICAgIW5lZWRzWVNjcm9sbGluZyA/ICdoaWRkZW4nIDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ2F1dG8nO1xyXG4gICAgICAgICAgICBsZXQgc2VjdGlvbktleSA9IHNlY3Rpb25Db25maWcua2V5O1xyXG4gICAgICAgICAgICBsZXQgY29udGVudCA9IHJlbmRlckNodW5rQ29udGVudChzZWN0aW9uQ29uZmlnLCBjaHVua0NvbmZpZywge1xyXG4gICAgICAgICAgICAgICAgdGFibGVDb2xHcm91cE5vZGU6IG1pY3JvQ29sR3JvdXBOb2RlLFxyXG4gICAgICAgICAgICAgICAgdGFibGVNaW5XaWR0aDogJycsXHJcbiAgICAgICAgICAgICAgICBjbGllbnRXaWR0aDogKCFwcm9wcy5jb2xsYXBzaWJsZVdpZHRoICYmIHNjcm9sbGVyQ2xpZW50V2lkdGhzW3NlY3Rpb25LZXldICE9PSB1bmRlZmluZWQpID8gc2Nyb2xsZXJDbGllbnRXaWR0aHNbc2VjdGlvbktleV0gOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgY2xpZW50SGVpZ2h0OiBzY3JvbGxlckNsaWVudEhlaWdodHNbc2VjdGlvbktleV0gIT09IHVuZGVmaW5lZCA/IHNjcm9sbGVyQ2xpZW50SGVpZ2h0c1tzZWN0aW9uS2V5XSA6IG51bGwsXHJcbiAgICAgICAgICAgICAgICBleHBhbmRSb3dzOiBzZWN0aW9uQ29uZmlnLmV4cGFuZFJvd3MsXHJcbiAgICAgICAgICAgICAgICBzeW5jUm93SGVpZ2h0czogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICByb3dTeW5jSGVpZ2h0czogW10sXHJcbiAgICAgICAgICAgICAgICByZXBvcnRSb3dIZWlnaHRDaGFuZ2U6ICgpID0+IHsgfSxcclxuICAgICAgICAgICAgfSwgaXNIZWFkZXIpO1xyXG4gICAgICAgICAgICByZXR1cm4geShpc0hlYWRlciA/ICd0aCcgOiAndGQnLCB7XHJcbiAgICAgICAgICAgICAgICByZWY6IGNodW5rQ29uZmlnLmVsUmVmLFxyXG4gICAgICAgICAgICAgICAgcm9sZTogJ3ByZXNlbnRhdGlvbicsXHJcbiAgICAgICAgICAgIH0sIHkoXCJkaXZcIiwgeyBjbGFzc05hbWU6IGBmYy1zY3JvbGxlci1oYXJuZXNzJHtpc0xpcXVpZCA/ICcgZmMtc2Nyb2xsZXItaGFybmVzcy1saXF1aWQnIDogJyd9YCB9LFxyXG4gICAgICAgICAgICAgICAgeShTY3JvbGxlciwgeyByZWY6IHRoaXMuc2Nyb2xsZXJSZWZzLmNyZWF0ZVJlZihzZWN0aW9uS2V5KSwgZWxSZWY6IHRoaXMuc2Nyb2xsZXJFbFJlZnMuY3JlYXRlUmVmKHNlY3Rpb25LZXkpLCBvdmVyZmxvd1k6IG92ZXJmbG93WSwgb3ZlcmZsb3dYOiAhcHJvcHMubGlxdWlkID8gJ3Zpc2libGUnIDogJ2hpZGRlbicgLyogbmF0dXJhbCBoZWlnaHQ/ICovLCBtYXhIZWlnaHQ6IHNlY3Rpb25Db25maWcubWF4SGVpZ2h0LCBsaXF1aWQ6IGlzTGlxdWlkLCBsaXF1aWRJc0Fic29sdXRlIC8vIGJlY2F1c2UgaXRzIHdpdGhpbiBhIGhhcm5lc3NcclxuICAgICAgICAgICAgICAgICAgICA6IHRydWUgfSwgY29udGVudCkpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgX2hhbmRsZVNjcm9sbGVyRWwoc2Nyb2xsZXJFbCwga2V5KSB7XHJcbiAgICAgICAgICAgIGxldCBzZWN0aW9uID0gZ2V0U2VjdGlvbkJ5S2V5KHRoaXMucHJvcHMuc2VjdGlvbnMsIGtleSk7XHJcbiAgICAgICAgICAgIGlmIChzZWN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICBzZXRSZWYoc2VjdGlvbi5jaHVuay5zY3JvbGxlckVsUmVmLCBzY3JvbGxlckVsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjb21wb25lbnREaWRNb3VudCgpIHtcclxuICAgICAgICAgICAgdGhpcy5oYW5kbGVTaXppbmcoKTtcclxuICAgICAgICAgICAgdGhpcy5jb250ZXh0LmFkZFJlc2l6ZUhhbmRsZXIodGhpcy5oYW5kbGVTaXppbmcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb21wb25lbnREaWRVcGRhdGUoKSB7XHJcbiAgICAgICAgICAgIC8vIFRPRE86IG5lZWQgYmV0dGVyIHNvbHV0aW9uIHdoZW4gc3RhdGUgY29udGFpbnMgbm9uLXNpemluZyB0aGluZ3NcclxuICAgICAgICAgICAgdGhpcy5oYW5kbGVTaXppbmcoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5yZW1vdmVSZXNpemVIYW5kbGVyKHRoaXMuaGFuZGxlU2l6aW5nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29tcHV0ZVNocmlua1dpZHRoKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gaGFzU2hyaW5rV2lkdGgodGhpcy5wcm9wcy5jb2xzKVxyXG4gICAgICAgICAgICAgICAgPyBjb21wdXRlU2hyaW5rV2lkdGgodGhpcy5zY3JvbGxlckVsUmVmcy5nZXRBbGwoKSlcclxuICAgICAgICAgICAgICAgIDogMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29tcHV0ZVNjcm9sbGVyRGltcygpIHtcclxuICAgICAgICAgICAgbGV0IHNjcm9sbGJhcldpZHRoID0gZ2V0U2Nyb2xsYmFyV2lkdGhzKCk7XHJcbiAgICAgICAgICAgIGxldCB7IHNjcm9sbGVyUmVmcywgc2Nyb2xsZXJFbFJlZnMgfSA9IHRoaXM7XHJcbiAgICAgICAgICAgIGxldCBmb3JjZVlTY3JvbGxiYXJzID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGxldCBzY3JvbGxlckNsaWVudFdpZHRocyA9IHt9O1xyXG4gICAgICAgICAgICBsZXQgc2Nyb2xsZXJDbGllbnRIZWlnaHRzID0ge307XHJcbiAgICAgICAgICAgIGZvciAobGV0IHNlY3Rpb25LZXkgaW4gc2Nyb2xsZXJSZWZzLmN1cnJlbnRNYXApIHtcclxuICAgICAgICAgICAgICAgIGxldCBzY3JvbGxlciA9IHNjcm9sbGVyUmVmcy5jdXJyZW50TWFwW3NlY3Rpb25LZXldO1xyXG4gICAgICAgICAgICAgICAgaWYgKHNjcm9sbGVyICYmIHNjcm9sbGVyLm5lZWRzWVNjcm9sbGluZygpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yY2VZU2Nyb2xsYmFycyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yIChsZXQgc2VjdGlvbiBvZiB0aGlzLnByb3BzLnNlY3Rpb25zKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgc2VjdGlvbktleSA9IHNlY3Rpb24ua2V5O1xyXG4gICAgICAgICAgICAgICAgbGV0IHNjcm9sbGVyRWwgPSBzY3JvbGxlckVsUmVmcy5jdXJyZW50TWFwW3NlY3Rpb25LZXldO1xyXG4gICAgICAgICAgICAgICAgaWYgKHNjcm9sbGVyRWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgaGFybmVzc0VsID0gc2Nyb2xsZXJFbC5wYXJlbnROb2RlOyAvLyBUT0RPOiB3ZWlyZCB3YXkgdG8gZ2V0IHRoaXMuIG5lZWQgaGFybmVzcyBiL2MgZG9lc24ndCBpbmNsdWRlIHRhYmxlIGJvcmRlcnNcclxuICAgICAgICAgICAgICAgICAgICBzY3JvbGxlckNsaWVudFdpZHRoc1tzZWN0aW9uS2V5XSA9IE1hdGguZmxvb3IoaGFybmVzc0VsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoIC0gKGZvcmNlWVNjcm9sbGJhcnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyBzY3JvbGxiYXJXaWR0aC55IC8vIHVzZSBnbG9iYWwgYmVjYXVzZSBzY3JvbGxlciBtaWdodCBub3QgaGF2ZSBzY3JvbGxiYXJzIHlldCBidXQgd2lsbCBuZWVkIHRoZW0gaW4gZnV0dXJlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogMCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNjcm9sbGVyQ2xpZW50SGVpZ2h0c1tzZWN0aW9uS2V5XSA9IE1hdGguZmxvb3IoaGFybmVzc0VsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHsgZm9yY2VZU2Nyb2xsYmFycywgc2Nyb2xsZXJDbGllbnRXaWR0aHMsIHNjcm9sbGVyQ2xpZW50SGVpZ2h0cyB9O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIFNpbXBsZVNjcm9sbEdyaWQuYWRkU3RhdGVFcXVhbGl0eSh7XHJcbiAgICAgICAgc2Nyb2xsZXJDbGllbnRXaWR0aHM6IGlzUHJvcHNFcXVhbCxcclxuICAgICAgICBzY3JvbGxlckNsaWVudEhlaWdodHM6IGlzUHJvcHNFcXVhbCxcclxuICAgIH0pO1xyXG4gICAgZnVuY3Rpb24gZ2V0U2VjdGlvbkJ5S2V5KHNlY3Rpb25zLCBrZXkpIHtcclxuICAgICAgICBmb3IgKGxldCBzZWN0aW9uIG9mIHNlY3Rpb25zKSB7XHJcbiAgICAgICAgICAgIGlmIChzZWN0aW9uLmtleSA9PT0ga2V5KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VjdGlvbjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBjbGFzcyBFdmVudENvbnRhaW5lciBleHRlbmRzIEJhc2VDb21wb25lbnQge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgICAgICB0aGlzLmhhbmRsZUVsID0gKGVsKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVsID0gZWw7XHJcbiAgICAgICAgICAgICAgICBpZiAoZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZXRFbFNlZyhlbCwgdGhpcy5wcm9wcy5zZWcpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZW5kZXIoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgcHJvcHMsIGNvbnRleHQgfSA9IHRoaXM7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgb3B0aW9ucyB9ID0gY29udGV4dDtcclxuICAgICAgICAgICAgY29uc3QgeyBzZWcgfSA9IHByb3BzO1xyXG4gICAgICAgICAgICBjb25zdCB7IGV2ZW50UmFuZ2UgfSA9IHNlZztcclxuICAgICAgICAgICAgY29uc3QgeyB1aSB9ID0gZXZlbnRSYW5nZTtcclxuICAgICAgICAgICAgY29uc3QgcmVuZGVyUHJvcHMgPSB7XHJcbiAgICAgICAgICAgICAgICBldmVudDogbmV3IEV2ZW50SW1wbChjb250ZXh0LCBldmVudFJhbmdlLmRlZiwgZXZlbnRSYW5nZS5pbnN0YW5jZSksXHJcbiAgICAgICAgICAgICAgICB2aWV3OiBjb250ZXh0LnZpZXdBcGksXHJcbiAgICAgICAgICAgICAgICB0aW1lVGV4dDogcHJvcHMudGltZVRleHQsXHJcbiAgICAgICAgICAgICAgICB0ZXh0Q29sb3I6IHVpLnRleHRDb2xvcixcclxuICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogdWkuYmFja2dyb3VuZENvbG9yLFxyXG4gICAgICAgICAgICAgICAgYm9yZGVyQ29sb3I6IHVpLmJvcmRlckNvbG9yLFxyXG4gICAgICAgICAgICAgICAgaXNEcmFnZ2FibGU6ICFwcm9wcy5kaXNhYmxlRHJhZ2dpbmcgJiYgY29tcHV0ZVNlZ0RyYWdnYWJsZShzZWcsIGNvbnRleHQpLFxyXG4gICAgICAgICAgICAgICAgaXNTdGFydFJlc2l6YWJsZTogIXByb3BzLmRpc2FibGVSZXNpemluZyAmJiBjb21wdXRlU2VnU3RhcnRSZXNpemFibGUoc2VnLCBjb250ZXh0KSxcclxuICAgICAgICAgICAgICAgIGlzRW5kUmVzaXphYmxlOiAhcHJvcHMuZGlzYWJsZVJlc2l6aW5nICYmIGNvbXB1dGVTZWdFbmRSZXNpemFibGUoc2VnKSxcclxuICAgICAgICAgICAgICAgIGlzTWlycm9yOiBCb29sZWFuKHByb3BzLmlzRHJhZ2dpbmcgfHwgcHJvcHMuaXNSZXNpemluZyB8fCBwcm9wcy5pc0RhdGVTZWxlY3RpbmcpLFxyXG4gICAgICAgICAgICAgICAgaXNTdGFydDogQm9vbGVhbihzZWcuaXNTdGFydCksXHJcbiAgICAgICAgICAgICAgICBpc0VuZDogQm9vbGVhbihzZWcuaXNFbmQpLFxyXG4gICAgICAgICAgICAgICAgaXNQYXN0OiBCb29sZWFuKHByb3BzLmlzUGFzdCksXHJcbiAgICAgICAgICAgICAgICBpc0Z1dHVyZTogQm9vbGVhbihwcm9wcy5pc0Z1dHVyZSksXHJcbiAgICAgICAgICAgICAgICBpc1RvZGF5OiBCb29sZWFuKHByb3BzLmlzVG9kYXkpLFxyXG4gICAgICAgICAgICAgICAgaXNTZWxlY3RlZDogQm9vbGVhbihwcm9wcy5pc1NlbGVjdGVkKSxcclxuICAgICAgICAgICAgICAgIGlzRHJhZ2dpbmc6IEJvb2xlYW4ocHJvcHMuaXNEcmFnZ2luZyksXHJcbiAgICAgICAgICAgICAgICBpc1Jlc2l6aW5nOiBCb29sZWFuKHByb3BzLmlzUmVzaXppbmcpLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4gKHkoQ29udGVudENvbnRhaW5lciwgT2JqZWN0LmFzc2lnbih7fSwgcHJvcHMgLyogY29udGFpbnMgY2hpbGRyZW4gKi8sIHsgZWxSZWY6IHRoaXMuaGFuZGxlRWwsIGVsQ2xhc3NlczogW1xyXG4gICAgICAgICAgICAgICAgICAgIC4uLmdldEV2ZW50Q2xhc3NOYW1lcyhyZW5kZXJQcm9wcyksXHJcbiAgICAgICAgICAgICAgICAgICAgLi4uc2VnLmV2ZW50UmFuZ2UudWkuY2xhc3NOYW1lcyxcclxuICAgICAgICAgICAgICAgICAgICAuLi4ocHJvcHMuZWxDbGFzc2VzIHx8IFtdKSxcclxuICAgICAgICAgICAgICAgIF0sIHJlbmRlclByb3BzOiByZW5kZXJQcm9wcywgZ2VuZXJhdG9yTmFtZTogXCJldmVudENvbnRlbnRcIiwgY3VzdG9tR2VuZXJhdG9yOiBvcHRpb25zLmV2ZW50Q29udGVudCwgZGVmYXVsdEdlbmVyYXRvcjogcHJvcHMuZGVmYXVsdEdlbmVyYXRvciwgY2xhc3NOYW1lR2VuZXJhdG9yOiBvcHRpb25zLmV2ZW50Q2xhc3NOYW1lcywgZGlkTW91bnQ6IG9wdGlvbnMuZXZlbnREaWRNb3VudCwgd2lsbFVubW91bnQ6IG9wdGlvbnMuZXZlbnRXaWxsVW5tb3VudCB9KSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmVsICYmIHRoaXMucHJvcHMuc2VnICE9PSBwcmV2UHJvcHMuc2VnKSB7XHJcbiAgICAgICAgICAgICAgICBzZXRFbFNlZyh0aGlzLmVsLCB0aGlzLnByb3BzLnNlZyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gc2hvdWxkIG5vdCBiZSBhIHB1cmVjb21wb25lbnRcclxuICAgIGNsYXNzIFN0YW5kYXJkRXZlbnQgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcclxuICAgICAgICByZW5kZXIoKSB7XHJcbiAgICAgICAgICAgIGxldCB7IHByb3BzLCBjb250ZXh0IH0gPSB0aGlzO1xyXG4gICAgICAgICAgICBsZXQgeyBvcHRpb25zIH0gPSBjb250ZXh0O1xyXG4gICAgICAgICAgICBsZXQgeyBzZWcgfSA9IHByb3BzO1xyXG4gICAgICAgICAgICBsZXQgeyB1aSB9ID0gc2VnLmV2ZW50UmFuZ2U7XHJcbiAgICAgICAgICAgIGxldCB0aW1lRm9ybWF0ID0gb3B0aW9ucy5ldmVudFRpbWVGb3JtYXQgfHwgcHJvcHMuZGVmYXVsdFRpbWVGb3JtYXQ7XHJcbiAgICAgICAgICAgIGxldCB0aW1lVGV4dCA9IGJ1aWxkU2VnVGltZVRleHQoc2VnLCB0aW1lRm9ybWF0LCBjb250ZXh0LCBwcm9wcy5kZWZhdWx0RGlzcGxheUV2ZW50VGltZSwgcHJvcHMuZGVmYXVsdERpc3BsYXlFdmVudEVuZCk7XHJcbiAgICAgICAgICAgIHJldHVybiAoeShFdmVudENvbnRhaW5lciwgT2JqZWN0LmFzc2lnbih7fSwgcHJvcHMgLyogaW5jbHVkZXMgZWxSZWYgKi8sIHsgZWxUYWc6IFwiYVwiLCBlbFN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgYm9yZGVyQ29sb3I6IHVpLmJvcmRlckNvbG9yLFxyXG4gICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogdWkuYmFja2dyb3VuZENvbG9yLFxyXG4gICAgICAgICAgICAgICAgfSwgZWxBdHRyczogZ2V0U2VnQW5jaG9yQXR0cnMoc2VnLCBjb250ZXh0KSwgZGVmYXVsdEdlbmVyYXRvcjogcmVuZGVySW5uZXJDb250ZW50JDEkMSwgdGltZVRleHQ6IHRpbWVUZXh0IH0pLCAoSW5uZXJDb250ZW50LCBldmVudENvbnRlbnRBcmcpID0+ICh5KF8sIG51bGwsXHJcbiAgICAgICAgICAgICAgICB5KElubmVyQ29udGVudCwgeyBlbFRhZzogXCJkaXZcIiwgZWxDbGFzc2VzOiBbJ2ZjLWV2ZW50LW1haW4nXSwgZWxTdHlsZTogeyBjb2xvcjogZXZlbnRDb250ZW50QXJnLnRleHRDb2xvciB9IH0pLFxyXG4gICAgICAgICAgICAgICAgQm9vbGVhbihldmVudENvbnRlbnRBcmcuaXNTdGFydFJlc2l6YWJsZSkgJiYgKHkoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtZXZlbnQtcmVzaXplciBmYy1ldmVudC1yZXNpemVyLXN0YXJ0XCIgfSkpLFxyXG4gICAgICAgICAgICAgICAgQm9vbGVhbihldmVudENvbnRlbnRBcmcuaXNFbmRSZXNpemFibGUpICYmICh5KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLWV2ZW50LXJlc2l6ZXIgZmMtZXZlbnQtcmVzaXplci1lbmRcIiB9KSkpKSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHJlbmRlcklubmVyQ29udGVudCQxJDEoaW5uZXJQcm9wcykge1xyXG4gICAgICAgIHJldHVybiAoeShcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy1ldmVudC1tYWluLWZyYW1lXCIgfSxcclxuICAgICAgICAgICAgaW5uZXJQcm9wcy50aW1lVGV4dCAmJiAoeShcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy1ldmVudC10aW1lXCIgfSwgaW5uZXJQcm9wcy50aW1lVGV4dCkpLFxyXG4gICAgICAgICAgICB5KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLWV2ZW50LXRpdGxlLWNvbnRhaW5lclwiIH0sXHJcbiAgICAgICAgICAgICAgICB5KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLWV2ZW50LXRpdGxlIGZjLXN0aWNreVwiIH0sIGlubmVyUHJvcHMuZXZlbnQudGl0bGUgfHwgeShfLCBudWxsLCBcIlxcdTAwQTBcIikpKSkpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IE5vd0luZGljYXRvckNvbnRhaW5lciA9IChwcm9wcykgPT4gKHkoVmlld0NvbnRleHRUeXBlLkNvbnN1bWVyLCBudWxsLCAoY29udGV4dCkgPT4ge1xyXG4gICAgICAgIGxldCB7IG9wdGlvbnMgfSA9IGNvbnRleHQ7XHJcbiAgICAgICAgbGV0IHJlbmRlclByb3BzID0ge1xyXG4gICAgICAgICAgICBpc0F4aXM6IHByb3BzLmlzQXhpcyxcclxuICAgICAgICAgICAgZGF0ZTogY29udGV4dC5kYXRlRW52LnRvRGF0ZShwcm9wcy5kYXRlKSxcclxuICAgICAgICAgICAgdmlldzogY29udGV4dC52aWV3QXBpLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuICh5KENvbnRlbnRDb250YWluZXIsIE9iamVjdC5hc3NpZ24oe30sIHByb3BzIC8qIGluY2x1ZGVzIGNoaWxkcmVuICovLCB7IGVsVGFnOiBwcm9wcy5lbFRhZyB8fCAnZGl2JywgcmVuZGVyUHJvcHM6IHJlbmRlclByb3BzLCBnZW5lcmF0b3JOYW1lOiBcIm5vd0luZGljYXRvckNvbnRlbnRcIiwgY3VzdG9tR2VuZXJhdG9yOiBvcHRpb25zLm5vd0luZGljYXRvckNvbnRlbnQsIGNsYXNzTmFtZUdlbmVyYXRvcjogb3B0aW9ucy5ub3dJbmRpY2F0b3JDbGFzc05hbWVzLCBkaWRNb3VudDogb3B0aW9ucy5ub3dJbmRpY2F0b3JEaWRNb3VudCwgd2lsbFVubW91bnQ6IG9wdGlvbnMubm93SW5kaWNhdG9yV2lsbFVubW91bnQgfSkpKTtcclxuICAgIH0pKTtcclxuXHJcbiAgICBjb25zdCBEQVlfTlVNX0ZPUk1BVCA9IGNyZWF0ZUZvcm1hdHRlcih7IGRheTogJ251bWVyaWMnIH0pO1xyXG4gICAgY2xhc3MgRGF5Q2VsbENvbnRhaW5lciBleHRlbmRzIEJhc2VDb21wb25lbnQge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgICAgICB0aGlzLnJlZmluZVJlbmRlclByb3BzID0gbWVtb2l6ZU9iakFyZyhyZWZpbmVSZW5kZXJQcm9wcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlbmRlcigpIHtcclxuICAgICAgICAgICAgbGV0IHsgcHJvcHMsIGNvbnRleHQgfSA9IHRoaXM7XHJcbiAgICAgICAgICAgIGxldCB7IG9wdGlvbnMgfSA9IGNvbnRleHQ7XHJcbiAgICAgICAgICAgIGxldCByZW5kZXJQcm9wcyA9IHRoaXMucmVmaW5lUmVuZGVyUHJvcHMoe1xyXG4gICAgICAgICAgICAgICAgZGF0ZTogcHJvcHMuZGF0ZSxcclxuICAgICAgICAgICAgICAgIGRhdGVQcm9maWxlOiBwcm9wcy5kYXRlUHJvZmlsZSxcclxuICAgICAgICAgICAgICAgIHRvZGF5UmFuZ2U6IHByb3BzLnRvZGF5UmFuZ2UsXHJcbiAgICAgICAgICAgICAgICBpc01vbnRoU3RhcnQ6IHByb3BzLmlzTW9udGhTdGFydCB8fCBmYWxzZSxcclxuICAgICAgICAgICAgICAgIHNob3dEYXlOdW1iZXI6IHByb3BzLnNob3dEYXlOdW1iZXIsXHJcbiAgICAgICAgICAgICAgICBleHRyYVJlbmRlclByb3BzOiBwcm9wcy5leHRyYVJlbmRlclByb3BzLFxyXG4gICAgICAgICAgICAgICAgdmlld0FwaTogY29udGV4dC52aWV3QXBpLFxyXG4gICAgICAgICAgICAgICAgZGF0ZUVudjogY29udGV4dC5kYXRlRW52LFxyXG4gICAgICAgICAgICAgICAgbW9udGhTdGFydEZvcm1hdDogb3B0aW9ucy5tb250aFN0YXJ0Rm9ybWF0LFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuICh5KENvbnRlbnRDb250YWluZXIsIE9iamVjdC5hc3NpZ24oe30sIHByb3BzIC8qIGluY2x1ZGVzIGNoaWxkcmVuICovLCB7IGVsQ2xhc3NlczogW1xyXG4gICAgICAgICAgICAgICAgICAgIC4uLmdldERheUNsYXNzTmFtZXMocmVuZGVyUHJvcHMsIGNvbnRleHQudGhlbWUpLFxyXG4gICAgICAgICAgICAgICAgICAgIC4uLihwcm9wcy5lbENsYXNzZXMgfHwgW10pLFxyXG4gICAgICAgICAgICAgICAgXSwgZWxBdHRyczogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwcm9wcy5lbEF0dHJzKSwgKHJlbmRlclByb3BzLmlzRGlzYWJsZWQgPyB7fSA6IHsgJ2RhdGEtZGF0ZSc6IGZvcm1hdERheVN0cmluZyhwcm9wcy5kYXRlKSB9KSksIHJlbmRlclByb3BzOiByZW5kZXJQcm9wcywgZ2VuZXJhdG9yTmFtZTogXCJkYXlDZWxsQ29udGVudFwiLCBjdXN0b21HZW5lcmF0b3I6IG9wdGlvbnMuZGF5Q2VsbENvbnRlbnQsIGRlZmF1bHRHZW5lcmF0b3I6IHByb3BzLmRlZmF1bHRHZW5lcmF0b3IsIGNsYXNzTmFtZUdlbmVyYXRvcjogXHJcbiAgICAgICAgICAgICAgICAvLyBkb24ndCB1c2UgY3VzdG9tIGNsYXNzTmFtZXMgaWYgZGlzYWJsZWRcclxuICAgICAgICAgICAgICAgIHJlbmRlclByb3BzLmlzRGlzYWJsZWQgPyB1bmRlZmluZWQgOiBvcHRpb25zLmRheUNlbGxDbGFzc05hbWVzLCBkaWRNb3VudDogb3B0aW9ucy5kYXlDZWxsRGlkTW91bnQsIHdpbGxVbm1vdW50OiBvcHRpb25zLmRheUNlbGxXaWxsVW5tb3VudCB9KSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGhhc0N1c3RvbURheUNlbGxDb250ZW50KG9wdGlvbnMpIHtcclxuICAgICAgICByZXR1cm4gQm9vbGVhbihvcHRpb25zLmRheUNlbGxDb250ZW50IHx8IGhhc0N1c3RvbVJlbmRlcmluZ0hhbmRsZXIoJ2RheUNlbGxDb250ZW50Jywgb3B0aW9ucykpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gcmVmaW5lUmVuZGVyUHJvcHMocmF3KSB7XHJcbiAgICAgICAgbGV0IHsgZGF0ZSwgZGF0ZUVudiwgZGF0ZVByb2ZpbGUsIGlzTW9udGhTdGFydCB9ID0gcmF3O1xyXG4gICAgICAgIGxldCBkYXlNZXRhID0gZ2V0RGF0ZU1ldGEoZGF0ZSwgcmF3LnRvZGF5UmFuZ2UsIG51bGwsIGRhdGVQcm9maWxlKTtcclxuICAgICAgICBsZXQgZGF5TnVtYmVyVGV4dCA9IHJhdy5zaG93RGF5TnVtYmVyID8gKGRhdGVFbnYuZm9ybWF0KGRhdGUsIGlzTW9udGhTdGFydCA/IHJhdy5tb250aFN0YXJ0Rm9ybWF0IDogREFZX05VTV9GT1JNQVQpKSA6ICcnO1xyXG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IGRhdGU6IGRhdGVFbnYudG9EYXRlKGRhdGUpLCB2aWV3OiByYXcudmlld0FwaSB9LCBkYXlNZXRhKSwgeyBpc01vbnRoU3RhcnQsXHJcbiAgICAgICAgICAgIGRheU51bWJlclRleHQgfSksIHJhdy5leHRyYVJlbmRlclByb3BzKTtcclxuICAgIH1cclxuXHJcbiAgICBjbGFzcyBCZ0V2ZW50IGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XHJcbiAgICAgICAgcmVuZGVyKCkge1xyXG4gICAgICAgICAgICBsZXQgeyBwcm9wcyB9ID0gdGhpcztcclxuICAgICAgICAgICAgbGV0IHsgc2VnIH0gPSBwcm9wcztcclxuICAgICAgICAgICAgcmV0dXJuICh5KEV2ZW50Q29udGFpbmVyLCB7IGVsVGFnOiBcImRpdlwiLCBlbENsYXNzZXM6IFsnZmMtYmctZXZlbnQnXSwgZWxTdHlsZTogeyBiYWNrZ3JvdW5kQ29sb3I6IHNlZy5ldmVudFJhbmdlLnVpLmJhY2tncm91bmRDb2xvciB9LCBkZWZhdWx0R2VuZXJhdG9yOiByZW5kZXJJbm5lckNvbnRlbnQkMywgc2VnOiBzZWcsIHRpbWVUZXh0OiBcIlwiLCBpc0RyYWdnaW5nOiBmYWxzZSwgaXNSZXNpemluZzogZmFsc2UsIGlzRGF0ZVNlbGVjdGluZzogZmFsc2UsIGlzU2VsZWN0ZWQ6IGZhbHNlLCBpc1Bhc3Q6IHByb3BzLmlzUGFzdCwgaXNGdXR1cmU6IHByb3BzLmlzRnV0dXJlLCBpc1RvZGF5OiBwcm9wcy5pc1RvZGF5LCBkaXNhYmxlRHJhZ2dpbmc6IHRydWUsIGRpc2FibGVSZXNpemluZzogdHJ1ZSB9KSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gcmVuZGVySW5uZXJDb250ZW50JDMocHJvcHMpIHtcclxuICAgICAgICBsZXQgeyB0aXRsZSB9ID0gcHJvcHMuZXZlbnQ7XHJcbiAgICAgICAgcmV0dXJuIHRpdGxlICYmICh5KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLWV2ZW50LXRpdGxlXCIgfSwgcHJvcHMuZXZlbnQudGl0bGUpKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHJlbmRlckZpbGwoZmlsbFR5cGUpIHtcclxuICAgICAgICByZXR1cm4gKHkoXCJkaXZcIiwgeyBjbGFzc05hbWU6IGBmYy0ke2ZpbGxUeXBlfWAgfSkpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IFdlZWtOdW1iZXJDb250YWluZXIgPSAocHJvcHMpID0+ICh5KFZpZXdDb250ZXh0VHlwZS5Db25zdW1lciwgbnVsbCwgKGNvbnRleHQpID0+IHtcclxuICAgICAgICBsZXQgeyBkYXRlRW52LCBvcHRpb25zIH0gPSBjb250ZXh0O1xyXG4gICAgICAgIGxldCB7IGRhdGUgfSA9IHByb3BzO1xyXG4gICAgICAgIGxldCBmb3JtYXQgPSBvcHRpb25zLndlZWtOdW1iZXJGb3JtYXQgfHwgcHJvcHMuZGVmYXVsdEZvcm1hdDtcclxuICAgICAgICBsZXQgbnVtID0gZGF0ZUVudi5jb21wdXRlV2Vla051bWJlcihkYXRlKTsgLy8gVE9ETzogc29tZWhvdyB1c2UgZm9yIGZvcm1hdHRpbmcgYXMgd2VsbD9cclxuICAgICAgICBsZXQgdGV4dCA9IGRhdGVFbnYuZm9ybWF0KGRhdGUsIGZvcm1hdCk7XHJcbiAgICAgICAgbGV0IHJlbmRlclByb3BzID0geyBudW0sIHRleHQsIGRhdGUgfTtcclxuICAgICAgICByZXR1cm4gKHkoQ29udGVudENvbnRhaW5lciAvLyB3aHkgaXNuJ3QgV2Vla051bWJlckNvbnRlbnRBcmcgYmVpbmcgYXV0by1kZXRlY3RlZD9cclxuICAgICAgICAsIE9iamVjdC5hc3NpZ24oe30sIHByb3BzIC8qIGluY2x1ZGVzIGNoaWxkcmVuICovLCB7IHJlbmRlclByb3BzOiByZW5kZXJQcm9wcywgZ2VuZXJhdG9yTmFtZTogXCJ3ZWVrTnVtYmVyQ29udGVudFwiLCBjdXN0b21HZW5lcmF0b3I6IG9wdGlvbnMud2Vla051bWJlckNvbnRlbnQsIGRlZmF1bHRHZW5lcmF0b3I6IHJlbmRlcklubmVyLCBjbGFzc05hbWVHZW5lcmF0b3I6IG9wdGlvbnMud2Vla051bWJlckNsYXNzTmFtZXMsIGRpZE1vdW50OiBvcHRpb25zLndlZWtOdW1iZXJEaWRNb3VudCwgd2lsbFVubW91bnQ6IG9wdGlvbnMud2Vla051bWJlcldpbGxVbm1vdW50IH0pKSk7XHJcbiAgICB9KSk7XHJcbiAgICBmdW5jdGlvbiByZW5kZXJJbm5lcihpbm5lclByb3BzKSB7XHJcbiAgICAgICAgcmV0dXJuIGlubmVyUHJvcHMudGV4dDtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBQQURESU5HX0ZST01fVklFV1BPUlQgPSAxMDtcclxuICAgIGNsYXNzIFBvcG92ZXIgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcclxuICAgICAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IHtcclxuICAgICAgICAgICAgICAgIHRpdGxlSWQ6IGdldFVuaXF1ZURvbUlkKCksXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlUm9vdEVsID0gKGVsKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJvb3RFbCA9IGVsO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucHJvcHMuZWxSZWYpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZXRSZWYodGhpcy5wcm9wcy5lbFJlZiwgZWwpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvLyBUcmlnZ2VyZWQgd2hlbiB0aGUgdXNlciBjbGlja3MgKmFueXdoZXJlKiBpbiB0aGUgZG9jdW1lbnQsIGZvciB0aGUgYXV0b0hpZGUgZmVhdHVyZVxyXG4gICAgICAgICAgICB0aGlzLmhhbmRsZURvY3VtZW50TW91c2VEb3duID0gKGV2KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAvLyBvbmx5IGhpZGUgdGhlIHBvcG92ZXIgaWYgdGhlIGNsaWNrIGhhcHBlbmVkIG91dHNpZGUgdGhlIHBvcG92ZXJcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IGdldEV2ZW50VGFyZ2V0VmlhUm9vdChldik7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMucm9vdEVsLmNvbnRhaW5zKHRhcmdldCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUNsb3NlQ2xpY2soKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdGhpcy5oYW5kbGVEb2N1bWVudEtleURvd24gPSAoZXYpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChldi5rZXkgPT09ICdFc2NhcGUnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVDbG9zZUNsaWNrKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlQ2xvc2VDbGljayA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGxldCB7IG9uQ2xvc2UgfSA9IHRoaXMucHJvcHM7XHJcbiAgICAgICAgICAgICAgICBpZiAob25DbG9zZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG9uQ2xvc2UoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVuZGVyKCkge1xyXG4gICAgICAgICAgICBsZXQgeyB0aGVtZSwgb3B0aW9ucyB9ID0gdGhpcy5jb250ZXh0O1xyXG4gICAgICAgICAgICBsZXQgeyBwcm9wcywgc3RhdGUgfSA9IHRoaXM7XHJcbiAgICAgICAgICAgIGxldCBjbGFzc05hbWVzID0gW1xyXG4gICAgICAgICAgICAgICAgJ2ZjLXBvcG92ZXInLFxyXG4gICAgICAgICAgICAgICAgdGhlbWUuZ2V0Q2xhc3MoJ3BvcG92ZXInKSxcclxuICAgICAgICAgICAgXS5jb25jYXQocHJvcHMuZXh0cmFDbGFzc05hbWVzIHx8IFtdKTtcclxuICAgICAgICAgICAgcmV0dXJuIGooeShcImRpdlwiLCBPYmplY3QuYXNzaWduKHt9LCBwcm9wcy5leHRyYUF0dHJzLCB7IGlkOiBwcm9wcy5pZCwgY2xhc3NOYW1lOiBjbGFzc05hbWVzLmpvaW4oJyAnKSwgXCJhcmlhLWxhYmVsbGVkYnlcIjogc3RhdGUudGl0bGVJZCwgcmVmOiB0aGlzLmhhbmRsZVJvb3RFbCB9KSxcclxuICAgICAgICAgICAgICAgIHkoXCJkaXZcIiwgeyBjbGFzc05hbWU6ICdmYy1wb3BvdmVyLWhlYWRlciAnICsgdGhlbWUuZ2V0Q2xhc3MoJ3BvcG92ZXJIZWFkZXInKSB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHkoXCJzcGFuXCIsIHsgY2xhc3NOYW1lOiBcImZjLXBvcG92ZXItdGl0bGVcIiwgaWQ6IHN0YXRlLnRpdGxlSWQgfSwgcHJvcHMudGl0bGUpLFxyXG4gICAgICAgICAgICAgICAgICAgIHkoXCJzcGFuXCIsIHsgY2xhc3NOYW1lOiAnZmMtcG9wb3Zlci1jbG9zZSAnICsgdGhlbWUuZ2V0SWNvbkNsYXNzKCdjbG9zZScpLCB0aXRsZTogb3B0aW9ucy5jbG9zZUhpbnQsIG9uQ2xpY2s6IHRoaXMuaGFuZGxlQ2xvc2VDbGljayB9KSksXHJcbiAgICAgICAgICAgICAgICB5KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiAnZmMtcG9wb3Zlci1ib2R5ICcgKyB0aGVtZS5nZXRDbGFzcygncG9wb3ZlckNvbnRlbnQnKSB9LCBwcm9wcy5jaGlsZHJlbikpLCBwcm9wcy5wYXJlbnRFbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xyXG4gICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLmhhbmRsZURvY3VtZW50TW91c2VEb3duKTtcclxuICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuaGFuZGxlRG9jdW1lbnRLZXlEb3duKTtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVTaXplKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xyXG4gICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLmhhbmRsZURvY3VtZW50TW91c2VEb3duKTtcclxuICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuaGFuZGxlRG9jdW1lbnRLZXlEb3duKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdXBkYXRlU2l6ZSgpIHtcclxuICAgICAgICAgICAgbGV0IHsgaXNSdGwgfSA9IHRoaXMuY29udGV4dDtcclxuICAgICAgICAgICAgbGV0IHsgYWxpZ25tZW50RWwsIGFsaWduR3JpZFRvcCB9ID0gdGhpcy5wcm9wcztcclxuICAgICAgICAgICAgbGV0IHsgcm9vdEVsIH0gPSB0aGlzO1xyXG4gICAgICAgICAgICBsZXQgYWxpZ25tZW50UmVjdCA9IGNvbXB1dGVDbGlwcGVkQ2xpZW50UmVjdChhbGlnbm1lbnRFbCk7XHJcbiAgICAgICAgICAgIGlmIChhbGlnbm1lbnRSZWN0KSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgcG9wb3ZlckRpbXMgPSByb290RWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICAgICAgICAgICAgICAvLyBwb3NpdGlvbiByZWxhdGl2ZSB0byB2aWV3cG9ydFxyXG4gICAgICAgICAgICAgICAgbGV0IHBvcG92ZXJUb3AgPSBhbGlnbkdyaWRUb3BcclxuICAgICAgICAgICAgICAgICAgICA/IGVsZW1lbnRDbG9zZXN0KGFsaWdubWVudEVsLCAnLmZjLXNjcm9sbGdyaWQnKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3BcclxuICAgICAgICAgICAgICAgICAgICA6IGFsaWdubWVudFJlY3QudG9wO1xyXG4gICAgICAgICAgICAgICAgbGV0IHBvcG92ZXJMZWZ0ID0gaXNSdGwgPyBhbGlnbm1lbnRSZWN0LnJpZ2h0IC0gcG9wb3ZlckRpbXMud2lkdGggOiBhbGlnbm1lbnRSZWN0LmxlZnQ7XHJcbiAgICAgICAgICAgICAgICAvLyBjb25zdHJhaW5cclxuICAgICAgICAgICAgICAgIHBvcG92ZXJUb3AgPSBNYXRoLm1heChwb3BvdmVyVG9wLCBQQURESU5HX0ZST01fVklFV1BPUlQpO1xyXG4gICAgICAgICAgICAgICAgcG9wb3ZlckxlZnQgPSBNYXRoLm1pbihwb3BvdmVyTGVmdCwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoIC0gUEFERElOR19GUk9NX1ZJRVdQT1JUIC0gcG9wb3ZlckRpbXMud2lkdGgpO1xyXG4gICAgICAgICAgICAgICAgcG9wb3ZlckxlZnQgPSBNYXRoLm1heChwb3BvdmVyTGVmdCwgUEFERElOR19GUk9NX1ZJRVdQT1JUKTtcclxuICAgICAgICAgICAgICAgIGxldCBvcmlnaW4gPSByb290RWwub2Zmc2V0UGFyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgICAgICAgICAgICAgYXBwbHlTdHlsZShyb290RWwsIHtcclxuICAgICAgICAgICAgICAgICAgICB0b3A6IHBvcG92ZXJUb3AgLSBvcmlnaW4udG9wLFxyXG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6IHBvcG92ZXJMZWZ0IC0gb3JpZ2luLmxlZnQsXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBjbGFzcyBNb3JlUG9wb3ZlciBleHRlbmRzIERhdGVDb21wb25lbnQge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgICAgICB0aGlzLmhhbmRsZVJvb3RFbCA9IChyb290RWwpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMucm9vdEVsID0gcm9vdEVsO1xyXG4gICAgICAgICAgICAgICAgaWYgKHJvb3RFbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5yZWdpc3RlckludGVyYWN0aXZlQ29tcG9uZW50KHRoaXMsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWw6IHJvb3RFbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXNlRXZlbnRDZW50ZXI6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LnVucmVnaXN0ZXJJbnRlcmFjdGl2ZUNvbXBvbmVudCh0aGlzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVuZGVyKCkge1xyXG4gICAgICAgICAgICBsZXQgeyBvcHRpb25zLCBkYXRlRW52IH0gPSB0aGlzLmNvbnRleHQ7XHJcbiAgICAgICAgICAgIGxldCB7IHByb3BzIH0gPSB0aGlzO1xyXG4gICAgICAgICAgICBsZXQgeyBzdGFydERhdGUsIHRvZGF5UmFuZ2UsIGRhdGVQcm9maWxlIH0gPSBwcm9wcztcclxuICAgICAgICAgICAgbGV0IHRpdGxlID0gZGF0ZUVudi5mb3JtYXQoc3RhcnREYXRlLCBvcHRpb25zLmRheVBvcG92ZXJGb3JtYXQpO1xyXG4gICAgICAgICAgICByZXR1cm4gKHkoRGF5Q2VsbENvbnRhaW5lciwgeyBlbFJlZjogdGhpcy5oYW5kbGVSb290RWwsIGRhdGU6IHN0YXJ0RGF0ZSwgZGF0ZVByb2ZpbGU6IGRhdGVQcm9maWxlLCB0b2RheVJhbmdlOiB0b2RheVJhbmdlIH0sIChJbm5lckNvbnRlbnQsIHJlbmRlclByb3BzLCBlbEF0dHJzKSA9PiAoeShQb3BvdmVyLCB7IGVsUmVmOiBlbEF0dHJzLnJlZiwgaWQ6IHByb3BzLmlkLCB0aXRsZTogdGl0bGUsIGV4dHJhQ2xhc3NOYW1lczogWydmYy1tb3JlLXBvcG92ZXInXS5jb25jYXQoZWxBdHRycy5jbGFzc05hbWUgfHwgW10pLCBleHRyYUF0dHJzOiBlbEF0dHJzIC8qIFRPRE86IG1ha2UgdGhlc2UgdGltZS1iYXNlZCB3aGVuIG5vdCB3aG9sZS1kYXk/ICovLCBwYXJlbnRFbDogcHJvcHMucGFyZW50RWwsIGFsaWdubWVudEVsOiBwcm9wcy5hbGlnbm1lbnRFbCwgYWxpZ25HcmlkVG9wOiBwcm9wcy5hbGlnbkdyaWRUb3AsIG9uQ2xvc2U6IHByb3BzLm9uQ2xvc2UgfSxcclxuICAgICAgICAgICAgICAgIGhhc0N1c3RvbURheUNlbGxDb250ZW50KG9wdGlvbnMpICYmICh5KElubmVyQ29udGVudCwgeyBlbFRhZzogXCJkaXZcIiwgZWxDbGFzc2VzOiBbJ2ZjLW1vcmUtcG9wb3Zlci1taXNjJ10gfSkpLFxyXG4gICAgICAgICAgICAgICAgcHJvcHMuY2hpbGRyZW4pKSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBxdWVyeUhpdChwb3NpdGlvbkxlZnQsIHBvc2l0aW9uVG9wLCBlbFdpZHRoLCBlbEhlaWdodCkge1xyXG4gICAgICAgICAgICBsZXQgeyByb290RWwsIHByb3BzIH0gPSB0aGlzO1xyXG4gICAgICAgICAgICBpZiAocG9zaXRpb25MZWZ0ID49IDAgJiYgcG9zaXRpb25MZWZ0IDwgZWxXaWR0aCAmJlxyXG4gICAgICAgICAgICAgICAgcG9zaXRpb25Ub3AgPj0gMCAmJiBwb3NpdGlvblRvcCA8IGVsSGVpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGVQcm9maWxlOiBwcm9wcy5kYXRlUHJvZmlsZSxcclxuICAgICAgICAgICAgICAgICAgICBkYXRlU3BhbjogT2JqZWN0LmFzc2lnbih7IGFsbERheTogIXByb3BzLmZvcmNlVGltZWQsIHJhbmdlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogcHJvcHMuc3RhcnREYXRlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiBwcm9wcy5lbmREYXRlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IH0sIHByb3BzLmV4dHJhRGF0ZVNwYW4pLFxyXG4gICAgICAgICAgICAgICAgICAgIGRheUVsOiByb290RWwsXHJcbiAgICAgICAgICAgICAgICAgICAgcmVjdDoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3A6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0OiBlbFdpZHRoLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBib3R0b206IGVsSGVpZ2h0LFxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgbGF5ZXI6IDEsIC8vIGltcG9ydGFudCB3aGVuIGNvbXBhcmluZyB3aXRoIGhpdHMgZnJvbSBvdGhlciBjb21wb25lbnRzXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBjbGFzcyBNb3JlTGlua0NvbnRhaW5lciBleHRlbmRzIEJhc2VDb21wb25lbnQge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0ge1xyXG4gICAgICAgICAgICAgICAgaXNQb3BvdmVyT3BlbjogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBwb3BvdmVySWQ6IGdldFVuaXF1ZURvbUlkKCksXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlTGlua0VsID0gKGxpbmtFbCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5saW5rRWwgPSBsaW5rRWw7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wcm9wcy5lbFJlZikge1xyXG4gICAgICAgICAgICAgICAgICAgIHNldFJlZih0aGlzLnByb3BzLmVsUmVmLCBsaW5rRWwpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB0aGlzLmhhbmRsZUNsaWNrID0gKGV2KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBsZXQgeyBwcm9wcywgY29udGV4dCB9ID0gdGhpcztcclxuICAgICAgICAgICAgICAgIGxldCB7IG1vcmVMaW5rQ2xpY2sgfSA9IGNvbnRleHQub3B0aW9ucztcclxuICAgICAgICAgICAgICAgIGxldCBkYXRlID0gY29tcHV0ZVJhbmdlKHByb3BzKS5zdGFydDtcclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGJ1aWxkUHVibGljU2VnKHNlZykge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCB7IGRlZiwgaW5zdGFuY2UsIHJhbmdlIH0gPSBzZWcuZXZlbnRSYW5nZTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudDogbmV3IEV2ZW50SW1wbChjb250ZXh0LCBkZWYsIGluc3RhbmNlKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IGNvbnRleHQuZGF0ZUVudi50b0RhdGUocmFuZ2Uuc3RhcnQpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IGNvbnRleHQuZGF0ZUVudi50b0RhdGUocmFuZ2UuZW5kKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXNTdGFydDogc2VnLmlzU3RhcnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzRW5kOiBzZWcuaXNFbmQsXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbW9yZUxpbmtDbGljayA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgICAgIG1vcmVMaW5rQ2xpY2sgPSBtb3JlTGlua0NsaWNrKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWxsRGF5OiBCb29sZWFuKHByb3BzLmFsbERheURhdGUpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxTZWdzOiBwcm9wcy5hbGxTZWdzLm1hcChidWlsZFB1YmxpY1NlZyksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhpZGRlblNlZ3M6IHByb3BzLmhpZGRlblNlZ3MubWFwKGJ1aWxkUHVibGljU2VnKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAganNFdmVudDogZXYsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpZXc6IGNvbnRleHQudmlld0FwaSxcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICghbW9yZUxpbmtDbGljayB8fCBtb3JlTGlua0NsaWNrID09PSAncG9wb3ZlcicpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKHsgaXNQb3BvdmVyT3BlbjogdHJ1ZSB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBtb3JlTGlua0NsaWNrID09PSAnc3RyaW5nJykgeyAvLyBhIHZpZXcgbmFtZVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuY2FsZW5kYXJBcGkuem9vbVRvKGRhdGUsIG1vcmVMaW5rQ2xpY2spO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB0aGlzLmhhbmRsZVBvcG92ZXJDbG9zZSA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoeyBpc1BvcG92ZXJPcGVuOiBmYWxzZSB9KTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVuZGVyKCkge1xyXG4gICAgICAgICAgICBsZXQgeyBwcm9wcywgc3RhdGUgfSA9IHRoaXM7XHJcbiAgICAgICAgICAgIHJldHVybiAoeShWaWV3Q29udGV4dFR5cGUuQ29uc3VtZXIsIG51bGwsIChjb250ZXh0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBsZXQgeyB2aWV3QXBpLCBvcHRpb25zLCBjYWxlbmRhckFwaSB9ID0gY29udGV4dDtcclxuICAgICAgICAgICAgICAgIGxldCB7IG1vcmVMaW5rVGV4dCB9ID0gb3B0aW9ucztcclxuICAgICAgICAgICAgICAgIGxldCB7IG1vcmVDbnQgfSA9IHByb3BzO1xyXG4gICAgICAgICAgICAgICAgbGV0IHJhbmdlID0gY29tcHV0ZVJhbmdlKHByb3BzKTtcclxuICAgICAgICAgICAgICAgIGxldCB0ZXh0ID0gdHlwZW9mIG1vcmVMaW5rVGV4dCA9PT0gJ2Z1bmN0aW9uJyAvLyBUT0RPOiBldmVudHVhbGx5IHVzZSBmb3JtYXRXaXRoT3JkaW5hbHNcclxuICAgICAgICAgICAgICAgICAgICA/IG1vcmVMaW5rVGV4dC5jYWxsKGNhbGVuZGFyQXBpLCBtb3JlQ250KVxyXG4gICAgICAgICAgICAgICAgICAgIDogYCske21vcmVDbnR9ICR7bW9yZUxpbmtUZXh0fWA7XHJcbiAgICAgICAgICAgICAgICBsZXQgaGludCA9IGZvcm1hdFdpdGhPcmRpbmFscyhvcHRpb25zLm1vcmVMaW5rSGludCwgW21vcmVDbnRdLCB0ZXh0KTtcclxuICAgICAgICAgICAgICAgIGxldCByZW5kZXJQcm9wcyA9IHtcclxuICAgICAgICAgICAgICAgICAgICBudW06IG1vcmVDbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgc2hvcnRUZXh0OiBgKyR7bW9yZUNudH1gLFxyXG4gICAgICAgICAgICAgICAgICAgIHRleHQsXHJcbiAgICAgICAgICAgICAgICAgICAgdmlldzogdmlld0FwaSxcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKHkoXywgbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICBCb29sZWFuKHByb3BzLm1vcmVDbnQpICYmICh5KENvbnRlbnRDb250YWluZXIsIHsgZWxUYWc6IHByb3BzLmVsVGFnIHx8ICdhJywgZWxSZWY6IHRoaXMuaGFuZGxlTGlua0VsLCBlbENsYXNzZXM6IFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLihwcm9wcy5lbENsYXNzZXMgfHwgW10pLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2ZjLW1vcmUtbGluaycsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF0sIGVsU3R5bGU6IHByb3BzLmVsU3R5bGUsIGVsQXR0cnM6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwcm9wcy5lbEF0dHJzKSwgY3JlYXRlQXJpYUNsaWNrQXR0cnModGhpcy5oYW5kbGVDbGljaykpLCB7IHRpdGxlOiBoaW50LCAnYXJpYS1leHBhbmRlZCc6IHN0YXRlLmlzUG9wb3Zlck9wZW4sICdhcmlhLWNvbnRyb2xzJzogc3RhdGUuaXNQb3BvdmVyT3BlbiA/IHN0YXRlLnBvcG92ZXJJZCA6ICcnIH0pLCByZW5kZXJQcm9wczogcmVuZGVyUHJvcHMsIGdlbmVyYXRvck5hbWU6IFwibW9yZUxpbmtDb250ZW50XCIsIGN1c3RvbUdlbmVyYXRvcjogb3B0aW9ucy5tb3JlTGlua0NvbnRlbnQsIGRlZmF1bHRHZW5lcmF0b3I6IHByb3BzLmRlZmF1bHRHZW5lcmF0b3IgfHwgcmVuZGVyTW9yZUxpbmtJbm5lciQxLCBjbGFzc05hbWVHZW5lcmF0b3I6IG9wdGlvbnMubW9yZUxpbmtDbGFzc05hbWVzLCBkaWRNb3VudDogb3B0aW9ucy5tb3JlTGlua0RpZE1vdW50LCB3aWxsVW5tb3VudDogb3B0aW9ucy5tb3JlTGlua1dpbGxVbm1vdW50IH0sIHByb3BzLmNoaWxkcmVuKSksXHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuaXNQb3BvdmVyT3BlbiAmJiAoeShNb3JlUG9wb3ZlciwgeyBpZDogc3RhdGUucG9wb3ZlcklkLCBzdGFydERhdGU6IHJhbmdlLnN0YXJ0LCBlbmREYXRlOiByYW5nZS5lbmQsIGRhdGVQcm9maWxlOiBwcm9wcy5kYXRlUHJvZmlsZSwgdG9kYXlSYW5nZTogcHJvcHMudG9kYXlSYW5nZSwgZXh0cmFEYXRlU3BhbjogcHJvcHMuZXh0cmFEYXRlU3BhbiwgcGFyZW50RWw6IHRoaXMucGFyZW50RWwsIGFsaWdubWVudEVsOiBwcm9wcy5hbGlnbm1lbnRFbFJlZiA/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wcy5hbGlnbm1lbnRFbFJlZi5jdXJyZW50IDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGlua0VsLCBhbGlnbkdyaWRUb3A6IHByb3BzLmFsaWduR3JpZFRvcCwgZm9yY2VUaW1lZDogcHJvcHMuZm9yY2VUaW1lZCwgb25DbG9zZTogdGhpcy5oYW5kbGVQb3BvdmVyQ2xvc2UgfSwgcHJvcHMucG9wb3ZlckNvbnRlbnQoKSkpKSk7XHJcbiAgICAgICAgICAgIH0pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29tcG9uZW50RGlkTW91bnQoKSB7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlUGFyZW50RWwoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29tcG9uZW50RGlkVXBkYXRlKCkge1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVBhcmVudEVsKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHVwZGF0ZVBhcmVudEVsKCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5saW5rRWwpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50RWwgPSBlbGVtZW50Q2xvc2VzdCh0aGlzLmxpbmtFbCwgJy5mYy12aWV3LWhhcm5lc3MnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHJlbmRlck1vcmVMaW5rSW5uZXIkMShwcm9wcykge1xyXG4gICAgICAgIHJldHVybiBwcm9wcy50ZXh0O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gY29tcHV0ZVJhbmdlKHByb3BzKSB7XHJcbiAgICAgICAgaWYgKHByb3BzLmFsbERheURhdGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHN0YXJ0OiBwcm9wcy5hbGxEYXlEYXRlLFxyXG4gICAgICAgICAgICAgICAgZW5kOiBhZGREYXlzKHByb3BzLmFsbERheURhdGUsIDEpLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgeyBoaWRkZW5TZWdzIH0gPSBwcm9wcztcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBzdGFydDogY29tcHV0ZUVhcmxpZXN0U2VnU3RhcnQoaGlkZGVuU2VncyksXHJcbiAgICAgICAgICAgIGVuZDogY29tcHV0ZUxhdGVzdFNlZ0VuZChoaWRkZW5TZWdzKSxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gY29tcHV0ZUVhcmxpZXN0U2VnU3RhcnQoc2Vncykge1xyXG4gICAgICAgIHJldHVybiBzZWdzLnJlZHVjZShwaWNrRWFybGllc3RTdGFydCkuZXZlbnRSYW5nZS5yYW5nZS5zdGFydDtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHBpY2tFYXJsaWVzdFN0YXJ0KHNlZzAsIHNlZzEpIHtcclxuICAgICAgICByZXR1cm4gc2VnMC5ldmVudFJhbmdlLnJhbmdlLnN0YXJ0IDwgc2VnMS5ldmVudFJhbmdlLnJhbmdlLnN0YXJ0ID8gc2VnMCA6IHNlZzE7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBjb21wdXRlTGF0ZXN0U2VnRW5kKHNlZ3MpIHtcclxuICAgICAgICByZXR1cm4gc2Vncy5yZWR1Y2UocGlja0xhdGVzdEVuZCkuZXZlbnRSYW5nZS5yYW5nZS5lbmQ7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBwaWNrTGF0ZXN0RW5kKHNlZzAsIHNlZzEpIHtcclxuICAgICAgICByZXR1cm4gc2VnMC5ldmVudFJhbmdlLnJhbmdlLmVuZCA+IHNlZzEuZXZlbnRSYW5nZS5yYW5nZS5lbmQgPyBzZWcwIDogc2VnMTtcclxuICAgIH1cclxuXHJcbiAgICBjbGFzcyBWaWV3Q29udGFpbmVyIGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XHJcbiAgICAgICAgcmVuZGVyKCkge1xyXG4gICAgICAgICAgICBsZXQgeyBwcm9wcywgY29udGV4dCB9ID0gdGhpcztcclxuICAgICAgICAgICAgbGV0IHsgb3B0aW9ucyB9ID0gY29udGV4dDtcclxuICAgICAgICAgICAgbGV0IHJlbmRlclByb3BzID0geyB2aWV3OiBjb250ZXh0LnZpZXdBcGkgfTtcclxuICAgICAgICAgICAgcmV0dXJuICh5KENvbnRlbnRDb250YWluZXIsIE9iamVjdC5hc3NpZ24oe30sIHByb3BzLCB7IGVsVGFnOiBwcm9wcy5lbFRhZyB8fCAnZGl2JywgZWxDbGFzc2VzOiBbXHJcbiAgICAgICAgICAgICAgICAgICAgLi4uYnVpbGRWaWV3Q2xhc3NOYW1lcyhwcm9wcy52aWV3U3BlYyksXHJcbiAgICAgICAgICAgICAgICAgICAgLi4uKHByb3BzLmVsQ2xhc3NlcyB8fCBbXSksXHJcbiAgICAgICAgICAgICAgICBdLCByZW5kZXJQcm9wczogcmVuZGVyUHJvcHMsIGNsYXNzTmFtZUdlbmVyYXRvcjogb3B0aW9ucy52aWV3Q2xhc3NOYW1lcywgZ2VuZXJhdG9yTmFtZTogdW5kZWZpbmVkLCBkaWRNb3VudDogb3B0aW9ucy52aWV3RGlkTW91bnQsIHdpbGxVbm1vdW50OiBvcHRpb25zLnZpZXdXaWxsVW5tb3VudCB9KSwgKCkgPT4gcHJvcHMuY2hpbGRyZW4pKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBidWlsZFZpZXdDbGFzc05hbWVzKHZpZXdTcGVjKSB7XHJcbiAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgYGZjLSR7dmlld1NwZWMudHlwZX0tdmlld2AsXHJcbiAgICAgICAgICAgICdmYy12aWV3JyxcclxuICAgICAgICBdO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IEVWRU5UX1NPVVJDRV9SRUZJTkVSUyA9IHtcclxuICAgICAgICBpZDogU3RyaW5nLFxyXG4gICAgICAgIGRlZmF1bHRBbGxEYXk6IEJvb2xlYW4sXHJcbiAgICAgICAgdXJsOiBTdHJpbmcsXHJcbiAgICAgICAgZm9ybWF0OiBTdHJpbmcsXHJcbiAgICAgICAgZXZlbnRzOiBpZGVudGl0eSxcclxuICAgICAgICBldmVudERhdGFUcmFuc2Zvcm06IGlkZW50aXR5LFxyXG4gICAgICAgIC8vIGZvciBhbnkgbmV0d29yay1yZWxhdGVkIHNvdXJjZXNcclxuICAgICAgICBzdWNjZXNzOiBpZGVudGl0eSxcclxuICAgICAgICBmYWlsdXJlOiBpZGVudGl0eSxcclxuICAgIH07XHJcbiAgICBmdW5jdGlvbiBwYXJzZUV2ZW50U291cmNlKHJhdywgY29udGV4dCwgcmVmaW5lcnMgPSBidWlsZEV2ZW50U291cmNlUmVmaW5lcnMoY29udGV4dCkpIHtcclxuICAgICAgICBsZXQgcmF3T2JqO1xyXG4gICAgICAgIGlmICh0eXBlb2YgcmF3ID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICByYXdPYmogPSB7IHVybDogcmF3IH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiByYXcgPT09ICdmdW5jdGlvbicgfHwgQXJyYXkuaXNBcnJheShyYXcpKSB7XHJcbiAgICAgICAgICAgIHJhd09iaiA9IHsgZXZlbnRzOiByYXcgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHJhdyA9PT0gJ29iamVjdCcgJiYgcmF3KSB7IC8vIG5vdCBudWxsXHJcbiAgICAgICAgICAgIHJhd09iaiA9IHJhdztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJhd09iaikge1xyXG4gICAgICAgICAgICBsZXQgeyByZWZpbmVkLCBleHRyYSB9ID0gcmVmaW5lUHJvcHMocmF3T2JqLCByZWZpbmVycyk7XHJcbiAgICAgICAgICAgIGxldCBtZXRhUmVzID0gYnVpbGRFdmVudFNvdXJjZU1ldGEocmVmaW5lZCwgY29udGV4dCk7XHJcbiAgICAgICAgICAgIGlmIChtZXRhUmVzKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIF9yYXc6IHJhdyxcclxuICAgICAgICAgICAgICAgICAgICBpc0ZldGNoaW5nOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICBsYXRlc3RGZXRjaElkOiAnJyxcclxuICAgICAgICAgICAgICAgICAgICBmZXRjaFJhbmdlOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRBbGxEYXk6IHJlZmluZWQuZGVmYXVsdEFsbERheSxcclxuICAgICAgICAgICAgICAgICAgICBldmVudERhdGFUcmFuc2Zvcm06IHJlZmluZWQuZXZlbnREYXRhVHJhbnNmb3JtLFxyXG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IHJlZmluZWQuc3VjY2VzcyxcclxuICAgICAgICAgICAgICAgICAgICBmYWlsdXJlOiByZWZpbmVkLmZhaWx1cmUsXHJcbiAgICAgICAgICAgICAgICAgICAgcHVibGljSWQ6IHJlZmluZWQuaWQgfHwgJycsXHJcbiAgICAgICAgICAgICAgICAgICAgc291cmNlSWQ6IGd1aWQoKSxcclxuICAgICAgICAgICAgICAgICAgICBzb3VyY2VEZWZJZDogbWV0YVJlcy5zb3VyY2VEZWZJZCxcclxuICAgICAgICAgICAgICAgICAgICBtZXRhOiBtZXRhUmVzLm1ldGEsXHJcbiAgICAgICAgICAgICAgICAgICAgdWk6IGNyZWF0ZUV2ZW50VWkocmVmaW5lZCwgY29udGV4dCksXHJcbiAgICAgICAgICAgICAgICAgICAgZXh0ZW5kZWRQcm9wczogZXh0cmEsXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYnVpbGRFdmVudFNvdXJjZVJlZmluZXJzKGNvbnRleHQpIHtcclxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIEVWRU5UX1VJX1JFRklORVJTKSwgRVZFTlRfU09VUkNFX1JFRklORVJTKSwgY29udGV4dC5wbHVnaW5Ib29rcy5ldmVudFNvdXJjZVJlZmluZXJzKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGJ1aWxkRXZlbnRTb3VyY2VNZXRhKHJhdywgY29udGV4dCkge1xyXG4gICAgICAgIGxldCBkZWZzID0gY29udGV4dC5wbHVnaW5Ib29rcy5ldmVudFNvdXJjZURlZnM7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IGRlZnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpIC09IDEpIHsgLy8gbGF0ZXItYWRkZWQgcGx1Z2lucyB0YWtlIHByZWNlZGVuY2VcclxuICAgICAgICAgICAgbGV0IGRlZiA9IGRlZnNbaV07XHJcbiAgICAgICAgICAgIGxldCBtZXRhID0gZGVmLnBhcnNlTWV0YShyYXcpO1xyXG4gICAgICAgICAgICBpZiAobWV0YSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgc291cmNlRGVmSWQ6IGksIG1ldGEgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBjbGFzcyBDYWxlbmRhckltcGwge1xyXG4gICAgICAgIGdldEN1cnJlbnREYXRhKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50RGF0YU1hbmFnZXIuZ2V0Q3VycmVudERhdGEoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZGlzcGF0Y2goYWN0aW9uKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudERhdGFNYW5hZ2VyLmRpc3BhdGNoKGFjdGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGdldCB2aWV3KCkgeyByZXR1cm4gdGhpcy5nZXRDdXJyZW50RGF0YSgpLnZpZXdBcGk7IH1cclxuICAgICAgICBiYXRjaFJlbmRlcmluZyhjYWxsYmFjaykge1xyXG4gICAgICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB1cGRhdGVTaXplKCkge1xyXG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ19yZXNpemUnLCB0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gT3B0aW9uc1xyXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAgICAgc2V0T3B0aW9uKG5hbWUsIHZhbCkge1xyXG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoKHtcclxuICAgICAgICAgICAgICAgIHR5cGU6ICdTRVRfT1BUSU9OJyxcclxuICAgICAgICAgICAgICAgIG9wdGlvbk5hbWU6IG5hbWUsXHJcbiAgICAgICAgICAgICAgICByYXdPcHRpb25WYWx1ZTogdmFsLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZ2V0T3B0aW9uKG5hbWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudERhdGFNYW5hZ2VyLmN1cnJlbnRDYWxlbmRhck9wdGlvbnNJbnB1dFtuYW1lXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZ2V0QXZhaWxhYmxlTG9jYWxlQ29kZXMoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLmdldEN1cnJlbnREYXRhKCkuYXZhaWxhYmxlUmF3TG9jYWxlcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFRyaWdnZXJcclxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgICAgIG9uKGhhbmRsZXJOYW1lLCBoYW5kbGVyKSB7XHJcbiAgICAgICAgICAgIGxldCB7IGN1cnJlbnREYXRhTWFuYWdlciB9ID0gdGhpcztcclxuICAgICAgICAgICAgaWYgKGN1cnJlbnREYXRhTWFuYWdlci5jdXJyZW50Q2FsZW5kYXJPcHRpb25zUmVmaW5lcnNbaGFuZGxlck5hbWVdKSB7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50RGF0YU1hbmFnZXIuZW1pdHRlci5vbihoYW5kbGVyTmFtZSwgaGFuZGxlcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYFVua25vd24gbGlzdGVuZXIgbmFtZSAnJHtoYW5kbGVyTmFtZX0nYCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgb2ZmKGhhbmRsZXJOYW1lLCBoYW5kbGVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudERhdGFNYW5hZ2VyLmVtaXR0ZXIub2ZmKGhhbmRsZXJOYW1lLCBoYW5kbGVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gbm90IG1lYW50IGZvciBwdWJsaWMgdXNlXHJcbiAgICAgICAgdHJpZ2dlcihoYW5kbGVyTmFtZSwgLi4uYXJncykge1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnREYXRhTWFuYWdlci5lbWl0dGVyLnRyaWdnZXIoaGFuZGxlck5hbWUsIC4uLmFyZ3MpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBWaWV3XHJcbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgICAgICBjaGFuZ2VWaWV3KHZpZXdUeXBlLCBkYXRlT3JSYW5nZSkge1xyXG4gICAgICAgICAgICB0aGlzLmJhdGNoUmVuZGVyaW5nKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMudW5zZWxlY3QoKTtcclxuICAgICAgICAgICAgICAgIGlmIChkYXRlT3JSYW5nZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRlT3JSYW5nZS5zdGFydCAmJiBkYXRlT3JSYW5nZS5lbmQpIHsgLy8gYSByYW5nZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdDSEFOR0VfVklFV19UWVBFJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpZXdUeXBlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnU0VUX09QVElPTicsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25OYW1lOiAndmlzaWJsZVJhbmdlJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhd09wdGlvblZhbHVlOiBkYXRlT3JSYW5nZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgeyBkYXRlRW52IH0gPSB0aGlzLmdldEN1cnJlbnREYXRhKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ0NIQU5HRV9WSUVXX1RZUEUnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlld1R5cGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRlTWFya2VyOiBkYXRlRW52LmNyZWF0ZU1hcmtlcihkYXRlT3JSYW5nZSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnQ0hBTkdFX1ZJRVdfVFlQRScsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpZXdUeXBlLFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gRm9yY2VzIG5hdmlnYXRpb24gdG8gYSB2aWV3IGZvciB0aGUgZ2l2ZW4gZGF0ZS5cclxuICAgICAgICAvLyBgdmlld1R5cGVgIGNhbiBiZSBhIHNwZWNpZmljIHZpZXcgbmFtZSBvciBhIGdlbmVyaWMgb25lIGxpa2UgXCJ3ZWVrXCIgb3IgXCJkYXlcIi5cclxuICAgICAgICAvLyBuZWVkcyB0byBjaGFuZ2VcclxuICAgICAgICB6b29tVG8oZGF0ZU1hcmtlciwgdmlld1R5cGUpIHtcclxuICAgICAgICAgICAgbGV0IHN0YXRlID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpO1xyXG4gICAgICAgICAgICBsZXQgc3BlYztcclxuICAgICAgICAgICAgdmlld1R5cGUgPSB2aWV3VHlwZSB8fCAnZGF5JzsgLy8gZGF5IGlzIGRlZmF1bHQgem9vbVxyXG4gICAgICAgICAgICBzcGVjID0gc3RhdGUudmlld1NwZWNzW3ZpZXdUeXBlXSB8fCB0aGlzLmdldFVuaXRWaWV3U3BlYyh2aWV3VHlwZSk7XHJcbiAgICAgICAgICAgIHRoaXMudW5zZWxlY3QoKTtcclxuICAgICAgICAgICAgaWYgKHNwZWMpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goe1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdDSEFOR0VfVklFV19UWVBFJyxcclxuICAgICAgICAgICAgICAgICAgICB2aWV3VHlwZTogc3BlYy50eXBlLFxyXG4gICAgICAgICAgICAgICAgICAgIGRhdGVNYXJrZXIsXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goe1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdDSEFOR0VfREFURScsXHJcbiAgICAgICAgICAgICAgICAgICAgZGF0ZU1hcmtlcixcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEdpdmVuIGEgZHVyYXRpb24gc2luZ3VsYXIgdW5pdCwgbGlrZSBcIndlZWtcIiBvciBcImRheVwiLCBmaW5kcyBhIG1hdGNoaW5nIHZpZXcgc3BlYy5cclxuICAgICAgICAvLyBQcmVmZXJlbmNlIGlzIGdpdmVuIHRvIHZpZXdzIHRoYXQgaGF2ZSBjb3JyZXNwb25kaW5nIGJ1dHRvbnMuXHJcbiAgICAgICAgZ2V0VW5pdFZpZXdTcGVjKHVuaXQpIHtcclxuICAgICAgICAgICAgbGV0IHsgdmlld1NwZWNzLCB0b29sYmFyQ29uZmlnIH0gPSB0aGlzLmdldEN1cnJlbnREYXRhKCk7XHJcbiAgICAgICAgICAgIGxldCB2aWV3VHlwZXMgPSBbXS5jb25jYXQodG9vbGJhckNvbmZpZy5oZWFkZXIgPyB0b29sYmFyQ29uZmlnLmhlYWRlci52aWV3c1dpdGhCdXR0b25zIDogW10sIHRvb2xiYXJDb25maWcuZm9vdGVyID8gdG9vbGJhckNvbmZpZy5mb290ZXIudmlld3NXaXRoQnV0dG9ucyA6IFtdKTtcclxuICAgICAgICAgICAgbGV0IGk7XHJcbiAgICAgICAgICAgIGxldCBzcGVjO1xyXG4gICAgICAgICAgICBmb3IgKGxldCB2aWV3VHlwZSBpbiB2aWV3U3BlY3MpIHtcclxuICAgICAgICAgICAgICAgIHZpZXdUeXBlcy5wdXNoKHZpZXdUeXBlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdmlld1R5cGVzLmxlbmd0aDsgaSArPSAxKSB7XHJcbiAgICAgICAgICAgICAgICBzcGVjID0gdmlld1NwZWNzW3ZpZXdUeXBlc1tpXV07XHJcbiAgICAgICAgICAgICAgICBpZiAoc3BlYykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzcGVjLnNpbmdsZVVuaXQgPT09IHVuaXQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNwZWM7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBDdXJyZW50IERhdGVcclxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgICAgIHByZXYoKSB7XHJcbiAgICAgICAgICAgIHRoaXMudW5zZWxlY3QoKTtcclxuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaCh7IHR5cGU6ICdQUkVWJyB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbmV4dCgpIHtcclxuICAgICAgICAgICAgdGhpcy51bnNlbGVjdCgpO1xyXG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoKHsgdHlwZTogJ05FWFQnIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwcmV2WWVhcigpIHtcclxuICAgICAgICAgICAgbGV0IHN0YXRlID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpO1xyXG4gICAgICAgICAgICB0aGlzLnVuc2VsZWN0KCk7XHJcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goe1xyXG4gICAgICAgICAgICAgICAgdHlwZTogJ0NIQU5HRV9EQVRFJyxcclxuICAgICAgICAgICAgICAgIGRhdGVNYXJrZXI6IHN0YXRlLmRhdGVFbnYuYWRkWWVhcnMoc3RhdGUuY3VycmVudERhdGUsIC0xKSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG5leHRZZWFyKCkge1xyXG4gICAgICAgICAgICBsZXQgc3RhdGUgPSB0aGlzLmdldEN1cnJlbnREYXRhKCk7XHJcbiAgICAgICAgICAgIHRoaXMudW5zZWxlY3QoKTtcclxuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaCh7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiAnQ0hBTkdFX0RBVEUnLFxyXG4gICAgICAgICAgICAgICAgZGF0ZU1hcmtlcjogc3RhdGUuZGF0ZUVudi5hZGRZZWFycyhzdGF0ZS5jdXJyZW50RGF0ZSwgMSksXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0b2RheSgpIHtcclxuICAgICAgICAgICAgbGV0IHN0YXRlID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpO1xyXG4gICAgICAgICAgICB0aGlzLnVuc2VsZWN0KCk7XHJcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goe1xyXG4gICAgICAgICAgICAgICAgdHlwZTogJ0NIQU5HRV9EQVRFJyxcclxuICAgICAgICAgICAgICAgIGRhdGVNYXJrZXI6IGdldE5vdyhzdGF0ZS5jYWxlbmRhck9wdGlvbnMubm93LCBzdGF0ZS5kYXRlRW52KSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGdvdG9EYXRlKHpvbmVkRGF0ZUlucHV0KSB7XHJcbiAgICAgICAgICAgIGxldCBzdGF0ZSA9IHRoaXMuZ2V0Q3VycmVudERhdGEoKTtcclxuICAgICAgICAgICAgdGhpcy51bnNlbGVjdCgpO1xyXG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoKHtcclxuICAgICAgICAgICAgICAgIHR5cGU6ICdDSEFOR0VfREFURScsXHJcbiAgICAgICAgICAgICAgICBkYXRlTWFya2VyOiBzdGF0ZS5kYXRlRW52LmNyZWF0ZU1hcmtlcih6b25lZERhdGVJbnB1dCksXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpbmNyZW1lbnREYXRlKGRlbHRhSW5wdXQpIHtcclxuICAgICAgICAgICAgbGV0IHN0YXRlID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpO1xyXG4gICAgICAgICAgICBsZXQgZGVsdGEgPSBjcmVhdGVEdXJhdGlvbihkZWx0YUlucHV0KTtcclxuICAgICAgICAgICAgaWYgKGRlbHRhKSB7IC8vIGVsc2UsIHdhcm4gYWJvdXQgaW52YWxpZCBpbnB1dD9cclxuICAgICAgICAgICAgICAgIHRoaXMudW5zZWxlY3QoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goe1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdDSEFOR0VfREFURScsXHJcbiAgICAgICAgICAgICAgICAgICAgZGF0ZU1hcmtlcjogc3RhdGUuZGF0ZUVudi5hZGQoc3RhdGUuY3VycmVudERhdGUsIGRlbHRhKSxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGdldERhdGUoKSB7XHJcbiAgICAgICAgICAgIGxldCBzdGF0ZSA9IHRoaXMuZ2V0Q3VycmVudERhdGEoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHN0YXRlLmRhdGVFbnYudG9EYXRlKHN0YXRlLmN1cnJlbnREYXRlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gRGF0ZSBGb3JtYXR0aW5nIFV0aWxzXHJcbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgICAgICBmb3JtYXREYXRlKGQsIGZvcm1hdHRlcikge1xyXG4gICAgICAgICAgICBsZXQgeyBkYXRlRW52IH0gPSB0aGlzLmdldEN1cnJlbnREYXRhKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBkYXRlRW52LmZvcm1hdChkYXRlRW52LmNyZWF0ZU1hcmtlcihkKSwgY3JlYXRlRm9ybWF0dGVyKGZvcm1hdHRlcikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBgc2V0dGluZ3NgIGlzIGZvciBmb3JtYXR0ZXIgQU5EIGlzRW5kRXhjbHVzaXZlXHJcbiAgICAgICAgZm9ybWF0UmFuZ2UoZDAsIGQxLCBzZXR0aW5ncykge1xyXG4gICAgICAgICAgICBsZXQgeyBkYXRlRW52IH0gPSB0aGlzLmdldEN1cnJlbnREYXRhKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBkYXRlRW52LmZvcm1hdFJhbmdlKGRhdGVFbnYuY3JlYXRlTWFya2VyKGQwKSwgZGF0ZUVudi5jcmVhdGVNYXJrZXIoZDEpLCBjcmVhdGVGb3JtYXR0ZXIoc2V0dGluZ3MpLCBzZXR0aW5ncyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvcm1hdElzbyhkLCBvbWl0VGltZSkge1xyXG4gICAgICAgICAgICBsZXQgeyBkYXRlRW52IH0gPSB0aGlzLmdldEN1cnJlbnREYXRhKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBkYXRlRW52LmZvcm1hdElzbyhkYXRlRW52LmNyZWF0ZU1hcmtlcihkKSwgeyBvbWl0VGltZSB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gRGF0ZSBTZWxlY3Rpb24gLyBFdmVudCBTZWxlY3Rpb24gLyBEYXlDbGlja1xyXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAgICAgc2VsZWN0KGRhdGVPck9iaiwgZW5kRGF0ZSkge1xyXG4gICAgICAgICAgICBsZXQgc2VsZWN0aW9uSW5wdXQ7XHJcbiAgICAgICAgICAgIGlmIChlbmREYXRlID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGlmIChkYXRlT3JPYmouc3RhcnQgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbklucHV0ID0gZGF0ZU9yT2JqO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uSW5wdXQgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBkYXRlT3JPYmosXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uSW5wdXQgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IGRhdGVPck9iaixcclxuICAgICAgICAgICAgICAgICAgICBlbmQ6IGVuZERhdGUsXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxldCBzdGF0ZSA9IHRoaXMuZ2V0Q3VycmVudERhdGEoKTtcclxuICAgICAgICAgICAgbGV0IHNlbGVjdGlvbiA9IHBhcnNlRGF0ZVNwYW4oc2VsZWN0aW9uSW5wdXQsIHN0YXRlLmRhdGVFbnYsIGNyZWF0ZUR1cmF0aW9uKHsgZGF5czogMSB9KSk7XHJcbiAgICAgICAgICAgIGlmIChzZWxlY3Rpb24pIHsgLy8gdGhyb3cgcGFyc2UgZXJyb3Igb3RoZXJ3aXNlP1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaCh7IHR5cGU6ICdTRUxFQ1RfREFURVMnLCBzZWxlY3Rpb24gfSk7XHJcbiAgICAgICAgICAgICAgICB0cmlnZ2VyRGF0ZVNlbGVjdChzZWxlY3Rpb24sIG51bGwsIHN0YXRlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB1bnNlbGVjdChwZXYpIHtcclxuICAgICAgICAgICAgbGV0IHN0YXRlID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpO1xyXG4gICAgICAgICAgICBpZiAoc3RhdGUuZGF0ZVNlbGVjdGlvbikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaCh7IHR5cGU6ICdVTlNFTEVDVF9EQVRFUycgfSk7XHJcbiAgICAgICAgICAgICAgICB0cmlnZ2VyRGF0ZVVuc2VsZWN0KHBldiwgc3RhdGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFB1YmxpYyBFdmVudHMgQVBJXHJcbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgICAgICBhZGRFdmVudChldmVudElucHV0LCBzb3VyY2VJbnB1dCkge1xyXG4gICAgICAgICAgICBpZiAoZXZlbnRJbnB1dCBpbnN0YW5jZW9mIEV2ZW50SW1wbCkge1xyXG4gICAgICAgICAgICAgICAgbGV0IGRlZiA9IGV2ZW50SW5wdXQuX2RlZjtcclxuICAgICAgICAgICAgICAgIGxldCBpbnN0YW5jZSA9IGV2ZW50SW5wdXQuX2luc3RhbmNlO1xyXG4gICAgICAgICAgICAgICAgbGV0IGN1cnJlbnREYXRhID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpO1xyXG4gICAgICAgICAgICAgICAgLy8gbm90IGFscmVhZHkgcHJlc2VudD8gZG9uJ3Qgd2FudCB0byBhZGQgYW4gb2xkIHNuYXBzaG90XHJcbiAgICAgICAgICAgICAgICBpZiAoIWN1cnJlbnREYXRhLmV2ZW50U3RvcmUuZGVmc1tkZWYuZGVmSWRdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdBRERfRVZFTlRTJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRTdG9yZTogZXZlbnRUdXBsZVRvU3RvcmUoeyBkZWYsIGluc3RhbmNlIH0pLCAvLyBUT0RPOiBiZXR0ZXIgdXRpbCBmb3IgdHdvIGFyZ3M/XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyRXZlbnRBZGQoZXZlbnRJbnB1dCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZXZlbnRJbnB1dDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgc3RhdGUgPSB0aGlzLmdldEN1cnJlbnREYXRhKCk7XHJcbiAgICAgICAgICAgIGxldCBldmVudFNvdXJjZTtcclxuICAgICAgICAgICAgaWYgKHNvdXJjZUlucHV0IGluc3RhbmNlb2YgRXZlbnRTb3VyY2VJbXBsKSB7XHJcbiAgICAgICAgICAgICAgICBldmVudFNvdXJjZSA9IHNvdXJjZUlucHV0LmludGVybmFsRXZlbnRTb3VyY2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHNvdXJjZUlucHV0ID09PSAnYm9vbGVhbicpIHtcclxuICAgICAgICAgICAgICAgIGlmIChzb3VyY2VJbnB1dCkgeyAvLyB0cnVlLiBwYXJ0IG9mIHRoZSBmaXJzdCBldmVudCBzb3VyY2VcclxuICAgICAgICAgICAgICAgICAgICBbZXZlbnRTb3VyY2VdID0gaGFzaFZhbHVlc1RvQXJyYXkoc3RhdGUuZXZlbnRTb3VyY2VzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChzb3VyY2VJbnB1dCAhPSBudWxsKSB7IC8vIGFuIElELiBhY2NlcHRzIGEgbnVtYmVyIHRvb1xyXG4gICAgICAgICAgICAgICAgbGV0IHNvdXJjZUFwaSA9IHRoaXMuZ2V0RXZlbnRTb3VyY2VCeUlkKHNvdXJjZUlucHV0KTsgLy8gVE9ETzogdXNlIGFuIGludGVybmFsIGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICBpZiAoIXNvdXJjZUFwaSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgQ291bGQgbm90IGZpbmQgYW4gZXZlbnQgc291cmNlIHdpdGggSUQgXCIke3NvdXJjZUlucHV0fVwiYCk7IC8vIFRPRE86IHRlc3RcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGV2ZW50U291cmNlID0gc291cmNlQXBpLmludGVybmFsRXZlbnRTb3VyY2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IHR1cGxlID0gcGFyc2VFdmVudChldmVudElucHV0LCBldmVudFNvdXJjZSwgc3RhdGUsIGZhbHNlKTtcclxuICAgICAgICAgICAgaWYgKHR1cGxlKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgbmV3RXZlbnRBcGkgPSBuZXcgRXZlbnRJbXBsKHN0YXRlLCB0dXBsZS5kZWYsIHR1cGxlLmRlZi5yZWN1cnJpbmdEZWYgPyBudWxsIDogdHVwbGUuaW5zdGFuY2UpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ0FERF9FVkVOVFMnLFxyXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50U3RvcmU6IGV2ZW50VHVwbGVUb1N0b3JlKHR1cGxlKSxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyRXZlbnRBZGQobmV3RXZlbnRBcGkpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ld0V2ZW50QXBpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0cmlnZ2VyRXZlbnRBZGQoZXZlbnRBcGkpIHtcclxuICAgICAgICAgICAgbGV0IHsgZW1pdHRlciB9ID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpO1xyXG4gICAgICAgICAgICBlbWl0dGVyLnRyaWdnZXIoJ2V2ZW50QWRkJywge1xyXG4gICAgICAgICAgICAgICAgZXZlbnQ6IGV2ZW50QXBpLFxyXG4gICAgICAgICAgICAgICAgcmVsYXRlZEV2ZW50czogW10sXHJcbiAgICAgICAgICAgICAgICByZXZlcnQ6ICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ1JFTU9WRV9FVkVOVFMnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudFN0b3JlOiBldmVudEFwaVRvU3RvcmUoZXZlbnRBcGkpLFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFRPRE86IG9wdGltaXplXHJcbiAgICAgICAgZ2V0RXZlbnRCeUlkKGlkKSB7XHJcbiAgICAgICAgICAgIGxldCBzdGF0ZSA9IHRoaXMuZ2V0Q3VycmVudERhdGEoKTtcclxuICAgICAgICAgICAgbGV0IHsgZGVmcywgaW5zdGFuY2VzIH0gPSBzdGF0ZS5ldmVudFN0b3JlO1xyXG4gICAgICAgICAgICBpZCA9IFN0cmluZyhpZCk7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGRlZklkIGluIGRlZnMpIHtcclxuICAgICAgICAgICAgICAgIGxldCBkZWYgPSBkZWZzW2RlZklkXTtcclxuICAgICAgICAgICAgICAgIGlmIChkZWYucHVibGljSWQgPT09IGlkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlZi5yZWN1cnJpbmdEZWYpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBFdmVudEltcGwoc3RhdGUsIGRlZiwgbnVsbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGluc3RhbmNlSWQgaW4gaW5zdGFuY2VzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBpbnN0YW5jZSA9IGluc3RhbmNlc1tpbnN0YW5jZUlkXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluc3RhbmNlLmRlZklkID09PSBkZWYuZGVmSWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRXZlbnRJbXBsKHN0YXRlLCBkZWYsIGluc3RhbmNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZ2V0RXZlbnRzKCkge1xyXG4gICAgICAgICAgICBsZXQgY3VycmVudERhdGEgPSB0aGlzLmdldEN1cnJlbnREYXRhKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBidWlsZEV2ZW50QXBpcyhjdXJyZW50RGF0YS5ldmVudFN0b3JlLCBjdXJyZW50RGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlbW92ZUFsbEV2ZW50cygpIHtcclxuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaCh7IHR5cGU6ICdSRU1PVkVfQUxMX0VWRU5UUycgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFB1YmxpYyBFdmVudCBTb3VyY2VzIEFQSVxyXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAgICAgZ2V0RXZlbnRTb3VyY2VzKCkge1xyXG4gICAgICAgICAgICBsZXQgc3RhdGUgPSB0aGlzLmdldEN1cnJlbnREYXRhKCk7XHJcbiAgICAgICAgICAgIGxldCBzb3VyY2VIYXNoID0gc3RhdGUuZXZlbnRTb3VyY2VzO1xyXG4gICAgICAgICAgICBsZXQgc291cmNlQXBpcyA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpbnRlcm5hbElkIGluIHNvdXJjZUhhc2gpIHtcclxuICAgICAgICAgICAgICAgIHNvdXJjZUFwaXMucHVzaChuZXcgRXZlbnRTb3VyY2VJbXBsKHN0YXRlLCBzb3VyY2VIYXNoW2ludGVybmFsSWRdKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHNvdXJjZUFwaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGdldEV2ZW50U291cmNlQnlJZChpZCkge1xyXG4gICAgICAgICAgICBsZXQgc3RhdGUgPSB0aGlzLmdldEN1cnJlbnREYXRhKCk7XHJcbiAgICAgICAgICAgIGxldCBzb3VyY2VIYXNoID0gc3RhdGUuZXZlbnRTb3VyY2VzO1xyXG4gICAgICAgICAgICBpZCA9IFN0cmluZyhpZCk7XHJcbiAgICAgICAgICAgIGZvciAobGV0IHNvdXJjZUlkIGluIHNvdXJjZUhhc2gpIHtcclxuICAgICAgICAgICAgICAgIGlmIChzb3VyY2VIYXNoW3NvdXJjZUlkXS5wdWJsaWNJZCA9PT0gaWQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEV2ZW50U291cmNlSW1wbChzdGF0ZSwgc291cmNlSGFzaFtzb3VyY2VJZF0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBhZGRFdmVudFNvdXJjZShzb3VyY2VJbnB1dCkge1xyXG4gICAgICAgICAgICBsZXQgc3RhdGUgPSB0aGlzLmdldEN1cnJlbnREYXRhKCk7XHJcbiAgICAgICAgICAgIGlmIChzb3VyY2VJbnB1dCBpbnN0YW5jZW9mIEV2ZW50U291cmNlSW1wbCkge1xyXG4gICAgICAgICAgICAgICAgLy8gbm90IGFscmVhZHkgcHJlc2VudD8gZG9uJ3Qgd2FudCB0byBhZGQgYW4gb2xkIHNuYXBzaG90XHJcbiAgICAgICAgICAgICAgICBpZiAoIXN0YXRlLmV2ZW50U291cmNlc1tzb3VyY2VJbnB1dC5pbnRlcm5hbEV2ZW50U291cmNlLnNvdXJjZUlkXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnQUREX0VWRU5UX1NPVVJDRVMnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VzOiBbc291cmNlSW5wdXQuaW50ZXJuYWxFdmVudFNvdXJjZV0sXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc291cmNlSW5wdXQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IGV2ZW50U291cmNlID0gcGFyc2VFdmVudFNvdXJjZShzb3VyY2VJbnB1dCwgc3RhdGUpO1xyXG4gICAgICAgICAgICBpZiAoZXZlbnRTb3VyY2UpIHsgLy8gVE9ETzogZXJyb3Igb3RoZXJ3aXNlP1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaCh7IHR5cGU6ICdBRERfRVZFTlRfU09VUkNFUycsIHNvdXJjZXM6IFtldmVudFNvdXJjZV0gfSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEV2ZW50U291cmNlSW1wbChzdGF0ZSwgZXZlbnRTb3VyY2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZW1vdmVBbGxFdmVudFNvdXJjZXMoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goeyB0eXBlOiAnUkVNT1ZFX0FMTF9FVkVOVF9TT1VSQ0VTJyB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVmZXRjaEV2ZW50cygpIHtcclxuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaCh7IHR5cGU6ICdGRVRDSF9FVkVOVF9TT1VSQ0VTJywgaXNSZWZldGNoOiB0cnVlIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBTY3JvbGxcclxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgICAgIHNjcm9sbFRvVGltZSh0aW1lSW5wdXQpIHtcclxuICAgICAgICAgICAgbGV0IHRpbWUgPSBjcmVhdGVEdXJhdGlvbih0aW1lSW5wdXQpO1xyXG4gICAgICAgICAgICBpZiAodGltZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCdfc2Nyb2xsUmVxdWVzdCcsIHsgdGltZSB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBjbGFzcyBTdG9yZSB7XHJcbiAgICAgICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlcnMgPSBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc2V0KHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGhhbmRsZXIgb2YgdGhpcy5oYW5kbGVycykge1xyXG4gICAgICAgICAgICAgICAgaGFuZGxlcih2YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgc3Vic2NyaWJlKGhhbmRsZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5oYW5kbGVycy5wdXNoKGhhbmRsZXIpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50VmFsdWUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgaGFuZGxlcih0aGlzLmN1cnJlbnRWYWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLypcclxuICAgIFN1YnNjcmliZXJzIHdpbGwgZ2V0IGEgTElTVCBvZiBDdXN0b21SZW5kZXJpbmdzXHJcbiAgICAqL1xyXG4gICAgY2xhc3MgQ3VzdG9tUmVuZGVyaW5nU3RvcmUgZXh0ZW5kcyBTdG9yZSB7XHJcbiAgICAgICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgIHRoaXMubWFwID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBmb3IgY29uc2lzdGVudCBvcmRlclxyXG4gICAgICAgIGhhbmRsZShjdXN0b21SZW5kZXJpbmcpIHtcclxuICAgICAgICAgICAgY29uc3QgeyBtYXAgfSA9IHRoaXM7XHJcbiAgICAgICAgICAgIGxldCB1cGRhdGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGlmIChjdXN0b21SZW5kZXJpbmcuaXNBY3RpdmUpIHtcclxuICAgICAgICAgICAgICAgIG1hcC5zZXQoY3VzdG9tUmVuZGVyaW5nLmlkLCBjdXN0b21SZW5kZXJpbmcpO1xyXG4gICAgICAgICAgICAgICAgdXBkYXRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAobWFwLmhhcyhjdXN0b21SZW5kZXJpbmcuaWQpKSB7XHJcbiAgICAgICAgICAgICAgICBtYXAuZGVsZXRlKGN1c3RvbVJlbmRlcmluZy5pZCk7XHJcbiAgICAgICAgICAgICAgICB1cGRhdGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodXBkYXRlZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXQobWFwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB2YXIgaW50ZXJuYWwgPSB7XHJcbiAgICAgICAgX19wcm90b19fOiBudWxsLFxyXG4gICAgICAgIEJBU0VfT1BUSU9OX0RFRkFVTFRTOiBCQVNFX09QVElPTl9ERUZBVUxUUyxcclxuICAgICAgICBCYXNlQ29tcG9uZW50OiBCYXNlQ29tcG9uZW50LFxyXG4gICAgICAgIEJnRXZlbnQ6IEJnRXZlbnQsXHJcbiAgICAgICAgQ2FsZW5kYXJJbXBsOiBDYWxlbmRhckltcGwsXHJcbiAgICAgICAgQ2FsZW5kYXJSb290OiBDYWxlbmRhclJvb3QsXHJcbiAgICAgICAgQ29udGVudENvbnRhaW5lcjogQ29udGVudENvbnRhaW5lcixcclxuICAgICAgICBDdXN0b21SZW5kZXJpbmdTdG9yZTogQ3VzdG9tUmVuZGVyaW5nU3RvcmUsXHJcbiAgICAgICAgRGF0ZUNvbXBvbmVudDogRGF0ZUNvbXBvbmVudCxcclxuICAgICAgICBEYXRlRW52OiBEYXRlRW52LFxyXG4gICAgICAgIERhdGVQcm9maWxlR2VuZXJhdG9yOiBEYXRlUHJvZmlsZUdlbmVyYXRvcixcclxuICAgICAgICBEYXlDZWxsQ29udGFpbmVyOiBEYXlDZWxsQ29udGFpbmVyLFxyXG4gICAgICAgIERheUhlYWRlcjogRGF5SGVhZGVyLFxyXG4gICAgICAgIERheVNlcmllc01vZGVsOiBEYXlTZXJpZXNNb2RlbCxcclxuICAgICAgICBEYXlUYWJsZU1vZGVsOiBEYXlUYWJsZU1vZGVsLFxyXG4gICAgICAgIERlbGF5ZWRSdW5uZXI6IERlbGF5ZWRSdW5uZXIsXHJcbiAgICAgICAgRWxlbWVudERyYWdnaW5nOiBFbGVtZW50RHJhZ2dpbmcsXHJcbiAgICAgICAgRWxlbWVudFNjcm9sbENvbnRyb2xsZXI6IEVsZW1lbnRTY3JvbGxDb250cm9sbGVyLFxyXG4gICAgICAgIEVtaXR0ZXI6IEVtaXR0ZXIsXHJcbiAgICAgICAgRXZlbnRDb250YWluZXI6IEV2ZW50Q29udGFpbmVyLFxyXG4gICAgICAgIEV2ZW50SW1wbDogRXZlbnRJbXBsLFxyXG4gICAgICAgIEludGVyYWN0aW9uOiBJbnRlcmFjdGlvbixcclxuICAgICAgICBNb3JlTGlua0NvbnRhaW5lcjogTW9yZUxpbmtDb250YWluZXIsXHJcbiAgICAgICAgTmFtZWRUaW1lWm9uZUltcGw6IE5hbWVkVGltZVpvbmVJbXBsLFxyXG4gICAgICAgIE5vd0luZGljYXRvckNvbnRhaW5lcjogTm93SW5kaWNhdG9yQ29udGFpbmVyLFxyXG4gICAgICAgIE5vd1RpbWVyOiBOb3dUaW1lcixcclxuICAgICAgICBQb3NpdGlvbkNhY2hlOiBQb3NpdGlvbkNhY2hlLFxyXG4gICAgICAgIFJlZk1hcDogUmVmTWFwLFxyXG4gICAgICAgIFNjcm9sbENvbnRyb2xsZXI6IFNjcm9sbENvbnRyb2xsZXIsXHJcbiAgICAgICAgU2Nyb2xsUmVzcG9uZGVyOiBTY3JvbGxSZXNwb25kZXIsXHJcbiAgICAgICAgU2Nyb2xsZXI6IFNjcm9sbGVyLFxyXG4gICAgICAgIFNlZ0hpZXJhcmNoeTogU2VnSGllcmFyY2h5LFxyXG4gICAgICAgIFNpbXBsZVNjcm9sbEdyaWQ6IFNpbXBsZVNjcm9sbEdyaWQsXHJcbiAgICAgICAgU2xpY2VyOiBTbGljZXIsXHJcbiAgICAgICAgU3BsaXR0ZXI6IFNwbGl0dGVyLFxyXG4gICAgICAgIFN0YW5kYXJkRXZlbnQ6IFN0YW5kYXJkRXZlbnQsXHJcbiAgICAgICAgVGFibGVEYXRlQ2VsbDogVGFibGVEYXRlQ2VsbCxcclxuICAgICAgICBUYWJsZURvd0NlbGw6IFRhYmxlRG93Q2VsbCxcclxuICAgICAgICBUaGVtZTogVGhlbWUsXHJcbiAgICAgICAgVmlld0NvbnRhaW5lcjogVmlld0NvbnRhaW5lcixcclxuICAgICAgICBWaWV3Q29udGV4dFR5cGU6IFZpZXdDb250ZXh0VHlwZSxcclxuICAgICAgICBXZWVrTnVtYmVyQ29udGFpbmVyOiBXZWVrTnVtYmVyQ29udGFpbmVyLFxyXG4gICAgICAgIFdpbmRvd1Njcm9sbENvbnRyb2xsZXI6IFdpbmRvd1Njcm9sbENvbnRyb2xsZXIsXHJcbiAgICAgICAgYWRkRGF5czogYWRkRGF5cyxcclxuICAgICAgICBhZGREdXJhdGlvbnM6IGFkZER1cmF0aW9ucyxcclxuICAgICAgICBhZGRNczogYWRkTXMsXHJcbiAgICAgICAgYWRkV2Vla3M6IGFkZFdlZWtzLFxyXG4gICAgICAgIGFsbG93Q29udGV4dE1lbnU6IGFsbG93Q29udGV4dE1lbnUsXHJcbiAgICAgICAgYWxsb3dTZWxlY3Rpb246IGFsbG93U2VsZWN0aW9uLFxyXG4gICAgICAgIGFwcGx5TXV0YXRpb25Ub0V2ZW50U3RvcmU6IGFwcGx5TXV0YXRpb25Ub0V2ZW50U3RvcmUsXHJcbiAgICAgICAgYXBwbHlTdHlsZTogYXBwbHlTdHlsZSxcclxuICAgICAgICBhc0NsZWFuRGF5czogYXNDbGVhbkRheXMsXHJcbiAgICAgICAgYXNSb3VnaE1pbnV0ZXM6IGFzUm91Z2hNaW51dGVzLFxyXG4gICAgICAgIGFzUm91Z2hNczogYXNSb3VnaE1zLFxyXG4gICAgICAgIGFzUm91Z2hTZWNvbmRzOiBhc1JvdWdoU2Vjb25kcyxcclxuICAgICAgICBiaW5hcnlTZWFyY2g6IGJpbmFyeVNlYXJjaCxcclxuICAgICAgICBidWlsZEVsQXR0cnM6IGJ1aWxkRWxBdHRycyxcclxuICAgICAgICBidWlsZEVudHJ5S2V5OiBidWlsZEVudHJ5S2V5LFxyXG4gICAgICAgIGJ1aWxkRXZlbnRBcGlzOiBidWlsZEV2ZW50QXBpcyxcclxuICAgICAgICBidWlsZEV2ZW50UmFuZ2VLZXk6IGJ1aWxkRXZlbnRSYW5nZUtleSxcclxuICAgICAgICBidWlsZElzb1N0cmluZzogYnVpbGRJc29TdHJpbmcsXHJcbiAgICAgICAgYnVpbGROYXZMaW5rQXR0cnM6IGJ1aWxkTmF2TGlua0F0dHJzLFxyXG4gICAgICAgIGJ1aWxkU2VnVGltZVRleHQ6IGJ1aWxkU2VnVGltZVRleHQsXHJcbiAgICAgICAgY29sbGVjdEZyb21IYXNoOiBjb2xsZWN0RnJvbUhhc2gsXHJcbiAgICAgICAgY29tYmluZUV2ZW50VWlzOiBjb21iaW5lRXZlbnRVaXMsXHJcbiAgICAgICAgY29tcGFyZUJ5RmllbGRTcGVjczogY29tcGFyZUJ5RmllbGRTcGVjcyxcclxuICAgICAgICBjb21wYXJlTnVtYmVyczogY29tcGFyZU51bWJlcnMsXHJcbiAgICAgICAgY29tcGFyZU9ianM6IGNvbXBhcmVPYmpzLFxyXG4gICAgICAgIGNvbXB1dGVFYXJsaWVzdFNlZ1N0YXJ0OiBjb21wdXRlRWFybGllc3RTZWdTdGFydCxcclxuICAgICAgICBjb21wdXRlRWRnZXM6IGNvbXB1dGVFZGdlcyxcclxuICAgICAgICBjb21wdXRlRmFsbGJhY2tIZWFkZXJGb3JtYXQ6IGNvbXB1dGVGYWxsYmFja0hlYWRlckZvcm1hdCxcclxuICAgICAgICBjb21wdXRlSW5uZXJSZWN0OiBjb21wdXRlSW5uZXJSZWN0LFxyXG4gICAgICAgIGNvbXB1dGVSZWN0OiBjb21wdXRlUmVjdCxcclxuICAgICAgICBjb21wdXRlU2hyaW5rV2lkdGg6IGNvbXB1dGVTaHJpbmtXaWR0aCxcclxuICAgICAgICBjb21wdXRlVmlzaWJsZURheVJhbmdlOiBjb21wdXRlVmlzaWJsZURheVJhbmdlLFxyXG4gICAgICAgIGNvbmZpZzogY29uZmlnLFxyXG4gICAgICAgIGNvbnN0cmFpblBvaW50OiBjb25zdHJhaW5Qb2ludCxcclxuICAgICAgICBjcmVhdGVEdXJhdGlvbjogY3JlYXRlRHVyYXRpb24sXHJcbiAgICAgICAgY3JlYXRlRW1wdHlFdmVudFN0b3JlOiBjcmVhdGVFbXB0eUV2ZW50U3RvcmUsXHJcbiAgICAgICAgY3JlYXRlRXZlbnRJbnN0YW5jZTogY3JlYXRlRXZlbnRJbnN0YW5jZSxcclxuICAgICAgICBjcmVhdGVFdmVudFVpOiBjcmVhdGVFdmVudFVpLFxyXG4gICAgICAgIGNyZWF0ZUZvcm1hdHRlcjogY3JlYXRlRm9ybWF0dGVyLFxyXG4gICAgICAgIGRpZmZEYXRlczogZGlmZkRhdGVzLFxyXG4gICAgICAgIGRpZmZEYXlBbmRUaW1lOiBkaWZmRGF5QW5kVGltZSxcclxuICAgICAgICBkaWZmRGF5czogZGlmZkRheXMsXHJcbiAgICAgICAgZGlmZlBvaW50czogZGlmZlBvaW50cyxcclxuICAgICAgICBkaWZmV2Vla3M6IGRpZmZXZWVrcyxcclxuICAgICAgICBkaWZmV2hvbGVEYXlzOiBkaWZmV2hvbGVEYXlzLFxyXG4gICAgICAgIGRpZmZXaG9sZVdlZWtzOiBkaWZmV2hvbGVXZWVrcyxcclxuICAgICAgICBkaXNhYmxlQ3Vyc29yOiBkaXNhYmxlQ3Vyc29yLFxyXG4gICAgICAgIGVsZW1lbnRDbG9zZXN0OiBlbGVtZW50Q2xvc2VzdCxcclxuICAgICAgICBlbGVtZW50TWF0Y2hlczogZWxlbWVudE1hdGNoZXMsXHJcbiAgICAgICAgZW5hYmxlQ3Vyc29yOiBlbmFibGVDdXJzb3IsXHJcbiAgICAgICAgZXZlbnRUdXBsZVRvU3RvcmU6IGV2ZW50VHVwbGVUb1N0b3JlLFxyXG4gICAgICAgIGZpbHRlckhhc2g6IGZpbHRlckhhc2gsXHJcbiAgICAgICAgZmluZERpcmVjdENoaWxkcmVuOiBmaW5kRGlyZWN0Q2hpbGRyZW4sXHJcbiAgICAgICAgZmluZEVsZW1lbnRzOiBmaW5kRWxlbWVudHMsXHJcbiAgICAgICAgZmxleGlibGVDb21wYXJlOiBmbGV4aWJsZUNvbXBhcmUsXHJcbiAgICAgICAgZm9ybWF0RGF5U3RyaW5nOiBmb3JtYXREYXlTdHJpbmcsXHJcbiAgICAgICAgZm9ybWF0SXNvTW9udGhTdHI6IGZvcm1hdElzb01vbnRoU3RyLFxyXG4gICAgICAgIGZvcm1hdElzb1RpbWVTdHJpbmc6IGZvcm1hdElzb1RpbWVTdHJpbmcsXHJcbiAgICAgICAgZ2V0QWxsb3dZU2Nyb2xsaW5nOiBnZXRBbGxvd1lTY3JvbGxpbmcsXHJcbiAgICAgICAgZ2V0Q2FuVkdyb3dXaXRoaW5DZWxsOiBnZXRDYW5WR3Jvd1dpdGhpbkNlbGwsXHJcbiAgICAgICAgZ2V0Q2xpcHBpbmdQYXJlbnRzOiBnZXRDbGlwcGluZ1BhcmVudHMsXHJcbiAgICAgICAgZ2V0RGF0ZU1ldGE6IGdldERhdGVNZXRhLFxyXG4gICAgICAgIGdldERheUNsYXNzTmFtZXM6IGdldERheUNsYXNzTmFtZXMsXHJcbiAgICAgICAgZ2V0RGVmYXVsdEV2ZW50RW5kOiBnZXREZWZhdWx0RXZlbnRFbmQsXHJcbiAgICAgICAgZ2V0RWxTZWc6IGdldEVsU2VnLFxyXG4gICAgICAgIGdldEVudHJ5U3BhbkVuZDogZ2V0RW50cnlTcGFuRW5kLFxyXG4gICAgICAgIGdldEV2ZW50VGFyZ2V0VmlhUm9vdDogZ2V0RXZlbnRUYXJnZXRWaWFSb290LFxyXG4gICAgICAgIGdldElzUnRsU2Nyb2xsYmFyT25MZWZ0OiBnZXRJc1J0bFNjcm9sbGJhck9uTGVmdCxcclxuICAgICAgICBnZXRSZWN0Q2VudGVyOiBnZXRSZWN0Q2VudGVyLFxyXG4gICAgICAgIGdldFJlbGV2YW50RXZlbnRzOiBnZXRSZWxldmFudEV2ZW50cyxcclxuICAgICAgICBnZXRTY3JvbGxHcmlkQ2xhc3NOYW1lczogZ2V0U2Nyb2xsR3JpZENsYXNzTmFtZXMsXHJcbiAgICAgICAgZ2V0U2Nyb2xsYmFyV2lkdGhzOiBnZXRTY3JvbGxiYXJXaWR0aHMsXHJcbiAgICAgICAgZ2V0U2VjdGlvbkNsYXNzTmFtZXM6IGdldFNlY3Rpb25DbGFzc05hbWVzLFxyXG4gICAgICAgIGdldFNlY3Rpb25IYXNMaXF1aWRIZWlnaHQ6IGdldFNlY3Rpb25IYXNMaXF1aWRIZWlnaHQsXHJcbiAgICAgICAgZ2V0U2VnQW5jaG9yQXR0cnM6IGdldFNlZ0FuY2hvckF0dHJzLFxyXG4gICAgICAgIGdldFNlZ01ldGE6IGdldFNlZ01ldGEsXHJcbiAgICAgICAgZ2V0U2xvdENsYXNzTmFtZXM6IGdldFNsb3RDbGFzc05hbWVzLFxyXG4gICAgICAgIGdldFN0aWNreUZvb3RlclNjcm9sbGJhcjogZ2V0U3RpY2t5Rm9vdGVyU2Nyb2xsYmFyLFxyXG4gICAgICAgIGdldFN0aWNreUhlYWRlckRhdGVzOiBnZXRTdGlja3lIZWFkZXJEYXRlcyxcclxuICAgICAgICBnZXRVbmlxdWVEb21JZDogZ2V0VW5pcXVlRG9tSWQsXHJcbiAgICAgICAgZ3JlYXRlc3REdXJhdGlvbkRlbm9taW5hdG9yOiBncmVhdGVzdER1cmF0aW9uRGVub21pbmF0b3IsXHJcbiAgICAgICAgZ3JvdXBJbnRlcnNlY3RpbmdFbnRyaWVzOiBncm91cEludGVyc2VjdGluZ0VudHJpZXMsXHJcbiAgICAgICAgZ3VpZDogZ3VpZCxcclxuICAgICAgICBoYXNCZ1JlbmRlcmluZzogaGFzQmdSZW5kZXJpbmcsXHJcbiAgICAgICAgaGFzQ3VzdG9tRGF5Q2VsbENvbnRlbnQ6IGhhc0N1c3RvbURheUNlbGxDb250ZW50LFxyXG4gICAgICAgIGhhc1Nocmlua1dpZHRoOiBoYXNTaHJpbmtXaWR0aCxcclxuICAgICAgICBpZGVudGl0eTogaWRlbnRpdHksXHJcbiAgICAgICAgaW5qZWN0U3R5bGVzOiBpbmplY3RTdHlsZXMsXHJcbiAgICAgICAgaW50ZXJhY3Rpb25TZXR0aW5nc1N0b3JlOiBpbnRlcmFjdGlvblNldHRpbmdzU3RvcmUsXHJcbiAgICAgICAgaW50ZXJhY3Rpb25TZXR0aW5nc1RvU3RvcmU6IGludGVyYWN0aW9uU2V0dGluZ3NUb1N0b3JlLFxyXG4gICAgICAgIGludGVyc2VjdFJhbmdlczogaW50ZXJzZWN0UmFuZ2VzLFxyXG4gICAgICAgIGludGVyc2VjdFJlY3RzOiBpbnRlcnNlY3RSZWN0cyxcclxuICAgICAgICBpbnRlcnNlY3RTcGFuczogaW50ZXJzZWN0U3BhbnMsXHJcbiAgICAgICAgaXNBcnJheXNFcXVhbDogaXNBcnJheXNFcXVhbCxcclxuICAgICAgICBpc0NvbFByb3BzRXF1YWw6IGlzQ29sUHJvcHNFcXVhbCxcclxuICAgICAgICBpc0RhdGVTZWxlY3Rpb25WYWxpZDogaXNEYXRlU2VsZWN0aW9uVmFsaWQsXHJcbiAgICAgICAgaXNEYXRlU3BhbnNFcXVhbDogaXNEYXRlU3BhbnNFcXVhbCxcclxuICAgICAgICBpc0ludDogaXNJbnQsXHJcbiAgICAgICAgaXNJbnRlcmFjdGlvblZhbGlkOiBpc0ludGVyYWN0aW9uVmFsaWQsXHJcbiAgICAgICAgaXNNdWx0aURheVJhbmdlOiBpc011bHRpRGF5UmFuZ2UsXHJcbiAgICAgICAgaXNQcm9wc0VxdWFsOiBpc1Byb3BzRXF1YWwsXHJcbiAgICAgICAgaXNQcm9wc1ZhbGlkOiBpc1Byb3BzVmFsaWQsXHJcbiAgICAgICAgaXNWYWxpZERhdGU6IGlzVmFsaWREYXRlLFxyXG4gICAgICAgIG1hcEhhc2g6IG1hcEhhc2gsXHJcbiAgICAgICAgbWVtb2l6ZTogbWVtb2l6ZSxcclxuICAgICAgICBtZW1vaXplQXJyYXlsaWtlOiBtZW1vaXplQXJyYXlsaWtlLFxyXG4gICAgICAgIG1lbW9pemVIYXNobGlrZTogbWVtb2l6ZUhhc2hsaWtlLFxyXG4gICAgICAgIG1lbW9pemVPYmpBcmc6IG1lbW9pemVPYmpBcmcsXHJcbiAgICAgICAgbWVyZ2VFdmVudFN0b3JlczogbWVyZ2VFdmVudFN0b3JlcyxcclxuICAgICAgICBtdWx0aXBseUR1cmF0aW9uOiBtdWx0aXBseUR1cmF0aW9uLFxyXG4gICAgICAgIHBhZFN0YXJ0OiBwYWRTdGFydCxcclxuICAgICAgICBwYXJzZUJ1c2luZXNzSG91cnM6IHBhcnNlQnVzaW5lc3NIb3VycyxcclxuICAgICAgICBwYXJzZUNsYXNzTmFtZXM6IHBhcnNlQ2xhc3NOYW1lcyxcclxuICAgICAgICBwYXJzZURyYWdNZXRhOiBwYXJzZURyYWdNZXRhLFxyXG4gICAgICAgIHBhcnNlRXZlbnREZWY6IHBhcnNlRXZlbnREZWYsXHJcbiAgICAgICAgcGFyc2VGaWVsZFNwZWNzOiBwYXJzZUZpZWxkU3BlY3MsXHJcbiAgICAgICAgcGFyc2VNYXJrZXI6IHBhcnNlLFxyXG4gICAgICAgIHBvaW50SW5zaWRlUmVjdDogcG9pbnRJbnNpZGVSZWN0LFxyXG4gICAgICAgIHByZXZlbnRDb250ZXh0TWVudTogcHJldmVudENvbnRleHRNZW51LFxyXG4gICAgICAgIHByZXZlbnREZWZhdWx0OiBwcmV2ZW50RGVmYXVsdCxcclxuICAgICAgICBwcmV2ZW50U2VsZWN0aW9uOiBwcmV2ZW50U2VsZWN0aW9uLFxyXG4gICAgICAgIHJhbmdlQ29udGFpbnNNYXJrZXI6IHJhbmdlQ29udGFpbnNNYXJrZXIsXHJcbiAgICAgICAgcmFuZ2VDb250YWluc1JhbmdlOiByYW5nZUNvbnRhaW5zUmFuZ2UsXHJcbiAgICAgICAgcmFuZ2VzRXF1YWw6IHJhbmdlc0VxdWFsLFxyXG4gICAgICAgIHJhbmdlc0ludGVyc2VjdDogcmFuZ2VzSW50ZXJzZWN0LFxyXG4gICAgICAgIHJlZmluZUV2ZW50RGVmOiByZWZpbmVFdmVudERlZixcclxuICAgICAgICByZWZpbmVQcm9wczogcmVmaW5lUHJvcHMsXHJcbiAgICAgICAgcmVtb3ZlRWxlbWVudDogcmVtb3ZlRWxlbWVudCxcclxuICAgICAgICByZW1vdmVFeGFjdDogcmVtb3ZlRXhhY3QsXHJcbiAgICAgICAgcmVuZGVyQ2h1bmtDb250ZW50OiByZW5kZXJDaHVua0NvbnRlbnQsXHJcbiAgICAgICAgcmVuZGVyRmlsbDogcmVuZGVyRmlsbCxcclxuICAgICAgICByZW5kZXJNaWNyb0NvbEdyb3VwOiByZW5kZXJNaWNyb0NvbEdyb3VwLFxyXG4gICAgICAgIHJlbmRlclNjcm9sbFNoaW06IHJlbmRlclNjcm9sbFNoaW0sXHJcbiAgICAgICAgcmVxdWVzdEpzb246IHJlcXVlc3RKc29uLFxyXG4gICAgICAgIHNhbml0aXplU2hyaW5rV2lkdGg6IHNhbml0aXplU2hyaW5rV2lkdGgsXHJcbiAgICAgICAgc2V0UmVmOiBzZXRSZWYsXHJcbiAgICAgICAgc2xpY2VFdmVudFN0b3JlOiBzbGljZUV2ZW50U3RvcmUsXHJcbiAgICAgICAgc29ydEV2ZW50U2Vnczogc29ydEV2ZW50U2VncyxcclxuICAgICAgICBzdGFydE9mRGF5OiBzdGFydE9mRGF5LFxyXG4gICAgICAgIHRyYW5zbGF0ZVJlY3Q6IHRyYW5zbGF0ZVJlY3QsXHJcbiAgICAgICAgdHJpZ2dlckRhdGVTZWxlY3Q6IHRyaWdnZXJEYXRlU2VsZWN0LFxyXG4gICAgICAgIHVucHJvbWlzaWZ5OiB1bnByb21pc2lmeSxcclxuICAgICAgICB3aGVuVHJhbnNpdGlvbkRvbmU6IHdoZW5UcmFuc2l0aW9uRG9uZSxcclxuICAgICAgICB3aG9sZURpdmlkZUR1cmF0aW9uczogd2hvbGVEaXZpZGVEdXJhdGlvbnNcclxuICAgIH07XHJcblxyXG4gICAgdmFyIHByZWFjdCA9IHtcclxuICAgICAgICBfX3Byb3RvX186IG51bGwsXHJcbiAgICAgICAgY3JlYXRlUG9ydGFsOiBqLFxyXG4gICAgICAgIGNyZWF0ZUNvbnRleHQ6IGNyZWF0ZUNvbnRleHQsXHJcbiAgICAgICAgZmx1c2hTeW5jOiBmbHVzaFN5bmMsXHJcbiAgICAgICAgQ29tcG9uZW50OiB4JDEsXHJcbiAgICAgICAgRnJhZ21lbnQ6IF8sXHJcbiAgICAgICAgY2xvbmVFbGVtZW50OiBGJDEsXHJcbiAgICAgICAgY3JlYXRlRWxlbWVudDogeSxcclxuICAgICAgICBjcmVhdGVSZWY6IGQsXHJcbiAgICAgICAgaDogeSxcclxuICAgICAgICBoeWRyYXRlOiBFLFxyXG4gICAgICAgIGdldCBpc1ZhbGlkRWxlbWVudCAoKSB7IHJldHVybiBpJDE7IH0sXHJcbiAgICAgICAgZ2V0IG9wdGlvbnMgKCkgeyByZXR1cm4gbCQxOyB9LFxyXG4gICAgICAgIHJlbmRlcjogRCQxLFxyXG4gICAgICAgIHRvQ2hpbGRBcnJheTogaiQyXHJcbiAgICB9O1xyXG5cclxuICAgIGNvbnN0IGdsb2JhbExvY2FsZXMgPSBbXTtcclxuXHJcbiAgICBjb25zdCBNSU5JTUFMX1JBV19FTl9MT0NBTEUgPSB7XHJcbiAgICAgICAgY29kZTogJ2VuJyxcclxuICAgICAgICB3ZWVrOiB7XHJcbiAgICAgICAgICAgIGRvdzogMCxcclxuICAgICAgICAgICAgZG95OiA0LCAvLyA0IGRheXMgbmVlZCB0byBiZSB3aXRoaW4gdGhlIHllYXIgdG8gYmUgY29uc2lkZXJlZCB0aGUgZmlyc3Qgd2Vla1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZGlyZWN0aW9uOiAnbHRyJyxcclxuICAgICAgICBidXR0b25UZXh0OiB7XHJcbiAgICAgICAgICAgIHByZXY6ICdwcmV2JyxcclxuICAgICAgICAgICAgbmV4dDogJ25leHQnLFxyXG4gICAgICAgICAgICBwcmV2WWVhcjogJ3ByZXYgeWVhcicsXHJcbiAgICAgICAgICAgIG5leHRZZWFyOiAnbmV4dCB5ZWFyJyxcclxuICAgICAgICAgICAgeWVhcjogJ3llYXInLFxyXG4gICAgICAgICAgICB0b2RheTogJ3RvZGF5JyxcclxuICAgICAgICAgICAgbW9udGg6ICdtb250aCcsXHJcbiAgICAgICAgICAgIHdlZWs6ICd3ZWVrJyxcclxuICAgICAgICAgICAgZGF5OiAnZGF5JyxcclxuICAgICAgICAgICAgbGlzdDogJ2xpc3QnLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgd2Vla1RleHQ6ICdXJyxcclxuICAgICAgICB3ZWVrVGV4dExvbmc6ICdXZWVrJyxcclxuICAgICAgICBjbG9zZUhpbnQ6ICdDbG9zZScsXHJcbiAgICAgICAgdGltZUhpbnQ6ICdUaW1lJyxcclxuICAgICAgICBldmVudEhpbnQ6ICdFdmVudCcsXHJcbiAgICAgICAgYWxsRGF5VGV4dDogJ2FsbC1kYXknLFxyXG4gICAgICAgIG1vcmVMaW5rVGV4dDogJ21vcmUnLFxyXG4gICAgICAgIG5vRXZlbnRzVGV4dDogJ05vIGV2ZW50cyB0byBkaXNwbGF5JyxcclxuICAgIH07XHJcbiAgICBjb25zdCBSQVdfRU5fTE9DQUxFID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBNSU5JTUFMX1JBV19FTl9MT0NBTEUpLCB7IFxyXG4gICAgICAgIC8vIEluY2x1ZGVzIHRoaW5ncyB3ZSBkb24ndCB3YW50IG90aGVyIGxvY2FsZXMgdG8gaW5oZXJpdCxcclxuICAgICAgICAvLyB0aGluZ3MgdGhhdCBkZXJpdmUgZnJvbSBvdGhlciB0cmFuc2xhdGFibGUgc3RyaW5ncy5cclxuICAgICAgICBidXR0b25IaW50czoge1xyXG4gICAgICAgICAgICBwcmV2OiAnUHJldmlvdXMgJDAnLFxyXG4gICAgICAgICAgICBuZXh0OiAnTmV4dCAkMCcsXHJcbiAgICAgICAgICAgIHRvZGF5KGJ1dHRvblRleHQsIHVuaXQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAodW5pdCA9PT0gJ2RheScpXHJcbiAgICAgICAgICAgICAgICAgICAgPyAnVG9kYXknXHJcbiAgICAgICAgICAgICAgICAgICAgOiBgVGhpcyAke2J1dHRvblRleHR9YDtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9LCB2aWV3SGludDogJyQwIHZpZXcnLCBuYXZMaW5rSGludDogJ0dvIHRvICQwJywgbW9yZUxpbmtIaW50KGV2ZW50Q250KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBgU2hvdyAke2V2ZW50Q250fSBtb3JlIGV2ZW50JHtldmVudENudCA9PT0gMSA/ICcnIDogJ3MnfWA7XHJcbiAgICAgICAgfSB9KTtcclxuICAgIGZ1bmN0aW9uIG9yZ2FuaXplUmF3TG9jYWxlcyhleHBsaWNpdFJhd0xvY2FsZXMpIHtcclxuICAgICAgICBsZXQgZGVmYXVsdENvZGUgPSBleHBsaWNpdFJhd0xvY2FsZXMubGVuZ3RoID4gMCA/IGV4cGxpY2l0UmF3TG9jYWxlc1swXS5jb2RlIDogJ2VuJztcclxuICAgICAgICBsZXQgYWxsUmF3TG9jYWxlcyA9IGdsb2JhbExvY2FsZXMuY29uY2F0KGV4cGxpY2l0UmF3TG9jYWxlcyk7XHJcbiAgICAgICAgbGV0IHJhd0xvY2FsZU1hcCA9IHtcclxuICAgICAgICAgICAgZW46IFJBV19FTl9MT0NBTEUsXHJcbiAgICAgICAgfTtcclxuICAgICAgICBmb3IgKGxldCByYXdMb2NhbGUgb2YgYWxsUmF3TG9jYWxlcykge1xyXG4gICAgICAgICAgICByYXdMb2NhbGVNYXBbcmF3TG9jYWxlLmNvZGVdID0gcmF3TG9jYWxlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBtYXA6IHJhd0xvY2FsZU1hcCxcclxuICAgICAgICAgICAgZGVmYXVsdENvZGUsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGJ1aWxkTG9jYWxlKGlucHV0U2luZ3VsYXIsIGF2YWlsYWJsZSkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXRTaW5ndWxhciA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkoaW5wdXRTaW5ndWxhcikpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlTG9jYWxlKGlucHV0U2luZ3VsYXIuY29kZSwgW2lucHV0U2luZ3VsYXIuY29kZV0sIGlucHV0U2luZ3VsYXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcXVlcnlMb2NhbGUoaW5wdXRTaW5ndWxhciwgYXZhaWxhYmxlKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHF1ZXJ5TG9jYWxlKGNvZGVBcmcsIGF2YWlsYWJsZSkge1xyXG4gICAgICAgIGxldCBjb2RlcyA9IFtdLmNvbmNhdChjb2RlQXJnIHx8IFtdKTsgLy8gd2lsbCBjb252ZXJ0IHRvIGFycmF5XHJcbiAgICAgICAgbGV0IHJhdyA9IHF1ZXJ5UmF3TG9jYWxlKGNvZGVzLCBhdmFpbGFibGUpIHx8IFJBV19FTl9MT0NBTEU7XHJcbiAgICAgICAgcmV0dXJuIHBhcnNlTG9jYWxlKGNvZGVBcmcsIGNvZGVzLCByYXcpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gcXVlcnlSYXdMb2NhbGUoY29kZXMsIGF2YWlsYWJsZSkge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29kZXMubGVuZ3RoOyBpICs9IDEpIHtcclxuICAgICAgICAgICAgbGV0IHBhcnRzID0gY29kZXNbaV0udG9Mb2NhbGVMb3dlckNhc2UoKS5zcGxpdCgnLScpO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gcGFydHMubGVuZ3RoOyBqID4gMDsgaiAtPSAxKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgc2ltcGxlSWQgPSBwYXJ0cy5zbGljZSgwLCBqKS5qb2luKCctJyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoYXZhaWxhYmxlW3NpbXBsZUlkXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhdmFpbGFibGVbc2ltcGxlSWRdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gcGFyc2VMb2NhbGUoY29kZUFyZywgY29kZXMsIHJhdykge1xyXG4gICAgICAgIGxldCBtZXJnZWQgPSBtZXJnZVByb3BzKFtNSU5JTUFMX1JBV19FTl9MT0NBTEUsIHJhd10sIFsnYnV0dG9uVGV4dCddKTtcclxuICAgICAgICBkZWxldGUgbWVyZ2VkLmNvZGU7IC8vIGRvbid0IHdhbnQgdGhpcyBwYXJ0IG9mIHRoZSBvcHRpb25zXHJcbiAgICAgICAgbGV0IHsgd2VlayB9ID0gbWVyZ2VkO1xyXG4gICAgICAgIGRlbGV0ZSBtZXJnZWQud2VlaztcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBjb2RlQXJnLFxyXG4gICAgICAgICAgICBjb2RlcyxcclxuICAgICAgICAgICAgd2VlayxcclxuICAgICAgICAgICAgc2ltcGxlTnVtYmVyRm9ybWF0OiBuZXcgSW50bC5OdW1iZXJGb3JtYXQoY29kZUFyZyksXHJcbiAgICAgICAgICAgIG9wdGlvbnM6IG1lcmdlZCxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFRPRE86IGVhc2llciB3YXkgdG8gYWRkIG5ldyBob29rcz8gbmVlZCB0byB1cGRhdGUgYSBtaWxsaW9uIHRoaW5nc1xyXG4gICAgZnVuY3Rpb24gY3JlYXRlUGx1Z2luKGlucHV0KSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgaWQ6IGd1aWQoKSxcclxuICAgICAgICAgICAgbmFtZTogaW5wdXQubmFtZSxcclxuICAgICAgICAgICAgcHJlbWl1bVJlbGVhc2VEYXRlOiBpbnB1dC5wcmVtaXVtUmVsZWFzZURhdGUgPyBuZXcgRGF0ZShpbnB1dC5wcmVtaXVtUmVsZWFzZURhdGUpIDogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICBkZXBzOiBpbnB1dC5kZXBzIHx8IFtdLFxyXG4gICAgICAgICAgICByZWR1Y2VyczogaW5wdXQucmVkdWNlcnMgfHwgW10sXHJcbiAgICAgICAgICAgIGlzTG9hZGluZ0Z1bmNzOiBpbnB1dC5pc0xvYWRpbmdGdW5jcyB8fCBbXSxcclxuICAgICAgICAgICAgY29udGV4dEluaXQ6IFtdLmNvbmNhdChpbnB1dC5jb250ZXh0SW5pdCB8fCBbXSksXHJcbiAgICAgICAgICAgIGV2ZW50UmVmaW5lcnM6IGlucHV0LmV2ZW50UmVmaW5lcnMgfHwge30sXHJcbiAgICAgICAgICAgIGV2ZW50RGVmTWVtYmVyQWRkZXJzOiBpbnB1dC5ldmVudERlZk1lbWJlckFkZGVycyB8fCBbXSxcclxuICAgICAgICAgICAgZXZlbnRTb3VyY2VSZWZpbmVyczogaW5wdXQuZXZlbnRTb3VyY2VSZWZpbmVycyB8fCB7fSxcclxuICAgICAgICAgICAgaXNEcmFnZ2FibGVUcmFuc2Zvcm1lcnM6IGlucHV0LmlzRHJhZ2dhYmxlVHJhbnNmb3JtZXJzIHx8IFtdLFxyXG4gICAgICAgICAgICBldmVudERyYWdNdXRhdGlvbk1hc3NhZ2VyczogaW5wdXQuZXZlbnREcmFnTXV0YXRpb25NYXNzYWdlcnMgfHwgW10sXHJcbiAgICAgICAgICAgIGV2ZW50RGVmTXV0YXRpb25BcHBsaWVyczogaW5wdXQuZXZlbnREZWZNdXRhdGlvbkFwcGxpZXJzIHx8IFtdLFxyXG4gICAgICAgICAgICBkYXRlU2VsZWN0aW9uVHJhbnNmb3JtZXJzOiBpbnB1dC5kYXRlU2VsZWN0aW9uVHJhbnNmb3JtZXJzIHx8IFtdLFxyXG4gICAgICAgICAgICBkYXRlUG9pbnRUcmFuc2Zvcm1zOiBpbnB1dC5kYXRlUG9pbnRUcmFuc2Zvcm1zIHx8IFtdLFxyXG4gICAgICAgICAgICBkYXRlU3BhblRyYW5zZm9ybXM6IGlucHV0LmRhdGVTcGFuVHJhbnNmb3JtcyB8fCBbXSxcclxuICAgICAgICAgICAgdmlld3M6IGlucHV0LnZpZXdzIHx8IHt9LFxyXG4gICAgICAgICAgICB2aWV3UHJvcHNUcmFuc2Zvcm1lcnM6IGlucHV0LnZpZXdQcm9wc1RyYW5zZm9ybWVycyB8fCBbXSxcclxuICAgICAgICAgICAgaXNQcm9wc1ZhbGlkOiBpbnB1dC5pc1Byb3BzVmFsaWQgfHwgbnVsbCxcclxuICAgICAgICAgICAgZXh0ZXJuYWxEZWZUcmFuc2Zvcm1zOiBpbnB1dC5leHRlcm5hbERlZlRyYW5zZm9ybXMgfHwgW10sXHJcbiAgICAgICAgICAgIHZpZXdDb250YWluZXJBcHBlbmRzOiBpbnB1dC52aWV3Q29udGFpbmVyQXBwZW5kcyB8fCBbXSxcclxuICAgICAgICAgICAgZXZlbnREcm9wVHJhbnNmb3JtZXJzOiBpbnB1dC5ldmVudERyb3BUcmFuc2Zvcm1lcnMgfHwgW10sXHJcbiAgICAgICAgICAgIGNvbXBvbmVudEludGVyYWN0aW9uczogaW5wdXQuY29tcG9uZW50SW50ZXJhY3Rpb25zIHx8IFtdLFxyXG4gICAgICAgICAgICBjYWxlbmRhckludGVyYWN0aW9uczogaW5wdXQuY2FsZW5kYXJJbnRlcmFjdGlvbnMgfHwgW10sXHJcbiAgICAgICAgICAgIHRoZW1lQ2xhc3NlczogaW5wdXQudGhlbWVDbGFzc2VzIHx8IHt9LFxyXG4gICAgICAgICAgICBldmVudFNvdXJjZURlZnM6IGlucHV0LmV2ZW50U291cmNlRGVmcyB8fCBbXSxcclxuICAgICAgICAgICAgY21kRm9ybWF0dGVyOiBpbnB1dC5jbWRGb3JtYXR0ZXIsXHJcbiAgICAgICAgICAgIHJlY3VycmluZ1R5cGVzOiBpbnB1dC5yZWN1cnJpbmdUeXBlcyB8fCBbXSxcclxuICAgICAgICAgICAgbmFtZWRUaW1lWm9uZWRJbXBsOiBpbnB1dC5uYW1lZFRpbWVab25lZEltcGwsXHJcbiAgICAgICAgICAgIGluaXRpYWxWaWV3OiBpbnB1dC5pbml0aWFsVmlldyB8fCAnJyxcclxuICAgICAgICAgICAgZWxlbWVudERyYWdnaW5nSW1wbDogaW5wdXQuZWxlbWVudERyYWdnaW5nSW1wbCxcclxuICAgICAgICAgICAgb3B0aW9uQ2hhbmdlSGFuZGxlcnM6IGlucHV0Lm9wdGlvbkNoYW5nZUhhbmRsZXJzIHx8IHt9LFxyXG4gICAgICAgICAgICBzY3JvbGxHcmlkSW1wbDogaW5wdXQuc2Nyb2xsR3JpZEltcGwgfHwgbnVsbCxcclxuICAgICAgICAgICAgbGlzdGVuZXJSZWZpbmVyczogaW5wdXQubGlzdGVuZXJSZWZpbmVycyB8fCB7fSxcclxuICAgICAgICAgICAgb3B0aW9uUmVmaW5lcnM6IGlucHV0Lm9wdGlvblJlZmluZXJzIHx8IHt9LFxyXG4gICAgICAgICAgICBwcm9wU2V0SGFuZGxlcnM6IGlucHV0LnByb3BTZXRIYW5kbGVycyB8fCB7fSxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYnVpbGRQbHVnaW5Ib29rcyhwbHVnaW5EZWZzLCBnbG9iYWxEZWZzKSB7XHJcbiAgICAgICAgbGV0IGN1cnJlbnRQbHVnaW5JZHMgPSB7fTtcclxuICAgICAgICBsZXQgaG9va3MgPSB7XHJcbiAgICAgICAgICAgIHByZW1pdW1SZWxlYXNlRGF0ZTogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICByZWR1Y2VyczogW10sXHJcbiAgICAgICAgICAgIGlzTG9hZGluZ0Z1bmNzOiBbXSxcclxuICAgICAgICAgICAgY29udGV4dEluaXQ6IFtdLFxyXG4gICAgICAgICAgICBldmVudFJlZmluZXJzOiB7fSxcclxuICAgICAgICAgICAgZXZlbnREZWZNZW1iZXJBZGRlcnM6IFtdLFxyXG4gICAgICAgICAgICBldmVudFNvdXJjZVJlZmluZXJzOiB7fSxcclxuICAgICAgICAgICAgaXNEcmFnZ2FibGVUcmFuc2Zvcm1lcnM6IFtdLFxyXG4gICAgICAgICAgICBldmVudERyYWdNdXRhdGlvbk1hc3NhZ2VyczogW10sXHJcbiAgICAgICAgICAgIGV2ZW50RGVmTXV0YXRpb25BcHBsaWVyczogW10sXHJcbiAgICAgICAgICAgIGRhdGVTZWxlY3Rpb25UcmFuc2Zvcm1lcnM6IFtdLFxyXG4gICAgICAgICAgICBkYXRlUG9pbnRUcmFuc2Zvcm1zOiBbXSxcclxuICAgICAgICAgICAgZGF0ZVNwYW5UcmFuc2Zvcm1zOiBbXSxcclxuICAgICAgICAgICAgdmlld3M6IHt9LFxyXG4gICAgICAgICAgICB2aWV3UHJvcHNUcmFuc2Zvcm1lcnM6IFtdLFxyXG4gICAgICAgICAgICBpc1Byb3BzVmFsaWQ6IG51bGwsXHJcbiAgICAgICAgICAgIGV4dGVybmFsRGVmVHJhbnNmb3JtczogW10sXHJcbiAgICAgICAgICAgIHZpZXdDb250YWluZXJBcHBlbmRzOiBbXSxcclxuICAgICAgICAgICAgZXZlbnREcm9wVHJhbnNmb3JtZXJzOiBbXSxcclxuICAgICAgICAgICAgY29tcG9uZW50SW50ZXJhY3Rpb25zOiBbXSxcclxuICAgICAgICAgICAgY2FsZW5kYXJJbnRlcmFjdGlvbnM6IFtdLFxyXG4gICAgICAgICAgICB0aGVtZUNsYXNzZXM6IHt9LFxyXG4gICAgICAgICAgICBldmVudFNvdXJjZURlZnM6IFtdLFxyXG4gICAgICAgICAgICBjbWRGb3JtYXR0ZXI6IG51bGwsXHJcbiAgICAgICAgICAgIHJlY3VycmluZ1R5cGVzOiBbXSxcclxuICAgICAgICAgICAgbmFtZWRUaW1lWm9uZWRJbXBsOiBudWxsLFxyXG4gICAgICAgICAgICBpbml0aWFsVmlldzogJycsXHJcbiAgICAgICAgICAgIGVsZW1lbnREcmFnZ2luZ0ltcGw6IG51bGwsXHJcbiAgICAgICAgICAgIG9wdGlvbkNoYW5nZUhhbmRsZXJzOiB7fSxcclxuICAgICAgICAgICAgc2Nyb2xsR3JpZEltcGw6IG51bGwsXHJcbiAgICAgICAgICAgIGxpc3RlbmVyUmVmaW5lcnM6IHt9LFxyXG4gICAgICAgICAgICBvcHRpb25SZWZpbmVyczoge30sXHJcbiAgICAgICAgICAgIHByb3BTZXRIYW5kbGVyczoge30sXHJcbiAgICAgICAgfTtcclxuICAgICAgICBmdW5jdGlvbiBhZGREZWZzKGRlZnMpIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgZGVmIG9mIGRlZnMpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHBsdWdpbk5hbWUgPSBkZWYubmFtZTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRJZCA9IGN1cnJlbnRQbHVnaW5JZHNbcGx1Z2luTmFtZV07XHJcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudElkID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50UGx1Z2luSWRzW3BsdWdpbk5hbWVdID0gZGVmLmlkO1xyXG4gICAgICAgICAgICAgICAgICAgIGFkZERlZnMoZGVmLmRlcHMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGhvb2tzID0gY29tYmluZUhvb2tzKGhvb2tzLCBkZWYpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY3VycmVudElkICE9PSBkZWYuaWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBkaWZmZXJlbnQgSUQgdGhhbiB0aGUgb25lIGFscmVhZHkgYWRkZWRcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYER1cGxpY2F0ZSBwbHVnaW4gJyR7cGx1Z2luTmFtZX0nYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHBsdWdpbkRlZnMpIHtcclxuICAgICAgICAgICAgYWRkRGVmcyhwbHVnaW5EZWZzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYWRkRGVmcyhnbG9iYWxEZWZzKTtcclxuICAgICAgICByZXR1cm4gaG9va3M7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBidWlsZEJ1aWxkUGx1Z2luSG9va3MoKSB7XHJcbiAgICAgICAgbGV0IGN1cnJlbnRPdmVycmlkZURlZnMgPSBbXTtcclxuICAgICAgICBsZXQgY3VycmVudEdsb2JhbERlZnMgPSBbXTtcclxuICAgICAgICBsZXQgY3VycmVudEhvb2tzO1xyXG4gICAgICAgIHJldHVybiAob3ZlcnJpZGVEZWZzLCBnbG9iYWxEZWZzKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICghY3VycmVudEhvb2tzIHx8ICFpc0FycmF5c0VxdWFsKG92ZXJyaWRlRGVmcywgY3VycmVudE92ZXJyaWRlRGVmcykgfHwgIWlzQXJyYXlzRXF1YWwoZ2xvYmFsRGVmcywgY3VycmVudEdsb2JhbERlZnMpKSB7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50SG9va3MgPSBidWlsZFBsdWdpbkhvb2tzKG92ZXJyaWRlRGVmcywgZ2xvYmFsRGVmcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY3VycmVudE92ZXJyaWRlRGVmcyA9IG92ZXJyaWRlRGVmcztcclxuICAgICAgICAgICAgY3VycmVudEdsb2JhbERlZnMgPSBnbG9iYWxEZWZzO1xyXG4gICAgICAgICAgICByZXR1cm4gY3VycmVudEhvb2tzO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBjb21iaW5lSG9va3MoaG9va3MwLCBob29rczEpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBwcmVtaXVtUmVsZWFzZURhdGU6IGNvbXBhcmVPcHRpb25hbERhdGVzKGhvb2tzMC5wcmVtaXVtUmVsZWFzZURhdGUsIGhvb2tzMS5wcmVtaXVtUmVsZWFzZURhdGUpLFxyXG4gICAgICAgICAgICByZWR1Y2VyczogaG9va3MwLnJlZHVjZXJzLmNvbmNhdChob29rczEucmVkdWNlcnMpLFxyXG4gICAgICAgICAgICBpc0xvYWRpbmdGdW5jczogaG9va3MwLmlzTG9hZGluZ0Z1bmNzLmNvbmNhdChob29rczEuaXNMb2FkaW5nRnVuY3MpLFxyXG4gICAgICAgICAgICBjb250ZXh0SW5pdDogaG9va3MwLmNvbnRleHRJbml0LmNvbmNhdChob29rczEuY29udGV4dEluaXQpLFxyXG4gICAgICAgICAgICBldmVudFJlZmluZXJzOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGhvb2tzMC5ldmVudFJlZmluZXJzKSwgaG9va3MxLmV2ZW50UmVmaW5lcnMpLFxyXG4gICAgICAgICAgICBldmVudERlZk1lbWJlckFkZGVyczogaG9va3MwLmV2ZW50RGVmTWVtYmVyQWRkZXJzLmNvbmNhdChob29rczEuZXZlbnREZWZNZW1iZXJBZGRlcnMpLFxyXG4gICAgICAgICAgICBldmVudFNvdXJjZVJlZmluZXJzOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGhvb2tzMC5ldmVudFNvdXJjZVJlZmluZXJzKSwgaG9va3MxLmV2ZW50U291cmNlUmVmaW5lcnMpLFxyXG4gICAgICAgICAgICBpc0RyYWdnYWJsZVRyYW5zZm9ybWVyczogaG9va3MwLmlzRHJhZ2dhYmxlVHJhbnNmb3JtZXJzLmNvbmNhdChob29rczEuaXNEcmFnZ2FibGVUcmFuc2Zvcm1lcnMpLFxyXG4gICAgICAgICAgICBldmVudERyYWdNdXRhdGlvbk1hc3NhZ2VyczogaG9va3MwLmV2ZW50RHJhZ011dGF0aW9uTWFzc2FnZXJzLmNvbmNhdChob29rczEuZXZlbnREcmFnTXV0YXRpb25NYXNzYWdlcnMpLFxyXG4gICAgICAgICAgICBldmVudERlZk11dGF0aW9uQXBwbGllcnM6IGhvb2tzMC5ldmVudERlZk11dGF0aW9uQXBwbGllcnMuY29uY2F0KGhvb2tzMS5ldmVudERlZk11dGF0aW9uQXBwbGllcnMpLFxyXG4gICAgICAgICAgICBkYXRlU2VsZWN0aW9uVHJhbnNmb3JtZXJzOiBob29rczAuZGF0ZVNlbGVjdGlvblRyYW5zZm9ybWVycy5jb25jYXQoaG9va3MxLmRhdGVTZWxlY3Rpb25UcmFuc2Zvcm1lcnMpLFxyXG4gICAgICAgICAgICBkYXRlUG9pbnRUcmFuc2Zvcm1zOiBob29rczAuZGF0ZVBvaW50VHJhbnNmb3Jtcy5jb25jYXQoaG9va3MxLmRhdGVQb2ludFRyYW5zZm9ybXMpLFxyXG4gICAgICAgICAgICBkYXRlU3BhblRyYW5zZm9ybXM6IGhvb2tzMC5kYXRlU3BhblRyYW5zZm9ybXMuY29uY2F0KGhvb2tzMS5kYXRlU3BhblRyYW5zZm9ybXMpLFxyXG4gICAgICAgICAgICB2aWV3czogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBob29rczAudmlld3MpLCBob29rczEudmlld3MpLFxyXG4gICAgICAgICAgICB2aWV3UHJvcHNUcmFuc2Zvcm1lcnM6IGhvb2tzMC52aWV3UHJvcHNUcmFuc2Zvcm1lcnMuY29uY2F0KGhvb2tzMS52aWV3UHJvcHNUcmFuc2Zvcm1lcnMpLFxyXG4gICAgICAgICAgICBpc1Byb3BzVmFsaWQ6IGhvb2tzMS5pc1Byb3BzVmFsaWQgfHwgaG9va3MwLmlzUHJvcHNWYWxpZCxcclxuICAgICAgICAgICAgZXh0ZXJuYWxEZWZUcmFuc2Zvcm1zOiBob29rczAuZXh0ZXJuYWxEZWZUcmFuc2Zvcm1zLmNvbmNhdChob29rczEuZXh0ZXJuYWxEZWZUcmFuc2Zvcm1zKSxcclxuICAgICAgICAgICAgdmlld0NvbnRhaW5lckFwcGVuZHM6IGhvb2tzMC52aWV3Q29udGFpbmVyQXBwZW5kcy5jb25jYXQoaG9va3MxLnZpZXdDb250YWluZXJBcHBlbmRzKSxcclxuICAgICAgICAgICAgZXZlbnREcm9wVHJhbnNmb3JtZXJzOiBob29rczAuZXZlbnREcm9wVHJhbnNmb3JtZXJzLmNvbmNhdChob29rczEuZXZlbnREcm9wVHJhbnNmb3JtZXJzKSxcclxuICAgICAgICAgICAgY2FsZW5kYXJJbnRlcmFjdGlvbnM6IGhvb2tzMC5jYWxlbmRhckludGVyYWN0aW9ucy5jb25jYXQoaG9va3MxLmNhbGVuZGFySW50ZXJhY3Rpb25zKSxcclxuICAgICAgICAgICAgY29tcG9uZW50SW50ZXJhY3Rpb25zOiBob29rczAuY29tcG9uZW50SW50ZXJhY3Rpb25zLmNvbmNhdChob29rczEuY29tcG9uZW50SW50ZXJhY3Rpb25zKSxcclxuICAgICAgICAgICAgdGhlbWVDbGFzc2VzOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGhvb2tzMC50aGVtZUNsYXNzZXMpLCBob29rczEudGhlbWVDbGFzc2VzKSxcclxuICAgICAgICAgICAgZXZlbnRTb3VyY2VEZWZzOiBob29rczAuZXZlbnRTb3VyY2VEZWZzLmNvbmNhdChob29rczEuZXZlbnRTb3VyY2VEZWZzKSxcclxuICAgICAgICAgICAgY21kRm9ybWF0dGVyOiBob29rczEuY21kRm9ybWF0dGVyIHx8IGhvb2tzMC5jbWRGb3JtYXR0ZXIsXHJcbiAgICAgICAgICAgIHJlY3VycmluZ1R5cGVzOiBob29rczAucmVjdXJyaW5nVHlwZXMuY29uY2F0KGhvb2tzMS5yZWN1cnJpbmdUeXBlcyksXHJcbiAgICAgICAgICAgIG5hbWVkVGltZVpvbmVkSW1wbDogaG9va3MxLm5hbWVkVGltZVpvbmVkSW1wbCB8fCBob29rczAubmFtZWRUaW1lWm9uZWRJbXBsLFxyXG4gICAgICAgICAgICBpbml0aWFsVmlldzogaG9va3MwLmluaXRpYWxWaWV3IHx8IGhvb2tzMS5pbml0aWFsVmlldyxcclxuICAgICAgICAgICAgZWxlbWVudERyYWdnaW5nSW1wbDogaG9va3MwLmVsZW1lbnREcmFnZ2luZ0ltcGwgfHwgaG9va3MxLmVsZW1lbnREcmFnZ2luZ0ltcGwsXHJcbiAgICAgICAgICAgIG9wdGlvbkNoYW5nZUhhbmRsZXJzOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGhvb2tzMC5vcHRpb25DaGFuZ2VIYW5kbGVycyksIGhvb2tzMS5vcHRpb25DaGFuZ2VIYW5kbGVycyksXHJcbiAgICAgICAgICAgIHNjcm9sbEdyaWRJbXBsOiBob29rczEuc2Nyb2xsR3JpZEltcGwgfHwgaG9va3MwLnNjcm9sbEdyaWRJbXBsLFxyXG4gICAgICAgICAgICBsaXN0ZW5lclJlZmluZXJzOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGhvb2tzMC5saXN0ZW5lclJlZmluZXJzKSwgaG9va3MxLmxpc3RlbmVyUmVmaW5lcnMpLFxyXG4gICAgICAgICAgICBvcHRpb25SZWZpbmVyczogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBob29rczAub3B0aW9uUmVmaW5lcnMpLCBob29rczEub3B0aW9uUmVmaW5lcnMpLFxyXG4gICAgICAgICAgICBwcm9wU2V0SGFuZGxlcnM6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgaG9va3MwLnByb3BTZXRIYW5kbGVycyksIGhvb2tzMS5wcm9wU2V0SGFuZGxlcnMpLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBjb21wYXJlT3B0aW9uYWxEYXRlcyhkYXRlMCwgZGF0ZTEpIHtcclxuICAgICAgICBpZiAoZGF0ZTAgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZGF0ZTE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChkYXRlMSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkYXRlMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKE1hdGgubWF4KGRhdGUwLnZhbHVlT2YoKSwgZGF0ZTEudmFsdWVPZigpKSk7XHJcbiAgICB9XHJcblxyXG4gICAgY2xhc3MgU3RhbmRhcmRUaGVtZSBleHRlbmRzIFRoZW1lIHtcclxuICAgIH1cclxuICAgIFN0YW5kYXJkVGhlbWUucHJvdG90eXBlLmNsYXNzZXMgPSB7XHJcbiAgICAgICAgcm9vdDogJ2ZjLXRoZW1lLXN0YW5kYXJkJyxcclxuICAgICAgICB0YWJsZUNlbGxTaGFkZWQ6ICdmYy1jZWxsLXNoYWRlZCcsXHJcbiAgICAgICAgYnV0dG9uR3JvdXA6ICdmYy1idXR0b24tZ3JvdXAnLFxyXG4gICAgICAgIGJ1dHRvbjogJ2ZjLWJ1dHRvbiBmYy1idXR0b24tcHJpbWFyeScsXHJcbiAgICAgICAgYnV0dG9uQWN0aXZlOiAnZmMtYnV0dG9uLWFjdGl2ZScsXHJcbiAgICB9O1xyXG4gICAgU3RhbmRhcmRUaGVtZS5wcm90b3R5cGUuYmFzZUljb25DbGFzcyA9ICdmYy1pY29uJztcclxuICAgIFN0YW5kYXJkVGhlbWUucHJvdG90eXBlLmljb25DbGFzc2VzID0ge1xyXG4gICAgICAgIGNsb3NlOiAnZmMtaWNvbi14JyxcclxuICAgICAgICBwcmV2OiAnZmMtaWNvbi1jaGV2cm9uLWxlZnQnLFxyXG4gICAgICAgIG5leHQ6ICdmYy1pY29uLWNoZXZyb24tcmlnaHQnLFxyXG4gICAgICAgIHByZXZZZWFyOiAnZmMtaWNvbi1jaGV2cm9ucy1sZWZ0JyxcclxuICAgICAgICBuZXh0WWVhcjogJ2ZjLWljb24tY2hldnJvbnMtcmlnaHQnLFxyXG4gICAgfTtcclxuICAgIFN0YW5kYXJkVGhlbWUucHJvdG90eXBlLnJ0bEljb25DbGFzc2VzID0ge1xyXG4gICAgICAgIHByZXY6ICdmYy1pY29uLWNoZXZyb24tcmlnaHQnLFxyXG4gICAgICAgIG5leHQ6ICdmYy1pY29uLWNoZXZyb24tbGVmdCcsXHJcbiAgICAgICAgcHJldlllYXI6ICdmYy1pY29uLWNoZXZyb25zLXJpZ2h0JyxcclxuICAgICAgICBuZXh0WWVhcjogJ2ZjLWljb24tY2hldnJvbnMtbGVmdCcsXHJcbiAgICB9O1xyXG4gICAgU3RhbmRhcmRUaGVtZS5wcm90b3R5cGUuaWNvbk92ZXJyaWRlT3B0aW9uID0gJ2J1dHRvbkljb25zJzsgLy8gVE9ETzogbWFrZSBUUy1mcmllbmRseVxyXG4gICAgU3RhbmRhcmRUaGVtZS5wcm90b3R5cGUuaWNvbk92ZXJyaWRlQ3VzdG9tQnV0dG9uT3B0aW9uID0gJ2ljb24nO1xyXG4gICAgU3RhbmRhcmRUaGVtZS5wcm90b3R5cGUuaWNvbk92ZXJyaWRlUHJlZml4ID0gJ2ZjLWljb24tJztcclxuXHJcbiAgICBmdW5jdGlvbiBjb21waWxlVmlld0RlZnMoZGVmYXVsdENvbmZpZ3MsIG92ZXJyaWRlQ29uZmlncykge1xyXG4gICAgICAgIGxldCBoYXNoID0ge307XHJcbiAgICAgICAgbGV0IHZpZXdUeXBlO1xyXG4gICAgICAgIGZvciAodmlld1R5cGUgaW4gZGVmYXVsdENvbmZpZ3MpIHtcclxuICAgICAgICAgICAgZW5zdXJlVmlld0RlZih2aWV3VHlwZSwgaGFzaCwgZGVmYXVsdENvbmZpZ3MsIG92ZXJyaWRlQ29uZmlncyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAodmlld1R5cGUgaW4gb3ZlcnJpZGVDb25maWdzKSB7XHJcbiAgICAgICAgICAgIGVuc3VyZVZpZXdEZWYodmlld1R5cGUsIGhhc2gsIGRlZmF1bHRDb25maWdzLCBvdmVycmlkZUNvbmZpZ3MpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaGFzaDtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGVuc3VyZVZpZXdEZWYodmlld1R5cGUsIGhhc2gsIGRlZmF1bHRDb25maWdzLCBvdmVycmlkZUNvbmZpZ3MpIHtcclxuICAgICAgICBpZiAoaGFzaFt2aWV3VHlwZV0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIGhhc2hbdmlld1R5cGVdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgdmlld0RlZiA9IGJ1aWxkVmlld0RlZih2aWV3VHlwZSwgaGFzaCwgZGVmYXVsdENvbmZpZ3MsIG92ZXJyaWRlQ29uZmlncyk7XHJcbiAgICAgICAgaWYgKHZpZXdEZWYpIHtcclxuICAgICAgICAgICAgaGFzaFt2aWV3VHlwZV0gPSB2aWV3RGVmO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdmlld0RlZjtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGJ1aWxkVmlld0RlZih2aWV3VHlwZSwgaGFzaCwgZGVmYXVsdENvbmZpZ3MsIG92ZXJyaWRlQ29uZmlncykge1xyXG4gICAgICAgIGxldCBkZWZhdWx0Q29uZmlnID0gZGVmYXVsdENvbmZpZ3Nbdmlld1R5cGVdO1xyXG4gICAgICAgIGxldCBvdmVycmlkZUNvbmZpZyA9IG92ZXJyaWRlQ29uZmlnc1t2aWV3VHlwZV07XHJcbiAgICAgICAgbGV0IHF1ZXJ5UHJvcCA9IChuYW1lKSA9PiAoKGRlZmF1bHRDb25maWcgJiYgZGVmYXVsdENvbmZpZ1tuYW1lXSAhPT0gbnVsbCkgPyBkZWZhdWx0Q29uZmlnW25hbWVdIDpcclxuICAgICAgICAgICAgKChvdmVycmlkZUNvbmZpZyAmJiBvdmVycmlkZUNvbmZpZ1tuYW1lXSAhPT0gbnVsbCkgPyBvdmVycmlkZUNvbmZpZ1tuYW1lXSA6IG51bGwpKTtcclxuICAgICAgICBsZXQgdGhlQ29tcG9uZW50ID0gcXVlcnlQcm9wKCdjb21wb25lbnQnKTtcclxuICAgICAgICBsZXQgc3VwZXJUeXBlID0gcXVlcnlQcm9wKCdzdXBlclR5cGUnKTtcclxuICAgICAgICBsZXQgc3VwZXJEZWYgPSBudWxsO1xyXG4gICAgICAgIGlmIChzdXBlclR5cGUpIHtcclxuICAgICAgICAgICAgaWYgKHN1cGVyVHlwZSA9PT0gdmlld1R5cGUpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuXFwndCBoYXZlIGEgY3VzdG9tIHZpZXcgdHlwZSB0aGF0IHJlZmVyZW5jZXMgaXRzZWxmJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc3VwZXJEZWYgPSBlbnN1cmVWaWV3RGVmKHN1cGVyVHlwZSwgaGFzaCwgZGVmYXVsdENvbmZpZ3MsIG92ZXJyaWRlQ29uZmlncyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdGhlQ29tcG9uZW50ICYmIHN1cGVyRGVmKSB7XHJcbiAgICAgICAgICAgIHRoZUNvbXBvbmVudCA9IHN1cGVyRGVmLmNvbXBvbmVudDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCF0aGVDb21wb25lbnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7IC8vIGRvbid0IHRocm93IGEgd2FybmluZywgbWlnaHQgYmUgc2V0dGluZ3MgZm9yIGEgc2luZ2xlLXVuaXQgdmlld1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB0eXBlOiB2aWV3VHlwZSxcclxuICAgICAgICAgICAgY29tcG9uZW50OiB0aGVDb21wb25lbnQsXHJcbiAgICAgICAgICAgIGRlZmF1bHRzOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIChzdXBlckRlZiA/IHN1cGVyRGVmLmRlZmF1bHRzIDoge30pKSwgKGRlZmF1bHRDb25maWcgPyBkZWZhdWx0Q29uZmlnLnJhd09wdGlvbnMgOiB7fSkpLFxyXG4gICAgICAgICAgICBvdmVycmlkZXM6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgKHN1cGVyRGVmID8gc3VwZXJEZWYub3ZlcnJpZGVzIDoge30pKSwgKG92ZXJyaWRlQ29uZmlnID8gb3ZlcnJpZGVDb25maWcucmF3T3B0aW9ucyA6IHt9KSksXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBwYXJzZVZpZXdDb25maWdzKGlucHV0cykge1xyXG4gICAgICAgIHJldHVybiBtYXBIYXNoKGlucHV0cywgcGFyc2VWaWV3Q29uZmlnKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHBhcnNlVmlld0NvbmZpZyhpbnB1dCkge1xyXG4gICAgICAgIGxldCByYXdPcHRpb25zID0gdHlwZW9mIGlucHV0ID09PSAnZnVuY3Rpb24nID9cclxuICAgICAgICAgICAgeyBjb21wb25lbnQ6IGlucHV0IH0gOlxyXG4gICAgICAgICAgICBpbnB1dDtcclxuICAgICAgICBsZXQgeyBjb21wb25lbnQgfSA9IHJhd09wdGlvbnM7XHJcbiAgICAgICAgaWYgKHJhd09wdGlvbnMuY29udGVudCkge1xyXG4gICAgICAgICAgICAvLyBUT0RPOiByZW1vdmUgY29udGVudC9jbGFzc05hbWVzL2RpZE1vdW50L2V0YyBmcm9tIG9wdGlvbnM/XHJcbiAgICAgICAgICAgIGNvbXBvbmVudCA9IGNyZWF0ZVZpZXdIb29rQ29tcG9uZW50KHJhd09wdGlvbnMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjb21wb25lbnQgJiYgIShjb21wb25lbnQucHJvdG90eXBlIGluc3RhbmNlb2YgQmFzZUNvbXBvbmVudCkpIHtcclxuICAgICAgICAgICAgLy8gV0hZPzogcGVvcGxlIHdlcmUgdXNpbmcgYGNvbXBvbmVudGAgcHJvcGVydHkgZm9yIGBjb250ZW50YFxyXG4gICAgICAgICAgICAvLyBUT0RPOiBjb252ZXJnZSBvbiBvbmUgc2V0dGluZyBuYW1lXHJcbiAgICAgICAgICAgIGNvbXBvbmVudCA9IGNyZWF0ZVZpZXdIb29rQ29tcG9uZW50KE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcmF3T3B0aW9ucyksIHsgY29udGVudDogY29tcG9uZW50IH0pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgc3VwZXJUeXBlOiByYXdPcHRpb25zLnR5cGUsXHJcbiAgICAgICAgICAgIGNvbXBvbmVudDogY29tcG9uZW50LFxyXG4gICAgICAgICAgICByYXdPcHRpb25zLCAvLyBpbmNsdWRlcyB0eXBlIGFuZCBjb21wb25lbnQgdG9vIDooXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGNyZWF0ZVZpZXdIb29rQ29tcG9uZW50KG9wdGlvbnMpIHtcclxuICAgICAgICByZXR1cm4gKHZpZXdQcm9wcykgPT4gKHkoVmlld0NvbnRleHRUeXBlLkNvbnN1bWVyLCBudWxsLCAoY29udGV4dCkgPT4gKHkoQ29udGVudENvbnRhaW5lciwgeyBlbFRhZzogXCJkaXZcIiwgZWxDbGFzc2VzOiBidWlsZFZpZXdDbGFzc05hbWVzKGNvbnRleHQudmlld1NwZWMpLCByZW5kZXJQcm9wczogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB2aWV3UHJvcHMpLCB7IG5leHREYXlUaHJlc2hvbGQ6IGNvbnRleHQub3B0aW9ucy5uZXh0RGF5VGhyZXNob2xkIH0pLCBnZW5lcmF0b3JOYW1lOiB1bmRlZmluZWQsIGN1c3RvbUdlbmVyYXRvcjogb3B0aW9ucy5jb250ZW50LCBjbGFzc05hbWVHZW5lcmF0b3I6IG9wdGlvbnMuY2xhc3NOYW1lcywgZGlkTW91bnQ6IG9wdGlvbnMuZGlkTW91bnQsIHdpbGxVbm1vdW50OiBvcHRpb25zLndpbGxVbm1vdW50IH0pKSkpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGJ1aWxkVmlld1NwZWNzKGRlZmF1bHRJbnB1dHMsIG9wdGlvbk92ZXJyaWRlcywgZHluYW1pY09wdGlvbk92ZXJyaWRlcywgbG9jYWxlRGVmYXVsdHMpIHtcclxuICAgICAgICBsZXQgZGVmYXVsdENvbmZpZ3MgPSBwYXJzZVZpZXdDb25maWdzKGRlZmF1bHRJbnB1dHMpO1xyXG4gICAgICAgIGxldCBvdmVycmlkZUNvbmZpZ3MgPSBwYXJzZVZpZXdDb25maWdzKG9wdGlvbk92ZXJyaWRlcy52aWV3cyk7XHJcbiAgICAgICAgbGV0IHZpZXdEZWZzID0gY29tcGlsZVZpZXdEZWZzKGRlZmF1bHRDb25maWdzLCBvdmVycmlkZUNvbmZpZ3MpO1xyXG4gICAgICAgIHJldHVybiBtYXBIYXNoKHZpZXdEZWZzLCAodmlld0RlZikgPT4gYnVpbGRWaWV3U3BlYyh2aWV3RGVmLCBvdmVycmlkZUNvbmZpZ3MsIG9wdGlvbk92ZXJyaWRlcywgZHluYW1pY09wdGlvbk92ZXJyaWRlcywgbG9jYWxlRGVmYXVsdHMpKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGJ1aWxkVmlld1NwZWModmlld0RlZiwgb3ZlcnJpZGVDb25maWdzLCBvcHRpb25PdmVycmlkZXMsIGR5bmFtaWNPcHRpb25PdmVycmlkZXMsIGxvY2FsZURlZmF1bHRzKSB7XHJcbiAgICAgICAgbGV0IGR1cmF0aW9uSW5wdXQgPSB2aWV3RGVmLm92ZXJyaWRlcy5kdXJhdGlvbiB8fFxyXG4gICAgICAgICAgICB2aWV3RGVmLmRlZmF1bHRzLmR1cmF0aW9uIHx8XHJcbiAgICAgICAgICAgIGR5bmFtaWNPcHRpb25PdmVycmlkZXMuZHVyYXRpb24gfHxcclxuICAgICAgICAgICAgb3B0aW9uT3ZlcnJpZGVzLmR1cmF0aW9uO1xyXG4gICAgICAgIGxldCBkdXJhdGlvbiA9IG51bGw7XHJcbiAgICAgICAgbGV0IGR1cmF0aW9uVW5pdCA9ICcnO1xyXG4gICAgICAgIGxldCBzaW5nbGVVbml0ID0gJyc7XHJcbiAgICAgICAgbGV0IHNpbmdsZVVuaXRPdmVycmlkZXMgPSB7fTtcclxuICAgICAgICBpZiAoZHVyYXRpb25JbnB1dCkge1xyXG4gICAgICAgICAgICBkdXJhdGlvbiA9IGNyZWF0ZUR1cmF0aW9uQ2FjaGVkKGR1cmF0aW9uSW5wdXQpO1xyXG4gICAgICAgICAgICBpZiAoZHVyYXRpb24pIHsgLy8gdmFsaWQ/XHJcbiAgICAgICAgICAgICAgICBsZXQgZGVub20gPSBncmVhdGVzdER1cmF0aW9uRGVub21pbmF0b3IoZHVyYXRpb24pO1xyXG4gICAgICAgICAgICAgICAgZHVyYXRpb25Vbml0ID0gZGVub20udW5pdDtcclxuICAgICAgICAgICAgICAgIGlmIChkZW5vbS52YWx1ZSA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNpbmdsZVVuaXQgPSBkdXJhdGlvblVuaXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgc2luZ2xlVW5pdE92ZXJyaWRlcyA9IG92ZXJyaWRlQ29uZmlnc1tkdXJhdGlvblVuaXRdID8gb3ZlcnJpZGVDb25maWdzW2R1cmF0aW9uVW5pdF0ucmF3T3B0aW9ucyA6IHt9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBxdWVyeUJ1dHRvblRleHQgPSAob3B0aW9uc1N1YnNldCkgPT4ge1xyXG4gICAgICAgICAgICBsZXQgYnV0dG9uVGV4dE1hcCA9IG9wdGlvbnNTdWJzZXQuYnV0dG9uVGV4dCB8fCB7fTtcclxuICAgICAgICAgICAgbGV0IGJ1dHRvblRleHRLZXkgPSB2aWV3RGVmLmRlZmF1bHRzLmJ1dHRvblRleHRLZXk7XHJcbiAgICAgICAgICAgIGlmIChidXR0b25UZXh0S2V5ICE9IG51bGwgJiYgYnV0dG9uVGV4dE1hcFtidXR0b25UZXh0S2V5XSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYnV0dG9uVGV4dE1hcFtidXR0b25UZXh0S2V5XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoYnV0dG9uVGV4dE1hcFt2aWV3RGVmLnR5cGVdICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBidXR0b25UZXh0TWFwW3ZpZXdEZWYudHlwZV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGJ1dHRvblRleHRNYXBbc2luZ2xlVW5pdF0gIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJ1dHRvblRleHRNYXBbc2luZ2xlVW5pdF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBsZXQgcXVlcnlCdXR0b25UaXRsZSA9IChvcHRpb25zU3Vic2V0KSA9PiB7XHJcbiAgICAgICAgICAgIGxldCBidXR0b25IaW50cyA9IG9wdGlvbnNTdWJzZXQuYnV0dG9uSGludHMgfHwge307XHJcbiAgICAgICAgICAgIGxldCBidXR0b25LZXkgPSB2aWV3RGVmLmRlZmF1bHRzLmJ1dHRvblRleHRLZXk7IC8vIHVzZSBzYW1lIGtleSBhcyB0ZXh0XHJcbiAgICAgICAgICAgIGlmIChidXR0b25LZXkgIT0gbnVsbCAmJiBidXR0b25IaW50c1tidXR0b25LZXldICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBidXR0b25IaW50c1tidXR0b25LZXldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChidXR0b25IaW50c1t2aWV3RGVmLnR5cGVdICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBidXR0b25IaW50c1t2aWV3RGVmLnR5cGVdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChidXR0b25IaW50c1tzaW5nbGVVbml0XSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYnV0dG9uSGludHNbc2luZ2xlVW5pdF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB0eXBlOiB2aWV3RGVmLnR5cGUsXHJcbiAgICAgICAgICAgIGNvbXBvbmVudDogdmlld0RlZi5jb21wb25lbnQsXHJcbiAgICAgICAgICAgIGR1cmF0aW9uLFxyXG4gICAgICAgICAgICBkdXJhdGlvblVuaXQsXHJcbiAgICAgICAgICAgIHNpbmdsZVVuaXQsXHJcbiAgICAgICAgICAgIG9wdGlvbkRlZmF1bHRzOiB2aWV3RGVmLmRlZmF1bHRzLFxyXG4gICAgICAgICAgICBvcHRpb25PdmVycmlkZXM6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc2luZ2xlVW5pdE92ZXJyaWRlcyksIHZpZXdEZWYub3ZlcnJpZGVzKSxcclxuICAgICAgICAgICAgYnV0dG9uVGV4dE92ZXJyaWRlOiBxdWVyeUJ1dHRvblRleHQoZHluYW1pY09wdGlvbk92ZXJyaWRlcykgfHxcclxuICAgICAgICAgICAgICAgIHF1ZXJ5QnV0dG9uVGV4dChvcHRpb25PdmVycmlkZXMpIHx8IC8vIGNvbnN0cnVjdG9yLXNwZWNpZmllZCBidXR0b25UZXh0IGxvb2t1cCBoYXNoIHRha2VzIHByZWNlZGVuY2VcclxuICAgICAgICAgICAgICAgIHZpZXdEZWYub3ZlcnJpZGVzLmJ1dHRvblRleHQsXHJcbiAgICAgICAgICAgIGJ1dHRvblRleHREZWZhdWx0OiBxdWVyeUJ1dHRvblRleHQobG9jYWxlRGVmYXVsdHMpIHx8XHJcbiAgICAgICAgICAgICAgICB2aWV3RGVmLmRlZmF1bHRzLmJ1dHRvblRleHQgfHxcclxuICAgICAgICAgICAgICAgIHF1ZXJ5QnV0dG9uVGV4dChCQVNFX09QVElPTl9ERUZBVUxUUykgfHxcclxuICAgICAgICAgICAgICAgIHZpZXdEZWYudHlwZSxcclxuICAgICAgICAgICAgLy8gbm90IERSWVxyXG4gICAgICAgICAgICBidXR0b25UaXRsZU92ZXJyaWRlOiBxdWVyeUJ1dHRvblRpdGxlKGR5bmFtaWNPcHRpb25PdmVycmlkZXMpIHx8XHJcbiAgICAgICAgICAgICAgICBxdWVyeUJ1dHRvblRpdGxlKG9wdGlvbk92ZXJyaWRlcykgfHxcclxuICAgICAgICAgICAgICAgIHZpZXdEZWYub3ZlcnJpZGVzLmJ1dHRvbkhpbnQsXHJcbiAgICAgICAgICAgIGJ1dHRvblRpdGxlRGVmYXVsdDogcXVlcnlCdXR0b25UaXRsZShsb2NhbGVEZWZhdWx0cykgfHxcclxuICAgICAgICAgICAgICAgIHZpZXdEZWYuZGVmYXVsdHMuYnV0dG9uSGludCB8fFxyXG4gICAgICAgICAgICAgICAgcXVlcnlCdXR0b25UaXRsZShCQVNFX09QVElPTl9ERUZBVUxUUyksXHJcbiAgICAgICAgICAgIC8vIHdpbGwgZXZlbnR1YWxseSBmYWxsIGJhY2sgdG8gYnV0dG9uVGV4dFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICAvLyBoYWNrIHRvIGdldCBtZW1vaXphdGlvbiB3b3JraW5nXHJcbiAgICBsZXQgZHVyYXRpb25JbnB1dE1hcCA9IHt9O1xyXG4gICAgZnVuY3Rpb24gY3JlYXRlRHVyYXRpb25DYWNoZWQoZHVyYXRpb25JbnB1dCkge1xyXG4gICAgICAgIGxldCBqc29uID0gSlNPTi5zdHJpbmdpZnkoZHVyYXRpb25JbnB1dCk7XHJcbiAgICAgICAgbGV0IHJlcyA9IGR1cmF0aW9uSW5wdXRNYXBbanNvbl07XHJcbiAgICAgICAgaWYgKHJlcyA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJlcyA9IGNyZWF0ZUR1cmF0aW9uKGR1cmF0aW9uSW5wdXQpO1xyXG4gICAgICAgICAgICBkdXJhdGlvbklucHV0TWFwW2pzb25dID0gcmVzO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHJlZHVjZVZpZXdUeXBlKHZpZXdUeXBlLCBhY3Rpb24pIHtcclxuICAgICAgICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgJ0NIQU5HRV9WSUVXX1RZUEUnOlxyXG4gICAgICAgICAgICAgICAgdmlld1R5cGUgPSBhY3Rpb24udmlld1R5cGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB2aWV3VHlwZTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiByZWR1Y2VEeW5hbWljT3B0aW9uT3ZlcnJpZGVzKGR5bmFtaWNPcHRpb25PdmVycmlkZXMsIGFjdGlvbikge1xyXG4gICAgICAgIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcclxuICAgICAgICAgICAgY2FzZSAnU0VUX09QVElPTic6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzKSwgeyBbYWN0aW9uLm9wdGlvbk5hbWVdOiBhY3Rpb24ucmF3T3B0aW9uVmFsdWUgfSk7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZHluYW1pY09wdGlvbk92ZXJyaWRlcztcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcmVkdWNlRGF0ZVByb2ZpbGUoY3VycmVudERhdGVQcm9maWxlLCBhY3Rpb24sIGN1cnJlbnREYXRlLCBkYXRlUHJvZmlsZUdlbmVyYXRvcikge1xyXG4gICAgICAgIGxldCBkcDtcclxuICAgICAgICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgJ0NIQU5HRV9WSUVXX1RZUEUnOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGVQcm9maWxlR2VuZXJhdG9yLmJ1aWxkKGFjdGlvbi5kYXRlTWFya2VyIHx8IGN1cnJlbnREYXRlKTtcclxuICAgICAgICAgICAgY2FzZSAnQ0hBTkdFX0RBVEUnOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGVQcm9maWxlR2VuZXJhdG9yLmJ1aWxkKGFjdGlvbi5kYXRlTWFya2VyKTtcclxuICAgICAgICAgICAgY2FzZSAnUFJFVic6XHJcbiAgICAgICAgICAgICAgICBkcCA9IGRhdGVQcm9maWxlR2VuZXJhdG9yLmJ1aWxkUHJldihjdXJyZW50RGF0ZVByb2ZpbGUsIGN1cnJlbnREYXRlKTtcclxuICAgICAgICAgICAgICAgIGlmIChkcC5pc1ZhbGlkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRwO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ05FWFQnOlxyXG4gICAgICAgICAgICAgICAgZHAgPSBkYXRlUHJvZmlsZUdlbmVyYXRvci5idWlsZE5leHQoY3VycmVudERhdGVQcm9maWxlLCBjdXJyZW50RGF0ZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZHAuaXNWYWxpZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkcDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY3VycmVudERhdGVQcm9maWxlO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGluaXRFdmVudFNvdXJjZXMoY2FsZW5kYXJPcHRpb25zLCBkYXRlUHJvZmlsZSwgY29udGV4dCkge1xyXG4gICAgICAgIGxldCBhY3RpdmVSYW5nZSA9IGRhdGVQcm9maWxlID8gZGF0ZVByb2ZpbGUuYWN0aXZlUmFuZ2UgOiBudWxsO1xyXG4gICAgICAgIHJldHVybiBhZGRTb3VyY2VzKHt9LCBwYXJzZUluaXRpYWxTb3VyY2VzKGNhbGVuZGFyT3B0aW9ucywgY29udGV4dCksIGFjdGl2ZVJhbmdlLCBjb250ZXh0KTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHJlZHVjZUV2ZW50U291cmNlcyhldmVudFNvdXJjZXMsIGFjdGlvbiwgZGF0ZVByb2ZpbGUsIGNvbnRleHQpIHtcclxuICAgICAgICBsZXQgYWN0aXZlUmFuZ2UgPSBkYXRlUHJvZmlsZSA/IGRhdGVQcm9maWxlLmFjdGl2ZVJhbmdlIDogbnVsbDsgLy8gbmVlZCB0aGlzIGNoZWNrP1xyXG4gICAgICAgIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcclxuICAgICAgICAgICAgY2FzZSAnQUREX0VWRU5UX1NPVVJDRVMnOiAvLyBhbHJlYWR5IHBhcnNlZFxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFkZFNvdXJjZXMoZXZlbnRTb3VyY2VzLCBhY3Rpb24uc291cmNlcywgYWN0aXZlUmFuZ2UsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICBjYXNlICdSRU1PVkVfRVZFTlRfU09VUkNFJzpcclxuICAgICAgICAgICAgICAgIHJldHVybiByZW1vdmVTb3VyY2UoZXZlbnRTb3VyY2VzLCBhY3Rpb24uc291cmNlSWQpO1xyXG4gICAgICAgICAgICBjYXNlICdQUkVWJzogLy8gVE9ETzogaG93IGRvIHdlIHRyYWNrIGFsbCBhY3Rpb25zIHRoYXQgYWZmZWN0IGRhdGVQcm9maWxlIDooXHJcbiAgICAgICAgICAgIGNhc2UgJ05FWFQnOlxyXG4gICAgICAgICAgICBjYXNlICdDSEFOR0VfREFURSc6XHJcbiAgICAgICAgICAgIGNhc2UgJ0NIQU5HRV9WSUVXX1RZUEUnOlxyXG4gICAgICAgICAgICAgICAgaWYgKGRhdGVQcm9maWxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZldGNoRGlydHlTb3VyY2VzKGV2ZW50U291cmNlcywgYWN0aXZlUmFuZ2UsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGV2ZW50U291cmNlcztcclxuICAgICAgICAgICAgY2FzZSAnRkVUQ0hfRVZFTlRfU09VUkNFUyc6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmV0Y2hTb3VyY2VzQnlJZHMoZXZlbnRTb3VyY2VzLCBhY3Rpb24uc291cmNlSWRzID8gLy8gd2h5IG5vIHR5cGU/XHJcbiAgICAgICAgICAgICAgICAgICAgYXJyYXlUb0hhc2goYWN0aW9uLnNvdXJjZUlkcykgOlxyXG4gICAgICAgICAgICAgICAgICAgIGV4Y2x1ZGVTdGF0aWNTb3VyY2VzKGV2ZW50U291cmNlcywgY29udGV4dCksIGFjdGl2ZVJhbmdlLCBhY3Rpb24uaXNSZWZldGNoIHx8IGZhbHNlLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgY2FzZSAnUkVDRUlWRV9FVkVOVFMnOlxyXG4gICAgICAgICAgICBjYXNlICdSRUNFSVZFX0VWRU5UX0VSUk9SJzpcclxuICAgICAgICAgICAgICAgIHJldHVybiByZWNlaXZlUmVzcG9uc2UoZXZlbnRTb3VyY2VzLCBhY3Rpb24uc291cmNlSWQsIGFjdGlvbi5mZXRjaElkLCBhY3Rpb24uZmV0Y2hSYW5nZSk7XHJcbiAgICAgICAgICAgIGNhc2UgJ1JFTU9WRV9BTExfRVZFTlRfU09VUkNFUyc6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge307XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZXZlbnRTb3VyY2VzO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHJlZHVjZUV2ZW50U291cmNlc05ld1RpbWVab25lKGV2ZW50U291cmNlcywgZGF0ZVByb2ZpbGUsIGNvbnRleHQpIHtcclxuICAgICAgICBsZXQgYWN0aXZlUmFuZ2UgPSBkYXRlUHJvZmlsZSA/IGRhdGVQcm9maWxlLmFjdGl2ZVJhbmdlIDogbnVsbDsgLy8gbmVlZCB0aGlzIGNoZWNrP1xyXG4gICAgICAgIHJldHVybiBmZXRjaFNvdXJjZXNCeUlkcyhldmVudFNvdXJjZXMsIGV4Y2x1ZGVTdGF0aWNTb3VyY2VzKGV2ZW50U291cmNlcywgY29udGV4dCksIGFjdGl2ZVJhbmdlLCB0cnVlLCBjb250ZXh0KTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGNvbXB1dGVFdmVudFNvdXJjZXNMb2FkaW5nKGV2ZW50U291cmNlcykge1xyXG4gICAgICAgIGZvciAobGV0IHNvdXJjZUlkIGluIGV2ZW50U291cmNlcykge1xyXG4gICAgICAgICAgICBpZiAoZXZlbnRTb3VyY2VzW3NvdXJjZUlkXS5pc0ZldGNoaW5nKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBhZGRTb3VyY2VzKGV2ZW50U291cmNlSGFzaCwgc291cmNlcywgZmV0Y2hSYW5nZSwgY29udGV4dCkge1xyXG4gICAgICAgIGxldCBoYXNoID0ge307XHJcbiAgICAgICAgZm9yIChsZXQgc291cmNlIG9mIHNvdXJjZXMpIHtcclxuICAgICAgICAgICAgaGFzaFtzb3VyY2Uuc291cmNlSWRdID0gc291cmNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZmV0Y2hSYW5nZSkge1xyXG4gICAgICAgICAgICBoYXNoID0gZmV0Y2hEaXJ0eVNvdXJjZXMoaGFzaCwgZmV0Y2hSYW5nZSwgY29udGV4dCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGV2ZW50U291cmNlSGFzaCksIGhhc2gpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gcmVtb3ZlU291cmNlKGV2ZW50U291cmNlSGFzaCwgc291cmNlSWQpIHtcclxuICAgICAgICByZXR1cm4gZmlsdGVySGFzaChldmVudFNvdXJjZUhhc2gsIChldmVudFNvdXJjZSkgPT4gZXZlbnRTb3VyY2Uuc291cmNlSWQgIT09IHNvdXJjZUlkKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGZldGNoRGlydHlTb3VyY2VzKHNvdXJjZUhhc2gsIGZldGNoUmFuZ2UsIGNvbnRleHQpIHtcclxuICAgICAgICByZXR1cm4gZmV0Y2hTb3VyY2VzQnlJZHMoc291cmNlSGFzaCwgZmlsdGVySGFzaChzb3VyY2VIYXNoLCAoZXZlbnRTb3VyY2UpID0+IGlzU291cmNlRGlydHkoZXZlbnRTb3VyY2UsIGZldGNoUmFuZ2UsIGNvbnRleHQpKSwgZmV0Y2hSYW5nZSwgZmFsc2UsIGNvbnRleHQpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gaXNTb3VyY2VEaXJ0eShldmVudFNvdXJjZSwgZmV0Y2hSYW5nZSwgY29udGV4dCkge1xyXG4gICAgICAgIGlmICghZG9lc1NvdXJjZU5lZWRSYW5nZShldmVudFNvdXJjZSwgY29udGV4dCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuICFldmVudFNvdXJjZS5sYXRlc3RGZXRjaElkO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gIWNvbnRleHQub3B0aW9ucy5sYXp5RmV0Y2hpbmcgfHxcclxuICAgICAgICAgICAgIWV2ZW50U291cmNlLmZldGNoUmFuZ2UgfHxcclxuICAgICAgICAgICAgZXZlbnRTb3VyY2UuaXNGZXRjaGluZyB8fCAvLyBhbHdheXMgY2FuY2VsIG91dGRhdGVkIGluLXByb2dyZXNzIGZldGNoZXNcclxuICAgICAgICAgICAgZmV0Y2hSYW5nZS5zdGFydCA8IGV2ZW50U291cmNlLmZldGNoUmFuZ2Uuc3RhcnQgfHxcclxuICAgICAgICAgICAgZmV0Y2hSYW5nZS5lbmQgPiBldmVudFNvdXJjZS5mZXRjaFJhbmdlLmVuZDtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGZldGNoU291cmNlc0J5SWRzKHByZXZTb3VyY2VzLCBzb3VyY2VJZEhhc2gsIGZldGNoUmFuZ2UsIGlzUmVmZXRjaCwgY29udGV4dCkge1xyXG4gICAgICAgIGxldCBuZXh0U291cmNlcyA9IHt9O1xyXG4gICAgICAgIGZvciAobGV0IHNvdXJjZUlkIGluIHByZXZTb3VyY2VzKSB7XHJcbiAgICAgICAgICAgIGxldCBzb3VyY2UgPSBwcmV2U291cmNlc1tzb3VyY2VJZF07XHJcbiAgICAgICAgICAgIGlmIChzb3VyY2VJZEhhc2hbc291cmNlSWRdKSB7XHJcbiAgICAgICAgICAgICAgICBuZXh0U291cmNlc1tzb3VyY2VJZF0gPSBmZXRjaFNvdXJjZShzb3VyY2UsIGZldGNoUmFuZ2UsIGlzUmVmZXRjaCwgY29udGV4dCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBuZXh0U291cmNlc1tzb3VyY2VJZF0gPSBzb3VyY2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5leHRTb3VyY2VzO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZmV0Y2hTb3VyY2UoZXZlbnRTb3VyY2UsIGZldGNoUmFuZ2UsIGlzUmVmZXRjaCwgY29udGV4dCkge1xyXG4gICAgICAgIGxldCB7IG9wdGlvbnMsIGNhbGVuZGFyQXBpIH0gPSBjb250ZXh0O1xyXG4gICAgICAgIGxldCBzb3VyY2VEZWYgPSBjb250ZXh0LnBsdWdpbkhvb2tzLmV2ZW50U291cmNlRGVmc1tldmVudFNvdXJjZS5zb3VyY2VEZWZJZF07XHJcbiAgICAgICAgbGV0IGZldGNoSWQgPSBndWlkKCk7XHJcbiAgICAgICAgc291cmNlRGVmLmZldGNoKHtcclxuICAgICAgICAgICAgZXZlbnRTb3VyY2UsXHJcbiAgICAgICAgICAgIHJhbmdlOiBmZXRjaFJhbmdlLFxyXG4gICAgICAgICAgICBpc1JlZmV0Y2gsXHJcbiAgICAgICAgICAgIGNvbnRleHQsXHJcbiAgICAgICAgfSwgKHJlcykgPT4ge1xyXG4gICAgICAgICAgICBsZXQgeyByYXdFdmVudHMgfSA9IHJlcztcclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZXZlbnRTb3VyY2VTdWNjZXNzKSB7XHJcbiAgICAgICAgICAgICAgICByYXdFdmVudHMgPSBvcHRpb25zLmV2ZW50U291cmNlU3VjY2Vzcy5jYWxsKGNhbGVuZGFyQXBpLCByYXdFdmVudHMsIHJlcy5yZXNwb25zZSkgfHwgcmF3RXZlbnRzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChldmVudFNvdXJjZS5zdWNjZXNzKSB7XHJcbiAgICAgICAgICAgICAgICByYXdFdmVudHMgPSBldmVudFNvdXJjZS5zdWNjZXNzLmNhbGwoY2FsZW5kYXJBcGksIHJhd0V2ZW50cywgcmVzLnJlc3BvbnNlKSB8fCByYXdFdmVudHM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29udGV4dC5kaXNwYXRjaCh7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiAnUkVDRUlWRV9FVkVOVFMnLFxyXG4gICAgICAgICAgICAgICAgc291cmNlSWQ6IGV2ZW50U291cmNlLnNvdXJjZUlkLFxyXG4gICAgICAgICAgICAgICAgZmV0Y2hJZCxcclxuICAgICAgICAgICAgICAgIGZldGNoUmFuZ2UsXHJcbiAgICAgICAgICAgICAgICByYXdFdmVudHMsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sIChlcnJvcikgPT4ge1xyXG4gICAgICAgICAgICBsZXQgZXJyb3JIYW5kbGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmV2ZW50U291cmNlRmFpbHVyZSkge1xyXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5ldmVudFNvdXJjZUZhaWx1cmUuY2FsbChjYWxlbmRhckFwaSwgZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgZXJyb3JIYW5kbGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZXZlbnRTb3VyY2UuZmFpbHVyZSkge1xyXG4gICAgICAgICAgICAgICAgZXZlbnRTb3VyY2UuZmFpbHVyZShlcnJvcik7XHJcbiAgICAgICAgICAgICAgICBlcnJvckhhbmRsZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghZXJyb3JIYW5kbGVkKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oZXJyb3IubWVzc2FnZSwgZXJyb3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnRleHQuZGlzcGF0Y2goe1xyXG4gICAgICAgICAgICAgICAgdHlwZTogJ1JFQ0VJVkVfRVZFTlRfRVJST1InLFxyXG4gICAgICAgICAgICAgICAgc291cmNlSWQ6IGV2ZW50U291cmNlLnNvdXJjZUlkLFxyXG4gICAgICAgICAgICAgICAgZmV0Y2hJZCxcclxuICAgICAgICAgICAgICAgIGZldGNoUmFuZ2UsXHJcbiAgICAgICAgICAgICAgICBlcnJvcixcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZXZlbnRTb3VyY2UpLCB7IGlzRmV0Y2hpbmc6IHRydWUsIGxhdGVzdEZldGNoSWQ6IGZldGNoSWQgfSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiByZWNlaXZlUmVzcG9uc2Uoc291cmNlSGFzaCwgc291cmNlSWQsIGZldGNoSWQsIGZldGNoUmFuZ2UpIHtcclxuICAgICAgICBsZXQgZXZlbnRTb3VyY2UgPSBzb3VyY2VIYXNoW3NvdXJjZUlkXTtcclxuICAgICAgICBpZiAoZXZlbnRTb3VyY2UgJiYgLy8gbm90IGFscmVhZHkgcmVtb3ZlZFxyXG4gICAgICAgICAgICBmZXRjaElkID09PSBldmVudFNvdXJjZS5sYXRlc3RGZXRjaElkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHNvdXJjZUhhc2gpLCB7IFtzb3VyY2VJZF06IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZXZlbnRTb3VyY2UpLCB7IGlzRmV0Y2hpbmc6IGZhbHNlLCBmZXRjaFJhbmdlIH0pIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc291cmNlSGFzaDtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGV4Y2x1ZGVTdGF0aWNTb3VyY2VzKGV2ZW50U291cmNlcywgY29udGV4dCkge1xyXG4gICAgICAgIHJldHVybiBmaWx0ZXJIYXNoKGV2ZW50U291cmNlcywgKGV2ZW50U291cmNlKSA9PiBkb2VzU291cmNlTmVlZFJhbmdlKGV2ZW50U291cmNlLCBjb250ZXh0KSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBwYXJzZUluaXRpYWxTb3VyY2VzKHJhd09wdGlvbnMsIGNvbnRleHQpIHtcclxuICAgICAgICBsZXQgcmVmaW5lcnMgPSBidWlsZEV2ZW50U291cmNlUmVmaW5lcnMoY29udGV4dCk7XHJcbiAgICAgICAgbGV0IHJhd1NvdXJjZXMgPSBbXS5jb25jYXQocmF3T3B0aW9ucy5ldmVudFNvdXJjZXMgfHwgW10pO1xyXG4gICAgICAgIGxldCBzb3VyY2VzID0gW107IC8vIHBhcnNlZFxyXG4gICAgICAgIGlmIChyYXdPcHRpb25zLmluaXRpYWxFdmVudHMpIHtcclxuICAgICAgICAgICAgcmF3U291cmNlcy51bnNoaWZ0KHJhd09wdGlvbnMuaW5pdGlhbEV2ZW50cyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChyYXdPcHRpb25zLmV2ZW50cykge1xyXG4gICAgICAgICAgICByYXdTb3VyY2VzLnVuc2hpZnQocmF3T3B0aW9ucy5ldmVudHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGxldCByYXdTb3VyY2Ugb2YgcmF3U291cmNlcykge1xyXG4gICAgICAgICAgICBsZXQgc291cmNlID0gcGFyc2VFdmVudFNvdXJjZShyYXdTb3VyY2UsIGNvbnRleHQsIHJlZmluZXJzKTtcclxuICAgICAgICAgICAgaWYgKHNvdXJjZSkge1xyXG4gICAgICAgICAgICAgICAgc291cmNlcy5wdXNoKHNvdXJjZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHNvdXJjZXM7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBkb2VzU291cmNlTmVlZFJhbmdlKGV2ZW50U291cmNlLCBjb250ZXh0KSB7XHJcbiAgICAgICAgbGV0IGRlZnMgPSBjb250ZXh0LnBsdWdpbkhvb2tzLmV2ZW50U291cmNlRGVmcztcclxuICAgICAgICByZXR1cm4gIWRlZnNbZXZlbnRTb3VyY2Uuc291cmNlRGVmSWRdLmlnbm9yZVJhbmdlO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHJlZHVjZURhdGVTZWxlY3Rpb24oY3VycmVudFNlbGVjdGlvbiwgYWN0aW9uKSB7XHJcbiAgICAgICAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xyXG4gICAgICAgICAgICBjYXNlICdVTlNFTEVDVF9EQVRFUyc6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgY2FzZSAnU0VMRUNUX0RBVEVTJzpcclxuICAgICAgICAgICAgICAgIHJldHVybiBhY3Rpb24uc2VsZWN0aW9uO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRTZWxlY3Rpb247XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHJlZHVjZVNlbGVjdGVkRXZlbnQoY3VycmVudEluc3RhbmNlSWQsIGFjdGlvbikge1xyXG4gICAgICAgIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcclxuICAgICAgICAgICAgY2FzZSAnVU5TRUxFQ1RfRVZFTlQnOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICAgICAgICBjYXNlICdTRUxFQ1RfRVZFTlQnOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjdGlvbi5ldmVudEluc3RhbmNlSWQ7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY3VycmVudEluc3RhbmNlSWQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHJlZHVjZUV2ZW50RHJhZyhjdXJyZW50RHJhZywgYWN0aW9uKSB7XHJcbiAgICAgICAgbGV0IG5ld0RyYWc7XHJcbiAgICAgICAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xyXG4gICAgICAgICAgICBjYXNlICdVTlNFVF9FVkVOVF9EUkFHJzpcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICBjYXNlICdTRVRfRVZFTlRfRFJBRyc6XHJcbiAgICAgICAgICAgICAgICBuZXdEcmFnID0gYWN0aW9uLnN0YXRlO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICBhZmZlY3RlZEV2ZW50czogbmV3RHJhZy5hZmZlY3RlZEV2ZW50cyxcclxuICAgICAgICAgICAgICAgICAgICBtdXRhdGVkRXZlbnRzOiBuZXdEcmFnLm11dGF0ZWRFdmVudHMsXHJcbiAgICAgICAgICAgICAgICAgICAgaXNFdmVudDogbmV3RHJhZy5pc0V2ZW50LFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHJldHVybiBjdXJyZW50RHJhZztcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcmVkdWNlRXZlbnRSZXNpemUoY3VycmVudFJlc2l6ZSwgYWN0aW9uKSB7XHJcbiAgICAgICAgbGV0IG5ld1Jlc2l6ZTtcclxuICAgICAgICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgJ1VOU0VUX0VWRU5UX1JFU0laRSc6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgY2FzZSAnU0VUX0VWRU5UX1JFU0laRSc6XHJcbiAgICAgICAgICAgICAgICBuZXdSZXNpemUgPSBhY3Rpb24uc3RhdGU7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGFmZmVjdGVkRXZlbnRzOiBuZXdSZXNpemUuYWZmZWN0ZWRFdmVudHMsXHJcbiAgICAgICAgICAgICAgICAgICAgbXV0YXRlZEV2ZW50czogbmV3UmVzaXplLm11dGF0ZWRFdmVudHMsXHJcbiAgICAgICAgICAgICAgICAgICAgaXNFdmVudDogbmV3UmVzaXplLmlzRXZlbnQsXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRSZXNpemU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHBhcnNlVG9vbGJhcnMoY2FsZW5kYXJPcHRpb25zLCBjYWxlbmRhck9wdGlvbk92ZXJyaWRlcywgdGhlbWUsIHZpZXdTcGVjcywgY2FsZW5kYXJBcGkpIHtcclxuICAgICAgICBsZXQgaGVhZGVyID0gY2FsZW5kYXJPcHRpb25zLmhlYWRlclRvb2xiYXIgPyBwYXJzZVRvb2xiYXIoY2FsZW5kYXJPcHRpb25zLmhlYWRlclRvb2xiYXIsIGNhbGVuZGFyT3B0aW9ucywgY2FsZW5kYXJPcHRpb25PdmVycmlkZXMsIHRoZW1lLCB2aWV3U3BlY3MsIGNhbGVuZGFyQXBpKSA6IG51bGw7XHJcbiAgICAgICAgbGV0IGZvb3RlciA9IGNhbGVuZGFyT3B0aW9ucy5mb290ZXJUb29sYmFyID8gcGFyc2VUb29sYmFyKGNhbGVuZGFyT3B0aW9ucy5mb290ZXJUb29sYmFyLCBjYWxlbmRhck9wdGlvbnMsIGNhbGVuZGFyT3B0aW9uT3ZlcnJpZGVzLCB0aGVtZSwgdmlld1NwZWNzLCBjYWxlbmRhckFwaSkgOiBudWxsO1xyXG4gICAgICAgIHJldHVybiB7IGhlYWRlciwgZm9vdGVyIH07XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBwYXJzZVRvb2xiYXIoc2VjdGlvblN0ckhhc2gsIGNhbGVuZGFyT3B0aW9ucywgY2FsZW5kYXJPcHRpb25PdmVycmlkZXMsIHRoZW1lLCB2aWV3U3BlY3MsIGNhbGVuZGFyQXBpKSB7XHJcbiAgICAgICAgbGV0IHNlY3Rpb25XaWRnZXRzID0ge307XHJcbiAgICAgICAgbGV0IHZpZXdzV2l0aEJ1dHRvbnMgPSBbXTtcclxuICAgICAgICBsZXQgaGFzVGl0bGUgPSBmYWxzZTtcclxuICAgICAgICBmb3IgKGxldCBzZWN0aW9uTmFtZSBpbiBzZWN0aW9uU3RySGFzaCkge1xyXG4gICAgICAgICAgICBsZXQgc2VjdGlvblN0ciA9IHNlY3Rpb25TdHJIYXNoW3NlY3Rpb25OYW1lXTtcclxuICAgICAgICAgICAgbGV0IHNlY3Rpb25SZXMgPSBwYXJzZVNlY3Rpb24oc2VjdGlvblN0ciwgY2FsZW5kYXJPcHRpb25zLCBjYWxlbmRhck9wdGlvbk92ZXJyaWRlcywgdGhlbWUsIHZpZXdTcGVjcywgY2FsZW5kYXJBcGkpO1xyXG4gICAgICAgICAgICBzZWN0aW9uV2lkZ2V0c1tzZWN0aW9uTmFtZV0gPSBzZWN0aW9uUmVzLndpZGdldHM7XHJcbiAgICAgICAgICAgIHZpZXdzV2l0aEJ1dHRvbnMucHVzaCguLi5zZWN0aW9uUmVzLnZpZXdzV2l0aEJ1dHRvbnMpO1xyXG4gICAgICAgICAgICBoYXNUaXRsZSA9IGhhc1RpdGxlIHx8IHNlY3Rpb25SZXMuaGFzVGl0bGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7IHNlY3Rpb25XaWRnZXRzLCB2aWV3c1dpdGhCdXR0b25zLCBoYXNUaXRsZSB9O1xyXG4gICAgfVxyXG4gICAgLypcclxuICAgIEJBRDogcXVlcnlpbmcgaWNvbnMgYW5kIHRleHQgaGVyZS4gc2hvdWxkIGJlIGRvbmUgYXQgcmVuZGVyIHRpbWVcclxuICAgICovXHJcbiAgICBmdW5jdGlvbiBwYXJzZVNlY3Rpb24oc2VjdGlvblN0ciwgY2FsZW5kYXJPcHRpb25zLCAvLyBkZWZhdWx0cytvdmVycmlkZXMsIHRoZW4gcmVmaW5lZFxyXG4gICAgY2FsZW5kYXJPcHRpb25PdmVycmlkZXMsIC8vIG92ZXJyaWRlcyBvbmx5ISwgdW5yZWZpbmVkIDooXHJcbiAgICB0aGVtZSwgdmlld1NwZWNzLCBjYWxlbmRhckFwaSkge1xyXG4gICAgICAgIGxldCBpc1J0bCA9IGNhbGVuZGFyT3B0aW9ucy5kaXJlY3Rpb24gPT09ICdydGwnO1xyXG4gICAgICAgIGxldCBjYWxlbmRhckN1c3RvbUJ1dHRvbnMgPSBjYWxlbmRhck9wdGlvbnMuY3VzdG9tQnV0dG9ucyB8fCB7fTtcclxuICAgICAgICBsZXQgY2FsZW5kYXJCdXR0b25UZXh0T3ZlcnJpZGVzID0gY2FsZW5kYXJPcHRpb25PdmVycmlkZXMuYnV0dG9uVGV4dCB8fCB7fTtcclxuICAgICAgICBsZXQgY2FsZW5kYXJCdXR0b25UZXh0ID0gY2FsZW5kYXJPcHRpb25zLmJ1dHRvblRleHQgfHwge307XHJcbiAgICAgICAgbGV0IGNhbGVuZGFyQnV0dG9uSGludE92ZXJyaWRlcyA9IGNhbGVuZGFyT3B0aW9uT3ZlcnJpZGVzLmJ1dHRvbkhpbnRzIHx8IHt9O1xyXG4gICAgICAgIGxldCBjYWxlbmRhckJ1dHRvbkhpbnRzID0gY2FsZW5kYXJPcHRpb25zLmJ1dHRvbkhpbnRzIHx8IHt9O1xyXG4gICAgICAgIGxldCBzZWN0aW9uU3Vic3RycyA9IHNlY3Rpb25TdHIgPyBzZWN0aW9uU3RyLnNwbGl0KCcgJykgOiBbXTtcclxuICAgICAgICBsZXQgdmlld3NXaXRoQnV0dG9ucyA9IFtdO1xyXG4gICAgICAgIGxldCBoYXNUaXRsZSA9IGZhbHNlO1xyXG4gICAgICAgIGxldCB3aWRnZXRzID0gc2VjdGlvblN1YnN0cnMubWFwKChidXR0b25Hcm91cFN0cikgPT4gKGJ1dHRvbkdyb3VwU3RyLnNwbGl0KCcsJykubWFwKChidXR0b25OYW1lKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChidXR0b25OYW1lID09PSAndGl0bGUnKSB7XHJcbiAgICAgICAgICAgICAgICBoYXNUaXRsZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4geyBidXR0b25OYW1lIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IGN1c3RvbUJ1dHRvblByb3BzO1xyXG4gICAgICAgICAgICBsZXQgdmlld1NwZWM7XHJcbiAgICAgICAgICAgIGxldCBidXR0b25DbGljaztcclxuICAgICAgICAgICAgbGV0IGJ1dHRvbkljb247IC8vIG9ubHkgb25lIG9mIHRoZXNlIHdpbGwgYmUgc2V0XHJcbiAgICAgICAgICAgIGxldCBidXR0b25UZXh0OyAvLyBcIlxyXG4gICAgICAgICAgICBsZXQgYnV0dG9uSGludDtcclxuICAgICAgICAgICAgLy8gXiBmb3IgdGhlIHRpdGxlPVwiXCIgYXR0cmlidXRlLCBmb3IgYWNjZXNzaWJpbGl0eVxyXG4gICAgICAgICAgICBpZiAoKGN1c3RvbUJ1dHRvblByb3BzID0gY2FsZW5kYXJDdXN0b21CdXR0b25zW2J1dHRvbk5hbWVdKSkge1xyXG4gICAgICAgICAgICAgICAgYnV0dG9uQ2xpY2sgPSAoZXYpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY3VzdG9tQnV0dG9uUHJvcHMuY2xpY2spIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3VzdG9tQnV0dG9uUHJvcHMuY2xpY2suY2FsbChldi50YXJnZXQsIGV2LCBldi50YXJnZXQpOyAvLyBUT0RPOiB1c2UgQ2FsZW5kYXIgdGhpcyBjb250ZXh0P1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAoYnV0dG9uSWNvbiA9IHRoZW1lLmdldEN1c3RvbUJ1dHRvbkljb25DbGFzcyhjdXN0b21CdXR0b25Qcm9wcykpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgKGJ1dHRvbkljb24gPSB0aGVtZS5nZXRJY29uQ2xhc3MoYnV0dG9uTmFtZSwgaXNSdGwpKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgIChidXR0b25UZXh0ID0gY3VzdG9tQnV0dG9uUHJvcHMudGV4dCk7XHJcbiAgICAgICAgICAgICAgICBidXR0b25IaW50ID0gY3VzdG9tQnV0dG9uUHJvcHMuaGludCB8fCBjdXN0b21CdXR0b25Qcm9wcy50ZXh0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCh2aWV3U3BlYyA9IHZpZXdTcGVjc1tidXR0b25OYW1lXSkpIHtcclxuICAgICAgICAgICAgICAgIHZpZXdzV2l0aEJ1dHRvbnMucHVzaChidXR0b25OYW1lKTtcclxuICAgICAgICAgICAgICAgIGJ1dHRvbkNsaWNrID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbGVuZGFyQXBpLmNoYW5nZVZpZXcoYnV0dG9uTmFtZSk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgKGJ1dHRvblRleHQgPSB2aWV3U3BlYy5idXR0b25UZXh0T3ZlcnJpZGUpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgKGJ1dHRvbkljb24gPSB0aGVtZS5nZXRJY29uQ2xhc3MoYnV0dG9uTmFtZSwgaXNSdGwpKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgIChidXR0b25UZXh0ID0gdmlld1NwZWMuYnV0dG9uVGV4dERlZmF1bHQpO1xyXG4gICAgICAgICAgICAgICAgbGV0IHRleHRGYWxsYmFjayA9IHZpZXdTcGVjLmJ1dHRvblRleHRPdmVycmlkZSB8fFxyXG4gICAgICAgICAgICAgICAgICAgIHZpZXdTcGVjLmJ1dHRvblRleHREZWZhdWx0O1xyXG4gICAgICAgICAgICAgICAgYnV0dG9uSGludCA9IGZvcm1hdFdpdGhPcmRpbmFscyh2aWV3U3BlYy5idXR0b25UaXRsZU92ZXJyaWRlIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgdmlld1NwZWMuYnV0dG9uVGl0bGVEZWZhdWx0IHx8XHJcbiAgICAgICAgICAgICAgICAgICAgY2FsZW5kYXJPcHRpb25zLnZpZXdIaW50LCBbdGV4dEZhbGxiYWNrLCBidXR0b25OYW1lXSwgLy8gdmlldy1uYW1lID0gYnV0dG9uTmFtZVxyXG4gICAgICAgICAgICAgICAgdGV4dEZhbGxiYWNrKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjYWxlbmRhckFwaVtidXR0b25OYW1lXSkgeyAvLyBhIGNhbGVuZGFyQXBpIG1ldGhvZFxyXG4gICAgICAgICAgICAgICAgYnV0dG9uQ2xpY2sgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FsZW5kYXJBcGlbYnV0dG9uTmFtZV0oKTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAoYnV0dG9uVGV4dCA9IGNhbGVuZGFyQnV0dG9uVGV4dE92ZXJyaWRlc1tidXR0b25OYW1lXSkgfHxcclxuICAgICAgICAgICAgICAgICAgICAoYnV0dG9uSWNvbiA9IHRoZW1lLmdldEljb25DbGFzcyhidXR0b25OYW1lLCBpc1J0bCkpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgKGJ1dHRvblRleHQgPSBjYWxlbmRhckJ1dHRvblRleHRbYnV0dG9uTmFtZV0pOyAvLyBldmVyeXRoaW5nIGVsc2UgaXMgY29uc2lkZXJlZCBkZWZhdWx0XHJcbiAgICAgICAgICAgICAgICBpZiAoYnV0dG9uTmFtZSA9PT0gJ3ByZXZZZWFyJyB8fCBidXR0b25OYW1lID09PSAnbmV4dFllYXInKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHByZXZPck5leHQgPSBidXR0b25OYW1lID09PSAncHJldlllYXInID8gJ3ByZXYnIDogJ25leHQnO1xyXG4gICAgICAgICAgICAgICAgICAgIGJ1dHRvbkhpbnQgPSBmb3JtYXRXaXRoT3JkaW5hbHMoY2FsZW5kYXJCdXR0b25IaW50T3ZlcnJpZGVzW3ByZXZPck5leHRdIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGVuZGFyQnV0dG9uSGludHNbcHJldk9yTmV4dF0sIFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsZW5kYXJCdXR0b25UZXh0LnllYXIgfHwgJ3llYXInLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAneWVhcicsXHJcbiAgICAgICAgICAgICAgICAgICAgXSwgY2FsZW5kYXJCdXR0b25UZXh0W2J1dHRvbk5hbWVdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGJ1dHRvbkhpbnQgPSAobmF2VW5pdCkgPT4gZm9ybWF0V2l0aE9yZGluYWxzKGNhbGVuZGFyQnV0dG9uSGludE92ZXJyaWRlc1tidXR0b25OYW1lXSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxlbmRhckJ1dHRvbkhpbnRzW2J1dHRvbk5hbWVdLCBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGVuZGFyQnV0dG9uVGV4dFtuYXZVbml0XSB8fCBuYXZVbml0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBuYXZVbml0LFxyXG4gICAgICAgICAgICAgICAgICAgIF0sIGNhbGVuZGFyQnV0dG9uVGV4dFtidXR0b25OYW1lXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHsgYnV0dG9uTmFtZSwgYnV0dG9uQ2xpY2ssIGJ1dHRvbkljb24sIGJ1dHRvblRleHQsIGJ1dHRvbkhpbnQgfTtcclxuICAgICAgICB9KSkpO1xyXG4gICAgICAgIHJldHVybiB7IHdpZGdldHMsIHZpZXdzV2l0aEJ1dHRvbnMsIGhhc1RpdGxlIH07XHJcbiAgICB9XHJcblxyXG4gICAgLy8gYWx3YXlzIHJlcHJlc2VudHMgdGhlIGN1cnJlbnQgdmlldy4gb3RoZXJ3aXNlLCBpdCdkIG5lZWQgdG8gY2hhbmdlIHZhbHVlIGV2ZXJ5IHRpbWUgZGF0ZSBjaGFuZ2VzXHJcbiAgICBjbGFzcyBWaWV3SW1wbCB7XHJcbiAgICAgICAgY29uc3RydWN0b3IodHlwZSwgZ2V0Q3VycmVudERhdGEsIGRhdGVFbnYpIHtcclxuICAgICAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcclxuICAgICAgICAgICAgdGhpcy5nZXRDdXJyZW50RGF0YSA9IGdldEN1cnJlbnREYXRhO1xyXG4gICAgICAgICAgICB0aGlzLmRhdGVFbnYgPSBkYXRlRW52O1xyXG4gICAgICAgIH1cclxuICAgICAgICBnZXQgY2FsZW5kYXIoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEN1cnJlbnREYXRhKCkuY2FsZW5kYXJBcGk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGdldCB0aXRsZSgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudERhdGEoKS52aWV3VGl0bGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGdldCBhY3RpdmVTdGFydCgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0ZUVudi50b0RhdGUodGhpcy5nZXRDdXJyZW50RGF0YSgpLmRhdGVQcm9maWxlLmFjdGl2ZVJhbmdlLnN0YXJ0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZ2V0IGFjdGl2ZUVuZCgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0ZUVudi50b0RhdGUodGhpcy5nZXRDdXJyZW50RGF0YSgpLmRhdGVQcm9maWxlLmFjdGl2ZVJhbmdlLmVuZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGdldCBjdXJyZW50U3RhcnQoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGVFbnYudG9EYXRlKHRoaXMuZ2V0Q3VycmVudERhdGEoKS5kYXRlUHJvZmlsZS5jdXJyZW50UmFuZ2Uuc3RhcnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBnZXQgY3VycmVudEVuZCgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0ZUVudi50b0RhdGUodGhpcy5nZXRDdXJyZW50RGF0YSgpLmRhdGVQcm9maWxlLmN1cnJlbnRSYW5nZS5lbmQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBnZXRPcHRpb24obmFtZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRDdXJyZW50RGF0YSgpLm9wdGlvbnNbbmFtZV07IC8vIGFyZSB0aGUgdmlldy1zcGVjaWZpYyBvcHRpb25zXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGxldCBldmVudFNvdXJjZURlZiQyID0ge1xyXG4gICAgICAgIGlnbm9yZVJhbmdlOiB0cnVlLFxyXG4gICAgICAgIHBhcnNlTWV0YShyZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHJlZmluZWQuZXZlbnRzKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlZmluZWQuZXZlbnRzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZmV0Y2goYXJnLCBzdWNjZXNzQ2FsbGJhY2spIHtcclxuICAgICAgICAgICAgc3VjY2Vzc0NhbGxiYWNrKHtcclxuICAgICAgICAgICAgICAgIHJhd0V2ZW50czogYXJnLmV2ZW50U291cmNlLm1ldGEsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sXHJcbiAgICB9O1xyXG4gICAgY29uc3QgYXJyYXlFdmVudFNvdXJjZVBsdWdpbiA9IGNyZWF0ZVBsdWdpbih7XHJcbiAgICAgICAgbmFtZTogJ2FycmF5LWV2ZW50LXNvdXJjZScsXHJcbiAgICAgICAgZXZlbnRTb3VyY2VEZWZzOiBbZXZlbnRTb3VyY2VEZWYkMl0sXHJcbiAgICB9KTtcclxuXHJcbiAgICBsZXQgZXZlbnRTb3VyY2VEZWYkMSA9IHtcclxuICAgICAgICBwYXJzZU1ldGEocmVmaW5lZCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHJlZmluZWQuZXZlbnRzID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVmaW5lZC5ldmVudHM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBmZXRjaChhcmcsIHN1Y2Nlc3NDYWxsYmFjaywgZXJyb3JDYWxsYmFjaykge1xyXG4gICAgICAgICAgICBjb25zdCB7IGRhdGVFbnYgfSA9IGFyZy5jb250ZXh0O1xyXG4gICAgICAgICAgICBjb25zdCBmdW5jID0gYXJnLmV2ZW50U291cmNlLm1ldGE7XHJcbiAgICAgICAgICAgIHVucHJvbWlzaWZ5KGZ1bmMuYmluZChudWxsLCBidWlsZFJhbmdlQXBpV2l0aFRpbWVab25lKGFyZy5yYW5nZSwgZGF0ZUVudikpLCAocmF3RXZlbnRzKSA9PiBzdWNjZXNzQ2FsbGJhY2soeyByYXdFdmVudHMgfSksIGVycm9yQ2FsbGJhY2spO1xyXG4gICAgICAgIH0sXHJcbiAgICB9O1xyXG4gICAgY29uc3QgZnVuY0V2ZW50U291cmNlUGx1Z2luID0gY3JlYXRlUGx1Z2luKHtcclxuICAgICAgICBuYW1lOiAnZnVuYy1ldmVudC1zb3VyY2UnLFxyXG4gICAgICAgIGV2ZW50U291cmNlRGVmczogW2V2ZW50U291cmNlRGVmJDFdLFxyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3QgSlNPTl9GRUVEX0VWRU5UX1NPVVJDRV9SRUZJTkVSUyA9IHtcclxuICAgICAgICBtZXRob2Q6IFN0cmluZyxcclxuICAgICAgICBleHRyYVBhcmFtczogaWRlbnRpdHksXHJcbiAgICAgICAgc3RhcnRQYXJhbTogU3RyaW5nLFxyXG4gICAgICAgIGVuZFBhcmFtOiBTdHJpbmcsXHJcbiAgICAgICAgdGltZVpvbmVQYXJhbTogU3RyaW5nLFxyXG4gICAgfTtcclxuXHJcbiAgICBsZXQgZXZlbnRTb3VyY2VEZWYgPSB7XHJcbiAgICAgICAgcGFyc2VNZXRhKHJlZmluZWQpIHtcclxuICAgICAgICAgICAgaWYgKHJlZmluZWQudXJsICYmIChyZWZpbmVkLmZvcm1hdCA9PT0gJ2pzb24nIHx8ICFyZWZpbmVkLmZvcm1hdCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdXJsOiByZWZpbmVkLnVybCxcclxuICAgICAgICAgICAgICAgICAgICBmb3JtYXQ6ICdqc29uJyxcclxuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IChyZWZpbmVkLm1ldGhvZCB8fCAnR0VUJykudG9VcHBlckNhc2UoKSxcclxuICAgICAgICAgICAgICAgICAgICBleHRyYVBhcmFtczogcmVmaW5lZC5leHRyYVBhcmFtcyxcclxuICAgICAgICAgICAgICAgICAgICBzdGFydFBhcmFtOiByZWZpbmVkLnN0YXJ0UGFyYW0sXHJcbiAgICAgICAgICAgICAgICAgICAgZW5kUGFyYW06IHJlZmluZWQuZW5kUGFyYW0sXHJcbiAgICAgICAgICAgICAgICAgICAgdGltZVpvbmVQYXJhbTogcmVmaW5lZC50aW1lWm9uZVBhcmFtLFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGZldGNoKGFyZywgc3VjY2Vzc0NhbGxiYWNrLCBlcnJvckNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgbWV0YSB9ID0gYXJnLmV2ZW50U291cmNlO1xyXG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0UGFyYW1zID0gYnVpbGRSZXF1ZXN0UGFyYW1zKG1ldGEsIGFyZy5yYW5nZSwgYXJnLmNvbnRleHQpO1xyXG4gICAgICAgICAgICByZXF1ZXN0SnNvbihtZXRhLm1ldGhvZCwgbWV0YS51cmwsIHJlcXVlc3RQYXJhbXMpLnRoZW4oKFtyYXdFdmVudHMsIHJlc3BvbnNlXSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgc3VjY2Vzc0NhbGxiYWNrKHsgcmF3RXZlbnRzLCByZXNwb25zZSB9KTtcclxuICAgICAgICAgICAgfSwgZXJyb3JDYWxsYmFjayk7XHJcbiAgICAgICAgfSxcclxuICAgIH07XHJcbiAgICBjb25zdCBqc29uRmVlZEV2ZW50U291cmNlUGx1Z2luID0gY3JlYXRlUGx1Z2luKHtcclxuICAgICAgICBuYW1lOiAnanNvbi1ldmVudC1zb3VyY2UnLFxyXG4gICAgICAgIGV2ZW50U291cmNlUmVmaW5lcnM6IEpTT05fRkVFRF9FVkVOVF9TT1VSQ0VfUkVGSU5FUlMsXHJcbiAgICAgICAgZXZlbnRTb3VyY2VEZWZzOiBbZXZlbnRTb3VyY2VEZWZdLFxyXG4gICAgfSk7XHJcbiAgICBmdW5jdGlvbiBidWlsZFJlcXVlc3RQYXJhbXMobWV0YSwgcmFuZ2UsIGNvbnRleHQpIHtcclxuICAgICAgICBsZXQgeyBkYXRlRW52LCBvcHRpb25zIH0gPSBjb250ZXh0O1xyXG4gICAgICAgIGxldCBzdGFydFBhcmFtO1xyXG4gICAgICAgIGxldCBlbmRQYXJhbTtcclxuICAgICAgICBsZXQgdGltZVpvbmVQYXJhbTtcclxuICAgICAgICBsZXQgY3VzdG9tUmVxdWVzdFBhcmFtcztcclxuICAgICAgICBsZXQgcGFyYW1zID0ge307XHJcbiAgICAgICAgc3RhcnRQYXJhbSA9IG1ldGEuc3RhcnRQYXJhbTtcclxuICAgICAgICBpZiAoc3RhcnRQYXJhbSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHN0YXJ0UGFyYW0gPSBvcHRpb25zLnN0YXJ0UGFyYW07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVuZFBhcmFtID0gbWV0YS5lbmRQYXJhbTtcclxuICAgICAgICBpZiAoZW5kUGFyYW0gPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBlbmRQYXJhbSA9IG9wdGlvbnMuZW5kUGFyYW07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRpbWVab25lUGFyYW0gPSBtZXRhLnRpbWVab25lUGFyYW07XHJcbiAgICAgICAgaWYgKHRpbWVab25lUGFyYW0gPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aW1lWm9uZVBhcmFtID0gb3B0aW9ucy50aW1lWm9uZVBhcmFtO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyByZXRyaWV2ZSBhbnkgb3V0Ym91bmQgR0VUL1BPU1QgZGF0YSBmcm9tIHRoZSBvcHRpb25zXHJcbiAgICAgICAgaWYgKHR5cGVvZiBtZXRhLmV4dHJhUGFyYW1zID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIC8vIHN1cHBsaWVkIGFzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEga2V5L3ZhbHVlIG9iamVjdFxyXG4gICAgICAgICAgICBjdXN0b21SZXF1ZXN0UGFyYW1zID0gbWV0YS5leHRyYVBhcmFtcygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gcHJvYmFibHkgc3VwcGxpZWQgYXMgYSBzdHJhaWdodCBrZXkvdmFsdWUgb2JqZWN0XHJcbiAgICAgICAgICAgIGN1c3RvbVJlcXVlc3RQYXJhbXMgPSBtZXRhLmV4dHJhUGFyYW1zIHx8IHt9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBPYmplY3QuYXNzaWduKHBhcmFtcywgY3VzdG9tUmVxdWVzdFBhcmFtcyk7XHJcbiAgICAgICAgcGFyYW1zW3N0YXJ0UGFyYW1dID0gZGF0ZUVudi5mb3JtYXRJc28ocmFuZ2Uuc3RhcnQpO1xyXG4gICAgICAgIHBhcmFtc1tlbmRQYXJhbV0gPSBkYXRlRW52LmZvcm1hdElzbyhyYW5nZS5lbmQpO1xyXG4gICAgICAgIGlmIChkYXRlRW52LnRpbWVab25lICE9PSAnbG9jYWwnKSB7XHJcbiAgICAgICAgICAgIHBhcmFtc1t0aW1lWm9uZVBhcmFtXSA9IGRhdGVFbnYudGltZVpvbmU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwYXJhbXM7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgU0lNUExFX1JFQ1VSUklOR19SRUZJTkVSUyA9IHtcclxuICAgICAgICBkYXlzT2ZXZWVrOiBpZGVudGl0eSxcclxuICAgICAgICBzdGFydFRpbWU6IGNyZWF0ZUR1cmF0aW9uLFxyXG4gICAgICAgIGVuZFRpbWU6IGNyZWF0ZUR1cmF0aW9uLFxyXG4gICAgICAgIGR1cmF0aW9uOiBjcmVhdGVEdXJhdGlvbixcclxuICAgICAgICBzdGFydFJlY3VyOiBpZGVudGl0eSxcclxuICAgICAgICBlbmRSZWN1cjogaWRlbnRpdHksXHJcbiAgICB9O1xyXG5cclxuICAgIGxldCByZWN1cnJpbmcgPSB7XHJcbiAgICAgICAgcGFyc2UocmVmaW5lZCwgZGF0ZUVudikge1xyXG4gICAgICAgICAgICBpZiAocmVmaW5lZC5kYXlzT2ZXZWVrIHx8IHJlZmluZWQuc3RhcnRUaW1lIHx8IHJlZmluZWQuZW5kVGltZSB8fCByZWZpbmVkLnN0YXJ0UmVjdXIgfHwgcmVmaW5lZC5lbmRSZWN1cikge1xyXG4gICAgICAgICAgICAgICAgbGV0IHJlY3VycmluZ0RhdGEgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGF5c09mV2VlazogcmVmaW5lZC5kYXlzT2ZXZWVrIHx8IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRUaW1lOiByZWZpbmVkLnN0YXJ0VGltZSB8fCBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgIGVuZFRpbWU6IHJlZmluZWQuZW5kVGltZSB8fCBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0UmVjdXI6IHJlZmluZWQuc3RhcnRSZWN1ciA/IGRhdGVFbnYuY3JlYXRlTWFya2VyKHJlZmluZWQuc3RhcnRSZWN1cikgOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgIGVuZFJlY3VyOiByZWZpbmVkLmVuZFJlY3VyID8gZGF0ZUVudi5jcmVhdGVNYXJrZXIocmVmaW5lZC5lbmRSZWN1cikgOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIGxldCBkdXJhdGlvbjtcclxuICAgICAgICAgICAgICAgIGlmIChyZWZpbmVkLmR1cmF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZHVyYXRpb24gPSByZWZpbmVkLmR1cmF0aW9uO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCFkdXJhdGlvbiAmJiByZWZpbmVkLnN0YXJ0VGltZSAmJiByZWZpbmVkLmVuZFRpbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbiA9IHN1YnRyYWN0RHVyYXRpb25zKHJlZmluZWQuZW5kVGltZSwgcmVmaW5lZC5zdGFydFRpbWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICBhbGxEYXlHdWVzczogQm9vbGVhbighcmVmaW5lZC5zdGFydFRpbWUgJiYgIXJlZmluZWQuZW5kVGltZSksXHJcbiAgICAgICAgICAgICAgICAgICAgZHVyYXRpb24sXHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZURhdGE6IHJlY3VycmluZ0RhdGEsIC8vIGRvZXNuJ3QgbmVlZCBlbmRUaW1lIGFueW1vcmUgYnV0IG9oIHdlbGxcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBleHBhbmQodHlwZURhdGEsIGZyYW1pbmdSYW5nZSwgZGF0ZUVudikge1xyXG4gICAgICAgICAgICBsZXQgY2xpcHBlZEZyYW1pbmdSYW5nZSA9IGludGVyc2VjdFJhbmdlcyhmcmFtaW5nUmFuZ2UsIHsgc3RhcnQ6IHR5cGVEYXRhLnN0YXJ0UmVjdXIsIGVuZDogdHlwZURhdGEuZW5kUmVjdXIgfSk7XHJcbiAgICAgICAgICAgIGlmIChjbGlwcGVkRnJhbWluZ1JhbmdlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZXhwYW5kUmFuZ2VzKHR5cGVEYXRhLmRheXNPZldlZWssIHR5cGVEYXRhLnN0YXJ0VGltZSwgY2xpcHBlZEZyYW1pbmdSYW5nZSwgZGF0ZUVudik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgIH0sXHJcbiAgICB9O1xyXG4gICAgY29uc3Qgc2ltcGxlUmVjdXJyaW5nRXZlbnRzUGx1Z2luID0gY3JlYXRlUGx1Z2luKHtcclxuICAgICAgICBuYW1lOiAnc2ltcGxlLXJlY3VycmluZy1ldmVudCcsXHJcbiAgICAgICAgcmVjdXJyaW5nVHlwZXM6IFtyZWN1cnJpbmddLFxyXG4gICAgICAgIGV2ZW50UmVmaW5lcnM6IFNJTVBMRV9SRUNVUlJJTkdfUkVGSU5FUlMsXHJcbiAgICB9KTtcclxuICAgIGZ1bmN0aW9uIGV4cGFuZFJhbmdlcyhkYXlzT2ZXZWVrLCBzdGFydFRpbWUsIGZyYW1pbmdSYW5nZSwgZGF0ZUVudikge1xyXG4gICAgICAgIGxldCBkb3dIYXNoID0gZGF5c09mV2VlayA/IGFycmF5VG9IYXNoKGRheXNPZldlZWspIDogbnVsbDtcclxuICAgICAgICBsZXQgZGF5TWFya2VyID0gc3RhcnRPZkRheShmcmFtaW5nUmFuZ2Uuc3RhcnQpO1xyXG4gICAgICAgIGxldCBlbmRNYXJrZXIgPSBmcmFtaW5nUmFuZ2UuZW5kO1xyXG4gICAgICAgIGxldCBpbnN0YW5jZVN0YXJ0cyA9IFtdO1xyXG4gICAgICAgIHdoaWxlIChkYXlNYXJrZXIgPCBlbmRNYXJrZXIpIHtcclxuICAgICAgICAgICAgbGV0IGluc3RhbmNlU3RhcnQ7XHJcbiAgICAgICAgICAgIC8vIGlmIGV2ZXJ5ZGF5LCBvciB0aGlzIHBhcnRpY3VsYXIgZGF5LW9mLXdlZWtcclxuICAgICAgICAgICAgaWYgKCFkb3dIYXNoIHx8IGRvd0hhc2hbZGF5TWFya2VyLmdldFVUQ0RheSgpXSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHN0YXJ0VGltZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlU3RhcnQgPSBkYXRlRW52LmFkZChkYXlNYXJrZXIsIHN0YXJ0VGltZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZVN0YXJ0ID0gZGF5TWFya2VyO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaW5zdGFuY2VTdGFydHMucHVzaChpbnN0YW5jZVN0YXJ0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBkYXlNYXJrZXIgPSBhZGREYXlzKGRheU1hcmtlciwgMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBpbnN0YW5jZVN0YXJ0cztcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBjaGFuZ2VIYW5kbGVyUGx1Z2luID0gY3JlYXRlUGx1Z2luKHtcclxuICAgICAgICBuYW1lOiAnY2hhbmdlLWhhbmRsZXInLFxyXG4gICAgICAgIG9wdGlvbkNoYW5nZUhhbmRsZXJzOiB7XHJcbiAgICAgICAgICAgIGV2ZW50cyhldmVudHMsIGNvbnRleHQpIHtcclxuICAgICAgICAgICAgICAgIGhhbmRsZUV2ZW50U291cmNlcyhbZXZlbnRzXSwgY29udGV4dCk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGV2ZW50U291cmNlczogaGFuZGxlRXZlbnRTb3VyY2VzLFxyXG4gICAgICAgIH0sXHJcbiAgICB9KTtcclxuICAgIC8qXHJcbiAgICBCVUc6IGlmIGBldmVudGAgd2FzIHN1cHBsaWVkLCBhbGwgcHJldmlvdXNseS1naXZlbiBgZXZlbnRTb3VyY2VzYCB3aWxsIGJlIHdpcGVkIG91dFxyXG4gICAgKi9cclxuICAgIGZ1bmN0aW9uIGhhbmRsZUV2ZW50U291cmNlcyhpbnB1dHMsIGNvbnRleHQpIHtcclxuICAgICAgICBsZXQgdW5mb3VuZFNvdXJjZXMgPSBoYXNoVmFsdWVzVG9BcnJheShjb250ZXh0LmdldEN1cnJlbnREYXRhKCkuZXZlbnRTb3VyY2VzKTtcclxuICAgICAgICBpZiAodW5mb3VuZFNvdXJjZXMubGVuZ3RoID09PSAxICYmXHJcbiAgICAgICAgICAgIGlucHV0cy5sZW5ndGggPT09IDEgJiZcclxuICAgICAgICAgICAgQXJyYXkuaXNBcnJheSh1bmZvdW5kU291cmNlc1swXS5fcmF3KSAmJlxyXG4gICAgICAgICAgICBBcnJheS5pc0FycmF5KGlucHV0c1swXSkpIHtcclxuICAgICAgICAgICAgY29udGV4dC5kaXNwYXRjaCh7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiAnUkVTRVRfUkFXX0VWRU5UUycsXHJcbiAgICAgICAgICAgICAgICBzb3VyY2VJZDogdW5mb3VuZFNvdXJjZXNbMF0uc291cmNlSWQsXHJcbiAgICAgICAgICAgICAgICByYXdFdmVudHM6IGlucHV0c1swXSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IG5ld0lucHV0cyA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IGlucHV0IG9mIGlucHV0cykge1xyXG4gICAgICAgICAgICBsZXQgaW5wdXRGb3VuZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHVuZm91bmRTb3VyY2VzLmxlbmd0aDsgaSArPSAxKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodW5mb3VuZFNvdXJjZXNbaV0uX3JhdyA9PT0gaW5wdXQpIHtcclxuICAgICAgICAgICAgICAgICAgICB1bmZvdW5kU291cmNlcy5zcGxpY2UoaSwgMSk7IC8vIGRlbGV0ZVxyXG4gICAgICAgICAgICAgICAgICAgIGlucHV0Rm91bmQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghaW5wdXRGb3VuZCkge1xyXG4gICAgICAgICAgICAgICAgbmV3SW5wdXRzLnB1c2goaW5wdXQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAobGV0IHVuZm91bmRTb3VyY2Ugb2YgdW5mb3VuZFNvdXJjZXMpIHtcclxuICAgICAgICAgICAgY29udGV4dC5kaXNwYXRjaCh7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiAnUkVNT1ZFX0VWRU5UX1NPVVJDRScsXHJcbiAgICAgICAgICAgICAgICBzb3VyY2VJZDogdW5mb3VuZFNvdXJjZS5zb3VyY2VJZCxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAobGV0IG5ld0lucHV0IG9mIG5ld0lucHV0cykge1xyXG4gICAgICAgICAgICBjb250ZXh0LmNhbGVuZGFyQXBpLmFkZEV2ZW50U291cmNlKG5ld0lucHV0KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaGFuZGxlRGF0ZVByb2ZpbGUoZGF0ZVByb2ZpbGUsIGNvbnRleHQpIHtcclxuICAgICAgICBjb250ZXh0LmVtaXR0ZXIudHJpZ2dlcignZGF0ZXNTZXQnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGJ1aWxkUmFuZ2VBcGlXaXRoVGltZVpvbmUoZGF0ZVByb2ZpbGUuYWN0aXZlUmFuZ2UsIGNvbnRleHQuZGF0ZUVudikpLCB7IHZpZXc6IGNvbnRleHQudmlld0FwaSB9KSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaGFuZGxlRXZlbnRTdG9yZShldmVudFN0b3JlLCBjb250ZXh0KSB7XHJcbiAgICAgICAgbGV0IHsgZW1pdHRlciB9ID0gY29udGV4dDtcclxuICAgICAgICBpZiAoZW1pdHRlci5oYXNIYW5kbGVycygnZXZlbnRzU2V0JykpIHtcclxuICAgICAgICAgICAgZW1pdHRlci50cmlnZ2VyKCdldmVudHNTZXQnLCBidWlsZEV2ZW50QXBpcyhldmVudFN0b3JlLCBjb250ZXh0KSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qXHJcbiAgICB0aGlzIGFycmF5IGlzIGV4cG9zZWQgb24gdGhlIHJvb3QgbmFtZXNwYWNlIHNvIHRoYXQgVU1EIHBsdWdpbnMgY2FuIGFkZCB0byBpdC5cclxuICAgIHNlZSB0aGUgcm9sbHVwLWJ1bmRsZXMgc2NyaXB0LlxyXG4gICAgKi9cclxuICAgIGNvbnN0IGdsb2JhbFBsdWdpbnMgPSBbXHJcbiAgICAgICAgYXJyYXlFdmVudFNvdXJjZVBsdWdpbixcclxuICAgICAgICBmdW5jRXZlbnRTb3VyY2VQbHVnaW4sXHJcbiAgICAgICAganNvbkZlZWRFdmVudFNvdXJjZVBsdWdpbixcclxuICAgICAgICBzaW1wbGVSZWN1cnJpbmdFdmVudHNQbHVnaW4sXHJcbiAgICAgICAgY2hhbmdlSGFuZGxlclBsdWdpbixcclxuICAgICAgICBjcmVhdGVQbHVnaW4oe1xyXG4gICAgICAgICAgICBuYW1lOiAnbWlzYycsXHJcbiAgICAgICAgICAgIGlzTG9hZGluZ0Z1bmNzOiBbXHJcbiAgICAgICAgICAgICAgICAoc3RhdGUpID0+IGNvbXB1dGVFdmVudFNvdXJjZXNMb2FkaW5nKHN0YXRlLmV2ZW50U291cmNlcyksXHJcbiAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgIHByb3BTZXRIYW5kbGVyczoge1xyXG4gICAgICAgICAgICAgICAgZGF0ZVByb2ZpbGU6IGhhbmRsZURhdGVQcm9maWxlLFxyXG4gICAgICAgICAgICAgICAgZXZlbnRTdG9yZTogaGFuZGxlRXZlbnRTdG9yZSxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9KSxcclxuICAgIF07XHJcblxyXG4gICAgY2xhc3MgVGFza1J1bm5lciB7XHJcbiAgICAgICAgY29uc3RydWN0b3IocnVuVGFza09wdGlvbiwgZHJhaW5lZE9wdGlvbikge1xyXG4gICAgICAgICAgICB0aGlzLnJ1blRhc2tPcHRpb24gPSBydW5UYXNrT3B0aW9uO1xyXG4gICAgICAgICAgICB0aGlzLmRyYWluZWRPcHRpb24gPSBkcmFpbmVkT3B0aW9uO1xyXG4gICAgICAgICAgICB0aGlzLnF1ZXVlID0gW107XHJcbiAgICAgICAgICAgIHRoaXMuZGVsYXllZFJ1bm5lciA9IG5ldyBEZWxheWVkUnVubmVyKHRoaXMuZHJhaW4uYmluZCh0aGlzKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlcXVlc3QodGFzaywgZGVsYXkpIHtcclxuICAgICAgICAgICAgdGhpcy5xdWV1ZS5wdXNoKHRhc2spO1xyXG4gICAgICAgICAgICB0aGlzLmRlbGF5ZWRSdW5uZXIucmVxdWVzdChkZWxheSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHBhdXNlKHNjb3BlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGVsYXllZFJ1bm5lci5wYXVzZShzY29wZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlc3VtZShzY29wZSwgZm9yY2UpIHtcclxuICAgICAgICAgICAgdGhpcy5kZWxheWVkUnVubmVyLnJlc3VtZShzY29wZSwgZm9yY2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkcmFpbigpIHtcclxuICAgICAgICAgICAgbGV0IHsgcXVldWUgfSA9IHRoaXM7XHJcbiAgICAgICAgICAgIHdoaWxlIChxdWV1ZS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIGxldCBjb21wbGV0ZWRUYXNrcyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgbGV0IHRhc2s7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoKHRhc2sgPSBxdWV1ZS5zaGlmdCgpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucnVuVGFzayh0YXNrKTtcclxuICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZWRUYXNrcy5wdXNoKHRhc2spO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5kcmFpbmVkKGNvbXBsZXRlZFRhc2tzKTtcclxuICAgICAgICAgICAgfSAvLyBrZWVwIGdvaW5nLCBpbiBjYXNlIG5ldyB0YXNrcyB3ZXJlIGFkZGVkIGluIHRoZSBkcmFpbmVkIGhhbmRsZXJcclxuICAgICAgICB9XHJcbiAgICAgICAgcnVuVGFzayh0YXNrKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnJ1blRhc2tPcHRpb24pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucnVuVGFza09wdGlvbih0YXNrKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBkcmFpbmVkKGNvbXBsZXRlZFRhc2tzKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmRyYWluZWRPcHRpb24pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZHJhaW5lZE9wdGlvbihjb21wbGV0ZWRUYXNrcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ29tcHV0ZXMgd2hhdCB0aGUgdGl0bGUgYXQgdGhlIHRvcCBvZiB0aGUgY2FsZW5kYXJBcGkgc2hvdWxkIGJlIGZvciB0aGlzIHZpZXdcclxuICAgIGZ1bmN0aW9uIGJ1aWxkVGl0bGUoZGF0ZVByb2ZpbGUsIHZpZXdPcHRpb25zLCBkYXRlRW52KSB7XHJcbiAgICAgICAgbGV0IHJhbmdlO1xyXG4gICAgICAgIC8vIGZvciB2aWV3cyB0aGF0IHNwYW4gYSBsYXJnZSB1bml0IG9mIHRpbWUsIHNob3cgdGhlIHByb3BlciBpbnRlcnZhbCwgaWdub3Jpbmcgc3RyYXkgZGF5cyBiZWZvcmUgYW5kIGFmdGVyXHJcbiAgICAgICAgaWYgKC9eKHllYXJ8bW9udGgpJC8udGVzdChkYXRlUHJvZmlsZS5jdXJyZW50UmFuZ2VVbml0KSkge1xyXG4gICAgICAgICAgICByYW5nZSA9IGRhdGVQcm9maWxlLmN1cnJlbnRSYW5nZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7IC8vIGZvciBkYXkgdW5pdHMgb3Igc21hbGxlciwgdXNlIHRoZSBhY3R1YWwgZGF5IHJhbmdlXHJcbiAgICAgICAgICAgIHJhbmdlID0gZGF0ZVByb2ZpbGUuYWN0aXZlUmFuZ2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkYXRlRW52LmZvcm1hdFJhbmdlKHJhbmdlLnN0YXJ0LCByYW5nZS5lbmQsIGNyZWF0ZUZvcm1hdHRlcih2aWV3T3B0aW9ucy50aXRsZUZvcm1hdCB8fCBidWlsZFRpdGxlRm9ybWF0KGRhdGVQcm9maWxlKSksIHtcclxuICAgICAgICAgICAgaXNFbmRFeGNsdXNpdmU6IGRhdGVQcm9maWxlLmlzUmFuZ2VBbGxEYXksXHJcbiAgICAgICAgICAgIGRlZmF1bHRTZXBhcmF0b3I6IHZpZXdPcHRpb25zLnRpdGxlUmFuZ2VTZXBhcmF0b3IsXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvLyBHZW5lcmF0ZXMgdGhlIGZvcm1hdCBzdHJpbmcgdGhhdCBzaG91bGQgYmUgdXNlZCB0byBnZW5lcmF0ZSB0aGUgdGl0bGUgZm9yIHRoZSBjdXJyZW50IGRhdGUgcmFuZ2UuXHJcbiAgICAvLyBBdHRlbXB0cyB0byBjb21wdXRlIHRoZSBtb3N0IGFwcHJvcHJpYXRlIGZvcm1hdCBpZiBub3QgZXhwbGljaXRseSBzcGVjaWZpZWQgd2l0aCBgdGl0bGVGb3JtYXRgLlxyXG4gICAgZnVuY3Rpb24gYnVpbGRUaXRsZUZvcm1hdChkYXRlUHJvZmlsZSkge1xyXG4gICAgICAgIGxldCB7IGN1cnJlbnRSYW5nZVVuaXQgfSA9IGRhdGVQcm9maWxlO1xyXG4gICAgICAgIGlmIChjdXJyZW50UmFuZ2VVbml0ID09PSAneWVhcicpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHsgeWVhcjogJ251bWVyaWMnIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjdXJyZW50UmFuZ2VVbml0ID09PSAnbW9udGgnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7IHllYXI6ICdudW1lcmljJywgbW9udGg6ICdsb25nJyB9OyAvLyBsaWtlIFwiU2VwdGVtYmVyIDIwMTRcIlxyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgZGF5cyA9IGRpZmZXaG9sZURheXMoZGF0ZVByb2ZpbGUuY3VycmVudFJhbmdlLnN0YXJ0LCBkYXRlUHJvZmlsZS5jdXJyZW50UmFuZ2UuZW5kKTtcclxuICAgICAgICBpZiAoZGF5cyAhPT0gbnVsbCAmJiBkYXlzID4gMSkge1xyXG4gICAgICAgICAgICAvLyBtdWx0aS1kYXkgcmFuZ2UuIHNob3J0ZXIsIGxpa2UgXCJTZXAgOSAtIDEwIDIwMTRcIlxyXG4gICAgICAgICAgICByZXR1cm4geyB5ZWFyOiAnbnVtZXJpYycsIG1vbnRoOiAnc2hvcnQnLCBkYXk6ICdudW1lcmljJyB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBvbmUgZGF5LiBsb25nZXIsIGxpa2UgXCJTZXB0ZW1iZXIgOSAyMDE0XCJcclxuICAgICAgICByZXR1cm4geyB5ZWFyOiAnbnVtZXJpYycsIG1vbnRoOiAnbG9uZycsIGRheTogJ251bWVyaWMnIH07XHJcbiAgICB9XHJcblxyXG4gICAgLy8gaW4gZnV0dXJlIHJlZmFjdG9yLCBkbyB0aGUgcmVkdXgtc3R5bGUgZnVuY3Rpb24oc3RhdGU9aW5pdGlhbCkgZm9yIGluaXRpYWwtc3RhdGVcclxuICAgIC8vIGFsc28sIHdoYXRldmVyIGlzIGhhcHBlbmluZyBpbiBjb25zdHJ1Y3RvciwgaGF2ZSBpdCBoYXBwZW4gaW4gYWN0aW9uIHF1ZXVlIHRvb1xyXG4gICAgY2xhc3MgQ2FsZW5kYXJEYXRhTWFuYWdlciB7XHJcbiAgICAgICAgY29uc3RydWN0b3IocHJvcHMpIHtcclxuICAgICAgICAgICAgdGhpcy5jb21wdXRlQ3VycmVudFZpZXdEYXRhID0gbWVtb2l6ZSh0aGlzLl9jb21wdXRlQ3VycmVudFZpZXdEYXRhKTtcclxuICAgICAgICAgICAgdGhpcy5vcmdhbml6ZVJhd0xvY2FsZXMgPSBtZW1vaXplKG9yZ2FuaXplUmF3TG9jYWxlcyk7XHJcbiAgICAgICAgICAgIHRoaXMuYnVpbGRMb2NhbGUgPSBtZW1vaXplKGJ1aWxkTG9jYWxlKTtcclxuICAgICAgICAgICAgdGhpcy5idWlsZFBsdWdpbkhvb2tzID0gYnVpbGRCdWlsZFBsdWdpbkhvb2tzKCk7XHJcbiAgICAgICAgICAgIHRoaXMuYnVpbGREYXRlRW52ID0gbWVtb2l6ZShidWlsZERhdGVFbnYkMSk7XHJcbiAgICAgICAgICAgIHRoaXMuYnVpbGRUaGVtZSA9IG1lbW9pemUoYnVpbGRUaGVtZSk7XHJcbiAgICAgICAgICAgIHRoaXMucGFyc2VUb29sYmFycyA9IG1lbW9pemUocGFyc2VUb29sYmFycyk7XHJcbiAgICAgICAgICAgIHRoaXMuYnVpbGRWaWV3U3BlY3MgPSBtZW1vaXplKGJ1aWxkVmlld1NwZWNzKTtcclxuICAgICAgICAgICAgdGhpcy5idWlsZERhdGVQcm9maWxlR2VuZXJhdG9yID0gbWVtb2l6ZU9iakFyZyhidWlsZERhdGVQcm9maWxlR2VuZXJhdG9yKTtcclxuICAgICAgICAgICAgdGhpcy5idWlsZFZpZXdBcGkgPSBtZW1vaXplKGJ1aWxkVmlld0FwaSk7XHJcbiAgICAgICAgICAgIHRoaXMuYnVpbGRWaWV3VWlQcm9wcyA9IG1lbW9pemVPYmpBcmcoYnVpbGRWaWV3VWlQcm9wcyk7XHJcbiAgICAgICAgICAgIHRoaXMuYnVpbGRFdmVudFVpQnlTb3VyY2UgPSBtZW1vaXplKGJ1aWxkRXZlbnRVaUJ5U291cmNlLCBpc1Byb3BzRXF1YWwpO1xyXG4gICAgICAgICAgICB0aGlzLmJ1aWxkRXZlbnRVaUJhc2VzID0gbWVtb2l6ZShidWlsZEV2ZW50VWlCYXNlcyk7XHJcbiAgICAgICAgICAgIHRoaXMucGFyc2VDb250ZXh0QnVzaW5lc3NIb3VycyA9IG1lbW9pemVPYmpBcmcocGFyc2VDb250ZXh0QnVzaW5lc3NIb3Vycyk7XHJcbiAgICAgICAgICAgIHRoaXMuYnVpbGRUaXRsZSA9IG1lbW9pemUoYnVpbGRUaXRsZSk7XHJcbiAgICAgICAgICAgIHRoaXMuZW1pdHRlciA9IG5ldyBFbWl0dGVyKCk7XHJcbiAgICAgICAgICAgIHRoaXMuYWN0aW9uUnVubmVyID0gbmV3IFRhc2tSdW5uZXIodGhpcy5faGFuZGxlQWN0aW9uLmJpbmQodGhpcyksIHRoaXMudXBkYXRlRGF0YS5iaW5kKHRoaXMpKTtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50Q2FsZW5kYXJPcHRpb25zSW5wdXQgPSB7fTtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50Q2FsZW5kYXJPcHRpb25zUmVmaW5lZCA9IHt9O1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRWaWV3T3B0aW9uc0lucHV0ID0ge307XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFZpZXdPcHRpb25zUmVmaW5lZCA9IHt9O1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRDYWxlbmRhck9wdGlvbnNSZWZpbmVycyA9IHt9O1xyXG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNGb3JSZWZpbmluZyA9IFtdO1xyXG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNGb3JIYW5kbGluZyA9IFtdO1xyXG4gICAgICAgICAgICB0aGlzLmdldEN1cnJlbnREYXRhID0gKCkgPT4gdGhpcy5kYXRhO1xyXG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoID0gKGFjdGlvbikgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hY3Rpb25SdW5uZXIucmVxdWVzdChhY3Rpb24pOyAvLyBwcm90ZWN0cyBhZ2FpbnN0IHJlY3Vyc2l2ZSBjYWxscyB0byBfaGFuZGxlQWN0aW9uXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHRoaXMucHJvcHMgPSBwcm9wcztcclxuICAgICAgICAgICAgdGhpcy5hY3Rpb25SdW5uZXIucGF1c2UoKTtcclxuICAgICAgICAgICAgbGV0IGR5bmFtaWNPcHRpb25PdmVycmlkZXMgPSB7fTtcclxuICAgICAgICAgICAgbGV0IG9wdGlvbnNEYXRhID0gdGhpcy5jb21wdXRlT3B0aW9uc0RhdGEocHJvcHMub3B0aW9uT3ZlcnJpZGVzLCBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzLCBwcm9wcy5jYWxlbmRhckFwaSk7XHJcbiAgICAgICAgICAgIGxldCBjdXJyZW50Vmlld1R5cGUgPSBvcHRpb25zRGF0YS5jYWxlbmRhck9wdGlvbnMuaW5pdGlhbFZpZXcgfHwgb3B0aW9uc0RhdGEucGx1Z2luSG9va3MuaW5pdGlhbFZpZXc7XHJcbiAgICAgICAgICAgIGxldCBjdXJyZW50Vmlld0RhdGEgPSB0aGlzLmNvbXB1dGVDdXJyZW50Vmlld0RhdGEoY3VycmVudFZpZXdUeXBlLCBvcHRpb25zRGF0YSwgcHJvcHMub3B0aW9uT3ZlcnJpZGVzLCBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzKTtcclxuICAgICAgICAgICAgLy8gd2lyZSB0aGluZ3MgdXBcclxuICAgICAgICAgICAgLy8gVE9ETzogbm90IERSWVxyXG4gICAgICAgICAgICBwcm9wcy5jYWxlbmRhckFwaS5jdXJyZW50RGF0YU1hbmFnZXIgPSB0aGlzO1xyXG4gICAgICAgICAgICB0aGlzLmVtaXR0ZXIuc2V0VGhpc0NvbnRleHQocHJvcHMuY2FsZW5kYXJBcGkpO1xyXG4gICAgICAgICAgICB0aGlzLmVtaXR0ZXIuc2V0T3B0aW9ucyhjdXJyZW50Vmlld0RhdGEub3B0aW9ucyk7XHJcbiAgICAgICAgICAgIGxldCBjdXJyZW50RGF0ZSA9IGdldEluaXRpYWxEYXRlKG9wdGlvbnNEYXRhLmNhbGVuZGFyT3B0aW9ucywgb3B0aW9uc0RhdGEuZGF0ZUVudik7XHJcbiAgICAgICAgICAgIGxldCBkYXRlUHJvZmlsZSA9IGN1cnJlbnRWaWV3RGF0YS5kYXRlUHJvZmlsZUdlbmVyYXRvci5idWlsZChjdXJyZW50RGF0ZSk7XHJcbiAgICAgICAgICAgIGlmICghcmFuZ2VDb250YWluc01hcmtlcihkYXRlUHJvZmlsZS5hY3RpdmVSYW5nZSwgY3VycmVudERhdGUpKSB7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50RGF0ZSA9IGRhdGVQcm9maWxlLmN1cnJlbnRSYW5nZS5zdGFydDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgY2FsZW5kYXJDb250ZXh0ID0ge1xyXG4gICAgICAgICAgICAgICAgZGF0ZUVudjogb3B0aW9uc0RhdGEuZGF0ZUVudixcclxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IG9wdGlvbnNEYXRhLmNhbGVuZGFyT3B0aW9ucyxcclxuICAgICAgICAgICAgICAgIHBsdWdpbkhvb2tzOiBvcHRpb25zRGF0YS5wbHVnaW5Ib29rcyxcclxuICAgICAgICAgICAgICAgIGNhbGVuZGFyQXBpOiBwcm9wcy5jYWxlbmRhckFwaSxcclxuICAgICAgICAgICAgICAgIGRpc3BhdGNoOiB0aGlzLmRpc3BhdGNoLFxyXG4gICAgICAgICAgICAgICAgZW1pdHRlcjogdGhpcy5lbWl0dGVyLFxyXG4gICAgICAgICAgICAgICAgZ2V0Q3VycmVudERhdGE6IHRoaXMuZ2V0Q3VycmVudERhdGEsXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8vIG5lZWRzIHRvIGJlIGFmdGVyIHNldFRoaXNDb250ZXh0XHJcbiAgICAgICAgICAgIGZvciAobGV0IGNhbGxiYWNrIG9mIG9wdGlvbnNEYXRhLnBsdWdpbkhvb2tzLmNvbnRleHRJbml0KSB7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhjYWxlbmRhckNvbnRleHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIE5PVCBEUllcclxuICAgICAgICAgICAgbGV0IGV2ZW50U291cmNlcyA9IGluaXRFdmVudFNvdXJjZXMob3B0aW9uc0RhdGEuY2FsZW5kYXJPcHRpb25zLCBkYXRlUHJvZmlsZSwgY2FsZW5kYXJDb250ZXh0KTtcclxuICAgICAgICAgICAgbGV0IGluaXRpYWxTdGF0ZSA9IHtcclxuICAgICAgICAgICAgICAgIGR5bmFtaWNPcHRpb25PdmVycmlkZXMsXHJcbiAgICAgICAgICAgICAgICBjdXJyZW50Vmlld1R5cGUsXHJcbiAgICAgICAgICAgICAgICBjdXJyZW50RGF0ZSxcclxuICAgICAgICAgICAgICAgIGRhdGVQcm9maWxlLFxyXG4gICAgICAgICAgICAgICAgYnVzaW5lc3NIb3VyczogdGhpcy5wYXJzZUNvbnRleHRCdXNpbmVzc0hvdXJzKGNhbGVuZGFyQ29udGV4dCksXHJcbiAgICAgICAgICAgICAgICBldmVudFNvdXJjZXMsXHJcbiAgICAgICAgICAgICAgICBldmVudFVpQmFzZXM6IHt9LFxyXG4gICAgICAgICAgICAgICAgZXZlbnRTdG9yZTogY3JlYXRlRW1wdHlFdmVudFN0b3JlKCksXHJcbiAgICAgICAgICAgICAgICByZW5kZXJhYmxlRXZlbnRTdG9yZTogY3JlYXRlRW1wdHlFdmVudFN0b3JlKCksXHJcbiAgICAgICAgICAgICAgICBkYXRlU2VsZWN0aW9uOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgZXZlbnRTZWxlY3Rpb246ICcnLFxyXG4gICAgICAgICAgICAgICAgZXZlbnREcmFnOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgZXZlbnRSZXNpemU6IG51bGwsXHJcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb25Db25maWc6IHRoaXMuYnVpbGRWaWV3VWlQcm9wcyhjYWxlbmRhckNvbnRleHQpLnNlbGVjdGlvbkNvbmZpZyxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgbGV0IGNvbnRleHRBbmRTdGF0ZSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY2FsZW5kYXJDb250ZXh0KSwgaW5pdGlhbFN0YXRlKTtcclxuICAgICAgICAgICAgZm9yIChsZXQgcmVkdWNlciBvZiBvcHRpb25zRGF0YS5wbHVnaW5Ib29rcy5yZWR1Y2Vycykge1xyXG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihpbml0aWFsU3RhdGUsIHJlZHVjZXIobnVsbCwgbnVsbCwgY29udGV4dEFuZFN0YXRlKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGNvbXB1dGVJc0xvYWRpbmcoaW5pdGlhbFN0YXRlLCBjYWxlbmRhckNvbnRleHQpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXR0ZXIudHJpZ2dlcignbG9hZGluZycsIHRydWUpOyAvLyBOT1QgRFJZXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IGluaXRpYWxTdGF0ZTtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVEYXRhKCk7XHJcbiAgICAgICAgICAgIHRoaXMuYWN0aW9uUnVubmVyLnJlc3VtZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXNldE9wdGlvbnMob3B0aW9uT3ZlcnJpZGVzLCBjaGFuZ2VkT3B0aW9uTmFtZXMpIHtcclxuICAgICAgICAgICAgbGV0IHsgcHJvcHMgfSA9IHRoaXM7XHJcbiAgICAgICAgICAgIGlmIChjaGFuZ2VkT3B0aW9uTmFtZXMgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgcHJvcHMub3B0aW9uT3ZlcnJpZGVzID0gb3B0aW9uT3ZlcnJpZGVzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcHJvcHMub3B0aW9uT3ZlcnJpZGVzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCAocHJvcHMub3B0aW9uT3ZlcnJpZGVzIHx8IHt9KSksIG9wdGlvbk92ZXJyaWRlcyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnNGb3JSZWZpbmluZy5wdXNoKC4uLmNoYW5nZWRPcHRpb25OYW1lcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGNoYW5nZWRPcHRpb25OYW1lcyA9PT0gdW5kZWZpbmVkIHx8IGNoYW5nZWRPcHRpb25OYW1lcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYWN0aW9uUnVubmVyLnJlcXVlc3Qoe1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdOT1RISU5HJyxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9oYW5kbGVBY3Rpb24oYWN0aW9uKSB7XHJcbiAgICAgICAgICAgIGxldCB7IHByb3BzLCBzdGF0ZSwgZW1pdHRlciB9ID0gdGhpcztcclxuICAgICAgICAgICAgbGV0IGR5bmFtaWNPcHRpb25PdmVycmlkZXMgPSByZWR1Y2VEeW5hbWljT3B0aW9uT3ZlcnJpZGVzKHN0YXRlLmR5bmFtaWNPcHRpb25PdmVycmlkZXMsIGFjdGlvbik7XHJcbiAgICAgICAgICAgIGxldCBvcHRpb25zRGF0YSA9IHRoaXMuY29tcHV0ZU9wdGlvbnNEYXRhKHByb3BzLm9wdGlvbk92ZXJyaWRlcywgZHluYW1pY09wdGlvbk92ZXJyaWRlcywgcHJvcHMuY2FsZW5kYXJBcGkpO1xyXG4gICAgICAgICAgICBsZXQgY3VycmVudFZpZXdUeXBlID0gcmVkdWNlVmlld1R5cGUoc3RhdGUuY3VycmVudFZpZXdUeXBlLCBhY3Rpb24pO1xyXG4gICAgICAgICAgICBsZXQgY3VycmVudFZpZXdEYXRhID0gdGhpcy5jb21wdXRlQ3VycmVudFZpZXdEYXRhKGN1cnJlbnRWaWV3VHlwZSwgb3B0aW9uc0RhdGEsIHByb3BzLm9wdGlvbk92ZXJyaWRlcywgZHluYW1pY09wdGlvbk92ZXJyaWRlcyk7XHJcbiAgICAgICAgICAgIC8vIHdpcmUgdGhpbmdzIHVwXHJcbiAgICAgICAgICAgIC8vIFRPRE86IG5vdCBEUllcclxuICAgICAgICAgICAgcHJvcHMuY2FsZW5kYXJBcGkuY3VycmVudERhdGFNYW5hZ2VyID0gdGhpcztcclxuICAgICAgICAgICAgZW1pdHRlci5zZXRUaGlzQ29udGV4dChwcm9wcy5jYWxlbmRhckFwaSk7XHJcbiAgICAgICAgICAgIGVtaXR0ZXIuc2V0T3B0aW9ucyhjdXJyZW50Vmlld0RhdGEub3B0aW9ucyk7XHJcbiAgICAgICAgICAgIGxldCBjYWxlbmRhckNvbnRleHQgPSB7XHJcbiAgICAgICAgICAgICAgICBkYXRlRW52OiBvcHRpb25zRGF0YS5kYXRlRW52LFxyXG4gICAgICAgICAgICAgICAgb3B0aW9uczogb3B0aW9uc0RhdGEuY2FsZW5kYXJPcHRpb25zLFxyXG4gICAgICAgICAgICAgICAgcGx1Z2luSG9va3M6IG9wdGlvbnNEYXRhLnBsdWdpbkhvb2tzLFxyXG4gICAgICAgICAgICAgICAgY2FsZW5kYXJBcGk6IHByb3BzLmNhbGVuZGFyQXBpLFxyXG4gICAgICAgICAgICAgICAgZGlzcGF0Y2g6IHRoaXMuZGlzcGF0Y2gsXHJcbiAgICAgICAgICAgICAgICBlbWl0dGVyLFxyXG4gICAgICAgICAgICAgICAgZ2V0Q3VycmVudERhdGE6IHRoaXMuZ2V0Q3VycmVudERhdGEsXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGxldCB7IGN1cnJlbnREYXRlLCBkYXRlUHJvZmlsZSB9ID0gc3RhdGU7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmRhdGEgJiYgdGhpcy5kYXRhLmRhdGVQcm9maWxlR2VuZXJhdG9yICE9PSBjdXJyZW50Vmlld0RhdGEuZGF0ZVByb2ZpbGVHZW5lcmF0b3IpIHsgLy8gaGFja1xyXG4gICAgICAgICAgICAgICAgZGF0ZVByb2ZpbGUgPSBjdXJyZW50Vmlld0RhdGEuZGF0ZVByb2ZpbGVHZW5lcmF0b3IuYnVpbGQoY3VycmVudERhdGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGN1cnJlbnREYXRlID0gcmVkdWNlQ3VycmVudERhdGUoY3VycmVudERhdGUsIGFjdGlvbik7XHJcbiAgICAgICAgICAgIGRhdGVQcm9maWxlID0gcmVkdWNlRGF0ZVByb2ZpbGUoZGF0ZVByb2ZpbGUsIGFjdGlvbiwgY3VycmVudERhdGUsIGN1cnJlbnRWaWV3RGF0YS5kYXRlUHJvZmlsZUdlbmVyYXRvcik7XHJcbiAgICAgICAgICAgIGlmIChhY3Rpb24udHlwZSA9PT0gJ1BSRVYnIHx8IC8vIFRPRE86IG1vdmUgdGhpcyBsb2dpYyBpbnRvIERhdGVQcm9maWxlR2VuZXJhdG9yXHJcbiAgICAgICAgICAgICAgICBhY3Rpb24udHlwZSA9PT0gJ05FWFQnIHx8IC8vIFwiXHJcbiAgICAgICAgICAgICAgICAhcmFuZ2VDb250YWluc01hcmtlcihkYXRlUHJvZmlsZS5jdXJyZW50UmFuZ2UsIGN1cnJlbnREYXRlKSkge1xyXG4gICAgICAgICAgICAgICAgY3VycmVudERhdGUgPSBkYXRlUHJvZmlsZS5jdXJyZW50UmFuZ2Uuc3RhcnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IGV2ZW50U291cmNlcyA9IHJlZHVjZUV2ZW50U291cmNlcyhzdGF0ZS5ldmVudFNvdXJjZXMsIGFjdGlvbiwgZGF0ZVByb2ZpbGUsIGNhbGVuZGFyQ29udGV4dCk7XHJcbiAgICAgICAgICAgIGxldCBldmVudFN0b3JlID0gcmVkdWNlRXZlbnRTdG9yZShzdGF0ZS5ldmVudFN0b3JlLCBhY3Rpb24sIGV2ZW50U291cmNlcywgZGF0ZVByb2ZpbGUsIGNhbGVuZGFyQ29udGV4dCk7XHJcbiAgICAgICAgICAgIGxldCBpc0V2ZW50c0xvYWRpbmcgPSBjb21wdXRlRXZlbnRTb3VyY2VzTG9hZGluZyhldmVudFNvdXJjZXMpOyAvLyBCQUQuIGFsc28gY2FsbGVkIGluIHRoaXMgZnVuYyBpbiBjb21wdXRlSXNMb2FkaW5nXHJcbiAgICAgICAgICAgIGxldCByZW5kZXJhYmxlRXZlbnRTdG9yZSA9IChpc0V2ZW50c0xvYWRpbmcgJiYgIWN1cnJlbnRWaWV3RGF0YS5vcHRpb25zLnByb2dyZXNzaXZlRXZlbnRSZW5kZXJpbmcpID9cclxuICAgICAgICAgICAgICAgIChzdGF0ZS5yZW5kZXJhYmxlRXZlbnRTdG9yZSB8fCBldmVudFN0b3JlKSA6IC8vIHRyeSBmcm9tIHByZXZpb3VzIHN0YXRlXHJcbiAgICAgICAgICAgICAgICBldmVudFN0b3JlO1xyXG4gICAgICAgICAgICBsZXQgeyBldmVudFVpU2luZ2xlQmFzZSwgc2VsZWN0aW9uQ29uZmlnIH0gPSB0aGlzLmJ1aWxkVmlld1VpUHJvcHMoY2FsZW5kYXJDb250ZXh0KTsgLy8gd2lsbCBtZW1vaXplIG9ialxyXG4gICAgICAgICAgICBsZXQgZXZlbnRVaUJ5U291cmNlID0gdGhpcy5idWlsZEV2ZW50VWlCeVNvdXJjZShldmVudFNvdXJjZXMpO1xyXG4gICAgICAgICAgICBsZXQgZXZlbnRVaUJhc2VzID0gdGhpcy5idWlsZEV2ZW50VWlCYXNlcyhyZW5kZXJhYmxlRXZlbnRTdG9yZS5kZWZzLCBldmVudFVpU2luZ2xlQmFzZSwgZXZlbnRVaUJ5U291cmNlKTtcclxuICAgICAgICAgICAgbGV0IG5ld1N0YXRlID0ge1xyXG4gICAgICAgICAgICAgICAgZHluYW1pY09wdGlvbk92ZXJyaWRlcyxcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRWaWV3VHlwZSxcclxuICAgICAgICAgICAgICAgIGN1cnJlbnREYXRlLFxyXG4gICAgICAgICAgICAgICAgZGF0ZVByb2ZpbGUsXHJcbiAgICAgICAgICAgICAgICBldmVudFNvdXJjZXMsXHJcbiAgICAgICAgICAgICAgICBldmVudFN0b3JlLFxyXG4gICAgICAgICAgICAgICAgcmVuZGVyYWJsZUV2ZW50U3RvcmUsXHJcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb25Db25maWcsXHJcbiAgICAgICAgICAgICAgICBldmVudFVpQmFzZXMsXHJcbiAgICAgICAgICAgICAgICBidXNpbmVzc0hvdXJzOiB0aGlzLnBhcnNlQ29udGV4dEJ1c2luZXNzSG91cnMoY2FsZW5kYXJDb250ZXh0KSxcclxuICAgICAgICAgICAgICAgIGRhdGVTZWxlY3Rpb246IHJlZHVjZURhdGVTZWxlY3Rpb24oc3RhdGUuZGF0ZVNlbGVjdGlvbiwgYWN0aW9uKSxcclxuICAgICAgICAgICAgICAgIGV2ZW50U2VsZWN0aW9uOiByZWR1Y2VTZWxlY3RlZEV2ZW50KHN0YXRlLmV2ZW50U2VsZWN0aW9uLCBhY3Rpb24pLFxyXG4gICAgICAgICAgICAgICAgZXZlbnREcmFnOiByZWR1Y2VFdmVudERyYWcoc3RhdGUuZXZlbnREcmFnLCBhY3Rpb24pLFxyXG4gICAgICAgICAgICAgICAgZXZlbnRSZXNpemU6IHJlZHVjZUV2ZW50UmVzaXplKHN0YXRlLmV2ZW50UmVzaXplLCBhY3Rpb24pLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBsZXQgY29udGV4dEFuZFN0YXRlID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBjYWxlbmRhckNvbnRleHQpLCBuZXdTdGF0ZSk7XHJcbiAgICAgICAgICAgIGZvciAobGV0IHJlZHVjZXIgb2Ygb3B0aW9uc0RhdGEucGx1Z2luSG9va3MucmVkdWNlcnMpIHtcclxuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24obmV3U3RhdGUsIHJlZHVjZXIoc3RhdGUsIGFjdGlvbiwgY29udGV4dEFuZFN0YXRlKSk7IC8vIGdpdmUgdGhlIE9MRCBzdGF0ZSwgZm9yIG9sZCB2YWx1ZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxldCB3YXNMb2FkaW5nID0gY29tcHV0ZUlzTG9hZGluZyhzdGF0ZSwgY2FsZW5kYXJDb250ZXh0KTtcclxuICAgICAgICAgICAgbGV0IGlzTG9hZGluZyA9IGNvbXB1dGVJc0xvYWRpbmcobmV3U3RhdGUsIGNhbGVuZGFyQ29udGV4dCk7XHJcbiAgICAgICAgICAgIC8vIFRPRE86IHVzZSBwcm9wU2V0SGFuZGxlcnMgaW4gcGx1Z2luIHN5c3RlbVxyXG4gICAgICAgICAgICBpZiAoIXdhc0xvYWRpbmcgJiYgaXNMb2FkaW5nKSB7XHJcbiAgICAgICAgICAgICAgICBlbWl0dGVyLnRyaWdnZXIoJ2xvYWRpbmcnLCB0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh3YXNMb2FkaW5nICYmICFpc0xvYWRpbmcpIHtcclxuICAgICAgICAgICAgICAgIGVtaXR0ZXIudHJpZ2dlcignbG9hZGluZycsIGZhbHNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gbmV3U3RhdGU7XHJcbiAgICAgICAgICAgIGlmIChwcm9wcy5vbkFjdGlvbikge1xyXG4gICAgICAgICAgICAgICAgcHJvcHMub25BY3Rpb24oYWN0aW9uKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB1cGRhdGVEYXRhKCkge1xyXG4gICAgICAgICAgICBsZXQgeyBwcm9wcywgc3RhdGUgfSA9IHRoaXM7XHJcbiAgICAgICAgICAgIGxldCBvbGREYXRhID0gdGhpcy5kYXRhO1xyXG4gICAgICAgICAgICBsZXQgb3B0aW9uc0RhdGEgPSB0aGlzLmNvbXB1dGVPcHRpb25zRGF0YShwcm9wcy5vcHRpb25PdmVycmlkZXMsIHN0YXRlLmR5bmFtaWNPcHRpb25PdmVycmlkZXMsIHByb3BzLmNhbGVuZGFyQXBpKTtcclxuICAgICAgICAgICAgbGV0IGN1cnJlbnRWaWV3RGF0YSA9IHRoaXMuY29tcHV0ZUN1cnJlbnRWaWV3RGF0YShzdGF0ZS5jdXJyZW50Vmlld1R5cGUsIG9wdGlvbnNEYXRhLCBwcm9wcy5vcHRpb25PdmVycmlkZXMsIHN0YXRlLmR5bmFtaWNPcHRpb25PdmVycmlkZXMpO1xyXG4gICAgICAgICAgICBsZXQgZGF0YSA9IHRoaXMuZGF0YSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgdmlld1RpdGxlOiB0aGlzLmJ1aWxkVGl0bGUoc3RhdGUuZGF0ZVByb2ZpbGUsIGN1cnJlbnRWaWV3RGF0YS5vcHRpb25zLCBvcHRpb25zRGF0YS5kYXRlRW52KSwgY2FsZW5kYXJBcGk6IHByb3BzLmNhbGVuZGFyQXBpLCBkaXNwYXRjaDogdGhpcy5kaXNwYXRjaCwgZW1pdHRlcjogdGhpcy5lbWl0dGVyLCBnZXRDdXJyZW50RGF0YTogdGhpcy5nZXRDdXJyZW50RGF0YSB9LCBvcHRpb25zRGF0YSksIGN1cnJlbnRWaWV3RGF0YSksIHN0YXRlKTtcclxuICAgICAgICAgICAgbGV0IGNoYW5nZUhhbmRsZXJzID0gb3B0aW9uc0RhdGEucGx1Z2luSG9va3Mub3B0aW9uQ2hhbmdlSGFuZGxlcnM7XHJcbiAgICAgICAgICAgIGxldCBvbGRDYWxlbmRhck9wdGlvbnMgPSBvbGREYXRhICYmIG9sZERhdGEuY2FsZW5kYXJPcHRpb25zO1xyXG4gICAgICAgICAgICBsZXQgbmV3Q2FsZW5kYXJPcHRpb25zID0gb3B0aW9uc0RhdGEuY2FsZW5kYXJPcHRpb25zO1xyXG4gICAgICAgICAgICBpZiAob2xkQ2FsZW5kYXJPcHRpb25zICYmIG9sZENhbGVuZGFyT3B0aW9ucyAhPT0gbmV3Q2FsZW5kYXJPcHRpb25zKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAob2xkQ2FsZW5kYXJPcHRpb25zLnRpbWVab25lICE9PSBuZXdDYWxlbmRhck9wdGlvbnMudGltZVpvbmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBoYWNrXHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuZXZlbnRTb3VyY2VzID0gZGF0YS5ldmVudFNvdXJjZXMgPSByZWR1Y2VFdmVudFNvdXJjZXNOZXdUaW1lWm9uZShkYXRhLmV2ZW50U291cmNlcywgc3RhdGUuZGF0ZVByb2ZpbGUsIGRhdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLmV2ZW50U3RvcmUgPSBkYXRhLmV2ZW50U3RvcmUgPSByZXpvbmVFdmVudFN0b3JlRGF0ZXMoZGF0YS5ldmVudFN0b3JlLCBvbGREYXRhLmRhdGVFbnYsIGRhdGEuZGF0ZUVudik7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUucmVuZGVyYWJsZUV2ZW50U3RvcmUgPSBkYXRhLnJlbmRlcmFibGVFdmVudFN0b3JlID0gcmV6b25lRXZlbnRTdG9yZURhdGVzKGRhdGEucmVuZGVyYWJsZUV2ZW50U3RvcmUsIG9sZERhdGEuZGF0ZUVudiwgZGF0YS5kYXRlRW52KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGZvciAobGV0IG9wdGlvbk5hbWUgaW4gY2hhbmdlSGFuZGxlcnMpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zRm9ySGFuZGxpbmcuaW5kZXhPZihvcHRpb25OYW1lKSAhPT0gLTEgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgb2xkQ2FsZW5kYXJPcHRpb25zW29wdGlvbk5hbWVdICE9PSBuZXdDYWxlbmRhck9wdGlvbnNbb3B0aW9uTmFtZV0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlSGFuZGxlcnNbb3B0aW9uTmFtZV0obmV3Q2FsZW5kYXJPcHRpb25zW29wdGlvbk5hbWVdLCBkYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5vcHRpb25zRm9ySGFuZGxpbmcgPSBbXTtcclxuICAgICAgICAgICAgaWYgKHByb3BzLm9uRGF0YSkge1xyXG4gICAgICAgICAgICAgICAgcHJvcHMub25EYXRhKGRhdGEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbXB1dGVPcHRpb25zRGF0YShvcHRpb25PdmVycmlkZXMsIGR5bmFtaWNPcHRpb25PdmVycmlkZXMsIGNhbGVuZGFyQXBpKSB7XHJcbiAgICAgICAgICAgIC8vIFRPRE86IGJsYWNrbGlzdCBvcHRpb25zIHRoYXQgYXJlIGhhbmRsZWQgYnkgb3B0aW9uQ2hhbmdlSGFuZGxlcnNcclxuICAgICAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnNGb3JSZWZpbmluZy5sZW5ndGggJiZcclxuICAgICAgICAgICAgICAgIG9wdGlvbk92ZXJyaWRlcyA9PT0gdGhpcy5zdGFibGVPcHRpb25PdmVycmlkZXMgJiZcclxuICAgICAgICAgICAgICAgIGR5bmFtaWNPcHRpb25PdmVycmlkZXMgPT09IHRoaXMuc3RhYmxlRHluYW1pY09wdGlvbk92ZXJyaWRlcykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhYmxlQ2FsZW5kYXJPcHRpb25zRGF0YTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgeyByZWZpbmVkT3B0aW9ucywgcGx1Z2luSG9va3MsIGxvY2FsZURlZmF1bHRzLCBhdmFpbGFibGVMb2NhbGVEYXRhLCBleHRyYSwgfSA9IHRoaXMucHJvY2Vzc1Jhd0NhbGVuZGFyT3B0aW9ucyhvcHRpb25PdmVycmlkZXMsIGR5bmFtaWNPcHRpb25PdmVycmlkZXMpO1xyXG4gICAgICAgICAgICB3YXJuVW5rbm93bk9wdGlvbnMoZXh0cmEpO1xyXG4gICAgICAgICAgICBsZXQgZGF0ZUVudiA9IHRoaXMuYnVpbGREYXRlRW52KHJlZmluZWRPcHRpb25zLnRpbWVab25lLCByZWZpbmVkT3B0aW9ucy5sb2NhbGUsIHJlZmluZWRPcHRpb25zLndlZWtOdW1iZXJDYWxjdWxhdGlvbiwgcmVmaW5lZE9wdGlvbnMuZmlyc3REYXksIHJlZmluZWRPcHRpb25zLndlZWtUZXh0LCBwbHVnaW5Ib29rcywgYXZhaWxhYmxlTG9jYWxlRGF0YSwgcmVmaW5lZE9wdGlvbnMuZGVmYXVsdFJhbmdlU2VwYXJhdG9yKTtcclxuICAgICAgICAgICAgbGV0IHZpZXdTcGVjcyA9IHRoaXMuYnVpbGRWaWV3U3BlY3MocGx1Z2luSG9va3Mudmlld3MsIHRoaXMuc3RhYmxlT3B0aW9uT3ZlcnJpZGVzLCB0aGlzLnN0YWJsZUR5bmFtaWNPcHRpb25PdmVycmlkZXMsIGxvY2FsZURlZmF1bHRzKTtcclxuICAgICAgICAgICAgbGV0IHRoZW1lID0gdGhpcy5idWlsZFRoZW1lKHJlZmluZWRPcHRpb25zLCBwbHVnaW5Ib29rcyk7XHJcbiAgICAgICAgICAgIGxldCB0b29sYmFyQ29uZmlnID0gdGhpcy5wYXJzZVRvb2xiYXJzKHJlZmluZWRPcHRpb25zLCB0aGlzLnN0YWJsZU9wdGlvbk92ZXJyaWRlcywgdGhlbWUsIHZpZXdTcGVjcywgY2FsZW5kYXJBcGkpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdGFibGVDYWxlbmRhck9wdGlvbnNEYXRhID0ge1xyXG4gICAgICAgICAgICAgICAgY2FsZW5kYXJPcHRpb25zOiByZWZpbmVkT3B0aW9ucyxcclxuICAgICAgICAgICAgICAgIHBsdWdpbkhvb2tzLFxyXG4gICAgICAgICAgICAgICAgZGF0ZUVudixcclxuICAgICAgICAgICAgICAgIHZpZXdTcGVjcyxcclxuICAgICAgICAgICAgICAgIHRoZW1lLFxyXG4gICAgICAgICAgICAgICAgdG9vbGJhckNvbmZpZyxcclxuICAgICAgICAgICAgICAgIGxvY2FsZURlZmF1bHRzLFxyXG4gICAgICAgICAgICAgICAgYXZhaWxhYmxlUmF3TG9jYWxlczogYXZhaWxhYmxlTG9jYWxlRGF0YS5tYXAsXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGFsd2F5cyBjYWxsZWQgZnJvbSBiZWhpbmQgYSBtZW1vaXplclxyXG4gICAgICAgIHByb2Nlc3NSYXdDYWxlbmRhck9wdGlvbnMob3B0aW9uT3ZlcnJpZGVzLCBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzKSB7XHJcbiAgICAgICAgICAgIGxldCB7IGxvY2FsZXMsIGxvY2FsZSB9ID0gbWVyZ2VSYXdPcHRpb25zKFtcclxuICAgICAgICAgICAgICAgIEJBU0VfT1BUSU9OX0RFRkFVTFRTLFxyXG4gICAgICAgICAgICAgICAgb3B0aW9uT3ZlcnJpZGVzLFxyXG4gICAgICAgICAgICAgICAgZHluYW1pY09wdGlvbk92ZXJyaWRlcyxcclxuICAgICAgICAgICAgXSk7XHJcbiAgICAgICAgICAgIGxldCBhdmFpbGFibGVMb2NhbGVEYXRhID0gdGhpcy5vcmdhbml6ZVJhd0xvY2FsZXMobG9jYWxlcyk7XHJcbiAgICAgICAgICAgIGxldCBhdmFpbGFibGVSYXdMb2NhbGVzID0gYXZhaWxhYmxlTG9jYWxlRGF0YS5tYXA7XHJcbiAgICAgICAgICAgIGxldCBsb2NhbGVEZWZhdWx0cyA9IHRoaXMuYnVpbGRMb2NhbGUobG9jYWxlIHx8IGF2YWlsYWJsZUxvY2FsZURhdGEuZGVmYXVsdENvZGUsIGF2YWlsYWJsZVJhd0xvY2FsZXMpLm9wdGlvbnM7XHJcbiAgICAgICAgICAgIGxldCBwbHVnaW5Ib29rcyA9IHRoaXMuYnVpbGRQbHVnaW5Ib29rcyhvcHRpb25PdmVycmlkZXMucGx1Z2lucyB8fCBbXSwgZ2xvYmFsUGx1Z2lucyk7XHJcbiAgICAgICAgICAgIGxldCByZWZpbmVycyA9IHRoaXMuY3VycmVudENhbGVuZGFyT3B0aW9uc1JlZmluZXJzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBCQVNFX09QVElPTl9SRUZJTkVSUyksIENBTEVOREFSX0xJU1RFTkVSX1JFRklORVJTKSwgQ0FMRU5EQVJfT1BUSU9OX1JFRklORVJTKSwgcGx1Z2luSG9va3MubGlzdGVuZXJSZWZpbmVycyksIHBsdWdpbkhvb2tzLm9wdGlvblJlZmluZXJzKTtcclxuICAgICAgICAgICAgbGV0IGV4dHJhID0ge307XHJcbiAgICAgICAgICAgIGxldCByYXcgPSBtZXJnZVJhd09wdGlvbnMoW1xyXG4gICAgICAgICAgICAgICAgQkFTRV9PUFRJT05fREVGQVVMVFMsXHJcbiAgICAgICAgICAgICAgICBsb2NhbGVEZWZhdWx0cyxcclxuICAgICAgICAgICAgICAgIG9wdGlvbk92ZXJyaWRlcyxcclxuICAgICAgICAgICAgICAgIGR5bmFtaWNPcHRpb25PdmVycmlkZXMsXHJcbiAgICAgICAgICAgIF0pO1xyXG4gICAgICAgICAgICBsZXQgcmVmaW5lZCA9IHt9O1xyXG4gICAgICAgICAgICBsZXQgY3VycmVudFJhdyA9IHRoaXMuY3VycmVudENhbGVuZGFyT3B0aW9uc0lucHV0O1xyXG4gICAgICAgICAgICBsZXQgY3VycmVudFJlZmluZWQgPSB0aGlzLmN1cnJlbnRDYWxlbmRhck9wdGlvbnNSZWZpbmVkO1xyXG4gICAgICAgICAgICBsZXQgYW55Q2hhbmdlcyA9IGZhbHNlO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBvcHRpb25OYW1lIGluIHJhdykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9uc0ZvclJlZmluaW5nLmluZGV4T2Yob3B0aW9uTmFtZSkgPT09IC0xICYmIChyYXdbb3B0aW9uTmFtZV0gPT09IGN1cnJlbnRSYXdbb3B0aW9uTmFtZV0gfHwgKENPTVBMRVhfT1BUSU9OX0NPTVBBUkFUT1JTW29wdGlvbk5hbWVdICYmXHJcbiAgICAgICAgICAgICAgICAgICAgKG9wdGlvbk5hbWUgaW4gY3VycmVudFJhdykgJiZcclxuICAgICAgICAgICAgICAgICAgICBDT01QTEVYX09QVElPTl9DT01QQVJBVE9SU1tvcHRpb25OYW1lXShjdXJyZW50UmF3W29wdGlvbk5hbWVdLCByYXdbb3B0aW9uTmFtZV0pKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZWZpbmVkW29wdGlvbk5hbWVdID0gY3VycmVudFJlZmluZWRbb3B0aW9uTmFtZV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyZWZpbmVyc1tvcHRpb25OYW1lXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlZmluZWRbb3B0aW9uTmFtZV0gPSByZWZpbmVyc1tvcHRpb25OYW1lXShyYXdbb3B0aW9uTmFtZV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGFueUNoYW5nZXMgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXh0cmFbb3B0aW9uTmFtZV0gPSBjdXJyZW50UmF3W29wdGlvbk5hbWVdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChhbnlDaGFuZ2VzKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRDYWxlbmRhck9wdGlvbnNJbnB1dCA9IHJhdztcclxuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudENhbGVuZGFyT3B0aW9uc1JlZmluZWQgPSByZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGFibGVPcHRpb25PdmVycmlkZXMgPSBvcHRpb25PdmVycmlkZXM7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0YWJsZUR5bmFtaWNPcHRpb25PdmVycmlkZXMgPSBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMub3B0aW9uc0ZvckhhbmRsaW5nLnB1c2goLi4udGhpcy5vcHRpb25zRm9yUmVmaW5pbmcpO1xyXG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNGb3JSZWZpbmluZyA9IFtdO1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgcmF3T3B0aW9uczogdGhpcy5jdXJyZW50Q2FsZW5kYXJPcHRpb25zSW5wdXQsXHJcbiAgICAgICAgICAgICAgICByZWZpbmVkT3B0aW9uczogdGhpcy5jdXJyZW50Q2FsZW5kYXJPcHRpb25zUmVmaW5lZCxcclxuICAgICAgICAgICAgICAgIHBsdWdpbkhvb2tzLFxyXG4gICAgICAgICAgICAgICAgYXZhaWxhYmxlTG9jYWxlRGF0YSxcclxuICAgICAgICAgICAgICAgIGxvY2FsZURlZmF1bHRzLFxyXG4gICAgICAgICAgICAgICAgZXh0cmEsXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9jb21wdXRlQ3VycmVudFZpZXdEYXRhKHZpZXdUeXBlLCBvcHRpb25zRGF0YSwgb3B0aW9uT3ZlcnJpZGVzLCBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzKSB7XHJcbiAgICAgICAgICAgIGxldCB2aWV3U3BlYyA9IG9wdGlvbnNEYXRhLnZpZXdTcGVjc1t2aWV3VHlwZV07XHJcbiAgICAgICAgICAgIGlmICghdmlld1NwZWMpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgdmlld1R5cGUgXCIke3ZpZXdUeXBlfVwiIGlzIG5vdCBhdmFpbGFibGUuIFBsZWFzZSBtYWtlIHN1cmUgeW91J3ZlIGxvYWRlZCBhbGwgbmVjY2Vzc2FyeSBwbHVnaW5zYCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IHsgcmVmaW5lZE9wdGlvbnMsIGV4dHJhIH0gPSB0aGlzLnByb2Nlc3NSYXdWaWV3T3B0aW9ucyh2aWV3U3BlYywgb3B0aW9uc0RhdGEucGx1Z2luSG9va3MsIG9wdGlvbnNEYXRhLmxvY2FsZURlZmF1bHRzLCBvcHRpb25PdmVycmlkZXMsIGR5bmFtaWNPcHRpb25PdmVycmlkZXMpO1xyXG4gICAgICAgICAgICB3YXJuVW5rbm93bk9wdGlvbnMoZXh0cmEpO1xyXG4gICAgICAgICAgICBsZXQgZGF0ZVByb2ZpbGVHZW5lcmF0b3IgPSB0aGlzLmJ1aWxkRGF0ZVByb2ZpbGVHZW5lcmF0b3Ioe1xyXG4gICAgICAgICAgICAgICAgZGF0ZVByb2ZpbGVHZW5lcmF0b3JDbGFzczogdmlld1NwZWMub3B0aW9uRGVmYXVsdHMuZGF0ZVByb2ZpbGVHZW5lcmF0b3JDbGFzcyxcclxuICAgICAgICAgICAgICAgIGR1cmF0aW9uOiB2aWV3U3BlYy5kdXJhdGlvbixcclxuICAgICAgICAgICAgICAgIGR1cmF0aW9uVW5pdDogdmlld1NwZWMuZHVyYXRpb25Vbml0LFxyXG4gICAgICAgICAgICAgICAgdXNlc01pbk1heFRpbWU6IHZpZXdTcGVjLm9wdGlvbkRlZmF1bHRzLnVzZXNNaW5NYXhUaW1lLFxyXG4gICAgICAgICAgICAgICAgZGF0ZUVudjogb3B0aW9uc0RhdGEuZGF0ZUVudixcclxuICAgICAgICAgICAgICAgIGNhbGVuZGFyQXBpOiB0aGlzLnByb3BzLmNhbGVuZGFyQXBpLFxyXG4gICAgICAgICAgICAgICAgc2xvdE1pblRpbWU6IHJlZmluZWRPcHRpb25zLnNsb3RNaW5UaW1lLFxyXG4gICAgICAgICAgICAgICAgc2xvdE1heFRpbWU6IHJlZmluZWRPcHRpb25zLnNsb3RNYXhUaW1lLFxyXG4gICAgICAgICAgICAgICAgc2hvd05vbkN1cnJlbnREYXRlczogcmVmaW5lZE9wdGlvbnMuc2hvd05vbkN1cnJlbnREYXRlcyxcclxuICAgICAgICAgICAgICAgIGRheUNvdW50OiByZWZpbmVkT3B0aW9ucy5kYXlDb3VudCxcclxuICAgICAgICAgICAgICAgIGRhdGVBbGlnbm1lbnQ6IHJlZmluZWRPcHRpb25zLmRhdGVBbGlnbm1lbnQsXHJcbiAgICAgICAgICAgICAgICBkYXRlSW5jcmVtZW50OiByZWZpbmVkT3B0aW9ucy5kYXRlSW5jcmVtZW50LFxyXG4gICAgICAgICAgICAgICAgaGlkZGVuRGF5czogcmVmaW5lZE9wdGlvbnMuaGlkZGVuRGF5cyxcclxuICAgICAgICAgICAgICAgIHdlZWtlbmRzOiByZWZpbmVkT3B0aW9ucy53ZWVrZW5kcyxcclxuICAgICAgICAgICAgICAgIG5vd0lucHV0OiByZWZpbmVkT3B0aW9ucy5ub3csXHJcbiAgICAgICAgICAgICAgICB2YWxpZFJhbmdlSW5wdXQ6IHJlZmluZWRPcHRpb25zLnZhbGlkUmFuZ2UsXHJcbiAgICAgICAgICAgICAgICB2aXNpYmxlUmFuZ2VJbnB1dDogcmVmaW5lZE9wdGlvbnMudmlzaWJsZVJhbmdlLFxyXG4gICAgICAgICAgICAgICAgZml4ZWRXZWVrQ291bnQ6IHJlZmluZWRPcHRpb25zLmZpeGVkV2Vla0NvdW50LFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgbGV0IHZpZXdBcGkgPSB0aGlzLmJ1aWxkVmlld0FwaSh2aWV3VHlwZSwgdGhpcy5nZXRDdXJyZW50RGF0YSwgb3B0aW9uc0RhdGEuZGF0ZUVudik7XHJcbiAgICAgICAgICAgIHJldHVybiB7IHZpZXdTcGVjLCBvcHRpb25zOiByZWZpbmVkT3B0aW9ucywgZGF0ZVByb2ZpbGVHZW5lcmF0b3IsIHZpZXdBcGkgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcHJvY2Vzc1Jhd1ZpZXdPcHRpb25zKHZpZXdTcGVjLCBwbHVnaW5Ib29rcywgbG9jYWxlRGVmYXVsdHMsIG9wdGlvbk92ZXJyaWRlcywgZHluYW1pY09wdGlvbk92ZXJyaWRlcykge1xyXG4gICAgICAgICAgICBsZXQgcmF3ID0gbWVyZ2VSYXdPcHRpb25zKFtcclxuICAgICAgICAgICAgICAgIEJBU0VfT1BUSU9OX0RFRkFVTFRTLFxyXG4gICAgICAgICAgICAgICAgdmlld1NwZWMub3B0aW9uRGVmYXVsdHMsXHJcbiAgICAgICAgICAgICAgICBsb2NhbGVEZWZhdWx0cyxcclxuICAgICAgICAgICAgICAgIG9wdGlvbk92ZXJyaWRlcyxcclxuICAgICAgICAgICAgICAgIHZpZXdTcGVjLm9wdGlvbk92ZXJyaWRlcyxcclxuICAgICAgICAgICAgICAgIGR5bmFtaWNPcHRpb25PdmVycmlkZXMsXHJcbiAgICAgICAgICAgIF0pO1xyXG4gICAgICAgICAgICBsZXQgcmVmaW5lcnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgQkFTRV9PUFRJT05fUkVGSU5FUlMpLCBDQUxFTkRBUl9MSVNURU5FUl9SRUZJTkVSUyksIENBTEVOREFSX09QVElPTl9SRUZJTkVSUyksIFZJRVdfT1BUSU9OX1JFRklORVJTKSwgcGx1Z2luSG9va3MubGlzdGVuZXJSZWZpbmVycyksIHBsdWdpbkhvb2tzLm9wdGlvblJlZmluZXJzKTtcclxuICAgICAgICAgICAgbGV0IHJlZmluZWQgPSB7fTtcclxuICAgICAgICAgICAgbGV0IGN1cnJlbnRSYXcgPSB0aGlzLmN1cnJlbnRWaWV3T3B0aW9uc0lucHV0O1xyXG4gICAgICAgICAgICBsZXQgY3VycmVudFJlZmluZWQgPSB0aGlzLmN1cnJlbnRWaWV3T3B0aW9uc1JlZmluZWQ7XHJcbiAgICAgICAgICAgIGxldCBhbnlDaGFuZ2VzID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGxldCBleHRyYSA9IHt9O1xyXG4gICAgICAgICAgICBmb3IgKGxldCBvcHRpb25OYW1lIGluIHJhdykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHJhd1tvcHRpb25OYW1lXSA9PT0gY3VycmVudFJhd1tvcHRpb25OYW1lXSB8fFxyXG4gICAgICAgICAgICAgICAgICAgIChDT01QTEVYX09QVElPTl9DT01QQVJBVE9SU1tvcHRpb25OYW1lXSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBDT01QTEVYX09QVElPTl9DT01QQVJBVE9SU1tvcHRpb25OYW1lXShyYXdbb3B0aW9uTmFtZV0sIGN1cnJlbnRSYXdbb3B0aW9uTmFtZV0pKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlZmluZWRbb3B0aW9uTmFtZV0gPSBjdXJyZW50UmVmaW5lZFtvcHRpb25OYW1lXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyYXdbb3B0aW9uTmFtZV0gPT09IHRoaXMuY3VycmVudENhbGVuZGFyT3B0aW9uc0lucHV0W29wdGlvbk5hbWVdIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChDT01QTEVYX09QVElPTl9DT01QQVJBVE9SU1tvcHRpb25OYW1lXSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQ09NUExFWF9PUFRJT05fQ09NUEFSQVRPUlNbb3B0aW9uTmFtZV0ocmF3W29wdGlvbk5hbWVdLCB0aGlzLmN1cnJlbnRDYWxlbmRhck9wdGlvbnNJbnB1dFtvcHRpb25OYW1lXSkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25OYW1lIGluIHRoaXMuY3VycmVudENhbGVuZGFyT3B0aW9uc1JlZmluZWQpIHsgLy8gbWlnaHQgYmUgYW4gXCJleHRyYVwiIHByb3BcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZmluZWRbb3B0aW9uTmFtZV0gPSB0aGlzLmN1cnJlbnRDYWxlbmRhck9wdGlvbnNSZWZpbmVkW29wdGlvbk5hbWVdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlZmluZXJzW29wdGlvbk5hbWVdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZmluZWRbb3B0aW9uTmFtZV0gPSByZWZpbmVyc1tvcHRpb25OYW1lXShyYXdbb3B0aW9uTmFtZV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmFbb3B0aW9uTmFtZV0gPSByYXdbb3B0aW9uTmFtZV07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGFueUNoYW5nZXMgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChhbnlDaGFuZ2VzKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRWaWV3T3B0aW9uc0lucHV0ID0gcmF3O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50Vmlld09wdGlvbnNSZWZpbmVkID0gcmVmaW5lZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgcmF3T3B0aW9uczogdGhpcy5jdXJyZW50Vmlld09wdGlvbnNJbnB1dCxcclxuICAgICAgICAgICAgICAgIHJlZmluZWRPcHRpb25zOiB0aGlzLmN1cnJlbnRWaWV3T3B0aW9uc1JlZmluZWQsXHJcbiAgICAgICAgICAgICAgICBleHRyYSxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBidWlsZERhdGVFbnYkMSh0aW1lWm9uZSwgZXhwbGljaXRMb2NhbGUsIHdlZWtOdW1iZXJDYWxjdWxhdGlvbiwgZmlyc3REYXksIHdlZWtUZXh0LCBwbHVnaW5Ib29rcywgYXZhaWxhYmxlTG9jYWxlRGF0YSwgZGVmYXVsdFNlcGFyYXRvcikge1xyXG4gICAgICAgIGxldCBsb2NhbGUgPSBidWlsZExvY2FsZShleHBsaWNpdExvY2FsZSB8fCBhdmFpbGFibGVMb2NhbGVEYXRhLmRlZmF1bHRDb2RlLCBhdmFpbGFibGVMb2NhbGVEYXRhLm1hcCk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlRW52KHtcclxuICAgICAgICAgICAgY2FsZW5kYXJTeXN0ZW06ICdncmVnb3J5JyxcclxuICAgICAgICAgICAgdGltZVpvbmUsXHJcbiAgICAgICAgICAgIG5hbWVkVGltZVpvbmVJbXBsOiBwbHVnaW5Ib29rcy5uYW1lZFRpbWVab25lZEltcGwsXHJcbiAgICAgICAgICAgIGxvY2FsZSxcclxuICAgICAgICAgICAgd2Vla051bWJlckNhbGN1bGF0aW9uLFxyXG4gICAgICAgICAgICBmaXJzdERheSxcclxuICAgICAgICAgICAgd2Vla1RleHQsXHJcbiAgICAgICAgICAgIGNtZEZvcm1hdHRlcjogcGx1Z2luSG9va3MuY21kRm9ybWF0dGVyLFxyXG4gICAgICAgICAgICBkZWZhdWx0U2VwYXJhdG9yLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYnVpbGRUaGVtZShvcHRpb25zLCBwbHVnaW5Ib29rcykge1xyXG4gICAgICAgIGxldCBUaGVtZUNsYXNzID0gcGx1Z2luSG9va3MudGhlbWVDbGFzc2VzW29wdGlvbnMudGhlbWVTeXN0ZW1dIHx8IFN0YW5kYXJkVGhlbWU7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBUaGVtZUNsYXNzKG9wdGlvbnMpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYnVpbGREYXRlUHJvZmlsZUdlbmVyYXRvcihwcm9wcykge1xyXG4gICAgICAgIGxldCBEYXRlUHJvZmlsZUdlbmVyYXRvckNsYXNzID0gcHJvcHMuZGF0ZVByb2ZpbGVHZW5lcmF0b3JDbGFzcyB8fCBEYXRlUHJvZmlsZUdlbmVyYXRvcjtcclxuICAgICAgICByZXR1cm4gbmV3IERhdGVQcm9maWxlR2VuZXJhdG9yQ2xhc3MocHJvcHMpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYnVpbGRWaWV3QXBpKHR5cGUsIGdldEN1cnJlbnREYXRhLCBkYXRlRW52KSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBWaWV3SW1wbCh0eXBlLCBnZXRDdXJyZW50RGF0YSwgZGF0ZUVudik7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBidWlsZEV2ZW50VWlCeVNvdXJjZShldmVudFNvdXJjZXMpIHtcclxuICAgICAgICByZXR1cm4gbWFwSGFzaChldmVudFNvdXJjZXMsIChldmVudFNvdXJjZSkgPT4gZXZlbnRTb3VyY2UudWkpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYnVpbGRFdmVudFVpQmFzZXMoZXZlbnREZWZzLCBldmVudFVpU2luZ2xlQmFzZSwgZXZlbnRVaUJ5U291cmNlKSB7XHJcbiAgICAgICAgbGV0IGV2ZW50VWlCYXNlcyA9IHsgJyc6IGV2ZW50VWlTaW5nbGVCYXNlIH07XHJcbiAgICAgICAgZm9yIChsZXQgZGVmSWQgaW4gZXZlbnREZWZzKSB7XHJcbiAgICAgICAgICAgIGxldCBkZWYgPSBldmVudERlZnNbZGVmSWRdO1xyXG4gICAgICAgICAgICBpZiAoZGVmLnNvdXJjZUlkICYmIGV2ZW50VWlCeVNvdXJjZVtkZWYuc291cmNlSWRdKSB7XHJcbiAgICAgICAgICAgICAgICBldmVudFVpQmFzZXNbZGVmSWRdID0gZXZlbnRVaUJ5U291cmNlW2RlZi5zb3VyY2VJZF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGV2ZW50VWlCYXNlcztcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGJ1aWxkVmlld1VpUHJvcHMoY2FsZW5kYXJDb250ZXh0KSB7XHJcbiAgICAgICAgbGV0IHsgb3B0aW9ucyB9ID0gY2FsZW5kYXJDb250ZXh0O1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGV2ZW50VWlTaW5nbGVCYXNlOiBjcmVhdGVFdmVudFVpKHtcclxuICAgICAgICAgICAgICAgIGRpc3BsYXk6IG9wdGlvbnMuZXZlbnREaXNwbGF5LFxyXG4gICAgICAgICAgICAgICAgZWRpdGFibGU6IG9wdGlvbnMuZWRpdGFibGUsXHJcbiAgICAgICAgICAgICAgICBzdGFydEVkaXRhYmxlOiBvcHRpb25zLmV2ZW50U3RhcnRFZGl0YWJsZSxcclxuICAgICAgICAgICAgICAgIGR1cmF0aW9uRWRpdGFibGU6IG9wdGlvbnMuZXZlbnREdXJhdGlvbkVkaXRhYmxlLFxyXG4gICAgICAgICAgICAgICAgY29uc3RyYWludDogb3B0aW9ucy5ldmVudENvbnN0cmFpbnQsXHJcbiAgICAgICAgICAgICAgICBvdmVybGFwOiB0eXBlb2Ygb3B0aW9ucy5ldmVudE92ZXJsYXAgPT09ICdib29sZWFuJyA/IG9wdGlvbnMuZXZlbnRPdmVybGFwIDogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAgICAgYWxsb3c6IG9wdGlvbnMuZXZlbnRBbGxvdyxcclxuICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogb3B0aW9ucy5ldmVudEJhY2tncm91bmRDb2xvcixcclxuICAgICAgICAgICAgICAgIGJvcmRlckNvbG9yOiBvcHRpb25zLmV2ZW50Qm9yZGVyQ29sb3IsXHJcbiAgICAgICAgICAgICAgICB0ZXh0Q29sb3I6IG9wdGlvbnMuZXZlbnRUZXh0Q29sb3IsXHJcbiAgICAgICAgICAgICAgICBjb2xvcjogb3B0aW9ucy5ldmVudENvbG9yLFxyXG4gICAgICAgICAgICAgICAgLy8gY2xhc3NOYW1lczogb3B0aW9ucy5ldmVudENsYXNzTmFtZXMgLy8gcmVuZGVyIGhvb2sgd2lsbCBoYW5kbGUgdGhpc1xyXG4gICAgICAgICAgICB9LCBjYWxlbmRhckNvbnRleHQpLFxyXG4gICAgICAgICAgICBzZWxlY3Rpb25Db25maWc6IGNyZWF0ZUV2ZW50VWkoe1xyXG4gICAgICAgICAgICAgICAgY29uc3RyYWludDogb3B0aW9ucy5zZWxlY3RDb25zdHJhaW50LFxyXG4gICAgICAgICAgICAgICAgb3ZlcmxhcDogdHlwZW9mIG9wdGlvbnMuc2VsZWN0T3ZlcmxhcCA9PT0gJ2Jvb2xlYW4nID8gb3B0aW9ucy5zZWxlY3RPdmVybGFwIDogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAgICAgYWxsb3c6IG9wdGlvbnMuc2VsZWN0QWxsb3csXHJcbiAgICAgICAgICAgIH0sIGNhbGVuZGFyQ29udGV4dCksXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGNvbXB1dGVJc0xvYWRpbmcoc3RhdGUsIGNvbnRleHQpIHtcclxuICAgICAgICBmb3IgKGxldCBpc0xvYWRpbmdGdW5jIG9mIGNvbnRleHQucGx1Z2luSG9va3MuaXNMb2FkaW5nRnVuY3MpIHtcclxuICAgICAgICAgICAgaWYgKGlzTG9hZGluZ0Z1bmMoc3RhdGUpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBwYXJzZUNvbnRleHRCdXNpbmVzc0hvdXJzKGNhbGVuZGFyQ29udGV4dCkge1xyXG4gICAgICAgIHJldHVybiBwYXJzZUJ1c2luZXNzSG91cnMoY2FsZW5kYXJDb250ZXh0Lm9wdGlvbnMuYnVzaW5lc3NIb3VycywgY2FsZW5kYXJDb250ZXh0KTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHdhcm5Vbmtub3duT3B0aW9ucyhvcHRpb25zLCB2aWV3TmFtZSkge1xyXG4gICAgICAgIGZvciAobGV0IG9wdGlvbk5hbWUgaW4gb3B0aW9ucykge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYFVua25vd24gb3B0aW9uICcke29wdGlvbk5hbWV9J2AgK1xyXG4gICAgICAgICAgICAgICAgKHZpZXdOYW1lID8gYCBmb3IgdmlldyAnJHt2aWV3TmFtZX0nYCA6ICcnKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNsYXNzIFRvb2xiYXJTZWN0aW9uIGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XHJcbiAgICAgICAgcmVuZGVyKCkge1xyXG4gICAgICAgICAgICBsZXQgY2hpbGRyZW4gPSB0aGlzLnByb3BzLndpZGdldEdyb3Vwcy5tYXAoKHdpZGdldEdyb3VwKSA9PiB0aGlzLnJlbmRlcldpZGdldEdyb3VwKHdpZGdldEdyb3VwKSk7XHJcbiAgICAgICAgICAgIHJldHVybiB5KCdkaXYnLCB7IGNsYXNzTmFtZTogJ2ZjLXRvb2xiYXItY2h1bmsnIH0sIC4uLmNoaWxkcmVuKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVuZGVyV2lkZ2V0R3JvdXAod2lkZ2V0R3JvdXApIHtcclxuICAgICAgICAgICAgbGV0IHsgcHJvcHMgfSA9IHRoaXM7XHJcbiAgICAgICAgICAgIGxldCB7IHRoZW1lIH0gPSB0aGlzLmNvbnRleHQ7XHJcbiAgICAgICAgICAgIGxldCBjaGlsZHJlbiA9IFtdO1xyXG4gICAgICAgICAgICBsZXQgaXNPbmx5QnV0dG9ucyA9IHRydWU7XHJcbiAgICAgICAgICAgIGZvciAobGV0IHdpZGdldCBvZiB3aWRnZXRHcm91cCkge1xyXG4gICAgICAgICAgICAgICAgbGV0IHsgYnV0dG9uTmFtZSwgYnV0dG9uQ2xpY2ssIGJ1dHRvblRleHQsIGJ1dHRvbkljb24sIGJ1dHRvbkhpbnQgfSA9IHdpZGdldDtcclxuICAgICAgICAgICAgICAgIGlmIChidXR0b25OYW1lID09PSAndGl0bGUnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaXNPbmx5QnV0dG9ucyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuLnB1c2goeShcImgyXCIsIHsgY2xhc3NOYW1lOiBcImZjLXRvb2xiYXItdGl0bGVcIiwgaWQ6IHByb3BzLnRpdGxlSWQgfSwgcHJvcHMudGl0bGUpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBpc1ByZXNzZWQgPSBidXR0b25OYW1lID09PSBwcm9wcy5hY3RpdmVCdXR0b247XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGlzRGlzYWJsZWQgPSAoIXByb3BzLmlzVG9kYXlFbmFibGVkICYmIGJ1dHRvbk5hbWUgPT09ICd0b2RheScpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICghcHJvcHMuaXNQcmV2RW5hYmxlZCAmJiBidXR0b25OYW1lID09PSAncHJldicpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICghcHJvcHMuaXNOZXh0RW5hYmxlZCAmJiBidXR0b25OYW1lID09PSAnbmV4dCcpO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBidXR0b25DbGFzc2VzID0gW2BmYy0ke2J1dHRvbk5hbWV9LWJ1dHRvbmAsIHRoZW1lLmdldENsYXNzKCdidXR0b24nKV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzUHJlc3NlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBidXR0b25DbGFzc2VzLnB1c2godGhlbWUuZ2V0Q2xhc3MoJ2J1dHRvbkFjdGl2ZScpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW4ucHVzaCh5KFwiYnV0dG9uXCIsIHsgdHlwZTogXCJidXR0b25cIiwgdGl0bGU6IHR5cGVvZiBidXR0b25IaW50ID09PSAnZnVuY3Rpb24nID8gYnV0dG9uSGludChwcm9wcy5uYXZVbml0KSA6IGJ1dHRvbkhpbnQsIGRpc2FibGVkOiBpc0Rpc2FibGVkLCBcImFyaWEtcHJlc3NlZFwiOiBpc1ByZXNzZWQsIGNsYXNzTmFtZTogYnV0dG9uQ2xhc3Nlcy5qb2luKCcgJyksIG9uQ2xpY2s6IGJ1dHRvbkNsaWNrIH0sIGJ1dHRvblRleHQgfHwgKGJ1dHRvbkljb24gPyB5KFwic3BhblwiLCB7IGNsYXNzTmFtZTogYnV0dG9uSWNvbiB9KSA6ICcnKSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgZ3JvdXBDbGFzc05hbWUgPSAoaXNPbmx5QnV0dG9ucyAmJiB0aGVtZS5nZXRDbGFzcygnYnV0dG9uR3JvdXAnKSkgfHwgJyc7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4geSgnZGl2JywgeyBjbGFzc05hbWU6IGdyb3VwQ2xhc3NOYW1lIH0sIC4uLmNoaWxkcmVuKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gY2hpbGRyZW5bMF07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNsYXNzIFRvb2xiYXIgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcclxuICAgICAgICByZW5kZXIoKSB7XHJcbiAgICAgICAgICAgIGxldCB7IG1vZGVsLCBleHRyYUNsYXNzTmFtZSB9ID0gdGhpcy5wcm9wcztcclxuICAgICAgICAgICAgbGV0IGZvcmNlTHRyID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGxldCBzdGFydENvbnRlbnQ7XHJcbiAgICAgICAgICAgIGxldCBlbmRDb250ZW50O1xyXG4gICAgICAgICAgICBsZXQgc2VjdGlvbldpZGdldHMgPSBtb2RlbC5zZWN0aW9uV2lkZ2V0cztcclxuICAgICAgICAgICAgbGV0IGNlbnRlckNvbnRlbnQgPSBzZWN0aW9uV2lkZ2V0cy5jZW50ZXI7XHJcbiAgICAgICAgICAgIGlmIChzZWN0aW9uV2lkZ2V0cy5sZWZ0KSB7XHJcbiAgICAgICAgICAgICAgICBmb3JjZUx0ciA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBzdGFydENvbnRlbnQgPSBzZWN0aW9uV2lkZ2V0cy5sZWZ0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc3RhcnRDb250ZW50ID0gc2VjdGlvbldpZGdldHMuc3RhcnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHNlY3Rpb25XaWRnZXRzLnJpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICBmb3JjZUx0ciA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBlbmRDb250ZW50ID0gc2VjdGlvbldpZGdldHMucmlnaHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBlbmRDb250ZW50ID0gc2VjdGlvbldpZGdldHMuZW5kO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxldCBjbGFzc05hbWVzID0gW1xyXG4gICAgICAgICAgICAgICAgZXh0cmFDbGFzc05hbWUgfHwgJycsXHJcbiAgICAgICAgICAgICAgICAnZmMtdG9vbGJhcicsXHJcbiAgICAgICAgICAgICAgICBmb3JjZUx0ciA/ICdmYy10b29sYmFyLWx0cicgOiAnJyxcclxuICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgcmV0dXJuICh5KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBjbGFzc05hbWVzLmpvaW4oJyAnKSB9LFxyXG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJTZWN0aW9uKCdzdGFydCcsIHN0YXJ0Q29udGVudCB8fCBbXSksXHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlclNlY3Rpb24oJ2NlbnRlcicsIGNlbnRlckNvbnRlbnQgfHwgW10pLFxyXG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJTZWN0aW9uKCdlbmQnLCBlbmRDb250ZW50IHx8IFtdKSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZW5kZXJTZWN0aW9uKGtleSwgd2lkZ2V0R3JvdXBzKSB7XHJcbiAgICAgICAgICAgIGxldCB7IHByb3BzIH0gPSB0aGlzO1xyXG4gICAgICAgICAgICByZXR1cm4gKHkoVG9vbGJhclNlY3Rpb24sIHsga2V5OiBrZXksIHdpZGdldEdyb3Vwczogd2lkZ2V0R3JvdXBzLCB0aXRsZTogcHJvcHMudGl0bGUsIG5hdlVuaXQ6IHByb3BzLm5hdlVuaXQsIGFjdGl2ZUJ1dHRvbjogcHJvcHMuYWN0aXZlQnV0dG9uLCBpc1RvZGF5RW5hYmxlZDogcHJvcHMuaXNUb2RheUVuYWJsZWQsIGlzUHJldkVuYWJsZWQ6IHByb3BzLmlzUHJldkVuYWJsZWQsIGlzTmV4dEVuYWJsZWQ6IHByb3BzLmlzTmV4dEVuYWJsZWQsIHRpdGxlSWQ6IHByb3BzLnRpdGxlSWQgfSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBjbGFzcyBWaWV3SGFybmVzcyBleHRlbmRzIEJhc2VDb21wb25lbnQge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0ge1xyXG4gICAgICAgICAgICAgICAgYXZhaWxhYmxlV2lkdGg6IG51bGwsXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlRWwgPSAoZWwpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZWwgPSBlbDtcclxuICAgICAgICAgICAgICAgIHNldFJlZih0aGlzLnByb3BzLmVsUmVmLCBlbCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUF2YWlsYWJsZVdpZHRoKCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlUmVzaXplID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVBdmFpbGFibGVXaWR0aCgpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZW5kZXIoKSB7XHJcbiAgICAgICAgICAgIGxldCB7IHByb3BzLCBzdGF0ZSB9ID0gdGhpcztcclxuICAgICAgICAgICAgbGV0IHsgYXNwZWN0UmF0aW8gfSA9IHByb3BzO1xyXG4gICAgICAgICAgICBsZXQgY2xhc3NOYW1lcyA9IFtcclxuICAgICAgICAgICAgICAgICdmYy12aWV3LWhhcm5lc3MnLFxyXG4gICAgICAgICAgICAgICAgKGFzcGVjdFJhdGlvIHx8IHByb3BzLmxpcXVpZCB8fCBwcm9wcy5oZWlnaHQpXHJcbiAgICAgICAgICAgICAgICAgICAgPyAnZmMtdmlldy1oYXJuZXNzLWFjdGl2ZScgLy8gaGFybmVzcyBjb250cm9scyB0aGUgaGVpZ2h0XHJcbiAgICAgICAgICAgICAgICAgICAgOiAnZmMtdmlldy1oYXJuZXNzLXBhc3NpdmUnLCAvLyBsZXQgdGhlIHZpZXcgZG8gdGhlIGhlaWdodFxyXG4gICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICBsZXQgaGVpZ2h0ID0gJyc7XHJcbiAgICAgICAgICAgIGxldCBwYWRkaW5nQm90dG9tID0gJyc7XHJcbiAgICAgICAgICAgIGlmIChhc3BlY3RSYXRpbykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlLmF2YWlsYWJsZVdpZHRoICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0ID0gc3RhdGUuYXZhaWxhYmxlV2lkdGggLyBhc3BlY3RSYXRpbztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHdoaWxlIHdhaXRpbmcgdG8ga25vdyBhdmFpbGFibGVXaWR0aCwgd2UgY2FuJ3Qgc2V0IGhlaWdodCB0byAqemVybypcclxuICAgICAgICAgICAgICAgICAgICAvLyBiZWNhdXNlIHdpbGwgY2F1c2UgbG90cyBvZiB1bm5lY2Vzc2FyeSBzY3JvbGxiYXJzIHdpdGhpbiBzY3JvbGxncmlkLlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEJFVFRFUjogZG9uJ3Qgc3RhcnQgcmVuZGVyaW5nIEFOWVRISU5HIHlldCB1bnRpbCB3ZSBrbm93IGNvbnRhaW5lciB3aWR0aFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIE5PVEU6IHdoeSBub3QgYWx3YXlzIHVzZSBwYWRkaW5nQm90dG9tPyBDYXVzZXMgaGVpZ2h0IG9zY2lsbGF0aW9uIChpc3N1ZSA1NjA2KVxyXG4gICAgICAgICAgICAgICAgICAgIHBhZGRpbmdCb3R0b20gPSBgJHsoMSAvIGFzcGVjdFJhdGlvKSAqIDEwMH0lYDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGhlaWdodCA9IHByb3BzLmhlaWdodCB8fCAnJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gKHkoXCJkaXZcIiwgeyBcImFyaWEtbGFiZWxsZWRieVwiOiBwcm9wcy5sYWJlbGVkQnlJZCwgcmVmOiB0aGlzLmhhbmRsZUVsLCBjbGFzc05hbWU6IGNsYXNzTmFtZXMuam9pbignICcpLCBzdHlsZTogeyBoZWlnaHQsIHBhZGRpbmdCb3R0b20gfSB9LCBwcm9wcy5jaGlsZHJlbikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb21wb25lbnREaWRNb3VudCgpIHtcclxuICAgICAgICAgICAgdGhpcy5jb250ZXh0LmFkZFJlc2l6ZUhhbmRsZXIodGhpcy5oYW5kbGVSZXNpemUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcclxuICAgICAgICAgICAgdGhpcy5jb250ZXh0LnJlbW92ZVJlc2l6ZUhhbmRsZXIodGhpcy5oYW5kbGVSZXNpemUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB1cGRhdGVBdmFpbGFibGVXaWR0aCgpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuZWwgJiYgLy8gbmVlZGVkLiBidXQgd2h5P1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5hc3BlY3RSYXRpbyAvLyBhc3BlY3RSYXRpbyBpcyB0aGUgb25seSBoZWlnaHQgc2V0dGluZyB0aGF0IG5lZWRzIGF2YWlsYWJsZVdpZHRoXHJcbiAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IGF2YWlsYWJsZVdpZHRoOiB0aGlzLmVsLm9mZnNldFdpZHRoIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qXHJcbiAgICBEZXRlY3RzIHdoZW4gdGhlIHVzZXIgY2xpY2tzIG9uIGFuIGV2ZW50IHdpdGhpbiBhIERhdGVDb21wb25lbnRcclxuICAgICovXHJcbiAgICBjbGFzcyBFdmVudENsaWNraW5nIGV4dGVuZHMgSW50ZXJhY3Rpb24ge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yKHNldHRpbmdzKSB7XHJcbiAgICAgICAgICAgIHN1cGVyKHNldHRpbmdzKTtcclxuICAgICAgICAgICAgdGhpcy5oYW5kbGVTZWdDbGljayA9IChldiwgc2VnRWwpID0+IHtcclxuICAgICAgICAgICAgICAgIGxldCB7IGNvbXBvbmVudCB9ID0gdGhpcztcclxuICAgICAgICAgICAgICAgIGxldCB7IGNvbnRleHQgfSA9IGNvbXBvbmVudDtcclxuICAgICAgICAgICAgICAgIGxldCBzZWcgPSBnZXRFbFNlZyhzZWdFbCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2VnICYmIC8vIG1pZ2h0IGJlIHRoZSA8ZGl2PiBzdXJyb3VuZGluZyB0aGUgbW9yZSBsaW5rXHJcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50LmlzVmFsaWRTZWdEb3duRWwoZXYudGFyZ2V0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIG91ciB3YXkgdG8gc2ltdWxhdGUgYSBsaW5rIGNsaWNrIGZvciBlbGVtZW50cyB0aGF0IGNhbid0IGJlIDxhPiB0YWdzXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZ3JhYiBiZWZvcmUgdHJpZ2dlciBmaXJlZCBpbiBjYXNlIHRyaWdnZXIgdHJhc2hlcyBET00gdGhydSByZXJlbmRlcmluZ1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBoYXNVcmxDb250YWluZXIgPSBlbGVtZW50Q2xvc2VzdChldi50YXJnZXQsICcuZmMtZXZlbnQtZm9yY2VkLXVybCcpO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCB1cmwgPSBoYXNVcmxDb250YWluZXIgPyBoYXNVcmxDb250YWluZXIucXVlcnlTZWxlY3RvcignYVtocmVmXScpLmhyZWYgOiAnJztcclxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmVtaXR0ZXIudHJpZ2dlcignZXZlbnRDbGljaycsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWw6IHNlZ0VsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudDogbmV3IEV2ZW50SW1wbChjb21wb25lbnQuY29udGV4dCwgc2VnLmV2ZW50UmFuZ2UuZGVmLCBzZWcuZXZlbnRSYW5nZS5pbnN0YW5jZSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGpzRXZlbnQ6IGV2LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2aWV3OiBjb250ZXh0LnZpZXdBcGksXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHVybCAmJiAhZXYuZGVmYXVsdFByZXZlbnRlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IHVybDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHRoaXMuZGVzdHJveSA9IGxpc3RlbkJ5U2VsZWN0b3Ioc2V0dGluZ3MuZWwsICdjbGljaycsICcuZmMtZXZlbnQnLCAvLyBvbiBib3RoIGZnIGFuZCBiZyBldmVudHNcclxuICAgICAgICAgICAgdGhpcy5oYW5kbGVTZWdDbGljayk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qXHJcbiAgICBUcmlnZ2VycyBldmVudHMgYW5kIGFkZHMvcmVtb3ZlcyBjb3JlIGNsYXNzTmFtZXMgd2hlbiB0aGUgdXNlcidzIHBvaW50ZXJcclxuICAgIGVudGVycy9sZWF2ZXMgZXZlbnQtZWxlbWVudHMgb2YgYSBjb21wb25lbnQuXHJcbiAgICAqL1xyXG4gICAgY2xhc3MgRXZlbnRIb3ZlcmluZyBleHRlbmRzIEludGVyYWN0aW9uIHtcclxuICAgICAgICBjb25zdHJ1Y3RvcihzZXR0aW5ncykge1xyXG4gICAgICAgICAgICBzdXBlcihzZXR0aW5ncyk7XHJcbiAgICAgICAgICAgIC8vIGZvciBzaW11bGF0aW5nIGFuIGV2ZW50TW91c2VMZWF2ZSB3aGVuIHRoZSBldmVudCBlbCBpcyBkZXN0cm95ZWQgd2hpbGUgbW91c2UgaXMgb3ZlciBpdFxyXG4gICAgICAgICAgICB0aGlzLmhhbmRsZUV2ZW50RWxSZW1vdmUgPSAoZWwpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChlbCA9PT0gdGhpcy5jdXJyZW50U2VnRWwpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVNlZ0xlYXZlKG51bGwsIHRoaXMuY3VycmVudFNlZ0VsKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdGhpcy5oYW5kbGVTZWdFbnRlciA9IChldiwgc2VnRWwpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChnZXRFbFNlZyhzZWdFbCkpIHsgLy8gVE9ETzogYmV0dGVyIHdheSB0byBtYWtlIHN1cmUgbm90IGhvdmVyaW5nIG92ZXIgbW9yZSsgbGluayBvciBpdHMgd3JhcHBlclxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFNlZ0VsID0gc2VnRWw7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyRXZlbnQoJ2V2ZW50TW91c2VFbnRlcicsIGV2LCBzZWdFbCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlU2VnTGVhdmUgPSAoZXYsIHNlZ0VsKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50U2VnRWwpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRTZWdFbCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyRXZlbnQoJ2V2ZW50TW91c2VMZWF2ZScsIGV2LCBzZWdFbCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlSG92ZXJMaXN0ZW5lcnMgPSBsaXN0ZW5Ub0hvdmVyQnlTZWxlY3RvcihzZXR0aW5ncy5lbCwgJy5mYy1ldmVudCcsIC8vIG9uIGJvdGggZmcgYW5kIGJnIGV2ZW50c1xyXG4gICAgICAgICAgICB0aGlzLmhhbmRsZVNlZ0VudGVyLCB0aGlzLmhhbmRsZVNlZ0xlYXZlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZGVzdHJveSgpIHtcclxuICAgICAgICAgICAgdGhpcy5yZW1vdmVIb3Zlckxpc3RlbmVycygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0cmlnZ2VyRXZlbnQocHVibGljRXZOYW1lLCBldiwgc2VnRWwpIHtcclxuICAgICAgICAgICAgbGV0IHsgY29tcG9uZW50IH0gPSB0aGlzO1xyXG4gICAgICAgICAgICBsZXQgeyBjb250ZXh0IH0gPSBjb21wb25lbnQ7XHJcbiAgICAgICAgICAgIGxldCBzZWcgPSBnZXRFbFNlZyhzZWdFbCk7XHJcbiAgICAgICAgICAgIGlmICghZXYgfHwgY29tcG9uZW50LmlzVmFsaWRTZWdEb3duRWwoZXYudGFyZ2V0KSkge1xyXG4gICAgICAgICAgICAgICAgY29udGV4dC5lbWl0dGVyLnRyaWdnZXIocHVibGljRXZOYW1lLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgZWw6IHNlZ0VsLFxyXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50OiBuZXcgRXZlbnRJbXBsKGNvbnRleHQsIHNlZy5ldmVudFJhbmdlLmRlZiwgc2VnLmV2ZW50UmFuZ2UuaW5zdGFuY2UpLFxyXG4gICAgICAgICAgICAgICAgICAgIGpzRXZlbnQ6IGV2LFxyXG4gICAgICAgICAgICAgICAgICAgIHZpZXc6IGNvbnRleHQudmlld0FwaSxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNsYXNzIENhbGVuZGFyQ29udGVudCBleHRlbmRzIFB1cmVDb21wb25lbnQge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgICAgICB0aGlzLmJ1aWxkVmlld0NvbnRleHQgPSBtZW1vaXplKGJ1aWxkVmlld0NvbnRleHQpO1xyXG4gICAgICAgICAgICB0aGlzLmJ1aWxkVmlld1Byb3BUcmFuc2Zvcm1lcnMgPSBtZW1vaXplKGJ1aWxkVmlld1Byb3BUcmFuc2Zvcm1lcnMpO1xyXG4gICAgICAgICAgICB0aGlzLmJ1aWxkVG9vbGJhclByb3BzID0gbWVtb2l6ZShidWlsZFRvb2xiYXJQcm9wcyk7XHJcbiAgICAgICAgICAgIHRoaXMuaGVhZGVyUmVmID0gZCgpO1xyXG4gICAgICAgICAgICB0aGlzLmZvb3RlclJlZiA9IGQoKTtcclxuICAgICAgICAgICAgdGhpcy5pbnRlcmFjdGlvbnNTdG9yZSA9IHt9O1xyXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IHtcclxuICAgICAgICAgICAgICAgIHZpZXdMYWJlbElkOiBnZXRVbmlxdWVEb21JZCgpLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvLyBDb21wb25lbnQgUmVnaXN0cmF0aW9uXHJcbiAgICAgICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAgICAgICAgIHRoaXMucmVnaXN0ZXJJbnRlcmFjdGl2ZUNvbXBvbmVudCA9IChjb21wb25lbnQsIHNldHRpbmdzSW5wdXQpID0+IHtcclxuICAgICAgICAgICAgICAgIGxldCBzZXR0aW5ncyA9IHBhcnNlSW50ZXJhY3Rpb25TZXR0aW5ncyhjb21wb25lbnQsIHNldHRpbmdzSW5wdXQpO1xyXG4gICAgICAgICAgICAgICAgbGV0IERFRkFVTFRfSU5URVJBQ1RJT05TID0gW1xyXG4gICAgICAgICAgICAgICAgICAgIEV2ZW50Q2xpY2tpbmcsXHJcbiAgICAgICAgICAgICAgICAgICAgRXZlbnRIb3ZlcmluZyxcclxuICAgICAgICAgICAgICAgIF07XHJcbiAgICAgICAgICAgICAgICBsZXQgaW50ZXJhY3Rpb25DbGFzc2VzID0gREVGQVVMVF9JTlRFUkFDVElPTlMuY29uY2F0KHRoaXMucHJvcHMucGx1Z2luSG9va3MuY29tcG9uZW50SW50ZXJhY3Rpb25zKTtcclxuICAgICAgICAgICAgICAgIGxldCBpbnRlcmFjdGlvbnMgPSBpbnRlcmFjdGlvbkNsYXNzZXMubWFwKChUaGVJbnRlcmFjdGlvbkNsYXNzKSA9PiBuZXcgVGhlSW50ZXJhY3Rpb25DbGFzcyhzZXR0aW5ncykpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbnRlcmFjdGlvbnNTdG9yZVtjb21wb25lbnQudWlkXSA9IGludGVyYWN0aW9ucztcclxuICAgICAgICAgICAgICAgIGludGVyYWN0aW9uU2V0dGluZ3NTdG9yZVtjb21wb25lbnQudWlkXSA9IHNldHRpbmdzO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB0aGlzLnVucmVnaXN0ZXJJbnRlcmFjdGl2ZUNvbXBvbmVudCA9IChjb21wb25lbnQpID0+IHtcclxuICAgICAgICAgICAgICAgIGxldCBsaXN0ZW5lcnMgPSB0aGlzLmludGVyYWN0aW9uc1N0b3JlW2NvbXBvbmVudC51aWRdO1xyXG4gICAgICAgICAgICAgICAgaWYgKGxpc3RlbmVycykge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGxpc3RlbmVyIG9mIGxpc3RlbmVycykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lci5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmludGVyYWN0aW9uc1N0b3JlW2NvbXBvbmVudC51aWRdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZGVsZXRlIGludGVyYWN0aW9uU2V0dGluZ3NTdG9yZVtjb21wb25lbnQudWlkXTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLy8gUmVzaXppbmdcclxuICAgICAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgICAgICAgICAgdGhpcy5yZXNpemVSdW5uZXIgPSBuZXcgRGVsYXllZFJ1bm5lcigoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BzLmVtaXR0ZXIudHJpZ2dlcignX3Jlc2l6ZScsIHRydWUpOyAvLyBzaG91bGQgd2luZG93IHJlc2l6ZXMgYmUgY29uc2lkZXJlZCBcImZvcmNlZFwiID9cclxuICAgICAgICAgICAgICAgIHRoaXMucHJvcHMuZW1pdHRlci50cmlnZ2VyKCd3aW5kb3dSZXNpemUnLCB7IHZpZXc6IHRoaXMucHJvcHMudmlld0FwaSB9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlV2luZG93UmVzaXplID0gKGV2KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBsZXQgeyBvcHRpb25zIH0gPSB0aGlzLnByb3BzO1xyXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuaGFuZGxlV2luZG93UmVzaXplICYmXHJcbiAgICAgICAgICAgICAgICAgICAgZXYudGFyZ2V0ID09PSB3aW5kb3cgLy8gYXZvaWQganF1aSBldmVudHNcclxuICAgICAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVzaXplUnVubmVyLnJlcXVlc3Qob3B0aW9ucy53aW5kb3dSZXNpemVEZWxheSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgcmVuZGVycyBJTlNJREUgb2YgYW4gb3V0ZXIgZGl2XHJcbiAgICAgICAgKi9cclxuICAgICAgICByZW5kZXIoKSB7XHJcbiAgICAgICAgICAgIGxldCB7IHByb3BzIH0gPSB0aGlzO1xyXG4gICAgICAgICAgICBsZXQgeyB0b29sYmFyQ29uZmlnLCBvcHRpb25zIH0gPSBwcm9wcztcclxuICAgICAgICAgICAgbGV0IHRvb2xiYXJQcm9wcyA9IHRoaXMuYnVpbGRUb29sYmFyUHJvcHMocHJvcHMudmlld1NwZWMsIHByb3BzLmRhdGVQcm9maWxlLCBwcm9wcy5kYXRlUHJvZmlsZUdlbmVyYXRvciwgcHJvcHMuY3VycmVudERhdGUsIGdldE5vdyhwcm9wcy5vcHRpb25zLm5vdywgcHJvcHMuZGF0ZUVudiksIC8vIFRPRE86IHVzZSBOb3dUaW1lcj8/Pz9cclxuICAgICAgICAgICAgcHJvcHMudmlld1RpdGxlKTtcclxuICAgICAgICAgICAgbGV0IHZpZXdWR3JvdyA9IGZhbHNlO1xyXG4gICAgICAgICAgICBsZXQgdmlld0hlaWdodCA9ICcnO1xyXG4gICAgICAgICAgICBsZXQgdmlld0FzcGVjdFJhdGlvO1xyXG4gICAgICAgICAgICBpZiAocHJvcHMuaXNIZWlnaHRBdXRvIHx8IHByb3BzLmZvclByaW50KSB7XHJcbiAgICAgICAgICAgICAgICB2aWV3SGVpZ2h0ID0gJyc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAob3B0aW9ucy5oZWlnaHQgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgdmlld1ZHcm93ID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChvcHRpb25zLmNvbnRlbnRIZWlnaHQgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgdmlld0hlaWdodCA9IG9wdGlvbnMuY29udGVudEhlaWdodDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZpZXdBc3BlY3RSYXRpbyA9IE1hdGgubWF4KG9wdGlvbnMuYXNwZWN0UmF0aW8sIDAuNSk7IC8vIHByZXZlbnQgZnJvbSBnZXR0aW5nIHRvbyB0YWxsXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IHZpZXdDb250ZXh0ID0gdGhpcy5idWlsZFZpZXdDb250ZXh0KHByb3BzLnZpZXdTcGVjLCBwcm9wcy52aWV3QXBpLCBwcm9wcy5vcHRpb25zLCBwcm9wcy5kYXRlUHJvZmlsZUdlbmVyYXRvciwgcHJvcHMuZGF0ZUVudiwgcHJvcHMudGhlbWUsIHByb3BzLnBsdWdpbkhvb2tzLCBwcm9wcy5kaXNwYXRjaCwgcHJvcHMuZ2V0Q3VycmVudERhdGEsIHByb3BzLmVtaXR0ZXIsIHByb3BzLmNhbGVuZGFyQXBpLCB0aGlzLnJlZ2lzdGVySW50ZXJhY3RpdmVDb21wb25lbnQsIHRoaXMudW5yZWdpc3RlckludGVyYWN0aXZlQ29tcG9uZW50KTtcclxuICAgICAgICAgICAgbGV0IHZpZXdMYWJlbElkID0gKHRvb2xiYXJDb25maWcuaGVhZGVyICYmIHRvb2xiYXJDb25maWcuaGVhZGVyLmhhc1RpdGxlKVxyXG4gICAgICAgICAgICAgICAgPyB0aGlzLnN0YXRlLnZpZXdMYWJlbElkXHJcbiAgICAgICAgICAgICAgICA6ICcnO1xyXG4gICAgICAgICAgICByZXR1cm4gKHkoVmlld0NvbnRleHRUeXBlLlByb3ZpZGVyLCB7IHZhbHVlOiB2aWV3Q29udGV4dCB9LFxyXG4gICAgICAgICAgICAgICAgdG9vbGJhckNvbmZpZy5oZWFkZXIgJiYgKHkoVG9vbGJhciwgT2JqZWN0LmFzc2lnbih7IHJlZjogdGhpcy5oZWFkZXJSZWYsIGV4dHJhQ2xhc3NOYW1lOiBcImZjLWhlYWRlci10b29sYmFyXCIsIG1vZGVsOiB0b29sYmFyQ29uZmlnLmhlYWRlciwgdGl0bGVJZDogdmlld0xhYmVsSWQgfSwgdG9vbGJhclByb3BzKSkpLFxyXG4gICAgICAgICAgICAgICAgeShWaWV3SGFybmVzcywgeyBsaXF1aWQ6IHZpZXdWR3JvdywgaGVpZ2h0OiB2aWV3SGVpZ2h0LCBhc3BlY3RSYXRpbzogdmlld0FzcGVjdFJhdGlvLCBsYWJlbGVkQnlJZDogdmlld0xhYmVsSWQgfSxcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlclZpZXcocHJvcHMpLFxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYnVpbGRBcHBlbmRDb250ZW50KCkpLFxyXG4gICAgICAgICAgICAgICAgdG9vbGJhckNvbmZpZy5mb290ZXIgJiYgKHkoVG9vbGJhciwgT2JqZWN0LmFzc2lnbih7IHJlZjogdGhpcy5mb290ZXJSZWYsIGV4dHJhQ2xhc3NOYW1lOiBcImZjLWZvb3Rlci10b29sYmFyXCIsIG1vZGVsOiB0b29sYmFyQ29uZmlnLmZvb3RlciwgdGl0bGVJZDogXCJcIiB9LCB0b29sYmFyUHJvcHMpKSkpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29tcG9uZW50RGlkTW91bnQoKSB7XHJcbiAgICAgICAgICAgIGxldCB7IHByb3BzIH0gPSB0aGlzO1xyXG4gICAgICAgICAgICB0aGlzLmNhbGVuZGFySW50ZXJhY3Rpb25zID0gcHJvcHMucGx1Z2luSG9va3MuY2FsZW5kYXJJbnRlcmFjdGlvbnNcclxuICAgICAgICAgICAgICAgIC5tYXAoKENhbGVuZGFySW50ZXJhY3Rpb25DbGFzcykgPT4gbmV3IENhbGVuZGFySW50ZXJhY3Rpb25DbGFzcyhwcm9wcykpO1xyXG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5oYW5kbGVXaW5kb3dSZXNpemUpO1xyXG4gICAgICAgICAgICBsZXQgeyBwcm9wU2V0SGFuZGxlcnMgfSA9IHByb3BzLnBsdWdpbkhvb2tzO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBwcm9wTmFtZSBpbiBwcm9wU2V0SGFuZGxlcnMpIHtcclxuICAgICAgICAgICAgICAgIHByb3BTZXRIYW5kbGVyc1twcm9wTmFtZV0ocHJvcHNbcHJvcE5hbWVdLCBwcm9wcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcykge1xyXG4gICAgICAgICAgICBsZXQgeyBwcm9wcyB9ID0gdGhpcztcclxuICAgICAgICAgICAgbGV0IHsgcHJvcFNldEhhbmRsZXJzIH0gPSBwcm9wcy5wbHVnaW5Ib29rcztcclxuICAgICAgICAgICAgZm9yIChsZXQgcHJvcE5hbWUgaW4gcHJvcFNldEhhbmRsZXJzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocHJvcHNbcHJvcE5hbWVdICE9PSBwcmV2UHJvcHNbcHJvcE5hbWVdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvcFNldEhhbmRsZXJzW3Byb3BOYW1lXShwcm9wc1twcm9wTmFtZV0sIHByb3BzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcclxuICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMuaGFuZGxlV2luZG93UmVzaXplKTtcclxuICAgICAgICAgICAgdGhpcy5yZXNpemVSdW5uZXIuY2xlYXIoKTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaW50ZXJhY3Rpb24gb2YgdGhpcy5jYWxlbmRhckludGVyYWN0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgaW50ZXJhY3Rpb24uZGVzdHJveSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMucHJvcHMuZW1pdHRlci50cmlnZ2VyKCdfdW5tb3VudCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBidWlsZEFwcGVuZENvbnRlbnQoKSB7XHJcbiAgICAgICAgICAgIGxldCB7IHByb3BzIH0gPSB0aGlzO1xyXG4gICAgICAgICAgICBsZXQgY2hpbGRyZW4gPSBwcm9wcy5wbHVnaW5Ib29rcy52aWV3Q29udGFpbmVyQXBwZW5kcy5tYXAoKGJ1aWxkQXBwZW5kQ29udGVudCkgPT4gYnVpbGRBcHBlbmRDb250ZW50KHByb3BzKSk7XHJcbiAgICAgICAgICAgIHJldHVybiB5KF8sIHt9LCAuLi5jaGlsZHJlbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlbmRlclZpZXcocHJvcHMpIHtcclxuICAgICAgICAgICAgbGV0IHsgcGx1Z2luSG9va3MgfSA9IHByb3BzO1xyXG4gICAgICAgICAgICBsZXQgeyB2aWV3U3BlYyB9ID0gcHJvcHM7XHJcbiAgICAgICAgICAgIGxldCB2aWV3UHJvcHMgPSB7XHJcbiAgICAgICAgICAgICAgICBkYXRlUHJvZmlsZTogcHJvcHMuZGF0ZVByb2ZpbGUsXHJcbiAgICAgICAgICAgICAgICBidXNpbmVzc0hvdXJzOiBwcm9wcy5idXNpbmVzc0hvdXJzLFxyXG4gICAgICAgICAgICAgICAgZXZlbnRTdG9yZTogcHJvcHMucmVuZGVyYWJsZUV2ZW50U3RvcmUsXHJcbiAgICAgICAgICAgICAgICBldmVudFVpQmFzZXM6IHByb3BzLmV2ZW50VWlCYXNlcyxcclxuICAgICAgICAgICAgICAgIGRhdGVTZWxlY3Rpb246IHByb3BzLmRhdGVTZWxlY3Rpb24sXHJcbiAgICAgICAgICAgICAgICBldmVudFNlbGVjdGlvbjogcHJvcHMuZXZlbnRTZWxlY3Rpb24sXHJcbiAgICAgICAgICAgICAgICBldmVudERyYWc6IHByb3BzLmV2ZW50RHJhZyxcclxuICAgICAgICAgICAgICAgIGV2ZW50UmVzaXplOiBwcm9wcy5ldmVudFJlc2l6ZSxcclxuICAgICAgICAgICAgICAgIGlzSGVpZ2h0QXV0bzogcHJvcHMuaXNIZWlnaHRBdXRvLFxyXG4gICAgICAgICAgICAgICAgZm9yUHJpbnQ6IHByb3BzLmZvclByaW50LFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBsZXQgdHJhbnNmb3JtZXJzID0gdGhpcy5idWlsZFZpZXdQcm9wVHJhbnNmb3JtZXJzKHBsdWdpbkhvb2tzLnZpZXdQcm9wc1RyYW5zZm9ybWVycyk7XHJcbiAgICAgICAgICAgIGZvciAobGV0IHRyYW5zZm9ybWVyIG9mIHRyYW5zZm9ybWVycykge1xyXG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih2aWV3UHJvcHMsIHRyYW5zZm9ybWVyLnRyYW5zZm9ybSh2aWV3UHJvcHMsIHByb3BzKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IFZpZXdDb21wb25lbnQgPSB2aWV3U3BlYy5jb21wb25lbnQ7XHJcbiAgICAgICAgICAgIHJldHVybiAoeShWaWV3Q29tcG9uZW50LCBPYmplY3QuYXNzaWduKHt9LCB2aWV3UHJvcHMpKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYnVpbGRUb29sYmFyUHJvcHModmlld1NwZWMsIGRhdGVQcm9maWxlLCBkYXRlUHJvZmlsZUdlbmVyYXRvciwgY3VycmVudERhdGUsIG5vdywgdGl0bGUpIHtcclxuICAgICAgICAvLyBkb24ndCBmb3JjZSBhbnkgZGF0ZS1wcm9maWxlcyB0byB2YWxpZCBkYXRlIHByb2ZpbGVzICh0aGUgYGZhbHNlYCkgc28gdGhhdCB3ZSBjYW4gdGVsbCBpZiBpdCdzIGludmFsaWRcclxuICAgICAgICBsZXQgdG9kYXlJbmZvID0gZGF0ZVByb2ZpbGVHZW5lcmF0b3IuYnVpbGQobm93LCB1bmRlZmluZWQsIGZhbHNlKTsgLy8gVE9ETzogbmVlZCBgdW5kZWZpbmVkYCBvciBlbHNlIElORklOSVRFIExPT1AgZm9yIHNvbWUgcmVhc29uXHJcbiAgICAgICAgbGV0IHByZXZJbmZvID0gZGF0ZVByb2ZpbGVHZW5lcmF0b3IuYnVpbGRQcmV2KGRhdGVQcm9maWxlLCBjdXJyZW50RGF0ZSwgZmFsc2UpO1xyXG4gICAgICAgIGxldCBuZXh0SW5mbyA9IGRhdGVQcm9maWxlR2VuZXJhdG9yLmJ1aWxkTmV4dChkYXRlUHJvZmlsZSwgY3VycmVudERhdGUsIGZhbHNlKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB0aXRsZSxcclxuICAgICAgICAgICAgYWN0aXZlQnV0dG9uOiB2aWV3U3BlYy50eXBlLFxyXG4gICAgICAgICAgICBuYXZVbml0OiB2aWV3U3BlYy5zaW5nbGVVbml0LFxyXG4gICAgICAgICAgICBpc1RvZGF5RW5hYmxlZDogdG9kYXlJbmZvLmlzVmFsaWQgJiYgIXJhbmdlQ29udGFpbnNNYXJrZXIoZGF0ZVByb2ZpbGUuY3VycmVudFJhbmdlLCBub3cpLFxyXG4gICAgICAgICAgICBpc1ByZXZFbmFibGVkOiBwcmV2SW5mby5pc1ZhbGlkLFxyXG4gICAgICAgICAgICBpc05leHRFbmFibGVkOiBuZXh0SW5mby5pc1ZhbGlkLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICAvLyBQbHVnaW5cclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICBmdW5jdGlvbiBidWlsZFZpZXdQcm9wVHJhbnNmb3JtZXJzKHRoZUNsYXNzZXMpIHtcclxuICAgICAgICByZXR1cm4gdGhlQ2xhc3Nlcy5tYXAoKFRoZUNsYXNzKSA9PiBuZXcgVGhlQ2xhc3MoKSk7XHJcbiAgICB9XHJcblxyXG4gICAgY2xhc3MgQ2FsZW5kYXIgZXh0ZW5kcyBDYWxlbmRhckltcGwge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yKGVsLCBvcHRpb25PdmVycmlkZXMgPSB7fSkge1xyXG4gICAgICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgICAgICB0aGlzLmlzUmVuZGVyaW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuaXNSZW5kZXJlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRDbGFzc05hbWVzID0gW107XHJcbiAgICAgICAgICAgIHRoaXMuY3VzdG9tQ29udGVudFJlbmRlcklkID0gMDtcclxuICAgICAgICAgICAgdGhpcy5oYW5kbGVBY3Rpb24gPSAoYWN0aW9uKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAvLyBhY3Rpb25zIHdlIGtub3cgd2Ugd2FudCB0byByZW5kZXIgaW1tZWRpYXRlbHlcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdTRVRfRVZFTlRfRFJBRyc6XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnU0VUX0VWRU5UX1JFU0laRSc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyUnVubmVyLnRyeURyYWluKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlRGF0YSA9IChkYXRhKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnREYXRhID0gZGF0YTtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyUnVubmVyLnJlcXVlc3QoZGF0YS5jYWxlbmRhck9wdGlvbnMucmVyZW5kZXJEZWxheSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlUmVuZGVyUmVxdWVzdCA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzUmVuZGVyaW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pc1JlbmRlcmVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgeyBjdXJyZW50RGF0YSB9ID0gdGhpcztcclxuICAgICAgICAgICAgICAgICAgICBmbHVzaFN5bmMoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBEJDEoeShDYWxlbmRhclJvb3QsIHsgb3B0aW9uczogY3VycmVudERhdGEuY2FsZW5kYXJPcHRpb25zLCB0aGVtZTogY3VycmVudERhdGEudGhlbWUsIGVtaXR0ZXI6IGN1cnJlbnREYXRhLmVtaXR0ZXIgfSwgKGNsYXNzTmFtZXMsIGhlaWdodCwgaXNIZWlnaHRBdXRvLCBmb3JQcmludCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRDbGFzc05hbWVzKGNsYXNzTmFtZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRIZWlnaHQoaGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoeShSZW5kZXJJZC5Qcm92aWRlciwgeyB2YWx1ZTogdGhpcy5jdXN0b21Db250ZW50UmVuZGVySWQgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5KENhbGVuZGFyQ29udGVudCwgT2JqZWN0LmFzc2lnbih7IGlzSGVpZ2h0QXV0bzogaXNIZWlnaHRBdXRvLCBmb3JQcmludDogZm9yUHJpbnQgfSwgY3VycmVudERhdGEpKSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSwgdGhpcy5lbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLmlzUmVuZGVyZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmlzUmVuZGVyZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICBEJDEobnVsbCwgdGhpcy5lbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRDbGFzc05hbWVzKFtdKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldEhlaWdodCgnJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGVuc3VyZUVsSGFzU3R5bGVzKGVsKTtcclxuICAgICAgICAgICAgdGhpcy5lbCA9IGVsO1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlclJ1bm5lciA9IG5ldyBEZWxheWVkUnVubmVyKHRoaXMuaGFuZGxlUmVuZGVyUmVxdWVzdCk7XHJcbiAgICAgICAgICAgIG5ldyBDYWxlbmRhckRhdGFNYW5hZ2VyKHtcclxuICAgICAgICAgICAgICAgIG9wdGlvbk92ZXJyaWRlcyxcclxuICAgICAgICAgICAgICAgIGNhbGVuZGFyQXBpOiB0aGlzLFxyXG4gICAgICAgICAgICAgICAgb25BY3Rpb246IHRoaXMuaGFuZGxlQWN0aW9uLFxyXG4gICAgICAgICAgICAgICAgb25EYXRhOiB0aGlzLmhhbmRsZURhdGEsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZW5kZXIoKSB7XHJcbiAgICAgICAgICAgIGxldCB3YXNSZW5kZXJpbmcgPSB0aGlzLmlzUmVuZGVyaW5nO1xyXG4gICAgICAgICAgICBpZiAoIXdhc1JlbmRlcmluZykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pc1JlbmRlcmluZyA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmN1c3RvbUNvbnRlbnRSZW5kZXJJZCArPSAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyUnVubmVyLnJlcXVlc3QoKTtcclxuICAgICAgICAgICAgaWYgKHdhc1JlbmRlcmluZykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVTaXplKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZGVzdHJveSgpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaXNSZW5kZXJpbmcpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaXNSZW5kZXJpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyUnVubmVyLnJlcXVlc3QoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB1cGRhdGVTaXplKCkge1xyXG4gICAgICAgICAgICBmbHVzaFN5bmMoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgc3VwZXIudXBkYXRlU2l6ZSgpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYmF0Y2hSZW5kZXJpbmcoZnVuYykge1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlclJ1bm5lci5wYXVzZSgnYmF0Y2hSZW5kZXJpbmcnKTtcclxuICAgICAgICAgICAgZnVuYygpO1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlclJ1bm5lci5yZXN1bWUoJ2JhdGNoUmVuZGVyaW5nJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHBhdXNlUmVuZGVyaW5nKCkge1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlclJ1bm5lci5wYXVzZSgncGF1c2VSZW5kZXJpbmcnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVzdW1lUmVuZGVyaW5nKCkge1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlclJ1bm5lci5yZXN1bWUoJ3BhdXNlUmVuZGVyaW5nJywgdHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlc2V0T3B0aW9ucyhvcHRpb25PdmVycmlkZXMsIGNoYW5nZWRPcHRpb25OYW1lcykge1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnREYXRhTWFuYWdlci5yZXNldE9wdGlvbnMob3B0aW9uT3ZlcnJpZGVzLCBjaGFuZ2VkT3B0aW9uTmFtZXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzZXRDbGFzc05hbWVzKGNsYXNzTmFtZXMpIHtcclxuICAgICAgICAgICAgaWYgKCFpc0FycmF5c0VxdWFsKGNsYXNzTmFtZXMsIHRoaXMuY3VycmVudENsYXNzTmFtZXMpKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgeyBjbGFzc0xpc3QgfSA9IHRoaXMuZWw7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBjbGFzc05hbWUgb2YgdGhpcy5jdXJyZW50Q2xhc3NOYW1lcykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTGlzdC5yZW1vdmUoY2xhc3NOYW1lKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGNsYXNzTmFtZSBvZiBjbGFzc05hbWVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NMaXN0LmFkZChjbGFzc05hbWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50Q2xhc3NOYW1lcyA9IGNsYXNzTmFtZXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgc2V0SGVpZ2h0KGhlaWdodCkge1xyXG4gICAgICAgICAgICBhcHBseVN0eWxlUHJvcCh0aGlzLmVsLCAnaGVpZ2h0JywgaGVpZ2h0KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZm9ybWF0RGF0ZShkYXRlSW5wdXQsIG9wdGlvbnMgPSB7fSkge1xyXG4gICAgICAgIGxldCBkYXRlRW52ID0gYnVpbGREYXRlRW52KG9wdGlvbnMpO1xyXG4gICAgICAgIGxldCBmb3JtYXR0ZXIgPSBjcmVhdGVGb3JtYXR0ZXIob3B0aW9ucyk7XHJcbiAgICAgICAgbGV0IGRhdGVNZXRhID0gZGF0ZUVudi5jcmVhdGVNYXJrZXJNZXRhKGRhdGVJbnB1dCk7XHJcbiAgICAgICAgaWYgKCFkYXRlTWV0YSkgeyAvLyBUT0RPOiB3YXJuaW5nP1xyXG4gICAgICAgICAgICByZXR1cm4gJyc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkYXRlRW52LmZvcm1hdChkYXRlTWV0YS5tYXJrZXIsIGZvcm1hdHRlciwge1xyXG4gICAgICAgICAgICBmb3JjZWRUem86IGRhdGVNZXRhLmZvcmNlZFR6byxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGZvcm1hdFJhbmdlKHN0YXJ0SW5wdXQsIGVuZElucHV0LCBvcHRpb25zKSB7XHJcbiAgICAgICAgbGV0IGRhdGVFbnYgPSBidWlsZERhdGVFbnYodHlwZW9mIG9wdGlvbnMgPT09ICdvYmplY3QnICYmIG9wdGlvbnMgPyBvcHRpb25zIDoge30pOyAvLyBwYXNzIGluIGlmIG5vbi1udWxsIG9iamVjdFxyXG4gICAgICAgIGxldCBmb3JtYXR0ZXIgPSBjcmVhdGVGb3JtYXR0ZXIob3B0aW9ucyk7XHJcbiAgICAgICAgbGV0IHN0YXJ0TWV0YSA9IGRhdGVFbnYuY3JlYXRlTWFya2VyTWV0YShzdGFydElucHV0KTtcclxuICAgICAgICBsZXQgZW5kTWV0YSA9IGRhdGVFbnYuY3JlYXRlTWFya2VyTWV0YShlbmRJbnB1dCk7XHJcbiAgICAgICAgaWYgKCFzdGFydE1ldGEgfHwgIWVuZE1ldGEpIHsgLy8gVE9ETzogd2FybmluZz9cclxuICAgICAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZGF0ZUVudi5mb3JtYXRSYW5nZShzdGFydE1ldGEubWFya2VyLCBlbmRNZXRhLm1hcmtlciwgZm9ybWF0dGVyLCB7XHJcbiAgICAgICAgICAgIGZvcmNlZFN0YXJ0VHpvOiBzdGFydE1ldGEuZm9yY2VkVHpvLFxyXG4gICAgICAgICAgICBmb3JjZWRFbmRUem86IGVuZE1ldGEuZm9yY2VkVHpvLFxyXG4gICAgICAgICAgICBpc0VuZEV4Y2x1c2l2ZTogb3B0aW9ucy5pc0VuZEV4Y2x1c2l2ZSxcclxuICAgICAgICAgICAgZGVmYXVsdFNlcGFyYXRvcjogQkFTRV9PUFRJT05fREVGQVVMVFMuZGVmYXVsdFJhbmdlU2VwYXJhdG9yLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLy8gVE9ETzogbW9yZSBEUlkgYW5kIG9wdGltaXplZFxyXG4gICAgZnVuY3Rpb24gYnVpbGREYXRlRW52KHNldHRpbmdzKSB7XHJcbiAgICAgICAgbGV0IGxvY2FsZSA9IGJ1aWxkTG9jYWxlKHNldHRpbmdzLmxvY2FsZSB8fCAnZW4nLCBvcmdhbml6ZVJhd0xvY2FsZXMoW10pLm1hcCk7IC8vIFRPRE86IGRvbid0IGhhcmRjb2RlICdlbicgZXZlcnl3aGVyZVxyXG4gICAgICAgIHJldHVybiBuZXcgRGF0ZUVudihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyB0aW1lWm9uZTogQkFTRV9PUFRJT05fREVGQVVMVFMudGltZVpvbmUsIGNhbGVuZGFyU3lzdGVtOiAnZ3JlZ29yeScgfSwgc2V0dGluZ3MpLCB7IGxvY2FsZSB9KSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gSEVMUEVSU1xyXG4gICAgLypcclxuICAgIGlmIG5leHREYXlUaHJlc2hvbGQgaXMgc3BlY2lmaWVkLCBzbGljaW5nIGlzIGRvbmUgaW4gYW4gYWxsLWRheSBmYXNoaW9uLlxyXG4gICAgeW91IGNhbiBnZXQgbmV4dERheVRocmVzaG9sZCBmcm9tIGNvbnRleHQubmV4dERheVRocmVzaG9sZFxyXG4gICAgKi9cclxuICAgIGZ1bmN0aW9uIHNsaWNlRXZlbnRzKHByb3BzLCBhbGxEYXkpIHtcclxuICAgICAgICByZXR1cm4gc2xpY2VFdmVudFN0b3JlKHByb3BzLmV2ZW50U3RvcmUsIHByb3BzLmV2ZW50VWlCYXNlcywgcHJvcHMuZGF0ZVByb2ZpbGUuYWN0aXZlUmFuZ2UsIGFsbERheSA/IHByb3BzLm5leHREYXlUaHJlc2hvbGQgOiBudWxsKS5mZztcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCB2ZXJzaW9uID0gJzYuMS44JztcclxuXHJcbiAgICBjb25maWcudG91Y2hNb3VzZUlnbm9yZVdhaXQgPSA1MDA7XHJcbiAgICBsZXQgaWdub3JlTW91c2VEZXB0aCA9IDA7XHJcbiAgICBsZXQgbGlzdGVuZXJDbnQgPSAwO1xyXG4gICAgbGV0IGlzV2luZG93VG91Y2hNb3ZlQ2FuY2VsbGVkID0gZmFsc2U7XHJcbiAgICAvKlxyXG4gICAgVXNlcyBhIFwicG9pbnRlclwiIGFic3RyYWN0aW9uLCB3aGljaCBtb25pdG9ycyBVSSBldmVudHMgZm9yIGJvdGggbW91c2UgYW5kIHRvdWNoLlxyXG4gICAgVHJhY2tzIHdoZW4gdGhlIHBvaW50ZXIgXCJkcmFnc1wiIG9uIGEgY2VydGFpbiBlbGVtZW50LCBtZWFuaW5nIGRvd24rbW92ZSt1cC5cclxuXHJcbiAgICBBbHNvLCB0cmFja3MgaWYgdGhlcmUgd2FzIHRvdWNoLXNjcm9sbGluZy5cclxuICAgIEFsc28sIGNhbiBwcmV2ZW50IHRvdWNoLXNjcm9sbGluZyBmcm9tIGhhcHBlbmluZy5cclxuICAgIEFsc28sIGNhbiBmaXJlIHBvaW50ZXJtb3ZlIGV2ZW50cyB3aGVuIHNjcm9sbGluZyBoYXBwZW5zIHVuZGVybmVhdGgsIGV2ZW4gd2hlbiBubyByZWFsIHBvaW50ZXIgbW92ZW1lbnQuXHJcblxyXG4gICAgZW1pdHM6XHJcbiAgICAtIHBvaW50ZXJkb3duXHJcbiAgICAtIHBvaW50ZXJtb3ZlXHJcbiAgICAtIHBvaW50ZXJ1cFxyXG4gICAgKi9cclxuICAgIGNsYXNzIFBvaW50ZXJEcmFnZ2luZyB7XHJcbiAgICAgICAgY29uc3RydWN0b3IoY29udGFpbmVyRWwpIHtcclxuICAgICAgICAgICAgdGhpcy5zdWJqZWN0RWwgPSBudWxsO1xyXG4gICAgICAgICAgICAvLyBvcHRpb25zIHRoYXQgY2FuIGJlIGRpcmVjdGx5IGFzc2lnbmVkIGJ5IGNhbGxlclxyXG4gICAgICAgICAgICB0aGlzLnNlbGVjdG9yID0gJyc7IC8vIHdpbGwgY2F1c2Ugc3ViamVjdEVsIGluIGFsbCBlbWl0dGVkIGV2ZW50cyB0byBiZSB0aGlzIGVsZW1lbnRcclxuICAgICAgICAgICAgdGhpcy5oYW5kbGVTZWxlY3RvciA9ICcnO1xyXG4gICAgICAgICAgICB0aGlzLnNob3VsZElnbm9yZU1vdmUgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5zaG91bGRXYXRjaFNjcm9sbCA9IHRydWU7IC8vIGZvciBzaW11bGF0aW5nIHBvaW50ZXJtb3ZlIG9uIHNjcm9sbFxyXG4gICAgICAgICAgICAvLyBpbnRlcm5hbCBzdGF0ZXNcclxuICAgICAgICAgICAgdGhpcy5pc0RyYWdnaW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuaXNUb3VjaERyYWdnaW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMud2FzVG91Y2hTY3JvbGwgPSBmYWxzZTtcclxuICAgICAgICAgICAgLy8gTW91c2VcclxuICAgICAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgICAgICAgICB0aGlzLmhhbmRsZU1vdXNlRG93biA9IChldikgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnNob3VsZElnbm9yZU1vdXNlKCkgJiZcclxuICAgICAgICAgICAgICAgICAgICBpc1ByaW1hcnlNb3VzZUJ1dHRvbihldikgJiZcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyeVN0YXJ0KGV2KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBwZXYgPSB0aGlzLmNyZWF0ZUV2ZW50RnJvbU1vdXNlKGV2LCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXR0ZXIudHJpZ2dlcigncG9pbnRlcmRvd24nLCBwZXYpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5pdFNjcm9sbFdhdGNoKHBldik7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLnNob3VsZElnbm9yZU1vdmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5oYW5kbGVNb3VzZU1vdmUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5oYW5kbGVNb3VzZVVwKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdGhpcy5oYW5kbGVNb3VzZU1vdmUgPSAoZXYpID0+IHtcclxuICAgICAgICAgICAgICAgIGxldCBwZXYgPSB0aGlzLmNyZWF0ZUV2ZW50RnJvbU1vdXNlKGV2KTtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVjb3JkQ29vcmRzKHBldik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXR0ZXIudHJpZ2dlcigncG9pbnRlcm1vdmUnLCBwZXYpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB0aGlzLmhhbmRsZU1vdXNlVXAgPSAoZXYpID0+IHtcclxuICAgICAgICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMuaGFuZGxlTW91c2VNb3ZlKTtcclxuICAgICAgICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLmhhbmRsZU1vdXNlVXApO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0dGVyLnRyaWdnZXIoJ3BvaW50ZXJ1cCcsIHRoaXMuY3JlYXRlRXZlbnRGcm9tTW91c2UoZXYpKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2xlYW51cCgpOyAvLyBjYWxsIGxhc3Qgc28gdGhhdCBwb2ludGVydXAgaGFzIGFjY2VzcyB0byBwcm9wc1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvLyBUb3VjaFxyXG4gICAgICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlVG91Y2hTdGFydCA9IChldikgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudHJ5U3RhcnQoZXYpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pc1RvdWNoRHJhZ2dpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBwZXYgPSB0aGlzLmNyZWF0ZUV2ZW50RnJvbVRvdWNoKGV2LCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXR0ZXIudHJpZ2dlcigncG9pbnRlcmRvd24nLCBwZXYpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5pdFNjcm9sbFdhdGNoKHBldik7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdW5saWtlIG1vdXNlLCBuZWVkIHRvIGF0dGFjaCB0byB0YXJnZXQsIG5vdCBkb2N1bWVudFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS80NTc2MDAxNFxyXG4gICAgICAgICAgICAgICAgICAgIGxldCB0YXJnZXRFbCA9IGV2LnRhcmdldDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuc2hvdWxkSWdub3JlTW92ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRFbC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLmhhbmRsZVRvdWNoTW92ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldEVsLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5oYW5kbGVUb3VjaEVuZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0RWwuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hjYW5jZWwnLCB0aGlzLmhhbmRsZVRvdWNoRW5kKTsgLy8gdHJlYXQgaXQgYXMgYSB0b3VjaCBlbmRcclxuICAgICAgICAgICAgICAgICAgICAvLyBhdHRhY2ggYSBoYW5kbGVyIHRvIGdldCBjYWxsZWQgd2hlbiBBTlkgc2Nyb2xsIGFjdGlvbiBoYXBwZW5zIG9uIHRoZSBwYWdlLlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgd2FzIGltcG9zc2libGUgdG8gZG8gd2l0aCBub3JtYWwgb24vb2ZmIGJlY2F1c2UgJ3Njcm9sbCcgZG9lc24ndCBidWJibGUuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzI5NTQ1NjUvOTYzNDJcclxuICAgICAgICAgICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcy5oYW5kbGVUb3VjaFNjcm9sbCwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlVG91Y2hNb3ZlID0gKGV2KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBsZXQgcGV2ID0gdGhpcy5jcmVhdGVFdmVudEZyb21Ub3VjaChldik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlY29yZENvb3JkcyhwZXYpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0dGVyLnRyaWdnZXIoJ3BvaW50ZXJtb3ZlJywgcGV2KTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdGhpcy5oYW5kbGVUb3VjaEVuZCA9IChldikgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNEcmFnZ2luZykgeyAvLyBkb25lIHRvIGd1YXJkIGFnYWluc3QgdG91Y2hlbmQgZm9sbG93ZWQgYnkgdG91Y2hjYW5jZWxcclxuICAgICAgICAgICAgICAgICAgICBsZXQgdGFyZ2V0RWwgPSBldi50YXJnZXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0RWwucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5oYW5kbGVUb3VjaE1vdmUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldEVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5oYW5kbGVUb3VjaEVuZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0RWwucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hjYW5jZWwnLCB0aGlzLmhhbmRsZVRvdWNoRW5kKTtcclxuICAgICAgICAgICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcy5oYW5kbGVUb3VjaFNjcm9sbCwgdHJ1ZSk7IC8vIHVzZUNhcHR1cmVkPXRydWVcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXR0ZXIudHJpZ2dlcigncG9pbnRlcnVwJywgdGhpcy5jcmVhdGVFdmVudEZyb21Ub3VjaChldikpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xlYW51cCgpOyAvLyBjYWxsIGxhc3Qgc28gdGhhdCBwb2ludGVydXAgaGFzIGFjY2VzcyB0byBwcm9wc1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaXNUb3VjaERyYWdnaW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRJZ25vcmluZ01vdXNlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlVG91Y2hTY3JvbGwgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLndhc1RvdWNoU2Nyb2xsID0gdHJ1ZTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdGhpcy5oYW5kbGVTY3JvbGwgPSAoZXYpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5zaG91bGRJZ25vcmVNb3ZlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBhZ2VYID0gKHdpbmRvdy5wYWdlWE9mZnNldCAtIHRoaXMucHJldlNjcm9sbFgpICsgdGhpcy5wcmV2UGFnZVg7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBhZ2VZID0gKHdpbmRvdy5wYWdlWU9mZnNldCAtIHRoaXMucHJldlNjcm9sbFkpICsgdGhpcy5wcmV2UGFnZVk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0dGVyLnRyaWdnZXIoJ3BvaW50ZXJtb3ZlJywge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvcmlnRXZlbnQ6IGV2LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpc1RvdWNoOiB0aGlzLmlzVG91Y2hEcmFnZ2luZyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3ViamVjdEVsOiB0aGlzLnN1YmplY3RFbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFnZVgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2VZLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWx0YVg6IHBhZ2VYIC0gdGhpcy5vcmlnUGFnZVgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbHRhWTogcGFnZVkgLSB0aGlzLm9yaWdQYWdlWSxcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdGhpcy5jb250YWluZXJFbCA9IGNvbnRhaW5lckVsO1xyXG4gICAgICAgICAgICB0aGlzLmVtaXR0ZXIgPSBuZXcgRW1pdHRlcigpO1xyXG4gICAgICAgICAgICBjb250YWluZXJFbC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLmhhbmRsZU1vdXNlRG93bik7XHJcbiAgICAgICAgICAgIGNvbnRhaW5lckVsLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCB0aGlzLmhhbmRsZVRvdWNoU3RhcnQsIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcclxuICAgICAgICAgICAgbGlzdGVuZXJDcmVhdGVkKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRlc3Ryb3koKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyRWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5oYW5kbGVNb3VzZURvd24pO1xyXG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lckVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCB0aGlzLmhhbmRsZVRvdWNoU3RhcnQsIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcclxuICAgICAgICAgICAgbGlzdGVuZXJEZXN0cm95ZWQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdHJ5U3RhcnQoZXYpIHtcclxuICAgICAgICAgICAgbGV0IHN1YmplY3RFbCA9IHRoaXMucXVlcnlTdWJqZWN0RWwoZXYpO1xyXG4gICAgICAgICAgICBsZXQgZG93bkVsID0gZXYudGFyZ2V0O1xyXG4gICAgICAgICAgICBpZiAoc3ViamVjdEVsICYmXHJcbiAgICAgICAgICAgICAgICAoIXRoaXMuaGFuZGxlU2VsZWN0b3IgfHwgZWxlbWVudENsb3Nlc3QoZG93bkVsLCB0aGlzLmhhbmRsZVNlbGVjdG9yKSkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3ViamVjdEVsID0gc3ViamVjdEVsO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pc0RyYWdnaW5nID0gdHJ1ZTsgLy8gZG8gdGhpcyBmaXJzdCBzbyBjYW5jZWxUb3VjaFNjcm9sbCB3aWxsIHdvcmtcclxuICAgICAgICAgICAgICAgIHRoaXMud2FzVG91Y2hTY3JvbGwgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2xlYW51cCgpIHtcclxuICAgICAgICAgICAgaXNXaW5kb3dUb3VjaE1vdmVDYW5jZWxsZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5pc0RyYWdnaW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuc3ViamVjdEVsID0gbnVsbDtcclxuICAgICAgICAgICAgLy8ga2VlcCB3YXNUb3VjaFNjcm9sbCBhcm91bmQgZm9yIGxhdGVyIGFjY2Vzc1xyXG4gICAgICAgICAgICB0aGlzLmRlc3Ryb3lTY3JvbGxXYXRjaCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBxdWVyeVN1YmplY3RFbChldikge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5zZWxlY3Rvcikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnRDbG9zZXN0KGV2LnRhcmdldCwgdGhpcy5zZWxlY3Rvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udGFpbmVyRWw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNob3VsZElnbm9yZU1vdXNlKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gaWdub3JlTW91c2VEZXB0aCB8fCB0aGlzLmlzVG91Y2hEcmFnZ2luZztcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gY2FuIGJlIGNhbGxlZCBieSB1c2VyIG9mIHRoaXMgY2xhc3MsIHRvIGNhbmNlbCB0b3VjaC1iYXNlZCBzY3JvbGxpbmcgZm9yIHRoZSBjdXJyZW50IGRyYWdcclxuICAgICAgICBjYW5jZWxUb3VjaFNjcm9sbCgpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaXNEcmFnZ2luZykge1xyXG4gICAgICAgICAgICAgICAgaXNXaW5kb3dUb3VjaE1vdmVDYW5jZWxsZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFNjcm9sbGluZyB0aGF0IHNpbXVsYXRlcyBwb2ludGVybW92ZXNcclxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAgICAgaW5pdFNjcm9sbFdhdGNoKGV2KSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnNob3VsZFdhdGNoU2Nyb2xsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlY29yZENvb3Jkcyhldik7XHJcbiAgICAgICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcy5oYW5kbGVTY3JvbGwsIHRydWUpOyAvLyB1c2VDYXB0dXJlPXRydWVcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZWNvcmRDb29yZHMoZXYpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuc2hvdWxkV2F0Y2hTY3JvbGwpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucHJldlBhZ2VYID0gZXYucGFnZVg7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnByZXZQYWdlWSA9IGV2LnBhZ2VZO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wcmV2U2Nyb2xsWCA9IHdpbmRvdy5wYWdlWE9mZnNldDtcclxuICAgICAgICAgICAgICAgIHRoaXMucHJldlNjcm9sbFkgPSB3aW5kb3cucGFnZVlPZmZzZXQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZGVzdHJveVNjcm9sbFdhdGNoKCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5zaG91bGRXYXRjaFNjcm9sbCkge1xyXG4gICAgICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMuaGFuZGxlU2Nyb2xsLCB0cnVlKTsgLy8gdXNlQ2FwdHVyZWQ9dHJ1ZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEV2ZW50IE5vcm1hbGl6YXRpb25cclxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAgICAgY3JlYXRlRXZlbnRGcm9tTW91c2UoZXYsIGlzRmlyc3QpIHtcclxuICAgICAgICAgICAgbGV0IGRlbHRhWCA9IDA7XHJcbiAgICAgICAgICAgIGxldCBkZWx0YVkgPSAwO1xyXG4gICAgICAgICAgICAvLyBUT0RPOiByZXBlYXQgY29kZVxyXG4gICAgICAgICAgICBpZiAoaXNGaXJzdCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vcmlnUGFnZVggPSBldi5wYWdlWDtcclxuICAgICAgICAgICAgICAgIHRoaXMub3JpZ1BhZ2VZID0gZXYucGFnZVk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBkZWx0YVggPSBldi5wYWdlWCAtIHRoaXMub3JpZ1BhZ2VYO1xyXG4gICAgICAgICAgICAgICAgZGVsdGFZID0gZXYucGFnZVkgLSB0aGlzLm9yaWdQYWdlWTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgb3JpZ0V2ZW50OiBldixcclxuICAgICAgICAgICAgICAgIGlzVG91Y2g6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgc3ViamVjdEVsOiB0aGlzLnN1YmplY3RFbCxcclxuICAgICAgICAgICAgICAgIHBhZ2VYOiBldi5wYWdlWCxcclxuICAgICAgICAgICAgICAgIHBhZ2VZOiBldi5wYWdlWSxcclxuICAgICAgICAgICAgICAgIGRlbHRhWCxcclxuICAgICAgICAgICAgICAgIGRlbHRhWSxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY3JlYXRlRXZlbnRGcm9tVG91Y2goZXYsIGlzRmlyc3QpIHtcclxuICAgICAgICAgICAgbGV0IHRvdWNoZXMgPSBldi50b3VjaGVzO1xyXG4gICAgICAgICAgICBsZXQgcGFnZVg7XHJcbiAgICAgICAgICAgIGxldCBwYWdlWTtcclxuICAgICAgICAgICAgbGV0IGRlbHRhWCA9IDA7XHJcbiAgICAgICAgICAgIGxldCBkZWx0YVkgPSAwO1xyXG4gICAgICAgICAgICAvLyBpZiB0b3VjaCBjb29yZHMgYXZhaWxhYmxlLCBwcmVmZXIsXHJcbiAgICAgICAgICAgIC8vIGJlY2F1c2UgRkYgd291bGQgZ2l2ZSBiYWQgZXYucGFnZVggZXYucGFnZVlcclxuICAgICAgICAgICAgaWYgKHRvdWNoZXMgJiYgdG91Y2hlcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHBhZ2VYID0gdG91Y2hlc1swXS5wYWdlWDtcclxuICAgICAgICAgICAgICAgIHBhZ2VZID0gdG91Y2hlc1swXS5wYWdlWTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHBhZ2VYID0gZXYucGFnZVg7XHJcbiAgICAgICAgICAgICAgICBwYWdlWSA9IGV2LnBhZ2VZO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFRPRE86IHJlcGVhdCBjb2RlXHJcbiAgICAgICAgICAgIGlmIChpc0ZpcnN0KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9yaWdQYWdlWCA9IHBhZ2VYO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vcmlnUGFnZVkgPSBwYWdlWTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGRlbHRhWCA9IHBhZ2VYIC0gdGhpcy5vcmlnUGFnZVg7XHJcbiAgICAgICAgICAgICAgICBkZWx0YVkgPSBwYWdlWSAtIHRoaXMub3JpZ1BhZ2VZO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBvcmlnRXZlbnQ6IGV2LFxyXG4gICAgICAgICAgICAgICAgaXNUb3VjaDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIHN1YmplY3RFbDogdGhpcy5zdWJqZWN0RWwsXHJcbiAgICAgICAgICAgICAgICBwYWdlWCxcclxuICAgICAgICAgICAgICAgIHBhZ2VZLFxyXG4gICAgICAgICAgICAgICAgZGVsdGFYLFxyXG4gICAgICAgICAgICAgICAgZGVsdGFZLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIFJldHVybnMgYSBib29sZWFuIHdoZXRoZXIgdGhpcyB3YXMgYSBsZWZ0IG1vdXNlIGNsaWNrIGFuZCBubyBjdHJsIGtleSAod2hpY2ggbWVhbnMgcmlnaHQgY2xpY2sgb24gTWFjKVxyXG4gICAgZnVuY3Rpb24gaXNQcmltYXJ5TW91c2VCdXR0b24oZXYpIHtcclxuICAgICAgICByZXR1cm4gZXYuYnV0dG9uID09PSAwICYmICFldi5jdHJsS2V5O1xyXG4gICAgfVxyXG4gICAgLy8gSWdub3JpbmcgZmFrZSBtb3VzZSBldmVudHMgZ2VuZXJhdGVkIGJ5IHRvdWNoXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICBmdW5jdGlvbiBzdGFydElnbm9yaW5nTW91c2UoKSB7XHJcbiAgICAgICAgaWdub3JlTW91c2VEZXB0aCArPSAxO1xyXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICBpZ25vcmVNb3VzZURlcHRoIC09IDE7XHJcbiAgICAgICAgfSwgY29uZmlnLnRvdWNoTW91c2VJZ25vcmVXYWl0KTtcclxuICAgIH1cclxuICAgIC8vIFdlIHdhbnQgdG8gYXR0YWNoIHRvdWNobW92ZSBhcyBlYXJseSBhcyBwb3NzaWJsZSBmb3IgU2FmYXJpXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICBmdW5jdGlvbiBsaXN0ZW5lckNyZWF0ZWQoKSB7XHJcbiAgICAgICAgbGlzdGVuZXJDbnQgKz0gMTtcclxuICAgICAgICBpZiAobGlzdGVuZXJDbnQgPT09IDEpIHtcclxuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIG9uV2luZG93VG91Y2hNb3ZlLCB7IHBhc3NpdmU6IGZhbHNlIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGxpc3RlbmVyRGVzdHJveWVkKCkge1xyXG4gICAgICAgIGxpc3RlbmVyQ250IC09IDE7XHJcbiAgICAgICAgaWYgKCFsaXN0ZW5lckNudCkge1xyXG4gICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgb25XaW5kb3dUb3VjaE1vdmUsIHsgcGFzc2l2ZTogZmFsc2UgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gb25XaW5kb3dUb3VjaE1vdmUoZXYpIHtcclxuICAgICAgICBpZiAoaXNXaW5kb3dUb3VjaE1vdmVDYW5jZWxsZWQpIHtcclxuICAgICAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLypcclxuICAgIEFuIGVmZmVjdCBpbiB3aGljaCBhbiBlbGVtZW50IGZvbGxvd3MgdGhlIG1vdmVtZW50IG9mIGEgcG9pbnRlciBhY3Jvc3MgdGhlIHNjcmVlbi5cclxuICAgIFRoZSBtb3ZpbmcgZWxlbWVudCBpcyBhIGNsb25lIG9mIHNvbWUgb3RoZXIgZWxlbWVudC5cclxuICAgIE11c3QgY2FsbCBzdGFydCArIGhhbmRsZU1vdmUgKyBzdG9wLlxyXG4gICAgKi9cclxuICAgIGNsYXNzIEVsZW1lbnRNaXJyb3Ige1xyXG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgICAgICB0aGlzLmlzVmlzaWJsZSA9IGZhbHNlOyAvLyBtdXN0IGJlIGV4cGxpY2l0bHkgZW5hYmxlZFxyXG4gICAgICAgICAgICB0aGlzLnNvdXJjZUVsID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5taXJyb3JFbCA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMuc291cmNlRWxSZWN0ID0gbnVsbDsgLy8gc2NyZWVuIGNvb3JkcyByZWxhdGl2ZSB0byB2aWV3cG9ydFxyXG4gICAgICAgICAgICAvLyBvcHRpb25zIHRoYXQgY2FuIGJlIHNldCBkaXJlY3RseSBieSBjYWxsZXJcclxuICAgICAgICAgICAgdGhpcy5wYXJlbnROb2RlID0gZG9jdW1lbnQuYm9keTsgLy8gSElHSExZIFNVR0dFU1RFRCB0byBzZXQgdGhpcyB0byBzaWRlc3RlcCBTaGFkb3dET00gaXNzdWVzXHJcbiAgICAgICAgICAgIHRoaXMuekluZGV4ID0gOTk5OTtcclxuICAgICAgICAgICAgdGhpcy5yZXZlcnREdXJhdGlvbiA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN0YXJ0KHNvdXJjZUVsLCBwYWdlWCwgcGFnZVkpIHtcclxuICAgICAgICAgICAgdGhpcy5zb3VyY2VFbCA9IHNvdXJjZUVsO1xyXG4gICAgICAgICAgICB0aGlzLnNvdXJjZUVsUmVjdCA9IHRoaXMuc291cmNlRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICAgICAgICAgIHRoaXMub3JpZ1NjcmVlblggPSBwYWdlWCAtIHdpbmRvdy5wYWdlWE9mZnNldDtcclxuICAgICAgICAgICAgdGhpcy5vcmlnU2NyZWVuWSA9IHBhZ2VZIC0gd2luZG93LnBhZ2VZT2Zmc2V0O1xyXG4gICAgICAgICAgICB0aGlzLmRlbHRhWCA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuZGVsdGFZID0gMDtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVFbFBvc2l0aW9uKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGhhbmRsZU1vdmUocGFnZVgsIHBhZ2VZKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGVsdGFYID0gKHBhZ2VYIC0gd2luZG93LnBhZ2VYT2Zmc2V0KSAtIHRoaXMub3JpZ1NjcmVlblg7XHJcbiAgICAgICAgICAgIHRoaXMuZGVsdGFZID0gKHBhZ2VZIC0gd2luZG93LnBhZ2VZT2Zmc2V0KSAtIHRoaXMub3JpZ1NjcmVlblk7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlRWxQb3NpdGlvbigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBjYW4gYmUgY2FsbGVkIGJlZm9yZSBzdGFydFxyXG4gICAgICAgIHNldElzVmlzaWJsZShib29sKSB7XHJcbiAgICAgICAgICAgIGlmIChib29sKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaXNWaXNpYmxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubWlycm9yRWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5taXJyb3JFbC5zdHlsZS5kaXNwbGF5ID0gJyc7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaXNWaXNpYmxlID0gYm9vbDsgLy8gbmVlZHMgdG8gaGFwcGVuIGJlZm9yZSB1cGRhdGVFbFBvc2l0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVFbFBvc2l0aW9uKCk7IC8vIGJlY2F1c2Ugd2FzIG5vdCB1cGRhdGluZyB0aGUgcG9zaXRpb24gd2hpbGUgaW52aXNpYmxlXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5pc1Zpc2libGUpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm1pcnJvckVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5taXJyb3JFbC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5pc1Zpc2libGUgPSBib29sO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGFsd2F5cyBhc3luY1xyXG4gICAgICAgIHN0b3AobmVlZHNSZXZlcnRBbmltYXRpb24sIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgIGxldCBkb25lID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhbnVwKCk7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBpZiAobmVlZHNSZXZlcnRBbmltYXRpb24gJiZcclxuICAgICAgICAgICAgICAgIHRoaXMubWlycm9yRWwgJiZcclxuICAgICAgICAgICAgICAgIHRoaXMuaXNWaXNpYmxlICYmXHJcbiAgICAgICAgICAgICAgICB0aGlzLnJldmVydER1cmF0aW9uICYmIC8vIGlmIDAsIHRyYW5zaXRpb24gd29uJ3Qgd29ya1xyXG4gICAgICAgICAgICAgICAgKHRoaXMuZGVsdGFYIHx8IHRoaXMuZGVsdGFZKSAvLyBpZiBzYW1lIGNvb3JkcywgdHJhbnNpdGlvbiB3b24ndCB3b3JrXHJcbiAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kb1JldmVydEFuaW1hdGlvbihkb25lLCB0aGlzLnJldmVydER1cmF0aW9uKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZG9uZSwgMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZG9SZXZlcnRBbmltYXRpb24oY2FsbGJhY2ssIHJldmVydER1cmF0aW9uKSB7XHJcbiAgICAgICAgICAgIGxldCBtaXJyb3JFbCA9IHRoaXMubWlycm9yRWw7XHJcbiAgICAgICAgICAgIGxldCBmaW5hbFNvdXJjZUVsUmVjdCA9IHRoaXMuc291cmNlRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7IC8vIGJlY2F1c2UgYXV0b3Njcm9sbGluZyBtaWdodCBoYXZlIGhhcHBlbmVkXHJcbiAgICAgICAgICAgIG1pcnJvckVsLnN0eWxlLnRyYW5zaXRpb24gPVxyXG4gICAgICAgICAgICAgICAgJ3RvcCAnICsgcmV2ZXJ0RHVyYXRpb24gKyAnbXMsJyArXHJcbiAgICAgICAgICAgICAgICAgICAgJ2xlZnQgJyArIHJldmVydER1cmF0aW9uICsgJ21zJztcclxuICAgICAgICAgICAgYXBwbHlTdHlsZShtaXJyb3JFbCwge1xyXG4gICAgICAgICAgICAgICAgbGVmdDogZmluYWxTb3VyY2VFbFJlY3QubGVmdCxcclxuICAgICAgICAgICAgICAgIHRvcDogZmluYWxTb3VyY2VFbFJlY3QudG9wLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgd2hlblRyYW5zaXRpb25Eb25lKG1pcnJvckVsLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBtaXJyb3JFbC5zdHlsZS50cmFuc2l0aW9uID0gJyc7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2xlYW51cCgpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMubWlycm9yRWwpIHtcclxuICAgICAgICAgICAgICAgIHJlbW92ZUVsZW1lbnQodGhpcy5taXJyb3JFbCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1pcnJvckVsID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnNvdXJjZUVsID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdXBkYXRlRWxQb3NpdGlvbigpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuc291cmNlRWwgJiYgdGhpcy5pc1Zpc2libGUpIHtcclxuICAgICAgICAgICAgICAgIGFwcGx5U3R5bGUodGhpcy5nZXRNaXJyb3JFbCgpLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogdGhpcy5zb3VyY2VFbFJlY3QubGVmdCArIHRoaXMuZGVsdGFYLFxyXG4gICAgICAgICAgICAgICAgICAgIHRvcDogdGhpcy5zb3VyY2VFbFJlY3QudG9wICsgdGhpcy5kZWx0YVksXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBnZXRNaXJyb3JFbCgpIHtcclxuICAgICAgICAgICAgbGV0IHNvdXJjZUVsUmVjdCA9IHRoaXMuc291cmNlRWxSZWN0O1xyXG4gICAgICAgICAgICBsZXQgbWlycm9yRWwgPSB0aGlzLm1pcnJvckVsO1xyXG4gICAgICAgICAgICBpZiAoIW1pcnJvckVsKSB7XHJcbiAgICAgICAgICAgICAgICBtaXJyb3JFbCA9IHRoaXMubWlycm9yRWwgPSB0aGlzLnNvdXJjZUVsLmNsb25lTm9kZSh0cnVlKTsgLy8gY2xvbmVDaGlsZHJlbj10cnVlXHJcbiAgICAgICAgICAgICAgICAvLyB3ZSBkb24ndCB3YW50IGxvbmcgdGFwcyBvciBhbnkgbW91c2UgaW50ZXJhY3Rpb24gY2F1c2luZyBzZWxlY3Rpb24vbWVudXMuXHJcbiAgICAgICAgICAgICAgICAvLyB3b3VsZCB1c2UgcHJldmVudFNlbGVjdGlvbigpLCBidXQgdGhhdCBwcmV2ZW50cyBzZWxlY3RzdGFydCwgY2F1c2luZyBwcm9ibGVtcy5cclxuICAgICAgICAgICAgICAgIG1pcnJvckVsLnN0eWxlLnVzZXJTZWxlY3QgPSAnbm9uZSc7XHJcbiAgICAgICAgICAgICAgICBtaXJyb3JFbC5jbGFzc0xpc3QuYWRkKCdmYy1ldmVudC1kcmFnZ2luZycpO1xyXG4gICAgICAgICAgICAgICAgYXBwbHlTdHlsZShtaXJyb3JFbCwge1xyXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAnZml4ZWQnLFxyXG4gICAgICAgICAgICAgICAgICAgIHpJbmRleDogdGhpcy56SW5kZXgsXHJcbiAgICAgICAgICAgICAgICAgICAgdmlzaWJpbGl0eTogJycsXHJcbiAgICAgICAgICAgICAgICAgICAgYm94U2l6aW5nOiAnYm9yZGVyLWJveCcsXHJcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHNvdXJjZUVsUmVjdC5yaWdodCAtIHNvdXJjZUVsUmVjdC5sZWZ0LFxyXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogc291cmNlRWxSZWN0LmJvdHRvbSAtIHNvdXJjZUVsUmVjdC50b3AsXHJcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQ6ICdhdXRvJyxcclxuICAgICAgICAgICAgICAgICAgICBib3R0b206ICdhdXRvJyxcclxuICAgICAgICAgICAgICAgICAgICBtYXJnaW46IDAsXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50Tm9kZS5hcHBlbmRDaGlsZChtaXJyb3JFbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG1pcnJvckVsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKlxyXG4gICAgSXMgYSBjYWNoZSBmb3IgYSBnaXZlbiBlbGVtZW50J3Mgc2Nyb2xsIGluZm9ybWF0aW9uIChhbGwgdGhlIGluZm8gdGhhdCBTY3JvbGxDb250cm9sbGVyIHN0b3JlcylcclxuICAgIGluIGFkZGl0aW9uIHRoZSBcImNsaWVudCByZWN0YW5nbGVcIiBvZiB0aGUgZWxlbWVudC4uIHRoZSBhcmVhIHdpdGhpbiB0aGUgc2Nyb2xsYmFycy5cclxuXHJcbiAgICBUaGUgY2FjaGUgY2FuIGJlIGluIG9uZSBvZiB0d28gbW9kZXM6XHJcbiAgICAtIGRvZXNMaXN0ZW5pbmc6ZmFsc2UgLSBpZ25vcmVzIHdoZW4gdGhlIGNvbnRhaW5lciBpcyBzY3JvbGxlZCBieSBzb21lb25lIGVsc2VcclxuICAgIC0gZG9lc0xpc3RlbmluZzp0cnVlIC0gd2F0Y2ggZm9yIHNjcm9sbGluZyBhbmQgdXBkYXRlIHRoZSBjYWNoZVxyXG4gICAgKi9cclxuICAgIGNsYXNzIFNjcm9sbEdlb21DYWNoZSBleHRlbmRzIFNjcm9sbENvbnRyb2xsZXIge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yKHNjcm9sbENvbnRyb2xsZXIsIGRvZXNMaXN0ZW5pbmcpIHtcclxuICAgICAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICAgICAgdGhpcy5oYW5kbGVTY3JvbGwgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbFRvcCA9IHRoaXMuc2Nyb2xsQ29udHJvbGxlci5nZXRTY3JvbGxUb3AoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsTGVmdCA9IHRoaXMuc2Nyb2xsQ29udHJvbGxlci5nZXRTY3JvbGxMZWZ0KCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVNjcm9sbENoYW5nZSgpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB0aGlzLnNjcm9sbENvbnRyb2xsZXIgPSBzY3JvbGxDb250cm9sbGVyO1xyXG4gICAgICAgICAgICB0aGlzLmRvZXNMaXN0ZW5pbmcgPSBkb2VzTGlzdGVuaW5nO1xyXG4gICAgICAgICAgICB0aGlzLnNjcm9sbFRvcCA9IHRoaXMub3JpZ1Njcm9sbFRvcCA9IHNjcm9sbENvbnRyb2xsZXIuZ2V0U2Nyb2xsVG9wKCk7XHJcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsTGVmdCA9IHRoaXMub3JpZ1Njcm9sbExlZnQgPSBzY3JvbGxDb250cm9sbGVyLmdldFNjcm9sbExlZnQoKTtcclxuICAgICAgICAgICAgdGhpcy5zY3JvbGxXaWR0aCA9IHNjcm9sbENvbnRyb2xsZXIuZ2V0U2Nyb2xsV2lkdGgoKTtcclxuICAgICAgICAgICAgdGhpcy5zY3JvbGxIZWlnaHQgPSBzY3JvbGxDb250cm9sbGVyLmdldFNjcm9sbEhlaWdodCgpO1xyXG4gICAgICAgICAgICB0aGlzLmNsaWVudFdpZHRoID0gc2Nyb2xsQ29udHJvbGxlci5nZXRDbGllbnRXaWR0aCgpO1xyXG4gICAgICAgICAgICB0aGlzLmNsaWVudEhlaWdodCA9IHNjcm9sbENvbnRyb2xsZXIuZ2V0Q2xpZW50SGVpZ2h0KCk7XHJcbiAgICAgICAgICAgIHRoaXMuY2xpZW50UmVjdCA9IHRoaXMuY29tcHV0ZUNsaWVudFJlY3QoKTsgLy8gZG8gbGFzdCBpbiBjYXNlIGl0IG5lZWRzIGNhY2hlZCB2YWx1ZXNcclxuICAgICAgICAgICAgaWYgKHRoaXMuZG9lc0xpc3RlbmluZykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5nZXRFdmVudFRhcmdldCgpLmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMuaGFuZGxlU2Nyb2xsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBkZXN0cm95KCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5kb2VzTGlzdGVuaW5nKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmdldEV2ZW50VGFyZ2V0KCkucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcy5oYW5kbGVTY3JvbGwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGdldFNjcm9sbFRvcCgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2Nyb2xsVG9wO1xyXG4gICAgICAgIH1cclxuICAgICAgICBnZXRTY3JvbGxMZWZ0KCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zY3JvbGxMZWZ0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBzZXRTY3JvbGxUb3AodG9wKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsQ29udHJvbGxlci5zZXRTY3JvbGxUb3AodG9wKTtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmRvZXNMaXN0ZW5pbmcpIHtcclxuICAgICAgICAgICAgICAgIC8vIHdlIGFyZSBub3QgcmVseWluZyBvbiB0aGUgZWxlbWVudCB0byBub3JtYWxpemUgb3V0LW9mLWJvdW5kcyBzY3JvbGwgdmFsdWVzXHJcbiAgICAgICAgICAgICAgICAvLyBzbyB3ZSBuZWVkIHRvIHNhbml0aXplIG91cnNlbHZlc1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxUb3AgPSBNYXRoLm1heChNYXRoLm1pbih0b3AsIHRoaXMuZ2V0TWF4U2Nyb2xsVG9wKCkpLCAwKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlU2Nyb2xsQ2hhbmdlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgc2V0U2Nyb2xsTGVmdCh0b3ApIHtcclxuICAgICAgICAgICAgdGhpcy5zY3JvbGxDb250cm9sbGVyLnNldFNjcm9sbExlZnQodG9wKTtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmRvZXNMaXN0ZW5pbmcpIHtcclxuICAgICAgICAgICAgICAgIC8vIHdlIGFyZSBub3QgcmVseWluZyBvbiB0aGUgZWxlbWVudCB0byBub3JtYWxpemUgb3V0LW9mLWJvdW5kcyBzY3JvbGwgdmFsdWVzXHJcbiAgICAgICAgICAgICAgICAvLyBzbyB3ZSBuZWVkIHRvIHNhbml0aXplIG91cnNlbHZlc1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxMZWZ0ID0gTWF0aC5tYXgoTWF0aC5taW4odG9wLCB0aGlzLmdldE1heFNjcm9sbExlZnQoKSksIDApO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVTY3JvbGxDaGFuZ2UoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBnZXRDbGllbnRXaWR0aCgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50V2lkdGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGdldENsaWVudEhlaWdodCgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50SGVpZ2h0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBnZXRTY3JvbGxXaWR0aCgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2Nyb2xsV2lkdGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGdldFNjcm9sbEhlaWdodCgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2Nyb2xsSGVpZ2h0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBoYW5kbGVTY3JvbGxDaGFuZ2UoKSB7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNsYXNzIEVsZW1lbnRTY3JvbGxHZW9tQ2FjaGUgZXh0ZW5kcyBTY3JvbGxHZW9tQ2FjaGUge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yKGVsLCBkb2VzTGlzdGVuaW5nKSB7XHJcbiAgICAgICAgICAgIHN1cGVyKG5ldyBFbGVtZW50U2Nyb2xsQ29udHJvbGxlcihlbCksIGRvZXNMaXN0ZW5pbmcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBnZXRFdmVudFRhcmdldCgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2Nyb2xsQ29udHJvbGxlci5lbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29tcHV0ZUNsaWVudFJlY3QoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjb21wdXRlSW5uZXJSZWN0KHRoaXMuc2Nyb2xsQ29udHJvbGxlci5lbCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNsYXNzIFdpbmRvd1Njcm9sbEdlb21DYWNoZSBleHRlbmRzIFNjcm9sbEdlb21DYWNoZSB7XHJcbiAgICAgICAgY29uc3RydWN0b3IoZG9lc0xpc3RlbmluZykge1xyXG4gICAgICAgICAgICBzdXBlcihuZXcgV2luZG93U2Nyb2xsQ29udHJvbGxlcigpLCBkb2VzTGlzdGVuaW5nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZ2V0RXZlbnRUYXJnZXQoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB3aW5kb3c7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbXB1dGVDbGllbnRSZWN0KCkge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgbGVmdDogdGhpcy5zY3JvbGxMZWZ0LFxyXG4gICAgICAgICAgICAgICAgcmlnaHQ6IHRoaXMuc2Nyb2xsTGVmdCArIHRoaXMuY2xpZW50V2lkdGgsXHJcbiAgICAgICAgICAgICAgICB0b3A6IHRoaXMuc2Nyb2xsVG9wLFxyXG4gICAgICAgICAgICAgICAgYm90dG9tOiB0aGlzLnNjcm9sbFRvcCArIHRoaXMuY2xpZW50SGVpZ2h0LFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyB0aGUgd2luZG93IGlzIHRoZSBvbmx5IHNjcm9sbCBvYmplY3QgdGhhdCBjaGFuZ2VzIGl0J3MgcmVjdGFuZ2xlIHJlbGF0aXZlXHJcbiAgICAgICAgLy8gdG8gdGhlIGRvY3VtZW50J3MgdG9wbGVmdCBhcyBpdCBzY3JvbGxzXHJcbiAgICAgICAgaGFuZGxlU2Nyb2xsQ2hhbmdlKCkge1xyXG4gICAgICAgICAgICB0aGlzLmNsaWVudFJlY3QgPSB0aGlzLmNvbXB1dGVDbGllbnRSZWN0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIElmIGF2YWlsYWJsZSB3ZSBhcmUgdXNpbmcgbmF0aXZlIFwicGVyZm9ybWFuY2VcIiBBUEkgaW5zdGVhZCBvZiBcIkRhdGVcIlxyXG4gICAgLy8gUmVhZCBtb3JlIGFib3V0IGl0IG9uIE1ETjpcclxuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9QZXJmb3JtYW5jZVxyXG4gICAgY29uc3QgZ2V0VGltZSA9IHR5cGVvZiBwZXJmb3JtYW5jZSA9PT0gJ2Z1bmN0aW9uJyA/IHBlcmZvcm1hbmNlLm5vdyA6IERhdGUubm93O1xyXG4gICAgLypcclxuICAgIEZvciBhIHBvaW50ZXIgaW50ZXJhY3Rpb24sIGF1dG9tYXRpY2FsbHkgc2Nyb2xscyBjZXJ0YWluIHNjcm9sbCBjb250YWluZXJzIHdoZW4gdGhlIHBvaW50ZXJcclxuICAgIGFwcHJvYWNoZXMgdGhlIGVkZ2UuXHJcblxyXG4gICAgVGhlIGNhbGxlciBtdXN0IGNhbGwgc3RhcnQgKyBoYW5kbGVNb3ZlICsgc3RvcC5cclxuICAgICovXHJcbiAgICBjbGFzcyBBdXRvU2Nyb2xsZXIge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgICAgICAvLyBvcHRpb25zIHRoYXQgY2FuIGJlIHNldCBieSBjYWxsZXJcclxuICAgICAgICAgICAgdGhpcy5pc0VuYWJsZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLnNjcm9sbFF1ZXJ5ID0gW3dpbmRvdywgJy5mYy1zY3JvbGxlciddO1xyXG4gICAgICAgICAgICB0aGlzLmVkZ2VUaHJlc2hvbGQgPSA1MDsgLy8gcGl4ZWxzXHJcbiAgICAgICAgICAgIHRoaXMubWF4VmVsb2NpdHkgPSAzMDA7IC8vIHBpeGVscyBwZXIgc2Vjb25kXHJcbiAgICAgICAgICAgIC8vIGludGVybmFsIHN0YXRlXHJcbiAgICAgICAgICAgIHRoaXMucG9pbnRlclNjcmVlblggPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLnBvaW50ZXJTY3JlZW5ZID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5pc0FuaW1hdGluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLnNjcm9sbENhY2hlcyA9IG51bGw7XHJcbiAgICAgICAgICAgIC8vIHByb3RlY3QgYWdhaW5zdCB0aGUgaW5pdGlhbCBwb2ludGVyZG93biBiZWluZyB0b28gY2xvc2UgdG8gYW4gZWRnZSBhbmQgc3RhcnRpbmcgdGhlIHNjcm9sbFxyXG4gICAgICAgICAgICB0aGlzLmV2ZXJNb3ZlZFVwID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuZXZlck1vdmVkRG93biA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLmV2ZXJNb3ZlZExlZnQgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5ldmVyTW92ZWRSaWdodCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLmFuaW1hdGUgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc0FuaW1hdGluZykgeyAvLyB3YXNuJ3QgY2FuY2VsbGVkIGJldHdlZW4gYW5pbWF0aW9uIGNhbGxzXHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGVkZ2UgPSB0aGlzLmNvbXB1dGVCZXN0RWRnZSh0aGlzLnBvaW50ZXJTY3JlZW5YICsgd2luZG93LnBhZ2VYT2Zmc2V0LCB0aGlzLnBvaW50ZXJTY3JlZW5ZICsgd2luZG93LnBhZ2VZT2Zmc2V0KTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZWRnZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbm93ID0gZ2V0VGltZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVNpZGUoZWRnZSwgKG5vdyAtIHRoaXMubXNTaW5jZVJlcXVlc3QpIC8gMTAwMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVxdWVzdEFuaW1hdGlvbihub3cpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pc0FuaW1hdGluZyA9IGZhbHNlOyAvLyB3aWxsIHN0b3AgYW5pbWF0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBzdGFydChwYWdlWCwgcGFnZVksIHNjcm9sbFN0YXJ0RWwpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaXNFbmFibGVkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbENhY2hlcyA9IHRoaXMuYnVpbGRDYWNoZXMoc2Nyb2xsU3RhcnRFbCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBvaW50ZXJTY3JlZW5YID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIHRoaXMucG9pbnRlclNjcmVlblkgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ldmVyTW92ZWRVcCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ldmVyTW92ZWREb3duID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZXJNb3ZlZExlZnQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZXZlck1vdmVkUmlnaHQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlTW92ZShwYWdlWCwgcGFnZVkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGhhbmRsZU1vdmUocGFnZVgsIHBhZ2VZKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmlzRW5hYmxlZCkge1xyXG4gICAgICAgICAgICAgICAgbGV0IHBvaW50ZXJTY3JlZW5YID0gcGFnZVggLSB3aW5kb3cucGFnZVhPZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICBsZXQgcG9pbnRlclNjcmVlblkgPSBwYWdlWSAtIHdpbmRvdy5wYWdlWU9mZnNldDtcclxuICAgICAgICAgICAgICAgIGxldCB5RGVsdGEgPSB0aGlzLnBvaW50ZXJTY3JlZW5ZID09PSBudWxsID8gMCA6IHBvaW50ZXJTY3JlZW5ZIC0gdGhpcy5wb2ludGVyU2NyZWVuWTtcclxuICAgICAgICAgICAgICAgIGxldCB4RGVsdGEgPSB0aGlzLnBvaW50ZXJTY3JlZW5YID09PSBudWxsID8gMCA6IHBvaW50ZXJTY3JlZW5YIC0gdGhpcy5wb2ludGVyU2NyZWVuWDtcclxuICAgICAgICAgICAgICAgIGlmICh5RGVsdGEgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ldmVyTW92ZWRVcCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh5RGVsdGEgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ldmVyTW92ZWREb3duID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh4RGVsdGEgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ldmVyTW92ZWRMZWZ0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHhEZWx0YSA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmV2ZXJNb3ZlZFJpZ2h0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMucG9pbnRlclNjcmVlblggPSBwb2ludGVyU2NyZWVuWDtcclxuICAgICAgICAgICAgICAgIHRoaXMucG9pbnRlclNjcmVlblkgPSBwb2ludGVyU2NyZWVuWTtcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5pc0FuaW1hdGluZykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaXNBbmltYXRpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVxdWVzdEFuaW1hdGlvbihnZXRUaW1lKCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN0b3AoKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmlzRW5hYmxlZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pc0FuaW1hdGluZyA9IGZhbHNlOyAvLyB3aWxsIHN0b3AgYW5pbWF0aW9uXHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBzY3JvbGxDYWNoZSBvZiB0aGlzLnNjcm9sbENhY2hlcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHNjcm9sbENhY2hlLmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsQ2FjaGVzID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uKG5vdykge1xyXG4gICAgICAgICAgICB0aGlzLm1zU2luY2VSZXF1ZXN0ID0gbm93O1xyXG4gICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5hbmltYXRlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaGFuZGxlU2lkZShlZGdlLCBzZWNvbmRzKSB7XHJcbiAgICAgICAgICAgIGxldCB7IHNjcm9sbENhY2hlIH0gPSBlZGdlO1xyXG4gICAgICAgICAgICBsZXQgeyBlZGdlVGhyZXNob2xkIH0gPSB0aGlzO1xyXG4gICAgICAgICAgICBsZXQgaW52RGlzdGFuY2UgPSBlZGdlVGhyZXNob2xkIC0gZWRnZS5kaXN0YW5jZTtcclxuICAgICAgICAgICAgbGV0IHZlbG9jaXR5ID0gLy8gdGhlIGNsb3NlciB0byB0aGUgZWRnZSwgdGhlIGZhc3RlciB3ZSBzY3JvbGxcclxuICAgICAgICAgICAgICgoaW52RGlzdGFuY2UgKiBpbnZEaXN0YW5jZSkgLyAoZWRnZVRocmVzaG9sZCAqIGVkZ2VUaHJlc2hvbGQpKSAqIC8vIHF1YWRyYXRpY1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tYXhWZWxvY2l0eSAqIHNlY29uZHM7XHJcbiAgICAgICAgICAgIGxldCBzaWduID0gMTtcclxuICAgICAgICAgICAgc3dpdGNoIChlZGdlLm5hbWUpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgJ2xlZnQnOlxyXG4gICAgICAgICAgICAgICAgICAgIHNpZ24gPSAtMTtcclxuICAgICAgICAgICAgICAgIC8vIGZhbGxzIHRocm91Z2hcclxuICAgICAgICAgICAgICAgIGNhc2UgJ3JpZ2h0JzpcclxuICAgICAgICAgICAgICAgICAgICBzY3JvbGxDYWNoZS5zZXRTY3JvbGxMZWZ0KHNjcm9sbENhY2hlLmdldFNjcm9sbExlZnQoKSArIHZlbG9jaXR5ICogc2lnbik7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlICd0b3AnOlxyXG4gICAgICAgICAgICAgICAgICAgIHNpZ24gPSAtMTtcclxuICAgICAgICAgICAgICAgIC8vIGZhbGxzIHRocm91Z2hcclxuICAgICAgICAgICAgICAgIGNhc2UgJ2JvdHRvbSc6XHJcbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsQ2FjaGUuc2V0U2Nyb2xsVG9wKHNjcm9sbENhY2hlLmdldFNjcm9sbFRvcCgpICsgdmVsb2NpdHkgKiBzaWduKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBsZWZ0L3RvcCBhcmUgcmVsYXRpdmUgdG8gZG9jdW1lbnQgdG9wbGVmdFxyXG4gICAgICAgIGNvbXB1dGVCZXN0RWRnZShsZWZ0LCB0b3ApIHtcclxuICAgICAgICAgICAgbGV0IHsgZWRnZVRocmVzaG9sZCB9ID0gdGhpcztcclxuICAgICAgICAgICAgbGV0IGJlc3RTaWRlID0gbnVsbDtcclxuICAgICAgICAgICAgbGV0IHNjcm9sbENhY2hlcyA9IHRoaXMuc2Nyb2xsQ2FjaGVzIHx8IFtdO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBzY3JvbGxDYWNoZSBvZiBzY3JvbGxDYWNoZXMpIHtcclxuICAgICAgICAgICAgICAgIGxldCByZWN0ID0gc2Nyb2xsQ2FjaGUuY2xpZW50UmVjdDtcclxuICAgICAgICAgICAgICAgIGxldCBsZWZ0RGlzdCA9IGxlZnQgLSByZWN0LmxlZnQ7XHJcbiAgICAgICAgICAgICAgICBsZXQgcmlnaHREaXN0ID0gcmVjdC5yaWdodCAtIGxlZnQ7XHJcbiAgICAgICAgICAgICAgICBsZXQgdG9wRGlzdCA9IHRvcCAtIHJlY3QudG9wO1xyXG4gICAgICAgICAgICAgICAgbGV0IGJvdHRvbURpc3QgPSByZWN0LmJvdHRvbSAtIHRvcDtcclxuICAgICAgICAgICAgICAgIC8vIGNvbXBsZXRlbHkgd2l0aGluIHRoZSByZWN0P1xyXG4gICAgICAgICAgICAgICAgaWYgKGxlZnREaXN0ID49IDAgJiYgcmlnaHREaXN0ID49IDAgJiYgdG9wRGlzdCA+PSAwICYmIGJvdHRvbURpc3QgPj0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0b3BEaXN0IDw9IGVkZ2VUaHJlc2hvbGQgJiYgdGhpcy5ldmVyTW92ZWRVcCAmJiBzY3JvbGxDYWNoZS5jYW5TY3JvbGxVcCgpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICghYmVzdFNpZGUgfHwgYmVzdFNpZGUuZGlzdGFuY2UgPiB0b3BEaXN0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0U2lkZSA9IHsgc2Nyb2xsQ2FjaGUsIG5hbWU6ICd0b3AnLCBkaXN0YW5jZTogdG9wRGlzdCB9O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoYm90dG9tRGlzdCA8PSBlZGdlVGhyZXNob2xkICYmIHRoaXMuZXZlck1vdmVkRG93biAmJiBzY3JvbGxDYWNoZS5jYW5TY3JvbGxEb3duKCkgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgKCFiZXN0U2lkZSB8fCBiZXN0U2lkZS5kaXN0YW5jZSA+IGJvdHRvbURpc3QpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RTaWRlID0geyBzY3JvbGxDYWNoZSwgbmFtZTogJ2JvdHRvbScsIGRpc3RhbmNlOiBib3R0b21EaXN0IH07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChsZWZ0RGlzdCA8PSBlZGdlVGhyZXNob2xkICYmIHRoaXMuZXZlck1vdmVkTGVmdCAmJiBzY3JvbGxDYWNoZS5jYW5TY3JvbGxMZWZ0KCkgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgKCFiZXN0U2lkZSB8fCBiZXN0U2lkZS5kaXN0YW5jZSA+IGxlZnREaXN0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0U2lkZSA9IHsgc2Nyb2xsQ2FjaGUsIG5hbWU6ICdsZWZ0JywgZGlzdGFuY2U6IGxlZnREaXN0IH07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyaWdodERpc3QgPD0gZWRnZVRocmVzaG9sZCAmJiB0aGlzLmV2ZXJNb3ZlZFJpZ2h0ICYmIHNjcm9sbENhY2hlLmNhblNjcm9sbFJpZ2h0KCkgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgKCFiZXN0U2lkZSB8fCBiZXN0U2lkZS5kaXN0YW5jZSA+IHJpZ2h0RGlzdCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYmVzdFNpZGUgPSB7IHNjcm9sbENhY2hlLCBuYW1lOiAncmlnaHQnLCBkaXN0YW5jZTogcmlnaHREaXN0IH07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBiZXN0U2lkZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYnVpbGRDYWNoZXMoc2Nyb2xsU3RhcnRFbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5xdWVyeVNjcm9sbEVscyhzY3JvbGxTdGFydEVsKS5tYXAoKGVsKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZWwgPT09IHdpbmRvdykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgV2luZG93U2Nyb2xsR2VvbUNhY2hlKGZhbHNlKTsgLy8gZmFsc2UgPSBkb24ndCBsaXN0ZW4gdG8gdXNlci1nZW5lcmF0ZWQgc2Nyb2xsc1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBFbGVtZW50U2Nyb2xsR2VvbUNhY2hlKGVsLCBmYWxzZSk7IC8vIGZhbHNlID0gZG9uJ3QgbGlzdGVuIHRvIHVzZXItZ2VuZXJhdGVkIHNjcm9sbHNcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHF1ZXJ5U2Nyb2xsRWxzKHNjcm9sbFN0YXJ0RWwpIHtcclxuICAgICAgICAgICAgbGV0IGVscyA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBxdWVyeSBvZiB0aGlzLnNjcm9sbFF1ZXJ5KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHF1ZXJ5ID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICAgICAgICAgIGVscy5wdXNoKHF1ZXJ5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGVscy5wdXNoKC4uLkFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHNjcm9sbFN0YXJ0RWwuZ2V0Um9vdE5vZGUoKS5xdWVyeVNlbGVjdG9yQWxsKHF1ZXJ5KSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBlbHM7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qXHJcbiAgICBNb25pdG9ycyBkcmFnZ2luZyBvbiBhbiBlbGVtZW50LiBIYXMgYSBudW1iZXIgb2YgaGlnaC1sZXZlbCBmZWF0dXJlczpcclxuICAgIC0gbWluaW11bSBkaXN0YW5jZSByZXF1aXJlZCBiZWZvcmUgZHJhZ2dpbmdcclxuICAgIC0gbWluaW11bSB3YWl0IHRpbWUgKFwiZGVsYXlcIikgYmVmb3JlIGRyYWdnaW5nXHJcbiAgICAtIGEgbWlycm9yIGVsZW1lbnQgdGhhdCBmb2xsb3dzIHRoZSBwb2ludGVyXHJcbiAgICAqL1xyXG4gICAgY2xhc3MgRmVhdHVyZWZ1bEVsZW1lbnREcmFnZ2luZyBleHRlbmRzIEVsZW1lbnREcmFnZ2luZyB7XHJcbiAgICAgICAgY29uc3RydWN0b3IoY29udGFpbmVyRWwsIHNlbGVjdG9yKSB7XHJcbiAgICAgICAgICAgIHN1cGVyKGNvbnRhaW5lckVsKTtcclxuICAgICAgICAgICAgdGhpcy5jb250YWluZXJFbCA9IGNvbnRhaW5lckVsO1xyXG4gICAgICAgICAgICAvLyBvcHRpb25zIHRoYXQgY2FuIGJlIGRpcmVjdGx5IHNldCBieSBjYWxsZXJcclxuICAgICAgICAgICAgLy8gdGhlIGNhbGxlciBjYW4gYWxzbyBzZXQgdGhlIFBvaW50ZXJEcmFnZ2luZydzIG9wdGlvbnMgYXMgd2VsbFxyXG4gICAgICAgICAgICB0aGlzLmRlbGF5ID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5taW5EaXN0YW5jZSA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMudG91Y2hTY3JvbGxBbGxvd2VkID0gdHJ1ZTsgLy8gcHJldmVudHMgZHJhZyBmcm9tIHN0YXJ0aW5nIGFuZCBibG9ja3Mgc2Nyb2xsaW5nIGR1cmluZyBkcmFnXHJcbiAgICAgICAgICAgIHRoaXMubWlycm9yTmVlZHNSZXZlcnQgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5pc0ludGVyYWN0aW5nID0gZmFsc2U7IC8vIGlzIHRoZSB1c2VyIHZhbGlkbHkgbW92aW5nIHRoZSBwb2ludGVyPyBsYXN0cyB1bnRpbCBwb2ludGVydXBcclxuICAgICAgICAgICAgdGhpcy5pc0RyYWdnaW5nID0gZmFsc2U7IC8vIGlzIGl0IElOVEVOVEZVTExZIGRyYWdnaW5nPyBsYXN0cyB1bnRpbCBhZnRlciByZXZlcnQgYW5pbWF0aW9uXHJcbiAgICAgICAgICAgIHRoaXMuaXNEZWxheUVuZGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuaXNEaXN0YW5jZVN1cnBhc3NlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLmRlbGF5VGltZW91dElkID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5vblBvaW50ZXJEb3duID0gKGV2KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaXNEcmFnZ2luZykgeyAvLyBzbyBuZXcgZHJhZyBkb2Vzbid0IGhhcHBlbiB3aGlsZSByZXZlcnQgYW5pbWF0aW9uIGlzIGdvaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pc0ludGVyYWN0aW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmlzRGVsYXlFbmRlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaXNEaXN0YW5jZVN1cnBhc3NlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIHByZXZlbnRTZWxlY3Rpb24oZG9jdW1lbnQuYm9keSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJldmVudENvbnRleHRNZW51KGRvY3VtZW50LmJvZHkpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHByZXZlbnQgbGlua3MgZnJvbSBiZWluZyB2aXNpdGVkIGlmIHRoZXJlJ3MgYW4gZXZlbnR1YWwgZHJhZy5cclxuICAgICAgICAgICAgICAgICAgICAvLyBhbHNvIHByZXZlbnRzIHNlbGVjdGlvbiBpbiBvbGRlciBicm93c2VycyAobWF5YmU/KS5cclxuICAgICAgICAgICAgICAgICAgICAvLyBub3QgbmVjZXNzYXJ5IGZvciB0b3VjaCwgYmVzaWRlcywgYnJvd3NlciB3b3VsZCBjb21wbGFpbiBhYm91dCBwYXNzaXZlbmVzcy5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWV2LmlzVG91Y2gpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXYub3JpZ0V2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdHRlci50cmlnZ2VyKCdwb2ludGVyZG93bicsIGV2KTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pc0ludGVyYWN0aW5nICYmIC8vIG5vdCBkZXN0cm95ZWQgdmlhIHBvaW50ZXJkb3duIGhhbmRsZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgIXRoaXMucG9pbnRlci5zaG91bGRJZ25vcmVNb3ZlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFjdGlvbnMgcmVsYXRlZCB0byBpbml0aWF0aW5nIGRyYWdzdGFydCtkcmFnbW92ZStkcmFnZW5kLi4uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWlycm9yLnNldElzVmlzaWJsZShmYWxzZSk7IC8vIHJlc2V0LiBjYWxsZXIgbXVzdCBzZXQtdmlzaWJsZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1pcnJvci5zdGFydChldi5zdWJqZWN0RWwsIGV2LnBhZ2VYLCBldi5wYWdlWSk7IC8vIG11c3QgaGFwcGVuIG9uIGZpcnN0IHBvaW50ZXIgZG93blxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0RGVsYXkoZXYpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMubWluRGlzdGFuY2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlRGlzdGFuY2VTdXJwYXNzZWQoZXYpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB0aGlzLm9uUG9pbnRlck1vdmUgPSAoZXYpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzSW50ZXJhY3RpbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXR0ZXIudHJpZ2dlcigncG9pbnRlcm1vdmUnLCBldik7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmlzRGlzdGFuY2VTdXJwYXNzZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG1pbkRpc3RhbmNlID0gdGhpcy5taW5EaXN0YW5jZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGRpc3RhbmNlU3E7IC8vIGN1cnJlbnQgZGlzdGFuY2UgZnJvbSB0aGUgb3JpZ2luLCBzcXVhcmVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB7IGRlbHRhWCwgZGVsdGFZIH0gPSBldjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzdGFuY2VTcSA9IGRlbHRhWCAqIGRlbHRhWCArIGRlbHRhWSAqIGRlbHRhWTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRpc3RhbmNlU3EgPj0gbWluRGlzdGFuY2UgKiBtaW5EaXN0YW5jZSkgeyAvLyB1c2UgcHl0aGFnb3JlYW4gdGhlb3JlbVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVEaXN0YW5jZVN1cnBhc3NlZChldik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNEcmFnZ2luZykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhIHJlYWwgcG9pbnRlciBtb3ZlPyAobm90IG9uZSBzaW11bGF0ZWQgYnkgc2Nyb2xsaW5nKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXYub3JpZ0V2ZW50LnR5cGUgIT09ICdzY3JvbGwnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1pcnJvci5oYW5kbGVNb3ZlKGV2LnBhZ2VYLCBldi5wYWdlWSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmF1dG9TY3JvbGxlci5oYW5kbGVNb3ZlKGV2LnBhZ2VYLCBldi5wYWdlWSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0dGVyLnRyaWdnZXIoJ2RyYWdtb3ZlJywgZXYpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdGhpcy5vblBvaW50ZXJVcCA9IChldikgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNJbnRlcmFjdGluZykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaXNJbnRlcmFjdGluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIGFsbG93U2VsZWN0aW9uKGRvY3VtZW50LmJvZHkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGFsbG93Q29udGV4dE1lbnUoZG9jdW1lbnQuYm9keSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0dGVyLnRyaWdnZXIoJ3BvaW50ZXJ1cCcsIGV2KTsgLy8gY2FuIHBvdGVudGlhbGx5IHNldCBtaXJyb3JOZWVkc1JldmVydFxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzRHJhZ2dpbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hdXRvU2Nyb2xsZXIuc3RvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRyeVN0b3BEcmFnKGV2KTsgLy8gd2hpY2ggd2lsbCBzdG9wIHRoZSBtaXJyb3JcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZGVsYXlUaW1lb3V0SWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuZGVsYXlUaW1lb3V0SWQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRlbGF5VGltZW91dElkID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGxldCBwb2ludGVyID0gdGhpcy5wb2ludGVyID0gbmV3IFBvaW50ZXJEcmFnZ2luZyhjb250YWluZXJFbCk7XHJcbiAgICAgICAgICAgIHBvaW50ZXIuZW1pdHRlci5vbigncG9pbnRlcmRvd24nLCB0aGlzLm9uUG9pbnRlckRvd24pO1xyXG4gICAgICAgICAgICBwb2ludGVyLmVtaXR0ZXIub24oJ3BvaW50ZXJtb3ZlJywgdGhpcy5vblBvaW50ZXJNb3ZlKTtcclxuICAgICAgICAgICAgcG9pbnRlci5lbWl0dGVyLm9uKCdwb2ludGVydXAnLCB0aGlzLm9uUG9pbnRlclVwKTtcclxuICAgICAgICAgICAgaWYgKHNlbGVjdG9yKSB7XHJcbiAgICAgICAgICAgICAgICBwb2ludGVyLnNlbGVjdG9yID0gc2VsZWN0b3I7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5taXJyb3IgPSBuZXcgRWxlbWVudE1pcnJvcigpO1xyXG4gICAgICAgICAgICB0aGlzLmF1dG9TY3JvbGxlciA9IG5ldyBBdXRvU2Nyb2xsZXIoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZGVzdHJveSgpIHtcclxuICAgICAgICAgICAgdGhpcy5wb2ludGVyLmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgLy8gSEFDSzogc2ltdWxhdGUgYSBwb2ludGVyLXVwIHRvIGVuZCB0aGUgY3VycmVudCBkcmFnXHJcbiAgICAgICAgICAgIC8vIFRPRE86IGZpcmUgJ2RyYWdlbmQnIGRpcmVjdGx5IGFuZCBzdG9wIGludGVyYWN0aW9uLiBkaXNjb3VyYWdlIHVzZSBvZiBwb2ludGVydXAgZXZlbnQgKGIvYyBtaWdodCBub3QgZmlyZSlcclxuICAgICAgICAgICAgdGhpcy5vblBvaW50ZXJVcCh7fSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN0YXJ0RGVsYXkoZXYpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmRlbGF5ID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kZWxheVRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVsYXlUaW1lb3V0SWQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlRGVsYXlFbmQoZXYpO1xyXG4gICAgICAgICAgICAgICAgfSwgdGhpcy5kZWxheSk7IC8vIG5vdCBhc3NpZ25hYmxlIHRvIG51bWJlciFcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlRGVsYXlFbmQoZXYpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGhhbmRsZURlbGF5RW5kKGV2KSB7XHJcbiAgICAgICAgICAgIHRoaXMuaXNEZWxheUVuZGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy50cnlTdGFydERyYWcoZXYpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBoYW5kbGVEaXN0YW5jZVN1cnBhc3NlZChldikge1xyXG4gICAgICAgICAgICB0aGlzLmlzRGlzdGFuY2VTdXJwYXNzZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLnRyeVN0YXJ0RHJhZyhldik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRyeVN0YXJ0RHJhZyhldikge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5pc0RlbGF5RW5kZWQgJiYgdGhpcy5pc0Rpc3RhbmNlU3VycGFzc2VkKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMucG9pbnRlci53YXNUb3VjaFNjcm9sbCB8fCB0aGlzLnRvdWNoU2Nyb2xsQWxsb3dlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaXNEcmFnZ2luZyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5taXJyb3JOZWVkc1JldmVydCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXV0b1Njcm9sbGVyLnN0YXJ0KGV2LnBhZ2VYLCBldi5wYWdlWSwgdGhpcy5jb250YWluZXJFbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0dGVyLnRyaWdnZXIoJ2RyYWdzdGFydCcsIGV2KTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy50b3VjaFNjcm9sbEFsbG93ZWQgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucG9pbnRlci5jYW5jZWxUb3VjaFNjcm9sbCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0cnlTdG9wRHJhZyhldikge1xyXG4gICAgICAgICAgICAvLyAuc3RvcCgpIGlzIEFMV0FZUyBhc3luY2hyb25vdXMsIHdoaWNoIHdlIE5FRUQgYmVjYXVzZSB3ZSB3YW50IGFsbCBwb2ludGVydXAgZXZlbnRzXHJcbiAgICAgICAgICAgIC8vIHRoYXQgY29tZSBmcm9tIHRoZSBkb2N1bWVudCB0byBmaXJlIGJlZm9yZWhhbmQuIG11Y2ggbW9yZSBjb252ZW5pZW50IHRoaXMgd2F5LlxyXG4gICAgICAgICAgICB0aGlzLm1pcnJvci5zdG9wKHRoaXMubWlycm9yTmVlZHNSZXZlcnQsIHRoaXMuc3RvcERyYWcuYmluZCh0aGlzLCBldikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzdG9wRHJhZyhldikge1xyXG4gICAgICAgICAgICB0aGlzLmlzRHJhZ2dpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5lbWl0dGVyLnRyaWdnZXIoJ2RyYWdlbmQnLCBldik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGZpbGwgaW4gdGhlIGltcGxlbWVudGF0aW9ucy4uLlxyXG4gICAgICAgIHNldElnbm9yZU1vdmUoYm9vbCkge1xyXG4gICAgICAgICAgICB0aGlzLnBvaW50ZXIuc2hvdWxkSWdub3JlTW92ZSA9IGJvb2w7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNldE1pcnJvcklzVmlzaWJsZShib29sKSB7XHJcbiAgICAgICAgICAgIHRoaXMubWlycm9yLnNldElzVmlzaWJsZShib29sKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc2V0TWlycm9yTmVlZHNSZXZlcnQoYm9vbCkge1xyXG4gICAgICAgICAgICB0aGlzLm1pcnJvck5lZWRzUmV2ZXJ0ID0gYm9vbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgc2V0QXV0b1Njcm9sbEVuYWJsZWQoYm9vbCkge1xyXG4gICAgICAgICAgICB0aGlzLmF1dG9TY3JvbGxlci5pc0VuYWJsZWQgPSBib29sO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKlxyXG4gICAgV2hlbiB0aGlzIGNsYXNzIGlzIGluc3RhbnRpYXRlZCwgaXQgcmVjb3JkcyB0aGUgb2Zmc2V0IG9mIGFuIGVsZW1lbnQgKHJlbGF0aXZlIHRvIHRoZSBkb2N1bWVudCB0b3BsZWZ0KSxcclxuICAgIGFuZCBjb250aW51ZXMgdG8gbW9uaXRvciBzY3JvbGxpbmcsIHVwZGF0aW5nIHRoZSBjYWNoZWQgY29vcmRpbmF0ZXMgaWYgaXQgbmVlZHMgdG8uXHJcbiAgICBEb2VzIG5vdCBhY2Nlc3MgdGhlIERPTSBhZnRlciBpbnN0YW50aWF0aW9uLCBzbyBoaWdobHkgcGVyZm9ybWFudC5cclxuXHJcbiAgICBBbHNvIGtlZXBzIHRyYWNrIG9mIGFsbCBzY3JvbGxpbmcvb3ZlcmZsb3c6aGlkZGVuIGNvbnRhaW5lcnMgdGhhdCBhcmUgcGFyZW50cyBvZiB0aGUgZ2l2ZW4gZWxlbWVudFxyXG4gICAgYW5kIGFuIGRldGVybWluZSBpZiBhIGdpdmVuIHBvaW50IGlzIGluc2lkZSB0aGUgY29tYmluZWQgY2xpcHBpbmcgcmVjdGFuZ2xlLlxyXG4gICAgKi9cclxuICAgIGNsYXNzIE9mZnNldFRyYWNrZXIge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yKGVsKSB7XHJcbiAgICAgICAgICAgIHRoaXMub3JpZ1JlY3QgPSBjb21wdXRlUmVjdChlbCk7XHJcbiAgICAgICAgICAgIC8vIHdpbGwgd29yayBmaW5lIGZvciBkaXZzIHRoYXQgaGF2ZSBvdmVyZmxvdzpoaWRkZW5cclxuICAgICAgICAgICAgdGhpcy5zY3JvbGxDYWNoZXMgPSBnZXRDbGlwcGluZ1BhcmVudHMoZWwpLm1hcCgoc2Nyb2xsRWwpID0+IG5ldyBFbGVtZW50U2Nyb2xsR2VvbUNhY2hlKHNjcm9sbEVsLCB0cnVlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRlc3Ryb3koKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IHNjcm9sbENhY2hlIG9mIHRoaXMuc2Nyb2xsQ2FjaGVzKSB7XHJcbiAgICAgICAgICAgICAgICBzY3JvbGxDYWNoZS5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY29tcHV0ZUxlZnQoKSB7XHJcbiAgICAgICAgICAgIGxldCBsZWZ0ID0gdGhpcy5vcmlnUmVjdC5sZWZ0O1xyXG4gICAgICAgICAgICBmb3IgKGxldCBzY3JvbGxDYWNoZSBvZiB0aGlzLnNjcm9sbENhY2hlcykge1xyXG4gICAgICAgICAgICAgICAgbGVmdCArPSBzY3JvbGxDYWNoZS5vcmlnU2Nyb2xsTGVmdCAtIHNjcm9sbENhY2hlLmdldFNjcm9sbExlZnQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbGVmdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29tcHV0ZVRvcCgpIHtcclxuICAgICAgICAgICAgbGV0IHRvcCA9IHRoaXMub3JpZ1JlY3QudG9wO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBzY3JvbGxDYWNoZSBvZiB0aGlzLnNjcm9sbENhY2hlcykge1xyXG4gICAgICAgICAgICAgICAgdG9wICs9IHNjcm9sbENhY2hlLm9yaWdTY3JvbGxUb3AgLSBzY3JvbGxDYWNoZS5nZXRTY3JvbGxUb3AoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdG9wO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpc1dpdGhpbkNsaXBwaW5nKHBhZ2VYLCBwYWdlWSkge1xyXG4gICAgICAgICAgICBsZXQgcG9pbnQgPSB7IGxlZnQ6IHBhZ2VYLCB0b3A6IHBhZ2VZIH07XHJcbiAgICAgICAgICAgIGZvciAobGV0IHNjcm9sbENhY2hlIG9mIHRoaXMuc2Nyb2xsQ2FjaGVzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzSWdub3JlZENsaXBwaW5nKHNjcm9sbENhY2hlLmdldEV2ZW50VGFyZ2V0KCkpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgIXBvaW50SW5zaWRlUmVjdChwb2ludCwgc2Nyb2xsQ2FjaGUuY2xpZW50UmVjdCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gY2VydGFpbiBjbGlwcGluZyBjb250YWluZXJzIHNob3VsZCBuZXZlciBjb25zdHJhaW4gaW50ZXJhY3Rpb25zLCBsaWtlIDxodG1sPiBhbmQgPGJvZHk+XHJcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZnVsbGNhbGVuZGFyL2Z1bGxjYWxlbmRhci9pc3N1ZXMvMzYxNVxyXG4gICAgZnVuY3Rpb24gaXNJZ25vcmVkQ2xpcHBpbmcobm9kZSkge1xyXG4gICAgICAgIGxldCB0YWdOYW1lID0gbm9kZS50YWdOYW1lO1xyXG4gICAgICAgIHJldHVybiB0YWdOYW1lID09PSAnSFRNTCcgfHwgdGFnTmFtZSA9PT0gJ0JPRFknO1xyXG4gICAgfVxyXG5cclxuICAgIC8qXHJcbiAgICBUcmFja3MgbW92ZW1lbnQgb3ZlciBtdWx0aXBsZSBkcm9wcGFibGUgYXJlYXMgKGFrYSBcImhpdHNcIilcclxuICAgIHRoYXQgZXhpc3QgaW4gb25lIG9yIG1vcmUgRGF0ZUNvbXBvbmVudHMuXHJcbiAgICBSZWxpZXMgb24gYW4gZXhpc3RpbmcgZHJhZ2dhYmxlLlxyXG5cclxuICAgIGVtaXRzOlxyXG4gICAgLSBwb2ludGVyZG93blxyXG4gICAgLSBkcmFnc3RhcnRcclxuICAgIC0gaGl0Y2hhbmdlIC0gZmlyZXMgaW5pdGlhbGx5LCBldmVuIGlmIG5vdCBvdmVyIGEgaGl0XHJcbiAgICAtIHBvaW50ZXJ1cFxyXG4gICAgLSAoaGl0Y2hhbmdlIC0gYWdhaW4sIHRvIG51bGwsIGlmIGVuZGVkIG92ZXIgYSBoaXQpXHJcbiAgICAtIGRyYWdlbmRcclxuICAgICovXHJcbiAgICBjbGFzcyBIaXREcmFnZ2luZyB7XHJcbiAgICAgICAgY29uc3RydWN0b3IoZHJhZ2dpbmcsIGRyb3BwYWJsZVN0b3JlKSB7XHJcbiAgICAgICAgICAgIC8vIG9wdGlvbnMgdGhhdCBjYW4gYmUgc2V0IGJ5IGNhbGxlclxyXG4gICAgICAgICAgICB0aGlzLnVzZVN1YmplY3RDZW50ZXIgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5yZXF1aXJlSW5pdGlhbCA9IHRydWU7IC8vIGlmIGRvZXNuJ3Qgc3RhcnQgb3V0IG9uIGEgaGl0LCB3b24ndCBlbWl0IGFueSBldmVudHNcclxuICAgICAgICAgICAgdGhpcy5pbml0aWFsSGl0ID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5tb3ZpbmdIaXQgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLmZpbmFsSGl0ID0gbnVsbDsgLy8gd29uJ3QgZXZlciBiZSBwb3B1bGF0ZWQgaWYgc2hvdWxkSWdub3JlTW92ZVxyXG4gICAgICAgICAgICB0aGlzLmhhbmRsZVBvaW50ZXJEb3duID0gKGV2KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBsZXQgeyBkcmFnZ2luZyB9ID0gdGhpcztcclxuICAgICAgICAgICAgICAgIHRoaXMuaW5pdGlhbEhpdCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1vdmluZ0hpdCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmZpbmFsSGl0ID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIHRoaXMucHJlcGFyZUhpdHMoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMucHJvY2Vzc0ZpcnN0Q29vcmQoZXYpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaW5pdGlhbEhpdCB8fCAhdGhpcy5yZXF1aXJlSW5pdGlhbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRyYWdnaW5nLnNldElnbm9yZU1vdmUoZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IGZpcmUgdGhpcyBiZWZvcmUgY29tcHV0aW5nIHByb2Nlc3NGaXJzdENvb3JkLCBzbyBsaXN0ZW5lcnMgY2FuIGNhbmNlbC4gdGhpcyBnZXRzIGZpcmVkIGJ5IGFsbW9zdCBldmVyeSBoYW5kbGVyIDooXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0dGVyLnRyaWdnZXIoJ3BvaW50ZXJkb3duJywgZXYpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZHJhZ2dpbmcuc2V0SWdub3JlTW92ZSh0cnVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdGhpcy5oYW5kbGVEcmFnU3RhcnQgPSAoZXYpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdHRlci50cmlnZ2VyKCdkcmFnc3RhcnQnLCBldik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZU1vdmUoZXYsIHRydWUpOyAvLyBmb3JjZSA9IGZpcmUgZXZlbiBpZiBpbml0aWFsbHkgbnVsbFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB0aGlzLmhhbmRsZURyYWdNb3ZlID0gKGV2KSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXR0ZXIudHJpZ2dlcignZHJhZ21vdmUnLCBldik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZU1vdmUoZXYpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB0aGlzLmhhbmRsZVBvaW50ZXJVcCA9IChldikgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZWxlYXNlSGl0cygpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0dGVyLnRyaWdnZXIoJ3BvaW50ZXJ1cCcsIGV2KTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdGhpcy5oYW5kbGVEcmFnRW5kID0gKGV2KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5tb3ZpbmdIaXQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXR0ZXIudHJpZ2dlcignaGl0dXBkYXRlJywgbnVsbCwgdHJ1ZSwgZXYpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5maW5hbEhpdCA9IHRoaXMubW92aW5nSGl0O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tb3ZpbmdIaXQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0dGVyLnRyaWdnZXIoJ2RyYWdlbmQnLCBldik7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHRoaXMuZHJvcHBhYmxlU3RvcmUgPSBkcm9wcGFibGVTdG9yZTtcclxuICAgICAgICAgICAgZHJhZ2dpbmcuZW1pdHRlci5vbigncG9pbnRlcmRvd24nLCB0aGlzLmhhbmRsZVBvaW50ZXJEb3duKTtcclxuICAgICAgICAgICAgZHJhZ2dpbmcuZW1pdHRlci5vbignZHJhZ3N0YXJ0JywgdGhpcy5oYW5kbGVEcmFnU3RhcnQpO1xyXG4gICAgICAgICAgICBkcmFnZ2luZy5lbWl0dGVyLm9uKCdkcmFnbW92ZScsIHRoaXMuaGFuZGxlRHJhZ01vdmUpO1xyXG4gICAgICAgICAgICBkcmFnZ2luZy5lbWl0dGVyLm9uKCdwb2ludGVydXAnLCB0aGlzLmhhbmRsZVBvaW50ZXJVcCk7XHJcbiAgICAgICAgICAgIGRyYWdnaW5nLmVtaXR0ZXIub24oJ2RyYWdlbmQnLCB0aGlzLmhhbmRsZURyYWdFbmQpO1xyXG4gICAgICAgICAgICB0aGlzLmRyYWdnaW5nID0gZHJhZ2dpbmc7XHJcbiAgICAgICAgICAgIHRoaXMuZW1pdHRlciA9IG5ldyBFbWl0dGVyKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHNldHMgaW5pdGlhbEhpdFxyXG4gICAgICAgIC8vIHNldHMgY29vcmRBZGp1c3RcclxuICAgICAgICBwcm9jZXNzRmlyc3RDb29yZChldikge1xyXG4gICAgICAgICAgICBsZXQgb3JpZ1BvaW50ID0geyBsZWZ0OiBldi5wYWdlWCwgdG9wOiBldi5wYWdlWSB9O1xyXG4gICAgICAgICAgICBsZXQgYWRqdXN0ZWRQb2ludCA9IG9yaWdQb2ludDtcclxuICAgICAgICAgICAgbGV0IHN1YmplY3RFbCA9IGV2LnN1YmplY3RFbDtcclxuICAgICAgICAgICAgbGV0IHN1YmplY3RSZWN0O1xyXG4gICAgICAgICAgICBpZiAoc3ViamVjdEVsIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHsgLy8gaS5lLiBub3QgYSBEb2N1bWVudC9TaGFkb3dSb290XHJcbiAgICAgICAgICAgICAgICBzdWJqZWN0UmVjdCA9IGNvbXB1dGVSZWN0KHN1YmplY3RFbCk7XHJcbiAgICAgICAgICAgICAgICBhZGp1c3RlZFBvaW50ID0gY29uc3RyYWluUG9pbnQoYWRqdXN0ZWRQb2ludCwgc3ViamVjdFJlY3QpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxldCBpbml0aWFsSGl0ID0gdGhpcy5pbml0aWFsSGl0ID0gdGhpcy5xdWVyeUhpdEZvck9mZnNldChhZGp1c3RlZFBvaW50LmxlZnQsIGFkanVzdGVkUG9pbnQudG9wKTtcclxuICAgICAgICAgICAgaWYgKGluaXRpYWxIaXQpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnVzZVN1YmplY3RDZW50ZXIgJiYgc3ViamVjdFJlY3QpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgc2xpY2VkU3ViamVjdFJlY3QgPSBpbnRlcnNlY3RSZWN0cyhzdWJqZWN0UmVjdCwgaW5pdGlhbEhpdC5yZWN0KTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2xpY2VkU3ViamVjdFJlY3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWRqdXN0ZWRQb2ludCA9IGdldFJlY3RDZW50ZXIoc2xpY2VkU3ViamVjdFJlY3QpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuY29vcmRBZGp1c3QgPSBkaWZmUG9pbnRzKGFkanVzdGVkUG9pbnQsIG9yaWdQb2ludCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvb3JkQWRqdXN0ID0geyBsZWZ0OiAwLCB0b3A6IDAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBoYW5kbGVNb3ZlKGV2LCBmb3JjZUhhbmRsZSkge1xyXG4gICAgICAgICAgICBsZXQgaGl0ID0gdGhpcy5xdWVyeUhpdEZvck9mZnNldChldi5wYWdlWCArIHRoaXMuY29vcmRBZGp1c3QubGVmdCwgZXYucGFnZVkgKyB0aGlzLmNvb3JkQWRqdXN0LnRvcCk7XHJcbiAgICAgICAgICAgIGlmIChmb3JjZUhhbmRsZSB8fCAhaXNIaXRzRXF1YWwodGhpcy5tb3ZpbmdIaXQsIGhpdCkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubW92aW5nSGl0ID0gaGl0O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0dGVyLnRyaWdnZXIoJ2hpdHVwZGF0ZScsIGhpdCwgZmFsc2UsIGV2KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBwcmVwYXJlSGl0cygpIHtcclxuICAgICAgICAgICAgdGhpcy5vZmZzZXRUcmFja2VycyA9IG1hcEhhc2godGhpcy5kcm9wcGFibGVTdG9yZSwgKGludGVyYWN0aW9uU2V0dGluZ3MpID0+IHtcclxuICAgICAgICAgICAgICAgIGludGVyYWN0aW9uU2V0dGluZ3MuY29tcG9uZW50LnByZXBhcmVIaXRzKCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IE9mZnNldFRyYWNrZXIoaW50ZXJhY3Rpb25TZXR0aW5ncy5lbCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZWxlYXNlSGl0cygpIHtcclxuICAgICAgICAgICAgbGV0IHsgb2Zmc2V0VHJhY2tlcnMgfSA9IHRoaXM7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGlkIGluIG9mZnNldFRyYWNrZXJzKSB7XHJcbiAgICAgICAgICAgICAgICBvZmZzZXRUcmFja2Vyc1tpZF0uZGVzdHJveSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMub2Zmc2V0VHJhY2tlcnMgPSB7fTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcXVlcnlIaXRGb3JPZmZzZXQob2Zmc2V0TGVmdCwgb2Zmc2V0VG9wKSB7XHJcbiAgICAgICAgICAgIGxldCB7IGRyb3BwYWJsZVN0b3JlLCBvZmZzZXRUcmFja2VycyB9ID0gdGhpcztcclxuICAgICAgICAgICAgbGV0IGJlc3RIaXQgPSBudWxsO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpZCBpbiBkcm9wcGFibGVTdG9yZSkge1xyXG4gICAgICAgICAgICAgICAgbGV0IGNvbXBvbmVudCA9IGRyb3BwYWJsZVN0b3JlW2lkXS5jb21wb25lbnQ7XHJcbiAgICAgICAgICAgICAgICBsZXQgb2Zmc2V0VHJhY2tlciA9IG9mZnNldFRyYWNrZXJzW2lkXTtcclxuICAgICAgICAgICAgICAgIGlmIChvZmZzZXRUcmFja2VyICYmIC8vIHdhc24ndCBkZXN0cm95ZWQgbWlkLWRyYWdcclxuICAgICAgICAgICAgICAgICAgICBvZmZzZXRUcmFja2VyLmlzV2l0aGluQ2xpcHBpbmcob2Zmc2V0TGVmdCwgb2Zmc2V0VG9wKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBvcmlnaW5MZWZ0ID0gb2Zmc2V0VHJhY2tlci5jb21wdXRlTGVmdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBvcmlnaW5Ub3AgPSBvZmZzZXRUcmFja2VyLmNvbXB1dGVUb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgcG9zaXRpb25MZWZ0ID0gb2Zmc2V0TGVmdCAtIG9yaWdpbkxlZnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBvc2l0aW9uVG9wID0gb2Zmc2V0VG9wIC0gb3JpZ2luVG9wO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCB7IG9yaWdSZWN0IH0gPSBvZmZzZXRUcmFja2VyO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCB3aWR0aCA9IG9yaWdSZWN0LnJpZ2h0IC0gb3JpZ1JlY3QubGVmdDtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgaGVpZ2h0ID0gb3JpZ1JlY3QuYm90dG9tIC0gb3JpZ1JlY3QudG9wO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgICAgICAgICAvLyBtdXN0IGJlIHdpdGhpbiB0aGUgZWxlbWVudCdzIGJvdW5kc1xyXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uTGVmdCA+PSAwICYmIHBvc2l0aW9uTGVmdCA8IHdpZHRoICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uVG9wID49IDAgJiYgcG9zaXRpb25Ub3AgPCBoZWlnaHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGhpdCA9IGNvbXBvbmVudC5xdWVyeUhpdChwb3NpdGlvbkxlZnQsIHBvc2l0aW9uVG9wLCB3aWR0aCwgaGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhpdCAmJiAoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSB0aGUgaGl0IGlzIHdpdGhpbiBhY3RpdmVSYW5nZSwgbWVhbmluZyBpdCdzIG5vdCBhIGRlYWQgY2VsbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByYW5nZUNvbnRhaW5zUmFuZ2UoaGl0LmRhdGVQcm9maWxlLmFjdGl2ZVJhbmdlLCBoaXQuZGF0ZVNwYW4ucmFuZ2UpKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKCFiZXN0SGl0IHx8IGhpdC5sYXllciA+IGJlc3RIaXQubGF5ZXIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaXQuY29tcG9uZW50SWQgPSBpZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhpdC5jb250ZXh0ID0gY29tcG9uZW50LmNvbnRleHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBiZXR0ZXIgd2F5IHRvIHJlLW9yaWVudCByZWN0YW5nbGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhpdC5yZWN0LmxlZnQgKz0gb3JpZ2luTGVmdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhpdC5yZWN0LnJpZ2h0ICs9IG9yaWdpbkxlZnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaXQucmVjdC50b3AgKz0gb3JpZ2luVG9wO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGl0LnJlY3QuYm90dG9tICs9IG9yaWdpblRvcDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RIaXQgPSBoaXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGJlc3RIaXQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gaXNIaXRzRXF1YWwoaGl0MCwgaGl0MSkge1xyXG4gICAgICAgIGlmICghaGl0MCAmJiAhaGl0MSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKEJvb2xlYW4oaGl0MCkgIT09IEJvb2xlYW4oaGl0MSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaXNEYXRlU3BhbnNFcXVhbChoaXQwLmRhdGVTcGFuLCBoaXQxLmRhdGVTcGFuKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBidWlsZERhdGVQb2ludEFwaVdpdGhDb250ZXh0KGRhdGVTcGFuLCBjb250ZXh0KSB7XHJcbiAgICAgICAgbGV0IHByb3BzID0ge307XHJcbiAgICAgICAgZm9yIChsZXQgdHJhbnNmb3JtIG9mIGNvbnRleHQucGx1Z2luSG9va3MuZGF0ZVBvaW50VHJhbnNmb3Jtcykge1xyXG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHByb3BzLCB0cmFuc2Zvcm0oZGF0ZVNwYW4sIGNvbnRleHQpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgT2JqZWN0LmFzc2lnbihwcm9wcywgYnVpbGREYXRlUG9pbnRBcGkoZGF0ZVNwYW4sIGNvbnRleHQuZGF0ZUVudikpO1xyXG4gICAgICAgIHJldHVybiBwcm9wcztcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGJ1aWxkRGF0ZVBvaW50QXBpKHNwYW4sIGRhdGVFbnYpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBkYXRlOiBkYXRlRW52LnRvRGF0ZShzcGFuLnJhbmdlLnN0YXJ0KSxcclxuICAgICAgICAgICAgZGF0ZVN0cjogZGF0ZUVudi5mb3JtYXRJc28oc3Bhbi5yYW5nZS5zdGFydCwgeyBvbWl0VGltZTogc3Bhbi5hbGxEYXkgfSksXHJcbiAgICAgICAgICAgIGFsbERheTogc3Bhbi5hbGxEYXksXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICAvKlxyXG4gICAgTW9uaXRvcnMgd2hlbiB0aGUgdXNlciBjbGlja3Mgb24gYSBzcGVjaWZpYyBkYXRlL3RpbWUgb2YgYSBjb21wb25lbnQuXHJcbiAgICBBIHBvaW50ZXJkb3duK3BvaW50ZXJ1cCBvbiB0aGUgc2FtZSBcImhpdFwiIGNvbnN0aXR1dGVzIGEgY2xpY2suXHJcbiAgICAqL1xyXG4gICAgY2xhc3MgRGF0ZUNsaWNraW5nIGV4dGVuZHMgSW50ZXJhY3Rpb24ge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yKHNldHRpbmdzKSB7XHJcbiAgICAgICAgICAgIHN1cGVyKHNldHRpbmdzKTtcclxuICAgICAgICAgICAgdGhpcy5oYW5kbGVQb2ludGVyRG93biA9IChwZXYpID0+IHtcclxuICAgICAgICAgICAgICAgIGxldCB7IGRyYWdnaW5nIH0gPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgbGV0IGRvd25FbCA9IHBldi5vcmlnRXZlbnQudGFyZ2V0O1xyXG4gICAgICAgICAgICAgICAgLy8gZG8gdGhpcyBpbiBwb2ludGVyZG93biAobm90IGRyYWdlbmQpIGJlY2F1c2UgRE9NIG1pZ2h0IGJlIG11dGF0ZWQgYnkgdGhlIHRpbWUgZHJhZ2VuZCBpcyBmaXJlZFxyXG4gICAgICAgICAgICAgICAgZHJhZ2dpbmcuc2V0SWdub3JlTW92ZSghdGhpcy5jb21wb25lbnQuaXNWYWxpZERhdGVEb3duRWwoZG93bkVsKSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8vIHdvbid0IGV2ZW4gZmlyZSBpZiBtb3Zpbmcgd2FzIGlnbm9yZWRcclxuICAgICAgICAgICAgdGhpcy5oYW5kbGVEcmFnRW5kID0gKGV2KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBsZXQgeyBjb21wb25lbnQgfSA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICBsZXQgeyBwb2ludGVyIH0gPSB0aGlzLmRyYWdnaW5nO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFwb2ludGVyLndhc1RvdWNoU2Nyb2xsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHsgaW5pdGlhbEhpdCwgZmluYWxIaXQgfSA9IHRoaXMuaGl0RHJhZ2dpbmc7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluaXRpYWxIaXQgJiYgZmluYWxIaXQgJiYgaXNIaXRzRXF1YWwoaW5pdGlhbEhpdCwgZmluYWxIaXQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB7IGNvbnRleHQgfSA9IGNvbXBvbmVudDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGFyZyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgYnVpbGREYXRlUG9pbnRBcGlXaXRoQ29udGV4dChpbml0aWFsSGl0LmRhdGVTcGFuLCBjb250ZXh0KSksIHsgZGF5RWw6IGluaXRpYWxIaXQuZGF5RWwsIGpzRXZlbnQ6IGV2Lm9yaWdFdmVudCwgdmlldzogY29udGV4dC52aWV3QXBpIHx8IGNvbnRleHQuY2FsZW5kYXJBcGkudmlldyB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5lbWl0dGVyLnRyaWdnZXIoJ2RhdGVDbGljaycsIGFyZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvLyB3ZSBETyB3YW50IHRvIHdhdGNoIHBvaW50ZXIgbW92ZXMgYmVjYXVzZSBvdGhlcndpc2UgZmluYWxIaXQgd29uJ3QgZ2V0IHBvcHVsYXRlZFxyXG4gICAgICAgICAgICB0aGlzLmRyYWdnaW5nID0gbmV3IEZlYXR1cmVmdWxFbGVtZW50RHJhZ2dpbmcoc2V0dGluZ3MuZWwpO1xyXG4gICAgICAgICAgICB0aGlzLmRyYWdnaW5nLmF1dG9TY3JvbGxlci5pc0VuYWJsZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgbGV0IGhpdERyYWdnaW5nID0gdGhpcy5oaXREcmFnZ2luZyA9IG5ldyBIaXREcmFnZ2luZyh0aGlzLmRyYWdnaW5nLCBpbnRlcmFjdGlvblNldHRpbmdzVG9TdG9yZShzZXR0aW5ncykpO1xyXG4gICAgICAgICAgICBoaXREcmFnZ2luZy5lbWl0dGVyLm9uKCdwb2ludGVyZG93bicsIHRoaXMuaGFuZGxlUG9pbnRlckRvd24pO1xyXG4gICAgICAgICAgICBoaXREcmFnZ2luZy5lbWl0dGVyLm9uKCdkcmFnZW5kJywgdGhpcy5oYW5kbGVEcmFnRW5kKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZGVzdHJveSgpIHtcclxuICAgICAgICAgICAgdGhpcy5kcmFnZ2luZy5kZXN0cm95KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qXHJcbiAgICBUcmFja3Mgd2hlbiB0aGUgdXNlciBzZWxlY3RzIGEgcG9ydGlvbiBvZiB0aW1lIG9mIGEgY29tcG9uZW50LFxyXG4gICAgY29uc3RpdHV0ZWQgYnkgYSBkcmFnIG92ZXIgZGF0ZSBjZWxscywgd2l0aCBhIHBvc3NpYmxlIGRlbGF5IGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGRyYWcuXHJcbiAgICAqL1xyXG4gICAgY2xhc3MgRGF0ZVNlbGVjdGluZyBleHRlbmRzIEludGVyYWN0aW9uIHtcclxuICAgICAgICBjb25zdHJ1Y3RvcihzZXR0aW5ncykge1xyXG4gICAgICAgICAgICBzdXBlcihzZXR0aW5ncyk7XHJcbiAgICAgICAgICAgIHRoaXMuZHJhZ1NlbGVjdGlvbiA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlUG9pbnRlckRvd24gPSAoZXYpID0+IHtcclxuICAgICAgICAgICAgICAgIGxldCB7IGNvbXBvbmVudCwgZHJhZ2dpbmcgfSA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICBsZXQgeyBvcHRpb25zIH0gPSBjb21wb25lbnQuY29udGV4dDtcclxuICAgICAgICAgICAgICAgIGxldCBjYW5TZWxlY3QgPSBvcHRpb25zLnNlbGVjdGFibGUgJiZcclxuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQuaXNWYWxpZERhdGVEb3duRWwoZXYub3JpZ0V2ZW50LnRhcmdldCk7XHJcbiAgICAgICAgICAgICAgICAvLyBkb24ndCBib3RoZXIgdG8gd2F0Y2ggZXhwZW5zaXZlIG1vdmVzIGlmIGNvbXBvbmVudCB3b24ndCBkbyBzZWxlY3Rpb25cclxuICAgICAgICAgICAgICAgIGRyYWdnaW5nLnNldElnbm9yZU1vdmUoIWNhblNlbGVjdCk7XHJcbiAgICAgICAgICAgICAgICAvLyBpZiB0b3VjaCwgcmVxdWlyZSB1c2VyIHRvIGhvbGQgZG93blxyXG4gICAgICAgICAgICAgICAgZHJhZ2dpbmcuZGVsYXkgPSBldi5pc1RvdWNoID8gZ2V0Q29tcG9uZW50VG91Y2hEZWxheSQxKGNvbXBvbmVudCkgOiBudWxsO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB0aGlzLmhhbmRsZURyYWdTdGFydCA9IChldikgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb21wb25lbnQuY29udGV4dC5jYWxlbmRhckFwaS51bnNlbGVjdChldik7IC8vIHVuc2VsZWN0IHByZXZpb3VzIHNlbGVjdGlvbnNcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdGhpcy5oYW5kbGVIaXRVcGRhdGUgPSAoaGl0LCBpc0ZpbmFsKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBsZXQgeyBjb250ZXh0IH0gPSB0aGlzLmNvbXBvbmVudDtcclxuICAgICAgICAgICAgICAgIGxldCBkcmFnU2VsZWN0aW9uID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIGxldCBpc0ludmFsaWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGlmIChoaXQpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgaW5pdGlhbEhpdCA9IHRoaXMuaGl0RHJhZ2dpbmcuaW5pdGlhbEhpdDtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgZGlzYWxsb3dlZCA9IGhpdC5jb21wb25lbnRJZCA9PT0gaW5pdGlhbEhpdC5jb21wb25lbnRJZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAmJiB0aGlzLmlzSGl0Q29tYm9BbGxvd2VkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICYmICF0aGlzLmlzSGl0Q29tYm9BbGxvd2VkKGluaXRpYWxIaXQsIGhpdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkaXNhbGxvd2VkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyYWdTZWxlY3Rpb24gPSBqb2luSGl0c0ludG9TZWxlY3Rpb24oaW5pdGlhbEhpdCwgaGl0LCBjb250ZXh0LnBsdWdpbkhvb2tzLmRhdGVTZWxlY3Rpb25UcmFuc2Zvcm1lcnMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWRyYWdTZWxlY3Rpb24gfHwgIWlzRGF0ZVNlbGVjdGlvblZhbGlkKGRyYWdTZWxlY3Rpb24sIGhpdC5kYXRlUHJvZmlsZSwgY29udGV4dCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXNJbnZhbGlkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZHJhZ1NlbGVjdGlvbiA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGRyYWdTZWxlY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmRpc3BhdGNoKHsgdHlwZTogJ1NFTEVDVF9EQVRFUycsIHNlbGVjdGlvbjogZHJhZ1NlbGVjdGlvbiB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFpc0ZpbmFsKSB7IC8vIG9ubHkgdW5zZWxlY3QgaWYgbW92ZWQgYXdheSB3aGlsZSBkcmFnZ2luZ1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuZGlzcGF0Y2goeyB0eXBlOiAnVU5TRUxFQ1RfREFURVMnIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCFpc0ludmFsaWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBlbmFibGVDdXJzb3IoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGRpc2FibGVDdXJzb3IoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICghaXNGaW5hbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhZ1NlbGVjdGlvbiA9IGRyYWdTZWxlY3Rpb247IC8vIG9ubHkgY2xlYXIgaWYgbW92ZWQgYXdheSBmcm9tIGFsbCBoaXRzIHdoaWxlIGRyYWdnaW5nXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlUG9pbnRlclVwID0gKHBldikgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZHJhZ1NlbGVjdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHNlbGVjdGlvbiBpcyBhbHJlYWR5IHJlbmRlcmVkLCBzbyBqdXN0IG5lZWQgdG8gcmVwb3J0IHNlbGVjdGlvblxyXG4gICAgICAgICAgICAgICAgICAgIHRyaWdnZXJEYXRlU2VsZWN0KHRoaXMuZHJhZ1NlbGVjdGlvbiwgcGV2LCB0aGlzLmNvbXBvbmVudC5jb250ZXh0KTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYWdTZWxlY3Rpb24gPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBsZXQgeyBjb21wb25lbnQgfSA9IHNldHRpbmdzO1xyXG4gICAgICAgICAgICBsZXQgeyBvcHRpb25zIH0gPSBjb21wb25lbnQuY29udGV4dDtcclxuICAgICAgICAgICAgbGV0IGRyYWdnaW5nID0gdGhpcy5kcmFnZ2luZyA9IG5ldyBGZWF0dXJlZnVsRWxlbWVudERyYWdnaW5nKHNldHRpbmdzLmVsKTtcclxuICAgICAgICAgICAgZHJhZ2dpbmcudG91Y2hTY3JvbGxBbGxvd2VkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGRyYWdnaW5nLm1pbkRpc3RhbmNlID0gb3B0aW9ucy5zZWxlY3RNaW5EaXN0YW5jZSB8fCAwO1xyXG4gICAgICAgICAgICBkcmFnZ2luZy5hdXRvU2Nyb2xsZXIuaXNFbmFibGVkID0gb3B0aW9ucy5kcmFnU2Nyb2xsO1xyXG4gICAgICAgICAgICBsZXQgaGl0RHJhZ2dpbmcgPSB0aGlzLmhpdERyYWdnaW5nID0gbmV3IEhpdERyYWdnaW5nKHRoaXMuZHJhZ2dpbmcsIGludGVyYWN0aW9uU2V0dGluZ3NUb1N0b3JlKHNldHRpbmdzKSk7XHJcbiAgICAgICAgICAgIGhpdERyYWdnaW5nLmVtaXR0ZXIub24oJ3BvaW50ZXJkb3duJywgdGhpcy5oYW5kbGVQb2ludGVyRG93bik7XHJcbiAgICAgICAgICAgIGhpdERyYWdnaW5nLmVtaXR0ZXIub24oJ2RyYWdzdGFydCcsIHRoaXMuaGFuZGxlRHJhZ1N0YXJ0KTtcclxuICAgICAgICAgICAgaGl0RHJhZ2dpbmcuZW1pdHRlci5vbignaGl0dXBkYXRlJywgdGhpcy5oYW5kbGVIaXRVcGRhdGUpO1xyXG4gICAgICAgICAgICBoaXREcmFnZ2luZy5lbWl0dGVyLm9uKCdwb2ludGVydXAnLCB0aGlzLmhhbmRsZVBvaW50ZXJVcCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRlc3Ryb3koKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmcuZGVzdHJveSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGdldENvbXBvbmVudFRvdWNoRGVsYXkkMShjb21wb25lbnQpIHtcclxuICAgICAgICBsZXQgeyBvcHRpb25zIH0gPSBjb21wb25lbnQuY29udGV4dDtcclxuICAgICAgICBsZXQgZGVsYXkgPSBvcHRpb25zLnNlbGVjdExvbmdQcmVzc0RlbGF5O1xyXG4gICAgICAgIGlmIChkZWxheSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGRlbGF5ID0gb3B0aW9ucy5sb25nUHJlc3NEZWxheTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGRlbGF5O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gam9pbkhpdHNJbnRvU2VsZWN0aW9uKGhpdDAsIGhpdDEsIGRhdGVTZWxlY3Rpb25UcmFuc2Zvcm1lcnMpIHtcclxuICAgICAgICBsZXQgZGF0ZVNwYW4wID0gaGl0MC5kYXRlU3BhbjtcclxuICAgICAgICBsZXQgZGF0ZVNwYW4xID0gaGl0MS5kYXRlU3BhbjtcclxuICAgICAgICBsZXQgbXMgPSBbXHJcbiAgICAgICAgICAgIGRhdGVTcGFuMC5yYW5nZS5zdGFydCxcclxuICAgICAgICAgICAgZGF0ZVNwYW4wLnJhbmdlLmVuZCxcclxuICAgICAgICAgICAgZGF0ZVNwYW4xLnJhbmdlLnN0YXJ0LFxyXG4gICAgICAgICAgICBkYXRlU3BhbjEucmFuZ2UuZW5kLFxyXG4gICAgICAgIF07XHJcbiAgICAgICAgbXMuc29ydChjb21wYXJlTnVtYmVycyk7XHJcbiAgICAgICAgbGV0IHByb3BzID0ge307XHJcbiAgICAgICAgZm9yIChsZXQgdHJhbnNmb3JtZXIgb2YgZGF0ZVNlbGVjdGlvblRyYW5zZm9ybWVycykge1xyXG4gICAgICAgICAgICBsZXQgcmVzID0gdHJhbnNmb3JtZXIoaGl0MCwgaGl0MSk7XHJcbiAgICAgICAgICAgIGlmIChyZXMgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocmVzKSB7XHJcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHByb3BzLCByZXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHByb3BzLnJhbmdlID0geyBzdGFydDogbXNbMF0sIGVuZDogbXNbM10gfTtcclxuICAgICAgICBwcm9wcy5hbGxEYXkgPSBkYXRlU3BhbjAuYWxsRGF5O1xyXG4gICAgICAgIHJldHVybiBwcm9wcztcclxuICAgIH1cclxuXHJcbiAgICBjbGFzcyBFdmVudERyYWdnaW5nIGV4dGVuZHMgSW50ZXJhY3Rpb24ge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yKHNldHRpbmdzKSB7XHJcbiAgICAgICAgICAgIHN1cGVyKHNldHRpbmdzKTtcclxuICAgICAgICAgICAgLy8gaW50ZXJuYWwgc3RhdGVcclxuICAgICAgICAgICAgdGhpcy5zdWJqZWN0RWwgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLnN1YmplY3RTZWcgPSBudWxsOyAvLyB0aGUgc2VnIGJlaW5nIHNlbGVjdGVkL2RyYWdnZWRcclxuICAgICAgICAgICAgdGhpcy5pc0RyYWdnaW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnRSYW5nZSA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMucmVsZXZhbnRFdmVudHMgPSBudWxsOyAvLyB0aGUgZXZlbnRzIGJlaW5nIGRyYWdnZWRcclxuICAgICAgICAgICAgdGhpcy5yZWNlaXZpbmdDb250ZXh0ID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy52YWxpZE11dGF0aW9uID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5tdXRhdGVkUmVsZXZhbnRFdmVudHMgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLmhhbmRsZVBvaW50ZXJEb3duID0gKGV2KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBsZXQgb3JpZ1RhcmdldCA9IGV2Lm9yaWdFdmVudC50YXJnZXQ7XHJcbiAgICAgICAgICAgICAgICBsZXQgeyBjb21wb25lbnQsIGRyYWdnaW5nIH0gPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgbGV0IHsgbWlycm9yIH0gPSBkcmFnZ2luZztcclxuICAgICAgICAgICAgICAgIGxldCB7IG9wdGlvbnMgfSA9IGNvbXBvbmVudC5jb250ZXh0O1xyXG4gICAgICAgICAgICAgICAgbGV0IGluaXRpYWxDb250ZXh0ID0gY29tcG9uZW50LmNvbnRleHQ7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN1YmplY3RFbCA9IGV2LnN1YmplY3RFbDtcclxuICAgICAgICAgICAgICAgIGxldCBzdWJqZWN0U2VnID0gdGhpcy5zdWJqZWN0U2VnID0gZ2V0RWxTZWcoZXYuc3ViamVjdEVsKTtcclxuICAgICAgICAgICAgICAgIGxldCBldmVudFJhbmdlID0gdGhpcy5ldmVudFJhbmdlID0gc3ViamVjdFNlZy5ldmVudFJhbmdlO1xyXG4gICAgICAgICAgICAgICAgbGV0IGV2ZW50SW5zdGFuY2VJZCA9IGV2ZW50UmFuZ2UuaW5zdGFuY2UuaW5zdGFuY2VJZDtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVsZXZhbnRFdmVudHMgPSBnZXRSZWxldmFudEV2ZW50cyhpbml0aWFsQ29udGV4dC5nZXRDdXJyZW50RGF0YSgpLmV2ZW50U3RvcmUsIGV2ZW50SW5zdGFuY2VJZCk7XHJcbiAgICAgICAgICAgICAgICBkcmFnZ2luZy5taW5EaXN0YW5jZSA9IGV2LmlzVG91Y2ggPyAwIDogb3B0aW9ucy5ldmVudERyYWdNaW5EaXN0YW5jZTtcclxuICAgICAgICAgICAgICAgIGRyYWdnaW5nLmRlbGF5ID1cclxuICAgICAgICAgICAgICAgICAgICAvLyBvbmx5IGRvIGEgdG91Y2ggZGVsYXkgaWYgdG91Y2ggYW5kIHRoaXMgZXZlbnQgaGFzbid0IGJlZW4gc2VsZWN0ZWQgeWV0XHJcbiAgICAgICAgICAgICAgICAgICAgKGV2LmlzVG91Y2ggJiYgZXZlbnRJbnN0YW5jZUlkICE9PSBjb21wb25lbnQucHJvcHMuZXZlbnRTZWxlY3Rpb24pID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0Q29tcG9uZW50VG91Y2hEZWxheShjb21wb25lbnQpIDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgbnVsbDtcclxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmZpeGVkTWlycm9yUGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWlycm9yLnBhcmVudE5vZGUgPSBvcHRpb25zLmZpeGVkTWlycm9yUGFyZW50O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWlycm9yLnBhcmVudE5vZGUgPSBlbGVtZW50Q2xvc2VzdChvcmlnVGFyZ2V0LCAnLmZjJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBtaXJyb3IucmV2ZXJ0RHVyYXRpb24gPSBvcHRpb25zLmRyYWdSZXZlcnREdXJhdGlvbjtcclxuICAgICAgICAgICAgICAgIGxldCBpc1ZhbGlkID0gY29tcG9uZW50LmlzVmFsaWRTZWdEb3duRWwob3JpZ1RhcmdldCkgJiZcclxuICAgICAgICAgICAgICAgICAgICAhZWxlbWVudENsb3Nlc3Qob3JpZ1RhcmdldCwgJy5mYy1ldmVudC1yZXNpemVyJyk7IC8vIE5PVCBvbiBhIHJlc2l6ZXJcclxuICAgICAgICAgICAgICAgIGRyYWdnaW5nLnNldElnbm9yZU1vdmUoIWlzVmFsaWQpO1xyXG4gICAgICAgICAgICAgICAgLy8gZGlzYWJsZSBkcmFnZ2luZyBmb3IgZWxlbWVudHMgdGhhdCBhcmUgcmVzaXphYmxlIChpZSwgc2VsZWN0YWJsZSlcclxuICAgICAgICAgICAgICAgIC8vIGJ1dCBhcmUgbm90IGRyYWdnYWJsZVxyXG4gICAgICAgICAgICAgICAgdGhpcy5pc0RyYWdnaW5nID0gaXNWYWxpZCAmJlxyXG4gICAgICAgICAgICAgICAgICAgIGV2LnN1YmplY3RFbC5jbGFzc0xpc3QuY29udGFpbnMoJ2ZjLWV2ZW50LWRyYWdnYWJsZScpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB0aGlzLmhhbmRsZURyYWdTdGFydCA9IChldikgPT4ge1xyXG4gICAgICAgICAgICAgICAgbGV0IGluaXRpYWxDb250ZXh0ID0gdGhpcy5jb21wb25lbnQuY29udGV4dDtcclxuICAgICAgICAgICAgICAgIGxldCBldmVudFJhbmdlID0gdGhpcy5ldmVudFJhbmdlO1xyXG4gICAgICAgICAgICAgICAgbGV0IGV2ZW50SW5zdGFuY2VJZCA9IGV2ZW50UmFuZ2UuaW5zdGFuY2UuaW5zdGFuY2VJZDtcclxuICAgICAgICAgICAgICAgIGlmIChldi5pc1RvdWNoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gbmVlZCB0byBzZWxlY3QgYSBkaWZmZXJlbnQgZXZlbnQ/XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50SW5zdGFuY2VJZCAhPT0gdGhpcy5jb21wb25lbnQucHJvcHMuZXZlbnRTZWxlY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5pdGlhbENvbnRleHQuZGlzcGF0Y2goeyB0eXBlOiAnU0VMRUNUX0VWRU5UJywgZXZlbnRJbnN0YW5jZUlkIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIG5vdyB1c2luZyBtb3VzZSwgYnV0IHdhcyBwcmV2aW91cyB0b3VjaCBpbnRlcmFjdGlvbiwgY2xlYXIgc2VsZWN0ZWQgZXZlbnRcclxuICAgICAgICAgICAgICAgICAgICBpbml0aWFsQ29udGV4dC5kaXNwYXRjaCh7IHR5cGU6ICdVTlNFTEVDVF9FVkVOVCcgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc0RyYWdnaW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5pdGlhbENvbnRleHQuY2FsZW5kYXJBcGkudW5zZWxlY3QoZXYpOyAvLyB1bnNlbGVjdCAqZGF0ZSogc2VsZWN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgaW5pdGlhbENvbnRleHQuZW1pdHRlci50cmlnZ2VyKCdldmVudERyYWdTdGFydCcsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWw6IHRoaXMuc3ViamVjdEVsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudDogbmV3IEV2ZW50SW1wbChpbml0aWFsQ29udGV4dCwgZXZlbnRSYW5nZS5kZWYsIGV2ZW50UmFuZ2UuaW5zdGFuY2UpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBqc0V2ZW50OiBldi5vcmlnRXZlbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpZXc6IGluaXRpYWxDb250ZXh0LnZpZXdBcGksXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlSGl0VXBkYXRlID0gKGhpdCwgaXNGaW5hbCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmlzRHJhZ2dpbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBsZXQgcmVsZXZhbnRFdmVudHMgPSB0aGlzLnJlbGV2YW50RXZlbnRzO1xyXG4gICAgICAgICAgICAgICAgbGV0IGluaXRpYWxIaXQgPSB0aGlzLmhpdERyYWdnaW5nLmluaXRpYWxIaXQ7XHJcbiAgICAgICAgICAgICAgICBsZXQgaW5pdGlhbENvbnRleHQgPSB0aGlzLmNvbXBvbmVudC5jb250ZXh0O1xyXG4gICAgICAgICAgICAgICAgLy8gc3RhdGVzIGJhc2VkIG9uIG5ldyBoaXRcclxuICAgICAgICAgICAgICAgIGxldCByZWNlaXZpbmdDb250ZXh0ID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIGxldCBtdXRhdGlvbiA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICBsZXQgbXV0YXRlZFJlbGV2YW50RXZlbnRzID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIGxldCBpc0ludmFsaWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGxldCBpbnRlcmFjdGlvbiA9IHtcclxuICAgICAgICAgICAgICAgICAgICBhZmZlY3RlZEV2ZW50czogcmVsZXZhbnRFdmVudHMsXHJcbiAgICAgICAgICAgICAgICAgICAgbXV0YXRlZEV2ZW50czogY3JlYXRlRW1wdHlFdmVudFN0b3JlKCksXHJcbiAgICAgICAgICAgICAgICAgICAgaXNFdmVudDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBpZiAoaGl0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVjZWl2aW5nQ29udGV4dCA9IGhpdC5jb250ZXh0O1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCByZWNlaXZpbmdPcHRpb25zID0gcmVjZWl2aW5nQ29udGV4dC5vcHRpb25zO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbml0aWFsQ29udGV4dCA9PT0gcmVjZWl2aW5nQ29udGV4dCB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAocmVjZWl2aW5nT3B0aW9ucy5lZGl0YWJsZSAmJiByZWNlaXZpbmdPcHRpb25zLmRyb3BwYWJsZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbXV0YXRpb24gPSBjb21wdXRlRXZlbnRNdXRhdGlvbihpbml0aWFsSGl0LCBoaXQsIHJlY2VpdmluZ0NvbnRleHQuZ2V0Q3VycmVudERhdGEoKS5wbHVnaW5Ib29rcy5ldmVudERyYWdNdXRhdGlvbk1hc3NhZ2Vycyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtdXRhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbXV0YXRlZFJlbGV2YW50RXZlbnRzID0gYXBwbHlNdXRhdGlvblRvRXZlbnRTdG9yZShyZWxldmFudEV2ZW50cywgcmVjZWl2aW5nQ29udGV4dC5nZXRDdXJyZW50RGF0YSgpLmV2ZW50VWlCYXNlcywgbXV0YXRpb24sIHJlY2VpdmluZ0NvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJhY3Rpb24ubXV0YXRlZEV2ZW50cyA9IG11dGF0ZWRSZWxldmFudEV2ZW50cztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNJbnRlcmFjdGlvblZhbGlkKGludGVyYWN0aW9uLCBoaXQuZGF0ZVByb2ZpbGUsIHJlY2VpdmluZ0NvbnRleHQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNJbnZhbGlkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtdXRhdGlvbiA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbXV0YXRlZFJlbGV2YW50RXZlbnRzID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRlcmFjdGlvbi5tdXRhdGVkRXZlbnRzID0gY3JlYXRlRW1wdHlFdmVudFN0b3JlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpdmluZ0NvbnRleHQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGxheURyYWcocmVjZWl2aW5nQ29udGV4dCwgaW50ZXJhY3Rpb24pO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc0ludmFsaWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBlbmFibGVDdXJzb3IoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGRpc2FibGVDdXJzb3IoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICghaXNGaW5hbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbml0aWFsQ29udGV4dCA9PT0gcmVjZWl2aW5nQ29udGV4dCAmJiAvLyBUT0RPOiB3cml0ZSB0ZXN0IGZvciB0aGlzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzSGl0c0VxdWFsKGluaXRpYWxIaXQsIGhpdCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbXV0YXRpb24gPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYWdnaW5nLnNldE1pcnJvck5lZWRzUmV2ZXJ0KCFtdXRhdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVuZGVyIHRoZSBtaXJyb3IgaWYgbm8gYWxyZWFkeS1yZW5kZXJlZCBtaXJyb3JcclxuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiB3aXNoIHdlIGNvdWxkIHNvbWVob3cgd2FpdCBmb3IgZGlzcGF0Y2ggdG8gZ3VhcmFudGVlIHJlbmRlclxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmcuc2V0TWlycm9ySXNWaXNpYmxlKCFoaXQgfHwgIXRoaXMuc3ViamVjdEVsLmdldFJvb3ROb2RlKCkucXVlcnlTZWxlY3RvcignLmZjLWV2ZW50LW1pcnJvcicpKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBhc3NpZ24gc3RhdGVzIGJhc2VkIG9uIG5ldyBoaXRcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlY2VpdmluZ0NvbnRleHQgPSByZWNlaXZpbmdDb250ZXh0O1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmFsaWRNdXRhdGlvbiA9IG11dGF0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubXV0YXRlZFJlbGV2YW50RXZlbnRzID0gbXV0YXRlZFJlbGV2YW50RXZlbnRzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB0aGlzLmhhbmRsZVBvaW50ZXJVcCA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5pc0RyYWdnaW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGVhbnVwKCk7IC8vIGJlY2F1c2UgaGFuZGxlRHJhZ0VuZCB3b24ndCBmaXJlXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlRHJhZ0VuZCA9IChldikgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNEcmFnZ2luZykge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBpbml0aWFsQ29udGV4dCA9IHRoaXMuY29tcG9uZW50LmNvbnRleHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGluaXRpYWxWaWV3ID0gaW5pdGlhbENvbnRleHQudmlld0FwaTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgeyByZWNlaXZpbmdDb250ZXh0LCB2YWxpZE11dGF0aW9uIH0gPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBldmVudERlZiA9IHRoaXMuZXZlbnRSYW5nZS5kZWY7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGV2ZW50SW5zdGFuY2UgPSB0aGlzLmV2ZW50UmFuZ2UuaW5zdGFuY2U7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGV2ZW50QXBpID0gbmV3IEV2ZW50SW1wbChpbml0aWFsQ29udGV4dCwgZXZlbnREZWYsIGV2ZW50SW5zdGFuY2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCByZWxldmFudEV2ZW50cyA9IHRoaXMucmVsZXZhbnRFdmVudHM7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IG11dGF0ZWRSZWxldmFudEV2ZW50cyA9IHRoaXMubXV0YXRlZFJlbGV2YW50RXZlbnRzO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCB7IGZpbmFsSGl0IH0gPSB0aGlzLmhpdERyYWdnaW5nO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJEcmFnKCk7IC8vIG11c3QgaGFwcGVuIGFmdGVyIHJldmVydCBhbmltYXRpb25cclxuICAgICAgICAgICAgICAgICAgICBpbml0aWFsQ29udGV4dC5lbWl0dGVyLnRyaWdnZXIoJ2V2ZW50RHJhZ1N0b3AnLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsOiB0aGlzLnN1YmplY3RFbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IGV2ZW50QXBpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBqc0V2ZW50OiBldi5vcmlnRXZlbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpZXc6IGluaXRpYWxWaWV3LFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWxpZE11dGF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRyb3BwZWQgd2l0aGluIHNhbWUgY2FsZW5kYXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlY2VpdmluZ0NvbnRleHQgPT09IGluaXRpYWxDb250ZXh0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgdXBkYXRlZEV2ZW50QXBpID0gbmV3IEV2ZW50SW1wbChpbml0aWFsQ29udGV4dCwgbXV0YXRlZFJlbGV2YW50RXZlbnRzLmRlZnNbZXZlbnREZWYuZGVmSWRdLCBldmVudEluc3RhbmNlID8gbXV0YXRlZFJlbGV2YW50RXZlbnRzLmluc3RhbmNlc1tldmVudEluc3RhbmNlLmluc3RhbmNlSWRdIDogbnVsbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbml0aWFsQ29udGV4dC5kaXNwYXRjaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ01FUkdFX0VWRU5UUycsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRTdG9yZTogbXV0YXRlZFJlbGV2YW50RXZlbnRzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZXZlbnRDaGFuZ2VBcmcgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2xkRXZlbnQ6IGV2ZW50QXBpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50OiB1cGRhdGVkRXZlbnRBcGksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVsYXRlZEV2ZW50czogYnVpbGRFdmVudEFwaXMobXV0YXRlZFJlbGV2YW50RXZlbnRzLCBpbml0aWFsQ29udGV4dCwgZXZlbnRJbnN0YW5jZSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV2ZXJ0KCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbml0aWFsQ29udGV4dC5kaXNwYXRjaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnTUVSR0VfRVZFTlRTJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50U3RvcmU6IHJlbGV2YW50RXZlbnRzLCAvLyB0aGUgcHJlLWNoYW5nZSBkYXRhXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHRyYW5zZm9ybWVkID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCB0cmFuc2Zvcm1lciBvZiBpbml0aWFsQ29udGV4dC5nZXRDdXJyZW50RGF0YSgpLnBsdWdpbkhvb2tzLmV2ZW50RHJvcFRyYW5zZm9ybWVycykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odHJhbnNmb3JtZWQsIHRyYW5zZm9ybWVyKHZhbGlkTXV0YXRpb24sIGluaXRpYWxDb250ZXh0KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbml0aWFsQ29udGV4dC5lbWl0dGVyLnRyaWdnZXIoJ2V2ZW50RHJvcCcsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBldmVudENoYW5nZUFyZyksIHRyYW5zZm9ybWVkKSwgeyBlbDogZXYuc3ViamVjdEVsLCBkZWx0YTogdmFsaWRNdXRhdGlvbi5kYXRlc0RlbHRhLCBqc0V2ZW50OiBldi5vcmlnRXZlbnQsIHZpZXc6IGluaXRpYWxWaWV3IH0pKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluaXRpYWxDb250ZXh0LmVtaXR0ZXIudHJpZ2dlcignZXZlbnRDaGFuZ2UnLCBldmVudENoYW5nZUFyZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkcm9wcGVkIGluIGRpZmZlcmVudCBjYWxlbmRhclxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlY2VpdmluZ0NvbnRleHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBldmVudFJlbW92ZUFyZyA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudDogZXZlbnRBcGksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVsYXRlZEV2ZW50czogYnVpbGRFdmVudEFwaXMocmVsZXZhbnRFdmVudHMsIGluaXRpYWxDb250ZXh0LCBldmVudEluc3RhbmNlKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXZlcnQoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluaXRpYWxDb250ZXh0LmRpc3BhdGNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdNRVJHRV9FVkVOVFMnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRTdG9yZTogcmVsZXZhbnRFdmVudHMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5pdGlhbENvbnRleHQuZW1pdHRlci50cmlnZ2VyKCdldmVudExlYXZlJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBldmVudFJlbW92ZUFyZyksIHsgZHJhZ2dlZEVsOiBldi5zdWJqZWN0RWwsIHZpZXc6IGluaXRpYWxWaWV3IH0pKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluaXRpYWxDb250ZXh0LmRpc3BhdGNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnUkVNT1ZFX0VWRU5UUycsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRTdG9yZTogcmVsZXZhbnRFdmVudHMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluaXRpYWxDb250ZXh0LmVtaXR0ZXIudHJpZ2dlcignZXZlbnRSZW1vdmUnLCBldmVudFJlbW92ZUFyZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgYWRkZWRFdmVudERlZiA9IG11dGF0ZWRSZWxldmFudEV2ZW50cy5kZWZzW2V2ZW50RGVmLmRlZklkXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBhZGRlZEV2ZW50SW5zdGFuY2UgPSBtdXRhdGVkUmVsZXZhbnRFdmVudHMuaW5zdGFuY2VzW2V2ZW50SW5zdGFuY2UuaW5zdGFuY2VJZF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgYWRkZWRFdmVudEFwaSA9IG5ldyBFdmVudEltcGwocmVjZWl2aW5nQ29udGV4dCwgYWRkZWRFdmVudERlZiwgYWRkZWRFdmVudEluc3RhbmNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpdmluZ0NvbnRleHQuZGlzcGF0Y2goe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdNRVJHRV9FVkVOVFMnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50U3RvcmU6IG11dGF0ZWRSZWxldmFudEV2ZW50cyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGV2ZW50QWRkQXJnID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50OiBhZGRlZEV2ZW50QXBpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbGF0ZWRFdmVudHM6IGJ1aWxkRXZlbnRBcGlzKG11dGF0ZWRSZWxldmFudEV2ZW50cywgcmVjZWl2aW5nQ29udGV4dCwgYWRkZWRFdmVudEluc3RhbmNlKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXZlcnQoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpdmluZ0NvbnRleHQuZGlzcGF0Y2goe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ1JFTU9WRV9FVkVOVFMnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRTdG9yZTogbXV0YXRlZFJlbGV2YW50RXZlbnRzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpdmluZ0NvbnRleHQuZW1pdHRlci50cmlnZ2VyKCdldmVudEFkZCcsIGV2ZW50QWRkQXJnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChldi5pc1RvdWNoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjZWl2aW5nQ29udGV4dC5kaXNwYXRjaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdTRUxFQ1RfRVZFTlQnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudEluc3RhbmNlSWQ6IGV2ZW50SW5zdGFuY2UuaW5zdGFuY2VJZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpdmluZ0NvbnRleHQuZW1pdHRlci50cmlnZ2VyKCdkcm9wJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBidWlsZERhdGVQb2ludEFwaVdpdGhDb250ZXh0KGZpbmFsSGl0LmRhdGVTcGFuLCByZWNlaXZpbmdDb250ZXh0KSksIHsgZHJhZ2dlZEVsOiBldi5zdWJqZWN0RWwsIGpzRXZlbnQ6IGV2Lm9yaWdFdmVudCwgdmlldzogZmluYWxIaXQuY29udGV4dC52aWV3QXBpIH0pKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpdmluZ0NvbnRleHQuZW1pdHRlci50cmlnZ2VyKCdldmVudFJlY2VpdmUnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGV2ZW50QWRkQXJnKSwgeyBkcmFnZ2VkRWw6IGV2LnN1YmplY3RFbCwgdmlldzogZmluYWxIaXQuY29udGV4dC52aWV3QXBpIH0pKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5pdGlhbENvbnRleHQuZW1pdHRlci50cmlnZ2VyKCdfbm9FdmVudERyb3AnKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNsZWFudXAoKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgbGV0IHsgY29tcG9uZW50IH0gPSB0aGlzO1xyXG4gICAgICAgICAgICBsZXQgeyBvcHRpb25zIH0gPSBjb21wb25lbnQuY29udGV4dDtcclxuICAgICAgICAgICAgbGV0IGRyYWdnaW5nID0gdGhpcy5kcmFnZ2luZyA9IG5ldyBGZWF0dXJlZnVsRWxlbWVudERyYWdnaW5nKHNldHRpbmdzLmVsKTtcclxuICAgICAgICAgICAgZHJhZ2dpbmcucG9pbnRlci5zZWxlY3RvciA9IEV2ZW50RHJhZ2dpbmcuU0VMRUNUT1I7XHJcbiAgICAgICAgICAgIGRyYWdnaW5nLnRvdWNoU2Nyb2xsQWxsb3dlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBkcmFnZ2luZy5hdXRvU2Nyb2xsZXIuaXNFbmFibGVkID0gb3B0aW9ucy5kcmFnU2Nyb2xsO1xyXG4gICAgICAgICAgICBsZXQgaGl0RHJhZ2dpbmcgPSB0aGlzLmhpdERyYWdnaW5nID0gbmV3IEhpdERyYWdnaW5nKHRoaXMuZHJhZ2dpbmcsIGludGVyYWN0aW9uU2V0dGluZ3NTdG9yZSk7XHJcbiAgICAgICAgICAgIGhpdERyYWdnaW5nLnVzZVN1YmplY3RDZW50ZXIgPSBzZXR0aW5ncy51c2VFdmVudENlbnRlcjtcclxuICAgICAgICAgICAgaGl0RHJhZ2dpbmcuZW1pdHRlci5vbigncG9pbnRlcmRvd24nLCB0aGlzLmhhbmRsZVBvaW50ZXJEb3duKTtcclxuICAgICAgICAgICAgaGl0RHJhZ2dpbmcuZW1pdHRlci5vbignZHJhZ3N0YXJ0JywgdGhpcy5oYW5kbGVEcmFnU3RhcnQpO1xyXG4gICAgICAgICAgICBoaXREcmFnZ2luZy5lbWl0dGVyLm9uKCdoaXR1cGRhdGUnLCB0aGlzLmhhbmRsZUhpdFVwZGF0ZSk7XHJcbiAgICAgICAgICAgIGhpdERyYWdnaW5nLmVtaXR0ZXIub24oJ3BvaW50ZXJ1cCcsIHRoaXMuaGFuZGxlUG9pbnRlclVwKTtcclxuICAgICAgICAgICAgaGl0RHJhZ2dpbmcuZW1pdHRlci5vbignZHJhZ2VuZCcsIHRoaXMuaGFuZGxlRHJhZ0VuZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRlc3Ryb3koKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmcuZGVzdHJveSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyByZW5kZXIgYSBkcmFnIHN0YXRlIG9uIHRoZSBuZXh0IHJlY2VpdmluZ0NhbGVuZGFyXHJcbiAgICAgICAgZGlzcGxheURyYWcobmV4dENvbnRleHQsIHN0YXRlKSB7XHJcbiAgICAgICAgICAgIGxldCBpbml0aWFsQ29udGV4dCA9IHRoaXMuY29tcG9uZW50LmNvbnRleHQ7XHJcbiAgICAgICAgICAgIGxldCBwcmV2Q29udGV4dCA9IHRoaXMucmVjZWl2aW5nQ29udGV4dDtcclxuICAgICAgICAgICAgLy8gZG9lcyB0aGUgcHJldmlvdXMgY2FsZW5kYXIgbmVlZCB0byBiZSBjbGVhcmVkP1xyXG4gICAgICAgICAgICBpZiAocHJldkNvbnRleHQgJiYgcHJldkNvbnRleHQgIT09IG5leHRDb250ZXh0KSB7XHJcbiAgICAgICAgICAgICAgICAvLyBkb2VzIHRoZSBpbml0aWFsIGNhbGVuZGFyIG5lZWQgdG8gYmUgY2xlYXJlZD9cclxuICAgICAgICAgICAgICAgIC8vIGlmIHNvLCBkb24ndCBjbGVhciBhbGwgdGhlIHdheS4gd2Ugc3RpbGwgbmVlZCB0byB0byBoaWRlIHRoZSBhZmZlY3RlZEV2ZW50c1xyXG4gICAgICAgICAgICAgICAgaWYgKHByZXZDb250ZXh0ID09PSBpbml0aWFsQ29udGV4dCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHByZXZDb250ZXh0LmRpc3BhdGNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ1NFVF9FVkVOVF9EUkFHJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGU6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFmZmVjdGVkRXZlbnRzOiBzdGF0ZS5hZmZlY3RlZEV2ZW50cyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG11dGF0ZWRFdmVudHM6IGNyZWF0ZUVtcHR5RXZlbnRTdG9yZSgpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNFdmVudDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBjb21wbGV0ZWx5IGNsZWFyIHRoZSBvbGQgY2FsZW5kYXIgaWYgaXQgd2Fzbid0IHRoZSBpbml0aWFsXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBwcmV2Q29udGV4dC5kaXNwYXRjaCh7IHR5cGU6ICdVTlNFVF9FVkVOVF9EUkFHJyB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobmV4dENvbnRleHQpIHtcclxuICAgICAgICAgICAgICAgIG5leHRDb250ZXh0LmRpc3BhdGNoKHsgdHlwZTogJ1NFVF9FVkVOVF9EUkFHJywgc3RhdGUgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY2xlYXJEcmFnKCkge1xyXG4gICAgICAgICAgICBsZXQgaW5pdGlhbENhbGVuZGFyID0gdGhpcy5jb21wb25lbnQuY29udGV4dDtcclxuICAgICAgICAgICAgbGV0IHsgcmVjZWl2aW5nQ29udGV4dCB9ID0gdGhpcztcclxuICAgICAgICAgICAgaWYgKHJlY2VpdmluZ0NvbnRleHQpIHtcclxuICAgICAgICAgICAgICAgIHJlY2VpdmluZ0NvbnRleHQuZGlzcGF0Y2goeyB0eXBlOiAnVU5TRVRfRVZFTlRfRFJBRycgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gdGhlIGluaXRpYWwgY2FsZW5kYXIgbWlnaHQgaGF2ZSBhbiBkdW1teSBkcmFnIHN0YXRlIGZyb20gZGlzcGxheURyYWdcclxuICAgICAgICAgICAgaWYgKGluaXRpYWxDYWxlbmRhciAhPT0gcmVjZWl2aW5nQ29udGV4dCkge1xyXG4gICAgICAgICAgICAgICAgaW5pdGlhbENhbGVuZGFyLmRpc3BhdGNoKHsgdHlwZTogJ1VOU0VUX0VWRU5UX0RSQUcnIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNsZWFudXAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3ViamVjdFNlZyA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMuaXNEcmFnZ2luZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLmV2ZW50UmFuZ2UgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLnJlbGV2YW50RXZlbnRzID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5yZWNlaXZpbmdDb250ZXh0ID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy52YWxpZE11dGF0aW9uID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5tdXRhdGVkUmVsZXZhbnRFdmVudHMgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIFRPRE86IHRlc3QgdGhpcyBpbiBJRTExXHJcbiAgICAvLyBRVUVTVElPTjogd2h5IGRvIHdlIG5lZWQgaXQgb24gdGhlIHJlc2l6YWJsZT8/P1xyXG4gICAgRXZlbnREcmFnZ2luZy5TRUxFQ1RPUiA9ICcuZmMtZXZlbnQtZHJhZ2dhYmxlLCAuZmMtZXZlbnQtcmVzaXphYmxlJztcclxuICAgIGZ1bmN0aW9uIGNvbXB1dGVFdmVudE11dGF0aW9uKGhpdDAsIGhpdDEsIG1hc3NhZ2Vycykge1xyXG4gICAgICAgIGxldCBkYXRlU3BhbjAgPSBoaXQwLmRhdGVTcGFuO1xyXG4gICAgICAgIGxldCBkYXRlU3BhbjEgPSBoaXQxLmRhdGVTcGFuO1xyXG4gICAgICAgIGxldCBkYXRlMCA9IGRhdGVTcGFuMC5yYW5nZS5zdGFydDtcclxuICAgICAgICBsZXQgZGF0ZTEgPSBkYXRlU3BhbjEucmFuZ2Uuc3RhcnQ7XHJcbiAgICAgICAgbGV0IHN0YW5kYXJkUHJvcHMgPSB7fTtcclxuICAgICAgICBpZiAoZGF0ZVNwYW4wLmFsbERheSAhPT0gZGF0ZVNwYW4xLmFsbERheSkge1xyXG4gICAgICAgICAgICBzdGFuZGFyZFByb3BzLmFsbERheSA9IGRhdGVTcGFuMS5hbGxEYXk7XHJcbiAgICAgICAgICAgIHN0YW5kYXJkUHJvcHMuaGFzRW5kID0gaGl0MS5jb250ZXh0Lm9wdGlvbnMuYWxsRGF5TWFpbnRhaW5EdXJhdGlvbjtcclxuICAgICAgICAgICAgaWYgKGRhdGVTcGFuMS5hbGxEYXkpIHtcclxuICAgICAgICAgICAgICAgIC8vIG1lYW5zIGRhdGUxIGlzIGFscmVhZHkgc3RhcnQtb2YtZGF5LFxyXG4gICAgICAgICAgICAgICAgLy8gYnV0IGRhdGUwIG5lZWRzIHRvIGJlIGNvbnZlcnRlZFxyXG4gICAgICAgICAgICAgICAgZGF0ZTAgPSBzdGFydE9mRGF5KGRhdGUwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgZGVsdGEgPSBkaWZmRGF0ZXMoZGF0ZTAsIGRhdGUxLCBoaXQwLmNvbnRleHQuZGF0ZUVudiwgaGl0MC5jb21wb25lbnRJZCA9PT0gaGl0MS5jb21wb25lbnRJZCA/XHJcbiAgICAgICAgICAgIGhpdDAubGFyZ2VVbml0IDpcclxuICAgICAgICAgICAgbnVsbCk7XHJcbiAgICAgICAgaWYgKGRlbHRhLm1pbGxpc2Vjb25kcykgeyAvLyBoYXMgaG91cnMvbWludXRlcy9zZWNvbmRzXHJcbiAgICAgICAgICAgIHN0YW5kYXJkUHJvcHMuYWxsRGF5ID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBtdXRhdGlvbiA9IHtcclxuICAgICAgICAgICAgZGF0ZXNEZWx0YTogZGVsdGEsXHJcbiAgICAgICAgICAgIHN0YW5kYXJkUHJvcHMsXHJcbiAgICAgICAgfTtcclxuICAgICAgICBmb3IgKGxldCBtYXNzYWdlciBvZiBtYXNzYWdlcnMpIHtcclxuICAgICAgICAgICAgbWFzc2FnZXIobXV0YXRpb24sIGhpdDAsIGhpdDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbXV0YXRpb247XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBnZXRDb21wb25lbnRUb3VjaERlbGF5KGNvbXBvbmVudCkge1xyXG4gICAgICAgIGxldCB7IG9wdGlvbnMgfSA9IGNvbXBvbmVudC5jb250ZXh0O1xyXG4gICAgICAgIGxldCBkZWxheSA9IG9wdGlvbnMuZXZlbnRMb25nUHJlc3NEZWxheTtcclxuICAgICAgICBpZiAoZGVsYXkgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBkZWxheSA9IG9wdGlvbnMubG9uZ1ByZXNzRGVsYXk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkZWxheTtcclxuICAgIH1cclxuXHJcbiAgICBjbGFzcyBFdmVudFJlc2l6aW5nIGV4dGVuZHMgSW50ZXJhY3Rpb24ge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yKHNldHRpbmdzKSB7XHJcbiAgICAgICAgICAgIHN1cGVyKHNldHRpbmdzKTtcclxuICAgICAgICAgICAgLy8gaW50ZXJuYWwgc3RhdGVcclxuICAgICAgICAgICAgdGhpcy5kcmFnZ2luZ1NlZ0VsID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5kcmFnZ2luZ1NlZyA9IG51bGw7IC8vIFRPRE86IHJlbmFtZSB0byByZXNpemluZ1NlZz8gc3ViamVjdFNlZz9cclxuICAgICAgICAgICAgdGhpcy5ldmVudFJhbmdlID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5yZWxldmFudEV2ZW50cyA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMudmFsaWRNdXRhdGlvbiA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMubXV0YXRlZFJlbGV2YW50RXZlbnRzID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5oYW5kbGVQb2ludGVyRG93biA9IChldikgPT4ge1xyXG4gICAgICAgICAgICAgICAgbGV0IHsgY29tcG9uZW50IH0gPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgbGV0IHNlZ0VsID0gdGhpcy5xdWVyeVNlZ0VsKGV2KTtcclxuICAgICAgICAgICAgICAgIGxldCBzZWcgPSBnZXRFbFNlZyhzZWdFbCk7XHJcbiAgICAgICAgICAgICAgICBsZXQgZXZlbnRSYW5nZSA9IHRoaXMuZXZlbnRSYW5nZSA9IHNlZy5ldmVudFJhbmdlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kcmFnZ2luZy5taW5EaXN0YW5jZSA9IGNvbXBvbmVudC5jb250ZXh0Lm9wdGlvbnMuZXZlbnREcmFnTWluRGlzdGFuY2U7XHJcbiAgICAgICAgICAgICAgICAvLyBpZiB0b3VjaCwgbmVlZCB0byBiZSB3b3JraW5nIHdpdGggYSBzZWxlY3RlZCBldmVudFxyXG4gICAgICAgICAgICAgICAgdGhpcy5kcmFnZ2luZy5zZXRJZ25vcmVNb3ZlKCF0aGlzLmNvbXBvbmVudC5pc1ZhbGlkU2VnRG93bkVsKGV2Lm9yaWdFdmVudC50YXJnZXQpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgKGV2LmlzVG91Y2ggJiYgdGhpcy5jb21wb25lbnQucHJvcHMuZXZlbnRTZWxlY3Rpb24gIT09IGV2ZW50UmFuZ2UuaW5zdGFuY2UuaW5zdGFuY2VJZCkpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB0aGlzLmhhbmRsZURyYWdTdGFydCA9IChldikgPT4ge1xyXG4gICAgICAgICAgICAgICAgbGV0IHsgY29udGV4dCB9ID0gdGhpcy5jb21wb25lbnQ7XHJcbiAgICAgICAgICAgICAgICBsZXQgZXZlbnRSYW5nZSA9IHRoaXMuZXZlbnRSYW5nZTtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVsZXZhbnRFdmVudHMgPSBnZXRSZWxldmFudEV2ZW50cyhjb250ZXh0LmdldEN1cnJlbnREYXRhKCkuZXZlbnRTdG9yZSwgdGhpcy5ldmVudFJhbmdlLmluc3RhbmNlLmluc3RhbmNlSWQpO1xyXG4gICAgICAgICAgICAgICAgbGV0IHNlZ0VsID0gdGhpcy5xdWVyeVNlZ0VsKGV2KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmdTZWdFbCA9IHNlZ0VsO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kcmFnZ2luZ1NlZyA9IGdldEVsU2VnKHNlZ0VsKTtcclxuICAgICAgICAgICAgICAgIGNvbnRleHQuY2FsZW5kYXJBcGkudW5zZWxlY3QoKTtcclxuICAgICAgICAgICAgICAgIGNvbnRleHQuZW1pdHRlci50cmlnZ2VyKCdldmVudFJlc2l6ZVN0YXJ0Jywge1xyXG4gICAgICAgICAgICAgICAgICAgIGVsOiBzZWdFbCxcclxuICAgICAgICAgICAgICAgICAgICBldmVudDogbmV3IEV2ZW50SW1wbChjb250ZXh0LCBldmVudFJhbmdlLmRlZiwgZXZlbnRSYW5nZS5pbnN0YW5jZSksXHJcbiAgICAgICAgICAgICAgICAgICAganNFdmVudDogZXYub3JpZ0V2ZW50LFxyXG4gICAgICAgICAgICAgICAgICAgIHZpZXc6IGNvbnRleHQudmlld0FwaSxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB0aGlzLmhhbmRsZUhpdFVwZGF0ZSA9IChoaXQsIGlzRmluYWwsIGV2KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBsZXQgeyBjb250ZXh0IH0gPSB0aGlzLmNvbXBvbmVudDtcclxuICAgICAgICAgICAgICAgIGxldCByZWxldmFudEV2ZW50cyA9IHRoaXMucmVsZXZhbnRFdmVudHM7XHJcbiAgICAgICAgICAgICAgICBsZXQgaW5pdGlhbEhpdCA9IHRoaXMuaGl0RHJhZ2dpbmcuaW5pdGlhbEhpdDtcclxuICAgICAgICAgICAgICAgIGxldCBldmVudEluc3RhbmNlID0gdGhpcy5ldmVudFJhbmdlLmluc3RhbmNlO1xyXG4gICAgICAgICAgICAgICAgbGV0IG11dGF0aW9uID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIGxldCBtdXRhdGVkUmVsZXZhbnRFdmVudHMgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgbGV0IGlzSW52YWxpZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgbGV0IGludGVyYWN0aW9uID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIGFmZmVjdGVkRXZlbnRzOiByZWxldmFudEV2ZW50cyxcclxuICAgICAgICAgICAgICAgICAgICBtdXRhdGVkRXZlbnRzOiBjcmVhdGVFbXB0eUV2ZW50U3RvcmUoKSxcclxuICAgICAgICAgICAgICAgICAgICBpc0V2ZW50OiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIGlmIChoaXQpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgZGlzYWxsb3dlZCA9IGhpdC5jb21wb25lbnRJZCA9PT0gaW5pdGlhbEhpdC5jb21wb25lbnRJZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAmJiB0aGlzLmlzSGl0Q29tYm9BbGxvd2VkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICYmICF0aGlzLmlzSGl0Q29tYm9BbGxvd2VkKGluaXRpYWxIaXQsIGhpdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkaXNhbGxvd2VkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG11dGF0aW9uID0gY29tcHV0ZU11dGF0aW9uKGluaXRpYWxIaXQsIGhpdCwgZXYuc3ViamVjdEVsLmNsYXNzTGlzdC5jb250YWlucygnZmMtZXZlbnQtcmVzaXplci1zdGFydCcpLCBldmVudEluc3RhbmNlLnJhbmdlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAobXV0YXRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICBtdXRhdGVkUmVsZXZhbnRFdmVudHMgPSBhcHBseU11dGF0aW9uVG9FdmVudFN0b3JlKHJlbGV2YW50RXZlbnRzLCBjb250ZXh0LmdldEN1cnJlbnREYXRhKCkuZXZlbnRVaUJhc2VzLCBtdXRhdGlvbiwgY29udGV4dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJhY3Rpb24ubXV0YXRlZEV2ZW50cyA9IG11dGF0ZWRSZWxldmFudEV2ZW50cztcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzSW50ZXJhY3Rpb25WYWxpZChpbnRlcmFjdGlvbiwgaGl0LmRhdGVQcm9maWxlLCBjb250ZXh0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0ludmFsaWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtdXRhdGlvbiA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG11dGF0ZWRSZWxldmFudEV2ZW50cyA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVyYWN0aW9uLm11dGF0ZWRFdmVudHMgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChtdXRhdGVkUmVsZXZhbnRFdmVudHMpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmRpc3BhdGNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ1NFVF9FVkVOVF9SRVNJWkUnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZTogaW50ZXJhY3Rpb24sXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmRpc3BhdGNoKHsgdHlwZTogJ1VOU0VUX0VWRU5UX1JFU0laRScgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzSW52YWxpZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGVuYWJsZUN1cnNvcigpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlzYWJsZUN1cnNvcigpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCFpc0ZpbmFsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG11dGF0aW9uICYmIGlzSGl0c0VxdWFsKGluaXRpYWxIaXQsIGhpdCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbXV0YXRpb24gPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbGlkTXV0YXRpb24gPSBtdXRhdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm11dGF0ZWRSZWxldmFudEV2ZW50cyA9IG11dGF0ZWRSZWxldmFudEV2ZW50cztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdGhpcy5oYW5kbGVEcmFnRW5kID0gKGV2KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBsZXQgeyBjb250ZXh0IH0gPSB0aGlzLmNvbXBvbmVudDtcclxuICAgICAgICAgICAgICAgIGxldCBldmVudERlZiA9IHRoaXMuZXZlbnRSYW5nZS5kZWY7XHJcbiAgICAgICAgICAgICAgICBsZXQgZXZlbnRJbnN0YW5jZSA9IHRoaXMuZXZlbnRSYW5nZS5pbnN0YW5jZTtcclxuICAgICAgICAgICAgICAgIGxldCBldmVudEFwaSA9IG5ldyBFdmVudEltcGwoY29udGV4dCwgZXZlbnREZWYsIGV2ZW50SW5zdGFuY2UpO1xyXG4gICAgICAgICAgICAgICAgbGV0IHJlbGV2YW50RXZlbnRzID0gdGhpcy5yZWxldmFudEV2ZW50cztcclxuICAgICAgICAgICAgICAgIGxldCBtdXRhdGVkUmVsZXZhbnRFdmVudHMgPSB0aGlzLm11dGF0ZWRSZWxldmFudEV2ZW50cztcclxuICAgICAgICAgICAgICAgIGNvbnRleHQuZW1pdHRlci50cmlnZ2VyKCdldmVudFJlc2l6ZVN0b3AnLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgZWw6IHRoaXMuZHJhZ2dpbmdTZWdFbCxcclxuICAgICAgICAgICAgICAgICAgICBldmVudDogZXZlbnRBcGksXHJcbiAgICAgICAgICAgICAgICAgICAganNFdmVudDogZXYub3JpZ0V2ZW50LFxyXG4gICAgICAgICAgICAgICAgICAgIHZpZXc6IGNvbnRleHQudmlld0FwaSxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudmFsaWRNdXRhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCB1cGRhdGVkRXZlbnRBcGkgPSBuZXcgRXZlbnRJbXBsKGNvbnRleHQsIG11dGF0ZWRSZWxldmFudEV2ZW50cy5kZWZzW2V2ZW50RGVmLmRlZklkXSwgZXZlbnRJbnN0YW5jZSA/IG11dGF0ZWRSZWxldmFudEV2ZW50cy5pbnN0YW5jZXNbZXZlbnRJbnN0YW5jZS5pbnN0YW5jZUlkXSA6IG51bGwpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuZGlzcGF0Y2goe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnTUVSR0VfRVZFTlRTJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRTdG9yZTogbXV0YXRlZFJlbGV2YW50RXZlbnRzLFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBldmVudENoYW5nZUFyZyA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb2xkRXZlbnQ6IGV2ZW50QXBpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudDogdXBkYXRlZEV2ZW50QXBpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZWxhdGVkRXZlbnRzOiBidWlsZEV2ZW50QXBpcyhtdXRhdGVkUmVsZXZhbnRFdmVudHMsIGNvbnRleHQsIGV2ZW50SW5zdGFuY2UpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXZlcnQoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmRpc3BhdGNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnTUVSR0VfRVZFTlRTJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudFN0b3JlOiByZWxldmFudEV2ZW50cywgLy8gdGhlIHByZS1jaGFuZ2UgZXZlbnRzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuZW1pdHRlci50cmlnZ2VyKCdldmVudFJlc2l6ZScsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZXZlbnRDaGFuZ2VBcmcpLCB7IGVsOiB0aGlzLmRyYWdnaW5nU2VnRWwsIHN0YXJ0RGVsdGE6IHRoaXMudmFsaWRNdXRhdGlvbi5zdGFydERlbHRhIHx8IGNyZWF0ZUR1cmF0aW9uKDApLCBlbmREZWx0YTogdGhpcy52YWxpZE11dGF0aW9uLmVuZERlbHRhIHx8IGNyZWF0ZUR1cmF0aW9uKDApLCBqc0V2ZW50OiBldi5vcmlnRXZlbnQsIHZpZXc6IGNvbnRleHQudmlld0FwaSB9KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5lbWl0dGVyLnRyaWdnZXIoJ2V2ZW50Q2hhbmdlJywgZXZlbnRDaGFuZ2VBcmcpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5lbWl0dGVyLnRyaWdnZXIoJ19ub0V2ZW50UmVzaXplJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyByZXNldCBhbGwgaW50ZXJuYWwgc3RhdGVcclxuICAgICAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmdTZWcgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZWxldmFudEV2ZW50cyA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnZhbGlkTXV0YXRpb24gPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgLy8gb2theSB0byBrZWVwIGV2ZW50SW5zdGFuY2UgYXJvdW5kLiB1c2VmdWwgdG8gc2V0IGl0IGluIGhhbmRsZVBvaW50ZXJEb3duXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGxldCB7IGNvbXBvbmVudCB9ID0gc2V0dGluZ3M7XHJcbiAgICAgICAgICAgIGxldCBkcmFnZ2luZyA9IHRoaXMuZHJhZ2dpbmcgPSBuZXcgRmVhdHVyZWZ1bEVsZW1lbnREcmFnZ2luZyhzZXR0aW5ncy5lbCk7XHJcbiAgICAgICAgICAgIGRyYWdnaW5nLnBvaW50ZXIuc2VsZWN0b3IgPSAnLmZjLWV2ZW50LXJlc2l6ZXInO1xyXG4gICAgICAgICAgICBkcmFnZ2luZy50b3VjaFNjcm9sbEFsbG93ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgZHJhZ2dpbmcuYXV0b1Njcm9sbGVyLmlzRW5hYmxlZCA9IGNvbXBvbmVudC5jb250ZXh0Lm9wdGlvbnMuZHJhZ1Njcm9sbDtcclxuICAgICAgICAgICAgbGV0IGhpdERyYWdnaW5nID0gdGhpcy5oaXREcmFnZ2luZyA9IG5ldyBIaXREcmFnZ2luZyh0aGlzLmRyYWdnaW5nLCBpbnRlcmFjdGlvblNldHRpbmdzVG9TdG9yZShzZXR0aW5ncykpO1xyXG4gICAgICAgICAgICBoaXREcmFnZ2luZy5lbWl0dGVyLm9uKCdwb2ludGVyZG93bicsIHRoaXMuaGFuZGxlUG9pbnRlckRvd24pO1xyXG4gICAgICAgICAgICBoaXREcmFnZ2luZy5lbWl0dGVyLm9uKCdkcmFnc3RhcnQnLCB0aGlzLmhhbmRsZURyYWdTdGFydCk7XHJcbiAgICAgICAgICAgIGhpdERyYWdnaW5nLmVtaXR0ZXIub24oJ2hpdHVwZGF0ZScsIHRoaXMuaGFuZGxlSGl0VXBkYXRlKTtcclxuICAgICAgICAgICAgaGl0RHJhZ2dpbmcuZW1pdHRlci5vbignZHJhZ2VuZCcsIHRoaXMuaGFuZGxlRHJhZ0VuZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRlc3Ryb3koKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmcuZGVzdHJveSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBxdWVyeVNlZ0VsKGV2KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50Q2xvc2VzdChldi5zdWJqZWN0RWwsICcuZmMtZXZlbnQnKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBjb21wdXRlTXV0YXRpb24oaGl0MCwgaGl0MSwgaXNGcm9tU3RhcnQsIGluc3RhbmNlUmFuZ2UpIHtcclxuICAgICAgICBsZXQgZGF0ZUVudiA9IGhpdDAuY29udGV4dC5kYXRlRW52O1xyXG4gICAgICAgIGxldCBkYXRlMCA9IGhpdDAuZGF0ZVNwYW4ucmFuZ2Uuc3RhcnQ7XHJcbiAgICAgICAgbGV0IGRhdGUxID0gaGl0MS5kYXRlU3Bhbi5yYW5nZS5zdGFydDtcclxuICAgICAgICBsZXQgZGVsdGEgPSBkaWZmRGF0ZXMoZGF0ZTAsIGRhdGUxLCBkYXRlRW52LCBoaXQwLmxhcmdlVW5pdCk7XHJcbiAgICAgICAgaWYgKGlzRnJvbVN0YXJ0KSB7XHJcbiAgICAgICAgICAgIGlmIChkYXRlRW52LmFkZChpbnN0YW5jZVJhbmdlLnN0YXJ0LCBkZWx0YSkgPCBpbnN0YW5jZVJhbmdlLmVuZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgc3RhcnREZWx0YTogZGVsdGEgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChkYXRlRW52LmFkZChpbnN0YW5jZVJhbmdlLmVuZCwgZGVsdGEpID4gaW5zdGFuY2VSYW5nZS5zdGFydCkge1xyXG4gICAgICAgICAgICByZXR1cm4geyBlbmREZWx0YTogZGVsdGEgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgY2xhc3MgVW5zZWxlY3RBdXRvIHtcclxuICAgICAgICBjb25zdHJ1Y3Rvcihjb250ZXh0KSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XHJcbiAgICAgICAgICAgIHRoaXMuaXNSZWNlbnRQb2ludGVyRGF0ZVNlbGVjdCA9IGZhbHNlOyAvLyB3aXNoIHdlIGNvdWxkIHVzZSBhIHNlbGVjdG9yIHRvIGRldGVjdCBkYXRlIHNlbGVjdGlvbiwgYnV0IHVzZXMgaGl0IHN5c3RlbVxyXG4gICAgICAgICAgICB0aGlzLm1hdGNoZXNDYW5jZWwgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5tYXRjaGVzRXZlbnQgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5vblNlbGVjdCA9IChzZWxlY3RJbmZvKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2VsZWN0SW5mby5qc0V2ZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pc1JlY2VudFBvaW50ZXJEYXRlU2VsZWN0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdGhpcy5vbkRvY3VtZW50UG9pbnRlckRvd24gPSAocGV2KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBsZXQgdW5zZWxlY3RDYW5jZWwgPSB0aGlzLmNvbnRleHQub3B0aW9ucy51bnNlbGVjdENhbmNlbDtcclxuICAgICAgICAgICAgICAgIGxldCBkb3duRWwgPSBnZXRFdmVudFRhcmdldFZpYVJvb3QocGV2Lm9yaWdFdmVudCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1hdGNoZXNDYW5jZWwgPSAhIWVsZW1lbnRDbG9zZXN0KGRvd25FbCwgdW5zZWxlY3RDYW5jZWwpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tYXRjaGVzRXZlbnQgPSAhIWVsZW1lbnRDbG9zZXN0KGRvd25FbCwgRXZlbnREcmFnZ2luZy5TRUxFQ1RPUik7IC8vIGludGVyYWN0aW9uIHN0YXJ0ZWQgb24gYW4gZXZlbnQ/XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHRoaXMub25Eb2N1bWVudFBvaW50ZXJVcCA9IChwZXYpID0+IHtcclxuICAgICAgICAgICAgICAgIGxldCB7IGNvbnRleHQgfSA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICBsZXQgeyBkb2N1bWVudFBvaW50ZXIgfSA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICBsZXQgY2FsZW5kYXJTdGF0ZSA9IGNvbnRleHQuZ2V0Q3VycmVudERhdGEoKTtcclxuICAgICAgICAgICAgICAgIC8vIHRvdWNoLXNjcm9sbGluZyBzaG91bGQgbmV2ZXIgdW5mb2N1cyBhbnkgdHlwZSBvZiBzZWxlY3Rpb25cclxuICAgICAgICAgICAgICAgIGlmICghZG9jdW1lbnRQb2ludGVyLndhc1RvdWNoU2Nyb2xsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhbGVuZGFyU3RhdGUuZGF0ZVNlbGVjdGlvbiAmJiAvLyBhbiBleGlzdGluZyBkYXRlIHNlbGVjdGlvbj9cclxuICAgICAgICAgICAgICAgICAgICAgICAgIXRoaXMuaXNSZWNlbnRQb2ludGVyRGF0ZVNlbGVjdCAvLyBhIG5ldyBwb2ludGVyLWluaXRpYXRlZCBkYXRlIHNlbGVjdGlvbiBzaW5jZSBsYXN0IG9uRG9jdW1lbnRQb2ludGVyVXA/XHJcbiAgICAgICAgICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB1bnNlbGVjdEF1dG8gPSBjb250ZXh0Lm9wdGlvbnMudW5zZWxlY3RBdXRvO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodW5zZWxlY3RBdXRvICYmICghdW5zZWxlY3RBdXRvIHx8ICF0aGlzLm1hdGNoZXNDYW5jZWwpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmNhbGVuZGFyQXBpLnVuc2VsZWN0KHBldik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhbGVuZGFyU3RhdGUuZXZlbnRTZWxlY3Rpb24gJiYgLy8gYW4gZXhpc3RpbmcgZXZlbnQgc2VsZWN0ZWQ/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICF0aGlzLm1hdGNoZXNFdmVudCAvLyBpbnRlcmFjdGlvbiBESUROJ1Qgc3RhcnQgb24gYW4gZXZlbnRcclxuICAgICAgICAgICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5kaXNwYXRjaCh7IHR5cGU6ICdVTlNFTEVDVF9FVkVOVCcgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5pc1JlY2VudFBvaW50ZXJEYXRlU2VsZWN0ID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGxldCBkb2N1bWVudFBvaW50ZXIgPSB0aGlzLmRvY3VtZW50UG9pbnRlciA9IG5ldyBQb2ludGVyRHJhZ2dpbmcoZG9jdW1lbnQpO1xyXG4gICAgICAgICAgICBkb2N1bWVudFBvaW50ZXIuc2hvdWxkSWdub3JlTW92ZSA9IHRydWU7XHJcbiAgICAgICAgICAgIGRvY3VtZW50UG9pbnRlci5zaG91bGRXYXRjaFNjcm9sbCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBkb2N1bWVudFBvaW50ZXIuZW1pdHRlci5vbigncG9pbnRlcmRvd24nLCB0aGlzLm9uRG9jdW1lbnRQb2ludGVyRG93bik7XHJcbiAgICAgICAgICAgIGRvY3VtZW50UG9pbnRlci5lbWl0dGVyLm9uKCdwb2ludGVydXAnLCB0aGlzLm9uRG9jdW1lbnRQb2ludGVyVXApO1xyXG4gICAgICAgICAgICAvKlxyXG4gICAgICAgICAgICBUT0RPOiBiZXR0ZXIgd2F5IHRvIGtub3cgYWJvdXQgd2hldGhlciB0aGVyZSB3YXMgYSBzZWxlY3Rpb24gd2l0aCB0aGUgcG9pbnRlclxyXG4gICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBjb250ZXh0LmVtaXR0ZXIub24oJ3NlbGVjdCcsIHRoaXMub25TZWxlY3QpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkZXN0cm95KCkge1xyXG4gICAgICAgICAgICB0aGlzLmNvbnRleHQuZW1pdHRlci5vZmYoJ3NlbGVjdCcsIHRoaXMub25TZWxlY3QpO1xyXG4gICAgICAgICAgICB0aGlzLmRvY3VtZW50UG9pbnRlci5kZXN0cm95KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IE9QVElPTl9SRUZJTkVSUyQzID0ge1xyXG4gICAgICAgIGZpeGVkTWlycm9yUGFyZW50OiBpZGVudGl0eSxcclxuICAgIH07XHJcbiAgICBjb25zdCBMSVNURU5FUl9SRUZJTkVSUyA9IHtcclxuICAgICAgICBkYXRlQ2xpY2s6IGlkZW50aXR5LFxyXG4gICAgICAgIGV2ZW50RHJhZ1N0YXJ0OiBpZGVudGl0eSxcclxuICAgICAgICBldmVudERyYWdTdG9wOiBpZGVudGl0eSxcclxuICAgICAgICBldmVudERyb3A6IGlkZW50aXR5LFxyXG4gICAgICAgIGV2ZW50UmVzaXplU3RhcnQ6IGlkZW50aXR5LFxyXG4gICAgICAgIGV2ZW50UmVzaXplU3RvcDogaWRlbnRpdHksXHJcbiAgICAgICAgZXZlbnRSZXNpemU6IGlkZW50aXR5LFxyXG4gICAgICAgIGRyb3A6IGlkZW50aXR5LFxyXG4gICAgICAgIGV2ZW50UmVjZWl2ZTogaWRlbnRpdHksXHJcbiAgICAgICAgZXZlbnRMZWF2ZTogaWRlbnRpdHksXHJcbiAgICB9O1xyXG5cclxuICAgIC8qXHJcbiAgICBHaXZlbiBhbiBhbHJlYWR5IGluc3RhbnRpYXRlZCBkcmFnZ2FibGUgb2JqZWN0IGZvciBvbmUtb3ItbW9yZSBlbGVtZW50cyxcclxuICAgIEludGVycHJldHMgYW55IGRyYWdnaW5nIGFzIGFuIGF0dGVtcHQgdG8gZHJhZyBhbiBldmVudHMgdGhhdCBsaXZlcyBvdXRzaWRlXHJcbiAgICBvZiBhIGNhbGVuZGFyIG9udG8gYSBjYWxlbmRhci5cclxuICAgICovXHJcbiAgICBjbGFzcyBFeHRlcm5hbEVsZW1lbnREcmFnZ2luZyB7XHJcbiAgICAgICAgY29uc3RydWN0b3IoZHJhZ2dpbmcsIHN1cHBsaWVkRHJhZ01ldGEpIHtcclxuICAgICAgICAgICAgdGhpcy5yZWNlaXZpbmdDb250ZXh0ID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5kcm9wcGFibGVFdmVudCA9IG51bGw7IC8vIHdpbGwgZXhpc3QgZm9yIGFsbCBkcmFncywgZXZlbiBpZiBjcmVhdGU6ZmFsc2VcclxuICAgICAgICAgICAgdGhpcy5zdXBwbGllZERyYWdNZXRhID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5kcmFnTWV0YSA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlRHJhZ1N0YXJ0ID0gKGV2KSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRyYWdNZXRhID0gdGhpcy5idWlsZERyYWdNZXRhKGV2LnN1YmplY3RFbCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlSGl0VXBkYXRlID0gKGhpdCwgaXNGaW5hbCwgZXYpID0+IHtcclxuICAgICAgICAgICAgICAgIGxldCB7IGRyYWdnaW5nIH0gPSB0aGlzLmhpdERyYWdnaW5nO1xyXG4gICAgICAgICAgICAgICAgbGV0IHJlY2VpdmluZ0NvbnRleHQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgbGV0IGRyb3BwYWJsZUV2ZW50ID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIGxldCBpc0ludmFsaWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGxldCBpbnRlcmFjdGlvbiA9IHtcclxuICAgICAgICAgICAgICAgICAgICBhZmZlY3RlZEV2ZW50czogY3JlYXRlRW1wdHlFdmVudFN0b3JlKCksXHJcbiAgICAgICAgICAgICAgICAgICAgbXV0YXRlZEV2ZW50czogY3JlYXRlRW1wdHlFdmVudFN0b3JlKCksXHJcbiAgICAgICAgICAgICAgICAgICAgaXNFdmVudDogdGhpcy5kcmFnTWV0YS5jcmVhdGUsXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgaWYgKGhpdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlY2VpdmluZ0NvbnRleHQgPSBoaXQuY29udGV4dDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jYW5Ecm9wRWxPbkNhbGVuZGFyKGV2LnN1YmplY3RFbCwgcmVjZWl2aW5nQ29udGV4dCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZHJvcHBhYmxlRXZlbnQgPSBjb21wdXRlRXZlbnRGb3JEYXRlU3BhbihoaXQuZGF0ZVNwYW4sIHRoaXMuZHJhZ01ldGEsIHJlY2VpdmluZ0NvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcmFjdGlvbi5tdXRhdGVkRXZlbnRzID0gZXZlbnRUdXBsZVRvU3RvcmUoZHJvcHBhYmxlRXZlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0ludmFsaWQgPSAhaXNJbnRlcmFjdGlvblZhbGlkKGludGVyYWN0aW9uLCBoaXQuZGF0ZVByb2ZpbGUsIHJlY2VpdmluZ0NvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNJbnZhbGlkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRlcmFjdGlvbi5tdXRhdGVkRXZlbnRzID0gY3JlYXRlRW1wdHlFdmVudFN0b3JlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkcm9wcGFibGVFdmVudCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BsYXlEcmFnKHJlY2VpdmluZ0NvbnRleHQsIGludGVyYWN0aW9uKTtcclxuICAgICAgICAgICAgICAgIC8vIHNob3cgbWlycm9yIGlmIG5vIGFscmVhZHktcmVuZGVyZWQgbWlycm9yIGVsZW1lbnQgT1IgaWYgd2UgYXJlIHNodXR0aW5nIGRvd24gdGhlIG1pcnJvciAoPylcclxuICAgICAgICAgICAgICAgIC8vIFRPRE86IHdpc2ggd2UgY291bGQgc29tZWhvdyB3YWl0IGZvciBkaXNwYXRjaCB0byBndWFyYW50ZWUgcmVuZGVyXHJcbiAgICAgICAgICAgICAgICBkcmFnZ2luZy5zZXRNaXJyb3JJc1Zpc2libGUoaXNGaW5hbCB8fCAhZHJvcHBhYmxlRXZlbnQgfHwgIWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5mYy1ldmVudC1taXJyb3InKSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzSW52YWxpZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGVuYWJsZUN1cnNvcigpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlzYWJsZUN1cnNvcigpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCFpc0ZpbmFsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZHJhZ2dpbmcuc2V0TWlycm9yTmVlZHNSZXZlcnQoIWRyb3BwYWJsZUV2ZW50KTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlY2VpdmluZ0NvbnRleHQgPSByZWNlaXZpbmdDb250ZXh0O1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJvcHBhYmxlRXZlbnQgPSBkcm9wcGFibGVFdmVudDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdGhpcy5oYW5kbGVEcmFnRW5kID0gKHBldikgPT4ge1xyXG4gICAgICAgICAgICAgICAgbGV0IHsgcmVjZWl2aW5nQ29udGV4dCwgZHJvcHBhYmxlRXZlbnQgfSA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNsZWFyRHJhZygpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlY2VpdmluZ0NvbnRleHQgJiYgZHJvcHBhYmxlRXZlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgZmluYWxIaXQgPSB0aGlzLmhpdERyYWdnaW5nLmZpbmFsSGl0O1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBmaW5hbFZpZXcgPSBmaW5hbEhpdC5jb250ZXh0LnZpZXdBcGk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGRyYWdNZXRhID0gdGhpcy5kcmFnTWV0YTtcclxuICAgICAgICAgICAgICAgICAgICByZWNlaXZpbmdDb250ZXh0LmVtaXR0ZXIudHJpZ2dlcignZHJvcCcsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgYnVpbGREYXRlUG9pbnRBcGlXaXRoQ29udGV4dChmaW5hbEhpdC5kYXRlU3BhbiwgcmVjZWl2aW5nQ29udGV4dCkpLCB7IGRyYWdnZWRFbDogcGV2LnN1YmplY3RFbCwganNFdmVudDogcGV2Lm9yaWdFdmVudCwgdmlldzogZmluYWxWaWV3IH0pKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZHJhZ01ldGEuY3JlYXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBhZGRpbmdFdmVudHMgPSBldmVudFR1cGxlVG9TdG9yZShkcm9wcGFibGVFdmVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpdmluZ0NvbnRleHQuZGlzcGF0Y2goe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ01FUkdFX0VWRU5UUycsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudFN0b3JlOiBhZGRpbmdFdmVudHMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGV2LmlzVG91Y2gpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpdmluZ0NvbnRleHQuZGlzcGF0Y2goe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdTRUxFQ1RfRVZFTlQnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50SW5zdGFuY2VJZDogZHJvcHBhYmxlRXZlbnQuaW5zdGFuY2UuaW5zdGFuY2VJZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNpZ25hbCB0aGF0IGFuIGV4dGVybmFsIGV2ZW50IGxhbmRlZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZWNlaXZpbmdDb250ZXh0LmVtaXR0ZXIudHJpZ2dlcignZXZlbnRSZWNlaXZlJywge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IG5ldyBFdmVudEltcGwocmVjZWl2aW5nQ29udGV4dCwgZHJvcHBhYmxlRXZlbnQuZGVmLCBkcm9wcGFibGVFdmVudC5pbnN0YW5jZSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWxhdGVkRXZlbnRzOiBbXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldmVydCgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWNlaXZpbmdDb250ZXh0LmRpc3BhdGNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ1JFTU9WRV9FVkVOVFMnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudFN0b3JlOiBhZGRpbmdFdmVudHMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZHJhZ2dlZEVsOiBwZXYuc3ViamVjdEVsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlldzogZmluYWxWaWV3LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlY2VpdmluZ0NvbnRleHQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kcm9wcGFibGVFdmVudCA9IG51bGw7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGxldCBoaXREcmFnZ2luZyA9IHRoaXMuaGl0RHJhZ2dpbmcgPSBuZXcgSGl0RHJhZ2dpbmcoZHJhZ2dpbmcsIGludGVyYWN0aW9uU2V0dGluZ3NTdG9yZSk7XHJcbiAgICAgICAgICAgIGhpdERyYWdnaW5nLnJlcXVpcmVJbml0aWFsID0gZmFsc2U7IC8vIHdpbGwgc3RhcnQgb3V0c2lkZSBvZiBhIGNvbXBvbmVudFxyXG4gICAgICAgICAgICBoaXREcmFnZ2luZy5lbWl0dGVyLm9uKCdkcmFnc3RhcnQnLCB0aGlzLmhhbmRsZURyYWdTdGFydCk7XHJcbiAgICAgICAgICAgIGhpdERyYWdnaW5nLmVtaXR0ZXIub24oJ2hpdHVwZGF0ZScsIHRoaXMuaGFuZGxlSGl0VXBkYXRlKTtcclxuICAgICAgICAgICAgaGl0RHJhZ2dpbmcuZW1pdHRlci5vbignZHJhZ2VuZCcsIHRoaXMuaGFuZGxlRHJhZ0VuZCk7XHJcbiAgICAgICAgICAgIHRoaXMuc3VwcGxpZWREcmFnTWV0YSA9IHN1cHBsaWVkRHJhZ01ldGE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJ1aWxkRHJhZ01ldGEoc3ViamVjdEVsKSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5zdXBwbGllZERyYWdNZXRhID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlRHJhZ01ldGEodGhpcy5zdXBwbGllZERyYWdNZXRhKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMuc3VwcGxpZWREcmFnTWV0YSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlRHJhZ01ldGEodGhpcy5zdXBwbGllZERyYWdNZXRhKHN1YmplY3RFbCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBnZXREcmFnTWV0YUZyb21FbChzdWJqZWN0RWwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkaXNwbGF5RHJhZyhuZXh0Q29udGV4dCwgc3RhdGUpIHtcclxuICAgICAgICAgICAgbGV0IHByZXZDb250ZXh0ID0gdGhpcy5yZWNlaXZpbmdDb250ZXh0O1xyXG4gICAgICAgICAgICBpZiAocHJldkNvbnRleHQgJiYgcHJldkNvbnRleHQgIT09IG5leHRDb250ZXh0KSB7XHJcbiAgICAgICAgICAgICAgICBwcmV2Q29udGV4dC5kaXNwYXRjaCh7IHR5cGU6ICdVTlNFVF9FVkVOVF9EUkFHJyB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobmV4dENvbnRleHQpIHtcclxuICAgICAgICAgICAgICAgIG5leHRDb250ZXh0LmRpc3BhdGNoKHsgdHlwZTogJ1NFVF9FVkVOVF9EUkFHJywgc3RhdGUgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY2xlYXJEcmFnKCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5yZWNlaXZpbmdDb250ZXh0KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlY2VpdmluZ0NvbnRleHQuZGlzcGF0Y2goeyB0eXBlOiAnVU5TRVRfRVZFTlRfRFJBRycgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY2FuRHJvcEVsT25DYWxlbmRhcihlbCwgcmVjZWl2aW5nQ29udGV4dCkge1xyXG4gICAgICAgICAgICBsZXQgZHJvcEFjY2VwdCA9IHJlY2VpdmluZ0NvbnRleHQub3B0aW9ucy5kcm9wQWNjZXB0O1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGRyb3BBY2NlcHQgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBkcm9wQWNjZXB0LmNhbGwocmVjZWl2aW5nQ29udGV4dC5jYWxlbmRhckFwaSwgZWwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZHJvcEFjY2VwdCA9PT0gJ3N0cmluZycgJiYgZHJvcEFjY2VwdCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIEJvb2xlYW4oZWxlbWVudE1hdGNoZXMoZWwsIGRyb3BBY2NlcHQpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBVdGlscyBmb3IgY29tcHV0aW5nIGV2ZW50IHN0b3JlIGZyb20gdGhlIERyYWdNZXRhXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICBmdW5jdGlvbiBjb21wdXRlRXZlbnRGb3JEYXRlU3BhbihkYXRlU3BhbiwgZHJhZ01ldGEsIGNvbnRleHQpIHtcclxuICAgICAgICBsZXQgZGVmUHJvcHMgPSBPYmplY3QuYXNzaWduKHt9LCBkcmFnTWV0YS5sZWZ0b3ZlclByb3BzKTtcclxuICAgICAgICBmb3IgKGxldCB0cmFuc2Zvcm0gb2YgY29udGV4dC5wbHVnaW5Ib29rcy5leHRlcm5hbERlZlRyYW5zZm9ybXMpIHtcclxuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihkZWZQcm9wcywgdHJhbnNmb3JtKGRhdGVTcGFuLCBkcmFnTWV0YSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgeyByZWZpbmVkLCBleHRyYSB9ID0gcmVmaW5lRXZlbnREZWYoZGVmUHJvcHMsIGNvbnRleHQpO1xyXG4gICAgICAgIGxldCBkZWYgPSBwYXJzZUV2ZW50RGVmKHJlZmluZWQsIGV4dHJhLCBkcmFnTWV0YS5zb3VyY2VJZCwgZGF0ZVNwYW4uYWxsRGF5LCBjb250ZXh0Lm9wdGlvbnMuZm9yY2VFdmVudER1cmF0aW9uIHx8IEJvb2xlYW4oZHJhZ01ldGEuZHVyYXRpb24pLCAvLyBoYXNFbmRcclxuICAgICAgICBjb250ZXh0KTtcclxuICAgICAgICBsZXQgc3RhcnQgPSBkYXRlU3Bhbi5yYW5nZS5zdGFydDtcclxuICAgICAgICAvLyBvbmx5IHJlbHkgb24gdGltZSBpbmZvIGlmIGRyb3Agem9uZSBpcyBhbGwtZGF5LFxyXG4gICAgICAgIC8vIG90aGVyd2lzZSwgd2UgYWxyZWFkeSBrbm93IHRoZSB0aW1lXHJcbiAgICAgICAgaWYgKGRhdGVTcGFuLmFsbERheSAmJiBkcmFnTWV0YS5zdGFydFRpbWUpIHtcclxuICAgICAgICAgICAgc3RhcnQgPSBjb250ZXh0LmRhdGVFbnYuYWRkKHN0YXJ0LCBkcmFnTWV0YS5zdGFydFRpbWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgZW5kID0gZHJhZ01ldGEuZHVyYXRpb24gP1xyXG4gICAgICAgICAgICBjb250ZXh0LmRhdGVFbnYuYWRkKHN0YXJ0LCBkcmFnTWV0YS5kdXJhdGlvbikgOlxyXG4gICAgICAgICAgICBnZXREZWZhdWx0RXZlbnRFbmQoZGF0ZVNwYW4uYWxsRGF5LCBzdGFydCwgY29udGV4dCk7XHJcbiAgICAgICAgbGV0IGluc3RhbmNlID0gY3JlYXRlRXZlbnRJbnN0YW5jZShkZWYuZGVmSWQsIHsgc3RhcnQsIGVuZCB9KTtcclxuICAgICAgICByZXR1cm4geyBkZWYsIGluc3RhbmNlIH07XHJcbiAgICB9XHJcbiAgICAvLyBVdGlscyBmb3IgZXh0cmFjdGluZyBkYXRhIGZyb20gZWxlbWVudFxyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgZnVuY3Rpb24gZ2V0RHJhZ01ldGFGcm9tRWwoZWwpIHtcclxuICAgICAgICBsZXQgc3RyID0gZ2V0RW1iZWRkZWRFbERhdGEoZWwsICdldmVudCcpO1xyXG4gICAgICAgIGxldCBvYmogPSBzdHIgP1xyXG4gICAgICAgICAgICBKU09OLnBhcnNlKHN0cikgOlxyXG4gICAgICAgICAgICB7IGNyZWF0ZTogZmFsc2UgfTsgLy8gaWYgbm8gZW1iZWRkZWQgZGF0YSwgYXNzdW1lIG5vIGV2ZW50IGNyZWF0aW9uXHJcbiAgICAgICAgcmV0dXJuIHBhcnNlRHJhZ01ldGEob2JqKTtcclxuICAgIH1cclxuICAgIGNvbmZpZy5kYXRhQXR0clByZWZpeCA9ICcnO1xyXG4gICAgZnVuY3Rpb24gZ2V0RW1iZWRkZWRFbERhdGEoZWwsIG5hbWUpIHtcclxuICAgICAgICBsZXQgcHJlZml4ID0gY29uZmlnLmRhdGFBdHRyUHJlZml4O1xyXG4gICAgICAgIGxldCBwcmVmaXhlZE5hbWUgPSAocHJlZml4ID8gcHJlZml4ICsgJy0nIDogJycpICsgbmFtZTtcclxuICAgICAgICByZXR1cm4gZWwuZ2V0QXR0cmlidXRlKCdkYXRhLScgKyBwcmVmaXhlZE5hbWUpIHx8ICcnO1xyXG4gICAgfVxyXG5cclxuICAgIC8qXHJcbiAgICBNYWtlcyBhbiBlbGVtZW50ICh0aGF0IGlzICpleHRlcm5hbCogdG8gYW55IGNhbGVuZGFyKSBkcmFnZ2FibGUuXHJcbiAgICBDYW4gcGFzcyBpbiBkYXRhIHRoYXQgZGV0ZXJtaW5lcyBob3cgYW4gZXZlbnQgd2lsbCBiZSBjcmVhdGVkIHdoZW4gZHJvcHBlZCBvbnRvIGEgY2FsZW5kYXIuXHJcbiAgICBMZXZlcmFnZXMgRnVsbENhbGVuZGFyJ3MgaW50ZXJuYWwgZHJhZy1uLWRyb3AgZnVuY3Rpb25hbGl0eSBXSVRIT1VUIGEgdGhpcmQtcGFydHkgZHJhZyBzeXN0ZW0uXHJcbiAgICAqL1xyXG4gICAgY2xhc3MgRXh0ZXJuYWxEcmFnZ2FibGUge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yKGVsLCBzZXR0aW5ncyA9IHt9KSB7XHJcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlUG9pbnRlckRvd24gPSAoZXYpID0+IHtcclxuICAgICAgICAgICAgICAgIGxldCB7IGRyYWdnaW5nIH0gPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgbGV0IHsgbWluRGlzdGFuY2UsIGxvbmdQcmVzc0RlbGF5IH0gPSB0aGlzLnNldHRpbmdzO1xyXG4gICAgICAgICAgICAgICAgZHJhZ2dpbmcubWluRGlzdGFuY2UgPVxyXG4gICAgICAgICAgICAgICAgICAgIG1pbkRpc3RhbmNlICE9IG51bGwgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5EaXN0YW5jZSA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChldi5pc1RvdWNoID8gMCA6IEJBU0VfT1BUSU9OX0RFRkFVTFRTLmV2ZW50RHJhZ01pbkRpc3RhbmNlKTtcclxuICAgICAgICAgICAgICAgIGRyYWdnaW5nLmRlbGF5ID1cclxuICAgICAgICAgICAgICAgICAgICBldi5pc1RvdWNoID8gLy8gVE9ETzogZXZlbnR1YWxseSByZWFkIGV2ZW50TG9uZ1ByZXNzRGVsYXkgaW5zdGVhZCB2dnZcclxuICAgICAgICAgICAgICAgICAgICAgICAgKGxvbmdQcmVzc0RlbGF5ICE9IG51bGwgPyBsb25nUHJlc3NEZWxheSA6IEJBU0VfT1BUSU9OX0RFRkFVTFRTLmxvbmdQcmVzc0RlbGF5KSA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDA7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlRHJhZ1N0YXJ0ID0gKGV2KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXYuaXNUb3VjaCAmJlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmcuZGVsYXkgJiZcclxuICAgICAgICAgICAgICAgICAgICBldi5zdWJqZWN0RWwuY2xhc3NMaXN0LmNvbnRhaW5zKCdmYy1ldmVudCcpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmFnZ2luZy5taXJyb3IuZ2V0TWlycm9yRWwoKS5jbGFzc0xpc3QuYWRkKCdmYy1ldmVudC1zZWxlY3RlZCcpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB0aGlzLnNldHRpbmdzID0gc2V0dGluZ3M7XHJcbiAgICAgICAgICAgIGxldCBkcmFnZ2luZyA9IHRoaXMuZHJhZ2dpbmcgPSBuZXcgRmVhdHVyZWZ1bEVsZW1lbnREcmFnZ2luZyhlbCk7XHJcbiAgICAgICAgICAgIGRyYWdnaW5nLnRvdWNoU2Nyb2xsQWxsb3dlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBpZiAoc2V0dGluZ3MuaXRlbVNlbGVjdG9yICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGRyYWdnaW5nLnBvaW50ZXIuc2VsZWN0b3IgPSBzZXR0aW5ncy5pdGVtU2VsZWN0b3I7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHNldHRpbmdzLmFwcGVuZFRvICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGRyYWdnaW5nLm1pcnJvci5wYXJlbnROb2RlID0gc2V0dGluZ3MuYXBwZW5kVG87IC8vIFRPRE86IHdyaXRlIHRlc3RzXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZHJhZ2dpbmcuZW1pdHRlci5vbigncG9pbnRlcmRvd24nLCB0aGlzLmhhbmRsZVBvaW50ZXJEb3duKTtcclxuICAgICAgICAgICAgZHJhZ2dpbmcuZW1pdHRlci5vbignZHJhZ3N0YXJ0JywgdGhpcy5oYW5kbGVEcmFnU3RhcnQpO1xyXG4gICAgICAgICAgICBuZXcgRXh0ZXJuYWxFbGVtZW50RHJhZ2dpbmcoZHJhZ2dpbmcsIHNldHRpbmdzLmV2ZW50RGF0YSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRlc3Ryb3koKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmcuZGVzdHJveSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKlxyXG4gICAgRGV0ZWN0cyB3aGVuIGEgKlRISVJELVBBUlRZKiBkcmFnLW4tZHJvcCBzeXN0ZW0gaW50ZXJhY3RzIHdpdGggZWxlbWVudHMuXHJcbiAgICBUaGUgdGhpcmQtcGFydHkgc3lzdGVtIGlzIHJlc3BvbnNpYmxlIGZvciBkcmF3aW5nIHRoZSB2aXN1YWxzIGVmZmVjdHMgb2YgdGhlIGRyYWcuXHJcbiAgICBUaGlzIGNsYXNzIHNpbXBseSBtb25pdG9ycyBmb3IgcG9pbnRlciBtb3ZlbWVudHMgYW5kIGZpcmVzIGV2ZW50cy5cclxuICAgIEl0IGFsc28gaGFzIHRoZSBhYmlsaXR5IHRvIGhpZGUgdGhlIG1vdmluZyBlbGVtZW50ICh0aGUgXCJtaXJyb3JcIikgZHVyaW5nIHRoZSBkcmFnLlxyXG4gICAgKi9cclxuICAgIGNsYXNzIEluZmVycmVkRWxlbWVudERyYWdnaW5nIGV4dGVuZHMgRWxlbWVudERyYWdnaW5nIHtcclxuICAgICAgICBjb25zdHJ1Y3Rvcihjb250YWluZXJFbCkge1xyXG4gICAgICAgICAgICBzdXBlcihjb250YWluZXJFbCk7XHJcbiAgICAgICAgICAgIHRoaXMuc2hvdWxkSWdub3JlTW92ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLm1pcnJvclNlbGVjdG9yID0gJyc7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudE1pcnJvckVsID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5oYW5kbGVQb2ludGVyRG93biA9IChldikgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0dGVyLnRyaWdnZXIoJ3BvaW50ZXJkb3duJywgZXYpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnNob3VsZElnbm9yZU1vdmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBmaXJlIGRyYWdzdGFydCByaWdodCBhd2F5LiBkb2VzIG5vdCBzdXBwb3J0IGRlbGF5IG9yIG1pbi1kaXN0YW5jZVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdHRlci50cmlnZ2VyKCdkcmFnc3RhcnQnLCBldik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlUG9pbnRlck1vdmUgPSAoZXYpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5zaG91bGRJZ25vcmVNb3ZlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0dGVyLnRyaWdnZXIoJ2RyYWdtb3ZlJywgZXYpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB0aGlzLmhhbmRsZVBvaW50ZXJVcCA9IChldikgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0dGVyLnRyaWdnZXIoJ3BvaW50ZXJ1cCcsIGV2KTtcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5zaG91bGRJZ25vcmVNb3ZlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZmlyZSBkcmFnZW5kIHJpZ2h0IGF3YXkuIGRvZXMgbm90IHN1cHBvcnQgYSByZXZlcnQgYW5pbWF0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0dGVyLnRyaWdnZXIoJ2RyYWdlbmQnLCBldik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGxldCBwb2ludGVyID0gdGhpcy5wb2ludGVyID0gbmV3IFBvaW50ZXJEcmFnZ2luZyhjb250YWluZXJFbCk7XHJcbiAgICAgICAgICAgIHBvaW50ZXIuZW1pdHRlci5vbigncG9pbnRlcmRvd24nLCB0aGlzLmhhbmRsZVBvaW50ZXJEb3duKTtcclxuICAgICAgICAgICAgcG9pbnRlci5lbWl0dGVyLm9uKCdwb2ludGVybW92ZScsIHRoaXMuaGFuZGxlUG9pbnRlck1vdmUpO1xyXG4gICAgICAgICAgICBwb2ludGVyLmVtaXR0ZXIub24oJ3BvaW50ZXJ1cCcsIHRoaXMuaGFuZGxlUG9pbnRlclVwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZGVzdHJveSgpIHtcclxuICAgICAgICAgICAgdGhpcy5wb2ludGVyLmRlc3Ryb3koKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc2V0SWdub3JlTW92ZShib29sKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2hvdWxkSWdub3JlTW92ZSA9IGJvb2w7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNldE1pcnJvcklzVmlzaWJsZShib29sKSB7XHJcbiAgICAgICAgICAgIGlmIChib29sKSB7XHJcbiAgICAgICAgICAgICAgICAvLyByZXN0b3JlIGEgcHJldmlvdXNseSBoaWRkZW4gZWxlbWVudC5cclxuICAgICAgICAgICAgICAgIC8vIHVzZSB0aGUgcmVmZXJlbmNlIGluIGNhc2UgdGhlIHNlbGVjdG9yIGNsYXNzIGhhcyBhbHJlYWR5IGJlZW4gcmVtb3ZlZC5cclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRNaXJyb3JFbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudE1pcnJvckVsLnN0eWxlLnZpc2liaWxpdHkgPSAnJztcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRNaXJyb3JFbCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgbWlycm9yRWwgPSB0aGlzLm1pcnJvclNlbGVjdG9yXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogc29tZWhvdyBxdWVyeSBGdWxsQ2FsZW5kYXJzIFdJVEhJTiBzaGFkb3ctcm9vdHNcclxuICAgICAgICAgICAgICAgICAgICA/IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGhpcy5taXJyb3JTZWxlY3RvcilcclxuICAgICAgICAgICAgICAgICAgICA6IG51bGw7XHJcbiAgICAgICAgICAgICAgICBpZiAobWlycm9yRWwpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRNaXJyb3JFbCA9IG1pcnJvckVsO1xyXG4gICAgICAgICAgICAgICAgICAgIG1pcnJvckVsLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKlxyXG4gICAgQnJpZGdlcyB0aGlyZC1wYXJ0eSBkcmFnLW4tZHJvcCBzeXN0ZW1zIHdpdGggRnVsbENhbGVuZGFyLlxyXG4gICAgTXVzdCBiZSBpbnN0YW50aWF0ZWQgYW5kIGRlc3Ryb3llZCBieSBjYWxsZXIuXHJcbiAgICAqL1xyXG4gICAgY2xhc3MgVGhpcmRQYXJ0eURyYWdnYWJsZSB7XHJcbiAgICAgICAgY29uc3RydWN0b3IoY29udGFpbmVyT3JTZXR0aW5ncywgc2V0dGluZ3MpIHtcclxuICAgICAgICAgICAgbGV0IGNvbnRhaW5lckVsID0gZG9jdW1lbnQ7XHJcbiAgICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgLy8gd2lzaCB3ZSBjb3VsZCBqdXN0IHRlc3QgaW5zdGFuY2VvZiBFdmVudFRhcmdldCwgYnV0IGRvZXNuJ3Qgd29yayBpbiBJRTExXHJcbiAgICAgICAgICAgIGNvbnRhaW5lck9yU2V0dGluZ3MgPT09IGRvY3VtZW50IHx8XHJcbiAgICAgICAgICAgICAgICBjb250YWluZXJPclNldHRpbmdzIGluc3RhbmNlb2YgRWxlbWVudCkge1xyXG4gICAgICAgICAgICAgICAgY29udGFpbmVyRWwgPSBjb250YWluZXJPclNldHRpbmdzO1xyXG4gICAgICAgICAgICAgICAgc2V0dGluZ3MgPSBzZXR0aW5ncyB8fCB7fTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHNldHRpbmdzID0gKGNvbnRhaW5lck9yU2V0dGluZ3MgfHwge30pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxldCBkcmFnZ2luZyA9IHRoaXMuZHJhZ2dpbmcgPSBuZXcgSW5mZXJyZWRFbGVtZW50RHJhZ2dpbmcoY29udGFpbmVyRWwpO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHNldHRpbmdzLml0ZW1TZWxlY3RvciA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgIGRyYWdnaW5nLnBvaW50ZXIuc2VsZWN0b3IgPSBzZXR0aW5ncy5pdGVtU2VsZWN0b3I7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY29udGFpbmVyRWwgPT09IGRvY3VtZW50KSB7XHJcbiAgICAgICAgICAgICAgICBkcmFnZ2luZy5wb2ludGVyLnNlbGVjdG9yID0gJ1tkYXRhLWV2ZW50XSc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBzZXR0aW5ncy5taXJyb3JTZWxlY3RvciA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgIGRyYWdnaW5nLm1pcnJvclNlbGVjdG9yID0gc2V0dGluZ3MubWlycm9yU2VsZWN0b3I7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbmV3IEV4dGVybmFsRWxlbWVudERyYWdnaW5nKGRyYWdnaW5nLCBzZXR0aW5ncy5ldmVudERhdGEpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xyXG4gICAgICAgIH1cclxuICAgICAgICBkZXN0cm95KCkge1xyXG4gICAgICAgICAgICB0aGlzLmRyYWdnaW5nLmRlc3Ryb3koKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGluZGV4JDQgPSBjcmVhdGVQbHVnaW4oe1xyXG4gICAgICAgIG5hbWU6ICdAZnVsbGNhbGVuZGFyL2ludGVyYWN0aW9uJyxcclxuICAgICAgICBjb21wb25lbnRJbnRlcmFjdGlvbnM6IFtEYXRlQ2xpY2tpbmcsIERhdGVTZWxlY3RpbmcsIEV2ZW50RHJhZ2dpbmcsIEV2ZW50UmVzaXppbmddLFxyXG4gICAgICAgIGNhbGVuZGFySW50ZXJhY3Rpb25zOiBbVW5zZWxlY3RBdXRvXSxcclxuICAgICAgICBlbGVtZW50RHJhZ2dpbmdJbXBsOiBGZWF0dXJlZnVsRWxlbWVudERyYWdnaW5nLFxyXG4gICAgICAgIG9wdGlvblJlZmluZXJzOiBPUFRJT05fUkVGSU5FUlMkMyxcclxuICAgICAgICBsaXN0ZW5lclJlZmluZXJzOiBMSVNURU5FUl9SRUZJTkVSUyxcclxuICAgIH0pO1xyXG5cclxuICAgIHZhciBjc3NfMjQ4eiQzID0gXCI6cm9vdHstLWZjLWRheWdyaWQtZXZlbnQtZG90LXdpZHRoOjhweH0uZmMtZGF5Z3JpZC1kYXktZXZlbnRzOmFmdGVyLC5mYy1kYXlncmlkLWRheS1ldmVudHM6YmVmb3JlLC5mYy1kYXlncmlkLWRheS1mcmFtZTphZnRlciwuZmMtZGF5Z3JpZC1kYXktZnJhbWU6YmVmb3JlLC5mYy1kYXlncmlkLWV2ZW50LWhhcm5lc3M6YWZ0ZXIsLmZjLWRheWdyaWQtZXZlbnQtaGFybmVzczpiZWZvcmV7Y2xlYXI6Ym90aDtjb250ZW50OlxcXCJcXFwiO2Rpc3BsYXk6dGFibGV9LmZjIC5mYy1kYXlncmlkLWJvZHl7cG9zaXRpb246cmVsYXRpdmU7ei1pbmRleDoxfS5mYyAuZmMtZGF5Z3JpZC1kYXkuZmMtZGF5LXRvZGF5e2JhY2tncm91bmQtY29sb3I6dmFyKC0tZmMtdG9kYXktYmctY29sb3IpfS5mYyAuZmMtZGF5Z3JpZC1kYXktZnJhbWV7bWluLWhlaWdodDoxMDAlO3Bvc2l0aW9uOnJlbGF0aXZlfS5mYyAuZmMtZGF5Z3JpZC1kYXktdG9we2Rpc3BsYXk6ZmxleDtmbGV4LWRpcmVjdGlvbjpyb3ctcmV2ZXJzZX0uZmMgLmZjLWRheS1vdGhlciAuZmMtZGF5Z3JpZC1kYXktdG9we29wYWNpdHk6LjN9LmZjIC5mYy1kYXlncmlkLWRheS1udW1iZXJ7cGFkZGluZzo0cHg7cG9zaXRpb246cmVsYXRpdmU7ei1pbmRleDo0fS5mYyAuZmMtZGF5Z3JpZC1tb250aC1zdGFydHtmb250LXNpemU6MS4xZW07Zm9udC13ZWlnaHQ6NzAwfS5mYyAuZmMtZGF5Z3JpZC1kYXktZXZlbnRze21hcmdpbi10b3A6MXB4fS5mYyAuZmMtZGF5Z3JpZC1ib2R5LWJhbGFuY2VkIC5mYy1kYXlncmlkLWRheS1ldmVudHN7bGVmdDowO3Bvc2l0aW9uOmFic29sdXRlO3JpZ2h0OjB9LmZjIC5mYy1kYXlncmlkLWJvZHktdW5iYWxhbmNlZCAuZmMtZGF5Z3JpZC1kYXktZXZlbnRze21pbi1oZWlnaHQ6MmVtO3Bvc2l0aW9uOnJlbGF0aXZlfS5mYyAuZmMtZGF5Z3JpZC1ib2R5LW5hdHVyYWwgLmZjLWRheWdyaWQtZGF5LWV2ZW50c3ttYXJnaW4tYm90dG9tOjFlbX0uZmMgLmZjLWRheWdyaWQtZXZlbnQtaGFybmVzc3twb3NpdGlvbjpyZWxhdGl2ZX0uZmMgLmZjLWRheWdyaWQtZXZlbnQtaGFybmVzcy1hYnN7bGVmdDowO3Bvc2l0aW9uOmFic29sdXRlO3JpZ2h0OjA7dG9wOjB9LmZjIC5mYy1kYXlncmlkLWJnLWhhcm5lc3N7Ym90dG9tOjA7cG9zaXRpb246YWJzb2x1dGU7dG9wOjB9LmZjIC5mYy1kYXlncmlkLWRheS1iZyAuZmMtbm9uLWJ1c2luZXNze3otaW5kZXg6MX0uZmMgLmZjLWRheWdyaWQtZGF5LWJnIC5mYy1iZy1ldmVudHt6LWluZGV4OjJ9LmZjIC5mYy1kYXlncmlkLWRheS1iZyAuZmMtaGlnaGxpZ2h0e3otaW5kZXg6M30uZmMgLmZjLWRheWdyaWQtZXZlbnR7bWFyZ2luLXRvcDoxcHg7ei1pbmRleDo2fS5mYyAuZmMtZGF5Z3JpZC1ldmVudC5mYy1ldmVudC1taXJyb3J7ei1pbmRleDo3fS5mYyAuZmMtZGF5Z3JpZC1kYXktYm90dG9te2ZvbnQtc2l6ZTouODVlbTttYXJnaW46MCAycHh9LmZjIC5mYy1kYXlncmlkLWRheS1ib3R0b206YWZ0ZXIsLmZjIC5mYy1kYXlncmlkLWRheS1ib3R0b206YmVmb3Jle2NsZWFyOmJvdGg7Y29udGVudDpcXFwiXFxcIjtkaXNwbGF5OnRhYmxlfS5mYyAuZmMtZGF5Z3JpZC1tb3JlLWxpbmt7Ym9yZGVyLXJhZGl1czozcHg7Y3Vyc29yOnBvaW50ZXI7bGluZS1oZWlnaHQ6MTttYXJnaW4tdG9wOjFweDttYXgtd2lkdGg6MTAwJTtvdmVyZmxvdzpoaWRkZW47cGFkZGluZzoycHg7cG9zaXRpb246cmVsYXRpdmU7d2hpdGUtc3BhY2U6bm93cmFwO3otaW5kZXg6NH0uZmMgLmZjLWRheWdyaWQtbW9yZS1saW5rOmhvdmVye2JhY2tncm91bmQtY29sb3I6cmdiYSgwLDAsMCwuMSl9LmZjIC5mYy1kYXlncmlkLXdlZWstbnVtYmVye2JhY2tncm91bmQtY29sb3I6dmFyKC0tZmMtbmV1dHJhbC1iZy1jb2xvcik7Y29sb3I6dmFyKC0tZmMtbmV1dHJhbC10ZXh0LWNvbG9yKTttaW4td2lkdGg6MS41ZW07cGFkZGluZzoycHg7cG9zaXRpb246YWJzb2x1dGU7dGV4dC1hbGlnbjpjZW50ZXI7dG9wOjA7ei1pbmRleDo1fS5mYyAuZmMtbW9yZS1wb3BvdmVyIC5mYy1wb3BvdmVyLWJvZHl7bWluLXdpZHRoOjIyMHB4O3BhZGRpbmc6MTBweH0uZmMtZGlyZWN0aW9uLWx0ciAuZmMtZGF5Z3JpZC1ldmVudC5mYy1ldmVudC1zdGFydCwuZmMtZGlyZWN0aW9uLXJ0bCAuZmMtZGF5Z3JpZC1ldmVudC5mYy1ldmVudC1lbmR7bWFyZ2luLWxlZnQ6MnB4fS5mYy1kaXJlY3Rpb24tbHRyIC5mYy1kYXlncmlkLWV2ZW50LmZjLWV2ZW50LWVuZCwuZmMtZGlyZWN0aW9uLXJ0bCAuZmMtZGF5Z3JpZC1ldmVudC5mYy1ldmVudC1zdGFydHttYXJnaW4tcmlnaHQ6MnB4fS5mYy1kaXJlY3Rpb24tbHRyIC5mYy1kYXlncmlkLW1vcmUtbGlua3tmbG9hdDpsZWZ0fS5mYy1kaXJlY3Rpb24tbHRyIC5mYy1kYXlncmlkLXdlZWstbnVtYmVye2JvcmRlci1yYWRpdXM6MCAwIDNweCAwO2xlZnQ6MH0uZmMtZGlyZWN0aW9uLXJ0bCAuZmMtZGF5Z3JpZC1tb3JlLWxpbmt7ZmxvYXQ6cmlnaHR9LmZjLWRpcmVjdGlvbi1ydGwgLmZjLWRheWdyaWQtd2Vlay1udW1iZXJ7Ym9yZGVyLXJhZGl1czowIDAgMCAzcHg7cmlnaHQ6MH0uZmMtbGlxdWlkLWhhY2sgLmZjLWRheWdyaWQtZGF5LWZyYW1le3Bvc2l0aW9uOnN0YXRpY30uZmMtZGF5Z3JpZC1ldmVudHtib3JkZXItcmFkaXVzOjNweDtmb250LXNpemU6dmFyKC0tZmMtc21hbGwtZm9udC1zaXplKTtwb3NpdGlvbjpyZWxhdGl2ZTt3aGl0ZS1zcGFjZTpub3dyYXB9LmZjLWRheWdyaWQtYmxvY2stZXZlbnQgLmZjLWV2ZW50LXRpbWV7Zm9udC13ZWlnaHQ6NzAwfS5mYy1kYXlncmlkLWJsb2NrLWV2ZW50IC5mYy1ldmVudC10aW1lLC5mYy1kYXlncmlkLWJsb2NrLWV2ZW50IC5mYy1ldmVudC10aXRsZXtwYWRkaW5nOjFweH0uZmMtZGF5Z3JpZC1kb3QtZXZlbnR7YWxpZ24taXRlbXM6Y2VudGVyO2Rpc3BsYXk6ZmxleDtwYWRkaW5nOjJweCAwfS5mYy1kYXlncmlkLWRvdC1ldmVudCAuZmMtZXZlbnQtdGl0bGV7ZmxleC1ncm93OjE7ZmxleC1zaHJpbms6MTtmb250LXdlaWdodDo3MDA7bWluLXdpZHRoOjA7b3ZlcmZsb3c6aGlkZGVufS5mYy1kYXlncmlkLWRvdC1ldmVudC5mYy1ldmVudC1taXJyb3IsLmZjLWRheWdyaWQtZG90LWV2ZW50OmhvdmVye2JhY2tncm91bmQ6cmdiYSgwLDAsMCwuMSl9LmZjLWRheWdyaWQtZG90LWV2ZW50LmZjLWV2ZW50LXNlbGVjdGVkOmJlZm9yZXtib3R0b206LTEwcHg7dG9wOi0xMHB4fS5mYy1kYXlncmlkLWV2ZW50LWRvdHtib3JkZXI6Y2FsYyh2YXIoLS1mYy1kYXlncmlkLWV2ZW50LWRvdC13aWR0aCkvMikgc29saWQgdmFyKC0tZmMtZXZlbnQtYm9yZGVyLWNvbG9yKTtib3JkZXItcmFkaXVzOmNhbGModmFyKC0tZmMtZGF5Z3JpZC1ldmVudC1kb3Qtd2lkdGgpLzIpO2JveC1zaXppbmc6Y29udGVudC1ib3g7aGVpZ2h0OjA7bWFyZ2luOjAgNHB4O3dpZHRoOjB9LmZjLWRpcmVjdGlvbi1sdHIgLmZjLWRheWdyaWQtZXZlbnQgLmZjLWV2ZW50LXRpbWV7bWFyZ2luLXJpZ2h0OjNweH0uZmMtZGlyZWN0aW9uLXJ0bCAuZmMtZGF5Z3JpZC1ldmVudCAuZmMtZXZlbnQtdGltZXttYXJnaW4tbGVmdDozcHh9XCI7XHJcbiAgICBpbmplY3RTdHlsZXMoY3NzXzI0OHokMyk7XHJcblxyXG4gICAgZnVuY3Rpb24gc3BsaXRTZWdzQnlSb3coc2Vncywgcm93Q250KSB7XHJcbiAgICAgICAgbGV0IGJ5Um93ID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByb3dDbnQ7IGkgKz0gMSkge1xyXG4gICAgICAgICAgICBieVJvd1tpXSA9IFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGxldCBzZWcgb2Ygc2Vncykge1xyXG4gICAgICAgICAgICBieVJvd1tzZWcucm93XS5wdXNoKHNlZyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBieVJvdztcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHNwbGl0U2Vnc0J5Rmlyc3RDb2woc2VncywgY29sQ250KSB7XHJcbiAgICAgICAgbGV0IGJ5Q29sID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2xDbnQ7IGkgKz0gMSkge1xyXG4gICAgICAgICAgICBieUNvbFtpXSA9IFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGxldCBzZWcgb2Ygc2Vncykge1xyXG4gICAgICAgICAgICBieUNvbFtzZWcuZmlyc3RDb2xdLnB1c2goc2VnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGJ5Q29sO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gc3BsaXRJbnRlcmFjdGlvbkJ5Um93KHVpLCByb3dDbnQpIHtcclxuICAgICAgICBsZXQgYnlSb3cgPSBbXTtcclxuICAgICAgICBpZiAoIXVpKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcm93Q250OyBpICs9IDEpIHtcclxuICAgICAgICAgICAgICAgIGJ5Um93W2ldID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByb3dDbnQ7IGkgKz0gMSkge1xyXG4gICAgICAgICAgICAgICAgYnlSb3dbaV0gPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWZmZWN0ZWRJbnN0YW5jZXM6IHVpLmFmZmVjdGVkSW5zdGFuY2VzLFxyXG4gICAgICAgICAgICAgICAgICAgIGlzRXZlbnQ6IHVpLmlzRXZlbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgc2VnczogW10sXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvciAobGV0IHNlZyBvZiB1aS5zZWdzKSB7XHJcbiAgICAgICAgICAgICAgICBieVJvd1tzZWcucm93XS5zZWdzLnB1c2goc2VnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYnlSb3c7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgREVGQVVMVF9UQUJMRV9FVkVOVF9USU1FX0ZPUk1BVCA9IGNyZWF0ZUZvcm1hdHRlcih7XHJcbiAgICAgICAgaG91cjogJ251bWVyaWMnLFxyXG4gICAgICAgIG1pbnV0ZTogJzItZGlnaXQnLFxyXG4gICAgICAgIG9taXRaZXJvTWludXRlOiB0cnVlLFxyXG4gICAgICAgIG1lcmlkaWVtOiAnbmFycm93JyxcclxuICAgIH0pO1xyXG4gICAgZnVuY3Rpb24gaGFzTGlzdEl0ZW1EaXNwbGF5KHNlZykge1xyXG4gICAgICAgIGxldCB7IGRpc3BsYXkgfSA9IHNlZy5ldmVudFJhbmdlLnVpO1xyXG4gICAgICAgIHJldHVybiBkaXNwbGF5ID09PSAnbGlzdC1pdGVtJyB8fCAoZGlzcGxheSA9PT0gJ2F1dG8nICYmXHJcbiAgICAgICAgICAgICFzZWcuZXZlbnRSYW5nZS5kZWYuYWxsRGF5ICYmXHJcbiAgICAgICAgICAgIHNlZy5maXJzdENvbCA9PT0gc2VnLmxhc3RDb2wgJiYgLy8gY2FuJ3QgYmUgbXVsdGktZGF5XHJcbiAgICAgICAgICAgIHNlZy5pc1N0YXJ0ICYmIC8vIFwiXHJcbiAgICAgICAgICAgIHNlZy5pc0VuZCAvLyBcIlxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgY2xhc3MgVGFibGVCbG9ja0V2ZW50IGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XHJcbiAgICAgICAgcmVuZGVyKCkge1xyXG4gICAgICAgICAgICBsZXQgeyBwcm9wcyB9ID0gdGhpcztcclxuICAgICAgICAgICAgcmV0dXJuICh5KFN0YW5kYXJkRXZlbnQsIE9iamVjdC5hc3NpZ24oe30sIHByb3BzLCB7IGVsQ2xhc3NlczogWydmYy1kYXlncmlkLWV2ZW50JywgJ2ZjLWRheWdyaWQtYmxvY2stZXZlbnQnLCAnZmMtaC1ldmVudCddLCBkZWZhdWx0VGltZUZvcm1hdDogREVGQVVMVF9UQUJMRV9FVkVOVF9USU1FX0ZPUk1BVCwgZGVmYXVsdERpc3BsYXlFdmVudEVuZDogcHJvcHMuZGVmYXVsdERpc3BsYXlFdmVudEVuZCwgZGlzYWJsZVJlc2l6aW5nOiAhcHJvcHMuc2VnLmV2ZW50UmFuZ2UuZGVmLmFsbERheSB9KSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBjbGFzcyBUYWJsZUxpc3RJdGVtRXZlbnQgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcclxuICAgICAgICByZW5kZXIoKSB7XHJcbiAgICAgICAgICAgIGxldCB7IHByb3BzLCBjb250ZXh0IH0gPSB0aGlzO1xyXG4gICAgICAgICAgICBsZXQgeyBvcHRpb25zIH0gPSBjb250ZXh0O1xyXG4gICAgICAgICAgICBsZXQgeyBzZWcgfSA9IHByb3BzO1xyXG4gICAgICAgICAgICBsZXQgdGltZUZvcm1hdCA9IG9wdGlvbnMuZXZlbnRUaW1lRm9ybWF0IHx8IERFRkFVTFRfVEFCTEVfRVZFTlRfVElNRV9GT1JNQVQ7XHJcbiAgICAgICAgICAgIGxldCB0aW1lVGV4dCA9IGJ1aWxkU2VnVGltZVRleHQoc2VnLCB0aW1lRm9ybWF0LCBjb250ZXh0LCB0cnVlLCBwcm9wcy5kZWZhdWx0RGlzcGxheUV2ZW50RW5kKTtcclxuICAgICAgICAgICAgcmV0dXJuICh5KEV2ZW50Q29udGFpbmVyLCBPYmplY3QuYXNzaWduKHt9LCBwcm9wcywgeyBlbFRhZzogXCJhXCIsIGVsQ2xhc3NlczogWydmYy1kYXlncmlkLWV2ZW50JywgJ2ZjLWRheWdyaWQtZG90LWV2ZW50J10sIGVsQXR0cnM6IGdldFNlZ0FuY2hvckF0dHJzKHByb3BzLnNlZywgY29udGV4dCksIGRlZmF1bHRHZW5lcmF0b3I6IHJlbmRlcklubmVyQ29udGVudCQyLCB0aW1lVGV4dDogdGltZVRleHQsIGlzUmVzaXppbmc6IGZhbHNlLCBpc0RhdGVTZWxlY3Rpbmc6IGZhbHNlIH0pKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gcmVuZGVySW5uZXJDb250ZW50JDIocmVuZGVyUHJvcHMpIHtcclxuICAgICAgICByZXR1cm4gKHkoXywgbnVsbCxcclxuICAgICAgICAgICAgeShcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy1kYXlncmlkLWV2ZW50LWRvdFwiLCBzdHlsZTogeyBib3JkZXJDb2xvcjogcmVuZGVyUHJvcHMuYm9yZGVyQ29sb3IgfHwgcmVuZGVyUHJvcHMuYmFja2dyb3VuZENvbG9yIH0gfSksXHJcbiAgICAgICAgICAgIHJlbmRlclByb3BzLnRpbWVUZXh0ICYmICh5KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLWV2ZW50LXRpbWVcIiB9LCByZW5kZXJQcm9wcy50aW1lVGV4dCkpLFxyXG4gICAgICAgICAgICB5KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLWV2ZW50LXRpdGxlXCIgfSwgcmVuZGVyUHJvcHMuZXZlbnQudGl0bGUgfHwgeShfLCBudWxsLCBcIlxcdTAwQTBcIikpKSk7XHJcbiAgICB9XHJcblxyXG4gICAgY2xhc3MgVGFibGVDZWxsTW9yZUxpbmsgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcclxuICAgICAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgdGhpcy5jb21waWxlU2VncyA9IG1lbW9pemUoY29tcGlsZVNlZ3MpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZW5kZXIoKSB7XHJcbiAgICAgICAgICAgIGxldCB7IHByb3BzIH0gPSB0aGlzO1xyXG4gICAgICAgICAgICBsZXQgeyBhbGxTZWdzLCBpbnZpc2libGVTZWdzIH0gPSB0aGlzLmNvbXBpbGVTZWdzKHByb3BzLnNpbmdsZVBsYWNlbWVudHMpO1xyXG4gICAgICAgICAgICByZXR1cm4gKHkoTW9yZUxpbmtDb250YWluZXIsIHsgZWxDbGFzc2VzOiBbJ2ZjLWRheWdyaWQtbW9yZS1saW5rJ10sIGRhdGVQcm9maWxlOiBwcm9wcy5kYXRlUHJvZmlsZSwgdG9kYXlSYW5nZTogcHJvcHMudG9kYXlSYW5nZSwgYWxsRGF5RGF0ZTogcHJvcHMuYWxsRGF5RGF0ZSwgbW9yZUNudDogcHJvcHMubW9yZUNudCwgYWxsU2VnczogYWxsU2VncywgaGlkZGVuU2VnczogaW52aXNpYmxlU2VncywgYWxpZ25tZW50RWxSZWY6IHByb3BzLmFsaWdubWVudEVsUmVmLCBhbGlnbkdyaWRUb3A6IHByb3BzLmFsaWduR3JpZFRvcCwgZXh0cmFEYXRlU3BhbjogcHJvcHMuZXh0cmFEYXRlU3BhbiwgcG9wb3ZlckNvbnRlbnQ6ICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgaXNGb3JjZWRJbnZpc2libGUgPSAocHJvcHMuZXZlbnREcmFnID8gcHJvcHMuZXZlbnREcmFnLmFmZmVjdGVkSW5zdGFuY2VzIDogbnVsbCkgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgKHByb3BzLmV2ZW50UmVzaXplID8gcHJvcHMuZXZlbnRSZXNpemUuYWZmZWN0ZWRJbnN0YW5jZXMgOiBudWxsKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7fTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHkoXywgbnVsbCwgYWxsU2Vncy5tYXAoKHNlZykgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgaW5zdGFuY2VJZCA9IHNlZy5ldmVudFJhbmdlLmluc3RhbmNlLmluc3RhbmNlSWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoeShcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy1kYXlncmlkLWV2ZW50LWhhcm5lc3NcIiwga2V5OiBpbnN0YW5jZUlkLCBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpc2liaWxpdHk6IGlzRm9yY2VkSW52aXNpYmxlW2luc3RhbmNlSWRdID8gJ2hpZGRlbicgOiAnJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gfSwgaGFzTGlzdEl0ZW1EaXNwbGF5KHNlZykgPyAoeShUYWJsZUxpc3RJdGVtRXZlbnQsIE9iamVjdC5hc3NpZ24oeyBzZWc6IHNlZywgaXNEcmFnZ2luZzogZmFsc2UsIGlzU2VsZWN0ZWQ6IGluc3RhbmNlSWQgPT09IHByb3BzLmV2ZW50U2VsZWN0aW9uLCBkZWZhdWx0RGlzcGxheUV2ZW50RW5kOiBmYWxzZSB9LCBnZXRTZWdNZXRhKHNlZywgcHJvcHMudG9kYXlSYW5nZSkpKSkgOiAoeShUYWJsZUJsb2NrRXZlbnQsIE9iamVjdC5hc3NpZ24oeyBzZWc6IHNlZywgaXNEcmFnZ2luZzogZmFsc2UsIGlzUmVzaXppbmc6IGZhbHNlLCBpc0RhdGVTZWxlY3Rpbmc6IGZhbHNlLCBpc1NlbGVjdGVkOiBpbnN0YW5jZUlkID09PSBwcm9wcy5ldmVudFNlbGVjdGlvbiwgZGVmYXVsdERpc3BsYXlFdmVudEVuZDogZmFsc2UgfSwgZ2V0U2VnTWV0YShzZWcsIHByb3BzLnRvZGF5UmFuZ2UpKSkpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSkpKTtcclxuICAgICAgICAgICAgICAgIH0gfSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGNvbXBpbGVTZWdzKHNpbmdsZVBsYWNlbWVudHMpIHtcclxuICAgICAgICBsZXQgYWxsU2VncyA9IFtdO1xyXG4gICAgICAgIGxldCBpbnZpc2libGVTZWdzID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgcGxhY2VtZW50IG9mIHNpbmdsZVBsYWNlbWVudHMpIHtcclxuICAgICAgICAgICAgYWxsU2Vncy5wdXNoKHBsYWNlbWVudC5zZWcpO1xyXG4gICAgICAgICAgICBpZiAoIXBsYWNlbWVudC5pc1Zpc2libGUpIHtcclxuICAgICAgICAgICAgICAgIGludmlzaWJsZVNlZ3MucHVzaChwbGFjZW1lbnQuc2VnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4geyBhbGxTZWdzLCBpbnZpc2libGVTZWdzIH07XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgREVGQVVMVF9XRUVLX05VTV9GT1JNQVQkMSA9IGNyZWF0ZUZvcm1hdHRlcih7IHdlZWs6ICduYXJyb3cnIH0pO1xyXG4gICAgY2xhc3MgVGFibGVDZWxsIGV4dGVuZHMgRGF0ZUNvbXBvbmVudCB7XHJcbiAgICAgICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgIHRoaXMucm9vdEVsUmVmID0gZCgpO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0ge1xyXG4gICAgICAgICAgICAgICAgZGF5TnVtYmVySWQ6IGdldFVuaXF1ZURvbUlkKCksXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlUm9vdEVsID0gKGVsKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBzZXRSZWYodGhpcy5yb290RWxSZWYsIGVsKTtcclxuICAgICAgICAgICAgICAgIHNldFJlZih0aGlzLnByb3BzLmVsUmVmLCBlbCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlbmRlcigpIHtcclxuICAgICAgICAgICAgbGV0IHsgY29udGV4dCwgcHJvcHMsIHN0YXRlLCByb290RWxSZWYgfSA9IHRoaXM7XHJcbiAgICAgICAgICAgIGxldCB7IG9wdGlvbnMsIGRhdGVFbnYgfSA9IGNvbnRleHQ7XHJcbiAgICAgICAgICAgIGxldCB7IGRhdGUsIGRhdGVQcm9maWxlIH0gPSBwcm9wcztcclxuICAgICAgICAgICAgLy8gVE9ETzogbWVtb2l6ZSB0aGlzP1xyXG4gICAgICAgICAgICBjb25zdCBpc01vbnRoU3RhcnQgPSBwcm9wcy5zaG93RGF5TnVtYmVyICYmXHJcbiAgICAgICAgICAgICAgICBzaG91bGREaXNwbGF5TW9udGhTdGFydChkYXRlLCBkYXRlUHJvZmlsZS5jdXJyZW50UmFuZ2UsIGRhdGVFbnYpO1xyXG4gICAgICAgICAgICByZXR1cm4gKHkoRGF5Q2VsbENvbnRhaW5lciwgeyBlbFRhZzogXCJ0ZFwiLCBlbFJlZjogdGhpcy5oYW5kbGVSb290RWwsIGVsQ2xhc3NlczogW1xyXG4gICAgICAgICAgICAgICAgICAgICdmYy1kYXlncmlkLWRheScsXHJcbiAgICAgICAgICAgICAgICAgICAgLi4uKHByb3BzLmV4dHJhQ2xhc3NOYW1lcyB8fCBbXSksXHJcbiAgICAgICAgICAgICAgICBdLCBlbEF0dHJzOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcHJvcHMuZXh0cmFEYXRhQXR0cnMpLCAocHJvcHMuc2hvd0RheU51bWJlciA/IHsgJ2FyaWEtbGFiZWxsZWRieSc6IHN0YXRlLmRheU51bWJlcklkIH0gOiB7fSkpLCB7IHJvbGU6ICdncmlkY2VsbCcgfSksIGRlZmF1bHRHZW5lcmF0b3I6IHJlbmRlclRvcElubmVyLCBkYXRlOiBkYXRlLCBkYXRlUHJvZmlsZTogZGF0ZVByb2ZpbGUsIHRvZGF5UmFuZ2U6IHByb3BzLnRvZGF5UmFuZ2UsIHNob3dEYXlOdW1iZXI6IHByb3BzLnNob3dEYXlOdW1iZXIsIGlzTW9udGhTdGFydDogaXNNb250aFN0YXJ0LCBleHRyYVJlbmRlclByb3BzOiBwcm9wcy5leHRyYVJlbmRlclByb3BzIH0sIChJbm5lckNvbnRlbnQsIHJlbmRlclByb3BzKSA9PiAoeShcImRpdlwiLCB7IHJlZjogcHJvcHMuaW5uZXJFbFJlZiwgY2xhc3NOYW1lOiBcImZjLWRheWdyaWQtZGF5LWZyYW1lIGZjLXNjcm9sbGdyaWQtc3luYy1pbm5lclwiLCBzdHlsZTogeyBtaW5IZWlnaHQ6IHByb3BzLm1pbkhlaWdodCB9IH0sXHJcbiAgICAgICAgICAgICAgICBwcm9wcy5zaG93V2Vla051bWJlciAmJiAoeShXZWVrTnVtYmVyQ29udGFpbmVyLCB7IGVsVGFnOiBcImFcIiwgZWxDbGFzc2VzOiBbJ2ZjLWRheWdyaWQtd2Vlay1udW1iZXInXSwgZWxBdHRyczogYnVpbGROYXZMaW5rQXR0cnMoY29udGV4dCwgZGF0ZSwgJ3dlZWsnKSwgZGF0ZTogZGF0ZSwgZGVmYXVsdEZvcm1hdDogREVGQVVMVF9XRUVLX05VTV9GT1JNQVQkMSB9KSksXHJcbiAgICAgICAgICAgICAgICAhcmVuZGVyUHJvcHMuaXNEaXNhYmxlZCAmJlxyXG4gICAgICAgICAgICAgICAgICAgIChwcm9wcy5zaG93RGF5TnVtYmVyIHx8IGhhc0N1c3RvbURheUNlbGxDb250ZW50KG9wdGlvbnMpIHx8IHByb3BzLmZvcmNlRGF5VG9wKSA/ICh5KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLWRheWdyaWQtZGF5LXRvcFwiIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgeShJbm5lckNvbnRlbnQsIHsgZWxUYWc6IFwiYVwiLCBlbENsYXNzZXM6IFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdmYy1kYXlncmlkLWRheS1udW1iZXInLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNNb250aFN0YXJ0ICYmICdmYy1kYXlncmlkLW1vbnRoLXN0YXJ0JyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgXSwgZWxBdHRyczogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBidWlsZE5hdkxpbmtBdHRycyhjb250ZXh0LCBkYXRlKSksIHsgaWQ6IHN0YXRlLmRheU51bWJlcklkIH0pIH0pKSkgOiBwcm9wcy5zaG93RGF5TnVtYmVyID8gKFxyXG4gICAgICAgICAgICAgICAgLy8gZm9yIGNyZWF0aW5nIGNvcnJlY3QgYW1vdW50IG9mIHNwYWNlIChzZWUgaXNzdWUgIzcxNjIpXHJcbiAgICAgICAgICAgICAgICB5KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLWRheWdyaWQtZGF5LXRvcFwiLCBzdHlsZTogeyB2aXNpYmlsaXR5OiAnaGlkZGVuJyB9IH0sXHJcbiAgICAgICAgICAgICAgICAgICAgeShcImFcIiwgeyBjbGFzc05hbWU6IFwiZmMtZGF5Z3JpZC1kYXktbnVtYmVyXCIgfSwgXCJcXHUwMEEwXCIpKSkgOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgICAgICB5KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLWRheWdyaWQtZGF5LWV2ZW50c1wiLCByZWY6IHByb3BzLmZnQ29udGVudEVsUmVmIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgcHJvcHMuZmdDb250ZW50LFxyXG4gICAgICAgICAgICAgICAgICAgIHkoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtZGF5Z3JpZC1kYXktYm90dG9tXCIsIHN0eWxlOiB7IG1hcmdpblRvcDogcHJvcHMubW9yZU1hcmdpblRvcCB9IH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHkoVGFibGVDZWxsTW9yZUxpbmssIHsgYWxsRGF5RGF0ZTogZGF0ZSwgc2luZ2xlUGxhY2VtZW50czogcHJvcHMuc2luZ2xlUGxhY2VtZW50cywgbW9yZUNudDogcHJvcHMubW9yZUNudCwgYWxpZ25tZW50RWxSZWY6IHJvb3RFbFJlZiwgYWxpZ25HcmlkVG9wOiAhcHJvcHMuc2hvd0RheU51bWJlciwgZXh0cmFEYXRlU3BhbjogcHJvcHMuZXh0cmFEYXRlU3BhbiwgZGF0ZVByb2ZpbGU6IHByb3BzLmRhdGVQcm9maWxlLCBldmVudFNlbGVjdGlvbjogcHJvcHMuZXZlbnRTZWxlY3Rpb24sIGV2ZW50RHJhZzogcHJvcHMuZXZlbnREcmFnLCBldmVudFJlc2l6ZTogcHJvcHMuZXZlbnRSZXNpemUsIHRvZGF5UmFuZ2U6IHByb3BzLnRvZGF5UmFuZ2UgfSkpKSxcclxuICAgICAgICAgICAgICAgIHkoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtZGF5Z3JpZC1kYXktYmdcIiB9LCBwcm9wcy5iZ0NvbnRlbnQpKSkpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiByZW5kZXJUb3BJbm5lcihwcm9wcykge1xyXG4gICAgICAgIHJldHVybiBwcm9wcy5kYXlOdW1iZXJUZXh0IHx8IHkoXywgbnVsbCwgXCJcXHUwMEEwXCIpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gc2hvdWxkRGlzcGxheU1vbnRoU3RhcnQoZGF0ZSwgY3VycmVudFJhbmdlLCBkYXRlRW52KSB7XHJcbiAgICAgICAgY29uc3QgeyBzdGFydDogY3VycmVudFN0YXJ0LCBlbmQ6IGN1cnJlbnRFbmQgfSA9IGN1cnJlbnRSYW5nZTtcclxuICAgICAgICBjb25zdCBjdXJyZW50RW5kSW5jbCA9IGFkZE1zKGN1cnJlbnRFbmQsIC0xKTtcclxuICAgICAgICBjb25zdCBjdXJyZW50Rmlyc3RZZWFyID0gZGF0ZUVudi5nZXRZZWFyKGN1cnJlbnRTdGFydCk7XHJcbiAgICAgICAgY29uc3QgY3VycmVudEZpcnN0TW9udGggPSBkYXRlRW52LmdldE1vbnRoKGN1cnJlbnRTdGFydCk7XHJcbiAgICAgICAgY29uc3QgY3VycmVudExhc3RZZWFyID0gZGF0ZUVudi5nZXRZZWFyKGN1cnJlbnRFbmRJbmNsKTtcclxuICAgICAgICBjb25zdCBjdXJyZW50TGFzdE1vbnRoID0gZGF0ZUVudi5nZXRNb250aChjdXJyZW50RW5kSW5jbCk7XHJcbiAgICAgICAgLy8gc3BhbnMgbW9yZSB0aGFuIG9uZSBtb250aD9cclxuICAgICAgICByZXR1cm4gIShjdXJyZW50Rmlyc3RZZWFyID09PSBjdXJyZW50TGFzdFllYXIgJiYgY3VycmVudEZpcnN0TW9udGggPT09IGN1cnJlbnRMYXN0TW9udGgpICYmXHJcbiAgICAgICAgICAgIEJvb2xlYW4oXHJcbiAgICAgICAgICAgIC8vIGZpcnN0IGRhdGUgaW4gY3VycmVudCB2aWV3P1xyXG4gICAgICAgICAgICBkYXRlLnZhbHVlT2YoKSA9PT0gY3VycmVudFN0YXJ0LnZhbHVlT2YoKSB8fFxyXG4gICAgICAgICAgICAgICAgLy8gYSBtb250aC1zdGFydCB0aGF0J3Mgd2l0aGluIHRoZSBjdXJyZW50IHJhbmdlP1xyXG4gICAgICAgICAgICAgICAgKGRhdGVFbnYuZ2V0RGF5KGRhdGUpID09PSAxICYmIGRhdGUudmFsdWVPZigpIDwgY3VycmVudEVuZC52YWx1ZU9mKCkpKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjb21wdXRlRmdTZWdQbGFjZW1lbnQoc2VncywgLy8gYXNzdW1lZCBhbHJlYWR5IHNvcnRlZFxyXG4gICAgZGF5TWF4RXZlbnRzLCBkYXlNYXhFdmVudFJvd3MsIHN0cmljdE9yZGVyLCBldmVudEluc3RhbmNlSGVpZ2h0cywgbWF4Q29udGVudEhlaWdodCwgY2VsbHMpIHtcclxuICAgICAgICBsZXQgaGllcmFyY2h5ID0gbmV3IERheUdyaWRTZWdIaWVyYXJjaHkoKTtcclxuICAgICAgICBoaWVyYXJjaHkuYWxsb3dSZXNsaWNpbmcgPSB0cnVlO1xyXG4gICAgICAgIGhpZXJhcmNoeS5zdHJpY3RPcmRlciA9IHN0cmljdE9yZGVyO1xyXG4gICAgICAgIGlmIChkYXlNYXhFdmVudHMgPT09IHRydWUgfHwgZGF5TWF4RXZlbnRSb3dzID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgIGhpZXJhcmNoeS5tYXhDb29yZCA9IG1heENvbnRlbnRIZWlnaHQ7XHJcbiAgICAgICAgICAgIGhpZXJhcmNoeS5oaWRkZW5Db25zdW1lcyA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBkYXlNYXhFdmVudHMgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgIGhpZXJhcmNoeS5tYXhTdGFja0NudCA9IGRheU1heEV2ZW50cztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGRheU1heEV2ZW50Um93cyA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgaGllcmFyY2h5Lm1heFN0YWNrQ250ID0gZGF5TWF4RXZlbnRSb3dzO1xyXG4gICAgICAgICAgICBoaWVyYXJjaHkuaGlkZGVuQ29uc3VtZXMgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBjcmVhdGUgc2VnSW5wdXRzIG9ubHkgZm9yIHNlZ3Mgd2l0aCBrbm93biBoZWlnaHRzXHJcbiAgICAgICAgbGV0IHNlZ0lucHV0cyA9IFtdO1xyXG4gICAgICAgIGxldCB1bmtub3duSGVpZ2h0U2VncyA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2Vncy5sZW5ndGg7IGkgKz0gMSkge1xyXG4gICAgICAgICAgICBsZXQgc2VnID0gc2Vnc1tpXTtcclxuICAgICAgICAgICAgbGV0IHsgaW5zdGFuY2VJZCB9ID0gc2VnLmV2ZW50UmFuZ2UuaW5zdGFuY2U7XHJcbiAgICAgICAgICAgIGxldCBldmVudEhlaWdodCA9IGV2ZW50SW5zdGFuY2VIZWlnaHRzW2luc3RhbmNlSWRdO1xyXG4gICAgICAgICAgICBpZiAoZXZlbnRIZWlnaHQgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgc2VnSW5wdXRzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiBpLFxyXG4gICAgICAgICAgICAgICAgICAgIHRoaWNrbmVzczogZXZlbnRIZWlnaHQsXHJcbiAgICAgICAgICAgICAgICAgICAgc3Bhbjoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogc2VnLmZpcnN0Q29sLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IHNlZy5sYXN0Q29sICsgMSxcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB1bmtub3duSGVpZ2h0U2Vncy5wdXNoKHNlZyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGhpZGRlbkVudHJpZXMgPSBoaWVyYXJjaHkuYWRkU2VncyhzZWdJbnB1dHMpO1xyXG4gICAgICAgIGxldCBzZWdSZWN0cyA9IGhpZXJhcmNoeS50b1JlY3RzKCk7XHJcbiAgICAgICAgbGV0IHsgc2luZ2xlQ29sUGxhY2VtZW50cywgbXVsdGlDb2xQbGFjZW1lbnRzLCBsZWZ0b3Zlck1hcmdpbnMgfSA9IHBsYWNlUmVjdHMoc2VnUmVjdHMsIHNlZ3MsIGNlbGxzKTtcclxuICAgICAgICBsZXQgbW9yZUNudHMgPSBbXTtcclxuICAgICAgICBsZXQgbW9yZU1hcmdpblRvcHMgPSBbXTtcclxuICAgICAgICAvLyBhZGQgc2VncyB3aXRoIHVua25vd24gaGVpZ2h0c1xyXG4gICAgICAgIGZvciAobGV0IHNlZyBvZiB1bmtub3duSGVpZ2h0U2Vncykge1xyXG4gICAgICAgICAgICBtdWx0aUNvbFBsYWNlbWVudHNbc2VnLmZpcnN0Q29sXS5wdXNoKHtcclxuICAgICAgICAgICAgICAgIHNlZyxcclxuICAgICAgICAgICAgICAgIGlzVmlzaWJsZTogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBpc0Fic29sdXRlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgYWJzb2x1dGVUb3A6IDAsXHJcbiAgICAgICAgICAgICAgICBtYXJnaW5Ub3A6IDAsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBjb2wgPSBzZWcuZmlyc3RDb2w7IGNvbCA8PSBzZWcubGFzdENvbDsgY29sICs9IDEpIHtcclxuICAgICAgICAgICAgICAgIHNpbmdsZUNvbFBsYWNlbWVudHNbY29sXS5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICBzZWc6IHJlc2xpY2VTZWcoc2VnLCBjb2wsIGNvbCArIDEsIGNlbGxzKSxcclxuICAgICAgICAgICAgICAgICAgICBpc1Zpc2libGU6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgIGlzQWJzb2x1dGU6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgIGFic29sdXRlVG9wOiAwLFxyXG4gICAgICAgICAgICAgICAgICAgIG1hcmdpblRvcDogMCxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGFkZCB0aGUgaGlkZGVuIGVudHJpZXNcclxuICAgICAgICBmb3IgKGxldCBjb2wgPSAwOyBjb2wgPCBjZWxscy5sZW5ndGg7IGNvbCArPSAxKSB7XHJcbiAgICAgICAgICAgIG1vcmVDbnRzLnB1c2goMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAobGV0IGhpZGRlbkVudHJ5IG9mIGhpZGRlbkVudHJpZXMpIHtcclxuICAgICAgICAgICAgbGV0IHNlZyA9IHNlZ3NbaGlkZGVuRW50cnkuaW5kZXhdO1xyXG4gICAgICAgICAgICBsZXQgaGlkZGVuU3BhbiA9IGhpZGRlbkVudHJ5LnNwYW47XHJcbiAgICAgICAgICAgIG11bHRpQ29sUGxhY2VtZW50c1toaWRkZW5TcGFuLnN0YXJ0XS5wdXNoKHtcclxuICAgICAgICAgICAgICAgIHNlZzogcmVzbGljZVNlZyhzZWcsIGhpZGRlblNwYW4uc3RhcnQsIGhpZGRlblNwYW4uZW5kLCBjZWxscyksXHJcbiAgICAgICAgICAgICAgICBpc1Zpc2libGU6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgaXNBYnNvbHV0ZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGFic29sdXRlVG9wOiAwLFxyXG4gICAgICAgICAgICAgICAgbWFyZ2luVG9wOiAwLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgZm9yIChsZXQgY29sID0gaGlkZGVuU3Bhbi5zdGFydDsgY29sIDwgaGlkZGVuU3Bhbi5lbmQ7IGNvbCArPSAxKSB7XHJcbiAgICAgICAgICAgICAgICBtb3JlQ250c1tjb2xdICs9IDE7XHJcbiAgICAgICAgICAgICAgICBzaW5nbGVDb2xQbGFjZW1lbnRzW2NvbF0ucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VnOiByZXNsaWNlU2VnKHNlZywgY29sLCBjb2wgKyAxLCBjZWxscyksXHJcbiAgICAgICAgICAgICAgICAgICAgaXNWaXNpYmxlOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICBpc0Fic29sdXRlOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICBhYnNvbHV0ZVRvcDogMCxcclxuICAgICAgICAgICAgICAgICAgICBtYXJnaW5Ub3A6IDAsXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBkZWFsIHdpdGggbGVmdG92ZXIgbWFyZ2luc1xyXG4gICAgICAgIGZvciAobGV0IGNvbCA9IDA7IGNvbCA8IGNlbGxzLmxlbmd0aDsgY29sICs9IDEpIHtcclxuICAgICAgICAgICAgbW9yZU1hcmdpblRvcHMucHVzaChsZWZ0b3Zlck1hcmdpbnNbY29sXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7IHNpbmdsZUNvbFBsYWNlbWVudHMsIG11bHRpQ29sUGxhY2VtZW50cywgbW9yZUNudHMsIG1vcmVNYXJnaW5Ub3BzIH07XHJcbiAgICB9XHJcbiAgICAvLyByZWN0cyBvcmRlcmVkIGJ5IHRvcCBjb29yZCwgdGhlbiBsZWZ0XHJcbiAgICBmdW5jdGlvbiBwbGFjZVJlY3RzKGFsbFJlY3RzLCBzZWdzLCBjZWxscykge1xyXG4gICAgICAgIGxldCByZWN0c0J5RWFjaENvbCA9IGdyb3VwUmVjdHNCeUVhY2hDb2woYWxsUmVjdHMsIGNlbGxzLmxlbmd0aCk7XHJcbiAgICAgICAgbGV0IHNpbmdsZUNvbFBsYWNlbWVudHMgPSBbXTtcclxuICAgICAgICBsZXQgbXVsdGlDb2xQbGFjZW1lbnRzID0gW107XHJcbiAgICAgICAgbGV0IGxlZnRvdmVyTWFyZ2lucyA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IGNvbCA9IDA7IGNvbCA8IGNlbGxzLmxlbmd0aDsgY29sICs9IDEpIHtcclxuICAgICAgICAgICAgbGV0IHJlY3RzID0gcmVjdHNCeUVhY2hDb2xbY29sXTtcclxuICAgICAgICAgICAgLy8gY29tcHV0ZSBhbGwgc3RhdGljIHNlZ3MgaW4gc2luZ2xlUGxhY2VtZW50c1xyXG4gICAgICAgICAgICBsZXQgc2luZ2xlUGxhY2VtZW50cyA9IFtdO1xyXG4gICAgICAgICAgICBsZXQgY3VycmVudEhlaWdodCA9IDA7XHJcbiAgICAgICAgICAgIGxldCBjdXJyZW50TWFyZ2luVG9wID0gMDtcclxuICAgICAgICAgICAgZm9yIChsZXQgcmVjdCBvZiByZWN0cykge1xyXG4gICAgICAgICAgICAgICAgbGV0IHNlZyA9IHNlZ3NbcmVjdC5pbmRleF07XHJcbiAgICAgICAgICAgICAgICBzaW5nbGVQbGFjZW1lbnRzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgIHNlZzogcmVzbGljZVNlZyhzZWcsIGNvbCwgY29sICsgMSwgY2VsbHMpLFxyXG4gICAgICAgICAgICAgICAgICAgIGlzVmlzaWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICBpc0Fic29sdXRlOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICBhYnNvbHV0ZVRvcDogcmVjdC5sZXZlbENvb3JkLFxyXG4gICAgICAgICAgICAgICAgICAgIG1hcmdpblRvcDogcmVjdC5sZXZlbENvb3JkIC0gY3VycmVudEhlaWdodCxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgY3VycmVudEhlaWdodCA9IHJlY3QubGV2ZWxDb29yZCArIHJlY3QudGhpY2tuZXNzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGNvbXB1dGUgbWl4ZWQgc3RhdGljL2Fic29sdXRlIHNlZ3MgaW4gbXVsdGlQbGFjZW1lbnRzXHJcbiAgICAgICAgICAgIGxldCBtdWx0aVBsYWNlbWVudHMgPSBbXTtcclxuICAgICAgICAgICAgY3VycmVudEhlaWdodCA9IDA7XHJcbiAgICAgICAgICAgIGN1cnJlbnRNYXJnaW5Ub3AgPSAwO1xyXG4gICAgICAgICAgICBmb3IgKGxldCByZWN0IG9mIHJlY3RzKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgc2VnID0gc2Vnc1tyZWN0LmluZGV4XTtcclxuICAgICAgICAgICAgICAgIGxldCBpc0Fic29sdXRlID0gcmVjdC5zcGFuLmVuZCAtIHJlY3Quc3Bhbi5zdGFydCA+IDE7IC8vIG11bHRpLWNvbHVtbj9cclxuICAgICAgICAgICAgICAgIGxldCBpc0ZpcnN0Q29sID0gcmVjdC5zcGFuLnN0YXJ0ID09PSBjb2w7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50TWFyZ2luVG9wICs9IHJlY3QubGV2ZWxDb29yZCAtIGN1cnJlbnRIZWlnaHQ7IC8vIGFtb3VudCBvZiBzcGFjZSBzaW5jZSBib3R0b20gb2YgcHJldmlvdXMgc2VnXHJcbiAgICAgICAgICAgICAgICBjdXJyZW50SGVpZ2h0ID0gcmVjdC5sZXZlbENvb3JkICsgcmVjdC50aGlja25lc3M7IC8vIGhlaWdodCB3aWxsIG5vdyBiZSBib3R0b20gb2YgY3VycmVudCBzZWdcclxuICAgICAgICAgICAgICAgIGlmIChpc0Fic29sdXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudE1hcmdpblRvcCArPSByZWN0LnRoaWNrbmVzcztcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNGaXJzdENvbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtdWx0aVBsYWNlbWVudHMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWc6IHJlc2xpY2VTZWcoc2VnLCByZWN0LnNwYW4uc3RhcnQsIHJlY3Quc3Bhbi5lbmQsIGNlbGxzKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzVmlzaWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzQWJzb2x1dGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhYnNvbHV0ZVRvcDogcmVjdC5sZXZlbENvb3JkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFyZ2luVG9wOiAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc0ZpcnN0Q29sKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbXVsdGlQbGFjZW1lbnRzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWc6IHJlc2xpY2VTZWcoc2VnLCByZWN0LnNwYW4uc3RhcnQsIHJlY3Quc3Bhbi5lbmQsIGNlbGxzKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXNWaXNpYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0Fic29sdXRlOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWJzb2x1dGVUb3A6IHJlY3QubGV2ZWxDb29yZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWFyZ2luVG9wOiBjdXJyZW50TWFyZ2luVG9wLCAvLyBjbGFpbSB0aGUgbWFyZ2luXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudE1hcmdpblRvcCA9IDA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc2luZ2xlQ29sUGxhY2VtZW50cy5wdXNoKHNpbmdsZVBsYWNlbWVudHMpO1xyXG4gICAgICAgICAgICBtdWx0aUNvbFBsYWNlbWVudHMucHVzaChtdWx0aVBsYWNlbWVudHMpO1xyXG4gICAgICAgICAgICBsZWZ0b3Zlck1hcmdpbnMucHVzaChjdXJyZW50TWFyZ2luVG9wKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHsgc2luZ2xlQ29sUGxhY2VtZW50cywgbXVsdGlDb2xQbGFjZW1lbnRzLCBsZWZ0b3Zlck1hcmdpbnMgfTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGdyb3VwUmVjdHNCeUVhY2hDb2wocmVjdHMsIGNvbENudCkge1xyXG4gICAgICAgIGxldCByZWN0c0J5RWFjaENvbCA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IGNvbCA9IDA7IGNvbCA8IGNvbENudDsgY29sICs9IDEpIHtcclxuICAgICAgICAgICAgcmVjdHNCeUVhY2hDb2wucHVzaChbXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAobGV0IHJlY3Qgb2YgcmVjdHMpIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgY29sID0gcmVjdC5zcGFuLnN0YXJ0OyBjb2wgPCByZWN0LnNwYW4uZW5kOyBjb2wgKz0gMSkge1xyXG4gICAgICAgICAgICAgICAgcmVjdHNCeUVhY2hDb2xbY29sXS5wdXNoKHJlY3QpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZWN0c0J5RWFjaENvbDtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHJlc2xpY2VTZWcoc2VnLCBzcGFuU3RhcnQsIHNwYW5FbmQsIGNlbGxzKSB7XHJcbiAgICAgICAgaWYgKHNlZy5maXJzdENvbCA9PT0gc3BhblN0YXJ0ICYmIHNlZy5sYXN0Q29sID09PSBzcGFuRW5kIC0gMSkge1xyXG4gICAgICAgICAgICByZXR1cm4gc2VnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgZXZlbnRSYW5nZSA9IHNlZy5ldmVudFJhbmdlO1xyXG4gICAgICAgIGxldCBvcmlnUmFuZ2UgPSBldmVudFJhbmdlLnJhbmdlO1xyXG4gICAgICAgIGxldCBzbGljZWRSYW5nZSA9IGludGVyc2VjdFJhbmdlcyhvcmlnUmFuZ2UsIHtcclxuICAgICAgICAgICAgc3RhcnQ6IGNlbGxzW3NwYW5TdGFydF0uZGF0ZSxcclxuICAgICAgICAgICAgZW5kOiBhZGREYXlzKGNlbGxzW3NwYW5FbmQgLSAxXS5kYXRlLCAxKSxcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzZWcpLCB7IGZpcnN0Q29sOiBzcGFuU3RhcnQsIGxhc3RDb2w6IHNwYW5FbmQgLSAxLCBldmVudFJhbmdlOiB7XHJcbiAgICAgICAgICAgICAgICBkZWY6IGV2ZW50UmFuZ2UuZGVmLFxyXG4gICAgICAgICAgICAgICAgdWk6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZXZlbnRSYW5nZS51aSksIHsgZHVyYXRpb25FZGl0YWJsZTogZmFsc2UgfSksXHJcbiAgICAgICAgICAgICAgICBpbnN0YW5jZTogZXZlbnRSYW5nZS5pbnN0YW5jZSxcclxuICAgICAgICAgICAgICAgIHJhbmdlOiBzbGljZWRSYW5nZSxcclxuICAgICAgICAgICAgfSwgaXNTdGFydDogc2VnLmlzU3RhcnQgJiYgc2xpY2VkUmFuZ2Uuc3RhcnQudmFsdWVPZigpID09PSBvcmlnUmFuZ2Uuc3RhcnQudmFsdWVPZigpLCBpc0VuZDogc2VnLmlzRW5kICYmIHNsaWNlZFJhbmdlLmVuZC52YWx1ZU9mKCkgPT09IG9yaWdSYW5nZS5lbmQudmFsdWVPZigpIH0pO1xyXG4gICAgfVxyXG4gICAgY2xhc3MgRGF5R3JpZFNlZ0hpZXJhcmNoeSBleHRlbmRzIFNlZ0hpZXJhcmNoeSB7XHJcbiAgICAgICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgIC8vIGNvbmZpZ1xyXG4gICAgICAgICAgICB0aGlzLmhpZGRlbkNvbnN1bWVzID0gZmFsc2U7XHJcbiAgICAgICAgICAgIC8vIGFsbG93cyB1cyB0byBrZWVwIGhpZGRlbiBlbnRyaWVzIGluIHRoZSBoaWVyYXJjaHkgc28gdGhleSB0YWtlIHVwIHNwYWNlXHJcbiAgICAgICAgICAgIHRoaXMuZm9yY2VIaWRkZW4gPSB7fTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYWRkU2VncyhzZWdJbnB1dHMpIHtcclxuICAgICAgICAgICAgY29uc3QgaGlkZGVuU2VncyA9IHN1cGVyLmFkZFNlZ3Moc2VnSW5wdXRzKTtcclxuICAgICAgICAgICAgY29uc3QgeyBlbnRyaWVzQnlMZXZlbCB9ID0gdGhpcztcclxuICAgICAgICAgICAgY29uc3QgZXhjbHVkZUhpZGRlbiA9IChlbnRyeSkgPT4gIXRoaXMuZm9yY2VIaWRkZW5bYnVpbGRFbnRyeUtleShlbnRyeSldO1xyXG4gICAgICAgICAgICAvLyByZW1vdmUgdGhlIGZvcmNlZC1oaWRkZW4gc2Vnc1xyXG4gICAgICAgICAgICBmb3IgKGxldCBsZXZlbCA9IDA7IGxldmVsIDwgZW50cmllc0J5TGV2ZWwubGVuZ3RoOyBsZXZlbCArPSAxKSB7XHJcbiAgICAgICAgICAgICAgICBlbnRyaWVzQnlMZXZlbFtsZXZlbF0gPSBlbnRyaWVzQnlMZXZlbFtsZXZlbF0uZmlsdGVyKGV4Y2x1ZGVIaWRkZW4pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBoaWRkZW5TZWdzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBoYW5kbGVJbnZhbGlkSW5zZXJ0aW9uKGluc2VydGlvbiwgZW50cnksIGhpZGRlbkVudHJpZXMpIHtcclxuICAgICAgICAgICAgY29uc3QgeyBlbnRyaWVzQnlMZXZlbCwgZm9yY2VIaWRkZW4gfSA9IHRoaXM7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgdG91Y2hpbmdFbnRyeSwgdG91Y2hpbmdMZXZlbCwgdG91Y2hpbmdMYXRlcmFsIH0gPSBpbnNlcnRpb247XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmhpZGRlbkNvbnN1bWVzICYmIHRvdWNoaW5nRW50cnkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRvdWNoaW5nRW50cnlJZCA9IGJ1aWxkRW50cnlLZXkodG91Y2hpbmdFbnRyeSk7XHJcbiAgICAgICAgICAgICAgICAvLyBpZiBub3QgYWxyZWFkeSBoaWRkZW5cclxuICAgICAgICAgICAgICAgIGlmICghZm9yY2VIaWRkZW5bdG91Y2hpbmdFbnRyeUlkXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmFsbG93UmVzbGljaW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBsYWNlaG9sZGVyRW50cnkgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRvdWNoaW5nRW50cnkpLCB7IHNwYW46IGludGVyc2VjdFNwYW5zKHRvdWNoaW5nRW50cnkuc3BhbiwgZW50cnkuc3BhbikgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBsYWNlaG9sZGVyRW50cnlJZCA9IGJ1aWxkRW50cnlLZXkocGxhY2Vob2xkZXJFbnRyeSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcmNlSGlkZGVuW3BsYWNlaG9sZGVyRW50cnlJZF0gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbnRyaWVzQnlMZXZlbFt0b3VjaGluZ0xldmVsXVt0b3VjaGluZ0xhdGVyYWxdID0gcGxhY2Vob2xkZXJFbnRyeTsgLy8gcmVwbGFjZSB0b3VjaGluZ0VudHJ5IHdpdGggb3VyIHBsYWNlaG9sZGVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3BsaXRFbnRyeSh0b3VjaGluZ0VudHJ5LCBlbnRyeSwgaGlkZGVuRW50cmllcyk7IC8vIHNwbGl0IHVwIHRoZSB0b3VjaGluZ0VudHJ5LCByZWluc2VydCBpdFxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yY2VIaWRkZW5bdG91Y2hpbmdFbnRyeUlkXSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhpZGRlbkVudHJpZXMucHVzaCh0b3VjaGluZ0VudHJ5KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHN1cGVyLmhhbmRsZUludmFsaWRJbnNlcnRpb24oaW5zZXJ0aW9uLCBlbnRyeSwgaGlkZGVuRW50cmllcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNsYXNzIFRhYmxlUm93IGV4dGVuZHMgRGF0ZUNvbXBvbmVudCB7XHJcbiAgICAgICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgIHRoaXMuY2VsbEVsUmVmcyA9IG5ldyBSZWZNYXAoKTsgLy8gdGhlIDx0ZD5cclxuICAgICAgICAgICAgdGhpcy5mcmFtZUVsUmVmcyA9IG5ldyBSZWZNYXAoKTsgLy8gdGhlIGZjLWRheWdyaWQtZGF5LWZyYW1lXHJcbiAgICAgICAgICAgIHRoaXMuZmdFbFJlZnMgPSBuZXcgUmVmTWFwKCk7IC8vIHRoZSBmYy1kYXlncmlkLWRheS1ldmVudHNcclxuICAgICAgICAgICAgdGhpcy5zZWdIYXJuZXNzUmVmcyA9IG5ldyBSZWZNYXAoKTsgLy8gaW5kZXhlZCBieSBcImluc3RhbmNlSWQ6Zmlyc3RDb2xcIlxyXG4gICAgICAgICAgICB0aGlzLnJvb3RFbFJlZiA9IGQoKTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IHtcclxuICAgICAgICAgICAgICAgIGZyYW1lUG9zaXRpb25zOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgbWF4Q29udGVudEhlaWdodDogbnVsbCxcclxuICAgICAgICAgICAgICAgIGV2ZW50SW5zdGFuY2VIZWlnaHRzOiB7fSxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdGhpcy5oYW5kbGVSZXNpemUgPSAoaXNGb3JjZWQpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChpc0ZvcmNlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlU2l6aW5nKHRydWUpOyAvLyBpc0V4dGVybmFsPXRydWVcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVuZGVyKCkge1xyXG4gICAgICAgICAgICBsZXQgeyBwcm9wcywgc3RhdGUsIGNvbnRleHQgfSA9IHRoaXM7XHJcbiAgICAgICAgICAgIGxldCB7IG9wdGlvbnMgfSA9IGNvbnRleHQ7XHJcbiAgICAgICAgICAgIGxldCBjb2xDbnQgPSBwcm9wcy5jZWxscy5sZW5ndGg7XHJcbiAgICAgICAgICAgIGxldCBidXNpbmVzc0hvdXJzQnlDb2wgPSBzcGxpdFNlZ3NCeUZpcnN0Q29sKHByb3BzLmJ1c2luZXNzSG91clNlZ3MsIGNvbENudCk7XHJcbiAgICAgICAgICAgIGxldCBiZ0V2ZW50U2Vnc0J5Q29sID0gc3BsaXRTZWdzQnlGaXJzdENvbChwcm9wcy5iZ0V2ZW50U2VncywgY29sQ250KTtcclxuICAgICAgICAgICAgbGV0IGhpZ2hsaWdodFNlZ3NCeUNvbCA9IHNwbGl0U2Vnc0J5Rmlyc3RDb2wodGhpcy5nZXRIaWdobGlnaHRTZWdzKCksIGNvbENudCk7XHJcbiAgICAgICAgICAgIGxldCBtaXJyb3JTZWdzQnlDb2wgPSBzcGxpdFNlZ3NCeUZpcnN0Q29sKHRoaXMuZ2V0TWlycm9yU2VncygpLCBjb2xDbnQpO1xyXG4gICAgICAgICAgICBsZXQgeyBzaW5nbGVDb2xQbGFjZW1lbnRzLCBtdWx0aUNvbFBsYWNlbWVudHMsIG1vcmVDbnRzLCBtb3JlTWFyZ2luVG9wcyB9ID0gY29tcHV0ZUZnU2VnUGxhY2VtZW50KHNvcnRFdmVudFNlZ3MocHJvcHMuZmdFdmVudFNlZ3MsIG9wdGlvbnMuZXZlbnRPcmRlciksIHByb3BzLmRheU1heEV2ZW50cywgcHJvcHMuZGF5TWF4RXZlbnRSb3dzLCBvcHRpb25zLmV2ZW50T3JkZXJTdHJpY3QsIHN0YXRlLmV2ZW50SW5zdGFuY2VIZWlnaHRzLCBzdGF0ZS5tYXhDb250ZW50SGVpZ2h0LCBwcm9wcy5jZWxscyk7XHJcbiAgICAgICAgICAgIGxldCBpc0ZvcmNlZEludmlzaWJsZSA9IC8vIFRPRE86IG1lc3N5IHdheSB0byBjb21wdXRlIHRoaXNcclxuICAgICAgICAgICAgIChwcm9wcy5ldmVudERyYWcgJiYgcHJvcHMuZXZlbnREcmFnLmFmZmVjdGVkSW5zdGFuY2VzKSB8fFxyXG4gICAgICAgICAgICAgICAgKHByb3BzLmV2ZW50UmVzaXplICYmIHByb3BzLmV2ZW50UmVzaXplLmFmZmVjdGVkSW5zdGFuY2VzKSB8fFxyXG4gICAgICAgICAgICAgICAge307XHJcbiAgICAgICAgICAgIHJldHVybiAoeShcInRyXCIsIHsgcmVmOiB0aGlzLnJvb3RFbFJlZiwgcm9sZTogXCJyb3dcIiB9LFxyXG4gICAgICAgICAgICAgICAgcHJvcHMucmVuZGVySW50cm8gJiYgcHJvcHMucmVuZGVySW50cm8oKSxcclxuICAgICAgICAgICAgICAgIHByb3BzLmNlbGxzLm1hcCgoY2VsbCwgY29sKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5vcm1hbEZnTm9kZXMgPSB0aGlzLnJlbmRlckZnU2Vncyhjb2wsIHByb3BzLmZvclByaW50ID8gc2luZ2xlQ29sUGxhY2VtZW50c1tjb2xdIDogbXVsdGlDb2xQbGFjZW1lbnRzW2NvbF0sIHByb3BzLnRvZGF5UmFuZ2UsIGlzRm9yY2VkSW52aXNpYmxlKTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgbWlycm9yRmdOb2RlcyA9IHRoaXMucmVuZGVyRmdTZWdzKGNvbCwgYnVpbGRNaXJyb3JQbGFjZW1lbnRzKG1pcnJvclNlZ3NCeUNvbFtjb2xdLCBtdWx0aUNvbFBsYWNlbWVudHMpLCBwcm9wcy50b2RheVJhbmdlLCB7fSwgQm9vbGVhbihwcm9wcy5ldmVudERyYWcpLCBCb29sZWFuKHByb3BzLmV2ZW50UmVzaXplKSwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoeShUYWJsZUNlbGwsIHsga2V5OiBjZWxsLmtleSwgZWxSZWY6IHRoaXMuY2VsbEVsUmVmcy5jcmVhdGVSZWYoY2VsbC5rZXkpLCBpbm5lckVsUmVmOiB0aGlzLmZyYW1lRWxSZWZzLmNyZWF0ZVJlZihjZWxsLmtleSkgLyogRkYgPHRkPiBwcm9ibGVtLCBidXQgb2theSB0byB1c2UgZm9yIGxlZnQvcmlnaHQuIFRPRE86IHJlbmFtZSBwcm9wICovLCBkYXRlUHJvZmlsZTogcHJvcHMuZGF0ZVByb2ZpbGUsIGRhdGU6IGNlbGwuZGF0ZSwgc2hvd0RheU51bWJlcjogcHJvcHMuc2hvd0RheU51bWJlcnMsIHNob3dXZWVrTnVtYmVyOiBwcm9wcy5zaG93V2Vla051bWJlcnMgJiYgY29sID09PSAwLCBmb3JjZURheVRvcDogcHJvcHMuc2hvd1dlZWtOdW1iZXJzIC8qIGV2ZW4gZGlzcGxheWluZyB3ZWVrbnVtIGZvciByb3csIG5vdCBuZWNlc3NhcmlseSBkYXkgKi8sIHRvZGF5UmFuZ2U6IHByb3BzLnRvZGF5UmFuZ2UsIGV2ZW50U2VsZWN0aW9uOiBwcm9wcy5ldmVudFNlbGVjdGlvbiwgZXZlbnREcmFnOiBwcm9wcy5ldmVudERyYWcsIGV2ZW50UmVzaXplOiBwcm9wcy5ldmVudFJlc2l6ZSwgZXh0cmFSZW5kZXJQcm9wczogY2VsbC5leHRyYVJlbmRlclByb3BzLCBleHRyYURhdGFBdHRyczogY2VsbC5leHRyYURhdGFBdHRycywgZXh0cmFDbGFzc05hbWVzOiBjZWxsLmV4dHJhQ2xhc3NOYW1lcywgZXh0cmFEYXRlU3BhbjogY2VsbC5leHRyYURhdGVTcGFuLCBtb3JlQ250OiBtb3JlQ250c1tjb2xdLCBtb3JlTWFyZ2luVG9wOiBtb3JlTWFyZ2luVG9wc1tjb2xdLCBzaW5nbGVQbGFjZW1lbnRzOiBzaW5nbGVDb2xQbGFjZW1lbnRzW2NvbF0sIGZnQ29udGVudEVsUmVmOiB0aGlzLmZnRWxSZWZzLmNyZWF0ZVJlZihjZWxsLmtleSksIGZnQ29udGVudDogKCAvLyBGcmFnbWVudCBzY29wZXMgdGhlIGtleXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgeShfLCBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeShfLCBudWxsLCBub3JtYWxGZ05vZGVzKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkoXywgbnVsbCwgbWlycm9yRmdOb2RlcykpKSwgYmdDb250ZW50OiAoIC8vIEZyYWdtZW50IHNjb3BlcyB0aGUga2V5c1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB5KF8sIG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlckZpbGxTZWdzKGhpZ2hsaWdodFNlZ3NCeUNvbFtjb2xdLCAnaGlnaGxpZ2h0JyksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlckZpbGxTZWdzKGJ1c2luZXNzSG91cnNCeUNvbFtjb2xdLCAnbm9uLWJ1c2luZXNzJyksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlckZpbGxTZWdzKGJnRXZlbnRTZWdzQnlDb2xbY29sXSwgJ2JnLWV2ZW50JykpKSwgbWluSGVpZ2h0OiBwcm9wcy5jZWxsTWluSGVpZ2h0IH0pKTtcclxuICAgICAgICAgICAgICAgIH0pKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVNpemluZyh0cnVlKTtcclxuICAgICAgICAgICAgdGhpcy5jb250ZXh0LmFkZFJlc2l6ZUhhbmRsZXIodGhpcy5oYW5kbGVSZXNpemUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzLCBwcmV2U3RhdGUpIHtcclxuICAgICAgICAgICAgbGV0IGN1cnJlbnRQcm9wcyA9IHRoaXMucHJvcHM7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlU2l6aW5nKCFpc1Byb3BzRXF1YWwocHJldlByb3BzLCBjdXJyZW50UHJvcHMpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5yZW1vdmVSZXNpemVIYW5kbGVyKHRoaXMuaGFuZGxlUmVzaXplKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZ2V0SGlnaGxpZ2h0U2VncygpIHtcclxuICAgICAgICAgICAgbGV0IHsgcHJvcHMgfSA9IHRoaXM7XHJcbiAgICAgICAgICAgIGlmIChwcm9wcy5ldmVudERyYWcgJiYgcHJvcHMuZXZlbnREcmFnLnNlZ3MubGVuZ3RoKSB7IC8vIG1lc3N5IGNoZWNrXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvcHMuZXZlbnREcmFnLnNlZ3M7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHByb3BzLmV2ZW50UmVzaXplICYmIHByb3BzLmV2ZW50UmVzaXplLnNlZ3MubGVuZ3RoKSB7IC8vIG1lc3N5IGNoZWNrXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvcHMuZXZlbnRSZXNpemUuc2VncztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcHJvcHMuZGF0ZVNlbGVjdGlvblNlZ3M7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGdldE1pcnJvclNlZ3MoKSB7XHJcbiAgICAgICAgICAgIGxldCB7IHByb3BzIH0gPSB0aGlzO1xyXG4gICAgICAgICAgICBpZiAocHJvcHMuZXZlbnRSZXNpemUgJiYgcHJvcHMuZXZlbnRSZXNpemUuc2Vncy5sZW5ndGgpIHsgLy8gbWVzc3kgY2hlY2tcclxuICAgICAgICAgICAgICAgIHJldHVybiBwcm9wcy5ldmVudFJlc2l6ZS5zZWdzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVuZGVyRmdTZWdzKGNvbCwgc2VnUGxhY2VtZW50cywgdG9kYXlSYW5nZSwgaXNGb3JjZWRJbnZpc2libGUsIGlzRHJhZ2dpbmcsIGlzUmVzaXppbmcsIGlzRGF0ZVNlbGVjdGluZykge1xyXG4gICAgICAgICAgICBsZXQgeyBjb250ZXh0IH0gPSB0aGlzO1xyXG4gICAgICAgICAgICBsZXQgeyBldmVudFNlbGVjdGlvbiB9ID0gdGhpcy5wcm9wcztcclxuICAgICAgICAgICAgbGV0IHsgZnJhbWVQb3NpdGlvbnMgfSA9IHRoaXMuc3RhdGU7XHJcbiAgICAgICAgICAgIGxldCBkZWZhdWx0RGlzcGxheUV2ZW50RW5kID0gdGhpcy5wcm9wcy5jZWxscy5sZW5ndGggPT09IDE7IC8vIGNvbENudCA9PT0gMVxyXG4gICAgICAgICAgICBsZXQgaXNNaXJyb3IgPSBpc0RyYWdnaW5nIHx8IGlzUmVzaXppbmcgfHwgaXNEYXRlU2VsZWN0aW5nO1xyXG4gICAgICAgICAgICBsZXQgbm9kZXMgPSBbXTtcclxuICAgICAgICAgICAgaWYgKGZyYW1lUG9zaXRpb25zKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBwbGFjZW1lbnQgb2Ygc2VnUGxhY2VtZW50cykge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCB7IHNlZyB9ID0gcGxhY2VtZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCB7IGluc3RhbmNlSWQgfSA9IHNlZy5ldmVudFJhbmdlLmluc3RhbmNlO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBrZXkgPSBpbnN0YW5jZUlkICsgJzonICsgY29sO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBpc1Zpc2libGUgPSBwbGFjZW1lbnQuaXNWaXNpYmxlICYmICFpc0ZvcmNlZEludmlzaWJsZVtpbnN0YW5jZUlkXTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgaXNBYnNvbHV0ZSA9IHBsYWNlbWVudC5pc0Fic29sdXRlO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBsZWZ0ID0gJyc7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJpZ2h0ID0gJyc7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzQWJzb2x1dGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRleHQuaXNSdGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBmcmFtZVBvc2l0aW9ucy5sZWZ0c1tzZWcubGFzdENvbF0gLSBmcmFtZVBvc2l0aW9ucy5sZWZ0c1tzZWcuZmlyc3RDb2xdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByaWdodCA9IGZyYW1lUG9zaXRpb25zLnJpZ2h0c1tzZWcuZmlyc3RDb2xdIC0gZnJhbWVQb3NpdGlvbnMucmlnaHRzW3NlZy5sYXN0Q29sXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvKlxyXG4gICAgICAgICAgICAgICAgICAgIGtub3duIGJ1ZzogZXZlbnRzIHRoYXQgYXJlIGZvcmNlIHRvIGJlIGxpc3QtaXRlbSBidXQgc3BhbiBtdWx0aXBsZSBkYXlzIHN0aWxsIHRha2UgdXAgc3BhY2UgaW4gbGF0ZXIgY29sdW1uc1xyXG4gICAgICAgICAgICAgICAgICAgIHRvZG86IGluIHByaW50IHZpZXcsIGZvciBtdWx0aS1kYXkgZXZlbnRzLCBkb24ndCBkaXNwbGF5IHRpdGxlIHdpdGhpbiBub24tc3RhcnQvZW5kIHNlZ3NcclxuICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgIG5vZGVzLnB1c2goeShcImRpdlwiLCB7IGNsYXNzTmFtZTogJ2ZjLWRheWdyaWQtZXZlbnQtaGFybmVzcycgKyAoaXNBYnNvbHV0ZSA/ICcgZmMtZGF5Z3JpZC1ldmVudC1oYXJuZXNzLWFicycgOiAnJyksIGtleToga2V5LCByZWY6IGlzTWlycm9yID8gbnVsbCA6IHRoaXMuc2VnSGFybmVzc1JlZnMuY3JlYXRlUmVmKGtleSksIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aXNpYmlsaXR5OiBpc1Zpc2libGUgPyAnJyA6ICdoaWRkZW4nLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFyZ2luVG9wOiBpc0Fic29sdXRlID8gJycgOiBwbGFjZW1lbnQubWFyZ2luVG9wLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiBpc0Fic29sdXRlID8gcGxhY2VtZW50LmFic29sdXRlVG9wIDogJycsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gfSwgaGFzTGlzdEl0ZW1EaXNwbGF5KHNlZykgPyAoeShUYWJsZUxpc3RJdGVtRXZlbnQsIE9iamVjdC5hc3NpZ24oeyBzZWc6IHNlZywgaXNEcmFnZ2luZzogaXNEcmFnZ2luZywgaXNTZWxlY3RlZDogaW5zdGFuY2VJZCA9PT0gZXZlbnRTZWxlY3Rpb24sIGRlZmF1bHREaXNwbGF5RXZlbnRFbmQ6IGRlZmF1bHREaXNwbGF5RXZlbnRFbmQgfSwgZ2V0U2VnTWV0YShzZWcsIHRvZGF5UmFuZ2UpKSkpIDogKHkoVGFibGVCbG9ja0V2ZW50LCBPYmplY3QuYXNzaWduKHsgc2VnOiBzZWcsIGlzRHJhZ2dpbmc6IGlzRHJhZ2dpbmcsIGlzUmVzaXppbmc6IGlzUmVzaXppbmcsIGlzRGF0ZVNlbGVjdGluZzogaXNEYXRlU2VsZWN0aW5nLCBpc1NlbGVjdGVkOiBpbnN0YW5jZUlkID09PSBldmVudFNlbGVjdGlvbiwgZGVmYXVsdERpc3BsYXlFdmVudEVuZDogZGVmYXVsdERpc3BsYXlFdmVudEVuZCB9LCBnZXRTZWdNZXRhKHNlZywgdG9kYXlSYW5nZSkpKSkpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbm9kZXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlbmRlckZpbGxTZWdzKHNlZ3MsIGZpbGxUeXBlKSB7XHJcbiAgICAgICAgICAgIGxldCB7IGlzUnRsIH0gPSB0aGlzLmNvbnRleHQ7XHJcbiAgICAgICAgICAgIGxldCB7IHRvZGF5UmFuZ2UgfSA9IHRoaXMucHJvcHM7XHJcbiAgICAgICAgICAgIGxldCB7IGZyYW1lUG9zaXRpb25zIH0gPSB0aGlzLnN0YXRlO1xyXG4gICAgICAgICAgICBsZXQgbm9kZXMgPSBbXTtcclxuICAgICAgICAgICAgaWYgKGZyYW1lUG9zaXRpb25zKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBzZWcgb2Ygc2Vncykge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBsZWZ0UmlnaHRDc3MgPSBpc1J0bCA/IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IGZyYW1lUG9zaXRpb25zLmxlZnRzW3NlZy5sYXN0Q29sXSAtIGZyYW1lUG9zaXRpb25zLmxlZnRzW3NlZy5maXJzdENvbF0sXHJcbiAgICAgICAgICAgICAgICAgICAgfSA6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IGZyYW1lUG9zaXRpb25zLnJpZ2h0c1tzZWcuZmlyc3RDb2xdIC0gZnJhbWVQb3NpdGlvbnMucmlnaHRzW3NlZy5sYXN0Q29sXSxcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIG5vZGVzLnB1c2goeShcImRpdlwiLCB7IGtleTogYnVpbGRFdmVudFJhbmdlS2V5KHNlZy5ldmVudFJhbmdlKSwgY2xhc3NOYW1lOiBcImZjLWRheWdyaWQtYmctaGFybmVzc1wiLCBzdHlsZTogbGVmdFJpZ2h0Q3NzIH0sIGZpbGxUeXBlID09PSAnYmctZXZlbnQnID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgeShCZ0V2ZW50LCBPYmplY3QuYXNzaWduKHsgc2VnOiBzZWcgfSwgZ2V0U2VnTWV0YShzZWcsIHRvZGF5UmFuZ2UpKSkgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZW5kZXJGaWxsKGZpbGxUeXBlKSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB5KF8sIHt9LCAuLi5ub2Rlcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHVwZGF0ZVNpemluZyhpc0V4dGVybmFsU2l6aW5nQ2hhbmdlKSB7XHJcbiAgICAgICAgICAgIGxldCB7IHByb3BzLCBzdGF0ZSwgZnJhbWVFbFJlZnMgfSA9IHRoaXM7XHJcbiAgICAgICAgICAgIGlmICghcHJvcHMuZm9yUHJpbnQgJiZcclxuICAgICAgICAgICAgICAgIHByb3BzLmNsaWVudFdpZHRoICE9PSBudWxsIC8vIHBvc2l0aW9uaW5nIHJlYWR5P1xyXG4gICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICAgIGlmIChpc0V4dGVybmFsU2l6aW5nQ2hhbmdlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZyYW1lRWxzID0gcHJvcHMuY2VsbHMubWFwKChjZWxsKSA9PiBmcmFtZUVsUmVmcy5jdXJyZW50TWFwW2NlbGwua2V5XSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZyYW1lRWxzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgb3JpZ2luRWwgPSB0aGlzLnJvb3RFbFJlZi5jdXJyZW50O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbmV3UG9zaXRpb25DYWNoZSA9IG5ldyBQb3NpdGlvbkNhY2hlKG9yaWdpbkVsLCBmcmFtZUVscywgdHJ1ZSwgLy8gaXNIb3Jpem9udGFsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzdGF0ZS5mcmFtZVBvc2l0aW9ucyB8fCAhc3RhdGUuZnJhbWVQb3NpdGlvbnMuc2ltaWxhclRvKG5ld1Bvc2l0aW9uQ2FjaGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcmFtZVBvc2l0aW9uczogbmV3IFBvc2l0aW9uQ2FjaGUob3JpZ2luRWwsIGZyYW1lRWxzLCB0cnVlLCAvLyBpc0hvcml6b250YWxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWxzZSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnN0IG9sZEluc3RhbmNlSGVpZ2h0cyA9IHRoaXMuc3RhdGUuZXZlbnRJbnN0YW5jZUhlaWdodHM7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdJbnN0YW5jZUhlaWdodHMgPSB0aGlzLnF1ZXJ5RXZlbnRJbnN0YW5jZUhlaWdodHMoKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGxpbWl0QnlDb250ZW50SGVpZ2h0ID0gcHJvcHMuZGF5TWF4RXZlbnRzID09PSB0cnVlIHx8IHByb3BzLmRheU1heEV2ZW50Um93cyA9PT0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2FmZVNldFN0YXRlKHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBIQUNLIHRvIHByZXZlbnQgb3NjaWxsYXRpb25zIG9mIGV2ZW50cyBiZWluZyBzaG93bi9oaWRkZW4gZnJvbSBtYXgtZXZlbnQtcm93c1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEVzc2VudGlhbGx5LCBvbmNlIHlvdSBjb21wdXRlIGFuIGVsZW1lbnQncyBoZWlnaHQsIG5ldmVyIG51bGwtb3V0LlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IGFsd2F5cyBkaXNwbGF5IGFsbCBldmVudHMsIGFzIHZpc2liaWxpdHk6aGlkZGVuP1xyXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50SW5zdGFuY2VIZWlnaHRzOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG9sZEluc3RhbmNlSGVpZ2h0cyksIG5ld0luc3RhbmNlSGVpZ2h0cyksXHJcbiAgICAgICAgICAgICAgICAgICAgbWF4Q29udGVudEhlaWdodDogbGltaXRCeUNvbnRlbnRIZWlnaHQgPyB0aGlzLmNvbXB1dGVNYXhDb250ZW50SGVpZ2h0KCkgOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcXVlcnlFdmVudEluc3RhbmNlSGVpZ2h0cygpIHtcclxuICAgICAgICAgICAgbGV0IHNlZ0VsTWFwID0gdGhpcy5zZWdIYXJuZXNzUmVmcy5jdXJyZW50TWFwO1xyXG4gICAgICAgICAgICBsZXQgZXZlbnRJbnN0YW5jZUhlaWdodHMgPSB7fTtcclxuICAgICAgICAgICAgLy8gZ2V0IHRoZSBtYXggaGVpZ2h0IGFtb25nc3QgaW5zdGFuY2Ugc2Vnc1xyXG4gICAgICAgICAgICBmb3IgKGxldCBrZXkgaW4gc2VnRWxNYXApIHtcclxuICAgICAgICAgICAgICAgIGxldCBoZWlnaHQgPSBNYXRoLnJvdW5kKHNlZ0VsTWFwW2tleV0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgIGxldCBpbnN0YW5jZUlkID0ga2V5LnNwbGl0KCc6JylbMF07IC8vIGRlY29uc3RydWN0IGhvdyByZW5kZXJGZ1NlZ3MgbWFrZXMgdGhlIGtleVxyXG4gICAgICAgICAgICAgICAgZXZlbnRJbnN0YW5jZUhlaWdodHNbaW5zdGFuY2VJZF0gPSBNYXRoLm1heChldmVudEluc3RhbmNlSGVpZ2h0c1tpbnN0YW5jZUlkXSB8fCAwLCBoZWlnaHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBldmVudEluc3RhbmNlSGVpZ2h0cztcclxuICAgICAgICB9XHJcbiAgICAgICAgY29tcHV0ZU1heENvbnRlbnRIZWlnaHQoKSB7XHJcbiAgICAgICAgICAgIGxldCBmaXJzdEtleSA9IHRoaXMucHJvcHMuY2VsbHNbMF0ua2V5O1xyXG4gICAgICAgICAgICBsZXQgY2VsbEVsID0gdGhpcy5jZWxsRWxSZWZzLmN1cnJlbnRNYXBbZmlyc3RLZXldO1xyXG4gICAgICAgICAgICBsZXQgZmNDb250YWluZXJFbCA9IHRoaXMuZmdFbFJlZnMuY3VycmVudE1hcFtmaXJzdEtleV07XHJcbiAgICAgICAgICAgIHJldHVybiBjZWxsRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuYm90dG9tIC0gZmNDb250YWluZXJFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3A7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGdldENlbGxFbHMoKSB7XHJcbiAgICAgICAgICAgIGxldCBlbE1hcCA9IHRoaXMuY2VsbEVsUmVmcy5jdXJyZW50TWFwO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9wcy5jZWxscy5tYXAoKGNlbGwpID0+IGVsTWFwW2NlbGwua2V5XSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgVGFibGVSb3cuYWRkU3RhdGVFcXVhbGl0eSh7XHJcbiAgICAgICAgZXZlbnRJbnN0YW5jZUhlaWdodHM6IGlzUHJvcHNFcXVhbCxcclxuICAgIH0pO1xyXG4gICAgZnVuY3Rpb24gYnVpbGRNaXJyb3JQbGFjZW1lbnRzKG1pcnJvclNlZ3MsIGNvbFBsYWNlbWVudHMpIHtcclxuICAgICAgICBpZiAoIW1pcnJvclNlZ3MubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHRvcHNCeUluc3RhbmNlSWQgPSBidWlsZEFic29sdXRlVG9wSGFzaChjb2xQbGFjZW1lbnRzKTsgLy8gVE9ETzogY2FjaGUgdGhpcyBhdCBmaXJzdCByZW5kZXI/XHJcbiAgICAgICAgcmV0dXJuIG1pcnJvclNlZ3MubWFwKChzZWcpID0+ICh7XHJcbiAgICAgICAgICAgIHNlZyxcclxuICAgICAgICAgICAgaXNWaXNpYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBpc0Fic29sdXRlOiB0cnVlLFxyXG4gICAgICAgICAgICBhYnNvbHV0ZVRvcDogdG9wc0J5SW5zdGFuY2VJZFtzZWcuZXZlbnRSYW5nZS5pbnN0YW5jZS5pbnN0YW5jZUlkXSxcclxuICAgICAgICAgICAgbWFyZ2luVG9wOiAwLFxyXG4gICAgICAgIH0pKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGJ1aWxkQWJzb2x1dGVUb3BIYXNoKGNvbFBsYWNlbWVudHMpIHtcclxuICAgICAgICBsZXQgdG9wc0J5SW5zdGFuY2VJZCA9IHt9O1xyXG4gICAgICAgIGZvciAobGV0IHBsYWNlbWVudHMgb2YgY29sUGxhY2VtZW50cykge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBwbGFjZW1lbnQgb2YgcGxhY2VtZW50cykge1xyXG4gICAgICAgICAgICAgICAgdG9wc0J5SW5zdGFuY2VJZFtwbGFjZW1lbnQuc2VnLmV2ZW50UmFuZ2UuaW5zdGFuY2UuaW5zdGFuY2VJZF0gPSBwbGFjZW1lbnQuYWJzb2x1dGVUb3A7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRvcHNCeUluc3RhbmNlSWQ7XHJcbiAgICB9XHJcblxyXG4gICAgY2xhc3MgVGFibGVSb3dzIGV4dGVuZHMgRGF0ZUNvbXBvbmVudCB7XHJcbiAgICAgICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgIHRoaXMuc3BsaXRCdXNpbmVzc0hvdXJTZWdzID0gbWVtb2l6ZShzcGxpdFNlZ3NCeVJvdyk7XHJcbiAgICAgICAgICAgIHRoaXMuc3BsaXRCZ0V2ZW50U2VncyA9IG1lbW9pemUoc3BsaXRTZWdzQnlSb3cpO1xyXG4gICAgICAgICAgICB0aGlzLnNwbGl0RmdFdmVudFNlZ3MgPSBtZW1vaXplKHNwbGl0U2Vnc0J5Um93KTtcclxuICAgICAgICAgICAgdGhpcy5zcGxpdERhdGVTZWxlY3Rpb25TZWdzID0gbWVtb2l6ZShzcGxpdFNlZ3NCeVJvdyk7XHJcbiAgICAgICAgICAgIHRoaXMuc3BsaXRFdmVudERyYWcgPSBtZW1vaXplKHNwbGl0SW50ZXJhY3Rpb25CeVJvdyk7XHJcbiAgICAgICAgICAgIHRoaXMuc3BsaXRFdmVudFJlc2l6ZSA9IG1lbW9pemUoc3BsaXRJbnRlcmFjdGlvbkJ5Um93KTtcclxuICAgICAgICAgICAgdGhpcy5yb3dSZWZzID0gbmV3IFJlZk1hcCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZW5kZXIoKSB7XHJcbiAgICAgICAgICAgIGxldCB7IHByb3BzLCBjb250ZXh0IH0gPSB0aGlzO1xyXG4gICAgICAgICAgICBsZXQgcm93Q250ID0gcHJvcHMuY2VsbHMubGVuZ3RoO1xyXG4gICAgICAgICAgICBsZXQgYnVzaW5lc3NIb3VyU2Vnc0J5Um93ID0gdGhpcy5zcGxpdEJ1c2luZXNzSG91clNlZ3MocHJvcHMuYnVzaW5lc3NIb3VyU2Vncywgcm93Q250KTtcclxuICAgICAgICAgICAgbGV0IGJnRXZlbnRTZWdzQnlSb3cgPSB0aGlzLnNwbGl0QmdFdmVudFNlZ3MocHJvcHMuYmdFdmVudFNlZ3MsIHJvd0NudCk7XHJcbiAgICAgICAgICAgIGxldCBmZ0V2ZW50U2Vnc0J5Um93ID0gdGhpcy5zcGxpdEZnRXZlbnRTZWdzKHByb3BzLmZnRXZlbnRTZWdzLCByb3dDbnQpO1xyXG4gICAgICAgICAgICBsZXQgZGF0ZVNlbGVjdGlvblNlZ3NCeVJvdyA9IHRoaXMuc3BsaXREYXRlU2VsZWN0aW9uU2Vncyhwcm9wcy5kYXRlU2VsZWN0aW9uU2Vncywgcm93Q250KTtcclxuICAgICAgICAgICAgbGV0IGV2ZW50RHJhZ0J5Um93ID0gdGhpcy5zcGxpdEV2ZW50RHJhZyhwcm9wcy5ldmVudERyYWcsIHJvd0NudCk7XHJcbiAgICAgICAgICAgIGxldCBldmVudFJlc2l6ZUJ5Um93ID0gdGhpcy5zcGxpdEV2ZW50UmVzaXplKHByb3BzLmV2ZW50UmVzaXplLCByb3dDbnQpO1xyXG4gICAgICAgICAgICAvLyBmb3IgRGF5R3JpZCB2aWV3IHdpdGggbWFueSByb3dzLCBmb3JjZSBhIG1pbi1oZWlnaHQgb24gY2VsbHMgc28gZG9lc24ndCBhcHBlYXIgc3F1aXNoZWRcclxuICAgICAgICAgICAgLy8gY2hvb3NlIDcgYmVjYXVzZSBhIG1vbnRoIHZpZXcgd2lsbCBoYXZlIG1heCA2IHJvd3NcclxuICAgICAgICAgICAgbGV0IGNlbGxNaW5IZWlnaHQgPSAocm93Q250ID49IDcgJiYgcHJvcHMuY2xpZW50V2lkdGgpID9cclxuICAgICAgICAgICAgICAgIHByb3BzLmNsaWVudFdpZHRoIC8gY29udGV4dC5vcHRpb25zLmFzcGVjdFJhdGlvIC8gNiA6XHJcbiAgICAgICAgICAgICAgICBudWxsO1xyXG4gICAgICAgICAgICByZXR1cm4gKHkoTm93VGltZXIsIHsgdW5pdDogXCJkYXlcIiB9LCAobm93RGF0ZSwgdG9kYXlSYW5nZSkgPT4gKHkoXywgbnVsbCwgcHJvcHMuY2VsbHMubWFwKChjZWxscywgcm93KSA9PiAoeShUYWJsZVJvdywgeyByZWY6IHRoaXMucm93UmVmcy5jcmVhdGVSZWYocm93KSwga2V5OiBjZWxscy5sZW5ndGhcclxuICAgICAgICAgICAgICAgICAgICA/IGNlbGxzWzBdLmRhdGUudG9JU09TdHJpbmcoKSAvKiBiZXN0PyBvciBwdXQga2V5IG9uIGNlbGw/IG9yIHVzZSBkaWZmIGZvcm1hdHRlcj8gKi9cclxuICAgICAgICAgICAgICAgICAgICA6IHJvdyAvLyBpbiBjYXNlIHRoZXJlIGFyZSBubyBjZWxscyAobGlrZSB3aGVuIHJlc291cmNlIHZpZXcgaXMgbG9hZGluZylcclxuICAgICAgICAgICAgICAgICwgc2hvd0RheU51bWJlcnM6IHJvd0NudCA+IDEsIHNob3dXZWVrTnVtYmVyczogcHJvcHMuc2hvd1dlZWtOdW1iZXJzLCB0b2RheVJhbmdlOiB0b2RheVJhbmdlLCBkYXRlUHJvZmlsZTogcHJvcHMuZGF0ZVByb2ZpbGUsIGNlbGxzOiBjZWxscywgcmVuZGVySW50cm86IHByb3BzLnJlbmRlclJvd0ludHJvLCBidXNpbmVzc0hvdXJTZWdzOiBidXNpbmVzc0hvdXJTZWdzQnlSb3dbcm93XSwgZXZlbnRTZWxlY3Rpb246IHByb3BzLmV2ZW50U2VsZWN0aW9uLCBiZ0V2ZW50U2VnczogYmdFdmVudFNlZ3NCeVJvd1tyb3ddLmZpbHRlcihpc1NlZ0FsbERheSkgLyogaGFjayAqLywgZmdFdmVudFNlZ3M6IGZnRXZlbnRTZWdzQnlSb3dbcm93XSwgZGF0ZVNlbGVjdGlvblNlZ3M6IGRhdGVTZWxlY3Rpb25TZWdzQnlSb3dbcm93XSwgZXZlbnREcmFnOiBldmVudERyYWdCeVJvd1tyb3ddLCBldmVudFJlc2l6ZTogZXZlbnRSZXNpemVCeVJvd1tyb3ddLCBkYXlNYXhFdmVudHM6IHByb3BzLmRheU1heEV2ZW50cywgZGF5TWF4RXZlbnRSb3dzOiBwcm9wcy5kYXlNYXhFdmVudFJvd3MsIGNsaWVudFdpZHRoOiBwcm9wcy5jbGllbnRXaWR0aCwgY2xpZW50SGVpZ2h0OiBwcm9wcy5jbGllbnRIZWlnaHQsIGNlbGxNaW5IZWlnaHQ6IGNlbGxNaW5IZWlnaHQsIGZvclByaW50OiBwcm9wcy5mb3JQcmludCB9KSkpKSkpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29tcG9uZW50RGlkTW91bnQoKSB7XHJcbiAgICAgICAgICAgIC8vIEhBQ0s6IG5lZWQgYSBkYXlncmlkIHdyYXBwZXIgcGFyZW50IHRvIGRvIHBvc2l0aW9uaW5nXHJcbiAgICAgICAgICAgIC8vIE5PVEU6IGEgZGF5Z3JpZCByZXNvdXJjZSB2aWV3IHcvbyByZXNvdXJjZXMgY2FuIGhhdmUgemVybyBjZWxsc1xyXG4gICAgICAgICAgICBjb25zdCBmaXJzdENlbGxFbCA9IHRoaXMucm93UmVmcy5jdXJyZW50TWFwWzBdLmdldENlbGxFbHMoKVswXTtcclxuICAgICAgICAgICAgdGhpcy5yb290RWwgPSBmaXJzdENlbGxFbCA/IGZpcnN0Q2VsbEVsLmNsb3Nlc3QoJy5mYy1kYXlncmlkLWJvZHknKSA6IG51bGw7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnJvb3RFbCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LnJlZ2lzdGVySW50ZXJhY3RpdmVDb21wb25lbnQodGhpcywge1xyXG4gICAgICAgICAgICAgICAgICAgIGVsOiB0aGlzLnJvb3RFbCxcclxuICAgICAgICAgICAgICAgICAgICBpc0hpdENvbWJvQWxsb3dlZDogdGhpcy5wcm9wcy5pc0hpdENvbWJvQWxsb3dlZCxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5yb290RWwpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC51bnJlZ2lzdGVySW50ZXJhY3RpdmVDb21wb25lbnQodGhpcyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJvb3RFbCA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gSGl0IFN5c3RlbVxyXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgICAgICBwcmVwYXJlSGl0cygpIHtcclxuICAgICAgICAgICAgdGhpcy5yb3dQb3NpdGlvbnMgPSBuZXcgUG9zaXRpb25DYWNoZSh0aGlzLnJvb3RFbCwgdGhpcy5yb3dSZWZzLmNvbGxlY3QoKS5tYXAoKHJvd09iaikgPT4gcm93T2JqLmdldENlbGxFbHMoKVswXSksIC8vIGZpcnN0IGNlbGwgZWwgaW4gZWFjaCByb3cuIFRPRE86IG5vdCBvcHRpbWFsXHJcbiAgICAgICAgICAgIGZhbHNlLCB0cnVlKTtcclxuICAgICAgICAgICAgdGhpcy5jb2xQb3NpdGlvbnMgPSBuZXcgUG9zaXRpb25DYWNoZSh0aGlzLnJvb3RFbCwgdGhpcy5yb3dSZWZzLmN1cnJlbnRNYXBbMF0uZ2V0Q2VsbEVscygpLCAvLyBjZWxsIGVscyBpbiBmaXJzdCByb3dcclxuICAgICAgICAgICAgdHJ1ZSwgLy8gaG9yaXpvbnRhbFxyXG4gICAgICAgICAgICBmYWxzZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHF1ZXJ5SGl0KHBvc2l0aW9uTGVmdCwgcG9zaXRpb25Ub3ApIHtcclxuICAgICAgICAgICAgbGV0IHsgY29sUG9zaXRpb25zLCByb3dQb3NpdGlvbnMgfSA9IHRoaXM7XHJcbiAgICAgICAgICAgIGxldCBjb2wgPSBjb2xQb3NpdGlvbnMubGVmdFRvSW5kZXgocG9zaXRpb25MZWZ0KTtcclxuICAgICAgICAgICAgbGV0IHJvdyA9IHJvd1Bvc2l0aW9ucy50b3BUb0luZGV4KHBvc2l0aW9uVG9wKTtcclxuICAgICAgICAgICAgaWYgKHJvdyAhPSBudWxsICYmIGNvbCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgY2VsbCA9IHRoaXMucHJvcHMuY2VsbHNbcm93XVtjb2xdO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICBkYXRlUHJvZmlsZTogdGhpcy5wcm9wcy5kYXRlUHJvZmlsZSxcclxuICAgICAgICAgICAgICAgICAgICBkYXRlU3BhbjogT2JqZWN0LmFzc2lnbih7IHJhbmdlOiB0aGlzLmdldENlbGxSYW5nZShyb3csIGNvbCksIGFsbERheTogdHJ1ZSB9LCBjZWxsLmV4dHJhRGF0ZVNwYW4pLFxyXG4gICAgICAgICAgICAgICAgICAgIGRheUVsOiB0aGlzLmdldENlbGxFbChyb3csIGNvbCksXHJcbiAgICAgICAgICAgICAgICAgICAgcmVjdDoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiBjb2xQb3NpdGlvbnMubGVmdHNbY29sXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IGNvbFBvc2l0aW9ucy5yaWdodHNbY29sXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiByb3dQb3NpdGlvbnMudG9wc1tyb3ddLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBib3R0b206IHJvd1Bvc2l0aW9ucy5ib3R0b21zW3Jvd10sXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBsYXllcjogMCxcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGdldENlbGxFbChyb3csIGNvbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yb3dSZWZzLmN1cnJlbnRNYXBbcm93XS5nZXRDZWxsRWxzKClbY29sXTsgLy8gVE9ETzogbm90IG9wdGltYWxcclxuICAgICAgICB9XHJcbiAgICAgICAgZ2V0Q2VsbFJhbmdlKHJvdywgY29sKSB7XHJcbiAgICAgICAgICAgIGxldCBzdGFydCA9IHRoaXMucHJvcHMuY2VsbHNbcm93XVtjb2xdLmRhdGU7XHJcbiAgICAgICAgICAgIGxldCBlbmQgPSBhZGREYXlzKHN0YXJ0LCAxKTtcclxuICAgICAgICAgICAgcmV0dXJuIHsgc3RhcnQsIGVuZCB9O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGlzU2VnQWxsRGF5KHNlZykge1xyXG4gICAgICAgIHJldHVybiBzZWcuZXZlbnRSYW5nZS5kZWYuYWxsRGF5O1xyXG4gICAgfVxyXG5cclxuICAgIGNsYXNzIFRhYmxlIGV4dGVuZHMgRGF0ZUNvbXBvbmVudCB7XHJcbiAgICAgICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgIHRoaXMuZWxSZWYgPSBkKCk7XHJcbiAgICAgICAgICAgIHRoaXMubmVlZHNTY3JvbGxSZXNldCA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZW5kZXIoKSB7XHJcbiAgICAgICAgICAgIGxldCB7IHByb3BzIH0gPSB0aGlzO1xyXG4gICAgICAgICAgICBsZXQgeyBkYXlNYXhFdmVudFJvd3MsIGRheU1heEV2ZW50cywgZXhwYW5kUm93cyB9ID0gcHJvcHM7XHJcbiAgICAgICAgICAgIGxldCBsaW1pdFZpYUJhbGFuY2VkID0gZGF5TWF4RXZlbnRzID09PSB0cnVlIHx8IGRheU1heEV2ZW50Um93cyA9PT0gdHJ1ZTtcclxuICAgICAgICAgICAgLy8gaWYgcm93cyBjYW4ndCBleHBhbmQgdG8gZmlsbCBmaXhlZCBoZWlnaHQsIGNhbid0IGRvIGJhbGFuY2VkLWhlaWdodCBldmVudCBsaW1pdFxyXG4gICAgICAgICAgICAvLyBUT0RPOiBiZXN0IHBsYWNlIHRvIG5vcm1hbGl6ZSB0aGVzZSBvcHRpb25zP1xyXG4gICAgICAgICAgICBpZiAobGltaXRWaWFCYWxhbmNlZCAmJiAhZXhwYW5kUm93cykge1xyXG4gICAgICAgICAgICAgICAgbGltaXRWaWFCYWxhbmNlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgZGF5TWF4RXZlbnRSb3dzID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIGRheU1heEV2ZW50cyA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IGNsYXNzTmFtZXMgPSBbXHJcbiAgICAgICAgICAgICAgICAnZmMtZGF5Z3JpZC1ib2R5JyxcclxuICAgICAgICAgICAgICAgIGxpbWl0VmlhQmFsYW5jZWQgPyAnZmMtZGF5Z3JpZC1ib2R5LWJhbGFuY2VkJyA6ICdmYy1kYXlncmlkLWJvZHktdW5iYWxhbmNlZCcsXHJcbiAgICAgICAgICAgICAgICBleHBhbmRSb3dzID8gJycgOiAnZmMtZGF5Z3JpZC1ib2R5LW5hdHVyYWwnLCAvLyB3aWxsIGhlaWdodCBvZiBvbmUgcm93IGRlcGVuZCBvbiB0aGUgb3RoZXJzP1xyXG4gICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICByZXR1cm4gKHkoXCJkaXZcIiwgeyByZWY6IHRoaXMuZWxSZWYsIGNsYXNzTmFtZTogY2xhc3NOYW1lcy5qb2luKCcgJyksIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlc2UgcHJvcHMgYXJlIGltcG9ydGFudCB0byBnaXZlIHRoaXMgd3JhcHBlciBjb3JyZWN0IGRpbWVuc2lvbnMgZm9yIGludGVyYWN0aW9uc1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IGlmIHdlIHNldCBpdCBoZXJlLCBjYW4gd2UgYXZvaWQgZ2l2aW5nIHRvIGlubmVyIHRhYmxlcz9cclxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogcHJvcHMuY2xpZW50V2lkdGgsXHJcbiAgICAgICAgICAgICAgICAgICAgbWluV2lkdGg6IHByb3BzLnRhYmxlTWluV2lkdGgsXHJcbiAgICAgICAgICAgICAgICB9IH0sXHJcbiAgICAgICAgICAgICAgICB5KFwidGFibGVcIiwgeyByb2xlOiBcInByZXNlbnRhdGlvblwiLCBjbGFzc05hbWU6IFwiZmMtc2Nyb2xsZ3JpZC1zeW5jLXRhYmxlXCIsIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBwcm9wcy5jbGllbnRXaWR0aCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWluV2lkdGg6IHByb3BzLnRhYmxlTWluV2lkdGgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogZXhwYW5kUm93cyA/IHByb3BzLmNsaWVudEhlaWdodCA6ICcnLFxyXG4gICAgICAgICAgICAgICAgICAgIH0gfSxcclxuICAgICAgICAgICAgICAgICAgICBwcm9wcy5jb2xHcm91cE5vZGUsXHJcbiAgICAgICAgICAgICAgICAgICAgeShcInRib2R5XCIsIHsgcm9sZTogXCJwcmVzZW50YXRpb25cIiB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB5KFRhYmxlUm93cywgeyBkYXRlUHJvZmlsZTogcHJvcHMuZGF0ZVByb2ZpbGUsIGNlbGxzOiBwcm9wcy5jZWxscywgcmVuZGVyUm93SW50cm86IHByb3BzLnJlbmRlclJvd0ludHJvLCBzaG93V2Vla051bWJlcnM6IHByb3BzLnNob3dXZWVrTnVtYmVycywgY2xpZW50V2lkdGg6IHByb3BzLmNsaWVudFdpZHRoLCBjbGllbnRIZWlnaHQ6IHByb3BzLmNsaWVudEhlaWdodCwgYnVzaW5lc3NIb3VyU2VnczogcHJvcHMuYnVzaW5lc3NIb3VyU2VncywgYmdFdmVudFNlZ3M6IHByb3BzLmJnRXZlbnRTZWdzLCBmZ0V2ZW50U2VnczogcHJvcHMuZmdFdmVudFNlZ3MsIGRhdGVTZWxlY3Rpb25TZWdzOiBwcm9wcy5kYXRlU2VsZWN0aW9uU2VncywgZXZlbnRTZWxlY3Rpb246IHByb3BzLmV2ZW50U2VsZWN0aW9uLCBldmVudERyYWc6IHByb3BzLmV2ZW50RHJhZywgZXZlbnRSZXNpemU6IHByb3BzLmV2ZW50UmVzaXplLCBkYXlNYXhFdmVudHM6IGRheU1heEV2ZW50cywgZGF5TWF4RXZlbnRSb3dzOiBkYXlNYXhFdmVudFJvd3MsIGZvclByaW50OiBwcm9wcy5mb3JQcmludCwgaXNIaXRDb21ib0FsbG93ZWQ6IHByb3BzLmlzSGl0Q29tYm9BbGxvd2VkIH0pKSkpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29tcG9uZW50RGlkTW91bnQoKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdFNjcm9sbFJlc2V0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMpIHtcclxuICAgICAgICAgICAgaWYgKHByZXZQcm9wcy5kYXRlUHJvZmlsZSAhPT0gdGhpcy5wcm9wcy5kYXRlUHJvZmlsZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZXF1ZXN0U2Nyb2xsUmVzZXQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZmx1c2hTY3JvbGxSZXNldCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlcXVlc3RTY3JvbGxSZXNldCgpIHtcclxuICAgICAgICAgICAgdGhpcy5uZWVkc1Njcm9sbFJlc2V0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5mbHVzaFNjcm9sbFJlc2V0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZsdXNoU2Nyb2xsUmVzZXQoKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLm5lZWRzU2Nyb2xsUmVzZXQgJiZcclxuICAgICAgICAgICAgICAgIHRoaXMucHJvcHMuY2xpZW50V2lkdGggLy8gc2l6ZXMgY29tcHV0ZWQ/XHJcbiAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc3ViamVjdEVsID0gZ2V0U2Nyb2xsU3ViamVjdEVsKHRoaXMuZWxSZWYuY3VycmVudCwgdGhpcy5wcm9wcy5kYXRlUHJvZmlsZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3ViamVjdEVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3JpZ2luRWwgPSBzdWJqZWN0RWwuY2xvc2VzdCgnLmZjLWRheWdyaWQtYm9keScpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNjcm9sbEVsID0gb3JpZ2luRWwuY2xvc2VzdCgnLmZjLXNjcm9sbGVyJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2Nyb2xsVG9wID0gc3ViamVjdEVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCAtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbkVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcDtcclxuICAgICAgICAgICAgICAgICAgICBzY3JvbGxFbC5zY3JvbGxUb3AgPSBzY3JvbGxUb3AgPyAoc2Nyb2xsVG9wICsgMSkgOiAwOyAvLyBvdmVyY29tZSBib3JkZXJcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMubmVlZHNTY3JvbGxSZXNldCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZ2V0U2Nyb2xsU3ViamVjdEVsKGNvbnRhaW5lckVsLCBkYXRlUHJvZmlsZSkge1xyXG4gICAgICAgIGxldCBlbDtcclxuICAgICAgICBpZiAoZGF0ZVByb2ZpbGUuY3VycmVudFJhbmdlVW5pdC5tYXRjaCgveWVhcnxtb250aC8pKSB7XHJcbiAgICAgICAgICAgIGVsID0gY29udGFpbmVyRWwucXVlcnlTZWxlY3RvcihgW2RhdGEtZGF0ZT1cIiR7Zm9ybWF0SXNvTW9udGhTdHIoZGF0ZVByb2ZpbGUuY3VycmVudERhdGUpfS0wMVwiXWApO1xyXG4gICAgICAgICAgICAvLyBldmVuIGlmIHZpZXcgaXMgbW9udGgtYmFzZWQsIGZpcnN0LW9mLW1vbnRoIG1pZ2h0IGJlIGhpZGRlbi4uLlxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWVsKSB7XHJcbiAgICAgICAgICAgIGVsID0gY29udGFpbmVyRWwucXVlcnlTZWxlY3RvcihgW2RhdGEtZGF0ZT1cIiR7Zm9ybWF0RGF5U3RyaW5nKGRhdGVQcm9maWxlLmN1cnJlbnREYXRlKX1cIl1gKTtcclxuICAgICAgICAgICAgLy8gY291bGQgc3RpbGwgYmUgaGlkZGVuIGlmIGFuIGludGVyaW9yLXZpZXcgaGlkZGVuIGRheVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZWw7XHJcbiAgICB9XHJcblxyXG4gICAgY2xhc3MgRGF5VGFibGVTbGljZXIgZXh0ZW5kcyBTbGljZXIge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgICAgICB0aGlzLmZvcmNlRGF5SWZMaXN0SXRlbSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNsaWNlUmFuZ2UoZGF0ZVJhbmdlLCBkYXlUYWJsZU1vZGVsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkYXlUYWJsZU1vZGVsLnNsaWNlUmFuZ2UoZGF0ZVJhbmdlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY2xhc3MgRGF5VGFibGUgZXh0ZW5kcyBEYXRlQ29tcG9uZW50IHtcclxuICAgICAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgdGhpcy5zbGljZXIgPSBuZXcgRGF5VGFibGVTbGljZXIoKTtcclxuICAgICAgICAgICAgdGhpcy50YWJsZVJlZiA9IGQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVuZGVyKCkge1xyXG4gICAgICAgICAgICBsZXQgeyBwcm9wcywgY29udGV4dCB9ID0gdGhpcztcclxuICAgICAgICAgICAgcmV0dXJuICh5KFRhYmxlLCBPYmplY3QuYXNzaWduKHsgcmVmOiB0aGlzLnRhYmxlUmVmIH0sIHRoaXMuc2xpY2VyLnNsaWNlUHJvcHMocHJvcHMsIHByb3BzLmRhdGVQcm9maWxlLCBwcm9wcy5uZXh0RGF5VGhyZXNob2xkLCBjb250ZXh0LCBwcm9wcy5kYXlUYWJsZU1vZGVsKSwgeyBkYXRlUHJvZmlsZTogcHJvcHMuZGF0ZVByb2ZpbGUsIGNlbGxzOiBwcm9wcy5kYXlUYWJsZU1vZGVsLmNlbGxzLCBjb2xHcm91cE5vZGU6IHByb3BzLmNvbEdyb3VwTm9kZSwgdGFibGVNaW5XaWR0aDogcHJvcHMudGFibGVNaW5XaWR0aCwgcmVuZGVyUm93SW50cm86IHByb3BzLnJlbmRlclJvd0ludHJvLCBkYXlNYXhFdmVudHM6IHByb3BzLmRheU1heEV2ZW50cywgZGF5TWF4RXZlbnRSb3dzOiBwcm9wcy5kYXlNYXhFdmVudFJvd3MsIHNob3dXZWVrTnVtYmVyczogcHJvcHMuc2hvd1dlZWtOdW1iZXJzLCBleHBhbmRSb3dzOiBwcm9wcy5leHBhbmRSb3dzLCBoZWFkZXJBbGlnbkVsUmVmOiBwcm9wcy5oZWFkZXJBbGlnbkVsUmVmLCBjbGllbnRXaWR0aDogcHJvcHMuY2xpZW50V2lkdGgsIGNsaWVudEhlaWdodDogcHJvcHMuY2xpZW50SGVpZ2h0LCBmb3JQcmludDogcHJvcHMuZm9yUHJpbnQgfSkpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY2xhc3MgVGFibGVEYXRlUHJvZmlsZUdlbmVyYXRvciBleHRlbmRzIERhdGVQcm9maWxlR2VuZXJhdG9yIHtcclxuICAgICAgICAvLyBDb21wdXRlcyB0aGUgZGF0ZSByYW5nZSB0aGF0IHdpbGwgYmUgcmVuZGVyZWRcclxuICAgICAgICBidWlsZFJlbmRlclJhbmdlKGN1cnJlbnRSYW5nZSwgY3VycmVudFJhbmdlVW5pdCwgaXNSYW5nZUFsbERheSkge1xyXG4gICAgICAgICAgICBsZXQgcmVuZGVyUmFuZ2UgPSBzdXBlci5idWlsZFJlbmRlclJhbmdlKGN1cnJlbnRSYW5nZSwgY3VycmVudFJhbmdlVW5pdCwgaXNSYW5nZUFsbERheSk7XHJcbiAgICAgICAgICAgIGxldCB7IHByb3BzIH0gPSB0aGlzO1xyXG4gICAgICAgICAgICByZXR1cm4gYnVpbGREYXlUYWJsZVJlbmRlclJhbmdlKHtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRSYW5nZTogcmVuZGVyUmFuZ2UsXHJcbiAgICAgICAgICAgICAgICBzbmFwVG9XZWVrOiAvXih5ZWFyfG1vbnRoKSQvLnRlc3QoY3VycmVudFJhbmdlVW5pdCksXHJcbiAgICAgICAgICAgICAgICBmaXhlZFdlZWtDb3VudDogcHJvcHMuZml4ZWRXZWVrQ291bnQsXHJcbiAgICAgICAgICAgICAgICBkYXRlRW52OiBwcm9wcy5kYXRlRW52LFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBidWlsZERheVRhYmxlUmVuZGVyUmFuZ2UocHJvcHMpIHtcclxuICAgICAgICBsZXQgeyBkYXRlRW52LCBjdXJyZW50UmFuZ2UgfSA9IHByb3BzO1xyXG4gICAgICAgIGxldCB7IHN0YXJ0LCBlbmQgfSA9IGN1cnJlbnRSYW5nZTtcclxuICAgICAgICBsZXQgZW5kT2ZXZWVrO1xyXG4gICAgICAgIC8vIHllYXIgYW5kIG1vbnRoIHZpZXdzIHNob3VsZCBiZSBhbGlnbmVkIHdpdGggd2Vla3MuIHRoaXMgaXMgYWxyZWFkeSBkb25lIGZvciB3ZWVrXHJcbiAgICAgICAgaWYgKHByb3BzLnNuYXBUb1dlZWspIHtcclxuICAgICAgICAgICAgc3RhcnQgPSBkYXRlRW52LnN0YXJ0T2ZXZWVrKHN0YXJ0KTtcclxuICAgICAgICAgICAgLy8gbWFrZSBlbmQtb2Ytd2VlayBpZiBub3QgYWxyZWFkeVxyXG4gICAgICAgICAgICBlbmRPZldlZWsgPSBkYXRlRW52LnN0YXJ0T2ZXZWVrKGVuZCk7XHJcbiAgICAgICAgICAgIGlmIChlbmRPZldlZWsudmFsdWVPZigpICE9PSBlbmQudmFsdWVPZigpKSB7XHJcbiAgICAgICAgICAgICAgICBlbmQgPSBhZGRXZWVrcyhlbmRPZldlZWssIDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGVuc3VyZSA2IHdlZWtzXHJcbiAgICAgICAgaWYgKHByb3BzLmZpeGVkV2Vla0NvdW50KSB7XHJcbiAgICAgICAgICAgIC8vIFRPRE86IGluc3RlYWQgb2YgdGhlc2UgZGF0ZS1tYXRoIGd5bW5hc3RpY3MgKGZvciBtdWx0aW1vbnRoIHZpZXcpLFxyXG4gICAgICAgICAgICAvLyBjb21wdXRlIGRhdGVwcm9maWxlcyBvZiBhbGwgbW9udGhzLCB0aGVuIHVzZSBzdGFydCBvZiBmaXJzdCBhbmQgZW5kIG9mIGxhc3QuXHJcbiAgICAgICAgICAgIGxldCBsYXN0TW9udGhSZW5kZXJTdGFydCA9IGRhdGVFbnYuc3RhcnRPZldlZWsoZGF0ZUVudi5zdGFydE9mTW9udGgoYWRkRGF5cyhjdXJyZW50UmFuZ2UuZW5kLCAtMSkpKTtcclxuICAgICAgICAgICAgbGV0IHJvd0NudCA9IE1hdGguY2VpbCgvLyBjb3VsZCBiZSBwYXJ0aWFsIHdlZWtzIGR1ZSB0byBoaWRkZW5EYXlzXHJcbiAgICAgICAgICAgIGRpZmZXZWVrcyhsYXN0TW9udGhSZW5kZXJTdGFydCwgZW5kKSk7XHJcbiAgICAgICAgICAgIGVuZCA9IGFkZFdlZWtzKGVuZCwgNiAtIHJvd0NudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7IHN0YXJ0LCBlbmQgfTtcclxuICAgIH1cclxuXHJcbiAgICAvKiBBbiBhYnN0cmFjdCBjbGFzcyBmb3IgdGhlIGRheWdyaWQgdmlld3MsIGFzIHdlbGwgYXMgbW9udGggdmlldy4gUmVuZGVycyBvbmUgb3IgbW9yZSByb3dzIG9mIGRheSBjZWxscy5cclxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgLy8gSXQgaXMgYSBtYW5hZ2VyIGZvciBhIFRhYmxlIHN1YmNvbXBvbmVudCwgd2hpY2ggZG9lcyBtb3N0IG9mIHRoZSBoZWF2eSBsaWZ0aW5nLlxyXG4gICAgLy8gSXQgaXMgcmVzcG9uc2libGUgZm9yIG1hbmFnaW5nIHdpZHRoL2hlaWdodC5cclxuICAgIGNsYXNzIFRhYmxlVmlldyBleHRlbmRzIERhdGVDb21wb25lbnQge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgICAgICB0aGlzLmhlYWRlckVsUmVmID0gZCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZW5kZXJTaW1wbGVMYXlvdXQoaGVhZGVyUm93Q29udGVudCwgYm9keUNvbnRlbnQpIHtcclxuICAgICAgICAgICAgbGV0IHsgcHJvcHMsIGNvbnRleHQgfSA9IHRoaXM7XHJcbiAgICAgICAgICAgIGxldCBzZWN0aW9ucyA9IFtdO1xyXG4gICAgICAgICAgICBsZXQgc3RpY2t5SGVhZGVyRGF0ZXMgPSBnZXRTdGlja3lIZWFkZXJEYXRlcyhjb250ZXh0Lm9wdGlvbnMpO1xyXG4gICAgICAgICAgICBpZiAoaGVhZGVyUm93Q29udGVudCkge1xyXG4gICAgICAgICAgICAgICAgc2VjdGlvbnMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2hlYWRlcicsXHJcbiAgICAgICAgICAgICAgICAgICAga2V5OiAnaGVhZGVyJyxcclxuICAgICAgICAgICAgICAgICAgICBpc1N0aWNreTogc3RpY2t5SGVhZGVyRGF0ZXMsXHJcbiAgICAgICAgICAgICAgICAgICAgY2h1bms6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxSZWY6IHRoaXMuaGVhZGVyRWxSZWYsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhYmxlQ2xhc3NOYW1lOiAnZmMtY29sLWhlYWRlcicsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvd0NvbnRlbnQ6IGhlYWRlclJvd0NvbnRlbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHNlY3Rpb25zLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgdHlwZTogJ2JvZHknLFxyXG4gICAgICAgICAgICAgICAga2V5OiAnYm9keScsXHJcbiAgICAgICAgICAgICAgICBsaXF1aWQ6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBjaHVuazogeyBjb250ZW50OiBib2R5Q29udGVudCB9LFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuICh5KFZpZXdDb250YWluZXIsIHsgZWxDbGFzc2VzOiBbJ2ZjLWRheWdyaWQnXSwgdmlld1NwZWM6IGNvbnRleHQudmlld1NwZWMgfSxcclxuICAgICAgICAgICAgICAgIHkoU2ltcGxlU2Nyb2xsR3JpZCwgeyBsaXF1aWQ6ICFwcm9wcy5pc0hlaWdodEF1dG8gJiYgIXByb3BzLmZvclByaW50LCBjb2xsYXBzaWJsZVdpZHRoOiBwcm9wcy5mb3JQcmludCwgY29sczogW10gLyogVE9ETzogbWFrZSBvcHRpb25hbD8gKi8sIHNlY3Rpb25zOiBzZWN0aW9ucyB9KSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZW5kZXJIU2Nyb2xsTGF5b3V0KGhlYWRlclJvd0NvbnRlbnQsIGJvZHlDb250ZW50LCBjb2xDbnQsIGRheU1pbldpZHRoKSB7XHJcbiAgICAgICAgICAgIGxldCBTY3JvbGxHcmlkID0gdGhpcy5jb250ZXh0LnBsdWdpbkhvb2tzLnNjcm9sbEdyaWRJbXBsO1xyXG4gICAgICAgICAgICBpZiAoIVNjcm9sbEdyaWQpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gU2Nyb2xsR3JpZCBpbXBsZW1lbnRhdGlvbicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxldCB7IHByb3BzLCBjb250ZXh0IH0gPSB0aGlzO1xyXG4gICAgICAgICAgICBsZXQgc3RpY2t5SGVhZGVyRGF0ZXMgPSAhcHJvcHMuZm9yUHJpbnQgJiYgZ2V0U3RpY2t5SGVhZGVyRGF0ZXMoY29udGV4dC5vcHRpb25zKTtcclxuICAgICAgICAgICAgbGV0IHN0aWNreUZvb3RlclNjcm9sbGJhciA9ICFwcm9wcy5mb3JQcmludCAmJiBnZXRTdGlja3lGb290ZXJTY3JvbGxiYXIoY29udGV4dC5vcHRpb25zKTtcclxuICAgICAgICAgICAgbGV0IHNlY3Rpb25zID0gW107XHJcbiAgICAgICAgICAgIGlmIChoZWFkZXJSb3dDb250ZW50KSB7XHJcbiAgICAgICAgICAgICAgICBzZWN0aW9ucy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnaGVhZGVyJyxcclxuICAgICAgICAgICAgICAgICAgICBrZXk6ICdoZWFkZXInLFxyXG4gICAgICAgICAgICAgICAgICAgIGlzU3RpY2t5OiBzdGlja3lIZWFkZXJEYXRlcyxcclxuICAgICAgICAgICAgICAgICAgICBjaHVua3M6IFt7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXk6ICdtYWluJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsUmVmOiB0aGlzLmhlYWRlckVsUmVmLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFibGVDbGFzc05hbWU6ICdmYy1jb2wtaGVhZGVyJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvd0NvbnRlbnQ6IGhlYWRlclJvd0NvbnRlbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1dLFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc2VjdGlvbnMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiAnYm9keScsXHJcbiAgICAgICAgICAgICAgICBrZXk6ICdib2R5JyxcclxuICAgICAgICAgICAgICAgIGxpcXVpZDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGNodW5rczogW3tcclxuICAgICAgICAgICAgICAgICAgICAgICAga2V5OiAnbWFpbicsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IGJvZHlDb250ZW50LFxyXG4gICAgICAgICAgICAgICAgICAgIH1dLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgaWYgKHN0aWNreUZvb3RlclNjcm9sbGJhcikge1xyXG4gICAgICAgICAgICAgICAgc2VjdGlvbnMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2Zvb3RlcicsXHJcbiAgICAgICAgICAgICAgICAgICAga2V5OiAnZm9vdGVyJyxcclxuICAgICAgICAgICAgICAgICAgICBpc1N0aWNreTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICBjaHVua3M6IFt7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXk6ICdtYWluJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHJlbmRlclNjcm9sbFNoaW0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1dLFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuICh5KFZpZXdDb250YWluZXIsIHsgZWxDbGFzc2VzOiBbJ2ZjLWRheWdyaWQnXSwgdmlld1NwZWM6IGNvbnRleHQudmlld1NwZWMgfSxcclxuICAgICAgICAgICAgICAgIHkoU2Nyb2xsR3JpZCwgeyBsaXF1aWQ6ICFwcm9wcy5pc0hlaWdodEF1dG8gJiYgIXByb3BzLmZvclByaW50LCBmb3JQcmludDogcHJvcHMuZm9yUHJpbnQsIGNvbGxhcHNpYmxlV2lkdGg6IHByb3BzLmZvclByaW50LCBjb2xHcm91cHM6IFt7IGNvbHM6IFt7IHNwYW46IGNvbENudCwgbWluV2lkdGg6IGRheU1pbldpZHRoIH1dIH1dLCBzZWN0aW9uczogc2VjdGlvbnMgfSkpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY2xhc3MgRGF5VGFibGVWaWV3IGV4dGVuZHMgVGFibGVWaWV3IHtcclxuICAgICAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgdGhpcy5idWlsZERheVRhYmxlTW9kZWwgPSBtZW1vaXplKGJ1aWxkRGF5VGFibGVNb2RlbCk7XHJcbiAgICAgICAgICAgIHRoaXMuaGVhZGVyUmVmID0gZCgpO1xyXG4gICAgICAgICAgICB0aGlzLnRhYmxlUmVmID0gZCgpO1xyXG4gICAgICAgICAgICAvLyBjYW4ndCBvdmVycmlkZSBhbnkgbGlmZWN5Y2xlIG1ldGhvZHMgZnJvbSBwYXJlbnRcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVuZGVyKCkge1xyXG4gICAgICAgICAgICBsZXQgeyBvcHRpb25zLCBkYXRlUHJvZmlsZUdlbmVyYXRvciB9ID0gdGhpcy5jb250ZXh0O1xyXG4gICAgICAgICAgICBsZXQgeyBwcm9wcyB9ID0gdGhpcztcclxuICAgICAgICAgICAgbGV0IGRheVRhYmxlTW9kZWwgPSB0aGlzLmJ1aWxkRGF5VGFibGVNb2RlbChwcm9wcy5kYXRlUHJvZmlsZSwgZGF0ZVByb2ZpbGVHZW5lcmF0b3IpO1xyXG4gICAgICAgICAgICBsZXQgaGVhZGVyQ29udGVudCA9IG9wdGlvbnMuZGF5SGVhZGVycyAmJiAoeShEYXlIZWFkZXIsIHsgcmVmOiB0aGlzLmhlYWRlclJlZiwgZGF0ZVByb2ZpbGU6IHByb3BzLmRhdGVQcm9maWxlLCBkYXRlczogZGF5VGFibGVNb2RlbC5oZWFkZXJEYXRlcywgZGF0ZXNSZXBEaXN0aW5jdERheXM6IGRheVRhYmxlTW9kZWwucm93Q250ID09PSAxIH0pKTtcclxuICAgICAgICAgICAgbGV0IGJvZHlDb250ZW50ID0gKGNvbnRlbnRBcmcpID0+ICh5KERheVRhYmxlLCB7IHJlZjogdGhpcy50YWJsZVJlZiwgZGF0ZVByb2ZpbGU6IHByb3BzLmRhdGVQcm9maWxlLCBkYXlUYWJsZU1vZGVsOiBkYXlUYWJsZU1vZGVsLCBidXNpbmVzc0hvdXJzOiBwcm9wcy5idXNpbmVzc0hvdXJzLCBkYXRlU2VsZWN0aW9uOiBwcm9wcy5kYXRlU2VsZWN0aW9uLCBldmVudFN0b3JlOiBwcm9wcy5ldmVudFN0b3JlLCBldmVudFVpQmFzZXM6IHByb3BzLmV2ZW50VWlCYXNlcywgZXZlbnRTZWxlY3Rpb246IHByb3BzLmV2ZW50U2VsZWN0aW9uLCBldmVudERyYWc6IHByb3BzLmV2ZW50RHJhZywgZXZlbnRSZXNpemU6IHByb3BzLmV2ZW50UmVzaXplLCBuZXh0RGF5VGhyZXNob2xkOiBvcHRpb25zLm5leHREYXlUaHJlc2hvbGQsIGNvbEdyb3VwTm9kZTogY29udGVudEFyZy50YWJsZUNvbEdyb3VwTm9kZSwgdGFibGVNaW5XaWR0aDogY29udGVudEFyZy50YWJsZU1pbldpZHRoLCBkYXlNYXhFdmVudHM6IG9wdGlvbnMuZGF5TWF4RXZlbnRzLCBkYXlNYXhFdmVudFJvd3M6IG9wdGlvbnMuZGF5TWF4RXZlbnRSb3dzLCBzaG93V2Vla051bWJlcnM6IG9wdGlvbnMud2Vla051bWJlcnMsIGV4cGFuZFJvd3M6ICFwcm9wcy5pc0hlaWdodEF1dG8sIGhlYWRlckFsaWduRWxSZWY6IHRoaXMuaGVhZGVyRWxSZWYsIGNsaWVudFdpZHRoOiBjb250ZW50QXJnLmNsaWVudFdpZHRoLCBjbGllbnRIZWlnaHQ6IGNvbnRlbnRBcmcuY2xpZW50SGVpZ2h0LCBmb3JQcmludDogcHJvcHMuZm9yUHJpbnQgfSkpO1xyXG4gICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5kYXlNaW5XaWR0aFxyXG4gICAgICAgICAgICAgICAgPyB0aGlzLnJlbmRlckhTY3JvbGxMYXlvdXQoaGVhZGVyQ29udGVudCwgYm9keUNvbnRlbnQsIGRheVRhYmxlTW9kZWwuY29sQ250LCBvcHRpb25zLmRheU1pbldpZHRoKVxyXG4gICAgICAgICAgICAgICAgOiB0aGlzLnJlbmRlclNpbXBsZUxheW91dChoZWFkZXJDb250ZW50LCBib2R5Q29udGVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYnVpbGREYXlUYWJsZU1vZGVsKGRhdGVQcm9maWxlLCBkYXRlUHJvZmlsZUdlbmVyYXRvcikge1xyXG4gICAgICAgIGxldCBkYXlTZXJpZXMgPSBuZXcgRGF5U2VyaWVzTW9kZWwoZGF0ZVByb2ZpbGUucmVuZGVyUmFuZ2UsIGRhdGVQcm9maWxlR2VuZXJhdG9yKTtcclxuICAgICAgICByZXR1cm4gbmV3IERheVRhYmxlTW9kZWwoZGF5U2VyaWVzLCAveWVhcnxtb250aHx3ZWVrLy50ZXN0KGRhdGVQcm9maWxlLmN1cnJlbnRSYW5nZVVuaXQpKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgaW5kZXgkMyA9IGNyZWF0ZVBsdWdpbih7XHJcbiAgICAgICAgbmFtZTogJ0BmdWxsY2FsZW5kYXIvZGF5Z3JpZCcsXHJcbiAgICAgICAgaW5pdGlhbFZpZXc6ICdkYXlHcmlkTW9udGgnLFxyXG4gICAgICAgIHZpZXdzOiB7XHJcbiAgICAgICAgICAgIGRheUdyaWQ6IHtcclxuICAgICAgICAgICAgICAgIGNvbXBvbmVudDogRGF5VGFibGVWaWV3LFxyXG4gICAgICAgICAgICAgICAgZGF0ZVByb2ZpbGVHZW5lcmF0b3JDbGFzczogVGFibGVEYXRlUHJvZmlsZUdlbmVyYXRvcixcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZGF5R3JpZERheToge1xyXG4gICAgICAgICAgICAgICAgdHlwZTogJ2RheUdyaWQnLFxyXG4gICAgICAgICAgICAgICAgZHVyYXRpb246IHsgZGF5czogMSB9LFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBkYXlHcmlkV2Vlazoge1xyXG4gICAgICAgICAgICAgICAgdHlwZTogJ2RheUdyaWQnLFxyXG4gICAgICAgICAgICAgICAgZHVyYXRpb246IHsgd2Vla3M6IDEgfSxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZGF5R3JpZE1vbnRoOiB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiAnZGF5R3JpZCcsXHJcbiAgICAgICAgICAgICAgICBkdXJhdGlvbjogeyBtb250aHM6IDEgfSxcclxuICAgICAgICAgICAgICAgIGZpeGVkV2Vla0NvdW50OiB0cnVlLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBkYXlHcmlkWWVhcjoge1xyXG4gICAgICAgICAgICAgICAgdHlwZTogJ2RheUdyaWQnLFxyXG4gICAgICAgICAgICAgICAgZHVyYXRpb246IHsgeWVhcnM6IDEgfSxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9LFxyXG4gICAgfSk7XHJcblxyXG4gICAgdmFyIGNzc18yNDh6JDIgPSBcIi5mYy12LWV2ZW50e2JhY2tncm91bmQtY29sb3I6dmFyKC0tZmMtZXZlbnQtYmctY29sb3IpO2JvcmRlcjoxcHggc29saWQgdmFyKC0tZmMtZXZlbnQtYm9yZGVyLWNvbG9yKTtkaXNwbGF5OmJsb2NrfS5mYy12LWV2ZW50IC5mYy1ldmVudC1tYWlue2NvbG9yOnZhcigtLWZjLWV2ZW50LXRleHQtY29sb3IpO2hlaWdodDoxMDAlfS5mYy12LWV2ZW50IC5mYy1ldmVudC1tYWluLWZyYW1le2Rpc3BsYXk6ZmxleDtmbGV4LWRpcmVjdGlvbjpjb2x1bW47aGVpZ2h0OjEwMCV9LmZjLXYtZXZlbnQgLmZjLWV2ZW50LXRpbWV7ZmxleC1ncm93OjA7ZmxleC1zaHJpbms6MDttYXgtaGVpZ2h0OjEwMCU7b3ZlcmZsb3c6aGlkZGVufS5mYy12LWV2ZW50IC5mYy1ldmVudC10aXRsZS1jb250YWluZXJ7ZmxleC1ncm93OjE7ZmxleC1zaHJpbms6MTttaW4taGVpZ2h0OjB9LmZjLXYtZXZlbnQgLmZjLWV2ZW50LXRpdGxle2JvdHRvbTowO21heC1oZWlnaHQ6MTAwJTtvdmVyZmxvdzpoaWRkZW47dG9wOjB9LmZjLXYtZXZlbnQ6bm90KC5mYy1ldmVudC1zdGFydCl7Ym9yZGVyLXRvcC1sZWZ0LXJhZGl1czowO2JvcmRlci10b3AtcmlnaHQtcmFkaXVzOjA7Ym9yZGVyLXRvcC13aWR0aDowfS5mYy12LWV2ZW50Om5vdCguZmMtZXZlbnQtZW5kKXtib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOjA7Ym9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6MDtib3JkZXItYm90dG9tLXdpZHRoOjB9LmZjLXYtZXZlbnQuZmMtZXZlbnQtc2VsZWN0ZWQ6YmVmb3Jle2xlZnQ6LTEwcHg7cmlnaHQ6LTEwcHh9LmZjLXYtZXZlbnQgLmZjLWV2ZW50LXJlc2l6ZXItc3RhcnR7Y3Vyc29yOm4tcmVzaXplfS5mYy12LWV2ZW50IC5mYy1ldmVudC1yZXNpemVyLWVuZHtjdXJzb3I6cy1yZXNpemV9LmZjLXYtZXZlbnQ6bm90KC5mYy1ldmVudC1zZWxlY3RlZCkgLmZjLWV2ZW50LXJlc2l6ZXJ7aGVpZ2h0OnZhcigtLWZjLWV2ZW50LXJlc2l6ZXItdGhpY2tuZXNzKTtsZWZ0OjA7cmlnaHQ6MH0uZmMtdi1ldmVudDpub3QoLmZjLWV2ZW50LXNlbGVjdGVkKSAuZmMtZXZlbnQtcmVzaXplci1zdGFydHt0b3A6Y2FsYyh2YXIoLS1mYy1ldmVudC1yZXNpemVyLXRoaWNrbmVzcykvLTIpfS5mYy12LWV2ZW50Om5vdCguZmMtZXZlbnQtc2VsZWN0ZWQpIC5mYy1ldmVudC1yZXNpemVyLWVuZHtib3R0b206Y2FsYyh2YXIoLS1mYy1ldmVudC1yZXNpemVyLXRoaWNrbmVzcykvLTIpfS5mYy12LWV2ZW50LmZjLWV2ZW50LXNlbGVjdGVkIC5mYy1ldmVudC1yZXNpemVye2xlZnQ6NTAlO21hcmdpbi1sZWZ0OmNhbGModmFyKC0tZmMtZXZlbnQtcmVzaXplci1kb3QtdG90YWwtd2lkdGgpLy0yKX0uZmMtdi1ldmVudC5mYy1ldmVudC1zZWxlY3RlZCAuZmMtZXZlbnQtcmVzaXplci1zdGFydHt0b3A6Y2FsYyh2YXIoLS1mYy1ldmVudC1yZXNpemVyLWRvdC10b3RhbC13aWR0aCkvLTIpfS5mYy12LWV2ZW50LmZjLWV2ZW50LXNlbGVjdGVkIC5mYy1ldmVudC1yZXNpemVyLWVuZHtib3R0b206Y2FsYyh2YXIoLS1mYy1ldmVudC1yZXNpemVyLWRvdC10b3RhbC13aWR0aCkvLTIpfS5mYyAuZmMtdGltZWdyaWQgLmZjLWRheWdyaWQtYm9keXt6LWluZGV4OjJ9LmZjIC5mYy10aW1lZ3JpZC1kaXZpZGVye3BhZGRpbmc6MCAwIDJweH0uZmMgLmZjLXRpbWVncmlkLWJvZHl7bWluLWhlaWdodDoxMDAlO3Bvc2l0aW9uOnJlbGF0aXZlO3otaW5kZXg6MX0uZmMgLmZjLXRpbWVncmlkLWF4aXMtY2h1bmt7cG9zaXRpb246cmVsYXRpdmV9LmZjIC5mYy10aW1lZ3JpZC1heGlzLWNodW5rPnRhYmxlLC5mYyAuZmMtdGltZWdyaWQtc2xvdHN7cG9zaXRpb246cmVsYXRpdmU7ei1pbmRleDoxfS5mYyAuZmMtdGltZWdyaWQtc2xvdHtib3JkZXItYm90dG9tOjA7aGVpZ2h0OjEuNWVtfS5mYyAuZmMtdGltZWdyaWQtc2xvdDplbXB0eTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXDAwYTBcXFwifS5mYyAuZmMtdGltZWdyaWQtc2xvdC1taW5vcntib3JkZXItdG9wLXN0eWxlOmRvdHRlZH0uZmMgLmZjLXRpbWVncmlkLXNsb3QtbGFiZWwtY3VzaGlvbntkaXNwbGF5OmlubGluZS1ibG9jazt3aGl0ZS1zcGFjZTpub3dyYXB9LmZjIC5mYy10aW1lZ3JpZC1zbG90LWxhYmVse3ZlcnRpY2FsLWFsaWduOm1pZGRsZX0uZmMgLmZjLXRpbWVncmlkLWF4aXMtY3VzaGlvbiwuZmMgLmZjLXRpbWVncmlkLXNsb3QtbGFiZWwtY3VzaGlvbntwYWRkaW5nOjAgNHB4fS5mYyAuZmMtdGltZWdyaWQtYXhpcy1mcmFtZS1saXF1aWR7aGVpZ2h0OjEwMCV9LmZjIC5mYy10aW1lZ3JpZC1heGlzLWZyYW1le2FsaWduLWl0ZW1zOmNlbnRlcjtkaXNwbGF5OmZsZXg7anVzdGlmeS1jb250ZW50OmZsZXgtZW5kO292ZXJmbG93OmhpZGRlbn0uZmMgLmZjLXRpbWVncmlkLWF4aXMtY3VzaGlvbntmbGV4LXNocmluazowO21heC13aWR0aDo2MHB4fS5mYy1kaXJlY3Rpb24tbHRyIC5mYy10aW1lZ3JpZC1zbG90LWxhYmVsLWZyYW1le3RleHQtYWxpZ246cmlnaHR9LmZjLWRpcmVjdGlvbi1ydGwgLmZjLXRpbWVncmlkLXNsb3QtbGFiZWwtZnJhbWV7dGV4dC1hbGlnbjpsZWZ0fS5mYy1saXF1aWQtaGFjayAuZmMtdGltZWdyaWQtYXhpcy1mcmFtZS1saXF1aWR7Ym90dG9tOjA7aGVpZ2h0OmF1dG87bGVmdDowO3Bvc2l0aW9uOmFic29sdXRlO3JpZ2h0OjA7dG9wOjB9LmZjIC5mYy10aW1lZ3JpZC1jb2wuZmMtZGF5LXRvZGF5e2JhY2tncm91bmQtY29sb3I6dmFyKC0tZmMtdG9kYXktYmctY29sb3IpfS5mYyAuZmMtdGltZWdyaWQtY29sLWZyYW1le21pbi1oZWlnaHQ6MTAwJTtwb3NpdGlvbjpyZWxhdGl2ZX0uZmMtbWVkaWEtc2NyZWVuLmZjLWxpcXVpZC1oYWNrIC5mYy10aW1lZ3JpZC1jb2wtZnJhbWV7Ym90dG9tOjA7aGVpZ2h0OmF1dG87bGVmdDowO3Bvc2l0aW9uOmFic29sdXRlO3JpZ2h0OjA7dG9wOjB9LmZjLW1lZGlhLXNjcmVlbiAuZmMtdGltZWdyaWQtY29sc3tib3R0b206MDtsZWZ0OjA7cG9zaXRpb246YWJzb2x1dGU7cmlnaHQ6MDt0b3A6MH0uZmMtbWVkaWEtc2NyZWVuIC5mYy10aW1lZ3JpZC1jb2xzPnRhYmxle2hlaWdodDoxMDAlfS5mYy1tZWRpYS1zY3JlZW4gLmZjLXRpbWVncmlkLWNvbC1iZywuZmMtbWVkaWEtc2NyZWVuIC5mYy10aW1lZ3JpZC1jb2wtZXZlbnRzLC5mYy1tZWRpYS1zY3JlZW4gLmZjLXRpbWVncmlkLW5vdy1pbmRpY2F0b3ItY29udGFpbmVye2xlZnQ6MDtwb3NpdGlvbjphYnNvbHV0ZTtyaWdodDowO3RvcDowfS5mYyAuZmMtdGltZWdyaWQtY29sLWJne3otaW5kZXg6Mn0uZmMgLmZjLXRpbWVncmlkLWNvbC1iZyAuZmMtbm9uLWJ1c2luZXNze3otaW5kZXg6MX0uZmMgLmZjLXRpbWVncmlkLWNvbC1iZyAuZmMtYmctZXZlbnR7ei1pbmRleDoyfS5mYyAuZmMtdGltZWdyaWQtY29sLWJnIC5mYy1oaWdobGlnaHR7ei1pbmRleDozfS5mYyAuZmMtdGltZWdyaWQtYmctaGFybmVzc3tsZWZ0OjA7cG9zaXRpb246YWJzb2x1dGU7cmlnaHQ6MH0uZmMgLmZjLXRpbWVncmlkLWNvbC1ldmVudHN7ei1pbmRleDozfS5mYyAuZmMtdGltZWdyaWQtbm93LWluZGljYXRvci1jb250YWluZXJ7Ym90dG9tOjA7b3ZlcmZsb3c6aGlkZGVufS5mYy1kaXJlY3Rpb24tbHRyIC5mYy10aW1lZ3JpZC1jb2wtZXZlbnRze21hcmdpbjowIDIuNSUgMCAycHh9LmZjLWRpcmVjdGlvbi1ydGwgLmZjLXRpbWVncmlkLWNvbC1ldmVudHN7bWFyZ2luOjAgMnB4IDAgMi41JX0uZmMtdGltZWdyaWQtZXZlbnQtaGFybmVzc3twb3NpdGlvbjphYnNvbHV0ZX0uZmMtdGltZWdyaWQtZXZlbnQtaGFybmVzcz4uZmMtdGltZWdyaWQtZXZlbnR7Ym90dG9tOjA7bGVmdDowO3Bvc2l0aW9uOmFic29sdXRlO3JpZ2h0OjA7dG9wOjB9LmZjLXRpbWVncmlkLWV2ZW50LWhhcm5lc3MtaW5zZXQgLmZjLXRpbWVncmlkLWV2ZW50LC5mYy10aW1lZ3JpZC1ldmVudC5mYy1ldmVudC1taXJyb3IsLmZjLXRpbWVncmlkLW1vcmUtbGlua3tib3gtc2hhZG93OjAgMCAwIDFweCB2YXIoLS1mYy1wYWdlLWJnLWNvbG9yKX0uZmMtdGltZWdyaWQtZXZlbnQsLmZjLXRpbWVncmlkLW1vcmUtbGlua3tib3JkZXItcmFkaXVzOjNweDtmb250LXNpemU6dmFyKC0tZmMtc21hbGwtZm9udC1zaXplKX0uZmMtdGltZWdyaWQtZXZlbnR7bWFyZ2luLWJvdHRvbToxcHh9LmZjLXRpbWVncmlkLWV2ZW50IC5mYy1ldmVudC1tYWlue3BhZGRpbmc6MXB4IDFweCAwfS5mYy10aW1lZ3JpZC1ldmVudCAuZmMtZXZlbnQtdGltZXtmb250LXNpemU6dmFyKC0tZmMtc21hbGwtZm9udC1zaXplKTttYXJnaW4tYm90dG9tOjFweDt3aGl0ZS1zcGFjZTpub3dyYXB9LmZjLXRpbWVncmlkLWV2ZW50LXNob3J0IC5mYy1ldmVudC1tYWluLWZyYW1le2ZsZXgtZGlyZWN0aW9uOnJvdztvdmVyZmxvdzpoaWRkZW59LmZjLXRpbWVncmlkLWV2ZW50LXNob3J0IC5mYy1ldmVudC10aW1lOmFmdGVye2NvbnRlbnQ6XFxcIlxcXFwwMGEwLVxcXFwwMGEwXFxcIn0uZmMtdGltZWdyaWQtZXZlbnQtc2hvcnQgLmZjLWV2ZW50LXRpdGxle2ZvbnQtc2l6ZTp2YXIoLS1mYy1zbWFsbC1mb250LXNpemUpfS5mYy10aW1lZ3JpZC1tb3JlLWxpbmt7YmFja2dyb3VuZDp2YXIoLS1mYy1tb3JlLWxpbmstYmctY29sb3IpO2NvbG9yOnZhcigtLWZjLW1vcmUtbGluay10ZXh0LWNvbG9yKTtjdXJzb3I6cG9pbnRlcjttYXJnaW4tYm90dG9tOjFweDtwb3NpdGlvbjphYnNvbHV0ZTt6LWluZGV4Ojk5OTl9LmZjLXRpbWVncmlkLW1vcmUtbGluay1pbm5lcntwYWRkaW5nOjNweCAycHg7dG9wOjB9LmZjLWRpcmVjdGlvbi1sdHIgLmZjLXRpbWVncmlkLW1vcmUtbGlua3tyaWdodDowfS5mYy1kaXJlY3Rpb24tcnRsIC5mYy10aW1lZ3JpZC1tb3JlLWxpbmt7bGVmdDowfS5mYyAuZmMtdGltZWdyaWQtbm93LWluZGljYXRvci1saW5le2JvcmRlci1jb2xvcjp2YXIoLS1mYy1ub3ctaW5kaWNhdG9yLWNvbG9yKTtib3JkZXItc3R5bGU6c29saWQ7Ym9yZGVyLXdpZHRoOjFweCAwIDA7bGVmdDowO3Bvc2l0aW9uOmFic29sdXRlO3JpZ2h0OjA7ei1pbmRleDo0fS5mYyAuZmMtdGltZWdyaWQtbm93LWluZGljYXRvci1hcnJvd3tib3JkZXItY29sb3I6dmFyKC0tZmMtbm93LWluZGljYXRvci1jb2xvcik7Ym9yZGVyLXN0eWxlOnNvbGlkO21hcmdpbi10b3A6LTVweDtwb3NpdGlvbjphYnNvbHV0ZTt6LWluZGV4OjR9LmZjLWRpcmVjdGlvbi1sdHIgLmZjLXRpbWVncmlkLW5vdy1pbmRpY2F0b3ItYXJyb3d7Ym9yZGVyLWJvdHRvbS1jb2xvcjp0cmFuc3BhcmVudDtib3JkZXItdG9wLWNvbG9yOnRyYW5zcGFyZW50O2JvcmRlci13aWR0aDo1cHggMCA1cHggNnB4O2xlZnQ6MH0uZmMtZGlyZWN0aW9uLXJ0bCAuZmMtdGltZWdyaWQtbm93LWluZGljYXRvci1hcnJvd3tib3JkZXItYm90dG9tLWNvbG9yOnRyYW5zcGFyZW50O2JvcmRlci10b3AtY29sb3I6dHJhbnNwYXJlbnQ7Ym9yZGVyLXdpZHRoOjVweCA2cHggNXB4IDA7cmlnaHQ6MH1cIjtcclxuICAgIGluamVjdFN0eWxlcyhjc3NfMjQ4eiQyKTtcclxuXHJcbiAgICBjbGFzcyBBbGxEYXlTcGxpdHRlciBleHRlbmRzIFNwbGl0dGVyIHtcclxuICAgICAgICBnZXRLZXlJbmZvKCkge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgYWxsRGF5OiB7fSxcclxuICAgICAgICAgICAgICAgIHRpbWVkOiB7fSxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZ2V0S2V5c0ZvckRhdGVTcGFuKGRhdGVTcGFuKSB7XHJcbiAgICAgICAgICAgIGlmIChkYXRlU3Bhbi5hbGxEYXkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBbJ2FsbERheSddO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBbJ3RpbWVkJ107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGdldEtleXNGb3JFdmVudERlZihldmVudERlZikge1xyXG4gICAgICAgICAgICBpZiAoIWV2ZW50RGVmLmFsbERheSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFsndGltZWQnXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoaGFzQmdSZW5kZXJpbmcoZXZlbnREZWYpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gWyd0aW1lZCcsICdhbGxEYXknXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gWydhbGxEYXknXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgREVGQVVMVF9TTEFUX0xBQkVMX0ZPUk1BVCA9IGNyZWF0ZUZvcm1hdHRlcih7XHJcbiAgICAgICAgaG91cjogJ251bWVyaWMnLFxyXG4gICAgICAgIG1pbnV0ZTogJzItZGlnaXQnLFxyXG4gICAgICAgIG9taXRaZXJvTWludXRlOiB0cnVlLFxyXG4gICAgICAgIG1lcmlkaWVtOiAnc2hvcnQnLFxyXG4gICAgfSk7XHJcbiAgICBmdW5jdGlvbiBUaW1lQ29sc0F4aXNDZWxsKHByb3BzKSB7XHJcbiAgICAgICAgbGV0IGNsYXNzTmFtZXMgPSBbXHJcbiAgICAgICAgICAgICdmYy10aW1lZ3JpZC1zbG90JyxcclxuICAgICAgICAgICAgJ2ZjLXRpbWVncmlkLXNsb3QtbGFiZWwnLFxyXG4gICAgICAgICAgICBwcm9wcy5pc0xhYmVsZWQgPyAnZmMtc2Nyb2xsZ3JpZC1zaHJpbmsnIDogJ2ZjLXRpbWVncmlkLXNsb3QtbWlub3InLFxyXG4gICAgICAgIF07XHJcbiAgICAgICAgcmV0dXJuICh5KFZpZXdDb250ZXh0VHlwZS5Db25zdW1lciwgbnVsbCwgKGNvbnRleHQpID0+IHtcclxuICAgICAgICAgICAgaWYgKCFwcm9wcy5pc0xhYmVsZWQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAoeShcInRkXCIsIHsgY2xhc3NOYW1lOiBjbGFzc05hbWVzLmpvaW4oJyAnKSwgXCJkYXRhLXRpbWVcIjogcHJvcHMuaXNvVGltZVN0ciB9KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IHsgZGF0ZUVudiwgb3B0aW9ucywgdmlld0FwaSB9ID0gY29udGV4dDtcclxuICAgICAgICAgICAgbGV0IGxhYmVsRm9ybWF0ID0gLy8gVE9ETzogZnVsbHkgcHJlLXBhcnNlXHJcbiAgICAgICAgICAgICBvcHRpb25zLnNsb3RMYWJlbEZvcm1hdCA9PSBudWxsID8gREVGQVVMVF9TTEFUX0xBQkVMX0ZPUk1BVCA6XHJcbiAgICAgICAgICAgICAgICBBcnJheS5pc0FycmF5KG9wdGlvbnMuc2xvdExhYmVsRm9ybWF0KSA/IGNyZWF0ZUZvcm1hdHRlcihvcHRpb25zLnNsb3RMYWJlbEZvcm1hdFswXSkgOlxyXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZUZvcm1hdHRlcihvcHRpb25zLnNsb3RMYWJlbEZvcm1hdCk7XHJcbiAgICAgICAgICAgIGxldCByZW5kZXJQcm9wcyA9IHtcclxuICAgICAgICAgICAgICAgIGxldmVsOiAwLFxyXG4gICAgICAgICAgICAgICAgdGltZTogcHJvcHMudGltZSxcclxuICAgICAgICAgICAgICAgIGRhdGU6IGRhdGVFbnYudG9EYXRlKHByb3BzLmRhdGUpLFxyXG4gICAgICAgICAgICAgICAgdmlldzogdmlld0FwaSxcclxuICAgICAgICAgICAgICAgIHRleHQ6IGRhdGVFbnYuZm9ybWF0KHByb3BzLmRhdGUsIGxhYmVsRm9ybWF0KSxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuICh5KENvbnRlbnRDb250YWluZXIsIHsgZWxUYWc6IFwidGRcIiwgZWxDbGFzc2VzOiBjbGFzc05hbWVzLCBlbEF0dHJzOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgJ2RhdGEtdGltZSc6IHByb3BzLmlzb1RpbWVTdHIsXHJcbiAgICAgICAgICAgICAgICB9LCByZW5kZXJQcm9wczogcmVuZGVyUHJvcHMsIGdlbmVyYXRvck5hbWU6IFwic2xvdExhYmVsQ29udGVudFwiLCBjdXN0b21HZW5lcmF0b3I6IG9wdGlvbnMuc2xvdExhYmVsQ29udGVudCwgZGVmYXVsdEdlbmVyYXRvcjogcmVuZGVySW5uZXJDb250ZW50JDEsIGNsYXNzTmFtZUdlbmVyYXRvcjogb3B0aW9ucy5zbG90TGFiZWxDbGFzc05hbWVzLCBkaWRNb3VudDogb3B0aW9ucy5zbG90TGFiZWxEaWRNb3VudCwgd2lsbFVubW91bnQ6IG9wdGlvbnMuc2xvdExhYmVsV2lsbFVubW91bnQgfSwgKElubmVyQ29udGVudCkgPT4gKHkoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtdGltZWdyaWQtc2xvdC1sYWJlbC1mcmFtZSBmYy1zY3JvbGxncmlkLXNocmluay1mcmFtZVwiIH0sXHJcbiAgICAgICAgICAgICAgICB5KElubmVyQ29udGVudCwgeyBlbFRhZzogXCJkaXZcIiwgZWxDbGFzc2VzOiBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdmYy10aW1lZ3JpZC1zbG90LWxhYmVsLWN1c2hpb24nLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAnZmMtc2Nyb2xsZ3JpZC1zaHJpbmstY3VzaGlvbicsXHJcbiAgICAgICAgICAgICAgICAgICAgXSB9KSkpKSk7XHJcbiAgICAgICAgfSkpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gcmVuZGVySW5uZXJDb250ZW50JDEocHJvcHMpIHtcclxuICAgICAgICByZXR1cm4gcHJvcHMudGV4dDtcclxuICAgIH1cclxuXHJcbiAgICBjbGFzcyBUaW1lQm9keUF4aXMgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcclxuICAgICAgICByZW5kZXIoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb3BzLnNsYXRNZXRhcy5tYXAoKHNsYXRNZXRhKSA9PiAoeShcInRyXCIsIHsga2V5OiBzbGF0TWV0YS5rZXkgfSxcclxuICAgICAgICAgICAgICAgIHkoVGltZUNvbHNBeGlzQ2VsbCwgT2JqZWN0LmFzc2lnbih7fSwgc2xhdE1ldGEpKSkpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgREVGQVVMVF9XRUVLX05VTV9GT1JNQVQgPSBjcmVhdGVGb3JtYXR0ZXIoeyB3ZWVrOiAnc2hvcnQnIH0pO1xyXG4gICAgY29uc3QgQVVUT19BTExfREFZX01BWF9FVkVOVF9ST1dTID0gNTtcclxuICAgIGNsYXNzIFRpbWVDb2xzVmlldyBleHRlbmRzIERhdGVDb21wb25lbnQge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgICAgICB0aGlzLmFsbERheVNwbGl0dGVyID0gbmV3IEFsbERheVNwbGl0dGVyKCk7IC8vIGZvciB1c2UgYnkgc3ViY2xhc3Nlc1xyXG4gICAgICAgICAgICB0aGlzLmhlYWRlckVsUmVmID0gZCgpO1xyXG4gICAgICAgICAgICB0aGlzLnJvb3RFbFJlZiA9IGQoKTtcclxuICAgICAgICAgICAgdGhpcy5zY3JvbGxlckVsUmVmID0gZCgpO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0ge1xyXG4gICAgICAgICAgICAgICAgc2xhdENvb3JkczogbnVsbCxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdGhpcy5oYW5kbGVTY3JvbGxUb3BSZXF1ZXN0ID0gKHNjcm9sbFRvcCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgbGV0IHNjcm9sbGVyRWwgPSB0aGlzLnNjcm9sbGVyRWxSZWYuY3VycmVudDtcclxuICAgICAgICAgICAgICAgIGlmIChzY3JvbGxlckVsKSB7IC8vIFRPRE86IG5vdCBzdXJlIGhvdyB0aGlzIGNvdWxkIGV2ZXIgYmUgbnVsbC4gd2VpcmRuZXNzIHdpdGggdGhlIHJlZHVjZXJcclxuICAgICAgICAgICAgICAgICAgICBzY3JvbGxlckVsLnNjcm9sbFRvcCA9IHNjcm9sbFRvcDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyogSGVhZGVyIFJlbmRlciBNZXRob2RzXHJcbiAgICAgICAgICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVySGVhZEF4aXMgPSAocm93S2V5LCBmcmFtZUhlaWdodCA9ICcnKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBsZXQgeyBvcHRpb25zIH0gPSB0aGlzLmNvbnRleHQ7XHJcbiAgICAgICAgICAgICAgICBsZXQgeyBkYXRlUHJvZmlsZSB9ID0gdGhpcy5wcm9wcztcclxuICAgICAgICAgICAgICAgIGxldCByYW5nZSA9IGRhdGVQcm9maWxlLnJlbmRlclJhbmdlO1xyXG4gICAgICAgICAgICAgICAgbGV0IGRheUNudCA9IGRpZmZEYXlzKHJhbmdlLnN0YXJ0LCByYW5nZS5lbmQpO1xyXG4gICAgICAgICAgICAgICAgLy8gb25seSBkbyBpbiBkYXkgdmlld3MgKHRvIGF2b2lkIGRvaW5nIGluIHdlZWsgdmlld3MgdGhhdCBkb250IG5lZWQgaXQpXHJcbiAgICAgICAgICAgICAgICBsZXQgbmF2TGlua0F0dHJzID0gKGRheUNudCA9PT0gMSlcclxuICAgICAgICAgICAgICAgICAgICA/IGJ1aWxkTmF2TGlua0F0dHJzKHRoaXMuY29udGV4dCwgcmFuZ2Uuc3RhcnQsICd3ZWVrJylcclxuICAgICAgICAgICAgICAgICAgICA6IHt9O1xyXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMud2Vla051bWJlcnMgJiYgcm93S2V5ID09PSAnZGF5Jykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoeShXZWVrTnVtYmVyQ29udGFpbmVyLCB7IGVsVGFnOiBcInRoXCIsIGVsQ2xhc3NlczogW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2ZjLXRpbWVncmlkLWF4aXMnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2ZjLXNjcm9sbGdyaWQtc2hyaW5rJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgXSwgZWxBdHRyczoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2FyaWEtaGlkZGVuJzogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgZGF0ZTogcmFuZ2Uuc3RhcnQsIGRlZmF1bHRGb3JtYXQ6IERFRkFVTFRfV0VFS19OVU1fRk9STUFUIH0sIChJbm5lckNvbnRlbnQpID0+ICh5KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZmMtdGltZWdyaWQtYXhpcy1mcmFtZScsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZmMtc2Nyb2xsZ3JpZC1zaHJpbmstZnJhbWUnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2ZjLXRpbWVncmlkLWF4aXMtZnJhbWUtbGlxdWlkJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgXS5qb2luKCcgJyksIHN0eWxlOiB7IGhlaWdodDogZnJhbWVIZWlnaHQgfSB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB5KElubmVyQ29udGVudCwgeyBlbFRhZzogXCJhXCIsIGVsQ2xhc3NlczogW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdmYy10aW1lZ3JpZC1heGlzLWN1c2hpb24nLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdmYy1zY3JvbGxncmlkLXNocmluay1jdXNoaW9uJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZmMtc2Nyb2xsZ3JpZC1zeW5jLWlubmVyJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0sIGVsQXR0cnM6IG5hdkxpbmtBdHRycyB9KSkpKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKHkoXCJ0aFwiLCB7IFwiYXJpYS1oaWRkZW5cIjogdHJ1ZSwgY2xhc3NOYW1lOiBcImZjLXRpbWVncmlkLWF4aXNcIiB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHkoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtdGltZWdyaWQtYXhpcy1mcmFtZVwiLCBzdHlsZTogeyBoZWlnaHQ6IGZyYW1lSGVpZ2h0IH0gfSkpKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyogVGFibGUgQ29tcG9uZW50IFJlbmRlciBNZXRob2RzXHJcbiAgICAgICAgICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbiAgICAgICAgICAgIC8vIG9ubHkgYSBvbmUtd2F5IGhlaWdodCBzeW5jLiB3ZSBkb24ndCBzZW5kIHRoZSBheGlzIGlubmVyLWNvbnRlbnQgaGVpZ2h0IHRvIHRoZSBEYXlHcmlkLFxyXG4gICAgICAgICAgICAvLyBidXQgRGF5R3JpZCBzdGlsbCBuZWVkcyB0byBoYXZlIGNsYXNzTmFtZXMgb24gaW5uZXIgZWxlbWVudHMgaW4gb3JkZXIgdG8gbWVhc3VyZS5cclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJUYWJsZVJvd0F4aXMgPSAocm93SGVpZ2h0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBsZXQgeyBvcHRpb25zLCB2aWV3QXBpIH0gPSB0aGlzLmNvbnRleHQ7XHJcbiAgICAgICAgICAgICAgICBsZXQgcmVuZGVyUHJvcHMgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogb3B0aW9ucy5hbGxEYXlUZXh0LFxyXG4gICAgICAgICAgICAgICAgICAgIHZpZXc6IHZpZXdBcGksXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgICAgIC8vIFRPRE86IG1ha2UgcmV1c2FibGUgaG9vay4gdXNlZCBpbiBsaXN0IHZpZXcgdG9vXHJcbiAgICAgICAgICAgICAgICB5KENvbnRlbnRDb250YWluZXIsIHsgZWxUYWc6IFwidGRcIiwgZWxDbGFzc2VzOiBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdmYy10aW1lZ3JpZC1heGlzJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ2ZjLXNjcm9sbGdyaWQtc2hyaW5rJyxcclxuICAgICAgICAgICAgICAgICAgICBdLCBlbEF0dHJzOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdhcmlhLWhpZGRlbic6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgfSwgcmVuZGVyUHJvcHM6IHJlbmRlclByb3BzLCBnZW5lcmF0b3JOYW1lOiBcImFsbERheUNvbnRlbnRcIiwgY3VzdG9tR2VuZXJhdG9yOiBvcHRpb25zLmFsbERheUNvbnRlbnQsIGRlZmF1bHRHZW5lcmF0b3I6IHJlbmRlckFsbERheUlubmVyJDEsIGNsYXNzTmFtZUdlbmVyYXRvcjogb3B0aW9ucy5hbGxEYXlDbGFzc05hbWVzLCBkaWRNb3VudDogb3B0aW9ucy5hbGxEYXlEaWRNb3VudCwgd2lsbFVubW91bnQ6IG9wdGlvbnMuYWxsRGF5V2lsbFVubW91bnQgfSwgKElubmVyQ29udGVudCkgPT4gKHkoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ2ZjLXRpbWVncmlkLWF4aXMtZnJhbWUnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAnZmMtc2Nyb2xsZ3JpZC1zaHJpbmstZnJhbWUnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByb3dIZWlnaHQgPT0gbnVsbCA/ICcgZmMtdGltZWdyaWQtYXhpcy1mcmFtZS1saXF1aWQnIDogJycsXHJcbiAgICAgICAgICAgICAgICAgICAgXS5qb2luKCcgJyksIHN0eWxlOiB7IGhlaWdodDogcm93SGVpZ2h0IH0gfSxcclxuICAgICAgICAgICAgICAgICAgICB5KElubmVyQ29udGVudCwgeyBlbFRhZzogXCJzcGFuXCIsIGVsQ2xhc3NlczogW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2ZjLXRpbWVncmlkLWF4aXMtY3VzaGlvbicsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZmMtc2Nyb2xsZ3JpZC1zaHJpbmstY3VzaGlvbicsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZmMtc2Nyb2xsZ3JpZC1zeW5jLWlubmVyJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgXSB9KSkpKSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlU2xhdENvb3JkcyA9IChzbGF0Q29vcmRzKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKHsgc2xhdENvb3JkcyB9KTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gcmVuZGVyaW5nXHJcbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgICAgIHJlbmRlclNpbXBsZUxheW91dChoZWFkZXJSb3dDb250ZW50LCBhbGxEYXlDb250ZW50LCB0aW1lQ29udGVudCkge1xyXG4gICAgICAgICAgICBsZXQgeyBjb250ZXh0LCBwcm9wcyB9ID0gdGhpcztcclxuICAgICAgICAgICAgbGV0IHNlY3Rpb25zID0gW107XHJcbiAgICAgICAgICAgIGxldCBzdGlja3lIZWFkZXJEYXRlcyA9IGdldFN0aWNreUhlYWRlckRhdGVzKGNvbnRleHQub3B0aW9ucyk7XHJcbiAgICAgICAgICAgIGlmIChoZWFkZXJSb3dDb250ZW50KSB7XHJcbiAgICAgICAgICAgICAgICBzZWN0aW9ucy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnaGVhZGVyJyxcclxuICAgICAgICAgICAgICAgICAgICBrZXk6ICdoZWFkZXInLFxyXG4gICAgICAgICAgICAgICAgICAgIGlzU3RpY2t5OiBzdGlja3lIZWFkZXJEYXRlcyxcclxuICAgICAgICAgICAgICAgICAgICBjaHVuazoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbFJlZjogdGhpcy5oZWFkZXJFbFJlZixcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGFibGVDbGFzc05hbWU6ICdmYy1jb2wtaGVhZGVyJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcm93Q29udGVudDogaGVhZGVyUm93Q29udGVudCxcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGFsbERheUNvbnRlbnQpIHtcclxuICAgICAgICAgICAgICAgIHNlY3Rpb25zLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdib2R5JyxcclxuICAgICAgICAgICAgICAgICAgICBrZXk6ICdhbGwtZGF5JyxcclxuICAgICAgICAgICAgICAgICAgICBjaHVuazogeyBjb250ZW50OiBhbGxEYXlDb250ZW50IH0sXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHNlY3Rpb25zLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdib2R5JyxcclxuICAgICAgICAgICAgICAgICAgICBrZXk6ICdhbGwtZGF5LWRpdmlkZXInLFxyXG4gICAgICAgICAgICAgICAgICAgIG91dGVyQ29udGVudDogKCAvLyBUT0RPOiByZW5hbWUgdG8gY2VsbENvbnRlbnQgc28gZG9uJ3QgbmVlZCB0byBkZWZpbmUgPHRyPj9cclxuICAgICAgICAgICAgICAgICAgICB5KFwidHJcIiwgeyByb2xlOiBcInByZXNlbnRhdGlvblwiLCBjbGFzc05hbWU6IFwiZmMtc2Nyb2xsZ3JpZC1zZWN0aW9uXCIgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgeShcInRkXCIsIHsgY2xhc3NOYW1lOiAnZmMtdGltZWdyaWQtZGl2aWRlciAnICsgY29udGV4dC50aGVtZS5nZXRDbGFzcygndGFibGVDZWxsU2hhZGVkJykgfSkpKSxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHNlY3Rpb25zLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgdHlwZTogJ2JvZHknLFxyXG4gICAgICAgICAgICAgICAga2V5OiAnYm9keScsXHJcbiAgICAgICAgICAgICAgICBsaXF1aWQ6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBleHBhbmRSb3dzOiBCb29sZWFuKGNvbnRleHQub3B0aW9ucy5leHBhbmRSb3dzKSxcclxuICAgICAgICAgICAgICAgIGNodW5rOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsZXJFbFJlZjogdGhpcy5zY3JvbGxlckVsUmVmLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHRpbWVDb250ZW50LFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiAoeShWaWV3Q29udGFpbmVyLCB7IGVsUmVmOiB0aGlzLnJvb3RFbFJlZiwgZWxDbGFzc2VzOiBbJ2ZjLXRpbWVncmlkJ10sIHZpZXdTcGVjOiBjb250ZXh0LnZpZXdTcGVjIH0sXHJcbiAgICAgICAgICAgICAgICB5KFNpbXBsZVNjcm9sbEdyaWQsIHsgbGlxdWlkOiAhcHJvcHMuaXNIZWlnaHRBdXRvICYmICFwcm9wcy5mb3JQcmludCwgY29sbGFwc2libGVXaWR0aDogcHJvcHMuZm9yUHJpbnQsIGNvbHM6IFt7IHdpZHRoOiAnc2hyaW5rJyB9XSwgc2VjdGlvbnM6IHNlY3Rpb25zIH0pKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlbmRlckhTY3JvbGxMYXlvdXQoaGVhZGVyUm93Q29udGVudCwgYWxsRGF5Q29udGVudCwgdGltZUNvbnRlbnQsIGNvbENudCwgZGF5TWluV2lkdGgsIHNsYXRNZXRhcywgc2xhdENvb3Jkcykge1xyXG4gICAgICAgICAgICBsZXQgU2Nyb2xsR3JpZCA9IHRoaXMuY29udGV4dC5wbHVnaW5Ib29rcy5zY3JvbGxHcmlkSW1wbDtcclxuICAgICAgICAgICAgaWYgKCFTY3JvbGxHcmlkKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIFNjcm9sbEdyaWQgaW1wbGVtZW50YXRpb24nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgeyBjb250ZXh0LCBwcm9wcyB9ID0gdGhpcztcclxuICAgICAgICAgICAgbGV0IHN0aWNreUhlYWRlckRhdGVzID0gIXByb3BzLmZvclByaW50ICYmIGdldFN0aWNreUhlYWRlckRhdGVzKGNvbnRleHQub3B0aW9ucyk7XHJcbiAgICAgICAgICAgIGxldCBzdGlja3lGb290ZXJTY3JvbGxiYXIgPSAhcHJvcHMuZm9yUHJpbnQgJiYgZ2V0U3RpY2t5Rm9vdGVyU2Nyb2xsYmFyKGNvbnRleHQub3B0aW9ucyk7XHJcbiAgICAgICAgICAgIGxldCBzZWN0aW9ucyA9IFtdO1xyXG4gICAgICAgICAgICBpZiAoaGVhZGVyUm93Q29udGVudCkge1xyXG4gICAgICAgICAgICAgICAgc2VjdGlvbnMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2hlYWRlcicsXHJcbiAgICAgICAgICAgICAgICAgICAga2V5OiAnaGVhZGVyJyxcclxuICAgICAgICAgICAgICAgICAgICBpc1N0aWNreTogc3RpY2t5SGVhZGVyRGF0ZXMsXHJcbiAgICAgICAgICAgICAgICAgICAgc3luY1Jvd0hlaWdodHM6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgY2h1bmtzOiBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleTogJ2F4aXMnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcm93Q29udGVudDogKGFyZykgPT4gKHkoXCJ0clwiLCB7IHJvbGU6IFwicHJlc2VudGF0aW9uXCIgfSwgdGhpcy5yZW5kZXJIZWFkQXhpcygnZGF5JywgYXJnLnJvd1N5bmNIZWlnaHRzWzBdKSkpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXk6ICdjb2xzJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsUmVmOiB0aGlzLmhlYWRlckVsUmVmLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFibGVDbGFzc05hbWU6ICdmYy1jb2wtaGVhZGVyJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvd0NvbnRlbnQ6IGhlYWRlclJvd0NvbnRlbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChhbGxEYXlDb250ZW50KSB7XHJcbiAgICAgICAgICAgICAgICBzZWN0aW9ucy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnYm9keScsXHJcbiAgICAgICAgICAgICAgICAgICAga2V5OiAnYWxsLWRheScsXHJcbiAgICAgICAgICAgICAgICAgICAgc3luY1Jvd0hlaWdodHM6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgY2h1bmtzOiBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleTogJ2F4aXMnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcm93Q29udGVudDogKGNvbnRlbnRBcmcpID0+ICh5KFwidHJcIiwgeyByb2xlOiBcInByZXNlbnRhdGlvblwiIH0sIHRoaXMucmVuZGVyVGFibGVSb3dBeGlzKGNvbnRlbnRBcmcucm93U3luY0hlaWdodHNbMF0pKSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleTogJ2NvbHMnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogYWxsRGF5Q29udGVudCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBzZWN0aW9ucy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICBrZXk6ICdhbGwtZGF5LWRpdmlkZXInLFxyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdib2R5JyxcclxuICAgICAgICAgICAgICAgICAgICBvdXRlckNvbnRlbnQ6ICggLy8gVE9ETzogcmVuYW1lIHRvIGNlbGxDb250ZW50IHNvIGRvbid0IG5lZWQgdG8gZGVmaW5lIDx0cj4/XHJcbiAgICAgICAgICAgICAgICAgICAgeShcInRyXCIsIHsgcm9sZTogXCJwcmVzZW50YXRpb25cIiwgY2xhc3NOYW1lOiBcImZjLXNjcm9sbGdyaWQtc2VjdGlvblwiIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHkoXCJ0ZFwiLCB7IGNvbFNwYW46IDIsIGNsYXNzTmFtZTogJ2ZjLXRpbWVncmlkLWRpdmlkZXIgJyArIGNvbnRleHQudGhlbWUuZ2V0Q2xhc3MoJ3RhYmxlQ2VsbFNoYWRlZCcpIH0pKSksXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgaXNOb3dJbmRpY2F0b3IgPSBjb250ZXh0Lm9wdGlvbnMubm93SW5kaWNhdG9yO1xyXG4gICAgICAgICAgICBzZWN0aW9ucy5wdXNoKHtcclxuICAgICAgICAgICAgICAgIHR5cGU6ICdib2R5JyxcclxuICAgICAgICAgICAgICAgIGtleTogJ2JvZHknLFxyXG4gICAgICAgICAgICAgICAgbGlxdWlkOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgZXhwYW5kUm93czogQm9vbGVhbihjb250ZXh0Lm9wdGlvbnMuZXhwYW5kUm93cyksXHJcbiAgICAgICAgICAgICAgICBjaHVua3M6IFtcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleTogJ2F4aXMnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiAoYXJnKSA9PiAoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IG1ha2UgdGhpcyBub3ctaW5kaWNhdG9yIGFycm93IG1vcmUgRFJZIHdpdGggVGltZUNvbHNDb250ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHkoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtdGltZWdyaWQtYXhpcy1jaHVua1wiIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5KFwidGFibGVcIiwgeyBcImFyaWEtaGlkZGVuXCI6IHRydWUsIHN0eWxlOiB7IGhlaWdodDogYXJnLmV4cGFuZFJvd3MgPyBhcmcuY2xpZW50SGVpZ2h0IDogJycgfSB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZy50YWJsZUNvbEdyb3VwTm9kZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5KFwidGJvZHlcIiwgbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeShUaW1lQm9keUF4aXMsIHsgc2xhdE1ldGFzOiBzbGF0TWV0YXMgfSkpKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtdGltZWdyaWQtbm93LWluZGljYXRvci1jb250YWluZXJcIiB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkoTm93VGltZXIsIHsgdW5pdDogaXNOb3dJbmRpY2F0b3IgPyAnbWludXRlJyA6ICdkYXknIC8qIGhhY2t5ICovIH0sIChub3dEYXRlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBub3dJbmRpY2F0b3JUb3AgPSBpc05vd0luZGljYXRvciAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2xhdENvb3JkcyAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2xhdENvb3Jkcy5zYWZlQ29tcHV0ZVRvcChub3dEYXRlKTsgLy8gbWlnaHQgcmV0dXJuIHZvaWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBub3dJbmRpY2F0b3JUb3AgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHkoTm93SW5kaWNhdG9yQ29udGFpbmVyLCB7IGVsQ2xhc3NlczogWydmYy10aW1lZ3JpZC1ub3ctaW5kaWNhdG9yLWFycm93J10sIGVsU3R5bGU6IHsgdG9wOiBub3dJbmRpY2F0b3JUb3AgfSwgaXNBeGlzOiB0cnVlLCBkYXRlOiBub3dEYXRlIH0pKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSkpKSxcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAga2V5OiAnY29scycsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbGVyRWxSZWY6IHRoaXMuc2Nyb2xsZXJFbFJlZixcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogdGltZUNvbnRlbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBpZiAoc3RpY2t5Rm9vdGVyU2Nyb2xsYmFyKSB7XHJcbiAgICAgICAgICAgICAgICBzZWN0aW9ucy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICBrZXk6ICdmb290ZXInLFxyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdmb290ZXInLFxyXG4gICAgICAgICAgICAgICAgICAgIGlzU3RpY2t5OiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgIGNodW5rczogW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXk6ICdheGlzJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHJlbmRlclNjcm9sbFNoaW0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleTogJ2NvbHMnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogcmVuZGVyU2Nyb2xsU2hpbSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuICh5KFZpZXdDb250YWluZXIsIHsgZWxSZWY6IHRoaXMucm9vdEVsUmVmLCBlbENsYXNzZXM6IFsnZmMtdGltZWdyaWQnXSwgdmlld1NwZWM6IGNvbnRleHQudmlld1NwZWMgfSxcclxuICAgICAgICAgICAgICAgIHkoU2Nyb2xsR3JpZCwgeyBsaXF1aWQ6ICFwcm9wcy5pc0hlaWdodEF1dG8gJiYgIXByb3BzLmZvclByaW50LCBmb3JQcmludDogcHJvcHMuZm9yUHJpbnQsIGNvbGxhcHNpYmxlV2lkdGg6IGZhbHNlLCBjb2xHcm91cHM6IFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeyB3aWR0aDogJ3NocmluaycsIGNvbHM6IFt7IHdpZHRoOiAnc2hyaW5rJyB9XSB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7IGNvbHM6IFt7IHNwYW46IGNvbENudCwgbWluV2lkdGg6IGRheU1pbldpZHRoIH1dIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgXSwgc2VjdGlvbnM6IHNlY3Rpb25zIH0pKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qIERpbWVuc2lvbnNcclxuICAgICAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgICAgIGdldEFsbERheU1heEV2ZW50UHJvcHMoKSB7XHJcbiAgICAgICAgICAgIGxldCB7IGRheU1heEV2ZW50cywgZGF5TWF4RXZlbnRSb3dzIH0gPSB0aGlzLmNvbnRleHQub3B0aW9ucztcclxuICAgICAgICAgICAgaWYgKGRheU1heEV2ZW50cyA9PT0gdHJ1ZSB8fCBkYXlNYXhFdmVudFJvd3MgPT09IHRydWUpIHsgLy8gaXMgYXV0bz9cclxuICAgICAgICAgICAgICAgIGRheU1heEV2ZW50cyA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgIGRheU1heEV2ZW50Um93cyA9IEFVVE9fQUxMX0RBWV9NQVhfRVZFTlRfUk9XUzsgLy8gbWFrZSBzdXJlIFwiYXV0b1wiIGdvZXMgdG8gYSByZWFsIG51bWJlclxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB7IGRheU1heEV2ZW50cywgZGF5TWF4RXZlbnRSb3dzIH07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gcmVuZGVyQWxsRGF5SW5uZXIkMShyZW5kZXJQcm9wcykge1xyXG4gICAgICAgIHJldHVybiByZW5kZXJQcm9wcy50ZXh0O1xyXG4gICAgfVxyXG5cclxuICAgIGNsYXNzIFRpbWVDb2xzU2xhdHNDb29yZHMge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yKHBvc2l0aW9ucywgZGF0ZVByb2ZpbGUsIHNsb3REdXJhdGlvbikge1xyXG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9ucyA9IHBvc2l0aW9ucztcclxuICAgICAgICAgICAgdGhpcy5kYXRlUHJvZmlsZSA9IGRhdGVQcm9maWxlO1xyXG4gICAgICAgICAgICB0aGlzLnNsb3REdXJhdGlvbiA9IHNsb3REdXJhdGlvbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgc2FmZUNvbXB1dGVUb3AoZGF0ZSkge1xyXG4gICAgICAgICAgICBsZXQgeyBkYXRlUHJvZmlsZSB9ID0gdGhpcztcclxuICAgICAgICAgICAgaWYgKHJhbmdlQ29udGFpbnNNYXJrZXIoZGF0ZVByb2ZpbGUuY3VycmVudFJhbmdlLCBkYXRlKSkge1xyXG4gICAgICAgICAgICAgICAgbGV0IHN0YXJ0T2ZEYXlEYXRlID0gc3RhcnRPZkRheShkYXRlKTtcclxuICAgICAgICAgICAgICAgIGxldCB0aW1lTXMgPSBkYXRlLnZhbHVlT2YoKSAtIHN0YXJ0T2ZEYXlEYXRlLnZhbHVlT2YoKTtcclxuICAgICAgICAgICAgICAgIGlmICh0aW1lTXMgPj0gYXNSb3VnaE1zKGRhdGVQcm9maWxlLnNsb3RNaW5UaW1lKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgIHRpbWVNcyA8IGFzUm91Z2hNcyhkYXRlUHJvZmlsZS5zbG90TWF4VGltZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb21wdXRlVGltZVRvcChjcmVhdGVEdXJhdGlvbih0aW1lTXMpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQ29tcHV0ZXMgdGhlIHRvcCBjb29yZGluYXRlLCByZWxhdGl2ZSB0byB0aGUgYm91bmRzIG9mIHRoZSBncmlkLCBvZiB0aGUgZ2l2ZW4gZGF0ZS5cclxuICAgICAgICAvLyBBIGBzdGFydE9mRGF5RGF0ZWAgbXVzdCBiZSBnaXZlbiBmb3IgYXZvaWRpbmcgYW1iaWd1aXR5IG92ZXIgaG93IHRvIHRyZWF0IG1pZG5pZ2h0LlxyXG4gICAgICAgIGNvbXB1dGVEYXRlVG9wKHdoZW4sIHN0YXJ0T2ZEYXlEYXRlKSB7XHJcbiAgICAgICAgICAgIGlmICghc3RhcnRPZkRheURhdGUpIHtcclxuICAgICAgICAgICAgICAgIHN0YXJ0T2ZEYXlEYXRlID0gc3RhcnRPZkRheSh3aGVuKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb21wdXRlVGltZVRvcChjcmVhdGVEdXJhdGlvbih3aGVuLnZhbHVlT2YoKSAtIHN0YXJ0T2ZEYXlEYXRlLnZhbHVlT2YoKSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBDb21wdXRlcyB0aGUgdG9wIGNvb3JkaW5hdGUsIHJlbGF0aXZlIHRvIHRoZSBib3VuZHMgb2YgdGhlIGdyaWQsIG9mIHRoZSBnaXZlbiB0aW1lIChhIER1cmF0aW9uKS5cclxuICAgICAgICAvLyBUaGlzIGlzIGEgbWFrZXNoaWZ5IHdheSB0byBjb21wdXRlIHRoZSB0aW1lLXRvcC4gQXNzdW1lcyBhbGwgc2xhdE1ldGFzIGRhdGVzIGFyZSB1bmlmb3JtLlxyXG4gICAgICAgIC8vIEV2ZW50dWFsbHkgYWxsb3cgY29tcHV0YXRpb24gd2l0aCBhcmJpcmFyeSBzbGF0IGRhdGVzLlxyXG4gICAgICAgIGNvbXB1dGVUaW1lVG9wKGR1cmF0aW9uKSB7XHJcbiAgICAgICAgICAgIGxldCB7IHBvc2l0aW9ucywgZGF0ZVByb2ZpbGUgfSA9IHRoaXM7XHJcbiAgICAgICAgICAgIGxldCBsZW4gPSBwb3NpdGlvbnMuZWxzLmxlbmd0aDtcclxuICAgICAgICAgICAgLy8gZmxvYXRpbmctcG9pbnQgdmFsdWUgb2YgIyBvZiBzbG90cyBjb3ZlcmVkXHJcbiAgICAgICAgICAgIGxldCBzbGF0Q292ZXJhZ2UgPSAoZHVyYXRpb24ubWlsbGlzZWNvbmRzIC0gYXNSb3VnaE1zKGRhdGVQcm9maWxlLnNsb3RNaW5UaW1lKSkgLyBhc1JvdWdoTXModGhpcy5zbG90RHVyYXRpb24pO1xyXG4gICAgICAgICAgICBsZXQgc2xhdEluZGV4O1xyXG4gICAgICAgICAgICBsZXQgc2xhdFJlbWFpbmRlcjtcclxuICAgICAgICAgICAgLy8gY29tcHV0ZSBhIGZsb2F0aW5nLXBvaW50IG51bWJlciBmb3IgaG93IG1hbnkgc2xhdHMgc2hvdWxkIGJlIHByb2dyZXNzZWQgdGhyb3VnaC5cclxuICAgICAgICAgICAgLy8gZnJvbSAwIHRvIG51bWJlciBvZiBzbGF0cyAoaW5jbHVzaXZlKVxyXG4gICAgICAgICAgICAvLyBjb25zdHJhaW5lZCBiZWNhdXNlIHNsb3RNaW5UaW1lL3Nsb3RNYXhUaW1lIG1pZ2h0IGJlIGN1c3RvbWl6ZWQuXHJcbiAgICAgICAgICAgIHNsYXRDb3ZlcmFnZSA9IE1hdGgubWF4KDAsIHNsYXRDb3ZlcmFnZSk7XHJcbiAgICAgICAgICAgIHNsYXRDb3ZlcmFnZSA9IE1hdGgubWluKGxlbiwgc2xhdENvdmVyYWdlKTtcclxuICAgICAgICAgICAgLy8gYW4gaW50ZWdlciBpbmRleCBvZiB0aGUgZnVydGhlc3Qgd2hvbGUgc2xhdFxyXG4gICAgICAgICAgICAvLyBmcm9tIDAgdG8gbnVtYmVyIHNsYXRzICgqZXhjbHVzaXZlKiwgc28gbGVuLTEpXHJcbiAgICAgICAgICAgIHNsYXRJbmRleCA9IE1hdGguZmxvb3Ioc2xhdENvdmVyYWdlKTtcclxuICAgICAgICAgICAgc2xhdEluZGV4ID0gTWF0aC5taW4oc2xhdEluZGV4LCBsZW4gLSAxKTtcclxuICAgICAgICAgICAgLy8gaG93IG11Y2ggZnVydGhlciB0aHJvdWdoIHRoZSBzbGF0SW5kZXggc2xhdCAoZnJvbSAwLjAtMS4wKSBtdXN0IGJlIGNvdmVyZWQgaW4gYWRkaXRpb24uXHJcbiAgICAgICAgICAgIC8vIGNvdWxkIGJlIDEuMCBpZiBzbGF0Q292ZXJhZ2UgaXMgY292ZXJpbmcgKmFsbCogdGhlIHNsb3RzXHJcbiAgICAgICAgICAgIHNsYXRSZW1haW5kZXIgPSBzbGF0Q292ZXJhZ2UgLSBzbGF0SW5kZXg7XHJcbiAgICAgICAgICAgIHJldHVybiBwb3NpdGlvbnMudG9wc1tzbGF0SW5kZXhdICtcclxuICAgICAgICAgICAgICAgIHBvc2l0aW9ucy5nZXRIZWlnaHQoc2xhdEluZGV4KSAqIHNsYXRSZW1haW5kZXI7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNsYXNzIFRpbWVDb2xzU2xhdHNCb2R5IGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XHJcbiAgICAgICAgcmVuZGVyKCkge1xyXG4gICAgICAgICAgICBsZXQgeyBwcm9wcywgY29udGV4dCB9ID0gdGhpcztcclxuICAgICAgICAgICAgbGV0IHsgb3B0aW9ucyB9ID0gY29udGV4dDtcclxuICAgICAgICAgICAgbGV0IHsgc2xhdEVsUmVmcyB9ID0gcHJvcHM7XHJcbiAgICAgICAgICAgIHJldHVybiAoeShcInRib2R5XCIsIG51bGwsIHByb3BzLnNsYXRNZXRhcy5tYXAoKHNsYXRNZXRhLCBpKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBsZXQgcmVuZGVyUHJvcHMgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGltZTogc2xhdE1ldGEudGltZSxcclxuICAgICAgICAgICAgICAgICAgICBkYXRlOiBjb250ZXh0LmRhdGVFbnYudG9EYXRlKHNsYXRNZXRhLmRhdGUpLFxyXG4gICAgICAgICAgICAgICAgICAgIHZpZXc6IGNvbnRleHQudmlld0FwaSxcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKHkoXCJ0clwiLCB7IGtleTogc2xhdE1ldGEua2V5LCByZWY6IHNsYXRFbFJlZnMuY3JlYXRlUmVmKHNsYXRNZXRhLmtleSkgfSxcclxuICAgICAgICAgICAgICAgICAgICBwcm9wcy5heGlzICYmICh5KFRpbWVDb2xzQXhpc0NlbGwsIE9iamVjdC5hc3NpZ24oe30sIHNsYXRNZXRhKSkpLFxyXG4gICAgICAgICAgICAgICAgICAgIHkoQ29udGVudENvbnRhaW5lciwgeyBlbFRhZzogXCJ0ZFwiLCBlbENsYXNzZXM6IFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdmYy10aW1lZ3JpZC1zbG90JyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdmYy10aW1lZ3JpZC1zbG90LWxhbmUnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIXNsYXRNZXRhLmlzTGFiZWxlZCAmJiAnZmMtdGltZWdyaWQtc2xvdC1taW5vcicsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF0sIGVsQXR0cnM6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdkYXRhLXRpbWUnOiBzbGF0TWV0YS5pc29UaW1lU3RyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCByZW5kZXJQcm9wczogcmVuZGVyUHJvcHMsIGdlbmVyYXRvck5hbWU6IFwic2xvdExhbmVDb250ZW50XCIsIGN1c3RvbUdlbmVyYXRvcjogb3B0aW9ucy5zbG90TGFuZUNvbnRlbnQsIGNsYXNzTmFtZUdlbmVyYXRvcjogb3B0aW9ucy5zbG90TGFuZUNsYXNzTmFtZXMsIGRpZE1vdW50OiBvcHRpb25zLnNsb3RMYW5lRGlkTW91bnQsIHdpbGxVbm1vdW50OiBvcHRpb25zLnNsb3RMYW5lV2lsbFVubW91bnQgfSkpKTtcclxuICAgICAgICAgICAgfSkpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLypcclxuICAgIGZvciB0aGUgaG9yaXpvbnRhbCBcInNsYXRzXCIgdGhhdCBydW4gd2lkdGgtd2lzZS4gSGFzIGEgdGltZSBheGlzIG9uIGEgc2lkZS4gRGVwZW5kcyBvbiBSVEwuXHJcbiAgICAqL1xyXG4gICAgY2xhc3MgVGltZUNvbHNTbGF0cyBleHRlbmRzIEJhc2VDb21wb25lbnQge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgICAgICB0aGlzLnJvb3RFbFJlZiA9IGQoKTtcclxuICAgICAgICAgICAgdGhpcy5zbGF0RWxSZWZzID0gbmV3IFJlZk1hcCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZW5kZXIoKSB7XHJcbiAgICAgICAgICAgIGxldCB7IHByb3BzLCBjb250ZXh0IH0gPSB0aGlzO1xyXG4gICAgICAgICAgICByZXR1cm4gKHkoXCJkaXZcIiwgeyByZWY6IHRoaXMucm9vdEVsUmVmLCBjbGFzc05hbWU6IFwiZmMtdGltZWdyaWQtc2xvdHNcIiB9LFxyXG4gICAgICAgICAgICAgICAgeShcInRhYmxlXCIsIHsgXCJhcmlhLWhpZGRlblwiOiB0cnVlLCBjbGFzc05hbWU6IGNvbnRleHQudGhlbWUuZ2V0Q2xhc3MoJ3RhYmxlJyksIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbldpZHRoOiBwcm9wcy50YWJsZU1pbldpZHRoLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogcHJvcHMuY2xpZW50V2lkdGgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogcHJvcHMubWluSGVpZ2h0LFxyXG4gICAgICAgICAgICAgICAgICAgIH0gfSxcclxuICAgICAgICAgICAgICAgICAgICBwcm9wcy50YWJsZUNvbEdyb3VwTm9kZSAvKiByZWxpZXMgb24gdGhlcmUgb25seSBiZWluZyBhIHNpbmdsZSA8Y29sPiBmb3IgdGhlIGF4aXMgKi8sXHJcbiAgICAgICAgICAgICAgICAgICAgeShUaW1lQ29sc1NsYXRzQm9keSwgeyBzbGF0RWxSZWZzOiB0aGlzLnNsYXRFbFJlZnMsIGF4aXM6IHByb3BzLmF4aXMsIHNsYXRNZXRhczogcHJvcHMuc2xhdE1ldGFzIH0pKSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb21wb25lbnREaWRNb3VudCgpIHtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVTaXppbmcoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29tcG9uZW50RGlkVXBkYXRlKCkge1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVNpemluZygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMucHJvcHMub25Db29yZHMpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucHJvcHMub25Db29yZHMobnVsbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdXBkYXRlU2l6aW5nKCkge1xyXG4gICAgICAgICAgICBsZXQgeyBjb250ZXh0LCBwcm9wcyB9ID0gdGhpcztcclxuICAgICAgICAgICAgaWYgKHByb3BzLm9uQ29vcmRzICYmXHJcbiAgICAgICAgICAgICAgICBwcm9wcy5jbGllbnRXaWR0aCAhPT0gbnVsbCAvLyBtZWFucyBzaXppbmcgaGFzIHN0YWJpbGl6ZWRcclxuICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgcm9vdEVsID0gdGhpcy5yb290RWxSZWYuY3VycmVudDtcclxuICAgICAgICAgICAgICAgIGlmIChyb290RWwub2Zmc2V0SGVpZ2h0KSB7IC8vIG5vdCBoaWRkZW4gYnkgY3NzXHJcbiAgICAgICAgICAgICAgICAgICAgcHJvcHMub25Db29yZHMobmV3IFRpbWVDb2xzU2xhdHNDb29yZHMobmV3IFBvc2l0aW9uQ2FjaGUodGhpcy5yb290RWxSZWYuY3VycmVudCwgY29sbGVjdFNsYXRFbHModGhpcy5zbGF0RWxSZWZzLmN1cnJlbnRNYXAsIHByb3BzLnNsYXRNZXRhcyksIGZhbHNlLCB0cnVlKSwgdGhpcy5wcm9wcy5kYXRlUHJvZmlsZSwgY29udGV4dC5vcHRpb25zLnNsb3REdXJhdGlvbikpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gY29sbGVjdFNsYXRFbHMoZWxNYXAsIHNsYXRNZXRhcykge1xyXG4gICAgICAgIHJldHVybiBzbGF0TWV0YXMubWFwKChzbGF0TWV0YSkgPT4gZWxNYXBbc2xhdE1ldGEua2V5XSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gc3BsaXRTZWdzQnlDb2woc2VncywgY29sQ250KSB7XHJcbiAgICAgICAgbGV0IHNlZ3NCeUNvbCA9IFtdO1xyXG4gICAgICAgIGxldCBpO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb2xDbnQ7IGkgKz0gMSkge1xyXG4gICAgICAgICAgICBzZWdzQnlDb2wucHVzaChbXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzZWdzKSB7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBzZWdzLmxlbmd0aDsgaSArPSAxKSB7XHJcbiAgICAgICAgICAgICAgICBzZWdzQnlDb2xbc2Vnc1tpXS5jb2xdLnB1c2goc2Vnc1tpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHNlZ3NCeUNvbDtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHNwbGl0SW50ZXJhY3Rpb25CeUNvbCh1aSwgY29sQ250KSB7XHJcbiAgICAgICAgbGV0IGJ5Um93ID0gW107XHJcbiAgICAgICAgaWYgKCF1aSkge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbENudDsgaSArPSAxKSB7XHJcbiAgICAgICAgICAgICAgICBieVJvd1tpXSA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29sQ250OyBpICs9IDEpIHtcclxuICAgICAgICAgICAgICAgIGJ5Um93W2ldID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIGFmZmVjdGVkSW5zdGFuY2VzOiB1aS5hZmZlY3RlZEluc3RhbmNlcyxcclxuICAgICAgICAgICAgICAgICAgICBpc0V2ZW50OiB1aS5pc0V2ZW50LFxyXG4gICAgICAgICAgICAgICAgICAgIHNlZ3M6IFtdLFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKGxldCBzZWcgb2YgdWkuc2Vncykge1xyXG4gICAgICAgICAgICAgICAgYnlSb3dbc2VnLmNvbF0uc2Vncy5wdXNoKHNlZyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGJ5Um93O1xyXG4gICAgfVxyXG5cclxuICAgIGNsYXNzIFRpbWVDb2xNb3JlTGluayBleHRlbmRzIEJhc2VDb21wb25lbnQge1xyXG4gICAgICAgIHJlbmRlcigpIHtcclxuICAgICAgICAgICAgbGV0IHsgcHJvcHMgfSA9IHRoaXM7XHJcbiAgICAgICAgICAgIHJldHVybiAoeShNb3JlTGlua0NvbnRhaW5lciwgeyBlbENsYXNzZXM6IFsnZmMtdGltZWdyaWQtbW9yZS1saW5rJ10sIGVsU3R5bGU6IHtcclxuICAgICAgICAgICAgICAgICAgICB0b3A6IHByb3BzLnRvcCxcclxuICAgICAgICAgICAgICAgICAgICBib3R0b206IHByb3BzLmJvdHRvbSxcclxuICAgICAgICAgICAgICAgIH0sIGFsbERheURhdGU6IG51bGwsIG1vcmVDbnQ6IHByb3BzLmhpZGRlblNlZ3MubGVuZ3RoLCBhbGxTZWdzOiBwcm9wcy5oaWRkZW5TZWdzLCBoaWRkZW5TZWdzOiBwcm9wcy5oaWRkZW5TZWdzLCBleHRyYURhdGVTcGFuOiBwcm9wcy5leHRyYURhdGVTcGFuLCBkYXRlUHJvZmlsZTogcHJvcHMuZGF0ZVByb2ZpbGUsIHRvZGF5UmFuZ2U6IHByb3BzLnRvZGF5UmFuZ2UsIHBvcG92ZXJDb250ZW50OiAoKSA9PiByZW5kZXJQbGFpbkZnU2Vncyhwcm9wcy5oaWRkZW5TZWdzLCBwcm9wcyksIGRlZmF1bHRHZW5lcmF0b3I6IHJlbmRlck1vcmVMaW5rSW5uZXIsIGZvcmNlVGltZWQ6IHRydWUgfSwgKElubmVyQ29udGVudCkgPT4gKHkoSW5uZXJDb250ZW50LCB7IGVsVGFnOiBcImRpdlwiLCBlbENsYXNzZXM6IFsnZmMtdGltZWdyaWQtbW9yZS1saW5rLWlubmVyJywgJ2ZjLXN0aWNreSddIH0pKSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHJlbmRlck1vcmVMaW5rSW5uZXIocHJvcHMpIHtcclxuICAgICAgICByZXR1cm4gcHJvcHMuc2hvcnRUZXh0O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHNlZ0lucHV0cyBhc3N1bWVkIHNvcnRlZFxyXG4gICAgZnVuY3Rpb24gYnVpbGRQb3NpdGlvbmluZyhzZWdJbnB1dHMsIHN0cmljdE9yZGVyLCBtYXhTdGFja0NudCkge1xyXG4gICAgICAgIGxldCBoaWVyYXJjaHkgPSBuZXcgU2VnSGllcmFyY2h5KCk7XHJcbiAgICAgICAgaWYgKHN0cmljdE9yZGVyICE9IG51bGwpIHtcclxuICAgICAgICAgICAgaGllcmFyY2h5LnN0cmljdE9yZGVyID0gc3RyaWN0T3JkZXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChtYXhTdGFja0NudCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIGhpZXJhcmNoeS5tYXhTdGFja0NudCA9IG1heFN0YWNrQ250O1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgaGlkZGVuRW50cmllcyA9IGhpZXJhcmNoeS5hZGRTZWdzKHNlZ0lucHV0cyk7XHJcbiAgICAgICAgbGV0IGhpZGRlbkdyb3VwcyA9IGdyb3VwSW50ZXJzZWN0aW5nRW50cmllcyhoaWRkZW5FbnRyaWVzKTtcclxuICAgICAgICBsZXQgd2ViID0gYnVpbGRXZWIoaGllcmFyY2h5KTtcclxuICAgICAgICB3ZWIgPSBzdHJldGNoV2ViKHdlYiwgMSk7IC8vIGFsbCBsZXZlbENvb3Jkcy90aGlja25lc3Mgd2lsbCBoYXZlIDAuMC0xLjBcclxuICAgICAgICBsZXQgc2VnUmVjdHMgPSB3ZWJUb1JlY3RzKHdlYik7XHJcbiAgICAgICAgcmV0dXJuIHsgc2VnUmVjdHMsIGhpZGRlbkdyb3VwcyB9O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYnVpbGRXZWIoaGllcmFyY2h5KSB7XHJcbiAgICAgICAgY29uc3QgeyBlbnRyaWVzQnlMZXZlbCB9ID0gaGllcmFyY2h5O1xyXG4gICAgICAgIGNvbnN0IGJ1aWxkTm9kZSA9IGNhY2hlYWJsZSgobGV2ZWwsIGxhdGVyYWwpID0+IGxldmVsICsgJzonICsgbGF0ZXJhbCwgKGxldmVsLCBsYXRlcmFsKSA9PiB7XHJcbiAgICAgICAgICAgIGxldCBzaWJsaW5nUmFuZ2UgPSBmaW5kTmV4dExldmVsU2VncyhoaWVyYXJjaHksIGxldmVsLCBsYXRlcmFsKTtcclxuICAgICAgICAgICAgbGV0IG5leHRMZXZlbFJlcyA9IGJ1aWxkTm9kZXMoc2libGluZ1JhbmdlLCBidWlsZE5vZGUpO1xyXG4gICAgICAgICAgICBsZXQgZW50cnkgPSBlbnRyaWVzQnlMZXZlbFtsZXZlbF1bbGF0ZXJhbF07XHJcbiAgICAgICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGVudHJ5KSwgeyBuZXh0TGV2ZWxOb2RlczogbmV4dExldmVsUmVzWzBdIH0pLFxyXG4gICAgICAgICAgICAgICAgZW50cnkudGhpY2tuZXNzICsgbmV4dExldmVsUmVzWzFdLCAvLyB0aGUgcHJlc3N1cmUgYnVpbGRzXHJcbiAgICAgICAgICAgIF07XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGJ1aWxkTm9kZXMoZW50cmllc0J5TGV2ZWwubGVuZ3RoXHJcbiAgICAgICAgICAgID8geyBsZXZlbDogMCwgbGF0ZXJhbFN0YXJ0OiAwLCBsYXRlcmFsRW5kOiBlbnRyaWVzQnlMZXZlbFswXS5sZW5ndGggfVxyXG4gICAgICAgICAgICA6IG51bGwsIGJ1aWxkTm9kZSlbMF07XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBidWlsZE5vZGVzKHNpYmxpbmdSYW5nZSwgYnVpbGROb2RlKSB7XHJcbiAgICAgICAgaWYgKCFzaWJsaW5nUmFuZ2UpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFtbXSwgMF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCB7IGxldmVsLCBsYXRlcmFsU3RhcnQsIGxhdGVyYWxFbmQgfSA9IHNpYmxpbmdSYW5nZTtcclxuICAgICAgICBsZXQgbGF0ZXJhbCA9IGxhdGVyYWxTdGFydDtcclxuICAgICAgICBsZXQgcGFpcnMgPSBbXTtcclxuICAgICAgICB3aGlsZSAobGF0ZXJhbCA8IGxhdGVyYWxFbmQpIHtcclxuICAgICAgICAgICAgcGFpcnMucHVzaChidWlsZE5vZGUobGV2ZWwsIGxhdGVyYWwpKTtcclxuICAgICAgICAgICAgbGF0ZXJhbCArPSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwYWlycy5zb3J0KGNtcERlc2NQcmVzc3VyZXMpO1xyXG4gICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgIHBhaXJzLm1hcChleHRyYWN0Tm9kZSksXHJcbiAgICAgICAgICAgIHBhaXJzWzBdWzFdLCAvLyBmaXJzdCBpdGVtJ3MgcHJlc3N1cmVcclxuICAgICAgICBdO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gY21wRGVzY1ByZXNzdXJlcyhhLCBiKSB7XHJcbiAgICAgICAgcmV0dXJuIGJbMV0gLSBhWzFdO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZXh0cmFjdE5vZGUoYSkge1xyXG4gICAgICAgIHJldHVybiBhWzBdO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZmluZE5leHRMZXZlbFNlZ3MoaGllcmFyY2h5LCBzdWJqZWN0TGV2ZWwsIHN1YmplY3RMYXRlcmFsKSB7XHJcbiAgICAgICAgbGV0IHsgbGV2ZWxDb29yZHMsIGVudHJpZXNCeUxldmVsIH0gPSBoaWVyYXJjaHk7XHJcbiAgICAgICAgbGV0IHN1YmplY3RFbnRyeSA9IGVudHJpZXNCeUxldmVsW3N1YmplY3RMZXZlbF1bc3ViamVjdExhdGVyYWxdO1xyXG4gICAgICAgIGxldCBhZnRlclN1YmplY3QgPSBsZXZlbENvb3Jkc1tzdWJqZWN0TGV2ZWxdICsgc3ViamVjdEVudHJ5LnRoaWNrbmVzcztcclxuICAgICAgICBsZXQgbGV2ZWxDbnQgPSBsZXZlbENvb3Jkcy5sZW5ndGg7XHJcbiAgICAgICAgbGV0IGxldmVsID0gc3ViamVjdExldmVsO1xyXG4gICAgICAgIC8vIHNraXAgcGFzdCBsZXZlbHMgdGhhdCBhcmUgdG9vIGhpZ2ggdXBcclxuICAgICAgICBmb3IgKDsgbGV2ZWwgPCBsZXZlbENudCAmJiBsZXZlbENvb3Jkc1tsZXZlbF0gPCBhZnRlclN1YmplY3Q7IGxldmVsICs9IDEpXHJcbiAgICAgICAgICAgIDsgLy8gZG8gbm90aGluZ1xyXG4gICAgICAgIGZvciAoOyBsZXZlbCA8IGxldmVsQ250OyBsZXZlbCArPSAxKSB7XHJcbiAgICAgICAgICAgIGxldCBlbnRyaWVzID0gZW50cmllc0J5TGV2ZWxbbGV2ZWxdO1xyXG4gICAgICAgICAgICBsZXQgZW50cnk7XHJcbiAgICAgICAgICAgIGxldCBzZWFyY2hJbmRleCA9IGJpbmFyeVNlYXJjaChlbnRyaWVzLCBzdWJqZWN0RW50cnkuc3Bhbi5zdGFydCwgZ2V0RW50cnlTcGFuRW5kKTtcclxuICAgICAgICAgICAgbGV0IGxhdGVyYWxTdGFydCA9IHNlYXJjaEluZGV4WzBdICsgc2VhcmNoSW5kZXhbMV07IC8vIGlmIGV4YWN0IG1hdGNoICh3aGljaCBkb2Vzbid0IGNvbGxpZGUpLCBnbyB0byBuZXh0IG9uZVxyXG4gICAgICAgICAgICBsZXQgbGF0ZXJhbEVuZCA9IGxhdGVyYWxTdGFydDtcclxuICAgICAgICAgICAgd2hpbGUgKCAvLyBsb29wIHRocm91Z2ggZW50cmllcyB0aGF0IGhvcml6b250YWxseSBpbnRlcnNlY3RcclxuICAgICAgICAgICAgKGVudHJ5ID0gZW50cmllc1tsYXRlcmFsRW5kXSkgJiYgLy8gYnV0IG5vdCBwYXN0IHRoZSB3aG9sZSBzZWcgbGlzdFxyXG4gICAgICAgICAgICAgICAgZW50cnkuc3Bhbi5zdGFydCA8IHN1YmplY3RFbnRyeS5zcGFuLmVuZCkge1xyXG4gICAgICAgICAgICAgICAgbGF0ZXJhbEVuZCArPSAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChsYXRlcmFsU3RhcnQgPCBsYXRlcmFsRW5kKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4geyBsZXZlbCwgbGF0ZXJhbFN0YXJ0LCBsYXRlcmFsRW5kIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBzdHJldGNoV2ViKHRvcExldmVsTm9kZXMsIHRvdGFsVGhpY2tuZXNzKSB7XHJcbiAgICAgICAgY29uc3Qgc3RyZXRjaE5vZGUgPSBjYWNoZWFibGUoKG5vZGUsIHN0YXJ0Q29vcmQsIHByZXZUaGlja25lc3MpID0+IGJ1aWxkRW50cnlLZXkobm9kZSksIChub2RlLCBzdGFydENvb3JkLCBwcmV2VGhpY2tuZXNzKSA9PiB7XHJcbiAgICAgICAgICAgIGxldCB7IG5leHRMZXZlbE5vZGVzLCB0aGlja25lc3MgfSA9IG5vZGU7XHJcbiAgICAgICAgICAgIGxldCBhbGxUaGlja25lc3MgPSB0aGlja25lc3MgKyBwcmV2VGhpY2tuZXNzO1xyXG4gICAgICAgICAgICBsZXQgdGhpY2tuZXNzRnJhY3Rpb24gPSB0aGlja25lc3MgLyBhbGxUaGlja25lc3M7XHJcbiAgICAgICAgICAgIGxldCBlbmRDb29yZDtcclxuICAgICAgICAgICAgbGV0IG5ld0NoaWxkcmVuID0gW107XHJcbiAgICAgICAgICAgIGlmICghbmV4dExldmVsTm9kZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBlbmRDb29yZCA9IHRvdGFsVGhpY2tuZXNzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgY2hpbGROb2RlIG9mIG5leHRMZXZlbE5vZGVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVuZENvb3JkID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJlcyA9IHN0cmV0Y2hOb2RlKGNoaWxkTm9kZSwgc3RhcnRDb29yZCwgYWxsVGhpY2tuZXNzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kQ29vcmQgPSByZXNbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0NoaWxkcmVuLnB1c2gocmVzWzFdKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCByZXMgPSBzdHJldGNoTm9kZShjaGlsZE5vZGUsIGVuZENvb3JkLCAwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3Q2hpbGRyZW4ucHVzaChyZXNbMV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgbmV3VGhpY2tuZXNzID0gKGVuZENvb3JkIC0gc3RhcnRDb29yZCkgKiB0aGlja25lc3NGcmFjdGlvbjtcclxuICAgICAgICAgICAgcmV0dXJuIFtlbmRDb29yZCAtIG5ld1RoaWNrbmVzcywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBub2RlKSwgeyB0aGlja25lc3M6IG5ld1RoaWNrbmVzcywgbmV4dExldmVsTm9kZXM6IG5ld0NoaWxkcmVuIH0pXTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gdG9wTGV2ZWxOb2Rlcy5tYXAoKG5vZGUpID0+IHN0cmV0Y2hOb2RlKG5vZGUsIDAsIDApWzFdKTtcclxuICAgIH1cclxuICAgIC8vIG5vdCBzb3J0ZWQgaW4gYW55IHBhcnRpY3VsYXIgb3JkZXJcclxuICAgIGZ1bmN0aW9uIHdlYlRvUmVjdHModG9wTGV2ZWxOb2Rlcykge1xyXG4gICAgICAgIGxldCByZWN0cyA9IFtdO1xyXG4gICAgICAgIGNvbnN0IHByb2Nlc3NOb2RlID0gY2FjaGVhYmxlKChub2RlLCBsZXZlbENvb3JkLCBzdGFja0RlcHRoKSA9PiBidWlsZEVudHJ5S2V5KG5vZGUpLCAobm9kZSwgbGV2ZWxDb29yZCwgc3RhY2tEZXB0aCkgPT4ge1xyXG4gICAgICAgICAgICBsZXQgcmVjdCA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbm9kZSksIHsgbGV2ZWxDb29yZCxcclxuICAgICAgICAgICAgICAgIHN0YWNrRGVwdGgsIHN0YWNrRm9yd2FyZDogMCB9KTtcclxuICAgICAgICAgICAgcmVjdHMucHVzaChyZWN0KTtcclxuICAgICAgICAgICAgcmV0dXJuIChyZWN0LnN0YWNrRm9yd2FyZCA9IHByb2Nlc3NOb2Rlcyhub2RlLm5leHRMZXZlbE5vZGVzLCBsZXZlbENvb3JkICsgbm9kZS50aGlja25lc3MsIHN0YWNrRGVwdGggKyAxKSArIDEpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGZ1bmN0aW9uIHByb2Nlc3NOb2Rlcyhub2RlcywgbGV2ZWxDb29yZCwgc3RhY2tEZXB0aCkge1xyXG4gICAgICAgICAgICBsZXQgc3RhY2tGb3J3YXJkID0gMDtcclxuICAgICAgICAgICAgZm9yIChsZXQgbm9kZSBvZiBub2Rlcykge1xyXG4gICAgICAgICAgICAgICAgc3RhY2tGb3J3YXJkID0gTWF0aC5tYXgocHJvY2Vzc05vZGUobm9kZSwgbGV2ZWxDb29yZCwgc3RhY2tEZXB0aCksIHN0YWNrRm9yd2FyZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHN0YWNrRm9yd2FyZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcHJvY2Vzc05vZGVzKHRvcExldmVsTm9kZXMsIDAsIDApO1xyXG4gICAgICAgIHJldHVybiByZWN0czsgLy8gVE9ETzogc29ydCByZWN0cyBieSBsZXZlbENvb3JkIHRvIGJlIGNvbnNpc3RlbnQgd2l0aCB0b1JlY3RzP1xyXG4gICAgfVxyXG4gICAgLy8gVE9ETzogbW92ZSB0byBnZW5lcmFsIHV0aWxcclxuICAgIGZ1bmN0aW9uIGNhY2hlYWJsZShrZXlGdW5jLCB3b3JrRnVuYykge1xyXG4gICAgICAgIGNvbnN0IGNhY2hlID0ge307XHJcbiAgICAgICAgcmV0dXJuICguLi5hcmdzKSA9PiB7XHJcbiAgICAgICAgICAgIGxldCBrZXkgPSBrZXlGdW5jKC4uLmFyZ3MpO1xyXG4gICAgICAgICAgICByZXR1cm4gKGtleSBpbiBjYWNoZSlcclxuICAgICAgICAgICAgICAgID8gY2FjaGVba2V5XVxyXG4gICAgICAgICAgICAgICAgOiAoY2FjaGVba2V5XSA9IHdvcmtGdW5jKC4uLmFyZ3MpKTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNvbXB1dGVTZWdWQ29vcmRzKHNlZ3MsIGNvbERhdGUsIHNsYXRDb29yZHMgPSBudWxsLCBldmVudE1pbkhlaWdodCA9IDApIHtcclxuICAgICAgICBsZXQgdmNvb3JkcyA9IFtdO1xyXG4gICAgICAgIGlmIChzbGF0Q29vcmRzKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2Vncy5sZW5ndGg7IGkgKz0gMSkge1xyXG4gICAgICAgICAgICAgICAgbGV0IHNlZyA9IHNlZ3NbaV07XHJcbiAgICAgICAgICAgICAgICBsZXQgc3BhblN0YXJ0ID0gc2xhdENvb3Jkcy5jb21wdXRlRGF0ZVRvcChzZWcuc3RhcnQsIGNvbERhdGUpO1xyXG4gICAgICAgICAgICAgICAgbGV0IHNwYW5FbmQgPSBNYXRoLm1heChzcGFuU3RhcnQgKyAoZXZlbnRNaW5IZWlnaHQgfHwgMCksIC8vIDooXHJcbiAgICAgICAgICAgICAgICBzbGF0Q29vcmRzLmNvbXB1dGVEYXRlVG9wKHNlZy5lbmQsIGNvbERhdGUpKTtcclxuICAgICAgICAgICAgICAgIHZjb29yZHMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IE1hdGgucm91bmQoc3BhblN0YXJ0KSxcclxuICAgICAgICAgICAgICAgICAgICBlbmQ6IE1hdGgucm91bmQoc3BhbkVuZCksIC8vXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdmNvb3JkcztcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGNvbXB1dGVGZ1NlZ1BsYWNlbWVudHMoc2Vncywgc2VnVkNvb3JkcywgLy8gbWlnaHQgbm90IGhhdmUgZm9yIGV2ZXJ5IHNlZ1xyXG4gICAgZXZlbnRPcmRlclN0cmljdCwgZXZlbnRNYXhTdGFjaykge1xyXG4gICAgICAgIGxldCBzZWdJbnB1dHMgPSBbXTtcclxuICAgICAgICBsZXQgZHVtYlNlZ3MgPSBbXTsgLy8gc2VncyB3aXRob3V0IGNvb3Jkc1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2Vncy5sZW5ndGg7IGkgKz0gMSkge1xyXG4gICAgICAgICAgICBsZXQgdmNvb3JkcyA9IHNlZ1ZDb29yZHNbaV07XHJcbiAgICAgICAgICAgIGlmICh2Y29vcmRzKSB7XHJcbiAgICAgICAgICAgICAgICBzZWdJbnB1dHMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGksXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpY2tuZXNzOiAxLFxyXG4gICAgICAgICAgICAgICAgICAgIHNwYW46IHZjb29yZHMsXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGR1bWJTZWdzLnB1c2goc2Vnc1tpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHsgc2VnUmVjdHMsIGhpZGRlbkdyb3VwcyB9ID0gYnVpbGRQb3NpdGlvbmluZyhzZWdJbnB1dHMsIGV2ZW50T3JkZXJTdHJpY3QsIGV2ZW50TWF4U3RhY2spO1xyXG4gICAgICAgIGxldCBzZWdQbGFjZW1lbnRzID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgc2VnUmVjdCBvZiBzZWdSZWN0cykge1xyXG4gICAgICAgICAgICBzZWdQbGFjZW1lbnRzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgc2VnOiBzZWdzW3NlZ1JlY3QuaW5kZXhdLFxyXG4gICAgICAgICAgICAgICAgcmVjdDogc2VnUmVjdCxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAobGV0IGR1bWJTZWcgb2YgZHVtYlNlZ3MpIHtcclxuICAgICAgICAgICAgc2VnUGxhY2VtZW50cy5wdXNoKHsgc2VnOiBkdW1iU2VnLCByZWN0OiBudWxsIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4geyBzZWdQbGFjZW1lbnRzLCBoaWRkZW5Hcm91cHMgfTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBERUZBVUxUX1RJTUVfRk9STUFUJDEgPSBjcmVhdGVGb3JtYXR0ZXIoe1xyXG4gICAgICAgIGhvdXI6ICdudW1lcmljJyxcclxuICAgICAgICBtaW51dGU6ICcyLWRpZ2l0JyxcclxuICAgICAgICBtZXJpZGllbTogZmFsc2UsXHJcbiAgICB9KTtcclxuICAgIGNsYXNzIFRpbWVDb2xFdmVudCBleHRlbmRzIEJhc2VDb21wb25lbnQge1xyXG4gICAgICAgIHJlbmRlcigpIHtcclxuICAgICAgICAgICAgcmV0dXJuICh5KFN0YW5kYXJkRXZlbnQsIE9iamVjdC5hc3NpZ24oe30sIHRoaXMucHJvcHMsIHsgZWxDbGFzc2VzOiBbXHJcbiAgICAgICAgICAgICAgICAgICAgJ2ZjLXRpbWVncmlkLWV2ZW50JyxcclxuICAgICAgICAgICAgICAgICAgICAnZmMtdi1ldmVudCcsXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5pc1Nob3J0ICYmICdmYy10aW1lZ3JpZC1ldmVudC1zaG9ydCcsXHJcbiAgICAgICAgICAgICAgICBdLCBkZWZhdWx0VGltZUZvcm1hdDogREVGQVVMVF9USU1FX0ZPUk1BVCQxIH0pKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNsYXNzIFRpbWVDb2wgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcclxuICAgICAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgdGhpcy5zb3J0RXZlbnRTZWdzID0gbWVtb2l6ZShzb3J0RXZlbnRTZWdzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVE9ETzogbWVtb2l6ZSBldmVudC1wbGFjZW1lbnQ/XHJcbiAgICAgICAgcmVuZGVyKCkge1xyXG4gICAgICAgICAgICBsZXQgeyBwcm9wcywgY29udGV4dCB9ID0gdGhpcztcclxuICAgICAgICAgICAgbGV0IHsgb3B0aW9ucyB9ID0gY29udGV4dDtcclxuICAgICAgICAgICAgbGV0IGlzU2VsZWN0TWlycm9yID0gb3B0aW9ucy5zZWxlY3RNaXJyb3I7XHJcbiAgICAgICAgICAgIGxldCBtaXJyb3JTZWdzID0gLy8geXVja1xyXG4gICAgICAgICAgICAgKHByb3BzLmV2ZW50RHJhZyAmJiBwcm9wcy5ldmVudERyYWcuc2VncykgfHxcclxuICAgICAgICAgICAgICAgIChwcm9wcy5ldmVudFJlc2l6ZSAmJiBwcm9wcy5ldmVudFJlc2l6ZS5zZWdzKSB8fFxyXG4gICAgICAgICAgICAgICAgKGlzU2VsZWN0TWlycm9yICYmIHByb3BzLmRhdGVTZWxlY3Rpb25TZWdzKSB8fFxyXG4gICAgICAgICAgICAgICAgW107XHJcbiAgICAgICAgICAgIGxldCBpbnRlcmFjdGlvbkFmZmVjdGVkSW5zdGFuY2VzID0gLy8gVE9ETzogbWVzc3kgd2F5IHRvIGNvbXB1dGUgdGhpc1xyXG4gICAgICAgICAgICAgKHByb3BzLmV2ZW50RHJhZyAmJiBwcm9wcy5ldmVudERyYWcuYWZmZWN0ZWRJbnN0YW5jZXMpIHx8XHJcbiAgICAgICAgICAgICAgICAocHJvcHMuZXZlbnRSZXNpemUgJiYgcHJvcHMuZXZlbnRSZXNpemUuYWZmZWN0ZWRJbnN0YW5jZXMpIHx8XHJcbiAgICAgICAgICAgICAgICB7fTtcclxuICAgICAgICAgICAgbGV0IHNvcnRlZEZnU2VncyA9IHRoaXMuc29ydEV2ZW50U2Vncyhwcm9wcy5mZ0V2ZW50U2Vncywgb3B0aW9ucy5ldmVudE9yZGVyKTtcclxuICAgICAgICAgICAgcmV0dXJuICh5KERheUNlbGxDb250YWluZXIsIHsgZWxUYWc6IFwidGRcIiwgZWxSZWY6IHByb3BzLmVsUmVmLCBlbENsYXNzZXM6IFtcclxuICAgICAgICAgICAgICAgICAgICAnZmMtdGltZWdyaWQtY29sJyxcclxuICAgICAgICAgICAgICAgICAgICAuLi4ocHJvcHMuZXh0cmFDbGFzc05hbWVzIHx8IFtdKSxcclxuICAgICAgICAgICAgICAgIF0sIGVsQXR0cnM6IE9iamVjdC5hc3NpZ24oeyByb2xlOiAnZ3JpZGNlbGwnIH0sIHByb3BzLmV4dHJhRGF0YUF0dHJzKSwgZGF0ZTogcHJvcHMuZGF0ZSwgZGF0ZVByb2ZpbGU6IHByb3BzLmRhdGVQcm9maWxlLCB0b2RheVJhbmdlOiBwcm9wcy50b2RheVJhbmdlLCBleHRyYVJlbmRlclByb3BzOiBwcm9wcy5leHRyYVJlbmRlclByb3BzIH0sIChJbm5lckNvbnRlbnQpID0+ICh5KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLXRpbWVncmlkLWNvbC1mcmFtZVwiIH0sXHJcbiAgICAgICAgICAgICAgICB5KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLXRpbWVncmlkLWNvbC1iZ1wiIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJGaWxsU2Vncyhwcm9wcy5idXNpbmVzc0hvdXJTZWdzLCAnbm9uLWJ1c2luZXNzJyksXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJGaWxsU2Vncyhwcm9wcy5iZ0V2ZW50U2VncywgJ2JnLWV2ZW50JyksXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJGaWxsU2Vncyhwcm9wcy5kYXRlU2VsZWN0aW9uU2VncywgJ2hpZ2hsaWdodCcpKSxcclxuICAgICAgICAgICAgICAgIHkoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtdGltZWdyaWQtY29sLWV2ZW50c1wiIH0sIHRoaXMucmVuZGVyRmdTZWdzKHNvcnRlZEZnU2VncywgaW50ZXJhY3Rpb25BZmZlY3RlZEluc3RhbmNlcywgZmFsc2UsIGZhbHNlLCBmYWxzZSkpLFxyXG4gICAgICAgICAgICAgICAgeShcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy10aW1lZ3JpZC1jb2wtZXZlbnRzXCIgfSwgdGhpcy5yZW5kZXJGZ1NlZ3MobWlycm9yU2Vncywge30sIEJvb2xlYW4ocHJvcHMuZXZlbnREcmFnKSwgQm9vbGVhbihwcm9wcy5ldmVudFJlc2l6ZSksIEJvb2xlYW4oaXNTZWxlY3RNaXJyb3IpLCAnbWlycm9yJykpLFxyXG4gICAgICAgICAgICAgICAgeShcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy10aW1lZ3JpZC1ub3ctaW5kaWNhdG9yLWNvbnRhaW5lclwiIH0sIHRoaXMucmVuZGVyTm93SW5kaWNhdG9yKHByb3BzLm5vd0luZGljYXRvclNlZ3MpKSxcclxuICAgICAgICAgICAgICAgIGhhc0N1c3RvbURheUNlbGxDb250ZW50KG9wdGlvbnMpICYmICh5KElubmVyQ29udGVudCwgeyBlbFRhZzogXCJkaXZcIiwgZWxDbGFzc2VzOiBbJ2ZjLXRpbWVncmlkLWNvbC1taXNjJ10gfSkpKSkpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVuZGVyRmdTZWdzKHNvcnRlZEZnU2Vncywgc2VnSXNJbnZpc2libGUsIGlzRHJhZ2dpbmcsIGlzUmVzaXppbmcsIGlzRGF0ZVNlbGVjdGluZywgZm9yY2VkS2V5KSB7XHJcbiAgICAgICAgICAgIGxldCB7IHByb3BzIH0gPSB0aGlzO1xyXG4gICAgICAgICAgICBpZiAocHJvcHMuZm9yUHJpbnQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZW5kZXJQbGFpbkZnU2Vncyhzb3J0ZWRGZ1NlZ3MsIHByb3BzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJQb3NpdGlvbmVkRmdTZWdzKHNvcnRlZEZnU2Vncywgc2VnSXNJbnZpc2libGUsIGlzRHJhZ2dpbmcsIGlzUmVzaXppbmcsIGlzRGF0ZVNlbGVjdGluZywgZm9yY2VkS2V5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVuZGVyUG9zaXRpb25lZEZnU2VncyhzZWdzLCAvLyBpZiBub3QgbWlycm9yLCBuZWVkcyB0byBiZSBzb3J0ZWRcclxuICAgICAgICBzZWdJc0ludmlzaWJsZSwgaXNEcmFnZ2luZywgaXNSZXNpemluZywgaXNEYXRlU2VsZWN0aW5nLCBmb3JjZWRLZXkpIHtcclxuICAgICAgICAgICAgbGV0IHsgZXZlbnRNYXhTdGFjaywgZXZlbnRTaG9ydEhlaWdodCwgZXZlbnRPcmRlclN0cmljdCwgZXZlbnRNaW5IZWlnaHQgfSA9IHRoaXMuY29udGV4dC5vcHRpb25zO1xyXG4gICAgICAgICAgICBsZXQgeyBkYXRlLCBzbGF0Q29vcmRzLCBldmVudFNlbGVjdGlvbiwgdG9kYXlSYW5nZSwgbm93RGF0ZSB9ID0gdGhpcy5wcm9wcztcclxuICAgICAgICAgICAgbGV0IGlzTWlycm9yID0gaXNEcmFnZ2luZyB8fCBpc1Jlc2l6aW5nIHx8IGlzRGF0ZVNlbGVjdGluZztcclxuICAgICAgICAgICAgbGV0IHNlZ1ZDb29yZHMgPSBjb21wdXRlU2VnVkNvb3JkcyhzZWdzLCBkYXRlLCBzbGF0Q29vcmRzLCBldmVudE1pbkhlaWdodCk7XHJcbiAgICAgICAgICAgIGxldCB7IHNlZ1BsYWNlbWVudHMsIGhpZGRlbkdyb3VwcyB9ID0gY29tcHV0ZUZnU2VnUGxhY2VtZW50cyhzZWdzLCBzZWdWQ29vcmRzLCBldmVudE9yZGVyU3RyaWN0LCBldmVudE1heFN0YWNrKTtcclxuICAgICAgICAgICAgcmV0dXJuICh5KF8sIG51bGwsXHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlckhpZGRlbkdyb3VwcyhoaWRkZW5Hcm91cHMsIHNlZ3MpLFxyXG4gICAgICAgICAgICAgICAgc2VnUGxhY2VtZW50cy5tYXAoKHNlZ1BsYWNlbWVudCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCB7IHNlZywgcmVjdCB9ID0gc2VnUGxhY2VtZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBpbnN0YW5jZUlkID0gc2VnLmV2ZW50UmFuZ2UuaW5zdGFuY2UuaW5zdGFuY2VJZDtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgaXNWaXNpYmxlID0gaXNNaXJyb3IgfHwgQm9vbGVhbighc2VnSXNJbnZpc2libGVbaW5zdGFuY2VJZF0gJiYgcmVjdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHZTdHlsZSA9IGNvbXB1dGVTZWdWU3R5bGUocmVjdCAmJiByZWN0LnNwYW4pO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBoU3R5bGUgPSAoIWlzTWlycm9yICYmIHJlY3QpID8gdGhpcy5jb21wdXRlU2VnSFN0eWxlKHJlY3QpIDogeyBsZWZ0OiAwLCByaWdodDogMCB9O1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBpc0luc2V0ID0gQm9vbGVhbihyZWN0KSAmJiByZWN0LnN0YWNrRm9yd2FyZCA+IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGlzU2hvcnQgPSBCb29sZWFuKHJlY3QpICYmIChyZWN0LnNwYW4uZW5kIC0gcmVjdC5zcGFuLnN0YXJ0KSA8IGV2ZW50U2hvcnRIZWlnaHQ7IC8vIGxvb2sgYXQgb3RoZXIgcGxhY2VzIGZvciB0aGlzIHByb2JsZW1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHkoXCJkaXZcIiwgeyBjbGFzc05hbWU6ICdmYy10aW1lZ3JpZC1ldmVudC1oYXJuZXNzJyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoaXNJbnNldCA/ICcgZmMtdGltZWdyaWQtZXZlbnQtaGFybmVzcy1pbnNldCcgOiAnJyksIGtleTogZm9yY2VkS2V5IHx8IGluc3RhbmNlSWQsIHN0eWxlOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyB2aXNpYmlsaXR5OiBpc1Zpc2libGUgPyAnJyA6ICdoaWRkZW4nIH0sIHZTdHlsZSksIGhTdHlsZSkgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgeShUaW1lQ29sRXZlbnQsIE9iamVjdC5hc3NpZ24oeyBzZWc6IHNlZywgaXNEcmFnZ2luZzogaXNEcmFnZ2luZywgaXNSZXNpemluZzogaXNSZXNpemluZywgaXNEYXRlU2VsZWN0aW5nOiBpc0RhdGVTZWxlY3RpbmcsIGlzU2VsZWN0ZWQ6IGluc3RhbmNlSWQgPT09IGV2ZW50U2VsZWN0aW9uLCBpc1Nob3J0OiBpc1Nob3J0IH0sIGdldFNlZ01ldGEoc2VnLCB0b2RheVJhbmdlLCBub3dEYXRlKSkpKSk7XHJcbiAgICAgICAgICAgICAgICB9KSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyB3aWxsIGFscmVhZHkgaGF2ZSBldmVudE1pbkhlaWdodCBhcHBsaWVkIGJlY2F1c2Ugc2VnSW5wdXRzIGFscmVhZHkgaGFkIGl0XHJcbiAgICAgICAgcmVuZGVySGlkZGVuR3JvdXBzKGhpZGRlbkdyb3Vwcywgc2Vncykge1xyXG4gICAgICAgICAgICBsZXQgeyBleHRyYURhdGVTcGFuLCBkYXRlUHJvZmlsZSwgdG9kYXlSYW5nZSwgbm93RGF0ZSwgZXZlbnRTZWxlY3Rpb24sIGV2ZW50RHJhZywgZXZlbnRSZXNpemUgfSA9IHRoaXMucHJvcHM7XHJcbiAgICAgICAgICAgIHJldHVybiAoeShfLCBudWxsLCBoaWRkZW5Hcm91cHMubWFwKChoaWRkZW5Hcm91cCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgbGV0IHBvc2l0aW9uQ3NzID0gY29tcHV0ZVNlZ1ZTdHlsZShoaWRkZW5Hcm91cC5zcGFuKTtcclxuICAgICAgICAgICAgICAgIGxldCBoaWRkZW5TZWdzID0gY29tcGlsZVNlZ3NGcm9tRW50cmllcyhoaWRkZW5Hcm91cC5lbnRyaWVzLCBzZWdzKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiAoeShUaW1lQ29sTW9yZUxpbmssIHsga2V5OiBidWlsZElzb1N0cmluZyhjb21wdXRlRWFybGllc3RTZWdTdGFydChoaWRkZW5TZWdzKSksIGhpZGRlblNlZ3M6IGhpZGRlblNlZ3MsIHRvcDogcG9zaXRpb25Dc3MudG9wLCBib3R0b206IHBvc2l0aW9uQ3NzLmJvdHRvbSwgZXh0cmFEYXRlU3BhbjogZXh0cmFEYXRlU3BhbiwgZGF0ZVByb2ZpbGU6IGRhdGVQcm9maWxlLCB0b2RheVJhbmdlOiB0b2RheVJhbmdlLCBub3dEYXRlOiBub3dEYXRlLCBldmVudFNlbGVjdGlvbjogZXZlbnRTZWxlY3Rpb24sIGV2ZW50RHJhZzogZXZlbnREcmFnLCBldmVudFJlc2l6ZTogZXZlbnRSZXNpemUgfSkpO1xyXG4gICAgICAgICAgICB9KSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZW5kZXJGaWxsU2VncyhzZWdzLCBmaWxsVHlwZSkge1xyXG4gICAgICAgICAgICBsZXQgeyBwcm9wcywgY29udGV4dCB9ID0gdGhpcztcclxuICAgICAgICAgICAgbGV0IHNlZ1ZDb29yZHMgPSBjb21wdXRlU2VnVkNvb3JkcyhzZWdzLCBwcm9wcy5kYXRlLCBwcm9wcy5zbGF0Q29vcmRzLCBjb250ZXh0Lm9wdGlvbnMuZXZlbnRNaW5IZWlnaHQpOyAvLyBkb24ndCBhc3N1bWUgYWxsIHBvcHVsYXRlZFxyXG4gICAgICAgICAgICBsZXQgY2hpbGRyZW4gPSBzZWdWQ29vcmRzLm1hcCgodmNvb3JkcywgaSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgbGV0IHNlZyA9IHNlZ3NbaV07XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKHkoXCJkaXZcIiwgeyBrZXk6IGJ1aWxkRXZlbnRSYW5nZUtleShzZWcuZXZlbnRSYW5nZSksIGNsYXNzTmFtZTogXCJmYy10aW1lZ3JpZC1iZy1oYXJuZXNzXCIsIHN0eWxlOiBjb21wdXRlU2VnVlN0eWxlKHZjb29yZHMpIH0sIGZpbGxUeXBlID09PSAnYmctZXZlbnQnID9cclxuICAgICAgICAgICAgICAgICAgICB5KEJnRXZlbnQsIE9iamVjdC5hc3NpZ24oeyBzZWc6IHNlZyB9LCBnZXRTZWdNZXRhKHNlZywgcHJvcHMudG9kYXlSYW5nZSwgcHJvcHMubm93RGF0ZSkpKSA6XHJcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyRmlsbChmaWxsVHlwZSkpKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiB5KF8sIG51bGwsIGNoaWxkcmVuKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVuZGVyTm93SW5kaWNhdG9yKHNlZ3MpIHtcclxuICAgICAgICAgICAgbGV0IHsgc2xhdENvb3JkcywgZGF0ZSB9ID0gdGhpcy5wcm9wcztcclxuICAgICAgICAgICAgaWYgKCFzbGF0Q29vcmRzKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gc2Vncy5tYXAoKHNlZywgaSkgPT4gKHkoTm93SW5kaWNhdG9yQ29udGFpbmVyXHJcbiAgICAgICAgICAgIC8vIGtleSBkb2Vzbid0IG1hdHRlci4gd2lsbCBvbmx5IGV2ZXIgYmUgb25lXHJcbiAgICAgICAgICAgICwgeyBcclxuICAgICAgICAgICAgICAgIC8vIGtleSBkb2Vzbid0IG1hdHRlci4gd2lsbCBvbmx5IGV2ZXIgYmUgb25lXHJcbiAgICAgICAgICAgICAgICBrZXk6IGksIGVsQ2xhc3NlczogWydmYy10aW1lZ3JpZC1ub3ctaW5kaWNhdG9yLWxpbmUnXSwgZWxTdHlsZToge1xyXG4gICAgICAgICAgICAgICAgICAgIHRvcDogc2xhdENvb3Jkcy5jb21wdXRlRGF0ZVRvcChzZWcuc3RhcnQsIGRhdGUpLFxyXG4gICAgICAgICAgICAgICAgfSwgaXNBeGlzOiBmYWxzZSwgZGF0ZTogZGF0ZSB9KSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb21wdXRlU2VnSFN0eWxlKHNlZ0hDb29yZHMpIHtcclxuICAgICAgICAgICAgbGV0IHsgaXNSdGwsIG9wdGlvbnMgfSA9IHRoaXMuY29udGV4dDtcclxuICAgICAgICAgICAgbGV0IHNob3VsZE92ZXJsYXAgPSBvcHRpb25zLnNsb3RFdmVudE92ZXJsYXA7XHJcbiAgICAgICAgICAgIGxldCBuZWFyQ29vcmQgPSBzZWdIQ29vcmRzLmxldmVsQ29vcmQ7IC8vIHRoZSBsZWZ0IHNpZGUgaWYgTFRSLiB0aGUgcmlnaHQgc2lkZSBpZiBSVEwuIGZsb2F0aW5nLXBvaW50XHJcbiAgICAgICAgICAgIGxldCBmYXJDb29yZCA9IHNlZ0hDb29yZHMubGV2ZWxDb29yZCArIHNlZ0hDb29yZHMudGhpY2tuZXNzOyAvLyB0aGUgcmlnaHQgc2lkZSBpZiBMVFIuIHRoZSBsZWZ0IHNpZGUgaWYgUlRMLiBmbG9hdGluZy1wb2ludFxyXG4gICAgICAgICAgICBsZXQgbGVmdDsgLy8gYW1vdW50IG9mIHNwYWNlIGZyb20gbGVmdCBlZGdlLCBhIGZyYWN0aW9uIG9mIHRoZSB0b3RhbCB3aWR0aFxyXG4gICAgICAgICAgICBsZXQgcmlnaHQ7IC8vIGFtb3VudCBvZiBzcGFjZSBmcm9tIHJpZ2h0IGVkZ2UsIGEgZnJhY3Rpb24gb2YgdGhlIHRvdGFsIHdpZHRoXHJcbiAgICAgICAgICAgIGlmIChzaG91bGRPdmVybGFwKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBkb3VibGUgdGhlIHdpZHRoLCBidXQgZG9uJ3QgZ28gYmV5b25kIHRoZSBtYXhpbXVtIGZvcndhcmQgY29vcmRpbmF0ZSAoMS4wKVxyXG4gICAgICAgICAgICAgICAgZmFyQ29vcmQgPSBNYXRoLm1pbigxLCBuZWFyQ29vcmQgKyAoZmFyQ29vcmQgLSBuZWFyQ29vcmQpICogMik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGlzUnRsKSB7XHJcbiAgICAgICAgICAgICAgICBsZWZ0ID0gMSAtIGZhckNvb3JkO1xyXG4gICAgICAgICAgICAgICAgcmlnaHQgPSBuZWFyQ29vcmQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBsZWZ0ID0gbmVhckNvb3JkO1xyXG4gICAgICAgICAgICAgICAgcmlnaHQgPSAxIC0gZmFyQ29vcmQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IHByb3BzID0ge1xyXG4gICAgICAgICAgICAgICAgekluZGV4OiBzZWdIQ29vcmRzLnN0YWNrRGVwdGggKyAxLFxyXG4gICAgICAgICAgICAgICAgbGVmdDogbGVmdCAqIDEwMCArICclJyxcclxuICAgICAgICAgICAgICAgIHJpZ2h0OiByaWdodCAqIDEwMCArICclJyxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgaWYgKHNob3VsZE92ZXJsYXAgJiYgIXNlZ0hDb29yZHMuc3RhY2tGb3J3YXJkKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBhZGQgcGFkZGluZyB0byB0aGUgZWRnZSBzbyB0aGF0IGZvcndhcmQgc3RhY2tlZCBldmVudHMgZG9uJ3QgY292ZXIgdGhlIHJlc2l6ZXIncyBpY29uXHJcbiAgICAgICAgICAgICAgICBwcm9wc1tpc1J0bCA/ICdtYXJnaW5MZWZ0JyA6ICdtYXJnaW5SaWdodCddID0gMTAgKiAyOyAvLyAxMCBpcyBhIGd1ZXNzdGltYXRlIG9mIHRoZSBpY29uJ3Mgd2lkdGhcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcHJvcHM7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gcmVuZGVyUGxhaW5GZ1NlZ3Moc29ydGVkRmdTZWdzLCB7IHRvZGF5UmFuZ2UsIG5vd0RhdGUsIGV2ZW50U2VsZWN0aW9uLCBldmVudERyYWcsIGV2ZW50UmVzaXplIH0pIHtcclxuICAgICAgICBsZXQgaGlkZGVuSW5zdGFuY2VzID0gKGV2ZW50RHJhZyA/IGV2ZW50RHJhZy5hZmZlY3RlZEluc3RhbmNlcyA6IG51bGwpIHx8XHJcbiAgICAgICAgICAgIChldmVudFJlc2l6ZSA/IGV2ZW50UmVzaXplLmFmZmVjdGVkSW5zdGFuY2VzIDogbnVsbCkgfHxcclxuICAgICAgICAgICAge307XHJcbiAgICAgICAgcmV0dXJuICh5KF8sIG51bGwsIHNvcnRlZEZnU2Vncy5tYXAoKHNlZykgPT4ge1xyXG4gICAgICAgICAgICBsZXQgaW5zdGFuY2VJZCA9IHNlZy5ldmVudFJhbmdlLmluc3RhbmNlLmluc3RhbmNlSWQ7XHJcbiAgICAgICAgICAgIHJldHVybiAoeShcImRpdlwiLCB7IGtleTogaW5zdGFuY2VJZCwgc3R5bGU6IHsgdmlzaWJpbGl0eTogaGlkZGVuSW5zdGFuY2VzW2luc3RhbmNlSWRdID8gJ2hpZGRlbicgOiAnJyB9IH0sXHJcbiAgICAgICAgICAgICAgICB5KFRpbWVDb2xFdmVudCwgT2JqZWN0LmFzc2lnbih7IHNlZzogc2VnLCBpc0RyYWdnaW5nOiBmYWxzZSwgaXNSZXNpemluZzogZmFsc2UsIGlzRGF0ZVNlbGVjdGluZzogZmFsc2UsIGlzU2VsZWN0ZWQ6IGluc3RhbmNlSWQgPT09IGV2ZW50U2VsZWN0aW9uLCBpc1Nob3J0OiBmYWxzZSB9LCBnZXRTZWdNZXRhKHNlZywgdG9kYXlSYW5nZSwgbm93RGF0ZSkpKSkpO1xyXG4gICAgICAgIH0pKSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBjb21wdXRlU2VnVlN0eWxlKHNlZ1ZDb29yZHMpIHtcclxuICAgICAgICBpZiAoIXNlZ1ZDb29yZHMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHsgdG9wOiAnJywgYm90dG9tOiAnJyB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB0b3A6IHNlZ1ZDb29yZHMuc3RhcnQsXHJcbiAgICAgICAgICAgIGJvdHRvbTogLXNlZ1ZDb29yZHMuZW5kLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBjb21waWxlU2Vnc0Zyb21FbnRyaWVzKHNlZ0VudHJpZXMsIGFsbFNlZ3MpIHtcclxuICAgICAgICByZXR1cm4gc2VnRW50cmllcy5tYXAoKHNlZ0VudHJ5KSA9PiBhbGxTZWdzW3NlZ0VudHJ5LmluZGV4XSk7XHJcbiAgICB9XHJcblxyXG4gICAgY2xhc3MgVGltZUNvbHNDb250ZW50IGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XHJcbiAgICAgICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgIHRoaXMuc3BsaXRGZ0V2ZW50U2VncyA9IG1lbW9pemUoc3BsaXRTZWdzQnlDb2wpO1xyXG4gICAgICAgICAgICB0aGlzLnNwbGl0QmdFdmVudFNlZ3MgPSBtZW1vaXplKHNwbGl0U2Vnc0J5Q29sKTtcclxuICAgICAgICAgICAgdGhpcy5zcGxpdEJ1c2luZXNzSG91clNlZ3MgPSBtZW1vaXplKHNwbGl0U2Vnc0J5Q29sKTtcclxuICAgICAgICAgICAgdGhpcy5zcGxpdE5vd0luZGljYXRvclNlZ3MgPSBtZW1vaXplKHNwbGl0U2Vnc0J5Q29sKTtcclxuICAgICAgICAgICAgdGhpcy5zcGxpdERhdGVTZWxlY3Rpb25TZWdzID0gbWVtb2l6ZShzcGxpdFNlZ3NCeUNvbCk7XHJcbiAgICAgICAgICAgIHRoaXMuc3BsaXRFdmVudERyYWcgPSBtZW1vaXplKHNwbGl0SW50ZXJhY3Rpb25CeUNvbCk7XHJcbiAgICAgICAgICAgIHRoaXMuc3BsaXRFdmVudFJlc2l6ZSA9IG1lbW9pemUoc3BsaXRJbnRlcmFjdGlvbkJ5Q29sKTtcclxuICAgICAgICAgICAgdGhpcy5yb290RWxSZWYgPSBkKCk7XHJcbiAgICAgICAgICAgIHRoaXMuY2VsbEVsUmVmcyA9IG5ldyBSZWZNYXAoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVuZGVyKCkge1xyXG4gICAgICAgICAgICBsZXQgeyBwcm9wcywgY29udGV4dCB9ID0gdGhpcztcclxuICAgICAgICAgICAgbGV0IG5vd0luZGljYXRvclRvcCA9IGNvbnRleHQub3B0aW9ucy5ub3dJbmRpY2F0b3IgJiZcclxuICAgICAgICAgICAgICAgIHByb3BzLnNsYXRDb29yZHMgJiZcclxuICAgICAgICAgICAgICAgIHByb3BzLnNsYXRDb29yZHMuc2FmZUNvbXB1dGVUb3AocHJvcHMubm93RGF0ZSk7IC8vIG1pZ2h0IHJldHVybiB2b2lkXHJcbiAgICAgICAgICAgIGxldCBjb2xDbnQgPSBwcm9wcy5jZWxscy5sZW5ndGg7XHJcbiAgICAgICAgICAgIGxldCBmZ0V2ZW50U2Vnc0J5Um93ID0gdGhpcy5zcGxpdEZnRXZlbnRTZWdzKHByb3BzLmZnRXZlbnRTZWdzLCBjb2xDbnQpO1xyXG4gICAgICAgICAgICBsZXQgYmdFdmVudFNlZ3NCeVJvdyA9IHRoaXMuc3BsaXRCZ0V2ZW50U2Vncyhwcm9wcy5iZ0V2ZW50U2VncywgY29sQ250KTtcclxuICAgICAgICAgICAgbGV0IGJ1c2luZXNzSG91clNlZ3NCeVJvdyA9IHRoaXMuc3BsaXRCdXNpbmVzc0hvdXJTZWdzKHByb3BzLmJ1c2luZXNzSG91clNlZ3MsIGNvbENudCk7XHJcbiAgICAgICAgICAgIGxldCBub3dJbmRpY2F0b3JTZWdzQnlSb3cgPSB0aGlzLnNwbGl0Tm93SW5kaWNhdG9yU2Vncyhwcm9wcy5ub3dJbmRpY2F0b3JTZWdzLCBjb2xDbnQpO1xyXG4gICAgICAgICAgICBsZXQgZGF0ZVNlbGVjdGlvblNlZ3NCeVJvdyA9IHRoaXMuc3BsaXREYXRlU2VsZWN0aW9uU2Vncyhwcm9wcy5kYXRlU2VsZWN0aW9uU2VncywgY29sQ250KTtcclxuICAgICAgICAgICAgbGV0IGV2ZW50RHJhZ0J5Um93ID0gdGhpcy5zcGxpdEV2ZW50RHJhZyhwcm9wcy5ldmVudERyYWcsIGNvbENudCk7XHJcbiAgICAgICAgICAgIGxldCBldmVudFJlc2l6ZUJ5Um93ID0gdGhpcy5zcGxpdEV2ZW50UmVzaXplKHByb3BzLmV2ZW50UmVzaXplLCBjb2xDbnQpO1xyXG4gICAgICAgICAgICByZXR1cm4gKHkoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtdGltZWdyaWQtY29sc1wiLCByZWY6IHRoaXMucm9vdEVsUmVmIH0sXHJcbiAgICAgICAgICAgICAgICB5KFwidGFibGVcIiwgeyByb2xlOiBcInByZXNlbnRhdGlvblwiLCBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5XaWR0aDogcHJvcHMudGFibGVNaW5XaWR0aCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHByb3BzLmNsaWVudFdpZHRoLFxyXG4gICAgICAgICAgICAgICAgICAgIH0gfSxcclxuICAgICAgICAgICAgICAgICAgICBwcm9wcy50YWJsZUNvbEdyb3VwTm9kZSxcclxuICAgICAgICAgICAgICAgICAgICB5KFwidGJvZHlcIiwgeyByb2xlOiBcInByZXNlbnRhdGlvblwiIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHkoXCJ0clwiLCB7IHJvbGU6IFwicm93XCIgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzLmF4aXMgJiYgKHkoXCJ0ZFwiLCB7IFwiYXJpYS1oaWRkZW5cIjogdHJ1ZSwgY2xhc3NOYW1lOiBcImZjLXRpbWVncmlkLWNvbCBmYy10aW1lZ3JpZC1heGlzXCIgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLXRpbWVncmlkLWNvbC1mcmFtZVwiIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtdGltZWdyaWQtbm93LWluZGljYXRvci1jb250YWluZXJcIiB9LCB0eXBlb2Ygbm93SW5kaWNhdG9yVG9wID09PSAnbnVtYmVyJyAmJiAoeShOb3dJbmRpY2F0b3JDb250YWluZXIsIHsgZWxDbGFzc2VzOiBbJ2ZjLXRpbWVncmlkLW5vdy1pbmRpY2F0b3ItYXJyb3cnXSwgZWxTdHlsZTogeyB0b3A6IG5vd0luZGljYXRvclRvcCB9LCBpc0F4aXM6IHRydWUsIGRhdGU6IHByb3BzLm5vd0RhdGUgfSkpKSkpKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzLmNlbGxzLm1hcCgoY2VsbCwgaSkgPT4gKHkoVGltZUNvbCwgeyBrZXk6IGNlbGwua2V5LCBlbFJlZjogdGhpcy5jZWxsRWxSZWZzLmNyZWF0ZVJlZihjZWxsLmtleSksIGRhdGVQcm9maWxlOiBwcm9wcy5kYXRlUHJvZmlsZSwgZGF0ZTogY2VsbC5kYXRlLCBub3dEYXRlOiBwcm9wcy5ub3dEYXRlLCB0b2RheVJhbmdlOiBwcm9wcy50b2RheVJhbmdlLCBleHRyYVJlbmRlclByb3BzOiBjZWxsLmV4dHJhUmVuZGVyUHJvcHMsIGV4dHJhRGF0YUF0dHJzOiBjZWxsLmV4dHJhRGF0YUF0dHJzLCBleHRyYUNsYXNzTmFtZXM6IGNlbGwuZXh0cmFDbGFzc05hbWVzLCBleHRyYURhdGVTcGFuOiBjZWxsLmV4dHJhRGF0ZVNwYW4sIGZnRXZlbnRTZWdzOiBmZ0V2ZW50U2Vnc0J5Um93W2ldLCBiZ0V2ZW50U2VnczogYmdFdmVudFNlZ3NCeVJvd1tpXSwgYnVzaW5lc3NIb3VyU2VnczogYnVzaW5lc3NIb3VyU2Vnc0J5Um93W2ldLCBub3dJbmRpY2F0b3JTZWdzOiBub3dJbmRpY2F0b3JTZWdzQnlSb3dbaV0sIGRhdGVTZWxlY3Rpb25TZWdzOiBkYXRlU2VsZWN0aW9uU2Vnc0J5Um93W2ldLCBldmVudERyYWc6IGV2ZW50RHJhZ0J5Um93W2ldLCBldmVudFJlc2l6ZTogZXZlbnRSZXNpemVCeVJvd1tpXSwgc2xhdENvb3JkczogcHJvcHMuc2xhdENvb3JkcywgZXZlbnRTZWxlY3Rpb246IHByb3BzLmV2ZW50U2VsZWN0aW9uLCBmb3JQcmludDogcHJvcHMuZm9yUHJpbnQgfSkpKSkpKSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb21wb25lbnREaWRNb3VudCgpIHtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVDb29yZHMoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29tcG9uZW50RGlkVXBkYXRlKCkge1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUNvb3JkcygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB1cGRhdGVDb29yZHMoKSB7XHJcbiAgICAgICAgICAgIGxldCB7IHByb3BzIH0gPSB0aGlzO1xyXG4gICAgICAgICAgICBpZiAocHJvcHMub25Db2xDb29yZHMgJiZcclxuICAgICAgICAgICAgICAgIHByb3BzLmNsaWVudFdpZHRoICE9PSBudWxsIC8vIG1lYW5zIHNpemluZyBoYXMgc3RhYmlsaXplZFxyXG4gICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICAgIHByb3BzLm9uQ29sQ29vcmRzKG5ldyBQb3NpdGlvbkNhY2hlKHRoaXMucm9vdEVsUmVmLmN1cnJlbnQsIGNvbGxlY3RDZWxsRWxzKHRoaXMuY2VsbEVsUmVmcy5jdXJyZW50TWFwLCBwcm9wcy5jZWxscyksIHRydWUsIC8vIGhvcml6b250YWxcclxuICAgICAgICAgICAgICAgIGZhbHNlKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBjb2xsZWN0Q2VsbEVscyhlbE1hcCwgY2VsbHMpIHtcclxuICAgICAgICByZXR1cm4gY2VsbHMubWFwKChjZWxsKSA9PiBlbE1hcFtjZWxsLmtleV0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qIEEgY29tcG9uZW50IHRoYXQgcmVuZGVycyBvbmUgb3IgbW9yZSBjb2x1bW5zIG9mIHZlcnRpY2FsIHRpbWUgc2xvdHNcclxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgY2xhc3MgVGltZUNvbHMgZXh0ZW5kcyBEYXRlQ29tcG9uZW50IHtcclxuICAgICAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgdGhpcy5wcm9jZXNzU2xvdE9wdGlvbnMgPSBtZW1vaXplKHByb2Nlc3NTbG90T3B0aW9ucyk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSB7XHJcbiAgICAgICAgICAgICAgICBzbGF0Q29vcmRzOiBudWxsLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB0aGlzLmhhbmRsZVJvb3RFbCA9IChlbCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LnJlZ2lzdGVySW50ZXJhY3RpdmVDb21wb25lbnQodGhpcywge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXNIaXRDb21ib0FsbG93ZWQ6IHRoaXMucHJvcHMuaXNIaXRDb21ib0FsbG93ZWQsXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQudW5yZWdpc3RlckludGVyYWN0aXZlQ29tcG9uZW50KHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB0aGlzLmhhbmRsZVNjcm9sbFJlcXVlc3QgPSAocmVxdWVzdCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgbGV0IHsgb25TY3JvbGxUb3BSZXF1ZXN0IH0gPSB0aGlzLnByb3BzO1xyXG4gICAgICAgICAgICAgICAgbGV0IHsgc2xhdENvb3JkcyB9ID0gdGhpcy5zdGF0ZTtcclxuICAgICAgICAgICAgICAgIGlmIChvblNjcm9sbFRvcFJlcXVlc3QgJiYgc2xhdENvb3Jkcykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXF1ZXN0LnRpbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHRvcCA9IHNsYXRDb29yZHMuY29tcHV0ZVRpbWVUb3AocmVxdWVzdC50aW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdG9wID0gTWF0aC5jZWlsKHRvcCk7IC8vIHpvb20gY2FuIGdpdmUgd2VpcmQgZmxvYXRpbmctcG9pbnQgdmFsdWVzLiByYXRoZXIgc2Nyb2xsIGEgbGl0dGxlIGJpdCBmdXJ0aGVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0b3ApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcCArPSAxOyAvLyB0byBvdmVyY29tZSB0b3AgYm9yZGVyIHRoYXQgc2xvdHMgYmV5b25kIHRoZSBmaXJzdCBoYXZlLiBsb29rcyBiZXR0ZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvblNjcm9sbFRvcFJlcXVlc3QodG9wKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlQ29sQ29vcmRzID0gKGNvbENvb3JkcykgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb2xDb29yZHMgPSBjb2xDb29yZHM7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlU2xhdENvb3JkcyA9IChzbGF0Q29vcmRzKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKHsgc2xhdENvb3JkcyB9KTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnByb3BzLm9uU2xhdENvb3Jkcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJvcHMub25TbGF0Q29vcmRzKHNsYXRDb29yZHMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZW5kZXIoKSB7XHJcbiAgICAgICAgICAgIGxldCB7IHByb3BzLCBzdGF0ZSB9ID0gdGhpcztcclxuICAgICAgICAgICAgcmV0dXJuICh5KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLXRpbWVncmlkLWJvZHlcIiwgcmVmOiB0aGlzLmhhbmRsZVJvb3RFbCwgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgICAgICAvLyB0aGVzZSBwcm9wcyBhcmUgaW1wb3J0YW50IHRvIGdpdmUgdGhpcyB3cmFwcGVyIGNvcnJlY3QgZGltZW5zaW9ucyBmb3IgaW50ZXJhY3Rpb25zXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogaWYgd2Ugc2V0IGl0IGhlcmUsIGNhbiB3ZSBhdm9pZCBnaXZpbmcgdG8gaW5uZXIgdGFibGVzP1xyXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBwcm9wcy5jbGllbnRXaWR0aCxcclxuICAgICAgICAgICAgICAgICAgICBtaW5XaWR0aDogcHJvcHMudGFibGVNaW5XaWR0aCxcclxuICAgICAgICAgICAgICAgIH0gfSxcclxuICAgICAgICAgICAgICAgIHkoVGltZUNvbHNTbGF0cywgeyBheGlzOiBwcm9wcy5heGlzLCBkYXRlUHJvZmlsZTogcHJvcHMuZGF0ZVByb2ZpbGUsIHNsYXRNZXRhczogcHJvcHMuc2xhdE1ldGFzLCBjbGllbnRXaWR0aDogcHJvcHMuY2xpZW50V2lkdGgsIG1pbkhlaWdodDogcHJvcHMuZXhwYW5kUm93cyA/IHByb3BzLmNsaWVudEhlaWdodCA6ICcnLCB0YWJsZU1pbldpZHRoOiBwcm9wcy50YWJsZU1pbldpZHRoLCB0YWJsZUNvbEdyb3VwTm9kZTogcHJvcHMuYXhpcyA/IHByb3BzLnRhYmxlQ29sR3JvdXBOb2RlIDogbnVsbCAvKiBheGlzIGRlcGVuZHMgb24gdGhlIGNvbGdyb3VwJ3Mgc2hyaW5raW5nICovLCBvbkNvb3JkczogdGhpcy5oYW5kbGVTbGF0Q29vcmRzIH0pLFxyXG4gICAgICAgICAgICAgICAgeShUaW1lQ29sc0NvbnRlbnQsIHsgY2VsbHM6IHByb3BzLmNlbGxzLCBheGlzOiBwcm9wcy5heGlzLCBkYXRlUHJvZmlsZTogcHJvcHMuZGF0ZVByb2ZpbGUsIGJ1c2luZXNzSG91clNlZ3M6IHByb3BzLmJ1c2luZXNzSG91clNlZ3MsIGJnRXZlbnRTZWdzOiBwcm9wcy5iZ0V2ZW50U2VncywgZmdFdmVudFNlZ3M6IHByb3BzLmZnRXZlbnRTZWdzLCBkYXRlU2VsZWN0aW9uU2VnczogcHJvcHMuZGF0ZVNlbGVjdGlvblNlZ3MsIGV2ZW50U2VsZWN0aW9uOiBwcm9wcy5ldmVudFNlbGVjdGlvbiwgZXZlbnREcmFnOiBwcm9wcy5ldmVudERyYWcsIGV2ZW50UmVzaXplOiBwcm9wcy5ldmVudFJlc2l6ZSwgdG9kYXlSYW5nZTogcHJvcHMudG9kYXlSYW5nZSwgbm93RGF0ZTogcHJvcHMubm93RGF0ZSwgbm93SW5kaWNhdG9yU2VnczogcHJvcHMubm93SW5kaWNhdG9yU2VncywgY2xpZW50V2lkdGg6IHByb3BzLmNsaWVudFdpZHRoLCB0YWJsZU1pbldpZHRoOiBwcm9wcy50YWJsZU1pbldpZHRoLCB0YWJsZUNvbEdyb3VwTm9kZTogcHJvcHMudGFibGVDb2xHcm91cE5vZGUsIHNsYXRDb29yZHM6IHN0YXRlLnNsYXRDb29yZHMsIG9uQ29sQ29vcmRzOiB0aGlzLmhhbmRsZUNvbENvb3JkcywgZm9yUHJpbnQ6IHByb3BzLmZvclByaW50IH0pKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xyXG4gICAgICAgICAgICB0aGlzLnNjcm9sbFJlc3BvbmRlciA9IHRoaXMuY29udGV4dC5jcmVhdGVTY3JvbGxSZXNwb25kZXIodGhpcy5oYW5kbGVTY3JvbGxSZXF1ZXN0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcykge1xyXG4gICAgICAgICAgICB0aGlzLnNjcm9sbFJlc3BvbmRlci51cGRhdGUocHJldlByb3BzLmRhdGVQcm9maWxlICE9PSB0aGlzLnByb3BzLmRhdGVQcm9maWxlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsUmVzcG9uZGVyLmRldGFjaCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBxdWVyeUhpdChwb3NpdGlvbkxlZnQsIHBvc2l0aW9uVG9wKSB7XHJcbiAgICAgICAgICAgIGxldCB7IGRhdGVFbnYsIG9wdGlvbnMgfSA9IHRoaXMuY29udGV4dDtcclxuICAgICAgICAgICAgbGV0IHsgY29sQ29vcmRzIH0gPSB0aGlzO1xyXG4gICAgICAgICAgICBsZXQgeyBkYXRlUHJvZmlsZSB9ID0gdGhpcy5wcm9wcztcclxuICAgICAgICAgICAgbGV0IHsgc2xhdENvb3JkcyB9ID0gdGhpcy5zdGF0ZTtcclxuICAgICAgICAgICAgbGV0IHsgc25hcER1cmF0aW9uLCBzbmFwc1BlclNsb3QgfSA9IHRoaXMucHJvY2Vzc1Nsb3RPcHRpb25zKHRoaXMucHJvcHMuc2xvdER1cmF0aW9uLCBvcHRpb25zLnNuYXBEdXJhdGlvbik7XHJcbiAgICAgICAgICAgIGxldCBjb2xJbmRleCA9IGNvbENvb3Jkcy5sZWZ0VG9JbmRleChwb3NpdGlvbkxlZnQpO1xyXG4gICAgICAgICAgICBsZXQgc2xhdEluZGV4ID0gc2xhdENvb3Jkcy5wb3NpdGlvbnMudG9wVG9JbmRleChwb3NpdGlvblRvcCk7XHJcbiAgICAgICAgICAgIGlmIChjb2xJbmRleCAhPSBudWxsICYmIHNsYXRJbmRleCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgY2VsbCA9IHRoaXMucHJvcHMuY2VsbHNbY29sSW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgbGV0IHNsYXRUb3AgPSBzbGF0Q29vcmRzLnBvc2l0aW9ucy50b3BzW3NsYXRJbmRleF07XHJcbiAgICAgICAgICAgICAgICBsZXQgc2xhdEhlaWdodCA9IHNsYXRDb29yZHMucG9zaXRpb25zLmdldEhlaWdodChzbGF0SW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgbGV0IHBhcnRpYWwgPSAocG9zaXRpb25Ub3AgLSBzbGF0VG9wKSAvIHNsYXRIZWlnaHQ7IC8vIGZsb2F0aW5nIHBvaW50IG51bWJlciBiZXR3ZWVuIDAgYW5kIDFcclxuICAgICAgICAgICAgICAgIGxldCBsb2NhbFNuYXBJbmRleCA9IE1hdGguZmxvb3IocGFydGlhbCAqIHNuYXBzUGVyU2xvdCk7IC8vIHRoZSBzbmFwICMgcmVsYXRpdmUgdG8gc3RhcnQgb2Ygc2xhdFxyXG4gICAgICAgICAgICAgICAgbGV0IHNuYXBJbmRleCA9IHNsYXRJbmRleCAqIHNuYXBzUGVyU2xvdCArIGxvY2FsU25hcEluZGV4O1xyXG4gICAgICAgICAgICAgICAgbGV0IGRheURhdGUgPSB0aGlzLnByb3BzLmNlbGxzW2NvbEluZGV4XS5kYXRlO1xyXG4gICAgICAgICAgICAgICAgbGV0IHRpbWUgPSBhZGREdXJhdGlvbnMoZGF0ZVByb2ZpbGUuc2xvdE1pblRpbWUsIG11bHRpcGx5RHVyYXRpb24oc25hcER1cmF0aW9uLCBzbmFwSW5kZXgpKTtcclxuICAgICAgICAgICAgICAgIGxldCBzdGFydCA9IGRhdGVFbnYuYWRkKGRheURhdGUsIHRpbWUpO1xyXG4gICAgICAgICAgICAgICAgbGV0IGVuZCA9IGRhdGVFbnYuYWRkKHN0YXJ0LCBzbmFwRHVyYXRpb24pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICBkYXRlUHJvZmlsZSxcclxuICAgICAgICAgICAgICAgICAgICBkYXRlU3BhbjogT2JqZWN0LmFzc2lnbih7IHJhbmdlOiB7IHN0YXJ0LCBlbmQgfSwgYWxsRGF5OiBmYWxzZSB9LCBjZWxsLmV4dHJhRGF0ZVNwYW4pLFxyXG4gICAgICAgICAgICAgICAgICAgIGRheUVsOiBjb2xDb29yZHMuZWxzW2NvbEluZGV4XSxcclxuICAgICAgICAgICAgICAgICAgICByZWN0OiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IGNvbENvb3Jkcy5sZWZ0c1tjb2xJbmRleF0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0OiBjb2xDb29yZHMucmlnaHRzW2NvbEluZGV4XSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiBzbGF0VG9wLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBib3R0b206IHNsYXRUb3AgKyBzbGF0SGVpZ2h0LFxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgbGF5ZXI6IDAsXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHByb2Nlc3NTbG90T3B0aW9ucyhzbG90RHVyYXRpb24sIHNuYXBEdXJhdGlvbk92ZXJyaWRlKSB7XHJcbiAgICAgICAgbGV0IHNuYXBEdXJhdGlvbiA9IHNuYXBEdXJhdGlvbk92ZXJyaWRlIHx8IHNsb3REdXJhdGlvbjtcclxuICAgICAgICBsZXQgc25hcHNQZXJTbG90ID0gd2hvbGVEaXZpZGVEdXJhdGlvbnMoc2xvdER1cmF0aW9uLCBzbmFwRHVyYXRpb24pO1xyXG4gICAgICAgIGlmIChzbmFwc1BlclNsb3QgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgc25hcER1cmF0aW9uID0gc2xvdER1cmF0aW9uO1xyXG4gICAgICAgICAgICBzbmFwc1BlclNsb3QgPSAxO1xyXG4gICAgICAgICAgICAvLyBUT0RPOiBzYXkgd2FybmluZz9cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHsgc25hcER1cmF0aW9uLCBzbmFwc1BlclNsb3QgfTtcclxuICAgIH1cclxuXHJcbiAgICBjbGFzcyBEYXlUaW1lQ29sc1NsaWNlciBleHRlbmRzIFNsaWNlciB7XHJcbiAgICAgICAgc2xpY2VSYW5nZShyYW5nZSwgZGF5UmFuZ2VzKSB7XHJcbiAgICAgICAgICAgIGxldCBzZWdzID0gW107XHJcbiAgICAgICAgICAgIGZvciAobGV0IGNvbCA9IDA7IGNvbCA8IGRheVJhbmdlcy5sZW5ndGg7IGNvbCArPSAxKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgc2VnUmFuZ2UgPSBpbnRlcnNlY3RSYW5nZXMocmFuZ2UsIGRheVJhbmdlc1tjb2xdKTtcclxuICAgICAgICAgICAgICAgIGlmIChzZWdSYW5nZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlZ3MucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBzZWdSYW5nZS5zdGFydCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiBzZWdSYW5nZS5lbmQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzU3RhcnQ6IHNlZ1JhbmdlLnN0YXJ0LnZhbHVlT2YoKSA9PT0gcmFuZ2Uuc3RhcnQudmFsdWVPZigpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0VuZDogc2VnUmFuZ2UuZW5kLnZhbHVlT2YoKSA9PT0gcmFuZ2UuZW5kLnZhbHVlT2YoKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29sLFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBzZWdzO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBjbGFzcyBEYXlUaW1lQ29scyBleHRlbmRzIERhdGVDb21wb25lbnQge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgICAgICB0aGlzLmJ1aWxkRGF5UmFuZ2VzID0gbWVtb2l6ZShidWlsZERheVJhbmdlcyk7XHJcbiAgICAgICAgICAgIHRoaXMuc2xpY2VyID0gbmV3IERheVRpbWVDb2xzU2xpY2VyKCk7XHJcbiAgICAgICAgICAgIHRoaXMudGltZUNvbHNSZWYgPSBkKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlbmRlcigpIHtcclxuICAgICAgICAgICAgbGV0IHsgcHJvcHMsIGNvbnRleHQgfSA9IHRoaXM7XHJcbiAgICAgICAgICAgIGxldCB7IGRhdGVQcm9maWxlLCBkYXlUYWJsZU1vZGVsIH0gPSBwcm9wcztcclxuICAgICAgICAgICAgbGV0IHsgbm93SW5kaWNhdG9yLCBuZXh0RGF5VGhyZXNob2xkIH0gPSBjb250ZXh0Lm9wdGlvbnM7XHJcbiAgICAgICAgICAgIGxldCBkYXlSYW5nZXMgPSB0aGlzLmJ1aWxkRGF5UmFuZ2VzKGRheVRhYmxlTW9kZWwsIGRhdGVQcm9maWxlLCBjb250ZXh0LmRhdGVFbnYpO1xyXG4gICAgICAgICAgICAvLyBnaXZlIGl0IHRoZSBmaXJzdCByb3cgb2YgY2VsbHNcclxuICAgICAgICAgICAgLy8gVE9ETzogd291bGQgbW92ZSB0aGlzIGZ1cnRoZXIgZG93biBoaWVyYXJjaHksIGJ1dCBzbGljZU5vd0RhdGUgbmVlZHMgaXRcclxuICAgICAgICAgICAgcmV0dXJuICh5KE5vd1RpbWVyLCB7IHVuaXQ6IG5vd0luZGljYXRvciA/ICdtaW51dGUnIDogJ2RheScgfSwgKG5vd0RhdGUsIHRvZGF5UmFuZ2UpID0+ICh5KFRpbWVDb2xzLCBPYmplY3QuYXNzaWduKHsgcmVmOiB0aGlzLnRpbWVDb2xzUmVmIH0sIHRoaXMuc2xpY2VyLnNsaWNlUHJvcHMocHJvcHMsIGRhdGVQcm9maWxlLCBudWxsLCBjb250ZXh0LCBkYXlSYW5nZXMpLCB7IGZvclByaW50OiBwcm9wcy5mb3JQcmludCwgYXhpczogcHJvcHMuYXhpcywgZGF0ZVByb2ZpbGU6IGRhdGVQcm9maWxlLCBzbGF0TWV0YXM6IHByb3BzLnNsYXRNZXRhcywgc2xvdER1cmF0aW9uOiBwcm9wcy5zbG90RHVyYXRpb24sIGNlbGxzOiBkYXlUYWJsZU1vZGVsLmNlbGxzWzBdLCB0YWJsZUNvbEdyb3VwTm9kZTogcHJvcHMudGFibGVDb2xHcm91cE5vZGUsIHRhYmxlTWluV2lkdGg6IHByb3BzLnRhYmxlTWluV2lkdGgsIGNsaWVudFdpZHRoOiBwcm9wcy5jbGllbnRXaWR0aCwgY2xpZW50SGVpZ2h0OiBwcm9wcy5jbGllbnRIZWlnaHQsIGV4cGFuZFJvd3M6IHByb3BzLmV4cGFuZFJvd3MsIG5vd0RhdGU6IG5vd0RhdGUsIG5vd0luZGljYXRvclNlZ3M6IG5vd0luZGljYXRvciAmJiB0aGlzLnNsaWNlci5zbGljZU5vd0RhdGUobm93RGF0ZSwgZGF0ZVByb2ZpbGUsIG5leHREYXlUaHJlc2hvbGQsIGNvbnRleHQsIGRheVJhbmdlcyksIHRvZGF5UmFuZ2U6IHRvZGF5UmFuZ2UsIG9uU2Nyb2xsVG9wUmVxdWVzdDogcHJvcHMub25TY3JvbGxUb3BSZXF1ZXN0LCBvblNsYXRDb29yZHM6IHByb3BzLm9uU2xhdENvb3JkcyB9KSkpKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYnVpbGREYXlSYW5nZXMoZGF5VGFibGVNb2RlbCwgZGF0ZVByb2ZpbGUsIGRhdGVFbnYpIHtcclxuICAgICAgICBsZXQgcmFuZ2VzID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgZGF0ZSBvZiBkYXlUYWJsZU1vZGVsLmhlYWRlckRhdGVzKSB7XHJcbiAgICAgICAgICAgIHJhbmdlcy5wdXNoKHtcclxuICAgICAgICAgICAgICAgIHN0YXJ0OiBkYXRlRW52LmFkZChkYXRlLCBkYXRlUHJvZmlsZS5zbG90TWluVGltZSksXHJcbiAgICAgICAgICAgICAgICBlbmQ6IGRhdGVFbnYuYWRkKGRhdGUsIGRhdGVQcm9maWxlLnNsb3RNYXhUaW1lKSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByYW5nZXM7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gcG90ZW50aWFsIG5pY2UgdmFsdWVzIGZvciB0aGUgc2xvdC1kdXJhdGlvbiBhbmQgaW50ZXJ2YWwtZHVyYXRpb25cclxuICAgIC8vIGZyb20gbGFyZ2VzdCB0byBzbWFsbGVzdFxyXG4gICAgY29uc3QgU1RPQ0tfU1VCX0RVUkFUSU9OUyA9IFtcclxuICAgICAgICB7IGhvdXJzOiAxIH0sXHJcbiAgICAgICAgeyBtaW51dGVzOiAzMCB9LFxyXG4gICAgICAgIHsgbWludXRlczogMTUgfSxcclxuICAgICAgICB7IHNlY29uZHM6IDMwIH0sXHJcbiAgICAgICAgeyBzZWNvbmRzOiAxNSB9LFxyXG4gICAgXTtcclxuICAgIGZ1bmN0aW9uIGJ1aWxkU2xhdE1ldGFzKHNsb3RNaW5UaW1lLCBzbG90TWF4VGltZSwgZXhwbGljaXRMYWJlbEludGVydmFsLCBzbG90RHVyYXRpb24sIGRhdGVFbnYpIHtcclxuICAgICAgICBsZXQgZGF5U3RhcnQgPSBuZXcgRGF0ZSgwKTtcclxuICAgICAgICBsZXQgc2xhdFRpbWUgPSBzbG90TWluVGltZTtcclxuICAgICAgICBsZXQgc2xhdEl0ZXJhdG9yID0gY3JlYXRlRHVyYXRpb24oMCk7XHJcbiAgICAgICAgbGV0IGxhYmVsSW50ZXJ2YWwgPSBleHBsaWNpdExhYmVsSW50ZXJ2YWwgfHwgY29tcHV0ZUxhYmVsSW50ZXJ2YWwoc2xvdER1cmF0aW9uKTtcclxuICAgICAgICBsZXQgbWV0YXMgPSBbXTtcclxuICAgICAgICB3aGlsZSAoYXNSb3VnaE1zKHNsYXRUaW1lKSA8IGFzUm91Z2hNcyhzbG90TWF4VGltZSkpIHtcclxuICAgICAgICAgICAgbGV0IGRhdGUgPSBkYXRlRW52LmFkZChkYXlTdGFydCwgc2xhdFRpbWUpO1xyXG4gICAgICAgICAgICBsZXQgaXNMYWJlbGVkID0gd2hvbGVEaXZpZGVEdXJhdGlvbnMoc2xhdEl0ZXJhdG9yLCBsYWJlbEludGVydmFsKSAhPT0gbnVsbDtcclxuICAgICAgICAgICAgbWV0YXMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICBkYXRlLFxyXG4gICAgICAgICAgICAgICAgdGltZTogc2xhdFRpbWUsXHJcbiAgICAgICAgICAgICAgICBrZXk6IGRhdGUudG9JU09TdHJpbmcoKSxcclxuICAgICAgICAgICAgICAgIGlzb1RpbWVTdHI6IGZvcm1hdElzb1RpbWVTdHJpbmcoZGF0ZSksXHJcbiAgICAgICAgICAgICAgICBpc0xhYmVsZWQsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBzbGF0VGltZSA9IGFkZER1cmF0aW9ucyhzbGF0VGltZSwgc2xvdER1cmF0aW9uKTtcclxuICAgICAgICAgICAgc2xhdEl0ZXJhdG9yID0gYWRkRHVyYXRpb25zKHNsYXRJdGVyYXRvciwgc2xvdER1cmF0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG1ldGFzO1xyXG4gICAgfVxyXG4gICAgLy8gQ29tcHV0ZXMgYW4gYXV0b21hdGljIHZhbHVlIGZvciBzbG90TGFiZWxJbnRlcnZhbFxyXG4gICAgZnVuY3Rpb24gY29tcHV0ZUxhYmVsSW50ZXJ2YWwoc2xvdER1cmF0aW9uKSB7XHJcbiAgICAgICAgbGV0IGk7XHJcbiAgICAgICAgbGV0IGxhYmVsSW50ZXJ2YWw7XHJcbiAgICAgICAgbGV0IHNsb3RzUGVyTGFiZWw7XHJcbiAgICAgICAgLy8gZmluZCB0aGUgc21hbGxlc3Qgc3RvY2sgbGFiZWwgaW50ZXJ2YWwgdGhhdCByZXN1bHRzIGluIG1vcmUgdGhhbiBvbmUgc2xvdHMtcGVyLWxhYmVsXHJcbiAgICAgICAgZm9yIChpID0gU1RPQ0tfU1VCX0RVUkFUSU9OUy5sZW5ndGggLSAxOyBpID49IDA7IGkgLT0gMSkge1xyXG4gICAgICAgICAgICBsYWJlbEludGVydmFsID0gY3JlYXRlRHVyYXRpb24oU1RPQ0tfU1VCX0RVUkFUSU9OU1tpXSk7XHJcbiAgICAgICAgICAgIHNsb3RzUGVyTGFiZWwgPSB3aG9sZURpdmlkZUR1cmF0aW9ucyhsYWJlbEludGVydmFsLCBzbG90RHVyYXRpb24pO1xyXG4gICAgICAgICAgICBpZiAoc2xvdHNQZXJMYWJlbCAhPT0gbnVsbCAmJiBzbG90c1BlckxhYmVsID4gMSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxhYmVsSW50ZXJ2YWw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHNsb3REdXJhdGlvbjsgLy8gZmFsbCBiYWNrXHJcbiAgICB9XHJcblxyXG4gICAgY2xhc3MgRGF5VGltZUNvbHNWaWV3IGV4dGVuZHMgVGltZUNvbHNWaWV3IHtcclxuICAgICAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgdGhpcy5idWlsZFRpbWVDb2xzTW9kZWwgPSBtZW1vaXplKGJ1aWxkVGltZUNvbHNNb2RlbCk7XHJcbiAgICAgICAgICAgIHRoaXMuYnVpbGRTbGF0TWV0YXMgPSBtZW1vaXplKGJ1aWxkU2xhdE1ldGFzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVuZGVyKCkge1xyXG4gICAgICAgICAgICBsZXQgeyBvcHRpb25zLCBkYXRlRW52LCBkYXRlUHJvZmlsZUdlbmVyYXRvciB9ID0gdGhpcy5jb250ZXh0O1xyXG4gICAgICAgICAgICBsZXQgeyBwcm9wcyB9ID0gdGhpcztcclxuICAgICAgICAgICAgbGV0IHsgZGF0ZVByb2ZpbGUgfSA9IHByb3BzO1xyXG4gICAgICAgICAgICBsZXQgZGF5VGFibGVNb2RlbCA9IHRoaXMuYnVpbGRUaW1lQ29sc01vZGVsKGRhdGVQcm9maWxlLCBkYXRlUHJvZmlsZUdlbmVyYXRvcik7XHJcbiAgICAgICAgICAgIGxldCBzcGxpdFByb3BzID0gdGhpcy5hbGxEYXlTcGxpdHRlci5zcGxpdFByb3BzKHByb3BzKTtcclxuICAgICAgICAgICAgbGV0IHNsYXRNZXRhcyA9IHRoaXMuYnVpbGRTbGF0TWV0YXMoZGF0ZVByb2ZpbGUuc2xvdE1pblRpbWUsIGRhdGVQcm9maWxlLnNsb3RNYXhUaW1lLCBvcHRpb25zLnNsb3RMYWJlbEludGVydmFsLCBvcHRpb25zLnNsb3REdXJhdGlvbiwgZGF0ZUVudik7XHJcbiAgICAgICAgICAgIGxldCB7IGRheU1pbldpZHRoIH0gPSBvcHRpb25zO1xyXG4gICAgICAgICAgICBsZXQgaGFzQXR0YWNoZWRBeGlzID0gIWRheU1pbldpZHRoO1xyXG4gICAgICAgICAgICBsZXQgaGFzRGV0YWNoZWRBeGlzID0gZGF5TWluV2lkdGg7XHJcbiAgICAgICAgICAgIGxldCBoZWFkZXJDb250ZW50ID0gb3B0aW9ucy5kYXlIZWFkZXJzICYmICh5KERheUhlYWRlciwgeyBkYXRlczogZGF5VGFibGVNb2RlbC5oZWFkZXJEYXRlcywgZGF0ZVByb2ZpbGU6IGRhdGVQcm9maWxlLCBkYXRlc1JlcERpc3RpbmN0RGF5czogdHJ1ZSwgcmVuZGVySW50cm86IGhhc0F0dGFjaGVkQXhpcyA/IHRoaXMucmVuZGVySGVhZEF4aXMgOiBudWxsIH0pKTtcclxuICAgICAgICAgICAgbGV0IGFsbERheUNvbnRlbnQgPSAob3B0aW9ucy5hbGxEYXlTbG90ICE9PSBmYWxzZSkgJiYgKChjb250ZW50QXJnKSA9PiAoeShEYXlUYWJsZSwgT2JqZWN0LmFzc2lnbih7fSwgc3BsaXRQcm9wcy5hbGxEYXksIHsgZGF0ZVByb2ZpbGU6IGRhdGVQcm9maWxlLCBkYXlUYWJsZU1vZGVsOiBkYXlUYWJsZU1vZGVsLCBuZXh0RGF5VGhyZXNob2xkOiBvcHRpb25zLm5leHREYXlUaHJlc2hvbGQsIHRhYmxlTWluV2lkdGg6IGNvbnRlbnRBcmcudGFibGVNaW5XaWR0aCwgY29sR3JvdXBOb2RlOiBjb250ZW50QXJnLnRhYmxlQ29sR3JvdXBOb2RlLCByZW5kZXJSb3dJbnRybzogaGFzQXR0YWNoZWRBeGlzID8gdGhpcy5yZW5kZXJUYWJsZVJvd0F4aXMgOiBudWxsLCBzaG93V2Vla051bWJlcnM6IGZhbHNlLCBleHBhbmRSb3dzOiBmYWxzZSwgaGVhZGVyQWxpZ25FbFJlZjogdGhpcy5oZWFkZXJFbFJlZiwgY2xpZW50V2lkdGg6IGNvbnRlbnRBcmcuY2xpZW50V2lkdGgsIGNsaWVudEhlaWdodDogY29udGVudEFyZy5jbGllbnRIZWlnaHQsIGZvclByaW50OiBwcm9wcy5mb3JQcmludCB9LCB0aGlzLmdldEFsbERheU1heEV2ZW50UHJvcHMoKSkpKSk7XHJcbiAgICAgICAgICAgIGxldCB0aW1lR3JpZENvbnRlbnQgPSAoY29udGVudEFyZykgPT4gKHkoRGF5VGltZUNvbHMsIE9iamVjdC5hc3NpZ24oe30sIHNwbGl0UHJvcHMudGltZWQsIHsgZGF5VGFibGVNb2RlbDogZGF5VGFibGVNb2RlbCwgZGF0ZVByb2ZpbGU6IGRhdGVQcm9maWxlLCBheGlzOiBoYXNBdHRhY2hlZEF4aXMsIHNsb3REdXJhdGlvbjogb3B0aW9ucy5zbG90RHVyYXRpb24sIHNsYXRNZXRhczogc2xhdE1ldGFzLCBmb3JQcmludDogcHJvcHMuZm9yUHJpbnQsIHRhYmxlQ29sR3JvdXBOb2RlOiBjb250ZW50QXJnLnRhYmxlQ29sR3JvdXBOb2RlLCB0YWJsZU1pbldpZHRoOiBjb250ZW50QXJnLnRhYmxlTWluV2lkdGgsIGNsaWVudFdpZHRoOiBjb250ZW50QXJnLmNsaWVudFdpZHRoLCBjbGllbnRIZWlnaHQ6IGNvbnRlbnRBcmcuY2xpZW50SGVpZ2h0LCBvblNsYXRDb29yZHM6IHRoaXMuaGFuZGxlU2xhdENvb3JkcywgZXhwYW5kUm93czogY29udGVudEFyZy5leHBhbmRSb3dzLCBvblNjcm9sbFRvcFJlcXVlc3Q6IHRoaXMuaGFuZGxlU2Nyb2xsVG9wUmVxdWVzdCB9KSkpO1xyXG4gICAgICAgICAgICByZXR1cm4gaGFzRGV0YWNoZWRBeGlzXHJcbiAgICAgICAgICAgICAgICA/IHRoaXMucmVuZGVySFNjcm9sbExheW91dChoZWFkZXJDb250ZW50LCBhbGxEYXlDb250ZW50LCB0aW1lR3JpZENvbnRlbnQsIGRheVRhYmxlTW9kZWwuY29sQ250LCBkYXlNaW5XaWR0aCwgc2xhdE1ldGFzLCB0aGlzLnN0YXRlLnNsYXRDb29yZHMpXHJcbiAgICAgICAgICAgICAgICA6IHRoaXMucmVuZGVyU2ltcGxlTGF5b3V0KGhlYWRlckNvbnRlbnQsIGFsbERheUNvbnRlbnQsIHRpbWVHcmlkQ29udGVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYnVpbGRUaW1lQ29sc01vZGVsKGRhdGVQcm9maWxlLCBkYXRlUHJvZmlsZUdlbmVyYXRvcikge1xyXG4gICAgICAgIGxldCBkYXlTZXJpZXMgPSBuZXcgRGF5U2VyaWVzTW9kZWwoZGF0ZVByb2ZpbGUucmVuZGVyUmFuZ2UsIGRhdGVQcm9maWxlR2VuZXJhdG9yKTtcclxuICAgICAgICByZXR1cm4gbmV3IERheVRhYmxlTW9kZWwoZGF5U2VyaWVzLCBmYWxzZSk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgT1BUSU9OX1JFRklORVJTJDIgPSB7XHJcbiAgICAgICAgYWxsRGF5U2xvdDogQm9vbGVhbixcclxuICAgIH07XHJcblxyXG4gICAgdmFyIGluZGV4JDIgPSBjcmVhdGVQbHVnaW4oe1xyXG4gICAgICAgIG5hbWU6ICdAZnVsbGNhbGVuZGFyL3RpbWVncmlkJyxcclxuICAgICAgICBpbml0aWFsVmlldzogJ3RpbWVHcmlkV2VlaycsXHJcbiAgICAgICAgb3B0aW9uUmVmaW5lcnM6IE9QVElPTl9SRUZJTkVSUyQyLFxyXG4gICAgICAgIHZpZXdzOiB7XHJcbiAgICAgICAgICAgIHRpbWVHcmlkOiB7XHJcbiAgICAgICAgICAgICAgICBjb21wb25lbnQ6IERheVRpbWVDb2xzVmlldyxcclxuICAgICAgICAgICAgICAgIHVzZXNNaW5NYXhUaW1lOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgYWxsRGF5U2xvdDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIHNsb3REdXJhdGlvbjogJzAwOjMwOjAwJyxcclxuICAgICAgICAgICAgICAgIHNsb3RFdmVudE92ZXJsYXA6IHRydWUsIC8vIGEgYmFkIG5hbWUuIGNvbmZ1c2VkIHdpdGggb3ZlcmxhcC9jb25zdHJhaW50IHN5c3RlbVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB0aW1lR3JpZERheToge1xyXG4gICAgICAgICAgICAgICAgdHlwZTogJ3RpbWVHcmlkJyxcclxuICAgICAgICAgICAgICAgIGR1cmF0aW9uOiB7IGRheXM6IDEgfSxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgdGltZUdyaWRXZWVrOiB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiAndGltZUdyaWQnLFxyXG4gICAgICAgICAgICAgICAgZHVyYXRpb246IHsgd2Vla3M6IDEgfSxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9LFxyXG4gICAgfSk7XHJcblxyXG4gICAgdmFyIGNzc18yNDh6JDEgPSBcIjpyb290ey0tZmMtbGlzdC1ldmVudC1kb3Qtd2lkdGg6MTBweDstLWZjLWxpc3QtZXZlbnQtaG92ZXItYmctY29sb3I6I2Y1ZjVmNX0uZmMtdGhlbWUtc3RhbmRhcmQgLmZjLWxpc3R7Ym9yZGVyOjFweCBzb2xpZCB2YXIoLS1mYy1ib3JkZXItY29sb3IpfS5mYyAuZmMtbGlzdC1lbXB0eXthbGlnbi1pdGVtczpjZW50ZXI7YmFja2dyb3VuZC1jb2xvcjp2YXIoLS1mYy1uZXV0cmFsLWJnLWNvbG9yKTtkaXNwbGF5OmZsZXg7aGVpZ2h0OjEwMCU7anVzdGlmeS1jb250ZW50OmNlbnRlcn0uZmMgLmZjLWxpc3QtZW1wdHktY3VzaGlvbnttYXJnaW46NWVtIDB9LmZjIC5mYy1saXN0LXRhYmxle2JvcmRlci1zdHlsZTpoaWRkZW47d2lkdGg6MTAwJX0uZmMgLmZjLWxpc3QtdGFibGUgdHI+Kntib3JkZXItbGVmdDowO2JvcmRlci1yaWdodDowfS5mYyAuZmMtbGlzdC1zdGlja3kgLmZjLWxpc3QtZGF5Pip7YmFja2dyb3VuZDp2YXIoLS1mYy1wYWdlLWJnLWNvbG9yKTtwb3NpdGlvbjpzdGlja3k7dG9wOjB9LmZjIC5mYy1saXN0LXRhYmxlIHRoZWFke2xlZnQ6LTEwMDAwcHg7cG9zaXRpb246YWJzb2x1dGV9LmZjIC5mYy1saXN0LXRhYmxlIHRib2R5PnRyOmZpcnN0LWNoaWxkIHRoe2JvcmRlci10b3A6MH0uZmMgLmZjLWxpc3QtdGFibGUgdGh7cGFkZGluZzowfS5mYyAuZmMtbGlzdC1kYXktY3VzaGlvbiwuZmMgLmZjLWxpc3QtdGFibGUgdGR7cGFkZGluZzo4cHggMTRweH0uZmMgLmZjLWxpc3QtZGF5LWN1c2hpb246YWZ0ZXJ7Y2xlYXI6Ym90aDtjb250ZW50OlxcXCJcXFwiO2Rpc3BsYXk6dGFibGV9LmZjLXRoZW1lLXN0YW5kYXJkIC5mYy1saXN0LWRheS1jdXNoaW9ue2JhY2tncm91bmQtY29sb3I6dmFyKC0tZmMtbmV1dHJhbC1iZy1jb2xvcil9LmZjLWRpcmVjdGlvbi1sdHIgLmZjLWxpc3QtZGF5LXRleHQsLmZjLWRpcmVjdGlvbi1ydGwgLmZjLWxpc3QtZGF5LXNpZGUtdGV4dHtmbG9hdDpsZWZ0fS5mYy1kaXJlY3Rpb24tbHRyIC5mYy1saXN0LWRheS1zaWRlLXRleHQsLmZjLWRpcmVjdGlvbi1ydGwgLmZjLWxpc3QtZGF5LXRleHR7ZmxvYXQ6cmlnaHR9LmZjLWRpcmVjdGlvbi1sdHIgLmZjLWxpc3QtdGFibGUgLmZjLWxpc3QtZXZlbnQtZ3JhcGhpY3twYWRkaW5nLXJpZ2h0OjB9LmZjLWRpcmVjdGlvbi1ydGwgLmZjLWxpc3QtdGFibGUgLmZjLWxpc3QtZXZlbnQtZ3JhcGhpY3twYWRkaW5nLWxlZnQ6MH0uZmMgLmZjLWxpc3QtZXZlbnQuZmMtZXZlbnQtZm9yY2VkLXVybHtjdXJzb3I6cG9pbnRlcn0uZmMgLmZjLWxpc3QtZXZlbnQ6aG92ZXIgdGR7YmFja2dyb3VuZC1jb2xvcjp2YXIoLS1mYy1saXN0LWV2ZW50LWhvdmVyLWJnLWNvbG9yKX0uZmMgLmZjLWxpc3QtZXZlbnQtZ3JhcGhpYywuZmMgLmZjLWxpc3QtZXZlbnQtdGltZXt3aGl0ZS1zcGFjZTpub3dyYXA7d2lkdGg6MXB4fS5mYyAuZmMtbGlzdC1ldmVudC1kb3R7Ym9yZGVyOmNhbGModmFyKC0tZmMtbGlzdC1ldmVudC1kb3Qtd2lkdGgpLzIpIHNvbGlkIHZhcigtLWZjLWV2ZW50LWJvcmRlci1jb2xvcik7Ym9yZGVyLXJhZGl1czpjYWxjKHZhcigtLWZjLWxpc3QtZXZlbnQtZG90LXdpZHRoKS8yKTtib3gtc2l6aW5nOmNvbnRlbnQtYm94O2Rpc3BsYXk6aW5saW5lLWJsb2NrO2hlaWdodDowO3dpZHRoOjB9LmZjIC5mYy1saXN0LWV2ZW50LXRpdGxlIGF7Y29sb3I6aW5oZXJpdDt0ZXh0LWRlY29yYXRpb246bm9uZX0uZmMgLmZjLWxpc3QtZXZlbnQuZmMtZXZlbnQtZm9yY2VkLXVybDpob3ZlciBhe3RleHQtZGVjb3JhdGlvbjp1bmRlcmxpbmV9XCI7XHJcbiAgICBpbmplY3RTdHlsZXMoY3NzXzI0OHokMSk7XHJcblxyXG4gICAgY2xhc3MgTGlzdFZpZXdIZWFkZXJSb3cgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcclxuICAgICAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IHtcclxuICAgICAgICAgICAgICAgIHRleHRJZDogZ2V0VW5pcXVlRG9tSWQoKSxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVuZGVyKCkge1xyXG4gICAgICAgICAgICBsZXQgeyB0aGVtZSwgZGF0ZUVudiwgb3B0aW9ucywgdmlld0FwaSB9ID0gdGhpcy5jb250ZXh0O1xyXG4gICAgICAgICAgICBsZXQgeyBjZWxsSWQsIGRheURhdGUsIHRvZGF5UmFuZ2UgfSA9IHRoaXMucHJvcHM7XHJcbiAgICAgICAgICAgIGxldCB7IHRleHRJZCB9ID0gdGhpcy5zdGF0ZTtcclxuICAgICAgICAgICAgbGV0IGRheU1ldGEgPSBnZXREYXRlTWV0YShkYXlEYXRlLCB0b2RheVJhbmdlKTtcclxuICAgICAgICAgICAgLy8gd2lsbCBldmVyIGJlIGZhbHN5P1xyXG4gICAgICAgICAgICBsZXQgdGV4dCA9IG9wdGlvbnMubGlzdERheUZvcm1hdCA/IGRhdGVFbnYuZm9ybWF0KGRheURhdGUsIG9wdGlvbnMubGlzdERheUZvcm1hdCkgOiAnJztcclxuICAgICAgICAgICAgLy8gd2lsbCBldmVyIGJlIGZhbHN5PyBhbHNvLCBCQUQgTkFNRSBcImFsdFwiXHJcbiAgICAgICAgICAgIGxldCBzaWRlVGV4dCA9IG9wdGlvbnMubGlzdERheVNpZGVGb3JtYXQgPyBkYXRlRW52LmZvcm1hdChkYXlEYXRlLCBvcHRpb25zLmxpc3REYXlTaWRlRm9ybWF0KSA6ICcnO1xyXG4gICAgICAgICAgICBsZXQgcmVuZGVyUHJvcHMgPSBPYmplY3QuYXNzaWduKHsgZGF0ZTogZGF0ZUVudi50b0RhdGUoZGF5RGF0ZSksIHZpZXc6IHZpZXdBcGksIHRleHRJZCxcclxuICAgICAgICAgICAgICAgIHRleHQsXHJcbiAgICAgICAgICAgICAgICBzaWRlVGV4dCwgbmF2TGlua0F0dHJzOiBidWlsZE5hdkxpbmtBdHRycyh0aGlzLmNvbnRleHQsIGRheURhdGUpLCBzaWRlTmF2TGlua0F0dHJzOiBidWlsZE5hdkxpbmtBdHRycyh0aGlzLmNvbnRleHQsIGRheURhdGUsICdkYXknLCBmYWxzZSkgfSwgZGF5TWV0YSk7XHJcbiAgICAgICAgICAgIC8vIFRPRE86IG1ha2UgYSByZXVzYWJsZSBIT0MgZm9yIGRheUhlYWRlciAodXNlZCBpbiBkYXlncmlkL3RpbWVncmlkIHRvbylcclxuICAgICAgICAgICAgcmV0dXJuICh5KENvbnRlbnRDb250YWluZXIsIHsgZWxUYWc6IFwidHJcIiwgZWxDbGFzc2VzOiBbXHJcbiAgICAgICAgICAgICAgICAgICAgJ2ZjLWxpc3QtZGF5JyxcclxuICAgICAgICAgICAgICAgICAgICAuLi5nZXREYXlDbGFzc05hbWVzKGRheU1ldGEsIHRoZW1lKSxcclxuICAgICAgICAgICAgICAgIF0sIGVsQXR0cnM6IHtcclxuICAgICAgICAgICAgICAgICAgICAnZGF0YS1kYXRlJzogZm9ybWF0RGF5U3RyaW5nKGRheURhdGUpLFxyXG4gICAgICAgICAgICAgICAgfSwgcmVuZGVyUHJvcHM6IHJlbmRlclByb3BzLCBnZW5lcmF0b3JOYW1lOiBcImRheUhlYWRlckNvbnRlbnRcIiwgY3VzdG9tR2VuZXJhdG9yOiBvcHRpb25zLmRheUhlYWRlckNvbnRlbnQsIGRlZmF1bHRHZW5lcmF0b3I6IHJlbmRlcklubmVyQ29udGVudCwgY2xhc3NOYW1lR2VuZXJhdG9yOiBvcHRpb25zLmRheUhlYWRlckNsYXNzTmFtZXMsIGRpZE1vdW50OiBvcHRpb25zLmRheUhlYWRlckRpZE1vdW50LCB3aWxsVW5tb3VudDogb3B0aW9ucy5kYXlIZWFkZXJXaWxsVW5tb3VudCB9LCAoSW5uZXJDb250ZW50KSA9PiAoIC8vIFRPRE86IGZvcmNlLWhpZGUgdG9wIGJvcmRlciBiYXNlZCBvbiA6Zmlyc3QtY2hpbGRcclxuICAgICAgICAgICAgeShcInRoXCIsIHsgc2NvcGU6IFwiY29sZ3JvdXBcIiwgY29sU3BhbjogMywgaWQ6IGNlbGxJZCwgXCJhcmlhLWxhYmVsbGVkYnlcIjogdGV4dElkIH0sXHJcbiAgICAgICAgICAgICAgICB5KElubmVyQ29udGVudCwgeyBlbFRhZzogXCJkaXZcIiwgZWxDbGFzc2VzOiBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdmYy1saXN0LWRheS1jdXNoaW9uJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhlbWUuZ2V0Q2xhc3MoJ3RhYmxlQ2VsbFNoYWRlZCcpLFxyXG4gICAgICAgICAgICAgICAgICAgIF0gfSkpKSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHJlbmRlcklubmVyQ29udGVudChwcm9wcykge1xyXG4gICAgICAgIHJldHVybiAoeShfLCBudWxsLFxyXG4gICAgICAgICAgICBwcm9wcy50ZXh0ICYmICh5KFwiYVwiLCBPYmplY3QuYXNzaWduKHsgaWQ6IHByb3BzLnRleHRJZCwgY2xhc3NOYW1lOiBcImZjLWxpc3QtZGF5LXRleHRcIiB9LCBwcm9wcy5uYXZMaW5rQXR0cnMpLCBwcm9wcy50ZXh0KSksXHJcbiAgICAgICAgICAgIHByb3BzLnNpZGVUZXh0ICYmICggLyogbm90IGtleWJvYXJkIHRhYmJhYmxlICoveShcImFcIiwgT2JqZWN0LmFzc2lnbih7IFwiYXJpYS1oaWRkZW5cIjogdHJ1ZSwgY2xhc3NOYW1lOiBcImZjLWxpc3QtZGF5LXNpZGUtdGV4dFwiIH0sIHByb3BzLnNpZGVOYXZMaW5rQXR0cnMpLCBwcm9wcy5zaWRlVGV4dCkpKSk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgREVGQVVMVF9USU1FX0ZPUk1BVCA9IGNyZWF0ZUZvcm1hdHRlcih7XHJcbiAgICAgICAgaG91cjogJ251bWVyaWMnLFxyXG4gICAgICAgIG1pbnV0ZTogJzItZGlnaXQnLFxyXG4gICAgICAgIG1lcmlkaWVtOiAnc2hvcnQnLFxyXG4gICAgfSk7XHJcbiAgICBjbGFzcyBMaXN0Vmlld0V2ZW50Um93IGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XHJcbiAgICAgICAgcmVuZGVyKCkge1xyXG4gICAgICAgICAgICBsZXQgeyBwcm9wcywgY29udGV4dCB9ID0gdGhpcztcclxuICAgICAgICAgICAgbGV0IHsgb3B0aW9ucyB9ID0gY29udGV4dDtcclxuICAgICAgICAgICAgbGV0IHsgc2VnLCB0aW1lSGVhZGVySWQsIGV2ZW50SGVhZGVySWQsIGRhdGVIZWFkZXJJZCB9ID0gcHJvcHM7XHJcbiAgICAgICAgICAgIGxldCB0aW1lRm9ybWF0ID0gb3B0aW9ucy5ldmVudFRpbWVGb3JtYXQgfHwgREVGQVVMVF9USU1FX0ZPUk1BVDtcclxuICAgICAgICAgICAgcmV0dXJuICh5KEV2ZW50Q29udGFpbmVyLCBPYmplY3QuYXNzaWduKHt9LCBwcm9wcywgeyBlbFRhZzogXCJ0clwiLCBlbENsYXNzZXM6IFtcclxuICAgICAgICAgICAgICAgICAgICAnZmMtbGlzdC1ldmVudCcsXHJcbiAgICAgICAgICAgICAgICAgICAgc2VnLmV2ZW50UmFuZ2UuZGVmLnVybCAmJiAnZmMtZXZlbnQtZm9yY2VkLXVybCcsXHJcbiAgICAgICAgICAgICAgICBdLCBkZWZhdWx0R2VuZXJhdG9yOiAoKSA9PiByZW5kZXJFdmVudElubmVyQ29udGVudChzZWcsIGNvbnRleHQpIC8qIHdlaXJkICovLCBzZWc6IHNlZywgdGltZVRleHQ6IFwiXCIsIGRpc2FibGVEcmFnZ2luZzogdHJ1ZSwgZGlzYWJsZVJlc2l6aW5nOiB0cnVlIH0pLCAoSW5uZXJDb250ZW50LCBldmVudENvbnRlbnRBcmcpID0+ICh5KF8sIG51bGwsXHJcbiAgICAgICAgICAgICAgICBidWlsZFRpbWVDb250ZW50KHNlZywgdGltZUZvcm1hdCwgY29udGV4dCwgdGltZUhlYWRlcklkLCBkYXRlSGVhZGVySWQpLFxyXG4gICAgICAgICAgICAgICAgeShcInRkXCIsIHsgXCJhcmlhLWhpZGRlblwiOiB0cnVlLCBjbGFzc05hbWU6IFwiZmMtbGlzdC1ldmVudC1ncmFwaGljXCIgfSxcclxuICAgICAgICAgICAgICAgICAgICB5KFwic3BhblwiLCB7IGNsYXNzTmFtZTogXCJmYy1saXN0LWV2ZW50LWRvdFwiLCBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyQ29sb3I6IGV2ZW50Q29udGVudEFyZy5ib3JkZXJDb2xvciB8fCBldmVudENvbnRlbnRBcmcuYmFja2dyb3VuZENvbG9yLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IH0pKSxcclxuICAgICAgICAgICAgICAgIHkoSW5uZXJDb250ZW50LCB7IGVsVGFnOiBcInRkXCIsIGVsQ2xhc3NlczogWydmYy1saXN0LWV2ZW50LXRpdGxlJ10sIGVsQXR0cnM6IHsgaGVhZGVyczogYCR7ZXZlbnRIZWFkZXJJZH0gJHtkYXRlSGVhZGVySWR9YCB9IH0pKSkpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiByZW5kZXJFdmVudElubmVyQ29udGVudChzZWcsIGNvbnRleHQpIHtcclxuICAgICAgICBsZXQgaW50ZXJhY3RpdmVBdHRycyA9IGdldFNlZ0FuY2hvckF0dHJzKHNlZywgY29udGV4dCk7XHJcbiAgICAgICAgcmV0dXJuICh5KFwiYVwiLCBPYmplY3QuYXNzaWduKHt9LCBpbnRlcmFjdGl2ZUF0dHJzKSwgc2VnLmV2ZW50UmFuZ2UuZGVmLnRpdGxlKSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBidWlsZFRpbWVDb250ZW50KHNlZywgdGltZUZvcm1hdCwgY29udGV4dCwgdGltZUhlYWRlcklkLCBkYXRlSGVhZGVySWQpIHtcclxuICAgICAgICBsZXQgeyBvcHRpb25zIH0gPSBjb250ZXh0O1xyXG4gICAgICAgIGlmIChvcHRpb25zLmRpc3BsYXlFdmVudFRpbWUgIT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIGxldCBldmVudERlZiA9IHNlZy5ldmVudFJhbmdlLmRlZjtcclxuICAgICAgICAgICAgbGV0IGV2ZW50SW5zdGFuY2UgPSBzZWcuZXZlbnRSYW5nZS5pbnN0YW5jZTtcclxuICAgICAgICAgICAgbGV0IGRvQWxsRGF5ID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGxldCB0aW1lVGV4dDtcclxuICAgICAgICAgICAgaWYgKGV2ZW50RGVmLmFsbERheSkge1xyXG4gICAgICAgICAgICAgICAgZG9BbGxEYXkgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzTXVsdGlEYXlSYW5nZShzZWcuZXZlbnRSYW5nZS5yYW5nZSkpIHsgLy8gVE9ETzogdXNlICghaXNTdGFydCB8fCAhaXNFbmQpIGluc3RlYWQ/XHJcbiAgICAgICAgICAgICAgICBpZiAoc2VnLmlzU3RhcnQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aW1lVGV4dCA9IGJ1aWxkU2VnVGltZVRleHQoc2VnLCB0aW1lRm9ybWF0LCBjb250ZXh0LCBudWxsLCBudWxsLCBldmVudEluc3RhbmNlLnJhbmdlLnN0YXJ0LCBzZWcuZW5kKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNlZy5pc0VuZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRpbWVUZXh0ID0gYnVpbGRTZWdUaW1lVGV4dChzZWcsIHRpbWVGb3JtYXQsIGNvbnRleHQsIG51bGwsIG51bGwsIHNlZy5zdGFydCwgZXZlbnRJbnN0YW5jZS5yYW5nZS5lbmQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZG9BbGxEYXkgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGltZVRleHQgPSBidWlsZFNlZ1RpbWVUZXh0KHNlZywgdGltZUZvcm1hdCwgY29udGV4dCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGRvQWxsRGF5KSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgcmVuZGVyUHJvcHMgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogY29udGV4dC5vcHRpb25zLmFsbERheVRleHQsXHJcbiAgICAgICAgICAgICAgICAgICAgdmlldzogY29udGV4dC52aWV3QXBpLFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIHJldHVybiAoeShDb250ZW50Q29udGFpbmVyLCB7IGVsVGFnOiBcInRkXCIsIGVsQ2xhc3NlczogWydmYy1saXN0LWV2ZW50LXRpbWUnXSwgZWxBdHRyczoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBgJHt0aW1lSGVhZGVySWR9ICR7ZGF0ZUhlYWRlcklkfWAsXHJcbiAgICAgICAgICAgICAgICAgICAgfSwgcmVuZGVyUHJvcHM6IHJlbmRlclByb3BzLCBnZW5lcmF0b3JOYW1lOiBcImFsbERheUNvbnRlbnRcIiwgY3VzdG9tR2VuZXJhdG9yOiBvcHRpb25zLmFsbERheUNvbnRlbnQsIGRlZmF1bHRHZW5lcmF0b3I6IHJlbmRlckFsbERheUlubmVyLCBjbGFzc05hbWVHZW5lcmF0b3I6IG9wdGlvbnMuYWxsRGF5Q2xhc3NOYW1lcywgZGlkTW91bnQ6IG9wdGlvbnMuYWxsRGF5RGlkTW91bnQsIHdpbGxVbm1vdW50OiBvcHRpb25zLmFsbERheVdpbGxVbm1vdW50IH0pKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gKHkoXCJ0ZFwiLCB7IGNsYXNzTmFtZTogXCJmYy1saXN0LWV2ZW50LXRpbWVcIiB9LCB0aW1lVGV4dCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHJlbmRlckFsbERheUlubmVyKHJlbmRlclByb3BzKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlbmRlclByb3BzLnRleHQ7XHJcbiAgICB9XHJcblxyXG4gICAgLypcclxuICAgIFJlc3BvbnNpYmxlIGZvciB0aGUgc2Nyb2xsZXIsIGFuZCBmb3J3YXJkaW5nIGV2ZW50LXJlbGF0ZWQgYWN0aW9ucyBpbnRvIHRoZSBcImdyaWRcIi5cclxuICAgICovXHJcbiAgICBjbGFzcyBMaXN0VmlldyBleHRlbmRzIERhdGVDb21wb25lbnQge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgICAgICB0aGlzLmNvbXB1dGVEYXRlVmFycyA9IG1lbW9pemUoY29tcHV0ZURhdGVWYXJzKTtcclxuICAgICAgICAgICAgdGhpcy5ldmVudFN0b3JlVG9TZWdzID0gbWVtb2l6ZSh0aGlzLl9ldmVudFN0b3JlVG9TZWdzKTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IHtcclxuICAgICAgICAgICAgICAgIHRpbWVIZWFkZXJJZDogZ2V0VW5pcXVlRG9tSWQoKSxcclxuICAgICAgICAgICAgICAgIGV2ZW50SGVhZGVySWQ6IGdldFVuaXF1ZURvbUlkKCksXHJcbiAgICAgICAgICAgICAgICBkYXRlSGVhZGVySWRSb290OiBnZXRVbmlxdWVEb21JZCgpLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB0aGlzLnNldFJvb3RFbCA9IChyb290RWwpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChyb290RWwpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQucmVnaXN0ZXJJbnRlcmFjdGl2ZUNvbXBvbmVudCh0aGlzLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsOiByb290RWwsXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQudW5yZWdpc3RlckludGVyYWN0aXZlQ29tcG9uZW50KHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZW5kZXIoKSB7XHJcbiAgICAgICAgICAgIGxldCB7IHByb3BzLCBjb250ZXh0IH0gPSB0aGlzO1xyXG4gICAgICAgICAgICBsZXQgeyBkYXlEYXRlcywgZGF5UmFuZ2VzIH0gPSB0aGlzLmNvbXB1dGVEYXRlVmFycyhwcm9wcy5kYXRlUHJvZmlsZSk7XHJcbiAgICAgICAgICAgIGxldCBldmVudFNlZ3MgPSB0aGlzLmV2ZW50U3RvcmVUb1NlZ3MocHJvcHMuZXZlbnRTdG9yZSwgcHJvcHMuZXZlbnRVaUJhc2VzLCBkYXlSYW5nZXMpO1xyXG4gICAgICAgICAgICByZXR1cm4gKHkoVmlld0NvbnRhaW5lciwgeyBlbFJlZjogdGhpcy5zZXRSb290RWwsIGVsQ2xhc3NlczogW1xyXG4gICAgICAgICAgICAgICAgICAgICdmYy1saXN0JyxcclxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnRoZW1lLmdldENsYXNzKCd0YWJsZScpLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQub3B0aW9ucy5zdGlja3lIZWFkZXJEYXRlcyAhPT0gZmFsc2UgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnZmMtbGlzdC1zdGlja3knIDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgJycsXHJcbiAgICAgICAgICAgICAgICBdLCB2aWV3U3BlYzogY29udGV4dC52aWV3U3BlYyB9LFxyXG4gICAgICAgICAgICAgICAgeShTY3JvbGxlciwgeyBsaXF1aWQ6ICFwcm9wcy5pc0hlaWdodEF1dG8sIG92ZXJmbG93WDogcHJvcHMuaXNIZWlnaHRBdXRvID8gJ3Zpc2libGUnIDogJ2hpZGRlbicsIG92ZXJmbG93WTogcHJvcHMuaXNIZWlnaHRBdXRvID8gJ3Zpc2libGUnIDogJ2F1dG8nIH0sIGV2ZW50U2Vncy5sZW5ndGggPiAwID9cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlclNlZ0xpc3QoZXZlbnRTZWdzLCBkYXlEYXRlcykgOlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyRW1wdHlNZXNzYWdlKCkpKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlbmRlckVtcHR5TWVzc2FnZSgpIHtcclxuICAgICAgICAgICAgbGV0IHsgb3B0aW9ucywgdmlld0FwaSB9ID0gdGhpcy5jb250ZXh0O1xyXG4gICAgICAgICAgICBsZXQgcmVuZGVyUHJvcHMgPSB7XHJcbiAgICAgICAgICAgICAgICB0ZXh0OiBvcHRpb25zLm5vRXZlbnRzVGV4dCxcclxuICAgICAgICAgICAgICAgIHZpZXc6IHZpZXdBcGksXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJldHVybiAoeShDb250ZW50Q29udGFpbmVyLCB7IGVsVGFnOiBcImRpdlwiLCBlbENsYXNzZXM6IFsnZmMtbGlzdC1lbXB0eSddLCByZW5kZXJQcm9wczogcmVuZGVyUHJvcHMsIGdlbmVyYXRvck5hbWU6IFwibm9FdmVudHNDb250ZW50XCIsIGN1c3RvbUdlbmVyYXRvcjogb3B0aW9ucy5ub0V2ZW50c0NvbnRlbnQsIGRlZmF1bHRHZW5lcmF0b3I6IHJlbmRlck5vRXZlbnRzSW5uZXIsIGNsYXNzTmFtZUdlbmVyYXRvcjogb3B0aW9ucy5ub0V2ZW50c0NsYXNzTmFtZXMsIGRpZE1vdW50OiBvcHRpb25zLm5vRXZlbnRzRGlkTW91bnQsIHdpbGxVbm1vdW50OiBvcHRpb25zLm5vRXZlbnRzV2lsbFVubW91bnQgfSwgKElubmVyQ29udGVudCkgPT4gKHkoSW5uZXJDb250ZW50LCB7IGVsVGFnOiBcImRpdlwiLCBlbENsYXNzZXM6IFsnZmMtbGlzdC1lbXB0eS1jdXNoaW9uJ10gfSkpKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlbmRlclNlZ0xpc3QoYWxsU2VncywgZGF5RGF0ZXMpIHtcclxuICAgICAgICAgICAgbGV0IHsgdGhlbWUsIG9wdGlvbnMgfSA9IHRoaXMuY29udGV4dDtcclxuICAgICAgICAgICAgbGV0IHsgdGltZUhlYWRlcklkLCBldmVudEhlYWRlcklkLCBkYXRlSGVhZGVySWRSb290IH0gPSB0aGlzLnN0YXRlO1xyXG4gICAgICAgICAgICBsZXQgc2Vnc0J5RGF5ID0gZ3JvdXBTZWdzQnlEYXkoYWxsU2Vncyk7IC8vIHNwYXJzZSBhcnJheVxyXG4gICAgICAgICAgICByZXR1cm4gKHkoTm93VGltZXIsIHsgdW5pdDogXCJkYXlcIiB9LCAobm93RGF0ZSwgdG9kYXlSYW5nZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgbGV0IGlubmVyTm9kZXMgPSBbXTtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGRheUluZGV4ID0gMDsgZGF5SW5kZXggPCBzZWdzQnlEYXkubGVuZ3RoOyBkYXlJbmRleCArPSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGRheVNlZ3MgPSBzZWdzQnlEYXlbZGF5SW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXlTZWdzKSB7IC8vIHNwYXJzZSBhcnJheSwgc28gbWlnaHQgYmUgdW5kZWZpbmVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBkYXlTdHIgPSBmb3JtYXREYXlTdHJpbmcoZGF5RGF0ZXNbZGF5SW5kZXhdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGRhdGVIZWFkZXJJZCA9IGRhdGVIZWFkZXJJZFJvb3QgKyAnLScgKyBkYXlTdHI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFwcGVuZCBhIGRheSBoZWFkZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5uZXJOb2Rlcy5wdXNoKHkoTGlzdFZpZXdIZWFkZXJSb3csIHsga2V5OiBkYXlTdHIsIGNlbGxJZDogZGF0ZUhlYWRlcklkLCBkYXlEYXRlOiBkYXlEYXRlc1tkYXlJbmRleF0sIHRvZGF5UmFuZ2U6IHRvZGF5UmFuZ2UgfSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXlTZWdzID0gc29ydEV2ZW50U2VncyhkYXlTZWdzLCBvcHRpb25zLmV2ZW50T3JkZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBzZWcgb2YgZGF5U2Vncykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5uZXJOb2Rlcy5wdXNoKHkoTGlzdFZpZXdFdmVudFJvdywgT2JqZWN0LmFzc2lnbih7IGtleTogZGF5U3RyICsgJzonICsgc2VnLmV2ZW50UmFuZ2UuaW5zdGFuY2UuaW5zdGFuY2VJZCAvKiBhcmUgbXVsdGlwbGUgc2VncyBmb3IgYW4gaW5zdGFuY2VJZCAqLywgc2VnOiBzZWcsIGlzRHJhZ2dpbmc6IGZhbHNlLCBpc1Jlc2l6aW5nOiBmYWxzZSwgaXNEYXRlU2VsZWN0aW5nOiBmYWxzZSwgaXNTZWxlY3RlZDogZmFsc2UsIHRpbWVIZWFkZXJJZDogdGltZUhlYWRlcklkLCBldmVudEhlYWRlcklkOiBldmVudEhlYWRlcklkLCBkYXRlSGVhZGVySWQ6IGRhdGVIZWFkZXJJZCB9LCBnZXRTZWdNZXRhKHNlZywgdG9kYXlSYW5nZSwgbm93RGF0ZSkpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKHkoXCJ0YWJsZVwiLCB7IGNsYXNzTmFtZTogJ2ZjLWxpc3QtdGFibGUgJyArIHRoZW1lLmdldENsYXNzKCd0YWJsZScpIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgeShcInRoZWFkXCIsIG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHkoXCJ0clwiLCBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeShcInRoXCIsIHsgc2NvcGU6IFwiY29sXCIsIGlkOiB0aW1lSGVhZGVySWQgfSwgb3B0aW9ucy50aW1lSGludCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5KFwidGhcIiwgeyBzY29wZTogXCJjb2xcIiwgXCJhcmlhLWhpZGRlblwiOiB0cnVlIH0pLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeShcInRoXCIsIHsgc2NvcGU6IFwiY29sXCIsIGlkOiBldmVudEhlYWRlcklkIH0sIG9wdGlvbnMuZXZlbnRIaW50KSkpLFxyXG4gICAgICAgICAgICAgICAgICAgIHkoXCJ0Ym9keVwiLCBudWxsLCBpbm5lck5vZGVzKSkpO1xyXG4gICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9ldmVudFN0b3JlVG9TZWdzKGV2ZW50U3RvcmUsIGV2ZW50VWlCYXNlcywgZGF5UmFuZ2VzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmV2ZW50UmFuZ2VzVG9TZWdzKHNsaWNlRXZlbnRTdG9yZShldmVudFN0b3JlLCBldmVudFVpQmFzZXMsIHRoaXMucHJvcHMuZGF0ZVByb2ZpbGUuYWN0aXZlUmFuZ2UsIHRoaXMuY29udGV4dC5vcHRpb25zLm5leHREYXlUaHJlc2hvbGQpLmZnLCBkYXlSYW5nZXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBldmVudFJhbmdlc1RvU2VncyhldmVudFJhbmdlcywgZGF5UmFuZ2VzKSB7XHJcbiAgICAgICAgICAgIGxldCBzZWdzID0gW107XHJcbiAgICAgICAgICAgIGZvciAobGV0IGV2ZW50UmFuZ2Ugb2YgZXZlbnRSYW5nZXMpIHtcclxuICAgICAgICAgICAgICAgIHNlZ3MucHVzaCguLi50aGlzLmV2ZW50UmFuZ2VUb1NlZ3MoZXZlbnRSYW5nZSwgZGF5UmFuZ2VzKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHNlZ3M7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGV2ZW50UmFuZ2VUb1NlZ3MoZXZlbnRSYW5nZSwgZGF5UmFuZ2VzKSB7XHJcbiAgICAgICAgICAgIGxldCB7IGRhdGVFbnYgfSA9IHRoaXMuY29udGV4dDtcclxuICAgICAgICAgICAgbGV0IHsgbmV4dERheVRocmVzaG9sZCB9ID0gdGhpcy5jb250ZXh0Lm9wdGlvbnM7XHJcbiAgICAgICAgICAgIGxldCByYW5nZSA9IGV2ZW50UmFuZ2UucmFuZ2U7XHJcbiAgICAgICAgICAgIGxldCBhbGxEYXkgPSBldmVudFJhbmdlLmRlZi5hbGxEYXk7XHJcbiAgICAgICAgICAgIGxldCBkYXlJbmRleDtcclxuICAgICAgICAgICAgbGV0IHNlZ1JhbmdlO1xyXG4gICAgICAgICAgICBsZXQgc2VnO1xyXG4gICAgICAgICAgICBsZXQgc2VncyA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKGRheUluZGV4ID0gMDsgZGF5SW5kZXggPCBkYXlSYW5nZXMubGVuZ3RoOyBkYXlJbmRleCArPSAxKSB7XHJcbiAgICAgICAgICAgICAgICBzZWdSYW5nZSA9IGludGVyc2VjdFJhbmdlcyhyYW5nZSwgZGF5UmFuZ2VzW2RheUluZGV4XSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2VnUmFuZ2UpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZWcgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudDogdGhpcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRSYW5nZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHNlZ1JhbmdlLnN0YXJ0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IHNlZ1JhbmdlLmVuZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXNTdGFydDogZXZlbnRSYW5nZS5pc1N0YXJ0ICYmIHNlZ1JhbmdlLnN0YXJ0LnZhbHVlT2YoKSA9PT0gcmFuZ2Uuc3RhcnQudmFsdWVPZigpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0VuZDogZXZlbnRSYW5nZS5pc0VuZCAmJiBzZWdSYW5nZS5lbmQudmFsdWVPZigpID09PSByYW5nZS5lbmQudmFsdWVPZigpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXlJbmRleCxcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIHNlZ3MucHVzaChzZWcpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGRldGVjdCB3aGVuIHJhbmdlIHdvbid0IGdvIGZ1bGx5IGludG8gdGhlIG5leHQgZGF5LFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGFuZCBtdXRhdGUgdGhlIGxhdGVzdCBzZWcgdG8gdGhlIGJlIHRoZSBlbmQuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzZWcuaXNFbmQgJiYgIWFsbERheSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXlJbmRleCArIDEgPCBkYXlSYW5nZXMubGVuZ3RoICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlLmVuZCA8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRlRW52LmFkZChkYXlSYW5nZXNbZGF5SW5kZXggKyAxXS5zdGFydCwgbmV4dERheVRocmVzaG9sZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VnLmVuZCA9IHJhbmdlLmVuZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VnLmlzRW5kID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBzZWdzO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHJlbmRlck5vRXZlbnRzSW5uZXIocmVuZGVyUHJvcHMpIHtcclxuICAgICAgICByZXR1cm4gcmVuZGVyUHJvcHMudGV4dDtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGNvbXB1dGVEYXRlVmFycyhkYXRlUHJvZmlsZSkge1xyXG4gICAgICAgIGxldCBkYXlTdGFydCA9IHN0YXJ0T2ZEYXkoZGF0ZVByb2ZpbGUucmVuZGVyUmFuZ2Uuc3RhcnQpO1xyXG4gICAgICAgIGxldCB2aWV3RW5kID0gZGF0ZVByb2ZpbGUucmVuZGVyUmFuZ2UuZW5kO1xyXG4gICAgICAgIGxldCBkYXlEYXRlcyA9IFtdO1xyXG4gICAgICAgIGxldCBkYXlSYW5nZXMgPSBbXTtcclxuICAgICAgICB3aGlsZSAoZGF5U3RhcnQgPCB2aWV3RW5kKSB7XHJcbiAgICAgICAgICAgIGRheURhdGVzLnB1c2goZGF5U3RhcnQpO1xyXG4gICAgICAgICAgICBkYXlSYW5nZXMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICBzdGFydDogZGF5U3RhcnQsXHJcbiAgICAgICAgICAgICAgICBlbmQ6IGFkZERheXMoZGF5U3RhcnQsIDEpLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgZGF5U3RhcnQgPSBhZGREYXlzKGRheVN0YXJ0LCAxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHsgZGF5RGF0ZXMsIGRheVJhbmdlcyB9O1xyXG4gICAgfVxyXG4gICAgLy8gUmV0dXJucyBhIHNwYXJzZSBhcnJheSBvZiBhcnJheXMsIHNlZ3MgZ3JvdXBlZCBieSB0aGVpciBkYXlJbmRleFxyXG4gICAgZnVuY3Rpb24gZ3JvdXBTZWdzQnlEYXkoc2Vncykge1xyXG4gICAgICAgIGxldCBzZWdzQnlEYXkgPSBbXTsgLy8gc3BhcnNlIGFycmF5XHJcbiAgICAgICAgbGV0IGk7XHJcbiAgICAgICAgbGV0IHNlZztcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2Vncy5sZW5ndGg7IGkgKz0gMSkge1xyXG4gICAgICAgICAgICBzZWcgPSBzZWdzW2ldO1xyXG4gICAgICAgICAgICAoc2Vnc0J5RGF5W3NlZy5kYXlJbmRleF0gfHwgKHNlZ3NCeURheVtzZWcuZGF5SW5kZXhdID0gW10pKVxyXG4gICAgICAgICAgICAgICAgLnB1c2goc2VnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHNlZ3NCeURheTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBPUFRJT05fUkVGSU5FUlMkMSA9IHtcclxuICAgICAgICBsaXN0RGF5Rm9ybWF0OiBjcmVhdGVGYWxzYWJsZUZvcm1hdHRlcixcclxuICAgICAgICBsaXN0RGF5U2lkZUZvcm1hdDogY3JlYXRlRmFsc2FibGVGb3JtYXR0ZXIsXHJcbiAgICAgICAgbm9FdmVudHNDbGFzc05hbWVzOiBpZGVudGl0eSxcclxuICAgICAgICBub0V2ZW50c0NvbnRlbnQ6IGlkZW50aXR5LFxyXG4gICAgICAgIG5vRXZlbnRzRGlkTW91bnQ6IGlkZW50aXR5LFxyXG4gICAgICAgIG5vRXZlbnRzV2lsbFVubW91bnQ6IGlkZW50aXR5LFxyXG4gICAgICAgIC8vIG5vRXZlbnRzVGV4dCBpcyBkZWZpbmVkIGluIGJhc2Ugb3B0aW9uc1xyXG4gICAgfTtcclxuICAgIGZ1bmN0aW9uIGNyZWF0ZUZhbHNhYmxlRm9ybWF0dGVyKGlucHV0KSB7XHJcbiAgICAgICAgcmV0dXJuIGlucHV0ID09PSBmYWxzZSA/IG51bGwgOiBjcmVhdGVGb3JtYXR0ZXIoaW5wdXQpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBpbmRleCQxID0gY3JlYXRlUGx1Z2luKHtcclxuICAgICAgICBuYW1lOiAnQGZ1bGxjYWxlbmRhci9saXN0JyxcclxuICAgICAgICBvcHRpb25SZWZpbmVyczogT1BUSU9OX1JFRklORVJTJDEsXHJcbiAgICAgICAgdmlld3M6IHtcclxuICAgICAgICAgICAgbGlzdDoge1xyXG4gICAgICAgICAgICAgICAgY29tcG9uZW50OiBMaXN0VmlldyxcclxuICAgICAgICAgICAgICAgIGJ1dHRvblRleHRLZXk6ICdsaXN0JyxcclxuICAgICAgICAgICAgICAgIGxpc3REYXlGb3JtYXQ6IHsgbW9udGg6ICdsb25nJywgZGF5OiAnbnVtZXJpYycsIHllYXI6ICdudW1lcmljJyB9LCAvLyBsaWtlIFwiSmFudWFyeSAxLCAyMDE2XCJcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgbGlzdERheToge1xyXG4gICAgICAgICAgICAgICAgdHlwZTogJ2xpc3QnLFxyXG4gICAgICAgICAgICAgICAgZHVyYXRpb246IHsgZGF5czogMSB9LFxyXG4gICAgICAgICAgICAgICAgbGlzdERheUZvcm1hdDogeyB3ZWVrZGF5OiAnbG9uZycgfSwgLy8gZGF5LW9mLXdlZWsgaXMgYWxsIHdlIG5lZWQuIGZ1bGwgZGF0ZSBpcyBwcm9iYWJseSBpbiBoZWFkZXJUb29sYmFyXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGxpc3RXZWVrOiB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiAnbGlzdCcsXHJcbiAgICAgICAgICAgICAgICBkdXJhdGlvbjogeyB3ZWVrczogMSB9LFxyXG4gICAgICAgICAgICAgICAgbGlzdERheUZvcm1hdDogeyB3ZWVrZGF5OiAnbG9uZycgfSxcclxuICAgICAgICAgICAgICAgIGxpc3REYXlTaWRlRm9ybWF0OiB7IG1vbnRoOiAnbG9uZycsIGRheTogJ251bWVyaWMnLCB5ZWFyOiAnbnVtZXJpYycgfSxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgbGlzdE1vbnRoOiB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiAnbGlzdCcsXHJcbiAgICAgICAgICAgICAgICBkdXJhdGlvbjogeyBtb250aDogMSB9LFxyXG4gICAgICAgICAgICAgICAgbGlzdERheVNpZGVGb3JtYXQ6IHsgd2Vla2RheTogJ2xvbmcnIH0sIC8vIGRheS1vZi13ZWVrIGlzIG5pY2UtdG8taGF2ZVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBsaXN0WWVhcjoge1xyXG4gICAgICAgICAgICAgICAgdHlwZTogJ2xpc3QnLFxyXG4gICAgICAgICAgICAgICAgZHVyYXRpb246IHsgeWVhcjogMSB9LFxyXG4gICAgICAgICAgICAgICAgbGlzdERheVNpZGVGb3JtYXQ6IHsgd2Vla2RheTogJ2xvbmcnIH0sIC8vIGRheS1vZi13ZWVrIGlzIG5pY2UtdG8taGF2ZVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH0sXHJcbiAgICB9KTtcclxuXHJcbiAgICBjbGFzcyBTaW5nbGVNb250aCBleHRlbmRzIERhdGVDb21wb25lbnQge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgICAgICB0aGlzLmJ1aWxkRGF5VGFibGVNb2RlbCA9IG1lbW9pemUoYnVpbGREYXlUYWJsZU1vZGVsKTtcclxuICAgICAgICAgICAgdGhpcy5zbGljZXIgPSBuZXcgRGF5VGFibGVTbGljZXIoKTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IHtcclxuICAgICAgICAgICAgICAgIGxhYmVsSWQ6IGdldFVuaXF1ZURvbUlkKCksXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlbmRlcigpIHtcclxuICAgICAgICAgICAgY29uc3QgeyBwcm9wcywgc3RhdGUsIGNvbnRleHQgfSA9IHRoaXM7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgZGF0ZVByb2ZpbGUsIGZvclByaW50IH0gPSBwcm9wcztcclxuICAgICAgICAgICAgY29uc3QgeyBvcHRpb25zIH0gPSBjb250ZXh0O1xyXG4gICAgICAgICAgICBjb25zdCBkYXlUYWJsZU1vZGVsID0gdGhpcy5idWlsZERheVRhYmxlTW9kZWwoZGF0ZVByb2ZpbGUsIGNvbnRleHQuZGF0ZVByb2ZpbGVHZW5lcmF0b3IpO1xyXG4gICAgICAgICAgICBjb25zdCBzbGljZWRQcm9wcyA9IHRoaXMuc2xpY2VyLnNsaWNlUHJvcHMocHJvcHMsIGRhdGVQcm9maWxlLCBvcHRpb25zLm5leHREYXlUaHJlc2hvbGQsIGNvbnRleHQsIGRheVRhYmxlTW9kZWwpO1xyXG4gICAgICAgICAgICAvLyBlbnN1cmUgc2luZ2xlLW1vbnRoIGhhcyBhc3BlY3QgcmF0aW9cclxuICAgICAgICAgICAgY29uc3QgdGFibGVIZWlnaHQgPSBwcm9wcy50YWJsZVdpZHRoICE9IG51bGwgPyBwcm9wcy50YWJsZVdpZHRoIC8gb3B0aW9ucy5hc3BlY3RSYXRpbyA6IG51bGw7XHJcbiAgICAgICAgICAgIGNvbnN0IHJvd0NudCA9IGRheVRhYmxlTW9kZWwuY2VsbHMubGVuZ3RoO1xyXG4gICAgICAgICAgICBjb25zdCByb3dIZWlnaHQgPSB0YWJsZUhlaWdodCAhPSBudWxsID8gdGFibGVIZWlnaHQgLyByb3dDbnQgOiBudWxsO1xyXG4gICAgICAgICAgICByZXR1cm4gKHkoXCJkaXZcIiwgeyByZWY6IHByb3BzLmVsUmVmLCBcImRhdGEtZGF0ZVwiOiBwcm9wcy5pc29EYXRlU3RyLCBjbGFzc05hbWU6IFwiZmMtbXVsdGltb250aC1tb250aFwiLCBzdHlsZTogeyB3aWR0aDogcHJvcHMud2lkdGggfSwgcm9sZTogXCJncmlkXCIsIFwiYXJpYS1sYWJlbGxlZGJ5XCI6IHN0YXRlLmxhYmVsSWQgfSxcclxuICAgICAgICAgICAgICAgIHkoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtbXVsdGltb250aC1oZWFkZXJcIiwgc3R5bGU6IHsgbWFyZ2luQm90dG9tOiByb3dIZWlnaHQgfSwgcm9sZTogXCJwcmVzZW50YXRpb25cIiB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHkoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtbXVsdGltb250aC10aXRsZVwiLCBpZDogc3RhdGUubGFiZWxJZCB9LCBjb250ZXh0LmRhdGVFbnYuZm9ybWF0KHByb3BzLmRhdGVQcm9maWxlLmN1cnJlbnRSYW5nZS5zdGFydCwgcHJvcHMudGl0bGVGb3JtYXQpKSxcclxuICAgICAgICAgICAgICAgICAgICB5KFwidGFibGVcIiwgeyBjbGFzc05hbWU6IFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdmYy1tdWx0aW1vbnRoLWhlYWRlci10YWJsZScsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnRoZW1lLmdldENsYXNzKCd0YWJsZScpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBdLmpvaW4oJyAnKSwgcm9sZTogXCJwcmVzZW50YXRpb25cIiB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB5KFwidGhlYWRcIiwgeyByb2xlOiBcInJvd2dyb3VwXCIgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkoRGF5SGVhZGVyLCB7IGRhdGVQcm9maWxlOiBwcm9wcy5kYXRlUHJvZmlsZSwgZGF0ZXM6IGRheVRhYmxlTW9kZWwuaGVhZGVyRGF0ZXMsIGRhdGVzUmVwRGlzdGluY3REYXlzOiBmYWxzZSB9KSkpKSxcclxuICAgICAgICAgICAgICAgIHkoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ2ZjLW11bHRpbW9udGgtZGF5Z3JpZCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdmYy1kYXlncmlkJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ2ZjLWRheWdyaWQtYm9keScsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICFmb3JQcmludCAmJiAnZmMtZGF5Z3JpZC1ib2R5LWJhbGFuY2VkJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yUHJpbnQgJiYgJ2ZjLWRheWdyaWQtYm9keS11bmJhbGFuY2VkJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yUHJpbnQgJiYgJ2ZjLWRheWdyaWQtYm9keS1uYXR1cmFsJyxcclxuICAgICAgICAgICAgICAgICAgICBdLmpvaW4oJyAnKSwgc3R5bGU6IHsgbWFyZ2luVG9wOiAtcm93SGVpZ2h0IH0gfSxcclxuICAgICAgICAgICAgICAgICAgICB5KFwidGFibGVcIiwgeyBjbGFzc05hbWU6IFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdmYy1tdWx0aW1vbnRoLWRheWdyaWQtdGFibGUnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC50aGVtZS5nZXRDbGFzcygndGFibGUnKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgXS5qb2luKCcgJyksIHN0eWxlOiB7IGhlaWdodDogZm9yUHJpbnQgPyAnJyA6IHRhYmxlSGVpZ2h0IH0sIHJvbGU6IFwicHJlc2VudGF0aW9uXCIgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgeShcInRib2R5XCIsIHsgcm9sZTogXCJyb3dncm91cFwiIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5KFRhYmxlUm93cywgT2JqZWN0LmFzc2lnbih7fSwgc2xpY2VkUHJvcHMsIHsgZGF0ZVByb2ZpbGU6IGRhdGVQcm9maWxlLCBjZWxsczogZGF5VGFibGVNb2RlbC5jZWxscywgZXZlbnRTZWxlY3Rpb246IHByb3BzLmV2ZW50U2VsZWN0aW9uLCBkYXlNYXhFdmVudHM6ICFmb3JQcmludCwgZGF5TWF4RXZlbnRSb3dzOiAhZm9yUHJpbnQsIHNob3dXZWVrTnVtYmVyczogb3B0aW9ucy53ZWVrTnVtYmVycywgY2xpZW50V2lkdGg6IHByb3BzLmNsaWVudFdpZHRoLCBjbGllbnRIZWlnaHQ6IHByb3BzLmNsaWVudEhlaWdodCwgZm9yUHJpbnQ6IGZvclByaW50IH0pKSkpKSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBjbGFzcyBNdWx0aU1vbnRoVmlldyBleHRlbmRzIERhdGVDb21wb25lbnQge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgICAgICB0aGlzLnNwbGl0RGF0ZVByb2ZpbGVCeU1vbnRoID0gbWVtb2l6ZShzcGxpdERhdGVQcm9maWxlQnlNb250aCk7XHJcbiAgICAgICAgICAgIHRoaXMuYnVpbGRNb250aEZvcm1hdCA9IG1lbW9pemUoYnVpbGRNb250aEZvcm1hdCk7XHJcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsRWxSZWYgPSBkKCk7XHJcbiAgICAgICAgICAgIHRoaXMuZmlyc3RNb250aEVsUmVmID0gZCgpO1xyXG4gICAgICAgICAgICB0aGlzLm5lZWRzU2Nyb2xsUmVzZXQgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5oYW5kbGVTaXppbmcgPSAoaXNGb3JjZWQpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChpc0ZvcmNlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlU2l6ZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZW5kZXIoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgY29udGV4dCwgcHJvcHMsIHN0YXRlIH0gPSB0aGlzO1xyXG4gICAgICAgICAgICBjb25zdCB7IG9wdGlvbnMgfSA9IGNvbnRleHQ7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgY2xpZW50V2lkdGgsIGNsaWVudEhlaWdodCB9ID0gc3RhdGU7XHJcbiAgICAgICAgICAgIGNvbnN0IG1vbnRoSFBhZGRpbmcgPSBzdGF0ZS5tb250aEhQYWRkaW5nIHx8IDA7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbENvdW50ID0gTWF0aC5taW4oY2xpZW50V2lkdGggIT0gbnVsbCA/XHJcbiAgICAgICAgICAgICAgICBNYXRoLmZsb29yKGNsaWVudFdpZHRoIC8gKG9wdGlvbnMubXVsdGlNb250aE1pbldpZHRoICsgbW9udGhIUGFkZGluZykpIDpcclxuICAgICAgICAgICAgICAgIDEsIG9wdGlvbnMubXVsdGlNb250aE1heENvbHVtbnMpIHx8IDE7XHJcbiAgICAgICAgICAgIGNvbnN0IG1vbnRoV2lkdGhQY3QgPSAoMTAwIC8gY29sQ291bnQpICsgJyUnO1xyXG4gICAgICAgICAgICBjb25zdCBtb250aFRhYmxlV2lkdGggPSBjbGllbnRXaWR0aCA9PSBudWxsID8gbnVsbCA6XHJcbiAgICAgICAgICAgICAgICAoY2xpZW50V2lkdGggLyBjb2xDb3VudCkgLSBtb250aEhQYWRkaW5nO1xyXG4gICAgICAgICAgICBjb25zdCBpc0xlZ2l0U2luZ2xlQ29sID0gY2xpZW50V2lkdGggIT0gbnVsbCAmJiBjb2xDb3VudCA9PT0gMTtcclxuICAgICAgICAgICAgY29uc3QgbW9udGhEYXRlUHJvZmlsZXMgPSB0aGlzLnNwbGl0RGF0ZVByb2ZpbGVCeU1vbnRoKGNvbnRleHQuZGF0ZVByb2ZpbGVHZW5lcmF0b3IsIHByb3BzLmRhdGVQcm9maWxlLCBjb250ZXh0LmRhdGVFbnYsIGlzTGVnaXRTaW5nbGVDb2wgPyBmYWxzZSA6IG9wdGlvbnMuZml4ZWRXZWVrQ291bnQsIG9wdGlvbnMuc2hvd05vbkN1cnJlbnREYXRlcyk7XHJcbiAgICAgICAgICAgIGNvbnN0IG1vbnRoVGl0bGVGb3JtYXQgPSB0aGlzLmJ1aWxkTW9udGhGb3JtYXQob3B0aW9ucy5tdWx0aU1vbnRoVGl0bGVGb3JtYXQsIG1vbnRoRGF0ZVByb2ZpbGVzKTtcclxuICAgICAgICAgICAgY29uc3Qgcm9vdENsYXNzTmFtZXMgPSBbXHJcbiAgICAgICAgICAgICAgICAnZmMtbXVsdGltb250aCcsXHJcbiAgICAgICAgICAgICAgICBpc0xlZ2l0U2luZ2xlQ29sID9cclxuICAgICAgICAgICAgICAgICAgICAnZmMtbXVsdGltb250aC1zaW5nbGVjb2wnIDpcclxuICAgICAgICAgICAgICAgICAgICAnZmMtbXVsdGltb250aC1tdWx0aWNvbCcsXHJcbiAgICAgICAgICAgICAgICAobW9udGhUYWJsZVdpZHRoICE9IG51bGwgJiYgbW9udGhUYWJsZVdpZHRoIDwgNDAwKSA/XHJcbiAgICAgICAgICAgICAgICAgICAgJ2ZjLW11bHRpbW9udGgtY29tcGFjdCcgOlxyXG4gICAgICAgICAgICAgICAgICAgICcnLFxyXG4gICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICByZXR1cm4gKHkoVmlld0NvbnRhaW5lciwgeyBlbFJlZjogdGhpcy5zY3JvbGxFbFJlZiwgZWxDbGFzc2VzOiByb290Q2xhc3NOYW1lcywgdmlld1NwZWM6IGNvbnRleHQudmlld1NwZWMgfSwgbW9udGhEYXRlUHJvZmlsZXMubWFwKChtb250aERhdGVQcm9maWxlLCBpKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBtb250aFN0ciA9IGZvcm1hdElzb01vbnRoU3RyKG1vbnRoRGF0ZVByb2ZpbGUuY3VycmVudFJhbmdlLnN0YXJ0KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiAoeShTaW5nbGVNb250aCwgT2JqZWN0LmFzc2lnbih7fSwgcHJvcHMsIHsga2V5OiBtb250aFN0ciwgaXNvRGF0ZVN0cjogbW9udGhTdHIsIGVsUmVmOiBpID09PSAwID8gdGhpcy5maXJzdE1vbnRoRWxSZWYgOiB1bmRlZmluZWQsIHRpdGxlRm9ybWF0OiBtb250aFRpdGxlRm9ybWF0LCBkYXRlUHJvZmlsZTogbW9udGhEYXRlUHJvZmlsZSwgd2lkdGg6IG1vbnRoV2lkdGhQY3QsIHRhYmxlV2lkdGg6IG1vbnRoVGFibGVXaWR0aCwgY2xpZW50V2lkdGg6IGNsaWVudFdpZHRoLCBjbGllbnRIZWlnaHQ6IGNsaWVudEhlaWdodCB9KSkpO1xyXG4gICAgICAgICAgICB9KSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb21wb25lbnREaWRNb3VudCgpIHtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVTaXplKCk7XHJcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5hZGRSZXNpemVIYW5kbGVyKHRoaXMuaGFuZGxlU2l6aW5nKTtcclxuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0U2Nyb2xsUmVzZXQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcykge1xyXG4gICAgICAgICAgICBpZiAoIWlzUHJvcHNFcXVhbChwcmV2UHJvcHMsIHRoaXMucHJvcHMpKSB7IC8vIGFuIGV4dGVybmFsIGNoYW5nZT9cclxuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlU2l6aW5nKGZhbHNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocHJldlByb3BzLmRhdGVQcm9maWxlICE9PSB0aGlzLnByb3BzLmRhdGVQcm9maWxlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlcXVlc3RTY3JvbGxSZXNldCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5mbHVzaFNjcm9sbFJlc2V0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5yZW1vdmVSZXNpemVIYW5kbGVyKHRoaXMuaGFuZGxlU2l6aW5nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdXBkYXRlU2l6ZSgpIHtcclxuICAgICAgICAgICAgY29uc3Qgc2Nyb2xsRWwgPSB0aGlzLnNjcm9sbEVsUmVmLmN1cnJlbnQ7XHJcbiAgICAgICAgICAgIGNvbnN0IGZpcnN0TW9udGhFbCA9IHRoaXMuZmlyc3RNb250aEVsUmVmLmN1cnJlbnQ7XHJcbiAgICAgICAgICAgIGlmIChzY3JvbGxFbCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgY2xpZW50V2lkdGg6IHNjcm9sbEVsLmNsaWVudFdpZHRoLFxyXG4gICAgICAgICAgICAgICAgICAgIGNsaWVudEhlaWdodDogc2Nyb2xsRWwuY2xpZW50SGVpZ2h0LFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGZpcnN0TW9udGhFbCAmJiBzY3JvbGxFbCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUubW9udGhIUGFkZGluZyA9PSBudWxsKSB7IC8vIGFsd2F5cyByZW1lbWJlciBpbml0aWFsIG5vbi16ZXJvIHZhbHVlXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vbnRoSFBhZGRpbmc6IHNjcm9sbEVsLmNsaWVudFdpZHRoIC0gLy8gZ28gd2l0aGluIHBhZGRpbmdcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0TW9udGhFbC5maXJzdENoaWxkLm9mZnNldFdpZHRoLFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlcXVlc3RTY3JvbGxSZXNldCgpIHtcclxuICAgICAgICAgICAgdGhpcy5uZWVkc1Njcm9sbFJlc2V0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5mbHVzaFNjcm9sbFJlc2V0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZsdXNoU2Nyb2xsUmVzZXQoKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLm5lZWRzU2Nyb2xsUmVzZXQgJiZcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUubW9udGhIUGFkZGluZyAhPSBudWxsIC8vIGluZGljYXRlcyBzaXppbmcgYWxyZWFkeSBoYXBwZW5lZFxyXG4gICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHsgY3VycmVudERhdGUgfSA9IHRoaXMucHJvcHMuZGF0ZVByb2ZpbGU7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzY3JvbGxFbCA9IHRoaXMuc2Nyb2xsRWxSZWYuY3VycmVudDtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG1vbnRoRWwgPSBzY3JvbGxFbC5xdWVyeVNlbGVjdG9yKGBbZGF0YS1kYXRlPVwiJHtmb3JtYXRJc29Nb250aFN0cihjdXJyZW50RGF0ZSl9XCJdYCk7XHJcbiAgICAgICAgICAgICAgICBzY3JvbGxFbC5zY3JvbGxUb3AgPSBtb250aEVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCAtXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maXJzdE1vbnRoRWxSZWYuY3VycmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3A7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm5lZWRzU2Nyb2xsUmVzZXQgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyB3b3JrYXJvdW5kIGZvciB3aGVuIHF1ZXVlZCBzZXRTdGF0ZSByZW5kZXIgKHcvIGNsaWVudFdpZHRoKSBnZXRzIGNhbmNlbGxlZCBiZWNhdXNlXHJcbiAgICAgICAgLy8gc3Vic2VxdWVudCB1cGRhdGUgYW5kIHNob3VsZENvbXBvbmVudFVwZGF0ZSBzYXlzIG5vdCB0byByZW5kZXIgOihcclxuICAgICAgICBzaG91bGRDb21wb25lbnRVcGRhdGUoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIGRhdGUgcHJvZmlsZVxyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgY29uc3Qgb25lTW9udGhEdXJhdGlvbiA9IGNyZWF0ZUR1cmF0aW9uKDEsICdtb250aCcpO1xyXG4gICAgZnVuY3Rpb24gc3BsaXREYXRlUHJvZmlsZUJ5TW9udGgoZGF0ZVByb2ZpbGVHZW5lcmF0b3IsIGRhdGVQcm9maWxlLCBkYXRlRW52LCBmaXhlZFdlZWtDb3VudCwgc2hvd05vbkN1cnJlbnREYXRlcykge1xyXG4gICAgICAgIGNvbnN0IHsgc3RhcnQsIGVuZCB9ID0gZGF0ZVByb2ZpbGUuY3VycmVudFJhbmdlO1xyXG4gICAgICAgIGxldCBtb250aFN0YXJ0ID0gc3RhcnQ7XHJcbiAgICAgICAgY29uc3QgbW9udGhEYXRlUHJvZmlsZXMgPSBbXTtcclxuICAgICAgICB3aGlsZSAobW9udGhTdGFydC52YWx1ZU9mKCkgPCBlbmQudmFsdWVPZigpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1vbnRoRW5kID0gZGF0ZUVudi5hZGQobW9udGhTdGFydCwgb25lTW9udGhEdXJhdGlvbik7XHJcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRSYW5nZSA9IHtcclxuICAgICAgICAgICAgICAgIC8vIHl1Y2tcclxuICAgICAgICAgICAgICAgIHN0YXJ0OiBkYXRlUHJvZmlsZUdlbmVyYXRvci5za2lwSGlkZGVuRGF5cyhtb250aFN0YXJ0KSxcclxuICAgICAgICAgICAgICAgIGVuZDogZGF0ZVByb2ZpbGVHZW5lcmF0b3Iuc2tpcEhpZGRlbkRheXMobW9udGhFbmQsIC0xLCB0cnVlKSxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgbGV0IHJlbmRlclJhbmdlID0gYnVpbGREYXlUYWJsZVJlbmRlclJhbmdlKHtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRSYW5nZSxcclxuICAgICAgICAgICAgICAgIHNuYXBUb1dlZWs6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBmaXhlZFdlZWtDb3VudCxcclxuICAgICAgICAgICAgICAgIGRhdGVFbnYsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZW5kZXJSYW5nZSA9IHtcclxuICAgICAgICAgICAgICAgIC8vIHl1Y2tcclxuICAgICAgICAgICAgICAgIHN0YXJ0OiBkYXRlUHJvZmlsZUdlbmVyYXRvci5za2lwSGlkZGVuRGF5cyhyZW5kZXJSYW5nZS5zdGFydCksXHJcbiAgICAgICAgICAgICAgICBlbmQ6IGRhdGVQcm9maWxlR2VuZXJhdG9yLnNraXBIaWRkZW5EYXlzKHJlbmRlclJhbmdlLmVuZCwgLTEsIHRydWUpLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBjb25zdCBhY3RpdmVSYW5nZSA9IGRhdGVQcm9maWxlLmFjdGl2ZVJhbmdlID9cclxuICAgICAgICAgICAgICAgIGludGVyc2VjdFJhbmdlcyhkYXRlUHJvZmlsZS5hY3RpdmVSYW5nZSwgc2hvd05vbkN1cnJlbnREYXRlcyA/IHJlbmRlclJhbmdlIDogY3VycmVudFJhbmdlKSA6XHJcbiAgICAgICAgICAgICAgICBudWxsO1xyXG4gICAgICAgICAgICBtb250aERhdGVQcm9maWxlcy5wdXNoKHtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnREYXRlOiBkYXRlUHJvZmlsZS5jdXJyZW50RGF0ZSxcclxuICAgICAgICAgICAgICAgIGlzVmFsaWQ6IGRhdGVQcm9maWxlLmlzVmFsaWQsXHJcbiAgICAgICAgICAgICAgICB2YWxpZFJhbmdlOiBkYXRlUHJvZmlsZS52YWxpZFJhbmdlLFxyXG4gICAgICAgICAgICAgICAgcmVuZGVyUmFuZ2UsXHJcbiAgICAgICAgICAgICAgICBhY3RpdmVSYW5nZSxcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRSYW5nZSxcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRSYW5nZVVuaXQ6ICdtb250aCcsXHJcbiAgICAgICAgICAgICAgICBpc1JhbmdlQWxsRGF5OiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgZGF0ZUluY3JlbWVudDogZGF0ZVByb2ZpbGUuZGF0ZUluY3JlbWVudCxcclxuICAgICAgICAgICAgICAgIHNsb3RNaW5UaW1lOiBkYXRlUHJvZmlsZS5zbG90TWF4VGltZSxcclxuICAgICAgICAgICAgICAgIHNsb3RNYXhUaW1lOiBkYXRlUHJvZmlsZS5zbG90TWluVGltZSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIG1vbnRoU3RhcnQgPSBtb250aEVuZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG1vbnRoRGF0ZVByb2ZpbGVzO1xyXG4gICAgfVxyXG4gICAgLy8gZGF0ZSBmb3JtYXR0aW5nXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICBjb25zdCBZRUFSX01PTlRIX0ZPUk1BVFRFUiA9IGNyZWF0ZUZvcm1hdHRlcih7IHllYXI6ICdudW1lcmljJywgbW9udGg6ICdsb25nJyB9KTtcclxuICAgIGNvbnN0IFlFQVJfRk9STUFUVEVSID0gY3JlYXRlRm9ybWF0dGVyKHsgbW9udGg6ICdsb25nJyB9KTtcclxuICAgIGZ1bmN0aW9uIGJ1aWxkTW9udGhGb3JtYXQoZm9ybWF0T3ZlcnJpZGUsIG1vbnRoRGF0ZVByb2ZpbGVzKSB7XHJcbiAgICAgICAgcmV0dXJuIGZvcm1hdE92ZXJyaWRlIHx8XHJcbiAgICAgICAgICAgICgobW9udGhEYXRlUHJvZmlsZXNbMF0uY3VycmVudFJhbmdlLnN0YXJ0LmdldFVUQ0Z1bGxZZWFyKCkgIT09XHJcbiAgICAgICAgICAgICAgICBtb250aERhdGVQcm9maWxlc1ttb250aERhdGVQcm9maWxlcy5sZW5ndGggLSAxXS5jdXJyZW50UmFuZ2Uuc3RhcnQuZ2V0VVRDRnVsbFllYXIoKSlcclxuICAgICAgICAgICAgICAgID8gWUVBUl9NT05USF9GT1JNQVRURVJcclxuICAgICAgICAgICAgICAgIDogWUVBUl9GT1JNQVRURVIpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IE9QVElPTl9SRUZJTkVSUyA9IHtcclxuICAgICAgICBtdWx0aU1vbnRoVGl0bGVGb3JtYXQ6IGNyZWF0ZUZvcm1hdHRlcixcclxuICAgICAgICBtdWx0aU1vbnRoTWF4Q29sdW1uczogTnVtYmVyLFxyXG4gICAgICAgIG11bHRpTW9udGhNaW5XaWR0aDogTnVtYmVyLFxyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgY3NzXzI0OHogPSBcIi5mYyAuZmMtbXVsdGltb250aHtib3JkZXI6MXB4IHNvbGlkIHZhcigtLWZjLWJvcmRlci1jb2xvcik7ZGlzcGxheTpmbGV4O2ZsZXgtd3JhcDp3cmFwO292ZXJmbG93LXg6aGlkZGVuO292ZXJmbG93LXk6YXV0b30uZmMgLmZjLW11bHRpbW9udGgtdGl0bGV7Zm9udC1zaXplOjEuMmVtO2ZvbnQtd2VpZ2h0OjcwMDtwYWRkaW5nOjFlbSAwO3RleHQtYWxpZ246Y2VudGVyfS5mYyAuZmMtbXVsdGltb250aC1kYXlncmlke2JhY2tncm91bmQ6dmFyKC0tZmMtcGFnZS1iZy1jb2xvcil9LmZjIC5mYy1tdWx0aW1vbnRoLWRheWdyaWQtdGFibGUsLmZjIC5mYy1tdWx0aW1vbnRoLWhlYWRlci10YWJsZXt0YWJsZS1sYXlvdXQ6Zml4ZWQ7d2lkdGg6MTAwJX0uZmMgLmZjLW11bHRpbW9udGgtZGF5Z3JpZC10YWJsZXtib3JkZXItdG9wLXN0eWxlOmhpZGRlbiFpbXBvcnRhbnR9LmZjIC5mYy1tdWx0aW1vbnRoLXNpbmdsZWNvbCAuZmMtbXVsdGltb250aHtwb3NpdGlvbjpyZWxhdGl2ZX0uZmMgLmZjLW11bHRpbW9udGgtc2luZ2xlY29sIC5mYy1tdWx0aW1vbnRoLWhlYWRlcntiYWNrZ3JvdW5kOnZhcigtLWZjLXBhZ2UtYmctY29sb3IpO3Bvc2l0aW9uOnJlbGF0aXZlO3RvcDowO3otaW5kZXg6Mn0uZmMgLmZjLW11bHRpbW9udGgtc2luZ2xlY29sIC5mYy1tdWx0aW1vbnRoLWRheWdyaWR7cG9zaXRpb246cmVsYXRpdmU7ei1pbmRleDoxfS5mYyAuZmMtbXVsdGltb250aC1zaW5nbGVjb2wgLmZjLW11bHRpbW9udGgtZGF5Z3JpZC10YWJsZSwuZmMgLmZjLW11bHRpbW9udGgtc2luZ2xlY29sIC5mYy1tdWx0aW1vbnRoLWhlYWRlci10YWJsZXtib3JkZXItbGVmdC1zdHlsZTpoaWRkZW47Ym9yZGVyLXJpZ2h0LXN0eWxlOmhpZGRlbn0uZmMgLmZjLW11bHRpbW9udGgtc2luZ2xlY29sIC5mYy1tdWx0aW1vbnRoLW1vbnRoOmxhc3QtY2hpbGQgLmZjLW11bHRpbW9udGgtZGF5Z3JpZC10YWJsZXtib3JkZXItYm90dG9tLXN0eWxlOmhpZGRlbn0uZmMgLmZjLW11bHRpbW9udGgtbXVsdGljb2x7bGluZS1oZWlnaHQ6MX0uZmMgLmZjLW11bHRpbW9udGgtbXVsdGljb2wgLmZjLW11bHRpbW9udGgtbW9udGh7cGFkZGluZzowIDEuMmVtIDEuMmVtfS5mYyAuZmMtbXVsdGltb250aC1tdWx0aWNvbCAuZmMtZGF5Z3JpZC1tb3JlLWxpbmt7Ym9yZGVyOjFweCBzb2xpZCB2YXIoLS1mYy1ldmVudC1ib3JkZXItY29sb3IpO2Rpc3BsYXk6YmxvY2s7ZmxvYXQ6bm9uZTtwYWRkaW5nOjFweH0uZmMgLmZjLW11bHRpbW9udGgtY29tcGFjdHtsaW5lLWhlaWdodDoxfS5mYyAuZmMtbXVsdGltb250aC1jb21wYWN0IC5mYy1tdWx0aW1vbnRoLWRheWdyaWQtdGFibGUsLmZjIC5mYy1tdWx0aW1vbnRoLWNvbXBhY3QgLmZjLW11bHRpbW9udGgtaGVhZGVyLXRhYmxle2ZvbnQtc2l6ZTouOWVtfS5mYy1tZWRpYS1zY3JlZW4gLmZjLW11bHRpbW9udGgtc2luZ2xlY29sIC5mYy1tdWx0aW1vbnRoLWhlYWRlcntwb3NpdGlvbjpzdGlja3l9LmZjLW1lZGlhLXByaW50IC5mYy1tdWx0aW1vbnRoe292ZXJmbG93OnZpc2libGV9XCI7XHJcbiAgICBpbmplY3RTdHlsZXMoY3NzXzI0OHopO1xyXG5cclxuICAgIHZhciBpbmRleCA9IGNyZWF0ZVBsdWdpbih7XHJcbiAgICAgICAgbmFtZTogJ0BmdWxsY2FsZW5kYXIvbXVsdGltb250aCcsXHJcbiAgICAgICAgaW5pdGlhbFZpZXc6ICdtdWx0aU1vbnRoWWVhcicsXHJcbiAgICAgICAgb3B0aW9uUmVmaW5lcnM6IE9QVElPTl9SRUZJTkVSUyxcclxuICAgICAgICB2aWV3czoge1xyXG4gICAgICAgICAgICBtdWx0aU1vbnRoOiB7XHJcbiAgICAgICAgICAgICAgICBjb21wb25lbnQ6IE11bHRpTW9udGhWaWV3LFxyXG4gICAgICAgICAgICAgICAgZGF0ZVByb2ZpbGVHZW5lcmF0b3JDbGFzczogVGFibGVEYXRlUHJvZmlsZUdlbmVyYXRvcixcclxuICAgICAgICAgICAgICAgIG11bHRpTW9udGhNaW5XaWR0aDogMzUwLFxyXG4gICAgICAgICAgICAgICAgbXVsdGlNb250aE1heENvbHVtbnM6IDMsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIG11bHRpTW9udGhZZWFyOiB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiAnbXVsdGlNb250aCcsXHJcbiAgICAgICAgICAgICAgICBkdXJhdGlvbjogeyB5ZWFyczogMSB9LFxyXG4gICAgICAgICAgICAgICAgZml4ZWRXZWVrQ291bnQ6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBzaG93Tm9uQ3VycmVudERhdGVzOiBmYWxzZSxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9LFxyXG4gICAgfSk7XHJcblxyXG4gICAgZ2xvYmFsUGx1Z2lucy5wdXNoKGluZGV4JDQsIGluZGV4JDMsIGluZGV4JDIsIGluZGV4JDEsIGluZGV4KTtcclxuXHJcbiAgICBleHBvcnRzLkNhbGVuZGFyID0gQ2FsZW5kYXI7XHJcbiAgICBleHBvcnRzLkRyYWdnYWJsZSA9IEV4dGVybmFsRHJhZ2dhYmxlO1xyXG4gICAgZXhwb3J0cy5JbnRlcm5hbCA9IGludGVybmFsO1xyXG4gICAgZXhwb3J0cy5Kc29uUmVxdWVzdEVycm9yID0gSnNvblJlcXVlc3RFcnJvcjtcclxuICAgIGV4cG9ydHMuUHJlYWN0ID0gcHJlYWN0O1xyXG4gICAgZXhwb3J0cy5UaGlyZFBhcnR5RHJhZ2dhYmxlID0gVGhpcmRQYXJ0eURyYWdnYWJsZTtcclxuICAgIGV4cG9ydHMuY3JlYXRlUGx1Z2luID0gY3JlYXRlUGx1Z2luO1xyXG4gICAgZXhwb3J0cy5mb3JtYXREYXRlID0gZm9ybWF0RGF0ZTtcclxuICAgIGV4cG9ydHMuZm9ybWF0UmFuZ2UgPSBmb3JtYXRSYW5nZTtcclxuICAgIGV4cG9ydHMuZ2xvYmFsTG9jYWxlcyA9IGdsb2JhbExvY2FsZXM7XHJcbiAgICBleHBvcnRzLmdsb2JhbFBsdWdpbnMgPSBnbG9iYWxQbHVnaW5zO1xyXG4gICAgZXhwb3J0cy5zbGljZUV2ZW50cyA9IHNsaWNlRXZlbnRzO1xyXG4gICAgZXhwb3J0cy52ZXJzaW9uID0gdmVyc2lvbjtcclxuXHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5cclxuICAgIHJldHVybiBleHBvcnRzO1xyXG5cclxufSkoe30pO1xyXG4iXSwibmFtZXMiOlsiRnVsbENhbGVuZGFyIiwiZXhwb3J0cyIsIm4iLCJsJDEiLCJ1JDEiLCJpJDEiLCJ0IiwiciQxIiwibyIsImYkMSIsImUkMSIsImMkMSIsInMiLCJhJDEiLCJoIiwibCIsInUiLCJ2JDEiLCJwYXJlbnROb2RlIiwicmVtb3ZlQ2hpbGQiLCJ5IiwiaSIsInIiLCJmIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwiY2hpbGRyZW4iLCJjYWxsIiwiZGVmYXVsdFByb3BzIiwicCIsInR5cGUiLCJwcm9wcyIsImtleSIsInJlZiIsIl9fayIsIl9fIiwiX19iIiwiX19lIiwiX19kIiwiX19jIiwiX19oIiwiX192Iiwidm5vZGUiLCJkIiwiY3VycmVudCIsIl8iLCJrJDEiLCJnJDIiLCJiJDEiLCJzZXRQcm9wZXJ0eSIsInRlc3QiLCJzdHlsZSIsImNzc1RleHQiLCJyZXBsYWNlIiwidG9Mb3dlckNhc2UiLCJzbGljZSIsImFkZEV2ZW50TGlzdGVuZXIiLCJ3JDIiLCJtJDEiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiaW5kZXhPZiIsInJlbW92ZUF0dHJpYnV0ZSIsInNldEF0dHJpYnV0ZSIsImV2ZW50IiwieCQxIiwiY29udGV4dCIsIkEiLCJQJDEiLCJiYXNlIiwiQyQxIiwic2V0VGltZW91dCIsIlQkMSIsInB1c2giLCIkJDEiLCJfX3IiLCJkZWJvdW5jZVJlbmRlcmluZyIsImUiLCJzb3J0Iiwic2hpZnQiLCJfX1AiLCJNIiwiX19uIiwib3duZXJTVkdFbGVtZW50IiwiTiIsIkgkMSIsImEiLCJ2IiwiayIsImIiLCJnIiwibSIsInciLCJBcnJheSIsImlzQXJyYXkiLCJJJDEiLCJ6JDEiLCJMJDEiLCJuZXh0U2libGluZyIsInEiLCJTIiwiaiQyIiwic29tZSIsImFwcGVuZENoaWxkIiwiaW5zZXJ0QmVmb3JlIiwiYyIsIlAiLCJDIiwiVCIsIiQiLCJjb250ZXh0VHlwZSIsInZhbHVlIiwiX19FIiwicHJvdG90eXBlIiwicmVuZGVyIiwiQiQxIiwic3ViIiwic3RhdGUiLCJfc2IiLCJfX3MiLCJnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMiLCJjb21wb25lbnRXaWxsTW91bnQiLCJjb21wb25lbnREaWRNb3VudCIsImNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMiLCJzaG91bGRDb21wb25lbnRVcGRhdGUiLCJmb3JFYWNoIiwiY29tcG9uZW50V2lsbFVwZGF0ZSIsImNvbXBvbmVudERpZFVwZGF0ZSIsImdldENoaWxkQ29udGV4dCIsImdldFNuYXBzaG90QmVmb3JlVXBkYXRlIiwiTyIsImRpZmZlZCIsImxvY2FsTmFtZSIsIm5vZGVUeXBlIiwiZG9jdW1lbnQiLCJjcmVhdGVUZXh0Tm9kZSIsImNyZWF0ZUVsZW1lbnROUyIsImNyZWF0ZUVsZW1lbnQiLCJpcyIsImRhdGEiLCJjaGlsZE5vZGVzIiwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwiLCJhdHRyaWJ1dGVzIiwibmFtZSIsIl9faHRtbCIsImlubmVySFRNTCIsImNoZWNrZWQiLCJ1bm1vdW50IiwiY29tcG9uZW50V2lsbFVubW91bnQiLCJEJDEiLCJmaXJzdENoaWxkIiwiRSIsIkYkMSIsIkckMSIsIkNvbnN1bWVyIiwiUHJvdmlkZXIiLCJzcGxpY2UiLCJnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IiLCJzZXRTdGF0ZSIsImNvbXBvbmVudERpZENhdGNoIiwiZm9yY2VVcGRhdGUiLCJQcm9taXNlIiwidGhlbiIsImJpbmQiLCJyZXNvbHZlIiwiX19IIiwidyQxIiwiX19OIiwiX19WIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiaiQxIiwiZmlsdGVyIiwiZyQxIiwiY2xlYXJUaW1lb3V0IiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJpc1B1cmVSZWFjdENvbXBvbmVudCIsIngiLCJfX2YiLCJJIiwiTCIsIm1hcCIsIlUiLCJEIiwiX191IiwiRiIsIl9fYSIsIlYiLCJfX1IiLCJfX08iLCJwb3AiLCJmYWxsYmFjayIsIlciLCJkZWxldGUiLCJyZXZlYWxPcmRlciIsInNpemUiLCJqIiwiY29udGFpbmVySW5mbyIsImdldCIsIk1hcCIsInJldmVyc2UiLCJzZXQiLCJ6IiwiU3ltYm9sIiwiZm9yIiwiQiIsIkgiLCJaIiwiaXNSZWFjdENvbXBvbmVudCIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJHIiwiSiIsIksiLCJjYW5jZWxCdWJibGUiLCJRIiwiZGVmYXVsdFByZXZlbnRlZCIsInBlcnNpc3QiLCJpc1Byb3BhZ2F0aW9uU3RvcHBlZCIsImlzRGVmYXVsdFByZXZlbnRlZCIsIm5hdGl2ZUV2ZW50Iiwibm4iLCJjbGFzcyIsInRuIiwibXVsdGlwbGUiLCJzZWxlY3RlZCIsImRlZmF1bHRWYWx1ZSIsImNsYXNzTmFtZSIsImVudW1lcmFibGUiLCIkJHR5cGVvZiIsImVuIiwic3R5bGVUZXh0cyIsInN0eWxlRWxzIiwiaW5qZWN0U3R5bGVzIiwic3R5bGVUZXh0Iiwic3R5bGVFbCIsImFwcGVuZFN0eWxlc1RvIiwiZW5zdXJlRWxIYXNTdHlsZXMiLCJlbCIsImlzQ29ubmVjdGVkIiwicmVnaXN0ZXJTdHlsZXNSb290IiwiZ2V0Um9vdE5vZGUiLCJyb290Tm9kZSIsInF1ZXJ5U2VsZWN0b3IiLCJub25jZSIsImdldE5vbmNlVmFsdWUiLCJwYXJlbnRFbCIsImhlYWQiLCJoeWRyYXRlU3R5bGVzUm9vdCIsInNoZWV0IiwicnVsZUNudCIsImNzc1J1bGVzIiwic3BsaXQiLCJzdHlsZVN0ciIsInRyaW0iLCJpbnNlcnRSdWxlIiwicXVlcmllZE5vbmNlVmFsdWUiLCJ1bmRlZmluZWQiLCJxdWVyeU5vbmNlVmFsdWUiLCJtZXRhV2l0aE5vbmNlIiwiaGFzQXR0cmlidXRlIiwiZ2V0QXR0cmlidXRlIiwiZWxXaXRoTm9uY2UiLCJjc3NfMjQ4eiQ0IiwicmVtb3ZlRWxlbWVudCIsImVsZW1lbnRDbG9zZXN0Iiwic2VsZWN0b3IiLCJjbG9zZXN0IiwiZG9jdW1lbnRFbGVtZW50IiwiY29udGFpbnMiLCJlbGVtZW50TWF0Y2hlcyIsInBhcmVudEVsZW1lbnQiLCJtZXRob2QiLCJtYXRjaGVzIiwibWF0Y2hlc1NlbGVjdG9yIiwibXNNYXRjaGVzU2VsZWN0b3IiLCJmaW5kRWxlbWVudHMiLCJjb250YWluZXIiLCJjb250YWluZXJzIiwiSFRNTEVsZW1lbnQiLCJhbGxNYXRjaGVzIiwicXVlcnlTZWxlY3RvckFsbCIsImZpbmREaXJlY3RDaGlsZHJlbiIsInBhcmVudCIsInBhcmVudHMiLCJjaGlsZE5vZGUiLCJQSVhFTF9QUk9QX1JFIiwiYXBwbHlTdHlsZSIsInByb3BOYW1lIiwiYXBwbHlTdHlsZVByb3AiLCJ2YWwiLCJnZXRFdmVudFRhcmdldFZpYVJvb3QiLCJldiIsIl9hIiwiX2IiLCJjb21wb3NlZFBhdGgiLCJ0YXJnZXQiLCJndWlkJDEiLCJnZXRVbmlxdWVEb21JZCIsInByZXZlbnREZWZhdWx0IiwiYnVpbGREZWxlZ2F0aW9uSGFuZGxlciIsImhhbmRsZXIiLCJtYXRjaGVkQ2hpbGQiLCJsaXN0ZW5CeVNlbGVjdG9yIiwiZXZlbnRUeXBlIiwiYXR0YWNoZWRIYW5kbGVyIiwibGlzdGVuVG9Ib3ZlckJ5U2VsZWN0b3IiLCJvbk1vdXNlRW50ZXIiLCJvbk1vdXNlTGVhdmUiLCJjdXJyZW50TWF0Y2hlZENoaWxkIiwibW91c2VPdmVyRXYiLCJyZWFsT25Nb3VzZUxlYXZlIiwibW91c2VMZWF2ZUV2IiwidHJhbnNpdGlvbkV2ZW50TmFtZXMiLCJ3aGVuVHJhbnNpdGlvbkRvbmUiLCJjYWxsYmFjayIsInJlYWxDYWxsYmFjayIsImV2ZW50TmFtZSIsImNyZWF0ZUFyaWFDbGlja0F0dHJzIiwiYXNzaWduIiwib25DbGljayIsImNyZWF0ZUFyaWFLZXlib2FyZEF0dHJzIiwidGFiSW5kZXgiLCJvbktleURvd24iLCJndWlkTnVtYmVyIiwiZ3VpZCIsIlN0cmluZyIsImRpc2FibGVDdXJzb3IiLCJib2R5IiwiY2xhc3NMaXN0IiwiYWRkIiwiZW5hYmxlQ3Vyc29yIiwicmVtb3ZlIiwicHJldmVudFNlbGVjdGlvbiIsInVzZXJTZWxlY3QiLCJhbGxvd1NlbGVjdGlvbiIsInByZXZlbnRDb250ZXh0TWVudSIsImFsbG93Q29udGV4dE1lbnUiLCJwYXJzZUZpZWxkU3BlY3MiLCJpbnB1dCIsInNwZWNzIiwidG9rZW5zIiwidG9rZW4iLCJjaGFyQXQiLCJmaWVsZCIsInN1YnN0cmluZyIsIm9yZGVyIiwiZnVuYyIsImNvbXBhcmVCeUZpZWxkU3BlY3MiLCJvYmowIiwib2JqMSIsImZpZWxkU3BlY3MiLCJjbXAiLCJjb21wYXJlQnlGaWVsZFNwZWMiLCJmaWVsZFNwZWMiLCJmbGV4aWJsZUNvbXBhcmUiLCJsb2NhbGVDb21wYXJlIiwicGFkU3RhcnQiLCJsZW4iLCJzdWJzdHIiLCJmb3JtYXRXaXRoT3JkaW5hbHMiLCJmb3JtYXR0ZXIiLCJhcmdzIiwiZmFsbGJhY2tUZXh0IiwicmVkdWNlIiwic3RyIiwiYXJnIiwiaW5kZXgiLCJjb21wYXJlTnVtYmVycyIsImlzSW50IiwiY29tcHV0ZVNtYWxsZXN0Q2VsbFdpZHRoIiwiY2VsbEVsIiwiYWxsV2lkdGhFbCIsImNvbnRlbnRXaWR0aEVsIiwiRXJyb3IiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJ3aWR0aCIsIklOVEVSTkFMX1VOSVRTIiwiUEFSU0VfUkUiLCJjcmVhdGVEdXJhdGlvbiIsInVuaXQiLCJwYXJzZVN0cmluZyIsInBhcnNlT2JqZWN0IiwiZXhlYyIsInNpZ24iLCJ5ZWFycyIsIm1vbnRocyIsImRheXMiLCJwYXJzZUludCIsIm1pbGxpc2Vjb25kcyIsIm9iaiIsImR1cmF0aW9uIiwieWVhciIsIm1vbnRoIiwiZGF5IiwiaG91cnMiLCJob3VyIiwibWludXRlcyIsIm1pbnV0ZSIsInNlY29uZHMiLCJzZWNvbmQiLCJtaWxsaXNlY29uZCIsIm1zIiwid2Vla3MiLCJ3ZWVrIiwic3BlY2lmaWVkV2Vla3MiLCJkdXJhdGlvbnNFcXVhbCIsImQwIiwiZDEiLCJhc0NsZWFuRGF5cyIsImR1ciIsImFkZER1cmF0aW9ucyIsInN1YnRyYWN0RHVyYXRpb25zIiwibXVsdGlwbHlEdXJhdGlvbiIsImFzUm91Z2hZZWFycyIsImFzUm91Z2hEYXlzIiwiYXNSb3VnaE1vbnRocyIsImFzUm91Z2hNcyIsImFzUm91Z2hNaW51dGVzIiwiYXNSb3VnaFNlY29uZHMiLCJ3aG9sZURpdmlkZUR1cmF0aW9ucyIsIm51bWVyYXRvciIsImRlbm9taW5hdG9yIiwicmVzIiwibG9jYWxSZXMiLCJncmVhdGVzdER1cmF0aW9uRGVub21pbmF0b3IiLCJoYXNPd25Qcm9wZXJ0eSIsIm1lcmdlUHJvcHMiLCJwcm9wT2JqcyIsImNvbXBsZXhQcm9wc01hcCIsImRlc3QiLCJpc01heWJlT2JqZWN0c0VxdWFsIiwiY29tcGxleE9ianMiLCJ1bnNoaWZ0IiwiZmlsdGVySGFzaCIsImhhc2giLCJmaWx0ZXJlZCIsIm1hcEhhc2giLCJuZXdIYXNoIiwiYXJyYXlUb0hhc2giLCJpdGVtIiwiaGFzaFZhbHVlc1RvQXJyYXkiLCJpc1Byb3BzRXF1YWwiLCJIQU5ETEVSX1JFIiwiaXNOb25IYW5kbGVyUHJvcHNFcXVhbCIsImtleXMiLCJnZXRVbmVxdWFsUHJvcHMiLCJjb21wYXJlT2JqcyIsIm9sZFByb3BzIiwibmV3UHJvcHMiLCJlcXVhbGl0eUZ1bmNzIiwiaXNPYmpWYWxzRXF1YWwiLCJ2YWwwIiwidmFsMSIsImNvbXBhcmF0b3IiLCJjb2xsZWN0RnJvbUhhc2giLCJzdGFydEluZGV4IiwiZW5kSW5kZXgiLCJzdGVwIiwicmVtb3ZlRXhhY3QiLCJhcnJheSIsImV4YWN0VmFsIiwicmVtb3ZlQ250IiwiaXNBcnJheXNFcXVhbCIsImEwIiwiYTEiLCJlcXVhbGl0eUZ1bmMiLCJEQVlfSURTIiwiYWRkV2Vla3MiLCJkYXRlVG9VdGNBcnJheSIsImFycmF5VG9VdGNEYXRlIiwiYWRkRGF5cyIsImFkZE1zIiwiZGlmZldlZWtzIiwibTAiLCJtMSIsImRpZmZEYXlzIiwidmFsdWVPZiIsImRpZmZIb3VycyIsImRpZmZNaW51dGVzIiwiZGlmZlNlY29uZHMiLCJkaWZmRGF5QW5kVGltZSIsIm0wZGF5Iiwic3RhcnRPZkRheSIsIm0xZGF5IiwiTWF0aCIsInJvdW5kIiwiZGlmZldob2xlV2Vla3MiLCJkaWZmV2hvbGVEYXlzIiwidGltZUFzTXMiLCJnZXRVVENGdWxsWWVhciIsImdldFVUQ01vbnRoIiwiZ2V0VVRDRGF0ZSIsInN0YXJ0T2ZIb3VyIiwiZ2V0VVRDSG91cnMiLCJzdGFydE9mTWludXRlIiwiZ2V0VVRDTWludXRlcyIsInN0YXJ0T2ZTZWNvbmQiLCJnZXRVVENTZWNvbmRzIiwid2Vla09mWWVhciIsIm1hcmtlciIsImRvdyIsImRveSIsIndlZWtPZkdpdmVuWWVhciIsIm5leHRXIiwibWluIiwiZmlyc3RXZWVrU3RhcnQiLCJmaXJzdFdlZWtPZmZzZXQiLCJkYXlTdGFydCIsImZsb29yIiwiZndkIiwiZndkbHciLCJnZXRVVENEYXkiLCJkYXRlVG9Mb2NhbEFycmF5IiwiZGF0ZSIsImdldEZ1bGxZZWFyIiwiZ2V0TW9udGgiLCJnZXREYXRlIiwiZ2V0SG91cnMiLCJnZXRNaW51dGVzIiwiZ2V0U2Vjb25kcyIsImdldE1pbGxpc2Vjb25kcyIsImFycmF5VG9Mb2NhbERhdGUiLCJEYXRlIiwiZ2V0VVRDTWlsbGlzZWNvbmRzIiwiY29uY2F0IiwiVVRDIiwiaXNWYWxpZERhdGUiLCJpc05hTiIsImJ1aWxkSXNvU3RyaW5nIiwidGltZVpvbmVPZmZzZXQiLCJzdHJpcFplcm9UaW1lIiwidG9JU09TdHJpbmciLCJmb3JtYXRUaW1lWm9uZU9mZnNldCIsImZvcm1hdERheVN0cmluZyIsImZvcm1hdElzb01vbnRoU3RyIiwibWF0Y2giLCJmb3JtYXRJc29UaW1lU3RyaW5nIiwiZG9Jc28iLCJhYnMiLCJtaW5zIiwibWVtb2l6ZSIsIndvcmtlckZ1bmMiLCJyZXNFcXVhbGl0eSIsInRlYXJkb3duRnVuYyIsImN1cnJlbnRBcmdzIiwiY3VycmVudFJlcyIsIm5ld0FyZ3MiLCJhcHBseSIsIm1lbW9pemVPYmpBcmciLCJjdXJyZW50QXJnIiwibmV3QXJnIiwibWVtb2l6ZUFycmF5bGlrZSIsImN1cnJlbnRBcmdTZXRzIiwiY3VycmVudFJlc3VsdHMiLCJuZXdBcmdTZXRzIiwiY3VycmVudExlbiIsIm5ld0xlbiIsIm1lbW9pemVIYXNobGlrZSIsImN1cnJlbnRBcmdIYXNoIiwiY3VycmVudFJlc0hhc2giLCJuZXdBcmdIYXNoIiwibmV3UmVzSGFzaCIsIkVYVEVOREVEX1NFVFRJTkdTX0FORF9TRVZFUklUSUVTIiwic2VwYXJhdG9yIiwib21pdFplcm9NaW51dGUiLCJtZXJpZGllbSIsIm9taXRDb21tYXMiLCJTVEFOREFSRF9EQVRFX1BST1BfU0VWRVJJVElFUyIsInRpbWVab25lTmFtZSIsImVyYSIsIndlZWtkYXkiLCJNRVJJRElFTV9SRSIsIkNPTU1BX1JFIiwiTVVMVElfU1BBQ0VfUkUiLCJMVFJfUkUiLCJVVENfUkUiLCJOYXRpdmVGb3JtYXR0ZXIiLCJmb3JtYXRTZXR0aW5ncyIsInN0YW5kYXJkRGF0ZVByb3BzIiwiZXh0ZW5kZWRTZXR0aW5ncyIsInNldmVyaXR5IiwibWF4IiwiYnVpbGRGb3JtYXR0aW5nRnVuYyIsImZvcm1hdCIsImZvcm1hdFJhbmdlIiwic3RhcnQiLCJlbmQiLCJiZXR0ZXJEZWZhdWx0U2VwYXJhdG9yIiwiZGlmZlNldmVyaXR5IiwiY29tcHV0ZU1hcmtlckRpZmZTZXZlcml0eSIsImNhbGVuZGFyU3lzdGVtIiwiYmlnZ2VzdFVuaXRGb3JQYXJ0aWFsIiwiZnVsbDAiLCJmdWxsMSIsInBhcnRpYWxEYXRlUHJvcHMiLCJjb21wdXRlUGFydGlhbEZvcm1hdHRpbmdPcHRpb25zIiwicGFydGlhbEZvcm1hdHRpbmdGdW5jIiwicGFydGlhbDAiLCJwYXJ0aWFsMSIsImluc2VydGlvbiIsImZpbmRDb21tb25JbnNlcnRpb24iLCJkZWZhdWx0U2VwYXJhdG9yIiwiYmVmb3JlIiwiYWZ0ZXIiLCJnZXRMYXJnZXN0VW5pdCIsInN0YW5kYXJkRGF0ZVByb3BDbnQiLCJmb3JtYXRXZWVrTnVtYmVyIiwiY29tcHV0ZVdlZWtOdW1iZXIiLCJ3ZWVrVGV4dCIsIndlZWtUZXh0TG9uZyIsImxvY2FsZSIsImJ1aWxkTmF0aXZlRm9ybWF0dGluZ0Z1bmMiLCJzYW5pdGl6ZVNldHRpbmdzIiwidGltZVpvbmUiLCJub3JtYWxGb3JtYXQiLCJJbnRsIiwiRGF0ZVRpbWVGb3JtYXQiLCJjb2RlcyIsInplcm9Gb3JtYXQiLCJ6ZXJvUHJvcHMiLCJwb3N0UHJvY2VzcyIsImluamVjdFR6b1N0ciIsInRvTG9jYWxlTG93ZXJDYXNlIiwidHpvU3RyIiwicmVwbGFjZWQiLCJudW0iLCJkaXNwbGF5IiwicGFydHMiLCJzaW1wbGVOdW1iZXJGb3JtYXQiLCJvcHRpb25zIiwiZGlyZWN0aW9uIiwiam9pbiIsImNhIiwiZ2V0TWFya2VyWWVhciIsImdldE1hcmtlck1vbnRoIiwiZ2V0TWFya2VyRGF5IiwiYmlnZ2VzdFVuaXQiLCJwYXJ0aWFsT3B0aW9ucyIsImkwIiwiZm91bmQwIiwiYmVmb3JlMCIsImFmdGVyMCIsImkxIiwiZm91bmQxIiwiYmVmb3JlMSIsImFmdGVyMSIsImV4cGFuZFpvbmVkTWFya2VyIiwiZGF0ZUluZm8iLCJtYXJrZXJUb0FycmF5IiwiY3JlYXRlVmVyYm9zZUZvcm1hdHRpbmdBcmciLCJzdGFydEluZm8iLCJlbmRJbmZvIiwibG9jYWxlQ29kZXMiLCJDbWRGb3JtYXR0ZXIiLCJjbWRTdHIiLCJjbWRGb3JtYXR0ZXIiLCJGdW5jRm9ybWF0dGVyIiwiY3JlYXRlRm9ybWF0dGVyIiwiQkFTRV9PUFRJT05fUkVGSU5FUlMiLCJuYXZMaW5rRGF5Q2xpY2siLCJpZGVudGl0eSIsIm5hdkxpbmtXZWVrQ2xpY2siLCJib290c3RyYXBGb250QXdlc29tZSIsImJ1dHRvbkljb25zIiwiY3VzdG9tQnV0dG9ucyIsImRlZmF1bHRBbGxEYXlFdmVudER1cmF0aW9uIiwiZGVmYXVsdFRpbWVkRXZlbnREdXJhdGlvbiIsIm5leHREYXlUaHJlc2hvbGQiLCJzY3JvbGxUaW1lIiwic2Nyb2xsVGltZVJlc2V0IiwiQm9vbGVhbiIsInNsb3RNaW5UaW1lIiwic2xvdE1heFRpbWUiLCJkYXlQb3BvdmVyRm9ybWF0Iiwic2xvdER1cmF0aW9uIiwic25hcER1cmF0aW9uIiwiaGVhZGVyVG9vbGJhciIsImZvb3RlclRvb2xiYXIiLCJkZWZhdWx0UmFuZ2VTZXBhcmF0b3IiLCJ0aXRsZVJhbmdlU2VwYXJhdG9yIiwiZm9yY2VFdmVudER1cmF0aW9uIiwiZGF5SGVhZGVycyIsImRheUhlYWRlckZvcm1hdCIsImRheUhlYWRlckNsYXNzTmFtZXMiLCJkYXlIZWFkZXJDb250ZW50IiwiZGF5SGVhZGVyRGlkTW91bnQiLCJkYXlIZWFkZXJXaWxsVW5tb3VudCIsImRheUNlbGxDbGFzc05hbWVzIiwiZGF5Q2VsbENvbnRlbnQiLCJkYXlDZWxsRGlkTW91bnQiLCJkYXlDZWxsV2lsbFVubW91bnQiLCJpbml0aWFsVmlldyIsImFzcGVjdFJhdGlvIiwiTnVtYmVyIiwid2Vla2VuZHMiLCJ3ZWVrTnVtYmVyQ2FsY3VsYXRpb24iLCJ3ZWVrTnVtYmVycyIsIndlZWtOdW1iZXJDbGFzc05hbWVzIiwid2Vla051bWJlckNvbnRlbnQiLCJ3ZWVrTnVtYmVyRGlkTW91bnQiLCJ3ZWVrTnVtYmVyV2lsbFVubW91bnQiLCJlZGl0YWJsZSIsInZpZXdDbGFzc05hbWVzIiwidmlld0RpZE1vdW50Iiwidmlld1dpbGxVbm1vdW50Iiwibm93SW5kaWNhdG9yIiwibm93SW5kaWNhdG9yQ2xhc3NOYW1lcyIsIm5vd0luZGljYXRvckNvbnRlbnQiLCJub3dJbmRpY2F0b3JEaWRNb3VudCIsIm5vd0luZGljYXRvcldpbGxVbm1vdW50Iiwic2hvd05vbkN1cnJlbnREYXRlcyIsImxhenlGZXRjaGluZyIsInN0YXJ0UGFyYW0iLCJlbmRQYXJhbSIsInRpbWVab25lUGFyYW0iLCJsb2NhbGVzIiwidGhlbWVTeXN0ZW0iLCJkcmFnUmV2ZXJ0RHVyYXRpb24iLCJkcmFnU2Nyb2xsIiwiYWxsRGF5TWFpbnRhaW5EdXJhdGlvbiIsInVuc2VsZWN0QXV0byIsImRyb3BBY2NlcHQiLCJldmVudE9yZGVyIiwiZXZlbnRPcmRlclN0cmljdCIsImhhbmRsZVdpbmRvd1Jlc2l6ZSIsIndpbmRvd1Jlc2l6ZURlbGF5IiwibG9uZ1ByZXNzRGVsYXkiLCJldmVudERyYWdNaW5EaXN0YW5jZSIsImV4cGFuZFJvd3MiLCJoZWlnaHQiLCJjb250ZW50SGVpZ2h0Iiwid2Vla051bWJlckZvcm1hdCIsImV2ZW50UmVzaXphYmxlRnJvbVN0YXJ0IiwiZGlzcGxheUV2ZW50VGltZSIsImRpc3BsYXlFdmVudEVuZCIsInByb2dyZXNzaXZlRXZlbnRSZW5kZXJpbmciLCJidXNpbmVzc0hvdXJzIiwiaW5pdGlhbERhdGUiLCJub3ciLCJldmVudERhdGFUcmFuc2Zvcm0iLCJzdGlja3lIZWFkZXJEYXRlcyIsInN0aWNreUZvb3RlclNjcm9sbGJhciIsInZpZXdIZWlnaHQiLCJkZWZhdWx0QWxsRGF5IiwiZXZlbnRTb3VyY2VGYWlsdXJlIiwiZXZlbnRTb3VyY2VTdWNjZXNzIiwiZXZlbnREaXNwbGF5IiwiZXZlbnRTdGFydEVkaXRhYmxlIiwiZXZlbnREdXJhdGlvbkVkaXRhYmxlIiwiZXZlbnRPdmVybGFwIiwiZXZlbnRDb25zdHJhaW50IiwiZXZlbnRBbGxvdyIsImV2ZW50QmFja2dyb3VuZENvbG9yIiwiZXZlbnRCb3JkZXJDb2xvciIsImV2ZW50VGV4dENvbG9yIiwiZXZlbnRDb2xvciIsImV2ZW50Q2xhc3NOYW1lcyIsImV2ZW50Q29udGVudCIsImV2ZW50RGlkTW91bnQiLCJldmVudFdpbGxVbm1vdW50Iiwic2VsZWN0Q29uc3RyYWludCIsInNlbGVjdE92ZXJsYXAiLCJzZWxlY3RBbGxvdyIsImRyb3BwYWJsZSIsInVuc2VsZWN0Q2FuY2VsIiwic2xvdExhYmVsRm9ybWF0Iiwic2xvdExhbmVDbGFzc05hbWVzIiwic2xvdExhbmVDb250ZW50Iiwic2xvdExhbmVEaWRNb3VudCIsInNsb3RMYW5lV2lsbFVubW91bnQiLCJzbG90TGFiZWxDbGFzc05hbWVzIiwic2xvdExhYmVsQ29udGVudCIsInNsb3RMYWJlbERpZE1vdW50Iiwic2xvdExhYmVsV2lsbFVubW91bnQiLCJkYXlNYXhFdmVudHMiLCJkYXlNYXhFdmVudFJvd3MiLCJkYXlNaW5XaWR0aCIsInNsb3RMYWJlbEludGVydmFsIiwiYWxsRGF5VGV4dCIsImFsbERheUNsYXNzTmFtZXMiLCJhbGxEYXlDb250ZW50IiwiYWxsRGF5RGlkTW91bnQiLCJhbGxEYXlXaWxsVW5tb3VudCIsInNsb3RNaW5XaWR0aCIsIm5hdkxpbmtzIiwiZXZlbnRUaW1lRm9ybWF0IiwicmVyZW5kZXJEZWxheSIsIm1vcmVMaW5rVGV4dCIsIm1vcmVMaW5rSGludCIsInNlbGVjdE1pbkRpc3RhbmNlIiwic2VsZWN0YWJsZSIsInNlbGVjdExvbmdQcmVzc0RlbGF5IiwiZXZlbnRMb25nUHJlc3NEZWxheSIsInNlbGVjdE1pcnJvciIsImV2ZW50TWF4U3RhY2siLCJldmVudE1pbkhlaWdodCIsImV2ZW50TWluV2lkdGgiLCJldmVudFNob3J0SGVpZ2h0Iiwic2xvdEV2ZW50T3ZlcmxhcCIsInBsdWdpbnMiLCJmaXJzdERheSIsImRheUNvdW50IiwiZGF0ZUFsaWdubWVudCIsImRhdGVJbmNyZW1lbnQiLCJoaWRkZW5EYXlzIiwiZml4ZWRXZWVrQ291bnQiLCJ2YWxpZFJhbmdlIiwidmlzaWJsZVJhbmdlIiwidGl0bGVGb3JtYXQiLCJldmVudEludGVyYWN0aXZlIiwibm9FdmVudHNUZXh0Iiwidmlld0hpbnQiLCJuYXZMaW5rSGludCIsImNsb3NlSGludCIsInRpbWVIaW50IiwiZXZlbnRIaW50IiwibW9yZUxpbmtDbGljayIsIm1vcmVMaW5rQ2xhc3NOYW1lcyIsIm1vcmVMaW5rQ29udGVudCIsIm1vcmVMaW5rRGlkTW91bnQiLCJtb3JlTGlua1dpbGxVbm1vdW50IiwibW9udGhTdGFydEZvcm1hdCIsImhhbmRsZUN1c3RvbVJlbmRlcmluZyIsImN1c3RvbVJlbmRlcmluZ01ldGFNYXAiLCJjdXN0b21SZW5kZXJpbmdSZXBsYWNlc0VsIiwiQkFTRV9PUFRJT05fREVGQVVMVFMiLCJjZW50ZXIiLCJDQUxFTkRBUl9MSVNURU5FUl9SRUZJTkVSUyIsImRhdGVzU2V0IiwiZXZlbnRzU2V0IiwiZXZlbnRBZGQiLCJldmVudENoYW5nZSIsImV2ZW50UmVtb3ZlIiwid2luZG93UmVzaXplIiwiZXZlbnRDbGljayIsImV2ZW50TW91c2VFbnRlciIsImV2ZW50TW91c2VMZWF2ZSIsInNlbGVjdCIsInVuc2VsZWN0IiwibG9hZGluZyIsIl91bm1vdW50IiwiX2JlZm9yZXByaW50IiwiX2FmdGVycHJpbnQiLCJfbm9FdmVudERyb3AiLCJfbm9FdmVudFJlc2l6ZSIsIl9yZXNpemUiLCJfc2Nyb2xsUmVxdWVzdCIsIkNBTEVOREFSX09QVElPTl9SRUZJTkVSUyIsImJ1dHRvblRleHQiLCJidXR0b25IaW50cyIsInZpZXdzIiwiaW5pdGlhbEV2ZW50cyIsImV2ZW50cyIsImV2ZW50U291cmNlcyIsIkNPTVBMRVhfT1BUSU9OX0NPTVBBUkFUT1JTIiwiaXNNYXliZUFycmF5c0VxdWFsIiwiVklFV19PUFRJT05fUkVGSU5FUlMiLCJjb21wb25lbnQiLCJidXR0b25UZXh0S2V5IiwiZGF0ZVByb2ZpbGVHZW5lcmF0b3JDbGFzcyIsInVzZXNNaW5NYXhUaW1lIiwiY2xhc3NOYW1lcyIsImNvbnRlbnQiLCJkaWRNb3VudCIsIndpbGxVbm1vdW50IiwibWVyZ2VSYXdPcHRpb25zIiwib3B0aW9uU2V0cyIsInJlZmluZVByb3BzIiwicmVmaW5lcnMiLCJyZWZpbmVkIiwiZXh0cmEiLCJyYXciLCJjcmVhdGVFdmVudEluc3RhbmNlIiwiZGVmSWQiLCJyYW5nZSIsImZvcmNlZFN0YXJ0VHpvIiwiZm9yY2VkRW5kVHpvIiwiaW5zdGFuY2VJZCIsInBhcnNlUmVjdXJyaW5nIiwiZGF0ZUVudiIsInJlY3VycmluZ1R5cGVzIiwicGFyc2VkIiwicGFyc2UiLCJhbGxEYXkiLCJhbGxEYXlHdWVzcyIsInR5cGVEYXRhIiwidHlwZUlkIiwiZXhwYW5kUmVjdXJyaW5nIiwiZXZlbnRTdG9yZSIsImZyYW1pbmdSYW5nZSIsInBsdWdpbkhvb2tzIiwiZGVmcyIsImluc3RhbmNlcyIsImluc3RhbmNlIiwicmVjdXJyaW5nRGVmIiwiZGVmIiwic3RhcnRzIiwiZXhwYW5kUmVjdXJyaW5nUmFuZ2VzIiwiZXZlbnREZWYiLCJ0eXBlRGVmIiwibWFya2VycyIsImV4cGFuZCIsInN1YnRyYWN0IiwicGFyc2VFdmVudHMiLCJyYXdFdmVudHMiLCJldmVudFNvdXJjZSIsImFsbG93T3BlblJhbmdlIiwiZGVmSWRNYXAiLCJpbnN0YW5jZUlkTWFwIiwiY3JlYXRlRW1wdHlFdmVudFN0b3JlIiwiZXZlbnRSZWZpbmVycyIsImJ1aWxkRXZlbnRSZWZpbmVycyIsInJhd0V2ZW50IiwidHVwbGUiLCJwYXJzZUV2ZW50IiwiZXZlbnRUdXBsZVRvU3RvcmUiLCJnZXRSZWxldmFudEV2ZW50cyIsIm5ld1N0b3JlIiwiZmlsdGVyRXZlbnRTdG9yZURlZnMiLCJsb29rRGVmIiwiaXNFdmVudERlZnNHcm91cGVkIiwiZGVmMCIsImRlZjEiLCJncm91cElkIiwibWVyZ2VFdmVudFN0b3JlcyIsInN0b3JlMCIsInN0b3JlMSIsImZpbHRlckZ1bmMiLCJleGNsdWRlU3ViRXZlbnRTdG9yZSIsIm1hc3RlciIsImZpbHRlcmVkRGVmcyIsImZpbHRlcmVkSW5zdGFuY2VzIiwibm9ybWFsaXplQ29uc3RyYWludCIsInBhcnNlQ2xhc3NOYW1lcyIsIkVWRU5UX1VJX1JFRklORVJTIiwic3RhcnRFZGl0YWJsZSIsImR1cmF0aW9uRWRpdGFibGUiLCJjb25zdHJhaW50Iiwib3ZlcmxhcCIsImFsbG93IiwiY29sb3IiLCJiYWNrZ3JvdW5kQ29sb3IiLCJib3JkZXJDb2xvciIsInRleHRDb2xvciIsIkVNUFRZX0VWRU5UX1VJIiwiY29uc3RyYWludHMiLCJhbGxvd3MiLCJjcmVhdGVFdmVudFVpIiwiY29tYmluZUV2ZW50VWlzIiwidWlzIiwiY29tYmluZVR3b0V2ZW50VWlzIiwiaXRlbTAiLCJpdGVtMSIsIkVWRU5UX05PTl9EQVRFX1JFRklORVJTIiwiaWQiLCJ0aXRsZSIsInVybCIsImludGVyYWN0aXZlIiwiRVZFTlRfREFURV9SRUZJTkVSUyIsIkVWRU5UX1JFRklORVJTIiwiZXh0ZW5kZWRQcm9wcyIsInJlZmluZUV2ZW50RGVmIiwiY29tcHV0ZUlzRGVmYXVsdEFsbERheSIsInJlY3VycmluZ1JlcyIsInBhcnNlRXZlbnREZWYiLCJzb3VyY2VJZCIsInNpbmdsZVJlcyIsInBhcnNlU2luZ2xlIiwiaGFzRW5kIiwicHVibGljSWQiLCJ1aSIsIm1lbWJlckFkZGVyIiwiZXZlbnREZWZNZW1iZXJBZGRlcnMiLCJmcmVlemUiLCJzdGFydE1ldGEiLCJzdGFydE1hcmtlciIsImVuZE1ldGEiLCJlbmRNYXJrZXIiLCJzdGFydElucHV0IiwiY3JlYXRlTWFya2VyTWV0YSIsImlzVGltZVVuc3BlY2lmaWVkIiwiZm9yY2VkVHpvIiwiREVGX0RFRkFVTFRTIiwic3RhcnRUaW1lIiwiZW5kVGltZSIsImRheXNPZldlZWsiLCJwYXJzZUJ1c2luZXNzSG91cnMiLCJyZWZpbmVJbnB1dHMiLCJyYXdEZWZzIiwicmF3RGVmIiwiY29tcHV0ZUFsaWduZWREYXlSYW5nZSIsInRpbWVkUmFuZ2UiLCJkYXlDbnQiLCJjb21wdXRlVmlzaWJsZURheVJhbmdlIiwic3RhcnREYXkiLCJlbmREYXkiLCJlbmRUaW1lTVMiLCJpc011bHRpRGF5UmFuZ2UiLCJkaWZmRGF0ZXMiLCJkYXRlMCIsImRhdGUxIiwibGFyZ2VVbml0IiwiZGlmZldob2xlWWVhcnMiLCJkaWZmV2hvbGVNb250aHMiLCJwb2ludEluc2lkZVJlY3QiLCJwb2ludCIsInJlY3QiLCJsZWZ0IiwicmlnaHQiLCJ0b3AiLCJib3R0b20iLCJpbnRlcnNlY3RSZWN0cyIsInJlY3QxIiwicmVjdDIiLCJ0cmFuc2xhdGVSZWN0IiwiZGVsdGFYIiwiZGVsdGFZIiwiY29uc3RyYWluUG9pbnQiLCJnZXRSZWN0Q2VudGVyIiwiZGlmZlBvaW50cyIsInBvaW50MSIsInBvaW50MiIsImNhblZHcm93V2l0aGluQ2VsbCIsImdldENhblZHcm93V2l0aGluQ2VsbCIsImNvbXB1dGVDYW5WR3Jvd1dpdGhpbkNlbGwiLCJwb3NpdGlvbiIsImRpdiIsInBvc3NpYmxlIiwib2Zmc2V0SGVpZ2h0IiwiRU1QVFlfRVZFTlRfU1RPUkUiLCJTcGxpdHRlciIsImdldEtleXNGb3JFdmVudERlZnMiLCJfZ2V0S2V5c0ZvckV2ZW50RGVmcyIsInNwbGl0RGF0ZVNlbGVjdGlvbiIsIl9zcGxpdERhdGVTcGFuIiwic3BsaXRFdmVudFN0b3JlIiwiX3NwbGl0RXZlbnRTdG9yZSIsInNwbGl0SW5kaXZpZHVhbFVpIiwiX3NwbGl0SW5kaXZpZHVhbFVpIiwic3BsaXRFdmVudERyYWciLCJfc3BsaXRJbnRlcmFjdGlvbiIsInNwbGl0RXZlbnRSZXNpemUiLCJldmVudFVpQnVpbGRlcnMiLCJzcGxpdFByb3BzIiwia2V5SW5mb3MiLCJnZXRLZXlJbmZvIiwiZGVmS2V5cyIsImRhdGVTZWxlY3Rpb25zIiwiZGF0ZVNlbGVjdGlvbiIsImluZGl2aWR1YWxVaSIsImV2ZW50VWlCYXNlcyIsImV2ZW50U3RvcmVzIiwiZXZlbnREcmFncyIsImV2ZW50RHJhZyIsImV2ZW50UmVzaXplcyIsImV2ZW50UmVzaXplIiwiaW5mbyIsImJ1aWxkRXZlbnRVaUZvcktleSIsImtleUluZm8iLCJidWlsZEV2ZW50VWkiLCJldmVudFNlbGVjdGlvbiIsImRhdGVTcGFuIiwiZGF0ZVNwYW5zIiwiZ2V0S2V5c0ZvckRhdGVTcGFuIiwiZ2V0S2V5c0ZvckV2ZW50RGVmIiwic3BsaXRTdG9yZXMiLCJzcGxpdEhhc2hlcyIsImludGVyYWN0aW9uIiwic3BsaXRTdGF0ZXMiLCJhZmZlY3RlZFN0b3JlcyIsImFmZmVjdGVkRXZlbnRzIiwibXV0YXRlZEtleXNCeURlZklkIiwibXV0YXRlZEV2ZW50cyIsIm11dGF0ZWRTdG9yZXMiLCJwb3B1bGF0ZSIsImlzRXZlbnQiLCJhbGxVaSIsImV2ZW50VWlGb3JLZXkiLCJiYXNlUGFydHMiLCJzdHVmZiIsInBhcnNlUmFuZ2UiLCJjcmVhdGVNYXJrZXIiLCJpbnZlcnRSYW5nZXMiLCJyYW5nZXMiLCJjb25zdHJhaW50UmFuZ2UiLCJpbnZlcnRlZFJhbmdlcyIsImRhdGVSYW5nZSIsImNvbXBhcmVSYW5nZXMiLCJyYW5nZTAiLCJyYW5nZTEiLCJpbnRlcnNlY3RSYW5nZXMiLCJuZXdSYW5nZSIsInJhbmdlc0VxdWFsIiwicmFuZ2VzSW50ZXJzZWN0IiwicmFuZ2VDb250YWluc1JhbmdlIiwib3V0ZXJSYW5nZSIsImlubmVyUmFuZ2UiLCJyYW5nZUNvbnRhaW5zTWFya2VyIiwiY29uc3RyYWluTWFya2VyVG9SYW5nZSIsImdldERhdGVNZXRhIiwidG9kYXlSYW5nZSIsIm5vd0RhdGUiLCJkYXRlUHJvZmlsZSIsImlzRGlzYWJsZWQiLCJhY3RpdmVSYW5nZSIsImlzT3RoZXIiLCJjdXJyZW50UmFuZ2UiLCJpc1RvZGF5IiwiaXNQYXN0IiwiaXNGdXR1cmUiLCJnZXREYXlDbGFzc05hbWVzIiwibWV0YSIsInRoZW1lIiwiZ2V0Q2xhc3MiLCJnZXRTbG90Q2xhc3NOYW1lcyIsIkRBWV9GT1JNQVQiLCJXRUVLX0ZPUk1BVCIsImJ1aWxkTmF2TGlua0F0dHJzIiwiZGF0ZU1hcmtlciIsInZpZXdUeXBlIiwiaXNUYWJiYWJsZSIsImNhbGVuZGFyQXBpIiwiZGF0ZVN0ciIsInpvbmVkRGF0ZSIsInRvRGF0ZSIsImhhbmRsZUludGVyYWN0aW9uIiwiY3VzdG9tQWN0aW9uIiwiem9vbVRvIiwiX2lzUnRsU2Nyb2xsYmFyT25MZWZ0IiwiZ2V0SXNSdGxTY3JvbGxiYXJPbkxlZnQiLCJjb21wdXRlSXNSdGxTY3JvbGxiYXJPbkxlZnQiLCJvdXRlckVsIiwiYm9yZGVyIiwicGFkZGluZyIsIm92ZXJmbG93IiwiaW5uZXJFbCIsIl9zY3JvbGxiYXJXaWR0aHMiLCJnZXRTY3JvbGxiYXJXaWR0aHMiLCJjb21wdXRlU2Nyb2xsYmFyV2lkdGhzIiwiY29tcHV0ZVNjcm9sbGJhcldpZHRoc0ZvckVsIiwiY2xpZW50SGVpZ2h0Iiwib2Zmc2V0V2lkdGgiLCJjbGllbnRXaWR0aCIsImNvbXB1dGVFZGdlcyIsImdldFBhZGRpbmciLCJjb21wdXRlZFN0eWxlIiwid2luZG93IiwiZ2V0Q29tcHV0ZWRTdHlsZSIsImJvcmRlckxlZnQiLCJib3JkZXJMZWZ0V2lkdGgiLCJib3JkZXJSaWdodCIsImJvcmRlclJpZ2h0V2lkdGgiLCJib3JkZXJUb3AiLCJib3JkZXJUb3BXaWR0aCIsImJvcmRlckJvdHRvbSIsImJvcmRlckJvdHRvbVdpZHRoIiwiYmFkU2Nyb2xsYmFyV2lkdGhzIiwic2Nyb2xsYmFyTGVmdFJpZ2h0Iiwic2Nyb2xsYmFyQm90dG9tIiwic2Nyb2xsYmFyTGVmdCIsInNjcm9sbGJhclJpZ2h0IiwicGFkZGluZ0xlZnQiLCJwYWRkaW5nUmlnaHQiLCJwYWRkaW5nVG9wIiwicGFkZGluZ0JvdHRvbSIsImNvbXB1dGVJbm5lclJlY3QiLCJnb1dpdGhpblBhZGRpbmciLCJkb0Zyb21XaW5kb3dWaWV3cG9ydCIsIm91dGVyUmVjdCIsImNvbXB1dGVSZWN0IiwiZWRnZXMiLCJwYWdlWE9mZnNldCIsInBhZ2VZT2Zmc2V0IiwiY29tcHV0ZUNsaXBwZWRDbGllbnRSZWN0IiwiY2xpcHBpbmdQYXJlbnRzIiwiZ2V0Q2xpcHBpbmdQYXJlbnRzIiwiY2xpcHBpbmdQYXJlbnQiLCJpbnRlcnNlY3Rpb24iLCJvdmVyZmxvd1kiLCJvdmVyZmxvd1giLCJ1bnByb21pc2lmeSIsIm5vcm1hbGl6ZWRTdWNjZXNzQ2FsbGJhY2siLCJub3JtYWxpemVkRmFpbHVyZUNhbGxiYWNrIiwiaXNSZXNvbHZlZCIsIndyYXBwZWRTdWNjZXNzIiwid3JhcHBlZEZhaWx1cmUiLCJlcnJvciIsIkVtaXR0ZXIiLCJoYW5kbGVycyIsInRoaXNDb250ZXh0Iiwic2V0VGhpc0NvbnRleHQiLCJzZXRPcHRpb25zIiwib24iLCJhZGRUb0hhc2giLCJvZmYiLCJyZW1vdmVGcm9tSGFzaCIsInRyaWdnZXIiLCJhdHRhY2hlZEhhbmRsZXJzIiwib3B0aW9uSGFuZGxlciIsImhhc0hhbmRsZXJzIiwiUG9zaXRpb25DYWNoZSIsIm9yaWdpbkVsIiwiZWxzIiwiaXNIb3Jpem9udGFsIiwiaXNWZXJ0aWNhbCIsIm9yaWdpbkNsaWVudFJlY3QiLCJidWlsZEVsSG9yaXpvbnRhbHMiLCJidWlsZEVsVmVydGljYWxzIiwib3JpZ2luQ2xpZW50TGVmdCIsImxlZnRzIiwicmlnaHRzIiwib3JpZ2luQ2xpZW50VG9wIiwidG9wcyIsImJvdHRvbXMiLCJsZWZ0VG9JbmRleCIsImxlZnRQb3NpdGlvbiIsInRvcFRvSW5kZXgiLCJ0b3BQb3NpdGlvbiIsImdldFdpZHRoIiwibGVmdEluZGV4IiwiZ2V0SGVpZ2h0IiwidG9wSW5kZXgiLCJzaW1pbGFyVG8iLCJvdGhlckNhY2hlIiwic2ltaWxhck51bUFycmF5cyIsIlNjcm9sbENvbnRyb2xsZXIiLCJnZXRNYXhTY3JvbGxUb3AiLCJnZXRTY3JvbGxIZWlnaHQiLCJnZXRDbGllbnRIZWlnaHQiLCJnZXRNYXhTY3JvbGxMZWZ0IiwiZ2V0U2Nyb2xsV2lkdGgiLCJnZXRDbGllbnRXaWR0aCIsImNhblNjcm9sbFZlcnRpY2FsbHkiLCJjYW5TY3JvbGxIb3Jpem9udGFsbHkiLCJjYW5TY3JvbGxVcCIsImdldFNjcm9sbFRvcCIsImNhblNjcm9sbERvd24iLCJjYW5TY3JvbGxMZWZ0IiwiZ2V0U2Nyb2xsTGVmdCIsImNhblNjcm9sbFJpZ2h0IiwiRWxlbWVudFNjcm9sbENvbnRyb2xsZXIiLCJzY3JvbGxUb3AiLCJzY3JvbGxMZWZ0Iiwic2V0U2Nyb2xsVG9wIiwic2V0U2Nyb2xsTGVmdCIsInNjcm9sbFdpZHRoIiwic2Nyb2xsSGVpZ2h0IiwiV2luZG93U2Nyb2xsQ29udHJvbGxlciIsInNjcm9sbCIsIlRoZW1lIiwiY2FsZW5kYXJPcHRpb25zIiwiaWNvbk92ZXJyaWRlT3B0aW9uIiwic2V0SWNvbk92ZXJyaWRlIiwiaWNvbk92ZXJyaWRlSGFzaCIsImljb25DbGFzc2VzQ29weSIsImJ1dHRvbk5hbWUiLCJpY29uQ2xhc3NlcyIsImFwcGx5SWNvbk92ZXJyaWRlUHJlZml4IiwicHJlZml4IiwiaWNvbk92ZXJyaWRlUHJlZml4IiwiY2xhc3NlcyIsImdldEljb25DbGFzcyIsImlzUnRsIiwicnRsSWNvbkNsYXNzZXMiLCJiYXNlSWNvbkNsYXNzIiwiZ2V0Q3VzdG9tQnV0dG9uSWNvbkNsYXNzIiwiY3VzdG9tQnV0dG9uUHJvcHMiLCJpY29uT3ZlcnJpZGVDdXN0b21CdXR0b25PcHRpb24iLCJmbHVzaFN5bmMiLCJydW5CZWZvcmVGbHVzaCIsIm9sZERlYm91bmNlUmVuZGVyaW5nIiwiY2FsbGJhY2tRIiwiZXhlY0NhbGxiYWNrU3luYyIsIkZha2VDb21wb25lbnQiLCJjcmVhdGVDb250ZXh0IiwiQ29udGV4dFR5cGUiLCJvcmlnUHJvdmlkZXIiLCJpc05ldyIsInN1YnMiLCJfcHJvcHMiLCJvbGQiLCJTY3JvbGxSZXNwb25kZXIiLCJleGVjRnVuYyIsImVtaXR0ZXIiLCJoYW5kbGVTY3JvbGxSZXF1ZXN0IiwicmVxdWVzdCIsInF1ZXVlZFJlcXVlc3QiLCJkcmFpbiIsImZpcmVJbml0aWFsU2Nyb2xsIiwiZGV0YWNoIiwidXBkYXRlIiwiaXNEYXRlc05ldyIsInRpbWUiLCJWaWV3Q29udGV4dFR5cGUiLCJidWlsZFZpZXdDb250ZXh0Iiwidmlld1NwZWMiLCJ2aWV3QXBpIiwidmlld09wdGlvbnMiLCJkYXRlUHJvZmlsZUdlbmVyYXRvciIsImRpc3BhdGNoIiwiZ2V0Q3VycmVudERhdGEiLCJyZWdpc3RlckludGVyYWN0aXZlQ29tcG9uZW50IiwidW5yZWdpc3RlckludGVyYWN0aXZlQ29tcG9uZW50IiwiYWRkUmVzaXplSGFuZGxlciIsInJlbW92ZVJlc2l6ZUhhbmRsZXIiLCJjcmVhdGVTY3JvbGxSZXNwb25kZXIiLCJQdXJlQ29tcG9uZW50IiwibmV4dFByb3BzIiwibmV4dFN0YXRlIiwiZGVidWciLCJjb25zb2xlIiwibG9nIiwicHJvcEVxdWFsaXR5Iiwic3RhdGVFcXVhbGl0eSIsInNhZmVTZXRTdGF0ZSIsIm5ld1N0YXRlIiwiYWRkUHJvcHNFcXVhbGl0eSIsImFkZFN0YXRlRXF1YWxpdHkiLCJCYXNlQ29tcG9uZW50IiwiY3JlYXRlIiwic2V0UmVmIiwiRGF0ZUNvbXBvbmVudCIsInVpZCIsInByZXBhcmVIaXRzIiwicXVlcnlIaXQiLCJwb3NpdGlvbkxlZnQiLCJwb3NpdGlvblRvcCIsImVsV2lkdGgiLCJlbEhlaWdodCIsImlzVmFsaWRTZWdEb3duRWwiLCJpc1ZhbGlkRGF0ZURvd25FbCIsInJlZHVjZUN1cnJlbnREYXRlIiwiY3VycmVudERhdGUiLCJhY3Rpb24iLCJnZXRJbml0aWFsRGF0ZSIsImluaXRpYWxEYXRlSW5wdXQiLCJnZXROb3ciLCJub3dJbnB1dCIsImNyZWF0ZU5vd01hcmtlciIsIkRhdGVQcm9maWxlR2VuZXJhdG9yIiwiaW5pdEhpZGRlbkRheXMiLCJidWlsZFByZXYiLCJjdXJyZW50RGF0ZVByb2ZpbGUiLCJmb3JjZVRvVmFsaWQiLCJwcmV2RGF0ZSIsInN0YXJ0T2YiLCJjdXJyZW50UmFuZ2VVbml0IiwiYnVpbGQiLCJidWlsZE5leHQiLCJuZXh0RGF0ZSIsImN1cnJlbnRJbmZvIiwiaXNSYW5nZUFsbERheSIsInJlbmRlclJhbmdlIiwiaXNWYWxpZCIsImJ1aWxkVmFsaWRSYW5nZSIsInRyaW1IaWRkZW5EYXlzIiwiYnVpbGRDdXJyZW50UmFuZ2VJbmZvIiwiYnVpbGRSZW5kZXJSYW5nZSIsImFkanVzdEFjdGl2ZVJhbmdlIiwiYnVpbGREYXRlSW5jcmVtZW50IiwidmFsaWRSYW5nZUlucHV0Iiwic2ltcGxlSW5wdXQiLCJyZWZpbmVSYW5nZSIsImR1cmF0aW9uVW5pdCIsImJ1aWxkUmFuZ2VGcm9tRHVyYXRpb24iLCJidWlsZFJhbmdlRnJvbURheUNvdW50IiwiYnVpbGRDdXN0b21WaXNpYmxlUmFuZ2UiLCJncmVhdGVzdFdob2xlVW5pdCIsImdldEZhbGxiYWNrRHVyYXRpb24iLCJpc0hpZGRlbkRheSIsInNraXBIaWRkZW5EYXlzIiwiY29tcHV0ZVJlcyIsInJ1bm5pbmdDb3VudCIsInZpc2libGVSYW5nZUlucHV0IiwiY3VzdG9tQWxpZ25tZW50IiwicmFuZ2VJbnB1dCIsImlzSGlkZGVuRGF5SGFzaCIsImluYyIsImlzRXhjbHVzaXZlIiwidHJpZ2dlckRhdGVTZWxlY3QiLCJzZWxlY3Rpb24iLCJwZXYiLCJidWlsZERhdGVTcGFuQXBpV2l0aENvbnRleHQiLCJqc0V2ZW50Iiwib3JpZ0V2ZW50IiwidmlldyIsInRyaWdnZXJEYXRlVW5zZWxlY3QiLCJ0cmFuc2Zvcm0iLCJkYXRlU3BhblRyYW5zZm9ybXMiLCJidWlsZERhdGVTcGFuQXBpIiwiZ2V0RGVmYXVsdEV2ZW50RW5kIiwiYXBwbHlNdXRhdGlvblRvRXZlbnRTdG9yZSIsImV2ZW50Q29uZmlnQmFzZSIsIm11dGF0aW9uIiwiZXZlbnRDb25maWdzIiwiY29tcGlsZUV2ZW50VWlzIiwiYXBwbHlNdXRhdGlvblRvRXZlbnREZWYiLCJhcHBseU11dGF0aW9uVG9FdmVudEluc3RhbmNlIiwiZXZlbnRDb25maWciLCJzdGFuZGFyZFByb3BzIiwic3RhcnREZWx0YSIsImVuZERlbHRhIiwiY29weSIsImFwcGxpZXIiLCJldmVudERlZk11dGF0aW9uQXBwbGllcnMiLCJldmVudEluc3RhbmNlIiwiZm9yY2VBbGxEYXkiLCJjbGVhckVuZCIsImRhdGVzRGVsdGEiLCJFdmVudFNvdXJjZUltcGwiLCJpbnRlcm5hbEV2ZW50U291cmNlIiwicmVmZXRjaCIsInNvdXJjZUlkcyIsImlzUmVmZXRjaCIsIkV2ZW50SW1wbCIsIl9jb250ZXh0IiwiX2RlZiIsIl9pbnN0YW5jZSIsInNldFByb3AiLCJ3YXJuIiwibXV0YXRlIiwic2V0RXh0ZW5kZWRQcm9wIiwic2V0U3RhcnQiLCJpbnN0YW5jZVJhbmdlIiwiZ3JhbnVsYXJpdHkiLCJtYWludGFpbkR1cmF0aW9uIiwic2V0RW5kIiwiZW5kSW5wdXQiLCJzZXREYXRlcyIsIm1vdmVTdGFydCIsImRlbHRhSW5wdXQiLCJkZWx0YSIsIm1vdmVFbmQiLCJtb3ZlRGF0ZXMiLCJzZXRBbGxEYXkiLCJmb3JtYXRJbnB1dCIsInJlbGV2YW50RXZlbnRzIiwib2xkRXZlbnQiLCJyZWxhdGVkRXZlbnRzIiwiYnVpbGRFdmVudEFwaXMiLCJyZXZlcnQiLCJhc1N0b3JlIiwiZXZlbnRBcGlUb1N0b3JlIiwic291cmNlIiwic3RhcnRTdHIiLCJmb3JtYXRJc28iLCJvbWl0VGltZSIsImVuZFN0ciIsInRvUGxhaW5PYmplY3QiLCJzZXR0aW5ncyIsImNvbGxhcHNlQ29sb3IiLCJjb2xsYXBzZUV4dGVuZGVkUHJvcHMiLCJ0b0pTT04iLCJldmVudEFwaSIsImV4Y2x1ZGVJbnN0YW5jZSIsImV2ZW50QXBpcyIsImV4Y2x1ZGVJbnN0YW5jZUlkIiwic2xpY2VFdmVudFN0b3JlIiwiaW52ZXJzZUJnQnlHcm91cElkIiwiaW52ZXJzZUJnQnlEZWZJZCIsImRlZkJ5R3JvdXBJZCIsImJnUmFuZ2VzIiwiZmdSYW5nZXMiLCJldmVudFVpcyIsIm9yaWdSYW5nZSIsIm5vcm1hbFJhbmdlIiwic2xpY2VkUmFuZ2UiLCJpc1N0YXJ0IiwiaXNFbmQiLCJpbnZlcnRlZFJhbmdlIiwiYmciLCJmZyIsImhhc0JnUmVuZGVyaW5nIiwic2V0RWxTZWciLCJzZWciLCJmY1NlZyIsImdldEVsU2VnIiwiZXZlbnREZWZzIiwiY29tcGlsZUV2ZW50VWkiLCJzb3J0RXZlbnRTZWdzIiwic2VncyIsImV2ZW50T3JkZXJTcGVjcyIsIm9ianMiLCJidWlsZFNlZ0NvbXBhcmVPYmoiLCJfc2VnIiwiZXZlbnRSYW5nZSIsImNvbXB1dGVTZWdEcmFnZ2FibGUiLCJ0cmFuc2Zvcm1lcnMiLCJpc0RyYWdnYWJsZVRyYW5zZm9ybWVycyIsInRyYW5zZm9ybWVyIiwiY29tcHV0ZVNlZ1N0YXJ0UmVzaXphYmxlIiwiY29tcHV0ZVNlZ0VuZFJlc2l6YWJsZSIsImJ1aWxkU2VnVGltZVRleHQiLCJ0aW1lRm9ybWF0IiwiZGVmYXVsdERpc3BsYXlFdmVudFRpbWUiLCJkZWZhdWx0RGlzcGxheUV2ZW50RW5kIiwic3RhcnRPdmVycmlkZSIsImVuZE92ZXJyaWRlIiwid2hvbGVFdmVudFN0YXJ0Iiwid2hvbGVFdmVudEVuZCIsInNlZ1N0YXJ0Iiwic2VnRW5kIiwiaXNTdGFydERheSIsImlzRW5kRGF5IiwiZ2V0U2VnTWV0YSIsInNlZ1JhbmdlIiwiZ2V0RXZlbnRDbGFzc05hbWVzIiwiaXNNaXJyb3IiLCJpc0RyYWdnYWJsZSIsImlzU3RhcnRSZXNpemFibGUiLCJpc0VuZFJlc2l6YWJsZSIsImlzRHJhZ2dpbmciLCJpc1Jlc2l6aW5nIiwiaXNTZWxlY3RlZCIsImJ1aWxkRXZlbnRSYW5nZUtleSIsImdldFNlZ0FuY2hvckF0dHJzIiwiaHJlZiIsIlNUQU5EQVJEX1BST1BTIiwicGFyc2VEYXRlU3BhbiIsImRlZmF1bHREdXJhdGlvbiIsInNwYW4iLCJwYXJzZU9wZW5EYXRlU3BhbiIsImlzRGF0ZVNwYW5zRXF1YWwiLCJzcGFuMCIsInNwYW4xIiwiaXNTcGFuUHJvcHNFcXVhbCIsImJ1aWxkUmFuZ2VBcGkiLCJidWlsZFJhbmdlQXBpV2l0aFRpbWVab25lIiwiZmFicmljYXRlRXZlbnRSYW5nZSIsImNhbGVuZGFyU3lzdGVtQ2xhc3NNYXAiLCJyZWdpc3RlckNhbGVuZGFyU3lzdGVtIiwidGhlQ2xhc3MiLCJjcmVhdGVDYWxlbmRhclN5c3RlbSIsIkdyZWdvcmlhbkNhbGVuZGFyU3lzdGVtIiwiYXJyYXlUb01hcmtlciIsImFyciIsIklTT19SRSIsIkRhdGVFbnYiLCJpc05hbWVkVGltZVpvbmUiLCJuYW1lZFRpbWVab25lSW1wbCIsImNhbkNvbXB1dGVPZmZzZXQiLCJ3ZWVrRG93Iiwid2Vla0RveSIsIndlZWtOdW1iZXJGdW5jIiwidGltZXN0YW1wVG9NYXJrZXIiLCJnZXRZZWFyIiwiZ2V0RGF5IiwiYWRkWWVhcnMiLCJhZGRNb250aHMiLCJjb3VudER1cmF0aW9uc0JldHdlZW4iLCJkaWZmIiwic3RhcnRPZlllYXIiLCJzdGFydE9mTW9udGgiLCJzdGFydE9mV2VlayIsImRhdGVPcHRpb25zIiwib2Zmc2V0Rm9yTWFya2VyIiwiaXNFbmRFeGNsdXNpdmUiLCJleHRyYU9wdGlvbnMiLCJvbWl0VGltZVpvbmVPZmZzZXQiLCJ0aW1lc3RhbXBUb0FycmF5IiwiZ2V0VGltZXpvbmVPZmZzZXQiLCJvZmZzZXRGb3JBcnJheSIsIk5hbWVkVGltZVpvbmVJbXBsIiwiU2VnSGllcmFyY2h5Iiwic3RyaWN0T3JkZXIiLCJhbGxvd1Jlc2xpY2luZyIsIm1heENvb3JkIiwibWF4U3RhY2tDbnQiLCJsZXZlbENvb3JkcyIsImVudHJpZXNCeUxldmVsIiwic3RhY2tDbnRzIiwiYWRkU2VncyIsImlucHV0cyIsImhpZGRlbkVudHJpZXMiLCJpbnNlcnRFbnRyeSIsImVudHJ5IiwiZmluZEluc2VydGlvbiIsImlzSW5zZXJ0aW9uVmFsaWQiLCJpbnNlcnRFbnRyeUF0IiwiaGFuZGxlSW52YWxpZEluc2VydGlvbiIsImxldmVsQ29vcmQiLCJ0aGlja25lc3MiLCJzdGFja0NudCIsInRvdWNoaW5nRW50cnkiLCJzcGxpdEVudHJ5IiwiYmFycmllciIsInBhcnRDbnQiLCJzcGxpdEhpZGRlbkVudHJpZXMiLCJlbnRyeVNwYW4iLCJiYXJyaWVyU3BhbiIsImludGVyc2VjdFNwYW5zIiwibGF0ZXJhbCIsImluc2VydEF0IiwibGV2ZWwiLCJidWlsZEVudHJ5S2V5IiwibmV3RW50cnkiLCJsZXZlbENudCIsImNhbmRpZGF0ZUNvb3JkIiwidG91Y2hpbmdMZXZlbCIsInRvdWNoaW5nTGF0ZXJhbCIsInRyYWNraW5nTGV2ZWwiLCJ0cmFja2luZ0Nvb3JkIiwidHJhY2tpbmdFbnRyaWVzIiwidHJhY2tpbmdFbnRyeSIsInNlYXJjaFJlcyIsImJpbmFyeVNlYXJjaCIsImdldEVudHJ5U3BhbkVuZCIsImxhdGVyYWxJbmRleCIsInRyYWNraW5nRW50cnlCb3R0b20iLCJkZXN0TGV2ZWwiLCJkZXN0TGF0ZXJhbCIsInRvUmVjdHMiLCJyZWN0cyIsImVudHJpZXMiLCJncm91cEludGVyc2VjdGluZ0VudHJpZXMiLCJtZXJnZXMiLCJmaWx0ZXJlZE1lcmdlcyIsImh1bmdyeU1lcmdlIiwibWVyZ2UiLCJqb2luU3BhbnMiLCJzZWFyY2hWYWwiLCJnZXRJdGVtVmFsIiwibWlkZGxlSW5kZXgiLCJtaWRkbGVWYWwiLCJJbnRlcmFjdGlvbiIsImlzSGl0Q29tYm9BbGxvd2VkIiwiZGVzdHJveSIsInBhcnNlSW50ZXJhY3Rpb25TZXR0aW5ncyIsInVzZUV2ZW50Q2VudGVyIiwiaW50ZXJhY3Rpb25TZXR0aW5nc1RvU3RvcmUiLCJpbnRlcmFjdGlvblNldHRpbmdzU3RvcmUiLCJFbGVtZW50RHJhZ2dpbmciLCJzZXRNaXJyb3JJc1Zpc2libGUiLCJib29sIiwic2V0TWlycm9yTmVlZHNSZXZlcnQiLCJzZXRBdXRvU2Nyb2xsRW5hYmxlZCIsImNvbmZpZyIsIkRSQUdfTUVUQV9SRUZJTkVSUyIsInBhcnNlRHJhZ01ldGEiLCJsZWZ0b3ZlclByb3BzIiwiQ2FsZW5kYXJSb290IiwiZm9yUHJpbnQiLCJoYW5kbGVCZWZvcmVQcmludCIsImhhbmRsZUFmdGVyUHJpbnQiLCJpc0hlaWdodEF1dG8iLCJjb21wdXRlRmFsbGJhY2tIZWFkZXJGb3JtYXQiLCJkYXRlc1JlcERpc3RpbmN0RGF5cyIsIkNMQVNTX05BTUUiLCJyZW5kZXJJbm5lciQxIiwicmVuZGVyUHJvcHMiLCJ0ZXh0IiwiQ29udGVudEluamVjdG9yIiwicXVldWVkRG9tTm9kZXMiLCJjdXJyZW50RG9tTm9kZXMiLCJoYW5kbGVFbCIsImVsUmVmIiwiY3VzdG9tR2VuZXJhdG9yIiwiZGVmYXVsdEdlbmVyYXRvciIsImF0dHJzIiwiYnVpbGRFbEF0dHJzIiwidXNlRGVmYXVsdCIsImlubmVyQ29udGVudCIsImN1cnJlbnRHZW5lcmF0b3JNZXRhIiwiY3VzdG9tR2VuZXJhdG9yUmVzIiwiaXNPYmplY3QiLCJodG1sIiwiZG9tTm9kZXMiLCJoYXNDdXN0b21SZW5kZXJpbmdIYW5kbGVyIiwiZ2VuZXJhdG9yTmFtZSIsImVsVGFnIiwiYXBwbHlRdWV1ZXVkRG9tTm9kZXMiLCJ0cmlnZ2VyQ3VzdG9tUmVuZGVyaW5nIiwiaXNBY3RpdmUiLCJnZW5lcmF0b3JNZXRhIiwiY29udGFpbmVyRWwiLCJyZXBvcnROZXdDb250YWluZXJFbCIsImVsQ2xhc3NlcyIsImlzVHJ1dGh5IiwibmV3Tm9kZSIsImVsU3R5bGUiLCJlbEF0dHJzIiwiZXh0cmFDbGFzc05hbWVzIiwiUmVuZGVySWQiLCJDb250ZW50Q29udGFpbmVyIiwiSW5uZXJDb250ZW50IiwiSW5uZXJDb250ZW50SW5qZWN0b3IiLCJoYW5kbGVSb290RWwiLCJyb290RWwiLCJnZW5lcmF0ZWRDbGFzc05hbWVzIiwiZ2VuZXJhdGVDbGFzc05hbWVzIiwiY2xhc3NOYW1lR2VuZXJhdG9yIiwicmVuZGVySWQiLCJjb250YWluZXJDb21wb25lbnQiLCJwYXJlbnRQcm9wcyIsIlRhYmxlRGF0ZUNlbGwiLCJkYXlNZXRhIiwibmF2TGlua0F0dHJzIiwiY29sQ250IiwiZXh0cmFSZW5kZXJQcm9wcyIsInJvbGUiLCJjb2xTcGFuIiwiZXh0cmFEYXRhQXR0cnMiLCJJbm5lckNvbnRhaW5lciIsImlzU3RpY2t5IiwiV0VFS0RBWV9GT1JNQVQiLCJUYWJsZURvd0NlbGwiLCJkYXRlTWV0YSIsIk5vd1RpbWVyIiwiaW5pdGlhbE5vd0RhdGUiLCJpbml0aWFsTm93UXVlcmllZE1zIiwiY29tcHV0ZVRpbWluZyIsImN1cnJlbnRTdGF0ZSIsInByZXZQcm9wcyIsInVucm91bmRlZE5vdyIsImN1cnJlbnRVbml0U3RhcnQiLCJuZXh0VW5pdFN0YXJ0Iiwid2FpdE1zIiwiYnVpbGREYXlSYW5nZSIsInRpbWVvdXRJZCIsIkRheUhlYWRlciIsImNyZWF0ZURheUhlYWRlckZvcm1hdHRlciIsImRhdGVzIiwicmVuZGVySW50cm8iLCJleHBsaWNpdEZvcm1hdCIsImRhdGVDbnQiLCJEYXlTZXJpZXNNb2RlbCIsImluZGljZXMiLCJkYXlJbmRleCIsImNudCIsInNsaWNlUmFuZ2UiLCJmaXJzdEluZGV4IiwiZ2V0RGF0ZURheUluZGV4IiwibGFzdEluZGV4IiwiY2xpcHBlZEZpcnN0SW5kZXgiLCJjbGlwcGVkTGFzdEluZGV4IiwiY2VpbCIsImRheU9mZnNldCIsIkRheVRhYmxlTW9kZWwiLCJkYXlTZXJpZXMiLCJicmVha09uV2Vla3MiLCJkYXlzUGVyUm93Iiwicm93Q250IiwiY2VsbHMiLCJidWlsZENlbGxzIiwiaGVhZGVyRGF0ZXMiLCJidWlsZEhlYWRlckRhdGVzIiwicm93cyIsInJvdyIsImNvbCIsImJ1aWxkQ2VsbCIsInNlcmllc1NlZyIsIm5leHRJbmRleCIsImZpcnN0Q29sIiwibGFzdENvbCIsIlNsaWNlciIsInNsaWNlQnVzaW5lc3NIb3VycyIsIl9zbGljZUJ1c2luZXNzSG91cnMiLCJzbGljZURhdGVTZWxlY3Rpb24iLCJfc2xpY2VEYXRlU3BhbiIsIl9zbGljZUV2ZW50U3RvcmUiLCJzbGljZUV2ZW50RHJhZyIsIl9zbGljZUludGVyYWN0aW9uIiwic2xpY2VFdmVudFJlc2l6ZSIsImZvcmNlRGF5SWZMaXN0SXRlbSIsInNsaWNlUHJvcHMiLCJleHRyYUFyZ3MiLCJldmVudFNlZ3MiLCJkYXRlU2VsZWN0aW9uU2VncyIsImJ1c2luZXNzSG91clNlZ3MiLCJmZ0V2ZW50U2VncyIsImJnRXZlbnRTZWdzIiwic2xpY2VOb3dEYXRlIiwiY29tcHV0ZUFjdGl2ZVJhbmdlIiwicmFuZ2VSZXMiLCJzbGljZUV2ZW50UmFuZ2VzIiwiYWZmZWN0ZWRJbnN0YW5jZXMiLCJhY3RpdmVEYXRlU3BhblJhbmdlIiwiZXZlbnRSYW5nZXMiLCJzbGljZUV2ZW50UmFuZ2UiLCJpc0NvbXBvbmVudEFsbERheSIsInJlZHVjZUV2ZW50U3RvcmUiLCJyZWNlaXZlUmF3RXZlbnRzIiwiZmV0Y2hJZCIsImZldGNoUmFuZ2UiLCJyZXNldFJhd0V2ZW50cyIsImFkZEV2ZW50IiwiZXhjbHVkZUV2ZW50c0J5U291cmNlSWQiLCJsYXRlc3RGZXRjaElkIiwic3Vic2V0IiwidHJhbnNmb3JtUmF3RXZlbnRzIiwiZXhpc3RpbmdFdmVudFN0b3JlIiwiYnVpbGRQdWJsaWNJZE1hcHMiLCJuZXdFdmVudFN0b3JlIiwiY2FsRWFjaFRyYW5zZm9ybSIsInNvdXJjZUVhY2hUcmFuc2Zvcm0iLCJ0cmFuc2Zvcm1FYWNoUmF3RXZlbnQiLCJyZWZpbmVkRXZlbnRzIiwicmVmaW5lZEV2ZW50IiwiZXhwYW5kUmFuZ2UiLCJyZXpvbmVFdmVudFN0b3JlRGF0ZXMiLCJvbGREYXRlRW52IiwibmV3RGF0ZUVudiIsImV4Y2x1ZGVJbnN0YW5jZXMiLCJyZW1vdmFscyIsImlzSW50ZXJhY3Rpb25WYWxpZCIsImlzTmV3UHJvcHNWYWxpZCIsImlzRGF0ZVNlbGVjdGlvblZhbGlkIiwiY2FsZW5kYXJTdGF0ZSIsImlzUHJvcHNWYWxpZCIsImRhdGVTcGFuTWV0YSIsImZpbHRlckNvbmZpZyIsImlzSW50ZXJhY3Rpb25Qcm9wc1ZhbGlkIiwiaXNEYXRlU2VsZWN0aW9uUHJvcHNWYWxpZCIsInN1YmplY3RFdmVudFN0b3JlIiwic3ViamVjdERlZnMiLCJzdWJqZWN0SW5zdGFuY2VzIiwic3ViamVjdENvbmZpZ3MiLCJzZWxlY3Rpb25Db25maWciLCJvdGhlckV2ZW50U3RvcmUiLCJvdGhlckRlZnMiLCJvdGhlckluc3RhbmNlcyIsIm90aGVyQ29uZmlncyIsInN1YmplY3RJbnN0YW5jZUlkIiwic3ViamVjdEluc3RhbmNlIiwic3ViamVjdFJhbmdlIiwic3ViamVjdENvbmZpZyIsInN1YmplY3REZWYiLCJhbGxDb25zdHJhaW50c1Bhc3MiLCJldmVudE92ZXJsYXBGdW5jIiwib3RoZXJJbnN0YW5jZUlkIiwib3RoZXJJbnN0YW5jZSIsIm90aGVyT3ZlcmxhcCIsImNhbGVuZGFyRXZlbnRTdG9yZSIsInN1YmplY3RBbGxvdyIsInN1YmplY3REYXRlU3BhbiIsIm9yaWdEZWYiLCJvcmlnSW5zdGFuY2UiLCJyZWxldmFudEV2ZW50U3RvcmUiLCJyZWxldmFudERlZnMiLCJyZWxldmFudEluc3RhbmNlcyIsInNlbGVjdGlvblJhbmdlIiwic2VsZWN0T3ZlcmxhcEZ1bmMiLCJyZWxldmFudEluc3RhbmNlSWQiLCJyZWxldmFudEluc3RhbmNlIiwic2VsZWN0aW9uQWxsb3ciLCJmdWxsRGF0ZVNwYW4iLCJidXNpbmVzc0hvdXJzVW5leHBhbmRlZCIsImFueVJhbmdlc0NvbnRhaW5SYW5nZSIsImNvbnN0cmFpbnRUb1JhbmdlcyIsImV2ZW50U3RvcmVUb1JhbmdlcyIsIm91dGVyUmFuZ2VzIiwiSnNvblJlcXVlc3RFcnJvciIsIm1lc3NhZ2UiLCJyZXNwb25zZSIsInJlcXVlc3RKc29uIiwicGFyYW1zIiwidG9VcHBlckNhc2UiLCJmZXRjaE9wdGlvbnMiLCJVUkxTZWFyY2hQYXJhbXMiLCJoZWFkZXJzIiwiZmV0Y2giLCJmZXRjaFJlcyIsIm9rIiwianNvbiIsInBhcnNlZFJlc3BvbnNlIiwiRGVsYXllZFJ1bm5lciIsImRyYWluZWRPcHRpb24iLCJpc1J1bm5pbmciLCJpc0RpcnR5IiwicGF1c2VEZXB0aHMiLCJkZWxheSIsImlzUGF1c2VkIiwidHJ5RHJhaW4iLCJwYXVzZSIsInNjb3BlIiwicmVzdW1lIiwiZm9yY2UiLCJkZXB0aCIsImRyYWluZWQiLCJjbGVhciIsIlZJU0lCTEVfSElEREVOX1JFIiwiU2Nyb2xsZXIiLCJsaXF1aWQiLCJsaXF1aWRJc0Fic29sdXRlIiwiaXNBYnNvbHV0ZSIsIm92ZXJjb21lTGVmdCIsIm92ZXJjb21lUmlnaHQiLCJvdmVyY29tZUJvdHRvbSIsIm1hcmdpbkxlZnQiLCJtYXJnaW5SaWdodCIsIm1hcmdpbkJvdHRvbSIsIm1heEhlaWdodCIsIm5lZWRzWFNjcm9sbGluZyIsInJlYWxDbGllbnRXaWR0aCIsImdldFlTY3JvbGxiYXJXaWR0aCIsImNoaWxkRWwiLCJuZWVkc1lTY3JvbGxpbmciLCJyZWFsQ2xpZW50SGVpZ2h0IiwiZ2V0WFNjcm9sbGJhcldpZHRoIiwiUmVmTWFwIiwibWFzdGVyQ2FsbGJhY2siLCJjdXJyZW50TWFwIiwiZGVwdGhzIiwiY2FsbGJhY2tNYXAiLCJoYW5kbGVWYWx1ZSIsInJlbW92ZWQiLCJhZGRlZCIsImNyZWF0ZVJlZiIsInJlZkNhbGxiYWNrIiwiY29sbGVjdCIsImdldEFsbCIsImNvbXB1dGVTaHJpbmtXaWR0aCIsImNodW5rRWxzIiwic2hyaW5rQ2VsbHMiLCJsYXJnZXN0V2lkdGgiLCJzaHJpbmtDZWxsIiwiZ2V0U2VjdGlvbkhhc0xpcXVpZEhlaWdodCIsInNlY3Rpb25Db25maWciLCJnZXRBbGxvd1lTY3JvbGxpbmciLCJyZW5kZXJDaHVua0NvbnRlbnQiLCJjaHVua0NvbmZpZyIsImlzSGVhZGVyIiwidGFibGVDbGFzc05hbWUiLCJzeW5jUm93SGVpZ2h0cyIsIm1pbldpZHRoIiwidGFibGVNaW5XaWR0aCIsInRhYmxlQ29sR3JvdXBOb2RlIiwicm93Q29udGVudCIsImlzQ29sUHJvcHNFcXVhbCIsImNvbHMwIiwiY29sczEiLCJyZW5kZXJNaWNyb0NvbEdyb3VwIiwiY29scyIsInNocmlua1dpZHRoIiwiY29sTm9kZXMiLCJjb2xQcm9wcyIsInNhbml0aXplU2hyaW5rV2lkdGgiLCJoYXNTaHJpbmtXaWR0aCIsImdldFNjcm9sbEdyaWRDbGFzc05hbWVzIiwiZ2V0U2VjdGlvbkNsYXNzTmFtZXMiLCJ3aG9sZVRhYmxlVkdyb3ciLCJyZW5kZXJTY3JvbGxTaGltIiwiZ2V0U3RpY2t5SGVhZGVyRGF0ZXMiLCJnZXRTdGlja3lGb290ZXJTY3JvbGxiYXIiLCJTaW1wbGVTY3JvbGxHcmlkIiwicHJvY2Vzc0NvbHMiLCJzY3JvbGxlclJlZnMiLCJzY3JvbGxlckVsUmVmcyIsIl9oYW5kbGVTY3JvbGxlckVsIiwiZm9yY2VZU2Nyb2xsYmFycyIsInNjcm9sbGVyQ2xpZW50V2lkdGhzIiwic2Nyb2xsZXJDbGllbnRIZWlnaHRzIiwiaGFuZGxlU2l6aW5nIiwiY29tcHV0ZVNjcm9sbGVyRGltcyIsInNlY3Rpb25Db25maWdzIiwic2VjdGlvbnMiLCJtaWNyb0NvbEdyb3VwTm9kZSIsImNvbGxhcHNpYmxlV2lkdGgiLCJjb25maWdDbnQiLCJjb25maWdJIiwiY3VycmVudENvbmZpZyIsImhlYWRTZWN0aW9uTm9kZXMiLCJib2R5U2VjdGlvbk5vZGVzIiwiZm9vdFNlY3Rpb25Ob2RlcyIsInJlbmRlclNlY3Rpb24iLCJpc0J1Z2d5Iiwicm9sZUF0dHJzIiwib3V0ZXJDb250ZW50IiwicmVuZGVyQ2h1bmtUZCIsImNodW5rIiwiaXNMaXF1aWQiLCJzZWN0aW9uS2V5Iiwicm93U3luY0hlaWdodHMiLCJyZXBvcnRSb3dIZWlnaHRDaGFuZ2UiLCJzY3JvbGxlckVsIiwic2VjdGlvbiIsImdldFNlY3Rpb25CeUtleSIsInNjcm9sbGVyRWxSZWYiLCJzY3JvbGxiYXJXaWR0aCIsInNjcm9sbGVyIiwiaGFybmVzc0VsIiwiRXZlbnRDb250YWluZXIiLCJ0aW1lVGV4dCIsImRpc2FibGVEcmFnZ2luZyIsImRpc2FibGVSZXNpemluZyIsImlzRGF0ZVNlbGVjdGluZyIsIlN0YW5kYXJkRXZlbnQiLCJkZWZhdWx0VGltZUZvcm1hdCIsInJlbmRlcklubmVyQ29udGVudCQxJDEiLCJldmVudENvbnRlbnRBcmciLCJpbm5lclByb3BzIiwiTm93SW5kaWNhdG9yQ29udGFpbmVyIiwiaXNBeGlzIiwiREFZX05VTV9GT1JNQVQiLCJEYXlDZWxsQ29udGFpbmVyIiwicmVmaW5lUmVuZGVyUHJvcHMiLCJpc01vbnRoU3RhcnQiLCJzaG93RGF5TnVtYmVyIiwiaGFzQ3VzdG9tRGF5Q2VsbENvbnRlbnQiLCJkYXlOdW1iZXJUZXh0IiwiQmdFdmVudCIsInJlbmRlcklubmVyQ29udGVudCQzIiwicmVuZGVyRmlsbCIsImZpbGxUeXBlIiwiV2Vla051bWJlckNvbnRhaW5lciIsImRlZmF1bHRGb3JtYXQiLCJyZW5kZXJJbm5lciIsIlBBRERJTkdfRlJPTV9WSUVXUE9SVCIsIlBvcG92ZXIiLCJ0aXRsZUlkIiwiaGFuZGxlRG9jdW1lbnRNb3VzZURvd24iLCJoYW5kbGVDbG9zZUNsaWNrIiwiaGFuZGxlRG9jdW1lbnRLZXlEb3duIiwib25DbG9zZSIsImV4dHJhQXR0cnMiLCJ1cGRhdGVTaXplIiwiYWxpZ25tZW50RWwiLCJhbGlnbkdyaWRUb3AiLCJhbGlnbm1lbnRSZWN0IiwicG9wb3ZlckRpbXMiLCJwb3BvdmVyVG9wIiwicG9wb3ZlckxlZnQiLCJvcmlnaW4iLCJvZmZzZXRQYXJlbnQiLCJNb3JlUG9wb3ZlciIsInN0YXJ0RGF0ZSIsImZvcmNlVGltZWQiLCJlbmREYXRlIiwiZXh0cmFEYXRlU3BhbiIsImRheUVsIiwibGF5ZXIiLCJNb3JlTGlua0NvbnRhaW5lciIsImlzUG9wb3Zlck9wZW4iLCJwb3BvdmVySWQiLCJoYW5kbGVMaW5rRWwiLCJsaW5rRWwiLCJoYW5kbGVDbGljayIsImNvbXB1dGVSYW5nZSIsImJ1aWxkUHVibGljU2VnIiwiYWxsRGF5RGF0ZSIsImFsbFNlZ3MiLCJoaWRkZW5TZWdzIiwiaGFuZGxlUG9wb3ZlckNsb3NlIiwibW9yZUNudCIsImhpbnQiLCJzaG9ydFRleHQiLCJyZW5kZXJNb3JlTGlua0lubmVyJDEiLCJhbGlnbm1lbnRFbFJlZiIsInBvcG92ZXJDb250ZW50IiwidXBkYXRlUGFyZW50RWwiLCJjb21wdXRlRWFybGllc3RTZWdTdGFydCIsImNvbXB1dGVMYXRlc3RTZWdFbmQiLCJwaWNrRWFybGllc3RTdGFydCIsInNlZzAiLCJzZWcxIiwicGlja0xhdGVzdEVuZCIsIlZpZXdDb250YWluZXIiLCJidWlsZFZpZXdDbGFzc05hbWVzIiwiRVZFTlRfU09VUkNFX1JFRklORVJTIiwic3VjY2VzcyIsImZhaWx1cmUiLCJwYXJzZUV2ZW50U291cmNlIiwiYnVpbGRFdmVudFNvdXJjZVJlZmluZXJzIiwicmF3T2JqIiwibWV0YVJlcyIsImJ1aWxkRXZlbnRTb3VyY2VNZXRhIiwiX3JhdyIsImlzRmV0Y2hpbmciLCJzb3VyY2VEZWZJZCIsImV2ZW50U291cmNlUmVmaW5lcnMiLCJldmVudFNvdXJjZURlZnMiLCJwYXJzZU1ldGEiLCJDYWxlbmRhckltcGwiLCJjdXJyZW50RGF0YU1hbmFnZXIiLCJiYXRjaFJlbmRlcmluZyIsInNldE9wdGlvbiIsIm9wdGlvbk5hbWUiLCJyYXdPcHRpb25WYWx1ZSIsImdldE9wdGlvbiIsImN1cnJlbnRDYWxlbmRhck9wdGlvbnNJbnB1dCIsImdldEF2YWlsYWJsZUxvY2FsZUNvZGVzIiwiYXZhaWxhYmxlUmF3TG9jYWxlcyIsImhhbmRsZXJOYW1lIiwiY3VycmVudENhbGVuZGFyT3B0aW9uc1JlZmluZXJzIiwiY2hhbmdlVmlldyIsImRhdGVPclJhbmdlIiwic3BlYyIsInZpZXdTcGVjcyIsImdldFVuaXRWaWV3U3BlYyIsInRvb2xiYXJDb25maWciLCJ2aWV3VHlwZXMiLCJoZWFkZXIiLCJ2aWV3c1dpdGhCdXR0b25zIiwiZm9vdGVyIiwic2luZ2xlVW5pdCIsInByZXYiLCJuZXh0IiwicHJldlllYXIiLCJuZXh0WWVhciIsInRvZGF5IiwiZ290b0RhdGUiLCJ6b25lZERhdGVJbnB1dCIsImluY3JlbWVudERhdGUiLCJmb3JtYXREYXRlIiwiZGF0ZU9yT2JqIiwic2VsZWN0aW9uSW5wdXQiLCJldmVudElucHV0Iiwic291cmNlSW5wdXQiLCJjdXJyZW50RGF0YSIsInRyaWdnZXJFdmVudEFkZCIsInNvdXJjZUFwaSIsImdldEV2ZW50U291cmNlQnlJZCIsIm5ld0V2ZW50QXBpIiwiZ2V0RXZlbnRCeUlkIiwiZ2V0RXZlbnRzIiwicmVtb3ZlQWxsRXZlbnRzIiwiZ2V0RXZlbnRTb3VyY2VzIiwic291cmNlSGFzaCIsInNvdXJjZUFwaXMiLCJpbnRlcm5hbElkIiwiYWRkRXZlbnRTb3VyY2UiLCJzb3VyY2VzIiwicmVtb3ZlQWxsRXZlbnRTb3VyY2VzIiwicmVmZXRjaEV2ZW50cyIsInNjcm9sbFRvVGltZSIsInRpbWVJbnB1dCIsIlN0b3JlIiwiY3VycmVudFZhbHVlIiwic3Vic2NyaWJlIiwiQ3VzdG9tUmVuZGVyaW5nU3RvcmUiLCJoYW5kbGUiLCJjdXN0b21SZW5kZXJpbmciLCJ1cGRhdGVkIiwiaGFzIiwiaW50ZXJuYWwiLCJfX3Byb3RvX18iLCJwYXJzZU1hcmtlciIsInByZWFjdCIsImNyZWF0ZVBvcnRhbCIsIkNvbXBvbmVudCIsIkZyYWdtZW50IiwiY2xvbmVFbGVtZW50IiwiaHlkcmF0ZSIsImlzVmFsaWRFbGVtZW50IiwidG9DaGlsZEFycmF5IiwiZ2xvYmFsTG9jYWxlcyIsIk1JTklNQUxfUkFXX0VOX0xPQ0FMRSIsImNvZGUiLCJsaXN0IiwiUkFXX0VOX0xPQ0FMRSIsImV2ZW50Q250Iiwib3JnYW5pemVSYXdMb2NhbGVzIiwiZXhwbGljaXRSYXdMb2NhbGVzIiwiZGVmYXVsdENvZGUiLCJhbGxSYXdMb2NhbGVzIiwicmF3TG9jYWxlTWFwIiwicmF3TG9jYWxlIiwiYnVpbGRMb2NhbGUiLCJpbnB1dFNpbmd1bGFyIiwiYXZhaWxhYmxlIiwicGFyc2VMb2NhbGUiLCJxdWVyeUxvY2FsZSIsImNvZGVBcmciLCJxdWVyeVJhd0xvY2FsZSIsInNpbXBsZUlkIiwibWVyZ2VkIiwiTnVtYmVyRm9ybWF0IiwiY3JlYXRlUGx1Z2luIiwicHJlbWl1bVJlbGVhc2VEYXRlIiwiZGVwcyIsInJlZHVjZXJzIiwiaXNMb2FkaW5nRnVuY3MiLCJjb250ZXh0SW5pdCIsImV2ZW50RHJhZ011dGF0aW9uTWFzc2FnZXJzIiwiZGF0ZVNlbGVjdGlvblRyYW5zZm9ybWVycyIsImRhdGVQb2ludFRyYW5zZm9ybXMiLCJ2aWV3UHJvcHNUcmFuc2Zvcm1lcnMiLCJleHRlcm5hbERlZlRyYW5zZm9ybXMiLCJ2aWV3Q29udGFpbmVyQXBwZW5kcyIsImV2ZW50RHJvcFRyYW5zZm9ybWVycyIsImNvbXBvbmVudEludGVyYWN0aW9ucyIsImNhbGVuZGFySW50ZXJhY3Rpb25zIiwidGhlbWVDbGFzc2VzIiwibmFtZWRUaW1lWm9uZWRJbXBsIiwiZWxlbWVudERyYWdnaW5nSW1wbCIsIm9wdGlvbkNoYW5nZUhhbmRsZXJzIiwic2Nyb2xsR3JpZEltcGwiLCJsaXN0ZW5lclJlZmluZXJzIiwib3B0aW9uUmVmaW5lcnMiLCJwcm9wU2V0SGFuZGxlcnMiLCJidWlsZFBsdWdpbkhvb2tzIiwicGx1Z2luRGVmcyIsImdsb2JhbERlZnMiLCJjdXJyZW50UGx1Z2luSWRzIiwiaG9va3MiLCJhZGREZWZzIiwicGx1Z2luTmFtZSIsImN1cnJlbnRJZCIsImNvbWJpbmVIb29rcyIsImJ1aWxkQnVpbGRQbHVnaW5Ib29rcyIsImN1cnJlbnRPdmVycmlkZURlZnMiLCJjdXJyZW50R2xvYmFsRGVmcyIsImN1cnJlbnRIb29rcyIsIm92ZXJyaWRlRGVmcyIsImhvb2tzMCIsImhvb2tzMSIsImNvbXBhcmVPcHRpb25hbERhdGVzIiwiU3RhbmRhcmRUaGVtZSIsInJvb3QiLCJ0YWJsZUNlbGxTaGFkZWQiLCJidXR0b25Hcm91cCIsImJ1dHRvbiIsImJ1dHRvbkFjdGl2ZSIsImNsb3NlIiwiY29tcGlsZVZpZXdEZWZzIiwiZGVmYXVsdENvbmZpZ3MiLCJvdmVycmlkZUNvbmZpZ3MiLCJlbnN1cmVWaWV3RGVmIiwidmlld0RlZiIsImJ1aWxkVmlld0RlZiIsImRlZmF1bHRDb25maWciLCJvdmVycmlkZUNvbmZpZyIsInF1ZXJ5UHJvcCIsInRoZUNvbXBvbmVudCIsInN1cGVyVHlwZSIsInN1cGVyRGVmIiwiZGVmYXVsdHMiLCJyYXdPcHRpb25zIiwib3ZlcnJpZGVzIiwicGFyc2VWaWV3Q29uZmlncyIsInBhcnNlVmlld0NvbmZpZyIsImNyZWF0ZVZpZXdIb29rQ29tcG9uZW50Iiwidmlld1Byb3BzIiwiYnVpbGRWaWV3U3BlY3MiLCJkZWZhdWx0SW5wdXRzIiwib3B0aW9uT3ZlcnJpZGVzIiwiZHluYW1pY09wdGlvbk92ZXJyaWRlcyIsImxvY2FsZURlZmF1bHRzIiwidmlld0RlZnMiLCJidWlsZFZpZXdTcGVjIiwiZHVyYXRpb25JbnB1dCIsInNpbmdsZVVuaXRPdmVycmlkZXMiLCJjcmVhdGVEdXJhdGlvbkNhY2hlZCIsImRlbm9tIiwicXVlcnlCdXR0b25UZXh0Iiwib3B0aW9uc1N1YnNldCIsImJ1dHRvblRleHRNYXAiLCJxdWVyeUJ1dHRvblRpdGxlIiwiYnV0dG9uS2V5Iiwib3B0aW9uRGVmYXVsdHMiLCJidXR0b25UZXh0T3ZlcnJpZGUiLCJidXR0b25UZXh0RGVmYXVsdCIsImJ1dHRvblRpdGxlT3ZlcnJpZGUiLCJidXR0b25IaW50IiwiYnV0dG9uVGl0bGVEZWZhdWx0IiwiZHVyYXRpb25JbnB1dE1hcCIsIkpTT04iLCJzdHJpbmdpZnkiLCJyZWR1Y2VWaWV3VHlwZSIsInJlZHVjZUR5bmFtaWNPcHRpb25PdmVycmlkZXMiLCJyZWR1Y2VEYXRlUHJvZmlsZSIsImRwIiwiaW5pdEV2ZW50U291cmNlcyIsImFkZFNvdXJjZXMiLCJwYXJzZUluaXRpYWxTb3VyY2VzIiwicmVkdWNlRXZlbnRTb3VyY2VzIiwicmVtb3ZlU291cmNlIiwiZmV0Y2hEaXJ0eVNvdXJjZXMiLCJmZXRjaFNvdXJjZXNCeUlkcyIsImV4Y2x1ZGVTdGF0aWNTb3VyY2VzIiwicmVjZWl2ZVJlc3BvbnNlIiwicmVkdWNlRXZlbnRTb3VyY2VzTmV3VGltZVpvbmUiLCJjb21wdXRlRXZlbnRTb3VyY2VzTG9hZGluZyIsImV2ZW50U291cmNlSGFzaCIsImlzU291cmNlRGlydHkiLCJkb2VzU291cmNlTmVlZFJhbmdlIiwicHJldlNvdXJjZXMiLCJzb3VyY2VJZEhhc2giLCJuZXh0U291cmNlcyIsImZldGNoU291cmNlIiwic291cmNlRGVmIiwiZXJyb3JIYW5kbGVkIiwicmF3U291cmNlcyIsInJhd1NvdXJjZSIsImlnbm9yZVJhbmdlIiwicmVkdWNlRGF0ZVNlbGVjdGlvbiIsImN1cnJlbnRTZWxlY3Rpb24iLCJyZWR1Y2VTZWxlY3RlZEV2ZW50IiwiY3VycmVudEluc3RhbmNlSWQiLCJldmVudEluc3RhbmNlSWQiLCJyZWR1Y2VFdmVudERyYWciLCJjdXJyZW50RHJhZyIsIm5ld0RyYWciLCJyZWR1Y2VFdmVudFJlc2l6ZSIsImN1cnJlbnRSZXNpemUiLCJuZXdSZXNpemUiLCJwYXJzZVRvb2xiYXJzIiwiY2FsZW5kYXJPcHRpb25PdmVycmlkZXMiLCJwYXJzZVRvb2xiYXIiLCJzZWN0aW9uU3RySGFzaCIsInNlY3Rpb25XaWRnZXRzIiwiaGFzVGl0bGUiLCJzZWN0aW9uTmFtZSIsInNlY3Rpb25TdHIiLCJzZWN0aW9uUmVzIiwicGFyc2VTZWN0aW9uIiwid2lkZ2V0cyIsImNhbGVuZGFyQ3VzdG9tQnV0dG9ucyIsImNhbGVuZGFyQnV0dG9uVGV4dE92ZXJyaWRlcyIsImNhbGVuZGFyQnV0dG9uVGV4dCIsImNhbGVuZGFyQnV0dG9uSGludE92ZXJyaWRlcyIsImNhbGVuZGFyQnV0dG9uSGludHMiLCJzZWN0aW9uU3Vic3RycyIsImJ1dHRvbkdyb3VwU3RyIiwiYnV0dG9uQ2xpY2siLCJidXR0b25JY29uIiwiY2xpY2siLCJ0ZXh0RmFsbGJhY2siLCJwcmV2T3JOZXh0IiwibmF2VW5pdCIsIlZpZXdJbXBsIiwiY2FsZW5kYXIiLCJ2aWV3VGl0bGUiLCJhY3RpdmVTdGFydCIsImFjdGl2ZUVuZCIsImN1cnJlbnRTdGFydCIsImN1cnJlbnRFbmQiLCJldmVudFNvdXJjZURlZiQyIiwic3VjY2Vzc0NhbGxiYWNrIiwiYXJyYXlFdmVudFNvdXJjZVBsdWdpbiIsImV2ZW50U291cmNlRGVmJDEiLCJlcnJvckNhbGxiYWNrIiwiZnVuY0V2ZW50U291cmNlUGx1Z2luIiwiSlNPTl9GRUVEX0VWRU5UX1NPVVJDRV9SRUZJTkVSUyIsImV4dHJhUGFyYW1zIiwiZXZlbnRTb3VyY2VEZWYiLCJyZXF1ZXN0UGFyYW1zIiwiYnVpbGRSZXF1ZXN0UGFyYW1zIiwianNvbkZlZWRFdmVudFNvdXJjZVBsdWdpbiIsImN1c3RvbVJlcXVlc3RQYXJhbXMiLCJTSU1QTEVfUkVDVVJSSU5HX1JFRklORVJTIiwic3RhcnRSZWN1ciIsImVuZFJlY3VyIiwicmVjdXJyaW5nIiwicmVjdXJyaW5nRGF0YSIsImNsaXBwZWRGcmFtaW5nUmFuZ2UiLCJleHBhbmRSYW5nZXMiLCJzaW1wbGVSZWN1cnJpbmdFdmVudHNQbHVnaW4iLCJkb3dIYXNoIiwiZGF5TWFya2VyIiwiaW5zdGFuY2VTdGFydHMiLCJpbnN0YW5jZVN0YXJ0IiwiY2hhbmdlSGFuZGxlclBsdWdpbiIsImhhbmRsZUV2ZW50U291cmNlcyIsInVuZm91bmRTb3VyY2VzIiwibmV3SW5wdXRzIiwiaW5wdXRGb3VuZCIsInVuZm91bmRTb3VyY2UiLCJuZXdJbnB1dCIsImhhbmRsZURhdGVQcm9maWxlIiwiaGFuZGxlRXZlbnRTdG9yZSIsImdsb2JhbFBsdWdpbnMiLCJUYXNrUnVubmVyIiwicnVuVGFza09wdGlvbiIsInF1ZXVlIiwiZGVsYXllZFJ1bm5lciIsInRhc2siLCJjb21wbGV0ZWRUYXNrcyIsInJ1blRhc2siLCJidWlsZFRpdGxlIiwiYnVpbGRUaXRsZUZvcm1hdCIsIkNhbGVuZGFyRGF0YU1hbmFnZXIiLCJjb21wdXRlQ3VycmVudFZpZXdEYXRhIiwiX2NvbXB1dGVDdXJyZW50Vmlld0RhdGEiLCJidWlsZERhdGVFbnYiLCJidWlsZERhdGVFbnYkMSIsImJ1aWxkVGhlbWUiLCJidWlsZERhdGVQcm9maWxlR2VuZXJhdG9yIiwiYnVpbGRWaWV3QXBpIiwiYnVpbGRWaWV3VWlQcm9wcyIsImJ1aWxkRXZlbnRVaUJ5U291cmNlIiwiYnVpbGRFdmVudFVpQmFzZXMiLCJwYXJzZUNvbnRleHRCdXNpbmVzc0hvdXJzIiwiYWN0aW9uUnVubmVyIiwiX2hhbmRsZUFjdGlvbiIsInVwZGF0ZURhdGEiLCJjdXJyZW50Q2FsZW5kYXJPcHRpb25zUmVmaW5lZCIsImN1cnJlbnRWaWV3T3B0aW9uc0lucHV0IiwiY3VycmVudFZpZXdPcHRpb25zUmVmaW5lZCIsIm9wdGlvbnNGb3JSZWZpbmluZyIsIm9wdGlvbnNGb3JIYW5kbGluZyIsIm9wdGlvbnNEYXRhIiwiY29tcHV0ZU9wdGlvbnNEYXRhIiwiY3VycmVudFZpZXdUeXBlIiwiY3VycmVudFZpZXdEYXRhIiwiY2FsZW5kYXJDb250ZXh0IiwiaW5pdGlhbFN0YXRlIiwicmVuZGVyYWJsZUV2ZW50U3RvcmUiLCJjb250ZXh0QW5kU3RhdGUiLCJyZWR1Y2VyIiwiY29tcHV0ZUlzTG9hZGluZyIsInJlc2V0T3B0aW9ucyIsImNoYW5nZWRPcHRpb25OYW1lcyIsImlzRXZlbnRzTG9hZGluZyIsImV2ZW50VWlTaW5nbGVCYXNlIiwiZXZlbnRVaUJ5U291cmNlIiwid2FzTG9hZGluZyIsImlzTG9hZGluZyIsIm9uQWN0aW9uIiwib2xkRGF0YSIsImNoYW5nZUhhbmRsZXJzIiwib2xkQ2FsZW5kYXJPcHRpb25zIiwibmV3Q2FsZW5kYXJPcHRpb25zIiwib25EYXRhIiwic3RhYmxlT3B0aW9uT3ZlcnJpZGVzIiwic3RhYmxlRHluYW1pY09wdGlvbk92ZXJyaWRlcyIsInN0YWJsZUNhbGVuZGFyT3B0aW9uc0RhdGEiLCJyZWZpbmVkT3B0aW9ucyIsImF2YWlsYWJsZUxvY2FsZURhdGEiLCJwcm9jZXNzUmF3Q2FsZW5kYXJPcHRpb25zIiwid2FyblVua25vd25PcHRpb25zIiwiY3VycmVudFJhdyIsImN1cnJlbnRSZWZpbmVkIiwiYW55Q2hhbmdlcyIsInByb2Nlc3NSYXdWaWV3T3B0aW9ucyIsImV4cGxpY2l0TG9jYWxlIiwiVGhlbWVDbGFzcyIsIkRhdGVQcm9maWxlR2VuZXJhdG9yQ2xhc3MiLCJpc0xvYWRpbmdGdW5jIiwidmlld05hbWUiLCJUb29sYmFyU2VjdGlvbiIsIndpZGdldEdyb3VwcyIsIndpZGdldEdyb3VwIiwicmVuZGVyV2lkZ2V0R3JvdXAiLCJpc09ubHlCdXR0b25zIiwid2lkZ2V0IiwiaXNQcmVzc2VkIiwiYWN0aXZlQnV0dG9uIiwiaXNUb2RheUVuYWJsZWQiLCJpc1ByZXZFbmFibGVkIiwiaXNOZXh0RW5hYmxlZCIsImJ1dHRvbkNsYXNzZXMiLCJkaXNhYmxlZCIsImdyb3VwQ2xhc3NOYW1lIiwiVG9vbGJhciIsIm1vZGVsIiwiZXh0cmFDbGFzc05hbWUiLCJmb3JjZUx0ciIsInN0YXJ0Q29udGVudCIsImVuZENvbnRlbnQiLCJjZW50ZXJDb250ZW50IiwiVmlld0hhcm5lc3MiLCJhdmFpbGFibGVXaWR0aCIsInVwZGF0ZUF2YWlsYWJsZVdpZHRoIiwiaGFuZGxlUmVzaXplIiwibGFiZWxlZEJ5SWQiLCJFdmVudENsaWNraW5nIiwiaGFuZGxlU2VnQ2xpY2siLCJzZWdFbCIsImhhc1VybENvbnRhaW5lciIsImxvY2F0aW9uIiwiRXZlbnRIb3ZlcmluZyIsImhhbmRsZUV2ZW50RWxSZW1vdmUiLCJjdXJyZW50U2VnRWwiLCJoYW5kbGVTZWdMZWF2ZSIsImhhbmRsZVNlZ0VudGVyIiwidHJpZ2dlckV2ZW50IiwicmVtb3ZlSG92ZXJMaXN0ZW5lcnMiLCJwdWJsaWNFdk5hbWUiLCJDYWxlbmRhckNvbnRlbnQiLCJidWlsZFZpZXdQcm9wVHJhbnNmb3JtZXJzIiwiYnVpbGRUb29sYmFyUHJvcHMiLCJoZWFkZXJSZWYiLCJmb290ZXJSZWYiLCJpbnRlcmFjdGlvbnNTdG9yZSIsInZpZXdMYWJlbElkIiwic2V0dGluZ3NJbnB1dCIsIkRFRkFVTFRfSU5URVJBQ1RJT05TIiwiaW50ZXJhY3Rpb25DbGFzc2VzIiwiaW50ZXJhY3Rpb25zIiwiVGhlSW50ZXJhY3Rpb25DbGFzcyIsImxpc3RlbmVycyIsImxpc3RlbmVyIiwicmVzaXplUnVubmVyIiwidG9vbGJhclByb3BzIiwidmlld1ZHcm93Iiwidmlld0FzcGVjdFJhdGlvIiwidmlld0NvbnRleHQiLCJyZW5kZXJWaWV3IiwiYnVpbGRBcHBlbmRDb250ZW50IiwiQ2FsZW5kYXJJbnRlcmFjdGlvbkNsYXNzIiwiVmlld0NvbXBvbmVudCIsInRvZGF5SW5mbyIsInByZXZJbmZvIiwibmV4dEluZm8iLCJ0aGVDbGFzc2VzIiwiVGhlQ2xhc3MiLCJDYWxlbmRhciIsImlzUmVuZGVyaW5nIiwiaXNSZW5kZXJlZCIsImN1cnJlbnRDbGFzc05hbWVzIiwiY3VzdG9tQ29udGVudFJlbmRlcklkIiwiaGFuZGxlQWN0aW9uIiwicmVuZGVyUnVubmVyIiwiaGFuZGxlRGF0YSIsImhhbmRsZVJlbmRlclJlcXVlc3QiLCJzZXRDbGFzc05hbWVzIiwic2V0SGVpZ2h0Iiwid2FzUmVuZGVyaW5nIiwicGF1c2VSZW5kZXJpbmciLCJyZXN1bWVSZW5kZXJpbmciLCJkYXRlSW5wdXQiLCJzbGljZUV2ZW50cyIsInZlcnNpb24iLCJ0b3VjaE1vdXNlSWdub3JlV2FpdCIsImlnbm9yZU1vdXNlRGVwdGgiLCJsaXN0ZW5lckNudCIsImlzV2luZG93VG91Y2hNb3ZlQ2FuY2VsbGVkIiwiUG9pbnRlckRyYWdnaW5nIiwic3ViamVjdEVsIiwiaGFuZGxlU2VsZWN0b3IiLCJzaG91bGRJZ25vcmVNb3ZlIiwic2hvdWxkV2F0Y2hTY3JvbGwiLCJpc1RvdWNoRHJhZ2dpbmciLCJ3YXNUb3VjaFNjcm9sbCIsImhhbmRsZU1vdXNlRG93biIsInNob3VsZElnbm9yZU1vdXNlIiwiaXNQcmltYXJ5TW91c2VCdXR0b24iLCJ0cnlTdGFydCIsImNyZWF0ZUV2ZW50RnJvbU1vdXNlIiwiaW5pdFNjcm9sbFdhdGNoIiwiaGFuZGxlTW91c2VNb3ZlIiwiaGFuZGxlTW91c2VVcCIsInJlY29yZENvb3JkcyIsImNsZWFudXAiLCJoYW5kbGVUb3VjaFN0YXJ0IiwiY3JlYXRlRXZlbnRGcm9tVG91Y2giLCJ0YXJnZXRFbCIsImhhbmRsZVRvdWNoTW92ZSIsImhhbmRsZVRvdWNoRW5kIiwiaGFuZGxlVG91Y2hTY3JvbGwiLCJzdGFydElnbm9yaW5nTW91c2UiLCJoYW5kbGVTY3JvbGwiLCJwYWdlWCIsInByZXZTY3JvbGxYIiwicHJldlBhZ2VYIiwicGFnZVkiLCJwcmV2U2Nyb2xsWSIsInByZXZQYWdlWSIsImlzVG91Y2giLCJvcmlnUGFnZVgiLCJvcmlnUGFnZVkiLCJwYXNzaXZlIiwibGlzdGVuZXJDcmVhdGVkIiwibGlzdGVuZXJEZXN0cm95ZWQiLCJxdWVyeVN1YmplY3RFbCIsImRvd25FbCIsImRlc3Ryb3lTY3JvbGxXYXRjaCIsImNhbmNlbFRvdWNoU2Nyb2xsIiwiaXNGaXJzdCIsInRvdWNoZXMiLCJjdHJsS2V5Iiwib25XaW5kb3dUb3VjaE1vdmUiLCJFbGVtZW50TWlycm9yIiwiaXNWaXNpYmxlIiwic291cmNlRWwiLCJtaXJyb3JFbCIsInNvdXJjZUVsUmVjdCIsInpJbmRleCIsInJldmVydER1cmF0aW9uIiwib3JpZ1NjcmVlblgiLCJvcmlnU2NyZWVuWSIsInVwZGF0ZUVsUG9zaXRpb24iLCJoYW5kbGVNb3ZlIiwic2V0SXNWaXNpYmxlIiwic3RvcCIsIm5lZWRzUmV2ZXJ0QW5pbWF0aW9uIiwiZG9uZSIsImRvUmV2ZXJ0QW5pbWF0aW9uIiwiZmluYWxTb3VyY2VFbFJlY3QiLCJ0cmFuc2l0aW9uIiwiZ2V0TWlycm9yRWwiLCJjbG9uZU5vZGUiLCJ2aXNpYmlsaXR5IiwiYm94U2l6aW5nIiwibWFyZ2luIiwiU2Nyb2xsR2VvbUNhY2hlIiwic2Nyb2xsQ29udHJvbGxlciIsImRvZXNMaXN0ZW5pbmciLCJoYW5kbGVTY3JvbGxDaGFuZ2UiLCJvcmlnU2Nyb2xsVG9wIiwib3JpZ1Njcm9sbExlZnQiLCJjbGllbnRSZWN0IiwiY29tcHV0ZUNsaWVudFJlY3QiLCJnZXRFdmVudFRhcmdldCIsIkVsZW1lbnRTY3JvbGxHZW9tQ2FjaGUiLCJXaW5kb3dTY3JvbGxHZW9tQ2FjaGUiLCJnZXRUaW1lIiwicGVyZm9ybWFuY2UiLCJBdXRvU2Nyb2xsZXIiLCJpc0VuYWJsZWQiLCJzY3JvbGxRdWVyeSIsImVkZ2VUaHJlc2hvbGQiLCJtYXhWZWxvY2l0eSIsInBvaW50ZXJTY3JlZW5YIiwicG9pbnRlclNjcmVlblkiLCJpc0FuaW1hdGluZyIsInNjcm9sbENhY2hlcyIsImV2ZXJNb3ZlZFVwIiwiZXZlck1vdmVkRG93biIsImV2ZXJNb3ZlZExlZnQiLCJldmVyTW92ZWRSaWdodCIsImFuaW1hdGUiLCJlZGdlIiwiY29tcHV0ZUJlc3RFZGdlIiwiaGFuZGxlU2lkZSIsIm1zU2luY2VSZXF1ZXN0IiwicmVxdWVzdEFuaW1hdGlvbiIsInNjcm9sbFN0YXJ0RWwiLCJidWlsZENhY2hlcyIsInlEZWx0YSIsInhEZWx0YSIsInNjcm9sbENhY2hlIiwiaW52RGlzdGFuY2UiLCJkaXN0YW5jZSIsInZlbG9jaXR5IiwiYmVzdFNpZGUiLCJsZWZ0RGlzdCIsInJpZ2h0RGlzdCIsInRvcERpc3QiLCJib3R0b21EaXN0IiwicXVlcnlTY3JvbGxFbHMiLCJxdWVyeSIsIkZlYXR1cmVmdWxFbGVtZW50RHJhZ2dpbmciLCJtaW5EaXN0YW5jZSIsInRvdWNoU2Nyb2xsQWxsb3dlZCIsIm1pcnJvck5lZWRzUmV2ZXJ0IiwiaXNJbnRlcmFjdGluZyIsImlzRGVsYXlFbmRlZCIsImlzRGlzdGFuY2VTdXJwYXNzZWQiLCJkZWxheVRpbWVvdXRJZCIsIm9uUG9pbnRlckRvd24iLCJwb2ludGVyIiwibWlycm9yIiwic3RhcnREZWxheSIsImhhbmRsZURpc3RhbmNlU3VycGFzc2VkIiwib25Qb2ludGVyTW92ZSIsImRpc3RhbmNlU3EiLCJhdXRvU2Nyb2xsZXIiLCJvblBvaW50ZXJVcCIsInRyeVN0b3BEcmFnIiwiaGFuZGxlRGVsYXlFbmQiLCJ0cnlTdGFydERyYWciLCJzdG9wRHJhZyIsInNldElnbm9yZU1vdmUiLCJPZmZzZXRUcmFja2VyIiwib3JpZ1JlY3QiLCJzY3JvbGxFbCIsImNvbXB1dGVMZWZ0IiwiY29tcHV0ZVRvcCIsImlzV2l0aGluQ2xpcHBpbmciLCJpc0lnbm9yZWRDbGlwcGluZyIsIm5vZGUiLCJ0YWdOYW1lIiwiSGl0RHJhZ2dpbmciLCJkcmFnZ2luZyIsImRyb3BwYWJsZVN0b3JlIiwidXNlU3ViamVjdENlbnRlciIsInJlcXVpcmVJbml0aWFsIiwiaW5pdGlhbEhpdCIsIm1vdmluZ0hpdCIsImZpbmFsSGl0IiwiaGFuZGxlUG9pbnRlckRvd24iLCJwcm9jZXNzRmlyc3RDb29yZCIsImhhbmRsZURyYWdTdGFydCIsImhhbmRsZURyYWdNb3ZlIiwiaGFuZGxlUG9pbnRlclVwIiwicmVsZWFzZUhpdHMiLCJoYW5kbGVEcmFnRW5kIiwib3JpZ1BvaW50IiwiYWRqdXN0ZWRQb2ludCIsInN1YmplY3RSZWN0IiwicXVlcnlIaXRGb3JPZmZzZXQiLCJzbGljZWRTdWJqZWN0UmVjdCIsImNvb3JkQWRqdXN0IiwiZm9yY2VIYW5kbGUiLCJoaXQiLCJpc0hpdHNFcXVhbCIsIm9mZnNldFRyYWNrZXJzIiwiaW50ZXJhY3Rpb25TZXR0aW5ncyIsIm9mZnNldExlZnQiLCJvZmZzZXRUb3AiLCJiZXN0SGl0Iiwib2Zmc2V0VHJhY2tlciIsIm9yaWdpbkxlZnQiLCJvcmlnaW5Ub3AiLCJjb21wb25lbnRJZCIsImhpdDAiLCJoaXQxIiwiYnVpbGREYXRlUG9pbnRBcGlXaXRoQ29udGV4dCIsImJ1aWxkRGF0ZVBvaW50QXBpIiwiRGF0ZUNsaWNraW5nIiwiaGl0RHJhZ2dpbmciLCJEYXRlU2VsZWN0aW5nIiwiZHJhZ1NlbGVjdGlvbiIsImNhblNlbGVjdCIsImdldENvbXBvbmVudFRvdWNoRGVsYXkkMSIsImhhbmRsZUhpdFVwZGF0ZSIsImlzRmluYWwiLCJpc0ludmFsaWQiLCJkaXNhbGxvd2VkIiwiam9pbkhpdHNJbnRvU2VsZWN0aW9uIiwiZGF0ZVNwYW4wIiwiZGF0ZVNwYW4xIiwiRXZlbnREcmFnZ2luZyIsInN1YmplY3RTZWciLCJyZWNlaXZpbmdDb250ZXh0IiwidmFsaWRNdXRhdGlvbiIsIm11dGF0ZWRSZWxldmFudEV2ZW50cyIsIm9yaWdUYXJnZXQiLCJpbml0aWFsQ29udGV4dCIsImdldENvbXBvbmVudFRvdWNoRGVsYXkiLCJmaXhlZE1pcnJvclBhcmVudCIsInJlY2VpdmluZ09wdGlvbnMiLCJjb21wdXRlRXZlbnRNdXRhdGlvbiIsImRpc3BsYXlEcmFnIiwiY2xlYXJEcmFnIiwidXBkYXRlZEV2ZW50QXBpIiwiZXZlbnRDaGFuZ2VBcmciLCJ0cmFuc2Zvcm1lZCIsImV2ZW50UmVtb3ZlQXJnIiwiZHJhZ2dlZEVsIiwiYWRkZWRFdmVudERlZiIsImFkZGVkRXZlbnRJbnN0YW5jZSIsImFkZGVkRXZlbnRBcGkiLCJldmVudEFkZEFyZyIsIlNFTEVDVE9SIiwibmV4dENvbnRleHQiLCJwcmV2Q29udGV4dCIsImluaXRpYWxDYWxlbmRhciIsIm1hc3NhZ2VycyIsIm1hc3NhZ2VyIiwiRXZlbnRSZXNpemluZyIsImRyYWdnaW5nU2VnRWwiLCJkcmFnZ2luZ1NlZyIsInF1ZXJ5U2VnRWwiLCJjb21wdXRlTXV0YXRpb24iLCJpc0Zyb21TdGFydCIsIlVuc2VsZWN0QXV0byIsImlzUmVjZW50UG9pbnRlckRhdGVTZWxlY3QiLCJtYXRjaGVzQ2FuY2VsIiwibWF0Y2hlc0V2ZW50Iiwib25TZWxlY3QiLCJzZWxlY3RJbmZvIiwib25Eb2N1bWVudFBvaW50ZXJEb3duIiwib25Eb2N1bWVudFBvaW50ZXJVcCIsImRvY3VtZW50UG9pbnRlciIsIk9QVElPTl9SRUZJTkVSUyQzIiwiTElTVEVORVJfUkVGSU5FUlMiLCJkYXRlQ2xpY2siLCJldmVudERyYWdTdGFydCIsImV2ZW50RHJhZ1N0b3AiLCJldmVudERyb3AiLCJldmVudFJlc2l6ZVN0YXJ0IiwiZXZlbnRSZXNpemVTdG9wIiwiZHJvcCIsImV2ZW50UmVjZWl2ZSIsImV2ZW50TGVhdmUiLCJFeHRlcm5hbEVsZW1lbnREcmFnZ2luZyIsInN1cHBsaWVkRHJhZ01ldGEiLCJkcm9wcGFibGVFdmVudCIsImRyYWdNZXRhIiwiYnVpbGREcmFnTWV0YSIsImNhbkRyb3BFbE9uQ2FsZW5kYXIiLCJjb21wdXRlRXZlbnRGb3JEYXRlU3BhbiIsImZpbmFsVmlldyIsImFkZGluZ0V2ZW50cyIsImdldERyYWdNZXRhRnJvbUVsIiwiZGVmUHJvcHMiLCJnZXRFbWJlZGRlZEVsRGF0YSIsImRhdGFBdHRyUHJlZml4IiwicHJlZml4ZWROYW1lIiwiRXh0ZXJuYWxEcmFnZ2FibGUiLCJpdGVtU2VsZWN0b3IiLCJhcHBlbmRUbyIsImV2ZW50RGF0YSIsIkluZmVycmVkRWxlbWVudERyYWdnaW5nIiwibWlycm9yU2VsZWN0b3IiLCJjdXJyZW50TWlycm9yRWwiLCJoYW5kbGVQb2ludGVyTW92ZSIsIlRoaXJkUGFydHlEcmFnZ2FibGUiLCJjb250YWluZXJPclNldHRpbmdzIiwiRWxlbWVudCIsImluZGV4JDQiLCJjc3NfMjQ4eiQzIiwic3BsaXRTZWdzQnlSb3ciLCJieVJvdyIsInNwbGl0U2Vnc0J5Rmlyc3RDb2wiLCJieUNvbCIsInNwbGl0SW50ZXJhY3Rpb25CeVJvdyIsIkRFRkFVTFRfVEFCTEVfRVZFTlRfVElNRV9GT1JNQVQiLCJoYXNMaXN0SXRlbURpc3BsYXkiLCJUYWJsZUJsb2NrRXZlbnQiLCJUYWJsZUxpc3RJdGVtRXZlbnQiLCJyZW5kZXJJbm5lckNvbnRlbnQkMiIsIlRhYmxlQ2VsbE1vcmVMaW5rIiwiY29tcGlsZVNlZ3MiLCJpbnZpc2libGVTZWdzIiwic2luZ2xlUGxhY2VtZW50cyIsImlzRm9yY2VkSW52aXNpYmxlIiwicGxhY2VtZW50IiwiREVGQVVMVF9XRUVLX05VTV9GT1JNQVQkMSIsIlRhYmxlQ2VsbCIsInJvb3RFbFJlZiIsImRheU51bWJlcklkIiwic2hvdWxkRGlzcGxheU1vbnRoU3RhcnQiLCJyZW5kZXJUb3BJbm5lciIsImlubmVyRWxSZWYiLCJtaW5IZWlnaHQiLCJzaG93V2Vla051bWJlciIsImZvcmNlRGF5VG9wIiwiZmdDb250ZW50RWxSZWYiLCJmZ0NvbnRlbnQiLCJtYXJnaW5Ub3AiLCJtb3JlTWFyZ2luVG9wIiwiYmdDb250ZW50IiwiY3VycmVudEVuZEluY2wiLCJjdXJyZW50Rmlyc3RZZWFyIiwiY3VycmVudEZpcnN0TW9udGgiLCJjdXJyZW50TGFzdFllYXIiLCJjdXJyZW50TGFzdE1vbnRoIiwiY29tcHV0ZUZnU2VnUGxhY2VtZW50IiwiZXZlbnRJbnN0YW5jZUhlaWdodHMiLCJtYXhDb250ZW50SGVpZ2h0IiwiaGllcmFyY2h5IiwiRGF5R3JpZFNlZ0hpZXJhcmNoeSIsImhpZGRlbkNvbnN1bWVzIiwic2VnSW5wdXRzIiwidW5rbm93bkhlaWdodFNlZ3MiLCJldmVudEhlaWdodCIsInNlZ1JlY3RzIiwic2luZ2xlQ29sUGxhY2VtZW50cyIsIm11bHRpQ29sUGxhY2VtZW50cyIsImxlZnRvdmVyTWFyZ2lucyIsInBsYWNlUmVjdHMiLCJtb3JlQ250cyIsIm1vcmVNYXJnaW5Ub3BzIiwiYWJzb2x1dGVUb3AiLCJyZXNsaWNlU2VnIiwiaGlkZGVuRW50cnkiLCJoaWRkZW5TcGFuIiwiYWxsUmVjdHMiLCJyZWN0c0J5RWFjaENvbCIsImdyb3VwUmVjdHNCeUVhY2hDb2wiLCJjdXJyZW50SGVpZ2h0IiwiY3VycmVudE1hcmdpblRvcCIsIm11bHRpUGxhY2VtZW50cyIsImlzRmlyc3RDb2wiLCJzcGFuU3RhcnQiLCJzcGFuRW5kIiwiZm9yY2VIaWRkZW4iLCJleGNsdWRlSGlkZGVuIiwidG91Y2hpbmdFbnRyeUlkIiwicGxhY2Vob2xkZXJFbnRyeSIsInBsYWNlaG9sZGVyRW50cnlJZCIsIlRhYmxlUm93IiwiY2VsbEVsUmVmcyIsImZyYW1lRWxSZWZzIiwiZmdFbFJlZnMiLCJzZWdIYXJuZXNzUmVmcyIsImZyYW1lUG9zaXRpb25zIiwiaXNGb3JjZWQiLCJ1cGRhdGVTaXppbmciLCJidXNpbmVzc0hvdXJzQnlDb2wiLCJiZ0V2ZW50U2Vnc0J5Q29sIiwiaGlnaGxpZ2h0U2Vnc0J5Q29sIiwiZ2V0SGlnaGxpZ2h0U2VncyIsIm1pcnJvclNlZ3NCeUNvbCIsImdldE1pcnJvclNlZ3MiLCJjZWxsIiwibm9ybWFsRmdOb2RlcyIsInJlbmRlckZnU2VncyIsIm1pcnJvckZnTm9kZXMiLCJidWlsZE1pcnJvclBsYWNlbWVudHMiLCJzaG93RGF5TnVtYmVycyIsInNob3dXZWVrTnVtYmVycyIsInJlbmRlckZpbGxTZWdzIiwiY2VsbE1pbkhlaWdodCIsInByZXZTdGF0ZSIsImN1cnJlbnRQcm9wcyIsInNlZ1BsYWNlbWVudHMiLCJub2RlcyIsImxlZnRSaWdodENzcyIsImlzRXh0ZXJuYWxTaXppbmdDaGFuZ2UiLCJmcmFtZUVscyIsIm5ld1Bvc2l0aW9uQ2FjaGUiLCJvbGRJbnN0YW5jZUhlaWdodHMiLCJuZXdJbnN0YW5jZUhlaWdodHMiLCJxdWVyeUV2ZW50SW5zdGFuY2VIZWlnaHRzIiwibGltaXRCeUNvbnRlbnRIZWlnaHQiLCJjb21wdXRlTWF4Q29udGVudEhlaWdodCIsInNlZ0VsTWFwIiwiZmlyc3RLZXkiLCJmY0NvbnRhaW5lckVsIiwiZ2V0Q2VsbEVscyIsImVsTWFwIiwibWlycm9yU2VncyIsImNvbFBsYWNlbWVudHMiLCJ0b3BzQnlJbnN0YW5jZUlkIiwiYnVpbGRBYnNvbHV0ZVRvcEhhc2giLCJwbGFjZW1lbnRzIiwiVGFibGVSb3dzIiwic3BsaXRCdXNpbmVzc0hvdXJTZWdzIiwic3BsaXRCZ0V2ZW50U2VncyIsInNwbGl0RmdFdmVudFNlZ3MiLCJzcGxpdERhdGVTZWxlY3Rpb25TZWdzIiwicm93UmVmcyIsImJ1c2luZXNzSG91clNlZ3NCeVJvdyIsImJnRXZlbnRTZWdzQnlSb3ciLCJmZ0V2ZW50U2Vnc0J5Um93IiwiZGF0ZVNlbGVjdGlvblNlZ3NCeVJvdyIsImV2ZW50RHJhZ0J5Um93IiwiZXZlbnRSZXNpemVCeVJvdyIsInJlbmRlclJvd0ludHJvIiwiaXNTZWdBbGxEYXkiLCJmaXJzdENlbGxFbCIsInJvd1Bvc2l0aW9ucyIsInJvd09iaiIsImNvbFBvc2l0aW9ucyIsImdldENlbGxSYW5nZSIsImdldENlbGxFbCIsIlRhYmxlIiwibmVlZHNTY3JvbGxSZXNldCIsImxpbWl0VmlhQmFsYW5jZWQiLCJjb2xHcm91cE5vZGUiLCJyZXF1ZXN0U2Nyb2xsUmVzZXQiLCJmbHVzaFNjcm9sbFJlc2V0IiwiZ2V0U2Nyb2xsU3ViamVjdEVsIiwiRGF5VGFibGVTbGljZXIiLCJkYXlUYWJsZU1vZGVsIiwiRGF5VGFibGUiLCJzbGljZXIiLCJ0YWJsZVJlZiIsImhlYWRlckFsaWduRWxSZWYiLCJUYWJsZURhdGVQcm9maWxlR2VuZXJhdG9yIiwiYnVpbGREYXlUYWJsZVJlbmRlclJhbmdlIiwic25hcFRvV2VlayIsImVuZE9mV2VlayIsImxhc3RNb250aFJlbmRlclN0YXJ0IiwiVGFibGVWaWV3IiwiaGVhZGVyRWxSZWYiLCJyZW5kZXJTaW1wbGVMYXlvdXQiLCJoZWFkZXJSb3dDb250ZW50IiwiYm9keUNvbnRlbnQiLCJyZW5kZXJIU2Nyb2xsTGF5b3V0IiwiU2Nyb2xsR3JpZCIsImNodW5rcyIsImNvbEdyb3VwcyIsIkRheVRhYmxlVmlldyIsImJ1aWxkRGF5VGFibGVNb2RlbCIsImhlYWRlckNvbnRlbnQiLCJjb250ZW50QXJnIiwiaW5kZXgkMyIsImRheUdyaWQiLCJkYXlHcmlkRGF5IiwiZGF5R3JpZFdlZWsiLCJkYXlHcmlkTW9udGgiLCJkYXlHcmlkWWVhciIsImNzc18yNDh6JDIiLCJBbGxEYXlTcGxpdHRlciIsInRpbWVkIiwiREVGQVVMVF9TTEFUX0xBQkVMX0ZPUk1BVCIsIlRpbWVDb2xzQXhpc0NlbGwiLCJpc0xhYmVsZWQiLCJpc29UaW1lU3RyIiwibGFiZWxGb3JtYXQiLCJyZW5kZXJJbm5lckNvbnRlbnQkMSIsIlRpbWVCb2R5QXhpcyIsInNsYXRNZXRhcyIsInNsYXRNZXRhIiwiREVGQVVMVF9XRUVLX05VTV9GT1JNQVQiLCJBVVRPX0FMTF9EQVlfTUFYX0VWRU5UX1JPV1MiLCJUaW1lQ29sc1ZpZXciLCJhbGxEYXlTcGxpdHRlciIsInNsYXRDb29yZHMiLCJoYW5kbGVTY3JvbGxUb3BSZXF1ZXN0IiwicmVuZGVySGVhZEF4aXMiLCJyb3dLZXkiLCJmcmFtZUhlaWdodCIsInJlbmRlclRhYmxlUm93QXhpcyIsInJvd0hlaWdodCIsInJlbmRlckFsbERheUlubmVyJDEiLCJoYW5kbGVTbGF0Q29vcmRzIiwidGltZUNvbnRlbnQiLCJpc05vd0luZGljYXRvciIsIm5vd0luZGljYXRvclRvcCIsInNhZmVDb21wdXRlVG9wIiwiZ2V0QWxsRGF5TWF4RXZlbnRQcm9wcyIsIlRpbWVDb2xzU2xhdHNDb29yZHMiLCJwb3NpdGlvbnMiLCJzdGFydE9mRGF5RGF0ZSIsInRpbWVNcyIsImNvbXB1dGVUaW1lVG9wIiwiY29tcHV0ZURhdGVUb3AiLCJ3aGVuIiwic2xhdENvdmVyYWdlIiwic2xhdEluZGV4Iiwic2xhdFJlbWFpbmRlciIsIlRpbWVDb2xzU2xhdHNCb2R5Iiwic2xhdEVsUmVmcyIsImF4aXMiLCJUaW1lQ29sc1NsYXRzIiwib25Db29yZHMiLCJjb2xsZWN0U2xhdEVscyIsInNwbGl0U2Vnc0J5Q29sIiwic2Vnc0J5Q29sIiwic3BsaXRJbnRlcmFjdGlvbkJ5Q29sIiwiVGltZUNvbE1vcmVMaW5rIiwicmVuZGVyUGxhaW5GZ1NlZ3MiLCJyZW5kZXJNb3JlTGlua0lubmVyIiwiYnVpbGRQb3NpdGlvbmluZyIsImhpZGRlbkdyb3VwcyIsIndlYiIsImJ1aWxkV2ViIiwic3RyZXRjaFdlYiIsIndlYlRvUmVjdHMiLCJidWlsZE5vZGUiLCJjYWNoZWFibGUiLCJzaWJsaW5nUmFuZ2UiLCJmaW5kTmV4dExldmVsU2VncyIsIm5leHRMZXZlbFJlcyIsImJ1aWxkTm9kZXMiLCJuZXh0TGV2ZWxOb2RlcyIsImxhdGVyYWxTdGFydCIsImxhdGVyYWxFbmQiLCJwYWlycyIsImNtcERlc2NQcmVzc3VyZXMiLCJleHRyYWN0Tm9kZSIsInN1YmplY3RMZXZlbCIsInN1YmplY3RMYXRlcmFsIiwic3ViamVjdEVudHJ5IiwiYWZ0ZXJTdWJqZWN0Iiwic2VhcmNoSW5kZXgiLCJ0b3BMZXZlbE5vZGVzIiwidG90YWxUaGlja25lc3MiLCJzdHJldGNoTm9kZSIsInN0YXJ0Q29vcmQiLCJwcmV2VGhpY2tuZXNzIiwiYWxsVGhpY2tuZXNzIiwidGhpY2tuZXNzRnJhY3Rpb24iLCJlbmRDb29yZCIsIm5ld0NoaWxkcmVuIiwibmV3VGhpY2tuZXNzIiwicHJvY2Vzc05vZGUiLCJzdGFja0RlcHRoIiwic3RhY2tGb3J3YXJkIiwicHJvY2Vzc05vZGVzIiwia2V5RnVuYyIsIndvcmtGdW5jIiwiY2FjaGUiLCJjb21wdXRlU2VnVkNvb3JkcyIsImNvbERhdGUiLCJ2Y29vcmRzIiwiY29tcHV0ZUZnU2VnUGxhY2VtZW50cyIsInNlZ1ZDb29yZHMiLCJkdW1iU2VncyIsInNlZ1JlY3QiLCJkdW1iU2VnIiwiREVGQVVMVF9USU1FX0ZPUk1BVCQxIiwiVGltZUNvbEV2ZW50IiwiaXNTaG9ydCIsIlRpbWVDb2wiLCJpc1NlbGVjdE1pcnJvciIsImludGVyYWN0aW9uQWZmZWN0ZWRJbnN0YW5jZXMiLCJzb3J0ZWRGZ1NlZ3MiLCJyZW5kZXJOb3dJbmRpY2F0b3IiLCJub3dJbmRpY2F0b3JTZWdzIiwic2VnSXNJbnZpc2libGUiLCJmb3JjZWRLZXkiLCJyZW5kZXJQb3NpdGlvbmVkRmdTZWdzIiwicmVuZGVySGlkZGVuR3JvdXBzIiwic2VnUGxhY2VtZW50IiwidlN0eWxlIiwiY29tcHV0ZVNlZ1ZTdHlsZSIsImhTdHlsZSIsImNvbXB1dGVTZWdIU3R5bGUiLCJpc0luc2V0IiwiaGlkZGVuR3JvdXAiLCJwb3NpdGlvbkNzcyIsImNvbXBpbGVTZWdzRnJvbUVudHJpZXMiLCJzZWdIQ29vcmRzIiwic2hvdWxkT3ZlcmxhcCIsIm5lYXJDb29yZCIsImZhckNvb3JkIiwiaGlkZGVuSW5zdGFuY2VzIiwic2VnRW50cmllcyIsInNlZ0VudHJ5IiwiVGltZUNvbHNDb250ZW50Iiwic3BsaXROb3dJbmRpY2F0b3JTZWdzIiwibm93SW5kaWNhdG9yU2Vnc0J5Um93IiwidXBkYXRlQ29vcmRzIiwib25Db2xDb29yZHMiLCJjb2xsZWN0Q2VsbEVscyIsIlRpbWVDb2xzIiwicHJvY2Vzc1Nsb3RPcHRpb25zIiwib25TY3JvbGxUb3BSZXF1ZXN0IiwiaGFuZGxlQ29sQ29vcmRzIiwiY29sQ29vcmRzIiwib25TbGF0Q29vcmRzIiwic2Nyb2xsUmVzcG9uZGVyIiwic25hcHNQZXJTbG90IiwiY29sSW5kZXgiLCJzbGF0VG9wIiwic2xhdEhlaWdodCIsInBhcnRpYWwiLCJsb2NhbFNuYXBJbmRleCIsInNuYXBJbmRleCIsImRheURhdGUiLCJzbmFwRHVyYXRpb25PdmVycmlkZSIsIkRheVRpbWVDb2xzU2xpY2VyIiwiZGF5UmFuZ2VzIiwiRGF5VGltZUNvbHMiLCJidWlsZERheVJhbmdlcyIsInRpbWVDb2xzUmVmIiwiU1RPQ0tfU1VCX0RVUkFUSU9OUyIsImJ1aWxkU2xhdE1ldGFzIiwiZXhwbGljaXRMYWJlbEludGVydmFsIiwic2xhdFRpbWUiLCJzbGF0SXRlcmF0b3IiLCJsYWJlbEludGVydmFsIiwiY29tcHV0ZUxhYmVsSW50ZXJ2YWwiLCJtZXRhcyIsInNsb3RzUGVyTGFiZWwiLCJEYXlUaW1lQ29sc1ZpZXciLCJidWlsZFRpbWVDb2xzTW9kZWwiLCJoYXNBdHRhY2hlZEF4aXMiLCJoYXNEZXRhY2hlZEF4aXMiLCJhbGxEYXlTbG90IiwidGltZUdyaWRDb250ZW50IiwiT1BUSU9OX1JFRklORVJTJDIiLCJpbmRleCQyIiwidGltZUdyaWQiLCJ0aW1lR3JpZERheSIsInRpbWVHcmlkV2VlayIsImNzc18yNDh6JDEiLCJMaXN0Vmlld0hlYWRlclJvdyIsInRleHRJZCIsImNlbGxJZCIsImxpc3REYXlGb3JtYXQiLCJzaWRlVGV4dCIsImxpc3REYXlTaWRlRm9ybWF0Iiwic2lkZU5hdkxpbmtBdHRycyIsInJlbmRlcklubmVyQ29udGVudCIsIkRFRkFVTFRfVElNRV9GT1JNQVQiLCJMaXN0Vmlld0V2ZW50Um93IiwidGltZUhlYWRlcklkIiwiZXZlbnRIZWFkZXJJZCIsImRhdGVIZWFkZXJJZCIsInJlbmRlckV2ZW50SW5uZXJDb250ZW50IiwiYnVpbGRUaW1lQ29udGVudCIsImludGVyYWN0aXZlQXR0cnMiLCJkb0FsbERheSIsInJlbmRlckFsbERheUlubmVyIiwiTGlzdFZpZXciLCJjb21wdXRlRGF0ZVZhcnMiLCJldmVudFN0b3JlVG9TZWdzIiwiX2V2ZW50U3RvcmVUb1NlZ3MiLCJkYXRlSGVhZGVySWRSb290Iiwic2V0Um9vdEVsIiwiZGF5RGF0ZXMiLCJyZW5kZXJTZWdMaXN0IiwicmVuZGVyRW1wdHlNZXNzYWdlIiwibm9FdmVudHNDb250ZW50IiwicmVuZGVyTm9FdmVudHNJbm5lciIsIm5vRXZlbnRzQ2xhc3NOYW1lcyIsIm5vRXZlbnRzRGlkTW91bnQiLCJub0V2ZW50c1dpbGxVbm1vdW50Iiwic2Vnc0J5RGF5IiwiZ3JvdXBTZWdzQnlEYXkiLCJpbm5lck5vZGVzIiwiZGF5U2VncyIsImRheVN0ciIsImV2ZW50UmFuZ2VzVG9TZWdzIiwiZXZlbnRSYW5nZVRvU2VncyIsInZpZXdFbmQiLCJPUFRJT05fUkVGSU5FUlMkMSIsImNyZWF0ZUZhbHNhYmxlRm9ybWF0dGVyIiwiaW5kZXgkMSIsImxpc3REYXkiLCJsaXN0V2VlayIsImxpc3RNb250aCIsImxpc3RZZWFyIiwiU2luZ2xlTW9udGgiLCJsYWJlbElkIiwic2xpY2VkUHJvcHMiLCJ0YWJsZUhlaWdodCIsInRhYmxlV2lkdGgiLCJpc29EYXRlU3RyIiwiTXVsdGlNb250aFZpZXciLCJzcGxpdERhdGVQcm9maWxlQnlNb250aCIsImJ1aWxkTW9udGhGb3JtYXQiLCJzY3JvbGxFbFJlZiIsImZpcnN0TW9udGhFbFJlZiIsIm1vbnRoSFBhZGRpbmciLCJjb2xDb3VudCIsIm11bHRpTW9udGhNaW5XaWR0aCIsIm11bHRpTW9udGhNYXhDb2x1bW5zIiwibW9udGhXaWR0aFBjdCIsIm1vbnRoVGFibGVXaWR0aCIsImlzTGVnaXRTaW5nbGVDb2wiLCJtb250aERhdGVQcm9maWxlcyIsIm1vbnRoVGl0bGVGb3JtYXQiLCJtdWx0aU1vbnRoVGl0bGVGb3JtYXQiLCJyb290Q2xhc3NOYW1lcyIsIm1vbnRoRGF0ZVByb2ZpbGUiLCJtb250aFN0ciIsImZpcnN0TW9udGhFbCIsIm1vbnRoRWwiLCJvbmVNb250aER1cmF0aW9uIiwibW9udGhTdGFydCIsIm1vbnRoRW5kIiwiWUVBUl9NT05USF9GT1JNQVRURVIiLCJZRUFSX0ZPUk1BVFRFUiIsImZvcm1hdE92ZXJyaWRlIiwiT1BUSU9OX1JFRklORVJTIiwiY3NzXzI0OHoiLCJtdWx0aU1vbnRoIiwibXVsdGlNb250aFllYXIiLCJEcmFnZ2FibGUiLCJJbnRlcm5hbCIsIlByZWFjdCJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7QUFJQSxHQUNBLElBQUlBLGVBQWUsQUFBQyxTQUFVQyxPQUFPO0lBQ2pDO0lBRUEsSUFBSUMsR0FBRUMsS0FBSUMsS0FBSUMsS0FBSUMsR0FBRUMsS0FBSUMsR0FBRUMsS0FBSUMsS0FBSUMsTUFBSSxDQUFDLEdBQUVDLElBQUUsRUFBRSxFQUFDQyxNQUFJO0lBQW9FLFNBQVNDLEVBQUVaLENBQUMsRUFBQ2EsQ0FBQztRQUFFLElBQUksSUFBSUMsS0FBS0QsRUFBRWIsQ0FBQyxDQUFDYyxFQUFFLEdBQUNELENBQUMsQ0FBQ0MsRUFBRTtRQUFDLE9BQU9kO0lBQUM7SUFBQyxTQUFTZSxJQUFJZixDQUFDO1FBQUUsSUFBSWEsSUFBRWIsRUFBRWdCLFVBQVU7UUFBQ0gsS0FBR0EsRUFBRUksV0FBVyxDQUFDakI7SUFBRztJQUFDLFNBQVNrQixFQUFFTCxDQUFDLEVBQUNDLENBQUMsRUFBQ0ssQ0FBQztRQUFFLElBQUlmLEdBQUVnQixHQUFFZCxHQUFFZSxJQUFFLENBQUM7UUFBRSxJQUFJZixLQUFLUSxFQUFFLFNBQU9SLElBQUVGLElBQUVVLENBQUMsQ0FBQ1IsRUFBRSxHQUFDLFNBQU9BLElBQUVjLElBQUVOLENBQUMsQ0FBQ1IsRUFBRSxHQUFDZSxDQUFDLENBQUNmLEVBQUUsR0FBQ1EsQ0FBQyxDQUFDUixFQUFFO1FBQUMsSUFBR2dCLFVBQVVDLE1BQU0sR0FBQyxLQUFJRixD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R0FBR0E7SUFDbkJqOEUsUUFBUTRwRyxTQUFTLEdBQUc5YjtJQUNwQjl0RixRQUFRNnBHLFFBQVEsR0FBR3ZrQztJQUNuQnRsRSxRQUFRMnpELGdCQUFnQixHQUFHQTtJQUMzQjN6RCxRQUFROHBHLE1BQU0sR0FBR3JrQztJQUNqQnpsRSxRQUFRc3VGLG1CQUFtQixHQUFHQTtJQUM5QnR1RixRQUFRdW5FLFlBQVksR0FBR0E7SUFDdkJ2bkUsUUFBUXVqRSxVQUFVLEdBQUdBO0lBQ3JCdmpFLFFBQVF3a0IsV0FBVyxHQUFHQTtJQUN0QnhrQixRQUFRaW1FLGFBQWEsR0FBR0E7SUFDeEJqbUUsUUFBUXl6RSxhQUFhLEdBQUdBO0lBQ3hCenpFLFFBQVFnOUUsV0FBVyxHQUFHQTtJQUN0Qmg5RSxRQUFRaTlFLE9BQU8sR0FBR0E7SUFFbEJud0UsT0FBT0MsY0FBYyxDQUFDL00sU0FBUyxjQUFjO1FBQUU2RyxPQUFPO0lBQUs7SUFFM0QsT0FBTzdHO0FBRVgsRUFBRyxDQUFDIiwiZmlsZSI6Iihzc3IpLy4vc3JjL3ZlbmRvci9mdWxsY2FsZW5kYXIvZ2xvYmFsLmpzIiwic291cmNlUm9vdCI6IiIsImlnbm9yZUxpc3QiOltdfQ==\n//# sourceURL=webpack-internal:///(ssr)/./src/vendor/fullcalendar/global.js\n");

/***/ }),

/***/ "(ssr)/./src/vendor/ionio-icon/css/iconoir.css":
/*!***********************************************!*\
  !*** ./src/vendor/ionio-icon/css/iconoir.css ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"4c406d9141bf\");\nif (false) {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9zcmMvdmVuZG9yL2lvbmlvLWljb24vY3NzL2ljb25vaXIuY3NzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxpRUFBZSxjQUFjO0FBQzdCLElBQUksS0FBVSxFQUFFLEVBQXVCIiwic291cmNlcyI6WyJEOlxcbmV4dFxcb3JnXFxzcmNcXHZlbmRvclxcaW9uaW8taWNvblxcY3NzXFxpY29ub2lyLmNzcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBcIjRjNDA2ZDkxNDFiZlwiXG5pZiAobW9kdWxlLmhvdCkgeyBtb2R1bGUuaG90LmFjY2VwdCgpIH1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./src/vendor/ionio-icon/css/iconoir.css\n");

/***/ }),

/***/ "(ssr)/./src/vendor/jstree/style.min.css":
/*!*****************************************!*\
  !*** ./src/vendor/jstree/style.min.css ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"ca900ec09bdd\");\nif (false) {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9zcmMvdmVuZG9yL2pzdHJlZS9zdHlsZS5taW4uY3NzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxpRUFBZSxjQUFjO0FBQzdCLElBQUksS0FBVSxFQUFFLEVBQXVCIiwic291cmNlcyI6WyJEOlxcbmV4dFxcb3JnXFxzcmNcXHZlbmRvclxcanN0cmVlXFxzdHlsZS5taW4uY3NzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IFwiY2E5MDBlYzA5YmRkXCJcbmlmIChtb2R1bGUuaG90KSB7IG1vZHVsZS5ob3QuYWNjZXB0KCkgfVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./src/vendor/jstree/style.min.css\n");

/***/ }),

/***/ "(ssr)/./src/vendor/leafletmaps/leaflet.css":
/*!********************************************!*\
  !*** ./src/vendor/leafletmaps/leaflet.css ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"ec929f1100c6\");\nif (false) {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9zcmMvdmVuZG9yL2xlYWZsZXRtYXBzL2xlYWZsZXQuY3NzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxpRUFBZSxjQUFjO0FBQzdCLElBQUksS0FBVSxFQUFFLEVBQXVCIiwic291cmNlcyI6WyJEOlxcbmV4dFxcb3JnXFxzcmNcXHZlbmRvclxcbGVhZmxldG1hcHNcXGxlYWZsZXQuY3NzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IFwiZWM5MjlmMTEwMGM2XCJcbmlmIChtb2R1bGUuaG90KSB7IG1vZHVsZS5ob3QuYWNjZXB0KCkgfVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./src/vendor/leafletmaps/leaflet.css\n");

/***/ }),

/***/ "(ssr)/./src/vendor/nouislider/nouislider.min.css":
/*!**************************************************!*\
  !*** ./src/vendor/nouislider/nouislider.min.css ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"33aad322ddcf\");\nif (false) {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9zcmMvdmVuZG9yL25vdWlzbGlkZXIvbm91aXNsaWRlci5taW4uY3NzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxpRUFBZSxjQUFjO0FBQzdCLElBQUksS0FBVSxFQUFFLEVBQXVCIiwic291cmNlcyI6WyJEOlxcbmV4dFxcb3JnXFxzcmNcXHZlbmRvclxcbm91aXNsaWRlclxcbm91aXNsaWRlci5taW4uY3NzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IFwiMzNhYWQzMjJkZGNmXCJcbmlmIChtb2R1bGUuaG90KSB7IG1vZHVsZS5ob3QuYWNjZXB0KCkgfVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./src/vendor/nouislider/nouislider.min.css\n");

/***/ }),

/***/ "(ssr)/./src/vendor/phosphor/phosphor-light.css":
/*!************************************************!*\
  !*** ./src/vendor/phosphor/phosphor-light.css ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"d2ab0bc56f03\");\nif (false) {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9zcmMvdmVuZG9yL3Bob3NwaG9yL3Bob3NwaG9yLWxpZ2h0LmNzcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsaUVBQWUsY0FBYztBQUM3QixJQUFJLEtBQVUsRUFBRSxFQUF1QiIsInNvdXJjZXMiOlsiRDpcXG5leHRcXG9yZ1xcc3JjXFx2ZW5kb3JcXHBob3NwaG9yXFxwaG9zcGhvci1saWdodC5jc3MiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgXCJkMmFiMGJjNTZmMDNcIlxuaWYgKG1vZHVsZS5ob3QpIHsgbW9kdWxlLmhvdC5hY2NlcHQoKSB9XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./src/vendor/phosphor/phosphor-light.css\n");

/***/ }),

/***/ "(ssr)/./src/vendor/prism/prism.min.css":
/*!****************************************!*\
  !*** ./src/vendor/prism/prism.min.css ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"ee7399d05d7f\");\nif (false) {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9zcmMvdmVuZG9yL3ByaXNtL3ByaXNtLm1pbi5jc3MiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLGlFQUFlLGNBQWM7QUFDN0IsSUFBSSxLQUFVLEVBQUUsRUFBdUIiLCJzb3VyY2VzIjpbIkQ6XFxuZXh0XFxvcmdcXHNyY1xcdmVuZG9yXFxwcmlzbVxccHJpc20ubWluLmNzcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBcImVlNzM5OWQwNWQ3ZlwiXG5pZiAobW9kdWxlLmhvdCkgeyBtb2R1bGUuaG90LmFjY2VwdCgpIH1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./src/vendor/prism/prism.min.css\n");

/***/ }),

/***/ "(ssr)/./src/vendor/select/select2.min.css":
/*!*******************************************!*\
  !*** ./src/vendor/select/select2.min.css ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"dd955de114f2\");\nif (false) {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9zcmMvdmVuZG9yL3NlbGVjdC9zZWxlY3QyLm1pbi5jc3MiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLGlFQUFlLGNBQWM7QUFDN0IsSUFBSSxLQUFVLEVBQUUsRUFBdUIiLCJzb3VyY2VzIjpbIkQ6XFxuZXh0XFxvcmdcXHNyY1xcdmVuZG9yXFxzZWxlY3RcXHNlbGVjdDIubWluLmNzcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBcImRkOTU1ZGUxMTRmMlwiXG5pZiAobW9kdWxlLmhvdCkgeyBtb2R1bGUuaG90LmFjY2VwdCgpIH1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./src/vendor/select/select2.min.css\n");

/***/ }),

/***/ "(ssr)/./src/vendor/shepherdjs/shepherd.css":
/*!********************************************!*\
  !*** ./src/vendor/shepherdjs/shepherd.css ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"5840dee87b75\");\nif (false) {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9zcmMvdmVuZG9yL3NoZXBoZXJkanMvc2hlcGhlcmQuY3NzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxpRUFBZSxjQUFjO0FBQzdCLElBQUksS0FBVSxFQUFFLEVBQXVCIiwic291cmNlcyI6WyJEOlxcbmV4dFxcb3JnXFxzcmNcXHZlbmRvclxcc2hlcGhlcmRqc1xcc2hlcGhlcmQuY3NzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IFwiNTg0MGRlZTg3Yjc1XCJcbmlmIChtb2R1bGUuaG90KSB7IG1vZHVsZS5ob3QuYWNjZXB0KCkgfVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./src/vendor/shepherdjs/shepherd.css\n");

/***/ }),

/***/ "(ssr)/./src/vendor/slick/slick.css":
/*!************************************!*\
  !*** ./src/vendor/slick/slick.css ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"64e6c5ff99f1\");\nif (false) {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9zcmMvdmVuZG9yL3NsaWNrL3NsaWNrLmNzcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsaUVBQWUsY0FBYztBQUM3QixJQUFJLEtBQVUsRUFBRSxFQUF1QiIsInNvdXJjZXMiOlsiRDpcXG5leHRcXG9yZ1xcc3JjXFx2ZW5kb3JcXHNsaWNrXFxzbGljay5jc3MiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgXCI2NGU2YzVmZjk5ZjFcIlxuaWYgKG1vZHVsZS5ob3QpIHsgbW9kdWxlLmhvdC5hY2NlcHQoKSB9XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./src/vendor/slick/slick.css\n");

/***/ }),

/***/ "(ssr)/./src/vendor/tabler-icons/tabler-icons.css":
/*!**************************************************!*\
  !*** ./src/vendor/tabler-icons/tabler-icons.css ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"72f4d15c8b14\");\nif (false) {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9zcmMvdmVuZG9yL3RhYmxlci1pY29ucy90YWJsZXItaWNvbnMuY3NzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxpRUFBZSxjQUFjO0FBQzdCLElBQUksS0FBVSxFQUFFLEVBQXVCIiwic291cmNlcyI6WyJEOlxcbmV4dFxcb3JnXFxzcmNcXHZlbmRvclxcdGFibGVyLWljb25zXFx0YWJsZXItaWNvbnMuY3NzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IFwiNzJmNGQxNWM4YjE0XCJcbmlmIChtb2R1bGUuaG90KSB7IG1vZHVsZS5ob3QuYWNjZXB0KCkgfVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./src/vendor/tabler-icons/tabler-icons.css\n");

/***/ }),

/***/ "(ssr)/./src/vendor/trumbowyg/trumbowyg.min.css":
/*!************************************************!*\
  !*** ./src/vendor/trumbowyg/trumbowyg.min.css ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"999e078456e1\");\nif (false) {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9zcmMvdmVuZG9yL3RydW1ib3d5Zy90cnVtYm93eWcubWluLmNzcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsaUVBQWUsY0FBYztBQUM3QixJQUFJLEtBQVUsRUFBRSxFQUF1QiIsInNvdXJjZXMiOlsiRDpcXG5leHRcXG9yZ1xcc3JjXFx2ZW5kb3JcXHRydW1ib3d5Z1xcdHJ1bWJvd3lnLm1pbi5jc3MiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgXCI5OTllMDc4NDU2ZTFcIlxuaWYgKG1vZHVsZS5ob3QpIHsgbW9kdWxlLmhvdC5hY2NlcHQoKSB9XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./src/vendor/trumbowyg/trumbowyg.min.css\n");

/***/ }),

/***/ "(ssr)/./src/vendor/vector-map/jquery-jvectormap.css":
/*!*****************************************************!*\
  !*** ./src/vendor/vector-map/jquery-jvectormap.css ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"b437342667d7\");\nif (false) {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9zcmMvdmVuZG9yL3ZlY3Rvci1tYXAvanF1ZXJ5LWp2ZWN0b3JtYXAuY3NzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxpRUFBZSxjQUFjO0FBQzdCLElBQUksS0FBVSxFQUFFLEVBQXVCIiwic291cmNlcyI6WyJEOlxcbmV4dFxcb3JnXFxzcmNcXHZlbmRvclxcdmVjdG9yLW1hcFxcanF1ZXJ5LWp2ZWN0b3JtYXAuY3NzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IFwiYjQzNzM0MjY2N2Q3XCJcbmlmIChtb2R1bGUuaG90KSB7IG1vZHVsZS5ob3QuYWNjZXB0KCkgfVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./src/vendor/vector-map/jquery-jvectormap.css\n");

/***/ }),

/***/ "(ssr)/./src/vendor/weather/weather-icons.css":
/*!**********************************************!*\
  !*** ./src/vendor/weather/weather-icons.css ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"afe5e3825084\");\nif (false) {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9zcmMvdmVuZG9yL3dlYXRoZXIvd2VhdGhlci1pY29ucy5jc3MiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLGlFQUFlLGNBQWM7QUFDN0IsSUFBSSxLQUFVLEVBQUUsRUFBdUIiLCJzb3VyY2VzIjpbIkQ6XFxuZXh0XFxvcmdcXHNyY1xcdmVuZG9yXFx3ZWF0aGVyXFx3ZWF0aGVyLWljb25zLmNzcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBcImFmZTVlMzgyNTA4NFwiXG5pZiAobW9kdWxlLmhvdCkgeyBtb2R1bGUuaG90LmFjY2VwdCgpIH1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./src/vendor/weather/weather-icons.css\n");

/***/ }),

/***/ "../app-render/action-async-storage.external":
/*!*******************************************************************************!*\
  !*** external "next/dist/server/app-render/action-async-storage.external.js" ***!
  \*******************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/server/app-render/action-async-storage.external.js");

/***/ }),

/***/ "../app-render/after-task-async-storage.external":
/*!***********************************************************************************!*\
  !*** external "next/dist/server/app-render/after-task-async-storage.external.js" ***!
  \***********************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/server/app-render/after-task-async-storage.external.js");

/***/ }),

/***/ "../app-render/dynamic-access-async-storage.external":
/*!***************************************************************************************!*\
  !*** external "next/dist/server/app-render/dynamic-access-async-storage.external.js" ***!
  \***************************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/server/app-render/dynamic-access-async-storage.external.js");

/***/ }),

/***/ "./work-async-storage.external":
/*!*****************************************************************************!*\
  !*** external "next/dist/server/app-render/work-async-storage.external.js" ***!
  \*****************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/server/app-render/work-async-storage.external.js");

/***/ }),

/***/ "./work-unit-async-storage.external":
/*!**********************************************************************************!*\
  !*** external "next/dist/server/app-render/work-unit-async-storage.external.js" ***!
  \**********************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/server/app-render/work-unit-async-storage.external.js");

/***/ }),

/***/ "http":
/*!***********************!*\
  !*** external "http" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("http");

/***/ }),

/***/ "https":
/*!************************!*\
  !*** external "https" ***!
  \************************/
/***/ ((module) => {

"use strict";
module.exports = require("https");

/***/ }),

/***/ "module":
/*!*************************!*\
  !*** external "module" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("module");

/***/ }),

/***/ "next/dist/compiled/next-server/app-page.runtime.dev.js":
/*!*************************************************************************!*\
  !*** external "next/dist/compiled/next-server/app-page.runtime.dev.js" ***!
  \*************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/compiled/next-server/app-page.runtime.dev.js");

/***/ }),

/***/ "next/dist/shared/lib/no-fallback-error.external":
/*!******************************************************************!*\
  !*** external "next/dist/shared/lib/no-fallback-error.external" ***!
  \******************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/no-fallback-error.external");

/***/ }),

/***/ "next/dist/shared/lib/router/utils/app-paths":
/*!**************************************************************!*\
  !*** external "next/dist/shared/lib/router/utils/app-paths" ***!
  \**************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/router/utils/app-paths");

/***/ }),

/***/ "next/dist/shared/lib/router/utils/is-bot":
/*!***********************************************************!*\
  !*** external "next/dist/shared/lib/router/utils/is-bot" ***!
  \***********************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/router/utils/is-bot");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("path");

/***/ }),

/***/ "punycode":
/*!***************************!*\
  !*** external "punycode" ***!
  \***************************/
/***/ ((module) => {

"use strict";
module.exports = require("punycode");

/***/ }),

/***/ "stream":
/*!*************************!*\
  !*** external "stream" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("stream");

/***/ }),

/***/ "url":
/*!**********************!*\
  !*** external "url" ***!
  \**********************/
/***/ ((module) => {

"use strict";
module.exports = require("url");

/***/ }),

/***/ "util":
/*!***********************!*\
  !*** external "util" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("util");

/***/ }),

/***/ "zlib":
/*!***********************!*\
  !*** external "zlib" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("zlib");

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../../../webpack-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = __webpack_require__.X(0, ["vendor-chunks/next","vendor-chunks/@supabase","vendor-chunks/tr46","vendor-chunks/whatwg-url","vendor-chunks/simplebar-react","vendor-chunks/webidl-conversions","vendor-chunks/@swc","vendor-chunks/slick-carousel","vendor-chunks/filepond","vendor-chunks/filepond-plugin-image-preview","vendor-chunks/bootstrap","vendor-chunks/prop-types","vendor-chunks/reactstrap","vendor-chunks/react-is","vendor-chunks/object-assign","vendor-chunks/classnames"], () => (__webpack_exec__("(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader/index.js?name=app%2Fauth%2Flogin%2Fpage&page=%2Fauth%2Flogin%2Fpage&appPaths=%2Fauth%2Flogin%2Fpage&pagePath=private-next-app-dir%2Fauth%2Flogin%2Fpage.js&appDir=D%3A%5Cnext%5Corg%5Csrc%5Capp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=D%3A%5Cnext%5Corg&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D&isGlobalNotFoundEnabled=!")));
module.exports = __webpack_exports__;

})();