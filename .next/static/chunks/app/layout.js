/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["app/layout"],{

/***/ "(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/AuthAdminApi.js":
/*!********************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/module/AuthAdminApi.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _GoTrueAdminApi__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./GoTrueAdminApi */ \"(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/GoTrueAdminApi.js\");\n\nconst AuthAdminApi = _GoTrueAdminApi__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AuthAdminApi);\n//# sourceMappingURL=AuthAdminApi.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvYXV0aC1qcy9kaXN0L21vZHVsZS9BdXRoQWRtaW5BcGkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBOEM7QUFDOUMscUJBQXFCLHVEQUFjO0FBQ25DLGlFQUFlLFlBQVksRUFBQztBQUM1QiIsInNvdXJjZXMiOlsiRDpcXG5leHRcXG9yZ1xcbm9kZV9tb2R1bGVzXFxAc3VwYWJhc2VcXGF1dGgtanNcXGRpc3RcXG1vZHVsZVxcQXV0aEFkbWluQXBpLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBHb1RydWVBZG1pbkFwaSBmcm9tICcuL0dvVHJ1ZUFkbWluQXBpJztcbmNvbnN0IEF1dGhBZG1pbkFwaSA9IEdvVHJ1ZUFkbWluQXBpO1xuZXhwb3J0IGRlZmF1bHQgQXV0aEFkbWluQXBpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QXV0aEFkbWluQXBpLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/AuthAdminApi.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/AuthClient.js":
/*!******************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/module/AuthClient.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _GoTrueClient__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./GoTrueClient */ \"(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/GoTrueClient.js\");\n\nconst AuthClient = _GoTrueClient__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AuthClient);\n//# sourceMappingURL=AuthClient.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvYXV0aC1qcy9kaXN0L21vZHVsZS9BdXRoQ2xpZW50LmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQTBDO0FBQzFDLG1CQUFtQixxREFBWTtBQUMvQixpRUFBZSxVQUFVLEVBQUM7QUFDMUIiLCJzb3VyY2VzIjpbIkQ6XFxuZXh0XFxvcmdcXG5vZGVfbW9kdWxlc1xcQHN1cGFiYXNlXFxhdXRoLWpzXFxkaXN0XFxtb2R1bGVcXEF1dGhDbGllbnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEdvVHJ1ZUNsaWVudCBmcm9tICcuL0dvVHJ1ZUNsaWVudCc7XG5jb25zdCBBdXRoQ2xpZW50ID0gR29UcnVlQ2xpZW50O1xuZXhwb3J0IGRlZmF1bHQgQXV0aENsaWVudDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUF1dGhDbGllbnQuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/AuthClient.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/GoTrueAdminApi.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/module/GoTrueAdminApi.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ GoTrueAdminApi)\n/* harmony export */ });\n/* harmony import */ var _lib_fetch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/fetch */ \"(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/fetch.js\");\n/* harmony import */ var _lib_helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/helpers */ \"(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/helpers.js\");\n/* harmony import */ var _lib_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/types */ \"(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/types.js\");\n/* harmony import */ var _lib_errors__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lib/errors */ \"(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/errors.js\");\nvar __rest = (undefined && undefined.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\n\n\n\n\nclass GoTrueAdminApi {\n    constructor({ url = '', headers = {}, fetch, }) {\n        this.url = url;\n        this.headers = headers;\n        this.fetch = (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_1__.resolveFetch)(fetch);\n        this.mfa = {\n            listFactors: this._listFactors.bind(this),\n            deleteFactor: this._deleteFactor.bind(this),\n        };\n        this.oauth = {\n            listClients: this._listOAuthClients.bind(this),\n            createClient: this._createOAuthClient.bind(this),\n            getClient: this._getOAuthClient.bind(this),\n            deleteClient: this._deleteOAuthClient.bind(this),\n            regenerateClientSecret: this._regenerateOAuthClientSecret.bind(this),\n        };\n    }\n    /**\n     * Removes a logged-in session.\n     * @param jwt A valid, logged-in JWT.\n     * @param scope The logout sope.\n     */\n    async signOut(jwt, scope = _lib_types__WEBPACK_IMPORTED_MODULE_2__.SIGN_OUT_SCOPES[0]) {\n        if (_lib_types__WEBPACK_IMPORTED_MODULE_2__.SIGN_OUT_SCOPES.indexOf(scope) < 0) {\n            throw new Error(`@supabase/auth-js: Parameter scope must be one of ${_lib_types__WEBPACK_IMPORTED_MODULE_2__.SIGN_OUT_SCOPES.join(', ')}`);\n        }\n        try {\n            await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_0__._request)(this.fetch, 'POST', `${this.url}/logout?scope=${scope}`, {\n                headers: this.headers,\n                jwt,\n                noResolveJson: true,\n            });\n            return { data: null, error: null };\n        }\n        catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_3__.isAuthError)(error)) {\n                return { data: null, error };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Sends an invite link to an email address.\n     * @param email The email address of the user.\n     * @param options Additional options to be included when inviting.\n     */\n    async inviteUserByEmail(email, options = {}) {\n        try {\n            return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_0__._request)(this.fetch, 'POST', `${this.url}/invite`, {\n                body: { email, data: options.data },\n                headers: this.headers,\n                redirectTo: options.redirectTo,\n                xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_0__._userResponse,\n            });\n        }\n        catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_3__.isAuthError)(error)) {\n                return { data: { user: null }, error };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Generates email links and OTPs to be sent via a custom email provider.\n     * @param email The user's email.\n     * @param options.password User password. For signup only.\n     * @param options.data Optional user metadata. For signup only.\n     * @param options.redirectTo The redirect url which should be appended to the generated link\n     */\n    async generateLink(params) {\n        try {\n            const { options } = params, rest = __rest(params, [\"options\"]);\n            const body = Object.assign(Object.assign({}, rest), options);\n            if ('newEmail' in rest) {\n                // replace newEmail with new_email in request body\n                body.new_email = rest === null || rest === void 0 ? void 0 : rest.newEmail;\n                delete body['newEmail'];\n            }\n            return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_0__._request)(this.fetch, 'POST', `${this.url}/admin/generate_link`, {\n                body: body,\n                headers: this.headers,\n                xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_0__._generateLinkResponse,\n                redirectTo: options === null || options === void 0 ? void 0 : options.redirectTo,\n            });\n        }\n        catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_3__.isAuthError)(error)) {\n                return {\n                    data: {\n                        properties: null,\n                        user: null,\n                    },\n                    error,\n                };\n            }\n            throw error;\n        }\n    }\n    // User Admin API\n    /**\n     * Creates a new user.\n     * This function should only be called on a server. Never expose your `service_role` key in the browser.\n     */\n    async createUser(attributes) {\n        try {\n            return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_0__._request)(this.fetch, 'POST', `${this.url}/admin/users`, {\n                body: attributes,\n                headers: this.headers,\n                xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_0__._userResponse,\n            });\n        }\n        catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_3__.isAuthError)(error)) {\n                return { data: { user: null }, error };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Get a list of users.\n     *\n     * This function should only be called on a server. Never expose your `service_role` key in the browser.\n     * @param params An object which supports `page` and `perPage` as numbers, to alter the paginated results.\n     */\n    async listUsers(params) {\n        var _a, _b, _c, _d, _e, _f, _g;\n        try {\n            const pagination = { nextPage: null, lastPage: 0, total: 0 };\n            const response = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_0__._request)(this.fetch, 'GET', `${this.url}/admin/users`, {\n                headers: this.headers,\n                noResolveJson: true,\n                query: {\n                    page: (_b = (_a = params === null || params === void 0 ? void 0 : params.page) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : '',\n                    per_page: (_d = (_c = params === null || params === void 0 ? void 0 : params.perPage) === null || _c === void 0 ? void 0 : _c.toString()) !== null && _d !== void 0 ? _d : '',\n                },\n                xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_0__._noResolveJsonResponse,\n            });\n            if (response.error)\n                throw response.error;\n            const users = await response.json();\n            const total = (_e = response.headers.get('x-total-count')) !== null && _e !== void 0 ? _e : 0;\n            const links = (_g = (_f = response.headers.get('link')) === null || _f === void 0 ? void 0 : _f.split(',')) !== null && _g !== void 0 ? _g : [];\n            if (links.length > 0) {\n                links.forEach((link) => {\n                    const page = parseInt(link.split(';')[0].split('=')[1].substring(0, 1));\n                    const rel = JSON.parse(link.split(';')[1].split('=')[1]);\n                    pagination[`${rel}Page`] = page;\n                });\n                pagination.total = parseInt(total);\n            }\n            return { data: Object.assign(Object.assign({}, users), pagination), error: null };\n        }\n        catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_3__.isAuthError)(error)) {\n                return { data: { users: [] }, error };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Get user by id.\n     *\n     * @param uid The user's unique identifier\n     *\n     * This function should only be called on a server. Never expose your `service_role` key in the browser.\n     */\n    async getUserById(uid) {\n        (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_1__.validateUUID)(uid);\n        try {\n            return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_0__._request)(this.fetch, 'GET', `${this.url}/admin/users/${uid}`, {\n                headers: this.headers,\n                xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_0__._userResponse,\n            });\n        }\n        catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_3__.isAuthError)(error)) {\n                return { data: { user: null }, error };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Updates the user data.\n     *\n     * @param attributes The data you want to update.\n     *\n     * This function should only be called on a server. Never expose your `service_role` key in the browser.\n     */\n    async updateUserById(uid, attributes) {\n        (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_1__.validateUUID)(uid);\n        try {\n            return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_0__._request)(this.fetch, 'PUT', `${this.url}/admin/users/${uid}`, {\n                body: attributes,\n                headers: this.headers,\n                xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_0__._userResponse,\n            });\n        }\n        catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_3__.isAuthError)(error)) {\n                return { data: { user: null }, error };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Delete a user. Requires a `service_role` key.\n     *\n     * @param id The user id you want to remove.\n     * @param shouldSoftDelete If true, then the user will be soft-deleted from the auth schema. Soft deletion allows user identification from the hashed user ID but is not reversible.\n     * Defaults to false for backward compatibility.\n     *\n     * This function should only be called on a server. Never expose your `service_role` key in the browser.\n     */\n    async deleteUser(id, shouldSoftDelete = false) {\n        (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_1__.validateUUID)(id);\n        try {\n            return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_0__._request)(this.fetch, 'DELETE', `${this.url}/admin/users/${id}`, {\n                headers: this.headers,\n                body: {\n                    should_soft_delete: shouldSoftDelete,\n                },\n                xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_0__._userResponse,\n            });\n        }\n        catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_3__.isAuthError)(error)) {\n                return { data: { user: null }, error };\n            }\n            throw error;\n        }\n    }\n    async _listFactors(params) {\n        (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_1__.validateUUID)(params.userId);\n        try {\n            const { data, error } = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_0__._request)(this.fetch, 'GET', `${this.url}/admin/users/${params.userId}/factors`, {\n                headers: this.headers,\n                xform: (factors) => {\n                    return { data: { factors }, error: null };\n                },\n            });\n            return { data, error };\n        }\n        catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_3__.isAuthError)(error)) {\n                return { data: null, error };\n            }\n            throw error;\n        }\n    }\n    async _deleteFactor(params) {\n        (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_1__.validateUUID)(params.userId);\n        (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_1__.validateUUID)(params.id);\n        try {\n            const data = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_0__._request)(this.fetch, 'DELETE', `${this.url}/admin/users/${params.userId}/factors/${params.id}`, {\n                headers: this.headers,\n            });\n            return { data, error: null };\n        }\n        catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_3__.isAuthError)(error)) {\n                return { data: null, error };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Lists all OAuth clients with optional pagination.\n     * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.\n     *\n     * This function should only be called on a server. Never expose your `service_role` key in the browser.\n     */\n    async _listOAuthClients(params) {\n        var _a, _b, _c, _d, _e, _f, _g;\n        try {\n            const pagination = { nextPage: null, lastPage: 0, total: 0 };\n            const response = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_0__._request)(this.fetch, 'GET', `${this.url}/admin/oauth/clients`, {\n                headers: this.headers,\n                noResolveJson: true,\n                query: {\n                    page: (_b = (_a = params === null || params === void 0 ? void 0 : params.page) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : '',\n                    per_page: (_d = (_c = params === null || params === void 0 ? void 0 : params.perPage) === null || _c === void 0 ? void 0 : _c.toString()) !== null && _d !== void 0 ? _d : '',\n                },\n                xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_0__._noResolveJsonResponse,\n            });\n            if (response.error)\n                throw response.error;\n            const clients = await response.json();\n            const total = (_e = response.headers.get('x-total-count')) !== null && _e !== void 0 ? _e : 0;\n            const links = (_g = (_f = response.headers.get('link')) === null || _f === void 0 ? void 0 : _f.split(',')) !== null && _g !== void 0 ? _g : [];\n            if (links.length > 0) {\n                links.forEach((link) => {\n                    const page = parseInt(link.split(';')[0].split('=')[1].substring(0, 1));\n                    const rel = JSON.parse(link.split(';')[1].split('=')[1]);\n                    pagination[`${rel}Page`] = page;\n                });\n                pagination.total = parseInt(total);\n            }\n            return { data: Object.assign(Object.assign({}, clients), pagination), error: null };\n        }\n        catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_3__.isAuthError)(error)) {\n                return { data: { clients: [] }, error };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Creates a new OAuth client.\n     * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.\n     *\n     * This function should only be called on a server. Never expose your `service_role` key in the browser.\n     */\n    async _createOAuthClient(params) {\n        try {\n            return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_0__._request)(this.fetch, 'POST', `${this.url}/admin/oauth/clients`, {\n                body: params,\n                headers: this.headers,\n                xform: (client) => {\n                    return { data: client, error: null };\n                },\n            });\n        }\n        catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_3__.isAuthError)(error)) {\n                return { data: null, error };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Gets details of a specific OAuth client.\n     * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.\n     *\n     * This function should only be called on a server. Never expose your `service_role` key in the browser.\n     */\n    async _getOAuthClient(clientId) {\n        try {\n            return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_0__._request)(this.fetch, 'GET', `${this.url}/admin/oauth/clients/${clientId}`, {\n                headers: this.headers,\n                xform: (client) => {\n                    return { data: client, error: null };\n                },\n            });\n        }\n        catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_3__.isAuthError)(error)) {\n                return { data: null, error };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Deletes an OAuth client.\n     * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.\n     *\n     * This function should only be called on a server. Never expose your `service_role` key in the browser.\n     */\n    async _deleteOAuthClient(clientId) {\n        try {\n            return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_0__._request)(this.fetch, 'DELETE', `${this.url}/admin/oauth/clients/${clientId}`, {\n                headers: this.headers,\n                xform: (client) => {\n                    return { data: client, error: null };\n                },\n            });\n        }\n        catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_3__.isAuthError)(error)) {\n                return { data: null, error };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Regenerates the secret for an OAuth client.\n     * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.\n     *\n     * This function should only be called on a server. Never expose your `service_role` key in the browser.\n     */\n    async _regenerateOAuthClientSecret(clientId) {\n        try {\n            return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_0__._request)(this.fetch, 'POST', `${this.url}/admin/oauth/clients/${clientId}/regenerate_secret`, {\n                headers: this.headers,\n                xform: (client) => {\n                    return { data: client, error: null };\n                },\n            });\n        }\n        catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_3__.isAuthError)(error)) {\n                return { data: null, error };\n            }\n            throw error;\n        }\n    }\n}\n//# sourceMappingURL=GoTrueAdminApi.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvYXV0aC1qcy9kaXN0L21vZHVsZS9Hb1RydWVBZG1pbkFwaS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBLGNBQWMsU0FBSSxJQUFJLFNBQUk7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsY0FBYztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ3NHO0FBQzNDO0FBQ1o7QUFDSjtBQUM1QjtBQUNmLGtCQUFrQixzQkFBc0IsVUFBVTtBQUNsRDtBQUNBO0FBQ0EscUJBQXFCLDBEQUFZO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsdURBQWU7QUFDOUMsWUFBWSx1REFBZTtBQUMzQixpRkFBaUYsdURBQWUsWUFBWTtBQUM1RztBQUNBO0FBQ0Esa0JBQWtCLG9EQUFRLHdCQUF3QixTQUFTLGdCQUFnQixNQUFNO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixxQkFBcUI7QUFDckI7QUFDQTtBQUNBLGdCQUFnQix3REFBVztBQUMzQix5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0EseUJBQXlCLG9EQUFRLHdCQUF3QixTQUFTO0FBQ2xFLHdCQUF3QiwyQkFBMkI7QUFDbkQ7QUFDQTtBQUNBLHVCQUF1QixxREFBYTtBQUNwQyxhQUFhO0FBQ2I7QUFDQTtBQUNBLGdCQUFnQix3REFBVztBQUMzQix5QkFBeUIsUUFBUSxZQUFZO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFVBQVU7QUFDOUIsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsb0RBQVEsd0JBQXdCLFNBQVMsdUJBQXVCLFNBQVM7QUFDbEc7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QixpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQSxnQkFBZ0Isd0RBQVc7QUFDM0IseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiRDpcXG5leHRcXG9yZ1xcbm9kZV9tb2R1bGVzXFxAc3VwYWJhc2VcXGF1dGgtanNcXGRpc3RcXG1vZHVsZVxcR29UcnVlQWRtaW5BcGkuanMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fcmVzdCA9ICh0aGlzICYmIHRoaXMuX19yZXN0KSB8fCBmdW5jdGlvbiAocywgZSkge1xuICAgIHZhciB0ID0ge307XG4gICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXG4gICAgICAgIHRbcF0gPSBzW3BdO1xuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKVxuICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xuICAgICAgICB9XG4gICAgcmV0dXJuIHQ7XG59O1xuaW1wb3J0IHsgX2dlbmVyYXRlTGlua1Jlc3BvbnNlLCBfbm9SZXNvbHZlSnNvblJlc3BvbnNlLCBfcmVxdWVzdCwgX3VzZXJSZXNwb25zZSwgfSBmcm9tICcuL2xpYi9mZXRjaCc7XG5pbXBvcnQgeyByZXNvbHZlRmV0Y2gsIHZhbGlkYXRlVVVJRCB9IGZyb20gJy4vbGliL2hlbHBlcnMnO1xuaW1wb3J0IHsgU0lHTl9PVVRfU0NPUEVTLCB9IGZyb20gJy4vbGliL3R5cGVzJztcbmltcG9ydCB7IGlzQXV0aEVycm9yIH0gZnJvbSAnLi9saWIvZXJyb3JzJztcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEdvVHJ1ZUFkbWluQXBpIHtcbiAgICBjb25zdHJ1Y3Rvcih7IHVybCA9ICcnLCBoZWFkZXJzID0ge30sIGZldGNoLCB9KSB7XG4gICAgICAgIHRoaXMudXJsID0gdXJsO1xuICAgICAgICB0aGlzLmhlYWRlcnMgPSBoZWFkZXJzO1xuICAgICAgICB0aGlzLmZldGNoID0gcmVzb2x2ZUZldGNoKGZldGNoKTtcbiAgICAgICAgdGhpcy5tZmEgPSB7XG4gICAgICAgICAgICBsaXN0RmFjdG9yczogdGhpcy5fbGlzdEZhY3RvcnMuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIGRlbGV0ZUZhY3RvcjogdGhpcy5fZGVsZXRlRmFjdG9yLmJpbmQodGhpcyksXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMub2F1dGggPSB7XG4gICAgICAgICAgICBsaXN0Q2xpZW50czogdGhpcy5fbGlzdE9BdXRoQ2xpZW50cy5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgY3JlYXRlQ2xpZW50OiB0aGlzLl9jcmVhdGVPQXV0aENsaWVudC5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgZ2V0Q2xpZW50OiB0aGlzLl9nZXRPQXV0aENsaWVudC5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgZGVsZXRlQ2xpZW50OiB0aGlzLl9kZWxldGVPQXV0aENsaWVudC5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgcmVnZW5lcmF0ZUNsaWVudFNlY3JldDogdGhpcy5fcmVnZW5lcmF0ZU9BdXRoQ2xpZW50U2VjcmV0LmJpbmQodGhpcyksXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSBsb2dnZWQtaW4gc2Vzc2lvbi5cbiAgICAgKiBAcGFyYW0gand0IEEgdmFsaWQsIGxvZ2dlZC1pbiBKV1QuXG4gICAgICogQHBhcmFtIHNjb3BlIFRoZSBsb2dvdXQgc29wZS5cbiAgICAgKi9cbiAgICBhc3luYyBzaWduT3V0KGp3dCwgc2NvcGUgPSBTSUdOX09VVF9TQ09QRVNbMF0pIHtcbiAgICAgICAgaWYgKFNJR05fT1VUX1NDT1BFUy5pbmRleE9mKHNjb3BlKSA8IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQHN1cGFiYXNlL2F1dGgtanM6IFBhcmFtZXRlciBzY29wZSBtdXN0IGJlIG9uZSBvZiAke1NJR05fT1VUX1NDT1BFUy5qb2luKCcsICcpfWApO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnUE9TVCcsIGAke3RoaXMudXJsfS9sb2dvdXQ/c2NvcGU9JHtzY29wZX1gLCB7XG4gICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgIGp3dCxcbiAgICAgICAgICAgICAgICBub1Jlc29sdmVKc29uOiB0cnVlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvcjogbnVsbCB9O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kcyBhbiBpbnZpdGUgbGluayB0byBhbiBlbWFpbCBhZGRyZXNzLlxuICAgICAqIEBwYXJhbSBlbWFpbCBUaGUgZW1haWwgYWRkcmVzcyBvZiB0aGUgdXNlci5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBBZGRpdGlvbmFsIG9wdGlvbnMgdG8gYmUgaW5jbHVkZWQgd2hlbiBpbnZpdGluZy5cbiAgICAgKi9cbiAgICBhc3luYyBpbnZpdGVVc2VyQnlFbWFpbChlbWFpbCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ1BPU1QnLCBgJHt0aGlzLnVybH0vaW52aXRlYCwge1xuICAgICAgICAgICAgICAgIGJvZHk6IHsgZW1haWwsIGRhdGE6IG9wdGlvbnMuZGF0YSB9LFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICByZWRpcmVjdFRvOiBvcHRpb25zLnJlZGlyZWN0VG8sXG4gICAgICAgICAgICAgICAgeGZvcm06IF91c2VyUmVzcG9uc2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwgfSwgZXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBlbWFpbCBsaW5rcyBhbmQgT1RQcyB0byBiZSBzZW50IHZpYSBhIGN1c3RvbSBlbWFpbCBwcm92aWRlci5cbiAgICAgKiBAcGFyYW0gZW1haWwgVGhlIHVzZXIncyBlbWFpbC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5wYXNzd29yZCBVc2VyIHBhc3N3b3JkLiBGb3Igc2lnbnVwIG9ubHkuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuZGF0YSBPcHRpb25hbCB1c2VyIG1ldGFkYXRhLiBGb3Igc2lnbnVwIG9ubHkuXG4gICAgICogQHBhcmFtIG9wdGlvbnMucmVkaXJlY3RUbyBUaGUgcmVkaXJlY3QgdXJsIHdoaWNoIHNob3VsZCBiZSBhcHBlbmRlZCB0byB0aGUgZ2VuZXJhdGVkIGxpbmtcbiAgICAgKi9cbiAgICBhc3luYyBnZW5lcmF0ZUxpbmsocGFyYW1zKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB7IG9wdGlvbnMgfSA9IHBhcmFtcywgcmVzdCA9IF9fcmVzdChwYXJhbXMsIFtcIm9wdGlvbnNcIl0pO1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcmVzdCksIG9wdGlvbnMpO1xuICAgICAgICAgICAgaWYgKCduZXdFbWFpbCcgaW4gcmVzdCkge1xuICAgICAgICAgICAgICAgIC8vIHJlcGxhY2UgbmV3RW1haWwgd2l0aCBuZXdfZW1haWwgaW4gcmVxdWVzdCBib2R5XG4gICAgICAgICAgICAgICAgYm9keS5uZXdfZW1haWwgPSByZXN0ID09PSBudWxsIHx8IHJlc3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlc3QubmV3RW1haWw7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ25ld0VtYWlsJ107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ1BPU1QnLCBgJHt0aGlzLnVybH0vYWRtaW4vZ2VuZXJhdGVfbGlua2AsIHtcbiAgICAgICAgICAgICAgICBib2R5OiBib2R5LFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICB4Zm9ybTogX2dlbmVyYXRlTGlua1Jlc3BvbnNlLFxuICAgICAgICAgICAgICAgIHJlZGlyZWN0VG86IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5yZWRpcmVjdFRvLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllczogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZXI6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBVc2VyIEFkbWluIEFQSVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgdXNlci5cbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBvbiBhIHNlcnZlci4gTmV2ZXIgZXhwb3NlIHlvdXIgYHNlcnZpY2Vfcm9sZWAga2V5IGluIHRoZSBicm93c2VyLlxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZVVzZXIoYXR0cmlidXRlcykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L2FkbWluL3VzZXJzYCwge1xuICAgICAgICAgICAgICAgIGJvZHk6IGF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgIHhmb3JtOiBfdXNlclJlc3BvbnNlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsIH0sIGVycm9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgYSBsaXN0IG9mIHVzZXJzLlxuICAgICAqXG4gICAgICogVGhpcyBmdW5jdGlvbiBzaG91bGQgb25seSBiZSBjYWxsZWQgb24gYSBzZXJ2ZXIuIE5ldmVyIGV4cG9zZSB5b3VyIGBzZXJ2aWNlX3JvbGVgIGtleSBpbiB0aGUgYnJvd3Nlci5cbiAgICAgKiBAcGFyYW0gcGFyYW1zIEFuIG9iamVjdCB3aGljaCBzdXBwb3J0cyBgcGFnZWAgYW5kIGBwZXJQYWdlYCBhcyBudW1iZXJzLCB0byBhbHRlciB0aGUgcGFnaW5hdGVkIHJlc3VsdHMuXG4gICAgICovXG4gICAgYXN5bmMgbGlzdFVzZXJzKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2c7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBwYWdpbmF0aW9uID0geyBuZXh0UGFnZTogbnVsbCwgbGFzdFBhZ2U6IDAsIHRvdGFsOiAwIH07XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdHRVQnLCBgJHt0aGlzLnVybH0vYWRtaW4vdXNlcnNgLCB7XG4gICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgIG5vUmVzb2x2ZUpzb246IHRydWUsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHtcbiAgICAgICAgICAgICAgICAgICAgcGFnZTogKF9iID0gKF9hID0gcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLnBhZ2UpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50b1N0cmluZygpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAnJyxcbiAgICAgICAgICAgICAgICAgICAgcGVyX3BhZ2U6IChfZCA9IChfYyA9IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5wZXJQYWdlKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MudG9TdHJpbmcoKSkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogJycsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB4Zm9ybTogX25vUmVzb2x2ZUpzb25SZXNwb25zZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlLmVycm9yKVxuICAgICAgICAgICAgICAgIHRocm93IHJlc3BvbnNlLmVycm9yO1xuICAgICAgICAgICAgY29uc3QgdXNlcnMgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICBjb25zdCB0b3RhbCA9IChfZSA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCd4LXRvdGFsLWNvdW50JykpICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6IDA7XG4gICAgICAgICAgICBjb25zdCBsaW5rcyA9IChfZyA9IChfZiA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdsaW5rJykpID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi5zcGxpdCgnLCcpKSAhPT0gbnVsbCAmJiBfZyAhPT0gdm9pZCAwID8gX2cgOiBbXTtcbiAgICAgICAgICAgIGlmIChsaW5rcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgbGlua3MuZm9yRWFjaCgobGluaykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYWdlID0gcGFyc2VJbnQobGluay5zcGxpdCgnOycpWzBdLnNwbGl0KCc9JylbMV0uc3Vic3RyaW5nKDAsIDEpKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVsID0gSlNPTi5wYXJzZShsaW5rLnNwbGl0KCc7JylbMV0uc3BsaXQoJz0nKVsxXSk7XG4gICAgICAgICAgICAgICAgICAgIHBhZ2luYXRpb25bYCR7cmVsfVBhZ2VgXSA9IHBhZ2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcGFnaW5hdGlvbi50b3RhbCA9IHBhcnNlSW50KHRvdGFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdXNlcnMpLCBwYWdpbmF0aW9uKSwgZXJyb3I6IG51bGwgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXJzOiBbXSB9LCBlcnJvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHVzZXIgYnkgaWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdWlkIFRoZSB1c2VyJ3MgdW5pcXVlIGlkZW50aWZpZXJcbiAgICAgKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gc2hvdWxkIG9ubHkgYmUgY2FsbGVkIG9uIGEgc2VydmVyLiBOZXZlciBleHBvc2UgeW91ciBgc2VydmljZV9yb2xlYCBrZXkgaW4gdGhlIGJyb3dzZXIuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0VXNlckJ5SWQodWlkKSB7XG4gICAgICAgIHZhbGlkYXRlVVVJRCh1aWQpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdHRVQnLCBgJHt0aGlzLnVybH0vYWRtaW4vdXNlcnMvJHt1aWR9YCwge1xuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICB4Zm9ybTogX3VzZXJSZXNwb25zZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogbnVsbCB9LCBlcnJvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgdXNlciBkYXRhLlxuICAgICAqXG4gICAgICogQHBhcmFtIGF0dHJpYnV0ZXMgVGhlIGRhdGEgeW91IHdhbnQgdG8gdXBkYXRlLlxuICAgICAqXG4gICAgICogVGhpcyBmdW5jdGlvbiBzaG91bGQgb25seSBiZSBjYWxsZWQgb24gYSBzZXJ2ZXIuIE5ldmVyIGV4cG9zZSB5b3VyIGBzZXJ2aWNlX3JvbGVgIGtleSBpbiB0aGUgYnJvd3Nlci5cbiAgICAgKi9cbiAgICBhc3luYyB1cGRhdGVVc2VyQnlJZCh1aWQsIGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgdmFsaWRhdGVVVUlEKHVpZCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ1BVVCcsIGAke3RoaXMudXJsfS9hZG1pbi91c2Vycy8ke3VpZH1gLCB7XG4gICAgICAgICAgICAgICAgYm9keTogYXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgeGZvcm06IF91c2VyUmVzcG9uc2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwgfSwgZXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZSBhIHVzZXIuIFJlcXVpcmVzIGEgYHNlcnZpY2Vfcm9sZWAga2V5LlxuICAgICAqXG4gICAgICogQHBhcmFtIGlkIFRoZSB1c2VyIGlkIHlvdSB3YW50IHRvIHJlbW92ZS5cbiAgICAgKiBAcGFyYW0gc2hvdWxkU29mdERlbGV0ZSBJZiB0cnVlLCB0aGVuIHRoZSB1c2VyIHdpbGwgYmUgc29mdC1kZWxldGVkIGZyb20gdGhlIGF1dGggc2NoZW1hLiBTb2Z0IGRlbGV0aW9uIGFsbG93cyB1c2VyIGlkZW50aWZpY2F0aW9uIGZyb20gdGhlIGhhc2hlZCB1c2VyIElEIGJ1dCBpcyBub3QgcmV2ZXJzaWJsZS5cbiAgICAgKiBEZWZhdWx0cyB0byBmYWxzZSBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eS5cbiAgICAgKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gc2hvdWxkIG9ubHkgYmUgY2FsbGVkIG9uIGEgc2VydmVyLiBOZXZlciBleHBvc2UgeW91ciBgc2VydmljZV9yb2xlYCBrZXkgaW4gdGhlIGJyb3dzZXIuXG4gICAgICovXG4gICAgYXN5bmMgZGVsZXRlVXNlcihpZCwgc2hvdWxkU29mdERlbGV0ZSA9IGZhbHNlKSB7XG4gICAgICAgIHZhbGlkYXRlVVVJRChpZCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ0RFTEVURScsIGAke3RoaXMudXJsfS9hZG1pbi91c2Vycy8ke2lkfWAsIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgYm9keToge1xuICAgICAgICAgICAgICAgICAgICBzaG91bGRfc29mdF9kZWxldGU6IHNob3VsZFNvZnREZWxldGUsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB4Zm9ybTogX3VzZXJSZXNwb25zZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogbnVsbCB9LCBlcnJvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgX2xpc3RGYWN0b3JzKHBhcmFtcykge1xuICAgICAgICB2YWxpZGF0ZVVVSUQocGFyYW1zLnVzZXJJZCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnR0VUJywgYCR7dGhpcy51cmx9L2FkbWluL3VzZXJzLyR7cGFyYW1zLnVzZXJJZH0vZmFjdG9yc2AsIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgeGZvcm06IChmYWN0b3JzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgZmFjdG9ycyB9LCBlcnJvcjogbnVsbCB9O1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB7IGRhdGEsIGVycm9yIH07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIF9kZWxldGVGYWN0b3IocGFyYW1zKSB7XG4gICAgICAgIHZhbGlkYXRlVVVJRChwYXJhbXMudXNlcklkKTtcbiAgICAgICAgdmFsaWRhdGVVVUlEKHBhcmFtcy5pZCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ0RFTEVURScsIGAke3RoaXMudXJsfS9hZG1pbi91c2Vycy8ke3BhcmFtcy51c2VySWR9L2ZhY3RvcnMvJHtwYXJhbXMuaWR9YCwge1xuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHsgZGF0YSwgZXJyb3I6IG51bGwgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogTGlzdHMgYWxsIE9BdXRoIGNsaWVudHMgd2l0aCBvcHRpb25hbCBwYWdpbmF0aW9uLlxuICAgICAqIE9ubHkgcmVsZXZhbnQgd2hlbiB0aGUgT0F1dGggMi4xIHNlcnZlciBpcyBlbmFibGVkIGluIFN1cGFiYXNlIEF1dGguXG4gICAgICpcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBvbiBhIHNlcnZlci4gTmV2ZXIgZXhwb3NlIHlvdXIgYHNlcnZpY2Vfcm9sZWAga2V5IGluIHRoZSBicm93c2VyLlxuICAgICAqL1xuICAgIGFzeW5jIF9saXN0T0F1dGhDbGllbnRzKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2c7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBwYWdpbmF0aW9uID0geyBuZXh0UGFnZTogbnVsbCwgbGFzdFBhZ2U6IDAsIHRvdGFsOiAwIH07XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdHRVQnLCBgJHt0aGlzLnVybH0vYWRtaW4vb2F1dGgvY2xpZW50c2AsIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgbm9SZXNvbHZlSnNvbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBxdWVyeToge1xuICAgICAgICAgICAgICAgICAgICBwYWdlOiAoX2IgPSAoX2EgPSBwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMucGFnZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnRvU3RyaW5nKCkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICcnLFxuICAgICAgICAgICAgICAgICAgICBwZXJfcGFnZTogKF9kID0gKF9jID0gcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLnBlclBhZ2UpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy50b1N0cmluZygpKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiAnJyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHhmb3JtOiBfbm9SZXNvbHZlSnNvblJlc3BvbnNlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2UuZXJyb3IpXG4gICAgICAgICAgICAgICAgdGhyb3cgcmVzcG9uc2UuZXJyb3I7XG4gICAgICAgICAgICBjb25zdCBjbGllbnRzID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgY29uc3QgdG90YWwgPSAoX2UgPSByZXNwb25zZS5oZWFkZXJzLmdldCgneC10b3RhbC1jb3VudCcpKSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiAwO1xuICAgICAgICAgICAgY29uc3QgbGlua3MgPSAoX2cgPSAoX2YgPSByZXNwb25zZS5oZWFkZXJzLmdldCgnbGluaycpKSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Yuc3BsaXQoJywnKSkgIT09IG51bGwgJiYgX2cgIT09IHZvaWQgMCA/IF9nIDogW107XG4gICAgICAgICAgICBpZiAobGlua3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGxpbmtzLmZvckVhY2goKGxpbmspID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFnZSA9IHBhcnNlSW50KGxpbmsuc3BsaXQoJzsnKVswXS5zcGxpdCgnPScpWzFdLnN1YnN0cmluZygwLCAxKSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlbCA9IEpTT04ucGFyc2UobGluay5zcGxpdCgnOycpWzFdLnNwbGl0KCc9JylbMV0pO1xuICAgICAgICAgICAgICAgICAgICBwYWdpbmF0aW9uW2Ake3JlbH1QYWdlYF0gPSBwYWdlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHBhZ2luYXRpb24udG90YWwgPSBwYXJzZUludCh0b3RhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBkYXRhOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGNsaWVudHMpLCBwYWdpbmF0aW9uKSwgZXJyb3I6IG51bGwgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IGNsaWVudHM6IFtdIH0sIGVycm9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IE9BdXRoIGNsaWVudC5cbiAgICAgKiBPbmx5IHJlbGV2YW50IHdoZW4gdGhlIE9BdXRoIDIuMSBzZXJ2ZXIgaXMgZW5hYmxlZCBpbiBTdXBhYmFzZSBBdXRoLlxuICAgICAqXG4gICAgICogVGhpcyBmdW5jdGlvbiBzaG91bGQgb25seSBiZSBjYWxsZWQgb24gYSBzZXJ2ZXIuIE5ldmVyIGV4cG9zZSB5b3VyIGBzZXJ2aWNlX3JvbGVgIGtleSBpbiB0aGUgYnJvd3Nlci5cbiAgICAgKi9cbiAgICBhc3luYyBfY3JlYXRlT0F1dGhDbGllbnQocGFyYW1zKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ1BPU1QnLCBgJHt0aGlzLnVybH0vYWRtaW4vb2F1dGgvY2xpZW50c2AsIHtcbiAgICAgICAgICAgICAgICBib2R5OiBwYXJhbXMsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgIHhmb3JtOiAoY2xpZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IGNsaWVudCwgZXJyb3I6IG51bGwgfTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgZGV0YWlscyBvZiBhIHNwZWNpZmljIE9BdXRoIGNsaWVudC5cbiAgICAgKiBPbmx5IHJlbGV2YW50IHdoZW4gdGhlIE9BdXRoIDIuMSBzZXJ2ZXIgaXMgZW5hYmxlZCBpbiBTdXBhYmFzZSBBdXRoLlxuICAgICAqXG4gICAgICogVGhpcyBmdW5jdGlvbiBzaG91bGQgb25seSBiZSBjYWxsZWQgb24gYSBzZXJ2ZXIuIE5ldmVyIGV4cG9zZSB5b3VyIGBzZXJ2aWNlX3JvbGVgIGtleSBpbiB0aGUgYnJvd3Nlci5cbiAgICAgKi9cbiAgICBhc3luYyBfZ2V0T0F1dGhDbGllbnQoY2xpZW50SWQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnR0VUJywgYCR7dGhpcy51cmx9L2FkbWluL29hdXRoL2NsaWVudHMvJHtjbGllbnRJZH1gLCB7XG4gICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgIHhmb3JtOiAoY2xpZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IGNsaWVudCwgZXJyb3I6IG51bGwgfTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZXMgYW4gT0F1dGggY2xpZW50LlxuICAgICAqIE9ubHkgcmVsZXZhbnQgd2hlbiB0aGUgT0F1dGggMi4xIHNlcnZlciBpcyBlbmFibGVkIGluIFN1cGFiYXNlIEF1dGguXG4gICAgICpcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBvbiBhIHNlcnZlci4gTmV2ZXIgZXhwb3NlIHlvdXIgYHNlcnZpY2Vfcm9sZWAga2V5IGluIHRoZSBicm93c2VyLlxuICAgICAqL1xuICAgIGFzeW5jIF9kZWxldGVPQXV0aENsaWVudChjbGllbnRJZCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdERUxFVEUnLCBgJHt0aGlzLnVybH0vYWRtaW4vb2F1dGgvY2xpZW50cy8ke2NsaWVudElkfWAsIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgeGZvcm06IChjbGllbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogY2xpZW50LCBlcnJvcjogbnVsbCB9O1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVnZW5lcmF0ZXMgdGhlIHNlY3JldCBmb3IgYW4gT0F1dGggY2xpZW50LlxuICAgICAqIE9ubHkgcmVsZXZhbnQgd2hlbiB0aGUgT0F1dGggMi4xIHNlcnZlciBpcyBlbmFibGVkIGluIFN1cGFiYXNlIEF1dGguXG4gICAgICpcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBvbiBhIHNlcnZlci4gTmV2ZXIgZXhwb3NlIHlvdXIgYHNlcnZpY2Vfcm9sZWAga2V5IGluIHRoZSBicm93c2VyLlxuICAgICAqL1xuICAgIGFzeW5jIF9yZWdlbmVyYXRlT0F1dGhDbGllbnRTZWNyZXQoY2xpZW50SWQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnUE9TVCcsIGAke3RoaXMudXJsfS9hZG1pbi9vYXV0aC9jbGllbnRzLyR7Y2xpZW50SWR9L3JlZ2VuZXJhdGVfc2VjcmV0YCwge1xuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICB4Zm9ybTogKGNsaWVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBjbGllbnQsIGVycm9yOiBudWxsIH07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUdvVHJ1ZUFkbWluQXBpLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/GoTrueAdminApi.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/GoTrueClient.js":
/*!********************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/module/GoTrueClient.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _GoTrueAdminApi__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./GoTrueAdminApi */ \"(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/GoTrueAdminApi.js\");\n/* harmony import */ var _lib_constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/constants */ \"(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/constants.js\");\n/* harmony import */ var _lib_errors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/errors */ \"(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/errors.js\");\n/* harmony import */ var _lib_fetch__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lib/fetch */ \"(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/fetch.js\");\n/* harmony import */ var _lib_helpers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./lib/helpers */ \"(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/helpers.js\");\n/* harmony import */ var _lib_local_storage__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./lib/local-storage */ \"(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/local-storage.js\");\n/* harmony import */ var _lib_locks__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./lib/locks */ \"(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/locks.js\");\n/* harmony import */ var _lib_polyfills__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./lib/polyfills */ \"(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/polyfills.js\");\n/* harmony import */ var _lib_version__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./lib/version */ \"(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/version.js\");\n/* harmony import */ var _lib_base64url__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./lib/base64url */ \"(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/base64url.js\");\n/* harmony import */ var _lib_web3_ethereum__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./lib/web3/ethereum */ \"(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/web3/ethereum.js\");\n/* harmony import */ var _lib_webauthn__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./lib/webauthn */ \"(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/webauthn.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n(0,_lib_polyfills__WEBPACK_IMPORTED_MODULE_7__.polyfillGlobalThis)(); // Make \"globalThis\" available\nconst DEFAULT_OPTIONS = {\n    url: _lib_constants__WEBPACK_IMPORTED_MODULE_1__.GOTRUE_URL,\n    storageKey: _lib_constants__WEBPACK_IMPORTED_MODULE_1__.STORAGE_KEY,\n    autoRefreshToken: true,\n    persistSession: true,\n    detectSessionInUrl: true,\n    headers: _lib_constants__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_HEADERS,\n    flowType: 'implicit',\n    debug: false,\n    hasCustomAuthorizationHeader: false,\n};\nasync function lockNoOp(name, acquireTimeout, fn) {\n    return await fn();\n}\n/**\n * Caches JWKS values for all clients created in the same environment. This is\n * especially useful for shared-memory execution environments such as Vercel's\n * Fluid Compute, AWS Lambda or Supabase's Edge Functions. Regardless of how\n * many clients are created, if they share the same storage key they will use\n * the same JWKS cache, significantly speeding up getClaims() with asymmetric\n * JWTs.\n */\nconst GLOBAL_JWKS = {};\nclass GoTrueClient {\n    /**\n     * The JWKS used for verifying asymmetric JWTs\n     */\n    get jwks() {\n        var _a, _b;\n        return (_b = (_a = GLOBAL_JWKS[this.storageKey]) === null || _a === void 0 ? void 0 : _a.jwks) !== null && _b !== void 0 ? _b : { keys: [] };\n    }\n    set jwks(value) {\n        GLOBAL_JWKS[this.storageKey] = Object.assign(Object.assign({}, GLOBAL_JWKS[this.storageKey]), { jwks: value });\n    }\n    get jwks_cached_at() {\n        var _a, _b;\n        return (_b = (_a = GLOBAL_JWKS[this.storageKey]) === null || _a === void 0 ? void 0 : _a.cachedAt) !== null && _b !== void 0 ? _b : Number.MIN_SAFE_INTEGER;\n    }\n    set jwks_cached_at(value) {\n        GLOBAL_JWKS[this.storageKey] = Object.assign(Object.assign({}, GLOBAL_JWKS[this.storageKey]), { cachedAt: value });\n    }\n    /**\n     * Create a new client for use in the browser.\n     */\n    constructor(options) {\n        var _a, _b;\n        /**\n         * @experimental\n         */\n        this.userStorage = null;\n        this.memoryStorage = null;\n        this.stateChangeEmitters = new Map();\n        this.autoRefreshTicker = null;\n        this.visibilityChangedCallback = null;\n        this.refreshingDeferred = null;\n        /**\n         * Keeps track of the async client initialization.\n         * When null or not yet resolved the auth state is `unknown`\n         * Once resolved the auth state is known and it's safe to call any further client methods.\n         * Keep extra care to never reject or throw uncaught errors\n         */\n        this.initializePromise = null;\n        this.detectSessionInUrl = true;\n        this.hasCustomAuthorizationHeader = false;\n        this.suppressGetSessionWarning = false;\n        this.lockAcquired = false;\n        this.pendingInLock = [];\n        /**\n         * Used to broadcast state change events to other tabs listening.\n         */\n        this.broadcastChannel = null;\n        this.logger = console.log;\n        this.instanceID = GoTrueClient.nextInstanceID;\n        GoTrueClient.nextInstanceID += 1;\n        if (this.instanceID > 0 && (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.isBrowser)()) {\n            console.warn('Multiple GoTrueClient instances detected in the same browser context. It is not an error, but this should be avoided as it may produce undefined behavior when used concurrently under the same storage key.');\n        }\n        const settings = Object.assign(Object.assign({}, DEFAULT_OPTIONS), options);\n        this.logDebugMessages = !!settings.debug;\n        if (typeof settings.debug === 'function') {\n            this.logger = settings.debug;\n        }\n        this.persistSession = settings.persistSession;\n        this.storageKey = settings.storageKey;\n        this.autoRefreshToken = settings.autoRefreshToken;\n        this.admin = new _GoTrueAdminApi__WEBPACK_IMPORTED_MODULE_0__[\"default\"]({\n            url: settings.url,\n            headers: settings.headers,\n            fetch: settings.fetch,\n        });\n        this.url = settings.url;\n        this.headers = settings.headers;\n        this.fetch = (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.resolveFetch)(settings.fetch);\n        this.lock = settings.lock || lockNoOp;\n        this.detectSessionInUrl = settings.detectSessionInUrl;\n        this.flowType = settings.flowType;\n        this.hasCustomAuthorizationHeader = settings.hasCustomAuthorizationHeader;\n        if (settings.lock) {\n            this.lock = settings.lock;\n        }\n        else if ((0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.isBrowser)() && ((_a = globalThis === null || globalThis === void 0 ? void 0 : globalThis.navigator) === null || _a === void 0 ? void 0 : _a.locks)) {\n            this.lock = _lib_locks__WEBPACK_IMPORTED_MODULE_6__.navigatorLock;\n        }\n        else {\n            this.lock = lockNoOp;\n        }\n        if (!this.jwks) {\n            this.jwks = { keys: [] };\n            this.jwks_cached_at = Number.MIN_SAFE_INTEGER;\n        }\n        this.mfa = {\n            verify: this._verify.bind(this),\n            enroll: this._enroll.bind(this),\n            unenroll: this._unenroll.bind(this),\n            challenge: this._challenge.bind(this),\n            listFactors: this._listFactors.bind(this),\n            challengeAndVerify: this._challengeAndVerify.bind(this),\n            getAuthenticatorAssuranceLevel: this._getAuthenticatorAssuranceLevel.bind(this),\n            webauthn: new _lib_webauthn__WEBPACK_IMPORTED_MODULE_11__.WebAuthnApi(this),\n        };\n        if (this.persistSession) {\n            if (settings.storage) {\n                this.storage = settings.storage;\n            }\n            else {\n                if ((0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.supportsLocalStorage)()) {\n                    this.storage = globalThis.localStorage;\n                }\n                else {\n                    this.memoryStorage = {};\n                    this.storage = (0,_lib_local_storage__WEBPACK_IMPORTED_MODULE_5__.memoryLocalStorageAdapter)(this.memoryStorage);\n                }\n            }\n            if (settings.userStorage) {\n                this.userStorage = settings.userStorage;\n            }\n        }\n        else {\n            this.memoryStorage = {};\n            this.storage = (0,_lib_local_storage__WEBPACK_IMPORTED_MODULE_5__.memoryLocalStorageAdapter)(this.memoryStorage);\n        }\n        if ((0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.isBrowser)() && globalThis.BroadcastChannel && this.persistSession && this.storageKey) {\n            try {\n                this.broadcastChannel = new globalThis.BroadcastChannel(this.storageKey);\n            }\n            catch (e) {\n                console.error('Failed to create a new BroadcastChannel, multi-tab state changes will not be available', e);\n            }\n            (_b = this.broadcastChannel) === null || _b === void 0 ? void 0 : _b.addEventListener('message', async (event) => {\n                this._debug('received broadcast notification from other tab or client', event);\n                await this._notifyAllSubscribers(event.data.event, event.data.session, false); // broadcast = false so we don't get an endless loop of messages\n            });\n        }\n        this.initialize();\n    }\n    _debug(...args) {\n        if (this.logDebugMessages) {\n            this.logger(`GoTrueClient@${this.instanceID} (${_lib_version__WEBPACK_IMPORTED_MODULE_8__.version}) ${new Date().toISOString()}`, ...args);\n        }\n        return this;\n    }\n    /**\n     * Initializes the client session either from the url or from storage.\n     * This method is automatically called when instantiating the client, but should also be called\n     * manually when checking for an error from an auth redirect (oauth, magiclink, password recovery, etc).\n     */\n    async initialize() {\n        if (this.initializePromise) {\n            return await this.initializePromise;\n        }\n        this.initializePromise = (async () => {\n            return await this._acquireLock(-1, async () => {\n                return await this._initialize();\n            });\n        })();\n        return await this.initializePromise;\n    }\n    /**\n     * IMPORTANT:\n     * 1. Never throw in this method, as it is called from the constructor\n     * 2. Never return a session from this method as it would be cached over\n     *    the whole lifetime of the client\n     */\n    async _initialize() {\n        var _a;\n        try {\n            const params = (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.parseParametersFromURL)(window.location.href);\n            let callbackUrlType = 'none';\n            if (this._isImplicitGrantCallback(params)) {\n                callbackUrlType = 'implicit';\n            }\n            else if (await this._isPKCECallback(params)) {\n                callbackUrlType = 'pkce';\n            }\n            /**\n             * Attempt to get the session from the URL only if these conditions are fulfilled\n             *\n             * Note: If the URL isn't one of the callback url types (implicit or pkce),\n             * then there could be an existing session so we don't want to prematurely remove it\n             */\n            if ((0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.isBrowser)() && this.detectSessionInUrl && callbackUrlType !== 'none') {\n                const { data, error } = await this._getSessionFromURL(params, callbackUrlType);\n                if (error) {\n                    this._debug('#_initialize()', 'error detecting session from URL', error);\n                    if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthImplicitGrantRedirectError)(error)) {\n                        const errorCode = (_a = error.details) === null || _a === void 0 ? void 0 : _a.code;\n                        if (errorCode === 'identity_already_exists' ||\n                            errorCode === 'identity_not_found' ||\n                            errorCode === 'single_identity_not_deletable') {\n                            return { error };\n                        }\n                    }\n                    // failed login attempt via url,\n                    // remove old session as in verifyOtp, signUp and signInWith*\n                    await this._removeSession();\n                    return { error };\n                }\n                const { session, redirectType } = data;\n                this._debug('#_initialize()', 'detected session in URL', session, 'redirect type', redirectType);\n                await this._saveSession(session);\n                setTimeout(async () => {\n                    if (redirectType === 'recovery') {\n                        await this._notifyAllSubscribers('PASSWORD_RECOVERY', session);\n                    }\n                    else {\n                        await this._notifyAllSubscribers('SIGNED_IN', session);\n                    }\n                }, 0);\n                return { error: null };\n            }\n            // no login attempt via callback url try to recover session from storage\n            await this._recoverAndRefresh();\n            return { error: null };\n        }\n        catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return { error };\n            }\n            return {\n                error: new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthUnknownError('Unexpected error during initialization', error),\n            };\n        }\n        finally {\n            await this._handleVisibilityChange();\n            this._debug('#_initialize()', 'end');\n        }\n    }\n    /**\n     * Creates a new anonymous user.\n     *\n     * @returns A session where the is_anonymous claim in the access token JWT set to true\n     */\n    async signInAnonymously(credentials) {\n        var _a, _b, _c;\n        try {\n            const res = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, 'POST', `${this.url}/signup`, {\n                headers: this.headers,\n                body: {\n                    data: (_b = (_a = credentials === null || credentials === void 0 ? void 0 : credentials.options) === null || _a === void 0 ? void 0 : _a.data) !== null && _b !== void 0 ? _b : {},\n                    gotrue_meta_security: { captcha_token: (_c = credentials === null || credentials === void 0 ? void 0 : credentials.options) === null || _c === void 0 ? void 0 : _c.captchaToken },\n                },\n                xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._sessionResponse,\n            });\n            const { data, error } = res;\n            if (error || !data) {\n                return { data: { user: null, session: null }, error: error };\n            }\n            const session = data.session;\n            const user = data.user;\n            if (data.session) {\n                await this._saveSession(data.session);\n                await this._notifyAllSubscribers('SIGNED_IN', session);\n            }\n            return { data: { user, session }, error: null };\n        }\n        catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return { data: { user: null, session: null }, error };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Creates a new user.\n     *\n     * Be aware that if a user account exists in the system you may get back an\n     * error message that attempts to hide this information from the user.\n     * This method has support for PKCE via email signups. The PKCE flow cannot be used when autoconfirm is enabled.\n     *\n     * @returns A logged-in session if the server has \"autoconfirm\" ON\n     * @returns A user if the server has \"autoconfirm\" OFF\n     */\n    async signUp(credentials) {\n        var _a, _b, _c;\n        try {\n            let res;\n            if ('email' in credentials) {\n                const { email, password, options } = credentials;\n                let codeChallenge = null;\n                let codeChallengeMethod = null;\n                if (this.flowType === 'pkce') {\n                    ;\n                    [codeChallenge, codeChallengeMethod] = await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.getCodeChallengeAndMethod)(this.storage, this.storageKey);\n                }\n                res = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, 'POST', `${this.url}/signup`, {\n                    headers: this.headers,\n                    redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo,\n                    body: {\n                        email,\n                        password,\n                        data: (_a = options === null || options === void 0 ? void 0 : options.data) !== null && _a !== void 0 ? _a : {},\n                        gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken },\n                        code_challenge: codeChallenge,\n                        code_challenge_method: codeChallengeMethod,\n                    },\n                    xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._sessionResponse,\n                });\n            }\n            else if ('phone' in credentials) {\n                const { phone, password, options } = credentials;\n                res = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, 'POST', `${this.url}/signup`, {\n                    headers: this.headers,\n                    body: {\n                        phone,\n                        password,\n                        data: (_b = options === null || options === void 0 ? void 0 : options.data) !== null && _b !== void 0 ? _b : {},\n                        channel: (_c = options === null || options === void 0 ? void 0 : options.channel) !== null && _c !== void 0 ? _c : 'sms',\n                        gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken },\n                    },\n                    xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._sessionResponse,\n                });\n            }\n            else {\n                throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthInvalidCredentialsError('You must provide either an email or phone number and a password');\n            }\n            const { data, error } = res;\n            if (error || !data) {\n                return { data: { user: null, session: null }, error: error };\n            }\n            const session = data.session;\n            const user = data.user;\n            if (data.session) {\n                await this._saveSession(data.session);\n                await this._notifyAllSubscribers('SIGNED_IN', session);\n            }\n            return { data: { user, session }, error: null };\n        }\n        catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return { data: { user: null, session: null }, error };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Log in an existing user with an email and password or phone and password.\n     *\n     * Be aware that you may get back an error message that will not distinguish\n     * between the cases where the account does not exist or that the\n     * email/phone and password combination is wrong or that the account can only\n     * be accessed via social login.\n     */\n    async signInWithPassword(credentials) {\n        try {\n            let res;\n            if ('email' in credentials) {\n                const { email, password, options } = credentials;\n                res = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, 'POST', `${this.url}/token?grant_type=password`, {\n                    headers: this.headers,\n                    body: {\n                        email,\n                        password,\n                        gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken },\n                    },\n                    xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._sessionResponsePassword,\n                });\n            }\n            else if ('phone' in credentials) {\n                const { phone, password, options } = credentials;\n                res = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, 'POST', `${this.url}/token?grant_type=password`, {\n                    headers: this.headers,\n                    body: {\n                        phone,\n                        password,\n                        gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken },\n                    },\n                    xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._sessionResponsePassword,\n                });\n            }\n            else {\n                throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthInvalidCredentialsError('You must provide either an email or phone number and a password');\n            }\n            const { data, error } = res;\n            if (error) {\n                return { data: { user: null, session: null }, error };\n            }\n            else if (!data || !data.session || !data.user) {\n                return { data: { user: null, session: null }, error: new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthInvalidTokenResponseError() };\n            }\n            if (data.session) {\n                await this._saveSession(data.session);\n                await this._notifyAllSubscribers('SIGNED_IN', data.session);\n            }\n            return {\n                data: Object.assign({ user: data.user, session: data.session }, (data.weak_password ? { weakPassword: data.weak_password } : null)),\n                error,\n            };\n        }\n        catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return { data: { user: null, session: null }, error };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Log in an existing user via a third-party provider.\n     * This method supports the PKCE flow.\n     */\n    async signInWithOAuth(credentials) {\n        var _a, _b, _c, _d;\n        return await this._handleProviderSignIn(credentials.provider, {\n            redirectTo: (_a = credentials.options) === null || _a === void 0 ? void 0 : _a.redirectTo,\n            scopes: (_b = credentials.options) === null || _b === void 0 ? void 0 : _b.scopes,\n            queryParams: (_c = credentials.options) === null || _c === void 0 ? void 0 : _c.queryParams,\n            skipBrowserRedirect: (_d = credentials.options) === null || _d === void 0 ? void 0 : _d.skipBrowserRedirect,\n        });\n    }\n    /**\n     * Log in an existing user by exchanging an Auth Code issued during the PKCE flow.\n     */\n    async exchangeCodeForSession(authCode) {\n        await this.initializePromise;\n        return this._acquireLock(-1, async () => {\n            return this._exchangeCodeForSession(authCode);\n        });\n    }\n    /**\n     * Signs in a user by verifying a message signed by the user's private key.\n     * Supports Ethereum (via Sign-In-With-Ethereum) & Solana (Sign-In-With-Solana) standards,\n     * both of which derive from the EIP-4361 standard\n     * With slight variation on Solana's side.\n     * @reference https://eips.ethereum.org/EIPS/eip-4361\n     */\n    async signInWithWeb3(credentials) {\n        const { chain } = credentials;\n        switch (chain) {\n            case 'ethereum':\n                return await this.signInWithEthereum(credentials);\n            case 'solana':\n                return await this.signInWithSolana(credentials);\n            default:\n                throw new Error(`@supabase/auth-js: Unsupported chain \"${chain}\"`);\n        }\n    }\n    async signInWithEthereum(credentials) {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;\n        // TODO: flatten type\n        let message;\n        let signature;\n        if ('message' in credentials) {\n            message = credentials.message;\n            signature = credentials.signature;\n        }\n        else {\n            const { chain, wallet, statement, options } = credentials;\n            let resolvedWallet;\n            if (!(0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.isBrowser)()) {\n                if (typeof wallet !== 'object' || !(options === null || options === void 0 ? void 0 : options.url)) {\n                    throw new Error('@supabase/auth-js: Both wallet and url must be specified in non-browser environments.');\n                }\n                resolvedWallet = wallet;\n            }\n            else if (typeof wallet === 'object') {\n                resolvedWallet = wallet;\n            }\n            else {\n                const windowAny = window;\n                if ('ethereum' in windowAny &&\n                    typeof windowAny.ethereum === 'object' &&\n                    'request' in windowAny.ethereum &&\n                    typeof windowAny.ethereum.request === 'function') {\n                    resolvedWallet = windowAny.ethereum;\n                }\n                else {\n                    throw new Error(`@supabase/auth-js: No compatible Ethereum wallet interface on the window object (window.ethereum) detected. Make sure the user already has a wallet installed and connected for this app. Prefer passing the wallet interface object directly to signInWithWeb3({ chain: 'ethereum', wallet: resolvedUserWallet }) instead.`);\n                }\n            }\n            const url = new URL((_a = options === null || options === void 0 ? void 0 : options.url) !== null && _a !== void 0 ? _a : window.location.href);\n            const accounts = await resolvedWallet\n                .request({\n                method: 'eth_requestAccounts',\n            })\n                .then((accs) => accs)\n                .catch(() => {\n                throw new Error(`@supabase/auth-js: Wallet method eth_requestAccounts is missing or invalid`);\n            });\n            if (!accounts || accounts.length === 0) {\n                throw new Error(`@supabase/auth-js: No accounts available. Please ensure the wallet is connected.`);\n            }\n            const address = (0,_lib_web3_ethereum__WEBPACK_IMPORTED_MODULE_10__.getAddress)(accounts[0]);\n            let chainId = (_b = options === null || options === void 0 ? void 0 : options.signInWithEthereum) === null || _b === void 0 ? void 0 : _b.chainId;\n            if (!chainId) {\n                const chainIdHex = await resolvedWallet.request({\n                    method: 'eth_chainId',\n                });\n                chainId = (0,_lib_web3_ethereum__WEBPACK_IMPORTED_MODULE_10__.fromHex)(chainIdHex);\n            }\n            const siweMessage = {\n                domain: url.host,\n                address: address,\n                statement: statement,\n                uri: url.href,\n                version: '1',\n                chainId: chainId,\n                nonce: (_c = options === null || options === void 0 ? void 0 : options.signInWithEthereum) === null || _c === void 0 ? void 0 : _c.nonce,\n                issuedAt: (_e = (_d = options === null || options === void 0 ? void 0 : options.signInWithEthereum) === null || _d === void 0 ? void 0 : _d.issuedAt) !== null && _e !== void 0 ? _e : new Date(),\n                expirationTime: (_f = options === null || options === void 0 ? void 0 : options.signInWithEthereum) === null || _f === void 0 ? void 0 : _f.expirationTime,\n                notBefore: (_g = options === null || options === void 0 ? void 0 : options.signInWithEthereum) === null || _g === void 0 ? void 0 : _g.notBefore,\n                requestId: (_h = options === null || options === void 0 ? void 0 : options.signInWithEthereum) === null || _h === void 0 ? void 0 : _h.requestId,\n                resources: (_j = options === null || options === void 0 ? void 0 : options.signInWithEthereum) === null || _j === void 0 ? void 0 : _j.resources,\n            };\n            message = (0,_lib_web3_ethereum__WEBPACK_IMPORTED_MODULE_10__.createSiweMessage)(siweMessage);\n            // Sign message\n            signature = (await resolvedWallet.request({\n                method: 'personal_sign',\n                params: [(0,_lib_web3_ethereum__WEBPACK_IMPORTED_MODULE_10__.toHex)(message), address],\n            }));\n        }\n        try {\n            const { data, error } = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, 'POST', `${this.url}/token?grant_type=web3`, {\n                headers: this.headers,\n                body: Object.assign({ chain: 'ethereum', message,\n                    signature }, (((_k = credentials.options) === null || _k === void 0 ? void 0 : _k.captchaToken)\n                    ? { gotrue_meta_security: { captcha_token: (_l = credentials.options) === null || _l === void 0 ? void 0 : _l.captchaToken } }\n                    : null)),\n                xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._sessionResponse,\n            });\n            if (error) {\n                throw error;\n            }\n            if (!data || !data.session || !data.user) {\n                return {\n                    data: { user: null, session: null },\n                    error: new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthInvalidTokenResponseError(),\n                };\n            }\n            if (data.session) {\n                await this._saveSession(data.session);\n                await this._notifyAllSubscribers('SIGNED_IN', data.session);\n            }\n            return { data: Object.assign({}, data), error };\n        }\n        catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return { data: { user: null, session: null }, error };\n            }\n            throw error;\n        }\n    }\n    async signInWithSolana(credentials) {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;\n        let message;\n        let signature;\n        if ('message' in credentials) {\n            message = credentials.message;\n            signature = credentials.signature;\n        }\n        else {\n            const { chain, wallet, statement, options } = credentials;\n            let resolvedWallet;\n            if (!(0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.isBrowser)()) {\n                if (typeof wallet !== 'object' || !(options === null || options === void 0 ? void 0 : options.url)) {\n                    throw new Error('@supabase/auth-js: Both wallet and url must be specified in non-browser environments.');\n                }\n                resolvedWallet = wallet;\n            }\n            else if (typeof wallet === 'object') {\n                resolvedWallet = wallet;\n            }\n            else {\n                const windowAny = window;\n                if ('solana' in windowAny &&\n                    typeof windowAny.solana === 'object' &&\n                    (('signIn' in windowAny.solana && typeof windowAny.solana.signIn === 'function') ||\n                        ('signMessage' in windowAny.solana &&\n                            typeof windowAny.solana.signMessage === 'function'))) {\n                    resolvedWallet = windowAny.solana;\n                }\n                else {\n                    throw new Error(`@supabase/auth-js: No compatible Solana wallet interface on the window object (window.solana) detected. Make sure the user already has a wallet installed and connected for this app. Prefer passing the wallet interface object directly to signInWithWeb3({ chain: 'solana', wallet: resolvedUserWallet }) instead.`);\n                }\n            }\n            const url = new URL((_a = options === null || options === void 0 ? void 0 : options.url) !== null && _a !== void 0 ? _a : window.location.href);\n            if ('signIn' in resolvedWallet && resolvedWallet.signIn) {\n                const output = await resolvedWallet.signIn(Object.assign(Object.assign(Object.assign({ issuedAt: new Date().toISOString() }, options === null || options === void 0 ? void 0 : options.signInWithSolana), { \n                    // non-overridable properties\n                    version: '1', domain: url.host, uri: url.href }), (statement ? { statement } : null)));\n                let outputToProcess;\n                if (Array.isArray(output) && output[0] && typeof output[0] === 'object') {\n                    outputToProcess = output[0];\n                }\n                else if (output &&\n                    typeof output === 'object' &&\n                    'signedMessage' in output &&\n                    'signature' in output) {\n                    outputToProcess = output;\n                }\n                else {\n                    throw new Error('@supabase/auth-js: Wallet method signIn() returned unrecognized value');\n                }\n                if ('signedMessage' in outputToProcess &&\n                    'signature' in outputToProcess &&\n                    (typeof outputToProcess.signedMessage === 'string' ||\n                        outputToProcess.signedMessage instanceof Uint8Array) &&\n                    outputToProcess.signature instanceof Uint8Array) {\n                    message =\n                        typeof outputToProcess.signedMessage === 'string'\n                            ? outputToProcess.signedMessage\n                            : new TextDecoder().decode(outputToProcess.signedMessage);\n                    signature = outputToProcess.signature;\n                }\n                else {\n                    throw new Error('@supabase/auth-js: Wallet method signIn() API returned object without signedMessage and signature fields');\n                }\n            }\n            else {\n                if (!('signMessage' in resolvedWallet) ||\n                    typeof resolvedWallet.signMessage !== 'function' ||\n                    !('publicKey' in resolvedWallet) ||\n                    typeof resolvedWallet !== 'object' ||\n                    !resolvedWallet.publicKey ||\n                    !('toBase58' in resolvedWallet.publicKey) ||\n                    typeof resolvedWallet.publicKey.toBase58 !== 'function') {\n                    throw new Error('@supabase/auth-js: Wallet does not have a compatible signMessage() and publicKey.toBase58() API');\n                }\n                message = [\n                    `${url.host} wants you to sign in with your Solana account:`,\n                    resolvedWallet.publicKey.toBase58(),\n                    ...(statement ? ['', statement, ''] : ['']),\n                    'Version: 1',\n                    `URI: ${url.href}`,\n                    `Issued At: ${(_c = (_b = options === null || options === void 0 ? void 0 : options.signInWithSolana) === null || _b === void 0 ? void 0 : _b.issuedAt) !== null && _c !== void 0 ? _c : new Date().toISOString()}`,\n                    ...(((_d = options === null || options === void 0 ? void 0 : options.signInWithSolana) === null || _d === void 0 ? void 0 : _d.notBefore)\n                        ? [`Not Before: ${options.signInWithSolana.notBefore}`]\n                        : []),\n                    ...(((_e = options === null || options === void 0 ? void 0 : options.signInWithSolana) === null || _e === void 0 ? void 0 : _e.expirationTime)\n                        ? [`Expiration Time: ${options.signInWithSolana.expirationTime}`]\n                        : []),\n                    ...(((_f = options === null || options === void 0 ? void 0 : options.signInWithSolana) === null || _f === void 0 ? void 0 : _f.chainId)\n                        ? [`Chain ID: ${options.signInWithSolana.chainId}`]\n                        : []),\n                    ...(((_g = options === null || options === void 0 ? void 0 : options.signInWithSolana) === null || _g === void 0 ? void 0 : _g.nonce) ? [`Nonce: ${options.signInWithSolana.nonce}`] : []),\n                    ...(((_h = options === null || options === void 0 ? void 0 : options.signInWithSolana) === null || _h === void 0 ? void 0 : _h.requestId)\n                        ? [`Request ID: ${options.signInWithSolana.requestId}`]\n                        : []),\n                    ...(((_k = (_j = options === null || options === void 0 ? void 0 : options.signInWithSolana) === null || _j === void 0 ? void 0 : _j.resources) === null || _k === void 0 ? void 0 : _k.length)\n                        ? [\n                            'Resources',\n                            ...options.signInWithSolana.resources.map((resource) => `- ${resource}`),\n                        ]\n                        : []),\n                ].join('\\n');\n                const maybeSignature = await resolvedWallet.signMessage(new TextEncoder().encode(message), 'utf8');\n                if (!maybeSignature || !(maybeSignature instanceof Uint8Array)) {\n                    throw new Error('@supabase/auth-js: Wallet signMessage() API returned an recognized value');\n                }\n                signature = maybeSignature;\n            }\n        }\n        try {\n            const { data, error } = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, 'POST', `${this.url}/token?grant_type=web3`, {\n                headers: this.headers,\n                body: Object.assign({ chain: 'solana', message, signature: (0,_lib_base64url__WEBPACK_IMPORTED_MODULE_9__.bytesToBase64URL)(signature) }, (((_l = credentials.options) === null || _l === void 0 ? void 0 : _l.captchaToken)\n                    ? { gotrue_meta_security: { captcha_token: (_m = credentials.options) === null || _m === void 0 ? void 0 : _m.captchaToken } }\n                    : null)),\n                xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._sessionResponse,\n            });\n            if (error) {\n                throw error;\n            }\n            if (!data || !data.session || !data.user) {\n                return {\n                    data: { user: null, session: null },\n                    error: new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthInvalidTokenResponseError(),\n                };\n            }\n            if (data.session) {\n                await this._saveSession(data.session);\n                await this._notifyAllSubscribers('SIGNED_IN', data.session);\n            }\n            return { data: Object.assign({}, data), error };\n        }\n        catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return { data: { user: null, session: null }, error };\n            }\n            throw error;\n        }\n    }\n    async _exchangeCodeForSession(authCode) {\n        const storageItem = await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.getItemAsync)(this.storage, `${this.storageKey}-code-verifier`);\n        const [codeVerifier, redirectType] = (storageItem !== null && storageItem !== void 0 ? storageItem : '').split('/');\n        try {\n            const { data, error } = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, 'POST', `${this.url}/token?grant_type=pkce`, {\n                headers: this.headers,\n                body: {\n                    auth_code: authCode,\n                    code_verifier: codeVerifier,\n                },\n                xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._sessionResponse,\n            });\n            await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.removeItemAsync)(this.storage, `${this.storageKey}-code-verifier`);\n            if (error) {\n                throw error;\n            }\n            if (!data || !data.session || !data.user) {\n                return {\n                    data: { user: null, session: null, redirectType: null },\n                    error: new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthInvalidTokenResponseError(),\n                };\n            }\n            if (data.session) {\n                await this._saveSession(data.session);\n                await this._notifyAllSubscribers('SIGNED_IN', data.session);\n            }\n            return { data: Object.assign(Object.assign({}, data), { redirectType: redirectType !== null && redirectType !== void 0 ? redirectType : null }), error };\n        }\n        catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return { data: { user: null, session: null, redirectType: null }, error };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Allows signing in with an OIDC ID token. The authentication provider used\n     * should be enabled and configured.\n     */\n    async signInWithIdToken(credentials) {\n        try {\n            const { options, provider, token, access_token, nonce } = credentials;\n            const res = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, 'POST', `${this.url}/token?grant_type=id_token`, {\n                headers: this.headers,\n                body: {\n                    provider,\n                    id_token: token,\n                    access_token,\n                    nonce,\n                    gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken },\n                },\n                xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._sessionResponse,\n            });\n            const { data, error } = res;\n            if (error) {\n                return { data: { user: null, session: null }, error };\n            }\n            else if (!data || !data.session || !data.user) {\n                return {\n                    data: { user: null, session: null },\n                    error: new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthInvalidTokenResponseError(),\n                };\n            }\n            if (data.session) {\n                await this._saveSession(data.session);\n                await this._notifyAllSubscribers('SIGNED_IN', data.session);\n            }\n            return { data, error };\n        }\n        catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return { data: { user: null, session: null }, error };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Log in a user using magiclink or a one-time password (OTP).\n     *\n     * If the `{{ .ConfirmationURL }}` variable is specified in the email template, a magiclink will be sent.\n     * If the `{{ .Token }}` variable is specified in the email template, an OTP will be sent.\n     * If you're using phone sign-ins, only an OTP will be sent. You won't be able to send a magiclink for phone sign-ins.\n     *\n     * Be aware that you may get back an error message that will not distinguish\n     * between the cases where the account does not exist or, that the account\n     * can only be accessed via social login.\n     *\n     * Do note that you will need to configure a Whatsapp sender on Twilio\n     * if you are using phone sign in with the 'whatsapp' channel. The whatsapp\n     * channel is not supported on other providers\n     * at this time.\n     * This method supports PKCE when an email is passed.\n     */\n    async signInWithOtp(credentials) {\n        var _a, _b, _c, _d, _e;\n        try {\n            if ('email' in credentials) {\n                const { email, options } = credentials;\n                let codeChallenge = null;\n                let codeChallengeMethod = null;\n                if (this.flowType === 'pkce') {\n                    ;\n                    [codeChallenge, codeChallengeMethod] = await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.getCodeChallengeAndMethod)(this.storage, this.storageKey);\n                }\n                const { error } = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, 'POST', `${this.url}/otp`, {\n                    headers: this.headers,\n                    body: {\n                        email,\n                        data: (_a = options === null || options === void 0 ? void 0 : options.data) !== null && _a !== void 0 ? _a : {},\n                        create_user: (_b = options === null || options === void 0 ? void 0 : options.shouldCreateUser) !== null && _b !== void 0 ? _b : true,\n                        gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken },\n                        code_challenge: codeChallenge,\n                        code_challenge_method: codeChallengeMethod,\n                    },\n                    redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo,\n                });\n                return { data: { user: null, session: null }, error };\n            }\n            if ('phone' in credentials) {\n                const { phone, options } = credentials;\n                const { data, error } = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, 'POST', `${this.url}/otp`, {\n                    headers: this.headers,\n                    body: {\n                        phone,\n                        data: (_c = options === null || options === void 0 ? void 0 : options.data) !== null && _c !== void 0 ? _c : {},\n                        create_user: (_d = options === null || options === void 0 ? void 0 : options.shouldCreateUser) !== null && _d !== void 0 ? _d : true,\n                        gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken },\n                        channel: (_e = options === null || options === void 0 ? void 0 : options.channel) !== null && _e !== void 0 ? _e : 'sms',\n                    },\n                });\n                return { data: { user: null, session: null, messageId: data === null || data === void 0 ? void 0 : data.message_id }, error };\n            }\n            throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthInvalidCredentialsError('You must provide either an email or phone number.');\n        }\n        catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return { data: { user: null, session: null }, error };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Log in a user given a User supplied OTP or TokenHash received through mobile or email.\n     */\n    async verifyOtp(params) {\n        var _a, _b;\n        try {\n            let redirectTo = undefined;\n            let captchaToken = undefined;\n            if ('options' in params) {\n                redirectTo = (_a = params.options) === null || _a === void 0 ? void 0 : _a.redirectTo;\n                captchaToken = (_b = params.options) === null || _b === void 0 ? void 0 : _b.captchaToken;\n            }\n            const { data, error } = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, 'POST', `${this.url}/verify`, {\n                headers: this.headers,\n                body: Object.assign(Object.assign({}, params), { gotrue_meta_security: { captcha_token: captchaToken } }),\n                redirectTo,\n                xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._sessionResponse,\n            });\n            if (error) {\n                throw error;\n            }\n            if (!data) {\n                throw new Error('An error occurred on token verification.');\n            }\n            const session = data.session;\n            const user = data.user;\n            if (session === null || session === void 0 ? void 0 : session.access_token) {\n                await this._saveSession(session);\n                await this._notifyAllSubscribers(params.type == 'recovery' ? 'PASSWORD_RECOVERY' : 'SIGNED_IN', session);\n            }\n            return { data: { user, session }, error: null };\n        }\n        catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return { data: { user: null, session: null }, error };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Attempts a single-sign on using an enterprise Identity Provider. A\n     * successful SSO attempt will redirect the current page to the identity\n     * provider authorization page. The redirect URL is implementation and SSO\n     * protocol specific.\n     *\n     * You can use it by providing a SSO domain. Typically you can extract this\n     * domain by asking users for their email address. If this domain is\n     * registered on the Auth instance the redirect will use that organization's\n     * currently active SSO Identity Provider for the login.\n     *\n     * If you have built an organization-specific login page, you can use the\n     * organization's SSO Identity Provider UUID directly instead.\n     */\n    async signInWithSSO(params) {\n        var _a, _b, _c;\n        try {\n            let codeChallenge = null;\n            let codeChallengeMethod = null;\n            if (this.flowType === 'pkce') {\n                ;\n                [codeChallenge, codeChallengeMethod] = await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.getCodeChallengeAndMethod)(this.storage, this.storageKey);\n            }\n            return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, 'POST', `${this.url}/sso`, {\n                body: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, ('providerId' in params ? { provider_id: params.providerId } : null)), ('domain' in params ? { domain: params.domain } : null)), { redirect_to: (_b = (_a = params.options) === null || _a === void 0 ? void 0 : _a.redirectTo) !== null && _b !== void 0 ? _b : undefined }), (((_c = params === null || params === void 0 ? void 0 : params.options) === null || _c === void 0 ? void 0 : _c.captchaToken)\n                    ? { gotrue_meta_security: { captcha_token: params.options.captchaToken } }\n                    : null)), { skip_http_redirect: true, code_challenge: codeChallenge, code_challenge_method: codeChallengeMethod }),\n                headers: this.headers,\n                xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._ssoResponse,\n            });\n        }\n        catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return { data: null, error };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Sends a reauthentication OTP to the user's email or phone number.\n     * Requires the user to be signed-in.\n     */\n    async reauthenticate() {\n        await this.initializePromise;\n        return await this._acquireLock(-1, async () => {\n            return await this._reauthenticate();\n        });\n    }\n    async _reauthenticate() {\n        try {\n            return await this._useSession(async (result) => {\n                const { data: { session }, error: sessionError, } = result;\n                if (sessionError)\n                    throw sessionError;\n                if (!session)\n                    throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthSessionMissingError();\n                const { error } = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, 'GET', `${this.url}/reauthenticate`, {\n                    headers: this.headers,\n                    jwt: session.access_token,\n                });\n                return { data: { user: null, session: null }, error };\n            });\n        }\n        catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return { data: { user: null, session: null }, error };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Resends an existing signup confirmation email, email change email, SMS OTP or phone change OTP.\n     */\n    async resend(credentials) {\n        try {\n            const endpoint = `${this.url}/resend`;\n            if ('email' in credentials) {\n                const { email, type, options } = credentials;\n                const { error } = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, 'POST', endpoint, {\n                    headers: this.headers,\n                    body: {\n                        email,\n                        type,\n                        gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken },\n                    },\n                    redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo,\n                });\n                return { data: { user: null, session: null }, error };\n            }\n            else if ('phone' in credentials) {\n                const { phone, type, options } = credentials;\n                const { data, error } = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, 'POST', endpoint, {\n                    headers: this.headers,\n                    body: {\n                        phone,\n                        type,\n                        gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken },\n                    },\n                });\n                return { data: { user: null, session: null, messageId: data === null || data === void 0 ? void 0 : data.message_id }, error };\n            }\n            throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthInvalidCredentialsError('You must provide either an email or phone number and a type');\n        }\n        catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return { data: { user: null, session: null }, error };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Returns the session, refreshing it if necessary.\n     *\n     * The session returned can be null if the session is not detected which can happen in the event a user is not signed-in or has logged out.\n     *\n     * **IMPORTANT:** This method loads values directly from the storage attached\n     * to the client. If that storage is based on request cookies for example,\n     * the values in it may not be authentic and therefore it's strongly advised\n     * against using this method and its results in such circumstances. A warning\n     * will be emitted if this is detected. Use {@link #getUser()} instead.\n     */\n    async getSession() {\n        await this.initializePromise;\n        const result = await this._acquireLock(-1, async () => {\n            return this._useSession(async (result) => {\n                return result;\n            });\n        });\n        return result;\n    }\n    /**\n     * Acquires a global lock based on the storage key.\n     */\n    async _acquireLock(acquireTimeout, fn) {\n        this._debug('#_acquireLock', 'begin', acquireTimeout);\n        try {\n            if (this.lockAcquired) {\n                const last = this.pendingInLock.length\n                    ? this.pendingInLock[this.pendingInLock.length - 1]\n                    : Promise.resolve();\n                const result = (async () => {\n                    await last;\n                    return await fn();\n                })();\n                this.pendingInLock.push((async () => {\n                    try {\n                        await result;\n                    }\n                    catch (e) {\n                        // we just care if it finished\n                    }\n                })());\n                return result;\n            }\n            return await this.lock(`lock:${this.storageKey}`, acquireTimeout, async () => {\n                this._debug('#_acquireLock', 'lock acquired for storage key', this.storageKey);\n                try {\n                    this.lockAcquired = true;\n                    const result = fn();\n                    this.pendingInLock.push((async () => {\n                        try {\n                            await result;\n                        }\n                        catch (e) {\n                            // we just care if it finished\n                        }\n                    })());\n                    await result;\n                    // keep draining the queue until there's nothing to wait on\n                    while (this.pendingInLock.length) {\n                        const waitOn = [...this.pendingInLock];\n                        await Promise.all(waitOn);\n                        this.pendingInLock.splice(0, waitOn.length);\n                    }\n                    return await result;\n                }\n                finally {\n                    this._debug('#_acquireLock', 'lock released for storage key', this.storageKey);\n                    this.lockAcquired = false;\n                }\n            });\n        }\n        finally {\n            this._debug('#_acquireLock', 'end');\n        }\n    }\n    /**\n     * Use instead of {@link #getSession} inside the library. It is\n     * semantically usually what you want, as getting a session involves some\n     * processing afterwards that requires only one client operating on the\n     * session at once across multiple tabs or processes.\n     */\n    async _useSession(fn) {\n        this._debug('#_useSession', 'begin');\n        try {\n            // the use of __loadSession here is the only correct use of the function!\n            const result = await this.__loadSession();\n            return await fn(result);\n        }\n        finally {\n            this._debug('#_useSession', 'end');\n        }\n    }\n    /**\n     * NEVER USE DIRECTLY!\n     *\n     * Always use {@link #_useSession}.\n     */\n    async __loadSession() {\n        this._debug('#__loadSession()', 'begin');\n        if (!this.lockAcquired) {\n            this._debug('#__loadSession()', 'used outside of an acquired lock!', new Error().stack);\n        }\n        try {\n            let currentSession = null;\n            const maybeSession = await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.getItemAsync)(this.storage, this.storageKey);\n            this._debug('#getSession()', 'session from storage', maybeSession);\n            if (maybeSession !== null) {\n                if (this._isValidSession(maybeSession)) {\n                    currentSession = maybeSession;\n                }\n                else {\n                    this._debug('#getSession()', 'session from storage is not valid');\n                    await this._removeSession();\n                }\n            }\n            if (!currentSession) {\n                return { data: { session: null }, error: null };\n            }\n            // A session is considered expired before the access token _actually_\n            // expires. When the autoRefreshToken option is off (or when the tab is\n            // in the background), very eager users of getSession() -- like\n            // realtime-js -- might send a valid JWT which will expire by the time it\n            // reaches the server.\n            const hasExpired = currentSession.expires_at\n                ? currentSession.expires_at * 1000 - Date.now() < _lib_constants__WEBPACK_IMPORTED_MODULE_1__.EXPIRY_MARGIN_MS\n                : false;\n            this._debug('#__loadSession()', `session has${hasExpired ? '' : ' not'} expired`, 'expires_at', currentSession.expires_at);\n            if (!hasExpired) {\n                if (this.userStorage) {\n                    const maybeUser = (await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.getItemAsync)(this.userStorage, this.storageKey + '-user'));\n                    if (maybeUser === null || maybeUser === void 0 ? void 0 : maybeUser.user) {\n                        currentSession.user = maybeUser.user;\n                    }\n                    else {\n                        currentSession.user = (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.userNotAvailableProxy)();\n                    }\n                }\n                if (this.storage.isServer && currentSession.user) {\n                    let suppressWarning = this.suppressGetSessionWarning;\n                    const proxySession = new Proxy(currentSession, {\n                        get: (target, prop, receiver) => {\n                            if (!suppressWarning && prop === 'user') {\n                                // only show warning when the user object is being accessed from the server\n                                console.warn('Using the user object as returned from supabase.auth.getSession() or from some supabase.auth.onAuthStateChange() events could be insecure! This value comes directly from the storage medium (usually cookies on the server) and may not be authentic. Use supabase.auth.getUser() instead which authenticates the data by contacting the Supabase Auth server.');\n                                suppressWarning = true; // keeps this proxy instance from logging additional warnings\n                                this.suppressGetSessionWarning = true; // keeps this client's future proxy instances from warning\n                            }\n                            return Reflect.get(target, prop, receiver);\n                        },\n                    });\n                    currentSession = proxySession;\n                }\n                return { data: { session: currentSession }, error: null };\n            }\n            const { data: session, error } = await this._callRefreshToken(currentSession.refresh_token);\n            if (error) {\n                return { data: { session: null }, error };\n            }\n            return { data: { session }, error: null };\n        }\n        finally {\n            this._debug('#__loadSession()', 'end');\n        }\n    }\n    /**\n     * Gets the current user details if there is an existing session. This method\n     * performs a network request to the Supabase Auth server, so the returned\n     * value is authentic and can be used to base authorization rules on.\n     *\n     * @param jwt Takes in an optional access token JWT. If no JWT is provided, the JWT from the current session is used.\n     */\n    async getUser(jwt) {\n        if (jwt) {\n            return await this._getUser(jwt);\n        }\n        await this.initializePromise;\n        const result = await this._acquireLock(-1, async () => {\n            return await this._getUser();\n        });\n        return result;\n    }\n    async _getUser(jwt) {\n        try {\n            if (jwt) {\n                return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, 'GET', `${this.url}/user`, {\n                    headers: this.headers,\n                    jwt: jwt,\n                    xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._userResponse,\n                });\n            }\n            return await this._useSession(async (result) => {\n                var _a, _b, _c;\n                const { data, error } = result;\n                if (error) {\n                    throw error;\n                }\n                // returns an error if there is no access_token or custom authorization header\n                if (!((_a = data.session) === null || _a === void 0 ? void 0 : _a.access_token) && !this.hasCustomAuthorizationHeader) {\n                    return { data: { user: null }, error: new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthSessionMissingError() };\n                }\n                return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, 'GET', `${this.url}/user`, {\n                    headers: this.headers,\n                    jwt: (_c = (_b = data.session) === null || _b === void 0 ? void 0 : _b.access_token) !== null && _c !== void 0 ? _c : undefined,\n                    xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._userResponse,\n                });\n            });\n        }\n        catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthSessionMissingError)(error)) {\n                    // JWT contains a `session_id` which does not correspond to an active\n                    // session in the database, indicating the user is signed out.\n                    await this._removeSession();\n                    await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.removeItemAsync)(this.storage, `${this.storageKey}-code-verifier`);\n                }\n                return { data: { user: null }, error };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Updates user data for a logged in user.\n     */\n    async updateUser(attributes, options = {}) {\n        await this.initializePromise;\n        return await this._acquireLock(-1, async () => {\n            return await this._updateUser(attributes, options);\n        });\n    }\n    async _updateUser(attributes, options = {}) {\n        try {\n            return await this._useSession(async (result) => {\n                const { data: sessionData, error: sessionError } = result;\n                if (sessionError) {\n                    throw sessionError;\n                }\n                if (!sessionData.session) {\n                    throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthSessionMissingError();\n                }\n                const session = sessionData.session;\n                let codeChallenge = null;\n                let codeChallengeMethod = null;\n                if (this.flowType === 'pkce' && attributes.email != null) {\n                    ;\n                    [codeChallenge, codeChallengeMethod] = await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.getCodeChallengeAndMethod)(this.storage, this.storageKey);\n                }\n                const { data, error: userError } = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, 'PUT', `${this.url}/user`, {\n                    headers: this.headers,\n                    redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo,\n                    body: Object.assign(Object.assign({}, attributes), { code_challenge: codeChallenge, code_challenge_method: codeChallengeMethod }),\n                    jwt: session.access_token,\n                    xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._userResponse,\n                });\n                if (userError)\n                    throw userError;\n                session.user = data.user;\n                await this._saveSession(session);\n                await this._notifyAllSubscribers('USER_UPDATED', session);\n                return { data: { user: session.user }, error: null };\n            });\n        }\n        catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return { data: { user: null }, error };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Sets the session data from the current session. If the current session is expired, setSession will take care of refreshing it to obtain a new session.\n     * If the refresh token or access token in the current session is invalid, an error will be thrown.\n     * @param currentSession The current session that minimally contains an access token and refresh token.\n     */\n    async setSession(currentSession) {\n        await this.initializePromise;\n        return await this._acquireLock(-1, async () => {\n            return await this._setSession(currentSession);\n        });\n    }\n    async _setSession(currentSession) {\n        try {\n            if (!currentSession.access_token || !currentSession.refresh_token) {\n                throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthSessionMissingError();\n            }\n            const timeNow = Date.now() / 1000;\n            let expiresAt = timeNow;\n            let hasExpired = true;\n            let session = null;\n            const { payload } = (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.decodeJWT)(currentSession.access_token);\n            if (payload.exp) {\n                expiresAt = payload.exp;\n                hasExpired = expiresAt <= timeNow;\n            }\n            if (hasExpired) {\n                const { data: refreshedSession, error } = await this._callRefreshToken(currentSession.refresh_token);\n                if (error) {\n                    return { data: { user: null, session: null }, error: error };\n                }\n                if (!refreshedSession) {\n                    return { data: { user: null, session: null }, error: null };\n                }\n                session = refreshedSession;\n            }\n            else {\n                const { data, error } = await this._getUser(currentSession.access_token);\n                if (error) {\n                    throw error;\n                }\n                session = {\n                    access_token: currentSession.access_token,\n                    refresh_token: currentSession.refresh_token,\n                    user: data.user,\n                    token_type: 'bearer',\n                    expires_in: expiresAt - timeNow,\n                    expires_at: expiresAt,\n                };\n                await this._saveSession(session);\n                await this._notifyAllSubscribers('SIGNED_IN', session);\n            }\n            return { data: { user: session.user, session }, error: null };\n        }\n        catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return { data: { session: null, user: null }, error };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Returns a new session, regardless of expiry status.\n     * Takes in an optional current session. If not passed in, then refreshSession() will attempt to retrieve it from getSession().\n     * If the current session's refresh token is invalid, an error will be thrown.\n     * @param currentSession The current session. If passed in, it must contain a refresh token.\n     */\n    async refreshSession(currentSession) {\n        await this.initializePromise;\n        return await this._acquireLock(-1, async () => {\n            return await this._refreshSession(currentSession);\n        });\n    }\n    async _refreshSession(currentSession) {\n        try {\n            return await this._useSession(async (result) => {\n                var _a;\n                if (!currentSession) {\n                    const { data, error } = result;\n                    if (error) {\n                        throw error;\n                    }\n                    currentSession = (_a = data.session) !== null && _a !== void 0 ? _a : undefined;\n                }\n                if (!(currentSession === null || currentSession === void 0 ? void 0 : currentSession.refresh_token)) {\n                    throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthSessionMissingError();\n                }\n                const { data: session, error } = await this._callRefreshToken(currentSession.refresh_token);\n                if (error) {\n                    return { data: { user: null, session: null }, error: error };\n                }\n                if (!session) {\n                    return { data: { user: null, session: null }, error: null };\n                }\n                return { data: { user: session.user, session }, error: null };\n            });\n        }\n        catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return { data: { user: null, session: null }, error };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Gets the session data from a URL string\n     */\n    async _getSessionFromURL(params, callbackUrlType) {\n        try {\n            if (!(0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.isBrowser)())\n                throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthImplicitGrantRedirectError('No browser detected.');\n            // If there's an error in the URL, it doesn't matter what flow it is, we just return the error.\n            if (params.error || params.error_description || params.error_code) {\n                // The error class returned implies that the redirect is from an implicit grant flow\n                // but it could also be from a redirect error from a PKCE flow.\n                throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthImplicitGrantRedirectError(params.error_description || 'Error in URL with unspecified error_description', {\n                    error: params.error || 'unspecified_error',\n                    code: params.error_code || 'unspecified_code',\n                });\n            }\n            // Checks for mismatches between the flowType initialised in the client and the URL parameters\n            switch (callbackUrlType) {\n                case 'implicit':\n                    if (this.flowType === 'pkce') {\n                        throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthPKCEGrantCodeExchangeError('Not a valid PKCE flow url.');\n                    }\n                    break;\n                case 'pkce':\n                    if (this.flowType === 'implicit') {\n                        throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthImplicitGrantRedirectError('Not a valid implicit grant flow url.');\n                    }\n                    break;\n                default:\n                // there's no mismatch so we continue\n            }\n            // Since this is a redirect for PKCE, we attempt to retrieve the code from the URL for the code exchange\n            if (callbackUrlType === 'pkce') {\n                this._debug('#_initialize()', 'begin', 'is PKCE flow', true);\n                if (!params.code)\n                    throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthPKCEGrantCodeExchangeError('No code detected.');\n                const { data, error } = await this._exchangeCodeForSession(params.code);\n                if (error)\n                    throw error;\n                const url = new URL(window.location.href);\n                url.searchParams.delete('code');\n                window.history.replaceState(window.history.state, '', url.toString());\n                return { data: { session: data.session, redirectType: null }, error: null };\n            }\n            const { provider_token, provider_refresh_token, access_token, refresh_token, expires_in, expires_at, token_type, } = params;\n            if (!access_token || !expires_in || !refresh_token || !token_type) {\n                throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthImplicitGrantRedirectError('No session defined in URL');\n            }\n            const timeNow = Math.round(Date.now() / 1000);\n            const expiresIn = parseInt(expires_in);\n            let expiresAt = timeNow + expiresIn;\n            if (expires_at) {\n                expiresAt = parseInt(expires_at);\n            }\n            const actuallyExpiresIn = expiresAt - timeNow;\n            if (actuallyExpiresIn * 1000 <= _lib_constants__WEBPACK_IMPORTED_MODULE_1__.AUTO_REFRESH_TICK_DURATION_MS) {\n                console.warn(`@supabase/gotrue-js: Session as retrieved from URL expires in ${actuallyExpiresIn}s, should have been closer to ${expiresIn}s`);\n            }\n            const issuedAt = expiresAt - expiresIn;\n            if (timeNow - issuedAt >= 120) {\n                console.warn('@supabase/gotrue-js: Session as retrieved from URL was issued over 120s ago, URL could be stale', issuedAt, expiresAt, timeNow);\n            }\n            else if (timeNow - issuedAt < 0) {\n                console.warn('@supabase/gotrue-js: Session as retrieved from URL was issued in the future? Check the device clock for skew', issuedAt, expiresAt, timeNow);\n            }\n            const { data, error } = await this._getUser(access_token);\n            if (error)\n                throw error;\n            const session = {\n                provider_token,\n                provider_refresh_token,\n                access_token,\n                expires_in: expiresIn,\n                expires_at: expiresAt,\n                refresh_token,\n                token_type: token_type,\n                user: data.user,\n            };\n            // Remove tokens from URL\n            window.location.hash = '';\n            this._debug('#_getSessionFromURL()', 'clearing window.location.hash');\n            return { data: { session, redirectType: params.type }, error: null };\n        }\n        catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return { data: { session: null, redirectType: null }, error };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Checks if the current URL contains parameters given by an implicit oauth grant flow (https://www.rfc-editor.org/rfc/rfc6749.html#section-4.2)\n     */\n    _isImplicitGrantCallback(params) {\n        return Boolean(params.access_token || params.error_description);\n    }\n    /**\n     * Checks if the current URL and backing storage contain parameters given by a PKCE flow\n     */\n    async _isPKCECallback(params) {\n        const currentStorageContent = await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.getItemAsync)(this.storage, `${this.storageKey}-code-verifier`);\n        return !!(params.code && currentStorageContent);\n    }\n    /**\n     * Inside a browser context, `signOut()` will remove the logged in user from the browser session and log them out - removing all items from localstorage and then trigger a `\"SIGNED_OUT\"` event.\n     *\n     * For server-side management, you can revoke all refresh tokens for a user by passing a user's JWT through to `auth.api.signOut(JWT: string)`.\n     * There is no way to revoke a user's access token jwt until it expires. It is recommended to set a shorter expiry on the jwt for this reason.\n     *\n     * If using `others` scope, no `SIGNED_OUT` event is fired!\n     */\n    async signOut(options = { scope: 'global' }) {\n        await this.initializePromise;\n        return await this._acquireLock(-1, async () => {\n            return await this._signOut(options);\n        });\n    }\n    async _signOut({ scope } = { scope: 'global' }) {\n        return await this._useSession(async (result) => {\n            var _a;\n            const { data, error: sessionError } = result;\n            if (sessionError) {\n                return { error: sessionError };\n            }\n            const accessToken = (_a = data.session) === null || _a === void 0 ? void 0 : _a.access_token;\n            if (accessToken) {\n                const { error } = await this.admin.signOut(accessToken, scope);\n                if (error) {\n                    // ignore 404s since user might not exist anymore\n                    // ignore 401s since an invalid or expired JWT should sign out the current session\n                    if (!((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthApiError)(error) &&\n                        (error.status === 404 || error.status === 401 || error.status === 403))) {\n                        return { error };\n                    }\n                }\n            }\n            if (scope !== 'others') {\n                await this._removeSession();\n                await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.removeItemAsync)(this.storage, `${this.storageKey}-code-verifier`);\n            }\n            return { error: null };\n        });\n    }\n    onAuthStateChange(callback) {\n        const id = (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.uuid)();\n        const subscription = {\n            id,\n            callback,\n            unsubscribe: () => {\n                this._debug('#unsubscribe()', 'state change callback with id removed', id);\n                this.stateChangeEmitters.delete(id);\n            },\n        };\n        this._debug('#onAuthStateChange()', 'registered callback with id', id);\n        this.stateChangeEmitters.set(id, subscription);\n        (async () => {\n            await this.initializePromise;\n            await this._acquireLock(-1, async () => {\n                this._emitInitialSession(id);\n            });\n        })();\n        return { data: { subscription } };\n    }\n    async _emitInitialSession(id) {\n        return await this._useSession(async (result) => {\n            var _a, _b;\n            try {\n                const { data: { session }, error, } = result;\n                if (error)\n                    throw error;\n                await ((_a = this.stateChangeEmitters.get(id)) === null || _a === void 0 ? void 0 : _a.callback('INITIAL_SESSION', session));\n                this._debug('INITIAL_SESSION', 'callback id', id, 'session', session);\n            }\n            catch (err) {\n                await ((_b = this.stateChangeEmitters.get(id)) === null || _b === void 0 ? void 0 : _b.callback('INITIAL_SESSION', null));\n                this._debug('INITIAL_SESSION', 'callback id', id, 'error', err);\n                console.error(err);\n            }\n        });\n    }\n    /**\n     * Sends a password reset request to an email address. This method supports the PKCE flow.\n     *\n     * @param email The email address of the user.\n     * @param options.redirectTo The URL to send the user to after they click the password reset link.\n     * @param options.captchaToken Verification token received when the user completes the captcha on the site.\n     */\n    async resetPasswordForEmail(email, options = {}) {\n        let codeChallenge = null;\n        let codeChallengeMethod = null;\n        if (this.flowType === 'pkce') {\n            ;\n            [codeChallenge, codeChallengeMethod] = await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.getCodeChallengeAndMethod)(this.storage, this.storageKey, true // isPasswordRecovery\n            );\n        }\n        try {\n            return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, 'POST', `${this.url}/recover`, {\n                body: {\n                    email,\n                    code_challenge: codeChallenge,\n                    code_challenge_method: codeChallengeMethod,\n                    gotrue_meta_security: { captcha_token: options.captchaToken },\n                },\n                headers: this.headers,\n                redirectTo: options.redirectTo,\n            });\n        }\n        catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return { data: null, error };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Gets all the identities linked to a user.\n     */\n    async getUserIdentities() {\n        var _a;\n        try {\n            const { data, error } = await this.getUser();\n            if (error)\n                throw error;\n            return { data: { identities: (_a = data.user.identities) !== null && _a !== void 0 ? _a : [] }, error: null };\n        }\n        catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return { data: null, error };\n            }\n            throw error;\n        }\n    }\n    async linkIdentity(credentials) {\n        if ('token' in credentials) {\n            return this.linkIdentityIdToken(credentials);\n        }\n        return this.linkIdentityOAuth(credentials);\n    }\n    async linkIdentityOAuth(credentials) {\n        var _a;\n        try {\n            const { data, error } = await this._useSession(async (result) => {\n                var _a, _b, _c, _d, _e;\n                const { data, error } = result;\n                if (error)\n                    throw error;\n                const url = await this._getUrlForProvider(`${this.url}/user/identities/authorize`, credentials.provider, {\n                    redirectTo: (_a = credentials.options) === null || _a === void 0 ? void 0 : _a.redirectTo,\n                    scopes: (_b = credentials.options) === null || _b === void 0 ? void 0 : _b.scopes,\n                    queryParams: (_c = credentials.options) === null || _c === void 0 ? void 0 : _c.queryParams,\n                    skipBrowserRedirect: true,\n                });\n                return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, 'GET', url, {\n                    headers: this.headers,\n                    jwt: (_e = (_d = data.session) === null || _d === void 0 ? void 0 : _d.access_token) !== null && _e !== void 0 ? _e : undefined,\n                });\n            });\n            if (error)\n                throw error;\n            if ((0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.isBrowser)() && !((_a = credentials.options) === null || _a === void 0 ? void 0 : _a.skipBrowserRedirect)) {\n                window.location.assign(data === null || data === void 0 ? void 0 : data.url);\n            }\n            return { data: { provider: credentials.provider, url: data === null || data === void 0 ? void 0 : data.url }, error: null };\n        }\n        catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return { data: { provider: credentials.provider, url: null }, error };\n            }\n            throw error;\n        }\n    }\n    async linkIdentityIdToken(credentials) {\n        return await this._useSession(async (result) => {\n            var _a;\n            try {\n                const { error: sessionError, data: { session }, } = result;\n                if (sessionError)\n                    throw sessionError;\n                const { options, provider, token, access_token, nonce } = credentials;\n                const res = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, 'POST', `${this.url}/token?grant_type=id_token`, {\n                    headers: this.headers,\n                    jwt: (_a = session === null || session === void 0 ? void 0 : session.access_token) !== null && _a !== void 0 ? _a : undefined,\n                    body: {\n                        provider,\n                        id_token: token,\n                        access_token,\n                        nonce,\n                        link_identity: true,\n                        gotrue_meta_security: { captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken },\n                    },\n                    xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._sessionResponse,\n                });\n                const { data, error } = res;\n                if (error) {\n                    return { data: { user: null, session: null }, error };\n                }\n                else if (!data || !data.session || !data.user) {\n                    return {\n                        data: { user: null, session: null },\n                        error: new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthInvalidTokenResponseError(),\n                    };\n                }\n                if (data.session) {\n                    await this._saveSession(data.session);\n                    await this._notifyAllSubscribers('USER_UPDATED', data.session);\n                }\n                return { data, error };\n            }\n            catch (error) {\n                if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                    return { data: { user: null, session: null }, error };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Unlinks an identity from a user by deleting it. The user will no longer be able to sign in with that identity once it's unlinked.\n     */\n    async unlinkIdentity(identity) {\n        try {\n            return await this._useSession(async (result) => {\n                var _a, _b;\n                const { data, error } = result;\n                if (error) {\n                    throw error;\n                }\n                return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, 'DELETE', `${this.url}/user/identities/${identity.identity_id}`, {\n                    headers: this.headers,\n                    jwt: (_b = (_a = data.session) === null || _a === void 0 ? void 0 : _a.access_token) !== null && _b !== void 0 ? _b : undefined,\n                });\n            });\n        }\n        catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return { data: null, error };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Generates a new JWT.\n     * @param refreshToken A valid refresh token that was returned on login.\n     */\n    async _refreshAccessToken(refreshToken) {\n        const debugName = `#_refreshAccessToken(${refreshToken.substring(0, 5)}...)`;\n        this._debug(debugName, 'begin');\n        try {\n            const startedAt = Date.now();\n            // will attempt to refresh the token with exponential backoff\n            return await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.retryable)(async (attempt) => {\n                if (attempt > 0) {\n                    await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.sleep)(200 * Math.pow(2, attempt - 1)); // 200, 400, 800, ...\n                }\n                this._debug(debugName, 'refreshing attempt', attempt);\n                return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, 'POST', `${this.url}/token?grant_type=refresh_token`, {\n                    body: { refresh_token: refreshToken },\n                    headers: this.headers,\n                    xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._sessionResponse,\n                });\n            }, (attempt, error) => {\n                const nextBackOffInterval = 200 * Math.pow(2, attempt);\n                return (error &&\n                    (0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthRetryableFetchError)(error) &&\n                    // retryable only if the request can be sent before the backoff overflows the tick duration\n                    Date.now() + nextBackOffInterval - startedAt < _lib_constants__WEBPACK_IMPORTED_MODULE_1__.AUTO_REFRESH_TICK_DURATION_MS);\n            });\n        }\n        catch (error) {\n            this._debug(debugName, 'error', error);\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return { data: { session: null, user: null }, error };\n            }\n            throw error;\n        }\n        finally {\n            this._debug(debugName, 'end');\n        }\n    }\n    _isValidSession(maybeSession) {\n        const isValidSession = typeof maybeSession === 'object' &&\n            maybeSession !== null &&\n            'access_token' in maybeSession &&\n            'refresh_token' in maybeSession &&\n            'expires_at' in maybeSession;\n        return isValidSession;\n    }\n    async _handleProviderSignIn(provider, options) {\n        const url = await this._getUrlForProvider(`${this.url}/authorize`, provider, {\n            redirectTo: options.redirectTo,\n            scopes: options.scopes,\n            queryParams: options.queryParams,\n        });\n        this._debug('#_handleProviderSignIn()', 'provider', provider, 'options', options, 'url', url);\n        // try to open on the browser\n        if ((0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.isBrowser)() && !options.skipBrowserRedirect) {\n            window.location.assign(url);\n        }\n        return { data: { provider, url }, error: null };\n    }\n    /**\n     * Recovers the session from LocalStorage and refreshes the token\n     * Note: this method is async to accommodate for AsyncStorage e.g. in React native.\n     */\n    async _recoverAndRefresh() {\n        var _a, _b;\n        const debugName = '#_recoverAndRefresh()';\n        this._debug(debugName, 'begin');\n        try {\n            const currentSession = (await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.getItemAsync)(this.storage, this.storageKey));\n            if (currentSession && this.userStorage) {\n                let maybeUser = (await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.getItemAsync)(this.userStorage, this.storageKey + '-user'));\n                if (!this.storage.isServer && Object.is(this.storage, this.userStorage) && !maybeUser) {\n                    // storage and userStorage are the same storage medium, for example\n                    // window.localStorage if userStorage does not have the user from\n                    // storage stored, store it first thereby migrating the user object\n                    // from storage -> userStorage\n                    maybeUser = { user: currentSession.user };\n                    await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.setItemAsync)(this.userStorage, this.storageKey + '-user', maybeUser);\n                }\n                currentSession.user = (_a = maybeUser === null || maybeUser === void 0 ? void 0 : maybeUser.user) !== null && _a !== void 0 ? _a : (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.userNotAvailableProxy)();\n            }\n            else if (currentSession && !currentSession.user) {\n                // user storage is not set, let's check if it was previously enabled so\n                // we bring back the storage as it should be\n                if (!currentSession.user) {\n                    // test if userStorage was previously enabled and the storage medium was the same, to move the user back under the same key\n                    const separateUser = (await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.getItemAsync)(this.storage, this.storageKey + '-user'));\n                    if (separateUser && (separateUser === null || separateUser === void 0 ? void 0 : separateUser.user)) {\n                        currentSession.user = separateUser.user;\n                        await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.removeItemAsync)(this.storage, this.storageKey + '-user');\n                        await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.setItemAsync)(this.storage, this.storageKey, currentSession);\n                    }\n                    else {\n                        currentSession.user = (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.userNotAvailableProxy)();\n                    }\n                }\n            }\n            this._debug(debugName, 'session from storage', currentSession);\n            if (!this._isValidSession(currentSession)) {\n                this._debug(debugName, 'session is not valid');\n                if (currentSession !== null) {\n                    await this._removeSession();\n                }\n                return;\n            }\n            const expiresWithMargin = ((_b = currentSession.expires_at) !== null && _b !== void 0 ? _b : Infinity) * 1000 - Date.now() < _lib_constants__WEBPACK_IMPORTED_MODULE_1__.EXPIRY_MARGIN_MS;\n            this._debug(debugName, `session has${expiresWithMargin ? '' : ' not'} expired with margin of ${_lib_constants__WEBPACK_IMPORTED_MODULE_1__.EXPIRY_MARGIN_MS}s`);\n            if (expiresWithMargin) {\n                if (this.autoRefreshToken && currentSession.refresh_token) {\n                    const { error } = await this._callRefreshToken(currentSession.refresh_token);\n                    if (error) {\n                        console.error(error);\n                        if (!(0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthRetryableFetchError)(error)) {\n                            this._debug(debugName, 'refresh failed with a non-retryable error, removing the session', error);\n                            await this._removeSession();\n                        }\n                    }\n                }\n            }\n            else if (currentSession.user &&\n                currentSession.user.__isUserNotAvailableProxy === true) {\n                // If we have a proxy user, try to get the real user data\n                try {\n                    const { data, error: userError } = await this._getUser(currentSession.access_token);\n                    if (!userError && (data === null || data === void 0 ? void 0 : data.user)) {\n                        currentSession.user = data.user;\n                        await this._saveSession(currentSession);\n                        await this._notifyAllSubscribers('SIGNED_IN', currentSession);\n                    }\n                    else {\n                        this._debug(debugName, 'could not get user data, skipping SIGNED_IN notification');\n                    }\n                }\n                catch (getUserError) {\n                    console.error('Error getting user data:', getUserError);\n                    this._debug(debugName, 'error getting user data, skipping SIGNED_IN notification', getUserError);\n                }\n            }\n            else {\n                // no need to persist currentSession again, as we just loaded it from\n                // local storage; persisting it again may overwrite a value saved by\n                // another client with access to the same local storage\n                await this._notifyAllSubscribers('SIGNED_IN', currentSession);\n            }\n        }\n        catch (err) {\n            this._debug(debugName, 'error', err);\n            console.error(err);\n            return;\n        }\n        finally {\n            this._debug(debugName, 'end');\n        }\n    }\n    async _callRefreshToken(refreshToken) {\n        var _a, _b;\n        if (!refreshToken) {\n            throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthSessionMissingError();\n        }\n        // refreshing is already in progress\n        if (this.refreshingDeferred) {\n            return this.refreshingDeferred.promise;\n        }\n        const debugName = `#_callRefreshToken(${refreshToken.substring(0, 5)}...)`;\n        this._debug(debugName, 'begin');\n        try {\n            this.refreshingDeferred = new _lib_helpers__WEBPACK_IMPORTED_MODULE_4__.Deferred();\n            const { data, error } = await this._refreshAccessToken(refreshToken);\n            if (error)\n                throw error;\n            if (!data.session)\n                throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthSessionMissingError();\n            await this._saveSession(data.session);\n            await this._notifyAllSubscribers('TOKEN_REFRESHED', data.session);\n            const result = { data: data.session, error: null };\n            this.refreshingDeferred.resolve(result);\n            return result;\n        }\n        catch (error) {\n            this._debug(debugName, 'error', error);\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                const result = { data: null, error };\n                if (!(0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthRetryableFetchError)(error)) {\n                    await this._removeSession();\n                }\n                (_a = this.refreshingDeferred) === null || _a === void 0 ? void 0 : _a.resolve(result);\n                return result;\n            }\n            (_b = this.refreshingDeferred) === null || _b === void 0 ? void 0 : _b.reject(error);\n            throw error;\n        }\n        finally {\n            this.refreshingDeferred = null;\n            this._debug(debugName, 'end');\n        }\n    }\n    async _notifyAllSubscribers(event, session, broadcast = true) {\n        const debugName = `#_notifyAllSubscribers(${event})`;\n        this._debug(debugName, 'begin', session, `broadcast = ${broadcast}`);\n        try {\n            if (this.broadcastChannel && broadcast) {\n                this.broadcastChannel.postMessage({ event, session });\n            }\n            const errors = [];\n            const promises = Array.from(this.stateChangeEmitters.values()).map(async (x) => {\n                try {\n                    await x.callback(event, session);\n                }\n                catch (e) {\n                    errors.push(e);\n                }\n            });\n            await Promise.all(promises);\n            if (errors.length > 0) {\n                for (let i = 0; i < errors.length; i += 1) {\n                    console.error(errors[i]);\n                }\n                throw errors[0];\n            }\n        }\n        finally {\n            this._debug(debugName, 'end');\n        }\n    }\n    /**\n     * set currentSession and currentUser\n     * process to _startAutoRefreshToken if possible\n     */\n    async _saveSession(session) {\n        this._debug('#_saveSession()', session);\n        // _saveSession is always called whenever a new session has been acquired\n        // so we can safely suppress the warning returned by future getSession calls\n        this.suppressGetSessionWarning = true;\n        // Create a shallow copy to work with, to avoid mutating the original session object if it's used elsewhere\n        const sessionToProcess = Object.assign({}, session);\n        const userIsProxy = sessionToProcess.user && sessionToProcess.user.__isUserNotAvailableProxy === true;\n        if (this.userStorage) {\n            if (!userIsProxy && sessionToProcess.user) {\n                // If it's a real user object, save it to userStorage.\n                await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.setItemAsync)(this.userStorage, this.storageKey + '-user', {\n                    user: sessionToProcess.user,\n                });\n            }\n            else if (userIsProxy) {\n                // If it's the proxy, it means user was not found in userStorage.\n                // We should ensure no stale user data for this key exists in userStorage if we were to save null,\n                // or simply not save the proxy. For now, we don't save the proxy here.\n                // If there's a need to clear userStorage if user becomes proxy, that logic would go here.\n            }\n            // Prepare the main session data for primary storage: remove the user property before cloning\n            // This is important because the original session.user might be the proxy\n            const mainSessionData = Object.assign({}, sessionToProcess);\n            delete mainSessionData.user; // Remove user (real or proxy) before cloning for main storage\n            const clonedMainSessionData = (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.deepClone)(mainSessionData);\n            await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.setItemAsync)(this.storage, this.storageKey, clonedMainSessionData);\n        }\n        else {\n            // No userStorage is configured.\n            // In this case, session.user should ideally not be a proxy.\n            // If it were, structuredClone would fail. This implies an issue elsewhere if user is a proxy here\n            const clonedSession = (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.deepClone)(sessionToProcess); // sessionToProcess still has its original user property\n            await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.setItemAsync)(this.storage, this.storageKey, clonedSession);\n        }\n    }\n    async _removeSession() {\n        this._debug('#_removeSession()');\n        await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.removeItemAsync)(this.storage, this.storageKey);\n        await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.removeItemAsync)(this.storage, this.storageKey + '-code-verifier');\n        await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.removeItemAsync)(this.storage, this.storageKey + '-user');\n        if (this.userStorage) {\n            await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.removeItemAsync)(this.userStorage, this.storageKey + '-user');\n        }\n        await this._notifyAllSubscribers('SIGNED_OUT', null);\n    }\n    /**\n     * Removes any registered visibilitychange callback.\n     *\n     * {@see #startAutoRefresh}\n     * {@see #stopAutoRefresh}\n     */\n    _removeVisibilityChangedCallback() {\n        this._debug('#_removeVisibilityChangedCallback()');\n        const callback = this.visibilityChangedCallback;\n        this.visibilityChangedCallback = null;\n        try {\n            if (callback && (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.isBrowser)() && (window === null || window === void 0 ? void 0 : window.removeEventListener)) {\n                window.removeEventListener('visibilitychange', callback);\n            }\n        }\n        catch (e) {\n            console.error('removing visibilitychange callback failed', e);\n        }\n    }\n    /**\n     * This is the private implementation of {@link #startAutoRefresh}. Use this\n     * within the library.\n     */\n    async _startAutoRefresh() {\n        await this._stopAutoRefresh();\n        this._debug('#_startAutoRefresh()');\n        const ticker = setInterval(() => this._autoRefreshTokenTick(), _lib_constants__WEBPACK_IMPORTED_MODULE_1__.AUTO_REFRESH_TICK_DURATION_MS);\n        this.autoRefreshTicker = ticker;\n        if (ticker && typeof ticker === 'object' && typeof ticker.unref === 'function') {\n            // ticker is a NodeJS Timeout object that has an `unref` method\n            // https://nodejs.org/api/timers.html#timeoutunref\n            // When auto refresh is used in NodeJS (like for testing) the\n            // `setInterval` is preventing the process from being marked as\n            // finished and tests run endlessly. This can be prevented by calling\n            // `unref()` on the returned object.\n            ticker.unref();\n            // @ts-expect-error TS has no context of Deno\n        }\n        else if (typeof Deno !== 'undefined' && typeof Deno.unrefTimer === 'function') {\n            // similar like for NodeJS, but with the Deno API\n            // https://deno.land/api@latest?unstable&s=Deno.unrefTimer\n            // @ts-expect-error TS has no context of Deno\n            Deno.unrefTimer(ticker);\n        }\n        // run the tick immediately, but in the next pass of the event loop so that\n        // #_initialize can be allowed to complete without recursively waiting on\n        // itself\n        setTimeout(async () => {\n            await this.initializePromise;\n            await this._autoRefreshTokenTick();\n        }, 0);\n    }\n    /**\n     * This is the private implementation of {@link #stopAutoRefresh}. Use this\n     * within the library.\n     */\n    async _stopAutoRefresh() {\n        this._debug('#_stopAutoRefresh()');\n        const ticker = this.autoRefreshTicker;\n        this.autoRefreshTicker = null;\n        if (ticker) {\n            clearInterval(ticker);\n        }\n    }\n    /**\n     * Starts an auto-refresh process in the background. The session is checked\n     * every few seconds. Close to the time of expiration a process is started to\n     * refresh the session. If refreshing fails it will be retried for as long as\n     * necessary.\n     *\n     * If you set the {@link GoTrueClientOptions#autoRefreshToken} you don't need\n     * to call this function, it will be called for you.\n     *\n     * On browsers the refresh process works only when the tab/window is in the\n     * foreground to conserve resources as well as prevent race conditions and\n     * flooding auth with requests. If you call this method any managed\n     * visibility change callback will be removed and you must manage visibility\n     * changes on your own.\n     *\n     * On non-browser platforms the refresh process works *continuously* in the\n     * background, which may not be desirable. You should hook into your\n     * platform's foreground indication mechanism and call these methods\n     * appropriately to conserve resources.\n     *\n     * {@see #stopAutoRefresh}\n     */\n    async startAutoRefresh() {\n        this._removeVisibilityChangedCallback();\n        await this._startAutoRefresh();\n    }\n    /**\n     * Stops an active auto refresh process running in the background (if any).\n     *\n     * If you call this method any managed visibility change callback will be\n     * removed and you must manage visibility changes on your own.\n     *\n     * See {@link #startAutoRefresh} for more details.\n     */\n    async stopAutoRefresh() {\n        this._removeVisibilityChangedCallback();\n        await this._stopAutoRefresh();\n    }\n    /**\n     * Runs the auto refresh token tick.\n     */\n    async _autoRefreshTokenTick() {\n        this._debug('#_autoRefreshTokenTick()', 'begin');\n        try {\n            await this._acquireLock(0, async () => {\n                try {\n                    const now = Date.now();\n                    try {\n                        return await this._useSession(async (result) => {\n                            const { data: { session }, } = result;\n                            if (!session || !session.refresh_token || !session.expires_at) {\n                                this._debug('#_autoRefreshTokenTick()', 'no session');\n                                return;\n                            }\n                            // session will expire in this many ticks (or has already expired if <= 0)\n                            const expiresInTicks = Math.floor((session.expires_at * 1000 - now) / _lib_constants__WEBPACK_IMPORTED_MODULE_1__.AUTO_REFRESH_TICK_DURATION_MS);\n                            this._debug('#_autoRefreshTokenTick()', `access token expires in ${expiresInTicks} ticks, a tick lasts ${_lib_constants__WEBPACK_IMPORTED_MODULE_1__.AUTO_REFRESH_TICK_DURATION_MS}ms, refresh threshold is ${_lib_constants__WEBPACK_IMPORTED_MODULE_1__.AUTO_REFRESH_TICK_THRESHOLD} ticks`);\n                            if (expiresInTicks <= _lib_constants__WEBPACK_IMPORTED_MODULE_1__.AUTO_REFRESH_TICK_THRESHOLD) {\n                                await this._callRefreshToken(session.refresh_token);\n                            }\n                        });\n                    }\n                    catch (e) {\n                        console.error('Auto refresh tick failed with error. This is likely a transient error.', e);\n                    }\n                }\n                finally {\n                    this._debug('#_autoRefreshTokenTick()', 'end');\n                }\n            });\n        }\n        catch (e) {\n            if (e.isAcquireTimeout || e instanceof _lib_locks__WEBPACK_IMPORTED_MODULE_6__.LockAcquireTimeoutError) {\n                this._debug('auto refresh token tick lock not available');\n            }\n            else {\n                throw e;\n            }\n        }\n    }\n    /**\n     * Registers callbacks on the browser / platform, which in-turn run\n     * algorithms when the browser window/tab are in foreground. On non-browser\n     * platforms it assumes always foreground.\n     */\n    async _handleVisibilityChange() {\n        this._debug('#_handleVisibilityChange()');\n        if (!(0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.isBrowser)() || !(window === null || window === void 0 ? void 0 : window.addEventListener)) {\n            if (this.autoRefreshToken) {\n                // in non-browser environments the refresh token ticker runs always\n                this.startAutoRefresh();\n            }\n            return false;\n        }\n        try {\n            this.visibilityChangedCallback = async () => await this._onVisibilityChanged(false);\n            window === null || window === void 0 ? void 0 : window.addEventListener('visibilitychange', this.visibilityChangedCallback);\n            // now immediately call the visbility changed callback to setup with the\n            // current visbility state\n            await this._onVisibilityChanged(true); // initial call\n        }\n        catch (error) {\n            console.error('_handleVisibilityChange', error);\n        }\n    }\n    /**\n     * Callback registered with `window.addEventListener('visibilitychange')`.\n     */\n    async _onVisibilityChanged(calledFromInitialize) {\n        const methodName = `#_onVisibilityChanged(${calledFromInitialize})`;\n        this._debug(methodName, 'visibilityState', document.visibilityState);\n        if (document.visibilityState === 'visible') {\n            if (this.autoRefreshToken) {\n                // in browser environments the refresh token ticker runs only on focused tabs\n                // which prevents race conditions\n                this._startAutoRefresh();\n            }\n            if (!calledFromInitialize) {\n                // called when the visibility has changed, i.e. the browser\n                // transitioned from hidden -> visible so we need to see if the session\n                // should be recovered immediately... but to do that we need to acquire\n                // the lock first asynchronously\n                await this.initializePromise;\n                await this._acquireLock(-1, async () => {\n                    if (document.visibilityState !== 'visible') {\n                        this._debug(methodName, 'acquired the lock to recover the session, but the browser visibilityState is no longer visible, aborting');\n                        // visibility has changed while waiting for the lock, abort\n                        return;\n                    }\n                    // recover the session\n                    await this._recoverAndRefresh();\n                });\n            }\n        }\n        else if (document.visibilityState === 'hidden') {\n            if (this.autoRefreshToken) {\n                this._stopAutoRefresh();\n            }\n        }\n    }\n    /**\n     * Generates the relevant login URL for a third-party provider.\n     * @param options.redirectTo A URL or mobile address to send the user to after they are confirmed.\n     * @param options.scopes A space-separated list of scopes granted to the OAuth application.\n     * @param options.queryParams An object of key-value pairs containing query parameters granted to the OAuth application.\n     */\n    async _getUrlForProvider(url, provider, options) {\n        const urlParams = [`provider=${encodeURIComponent(provider)}`];\n        if (options === null || options === void 0 ? void 0 : options.redirectTo) {\n            urlParams.push(`redirect_to=${encodeURIComponent(options.redirectTo)}`);\n        }\n        if (options === null || options === void 0 ? void 0 : options.scopes) {\n            urlParams.push(`scopes=${encodeURIComponent(options.scopes)}`);\n        }\n        if (this.flowType === 'pkce') {\n            const [codeChallenge, codeChallengeMethod] = await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.getCodeChallengeAndMethod)(this.storage, this.storageKey);\n            const flowParams = new URLSearchParams({\n                code_challenge: `${encodeURIComponent(codeChallenge)}`,\n                code_challenge_method: `${encodeURIComponent(codeChallengeMethod)}`,\n            });\n            urlParams.push(flowParams.toString());\n        }\n        if (options === null || options === void 0 ? void 0 : options.queryParams) {\n            const query = new URLSearchParams(options.queryParams);\n            urlParams.push(query.toString());\n        }\n        if (options === null || options === void 0 ? void 0 : options.skipBrowserRedirect) {\n            urlParams.push(`skip_http_redirect=${options.skipBrowserRedirect}`);\n        }\n        return `${url}?${urlParams.join('&')}`;\n    }\n    async _unenroll(params) {\n        try {\n            return await this._useSession(async (result) => {\n                var _a;\n                const { data: sessionData, error: sessionError } = result;\n                if (sessionError) {\n                    return { data: null, error: sessionError };\n                }\n                return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, 'DELETE', `${this.url}/factors/${params.factorId}`, {\n                    headers: this.headers,\n                    jwt: (_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token,\n                });\n            });\n        }\n        catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return { data: null, error };\n            }\n            throw error;\n        }\n    }\n    async _enroll(params) {\n        try {\n            return await this._useSession(async (result) => {\n                var _a, _b;\n                const { data: sessionData, error: sessionError } = result;\n                if (sessionError) {\n                    return { data: null, error: sessionError };\n                }\n                const body = Object.assign({ friendly_name: params.friendlyName, factor_type: params.factorType }, (params.factorType === 'phone'\n                    ? { phone: params.phone }\n                    : params.factorType === 'totp'\n                        ? { issuer: params.issuer }\n                        : {}));\n                const { data, error } = (await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, 'POST', `${this.url}/factors`, {\n                    body,\n                    headers: this.headers,\n                    jwt: (_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token,\n                }));\n                if (error) {\n                    return { data: null, error };\n                }\n                if (params.factorType === 'totp' && data.type === 'totp' && ((_b = data === null || data === void 0 ? void 0 : data.totp) === null || _b === void 0 ? void 0 : _b.qr_code)) {\n                    data.totp.qr_code = `data:image/svg+xml;utf-8,${data.totp.qr_code}`;\n                }\n                return { data, error: null };\n            });\n        }\n        catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return { data: null, error };\n            }\n            throw error;\n        }\n    }\n    async _verify(params) {\n        return this._acquireLock(-1, async () => {\n            try {\n                return await this._useSession(async (result) => {\n                    var _a;\n                    const { data: sessionData, error: sessionError } = result;\n                    if (sessionError) {\n                        return { data: null, error: sessionError };\n                    }\n                    const body = Object.assign({ challenge_id: params.challengeId }, ('webauthn' in params\n                        ? {\n                            webauthn: Object.assign(Object.assign({}, params.webauthn), { credential_response: params.webauthn.type === 'create'\n                                    ? (0,_lib_webauthn__WEBPACK_IMPORTED_MODULE_11__.serializeCredentialCreationResponse)(params.webauthn.credential_response)\n                                    : (0,_lib_webauthn__WEBPACK_IMPORTED_MODULE_11__.serializeCredentialRequestResponse)(params.webauthn.credential_response) }),\n                        }\n                        : { code: params.code }));\n                    const { data, error } = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, 'POST', `${this.url}/factors/${params.factorId}/verify`, {\n                        body,\n                        headers: this.headers,\n                        jwt: (_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token,\n                    });\n                    if (error) {\n                        return { data: null, error };\n                    }\n                    await this._saveSession(Object.assign({ expires_at: Math.round(Date.now() / 1000) + data.expires_in }, data));\n                    await this._notifyAllSubscribers('MFA_CHALLENGE_VERIFIED', data);\n                    return { data, error };\n                });\n            }\n            catch (error) {\n                if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                    return { data: null, error };\n                }\n                throw error;\n            }\n        });\n    }\n    async _challenge(params) {\n        return this._acquireLock(-1, async () => {\n            try {\n                return await this._useSession(async (result) => {\n                    var _a;\n                    const { data: sessionData, error: sessionError } = result;\n                    if (sessionError) {\n                        return { data: null, error: sessionError };\n                    }\n                    const response = (await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, 'POST', `${this.url}/factors/${params.factorId}/challenge`, {\n                        body: params,\n                        headers: this.headers,\n                        jwt: (_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token,\n                    }));\n                    if (response.error) {\n                        return response;\n                    }\n                    const { data } = response;\n                    if (data.type !== 'webauthn') {\n                        return { data, error: null };\n                    }\n                    switch (data.webauthn.type) {\n                        case 'create':\n                            return {\n                                data: Object.assign(Object.assign({}, data), { webauthn: Object.assign(Object.assign({}, data.webauthn), { credential_options: Object.assign(Object.assign({}, data.webauthn.credential_options), { publicKey: (0,_lib_webauthn__WEBPACK_IMPORTED_MODULE_11__.deserializeCredentialCreationOptions)(data.webauthn.credential_options.publicKey) }) }) }),\n                                error: null,\n                            };\n                        case 'request':\n                            return {\n                                data: Object.assign(Object.assign({}, data), { webauthn: Object.assign(Object.assign({}, data.webauthn), { credential_options: Object.assign(Object.assign({}, data.webauthn.credential_options), { publicKey: (0,_lib_webauthn__WEBPACK_IMPORTED_MODULE_11__.deserializeCredentialRequestOptions)(data.webauthn.credential_options.publicKey) }) }) }),\n                                error: null,\n                            };\n                    }\n                });\n            }\n            catch (error) {\n                if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                    return { data: null, error };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * {@see GoTrueMFAApi#challengeAndVerify}\n     */\n    async _challengeAndVerify(params) {\n        // both _challenge and _verify independently acquire the lock, so no need\n        // to acquire it here\n        const { data: challengeData, error: challengeError } = await this._challenge({\n            factorId: params.factorId,\n        });\n        if (challengeError) {\n            return { data: null, error: challengeError };\n        }\n        return await this._verify({\n            factorId: params.factorId,\n            challengeId: challengeData.id,\n            code: params.code,\n        });\n    }\n    /**\n     * {@see GoTrueMFAApi#listFactors}\n     */\n    async _listFactors() {\n        var _a;\n        // use #getUser instead of #_getUser as the former acquires a lock\n        const { data: { user }, error: userError, } = await this.getUser();\n        if (userError) {\n            return { data: null, error: userError };\n        }\n        const data = {\n            all: [],\n            phone: [],\n            totp: [],\n            webauthn: [],\n        };\n        // loop over the factors ONCE\n        for (const factor of (_a = user === null || user === void 0 ? void 0 : user.factors) !== null && _a !== void 0 ? _a : []) {\n            data.all.push(factor);\n            if (factor.status === 'verified') {\n                ;\n                data[factor.factor_type].push(factor);\n            }\n        }\n        return {\n            data,\n            error: null,\n        };\n    }\n    /**\n     * {@see GoTrueMFAApi#getAuthenticatorAssuranceLevel}\n     */\n    async _getAuthenticatorAssuranceLevel() {\n        return this._acquireLock(-1, async () => {\n            return await this._useSession(async (result) => {\n                var _a, _b;\n                const { data: { session }, error: sessionError, } = result;\n                if (sessionError) {\n                    return { data: null, error: sessionError };\n                }\n                if (!session) {\n                    return {\n                        data: { currentLevel: null, nextLevel: null, currentAuthenticationMethods: [] },\n                        error: null,\n                    };\n                }\n                const { payload } = (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.decodeJWT)(session.access_token);\n                let currentLevel = null;\n                if (payload.aal) {\n                    currentLevel = payload.aal;\n                }\n                let nextLevel = currentLevel;\n                const verifiedFactors = (_b = (_a = session.user.factors) === null || _a === void 0 ? void 0 : _a.filter((factor) => factor.status === 'verified')) !== null && _b !== void 0 ? _b : [];\n                if (verifiedFactors.length > 0) {\n                    nextLevel = 'aal2';\n                }\n                const currentAuthenticationMethods = payload.amr || [];\n                return { data: { currentLevel, nextLevel, currentAuthenticationMethods }, error: null };\n            });\n        });\n    }\n    async fetchJwk(kid, jwks = { keys: [] }) {\n        // try fetching from the supplied jwks\n        let jwk = jwks.keys.find((key) => key.kid === kid);\n        if (jwk) {\n            return jwk;\n        }\n        const now = Date.now();\n        // try fetching from cache\n        jwk = this.jwks.keys.find((key) => key.kid === kid);\n        // jwk exists and jwks isn't stale\n        if (jwk && this.jwks_cached_at + _lib_constants__WEBPACK_IMPORTED_MODULE_1__.JWKS_TTL > now) {\n            return jwk;\n        }\n        // jwk isn't cached in memory so we need to fetch it from the well-known endpoint\n        const { data, error } = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, 'GET', `${this.url}/.well-known/jwks.json`, {\n            headers: this.headers,\n        });\n        if (error) {\n            throw error;\n        }\n        if (!data.keys || data.keys.length === 0) {\n            return null;\n        }\n        this.jwks = data;\n        this.jwks_cached_at = now;\n        // Find the signing key\n        jwk = data.keys.find((key) => key.kid === kid);\n        if (!jwk) {\n            return null;\n        }\n        return jwk;\n    }\n    /**\n     * Extracts the JWT claims present in the access token by first verifying the\n     * JWT against the server's JSON Web Key Set endpoint\n     * `/.well-known/jwks.json` which is often cached, resulting in significantly\n     * faster responses. Prefer this method over {@link #getUser} which always\n     * sends a request to the Auth server for each JWT.\n     *\n     * If the project is not using an asymmetric JWT signing key (like ECC or\n     * RSA) it always sends a request to the Auth server (similar to {@link\n     * #getUser}) to verify the JWT.\n     *\n     * @param jwt An optional specific JWT you wish to verify, not the one you\n     *            can obtain from {@link #getSession}.\n     * @param options Various additional options that allow you to customize the\n     *                behavior of this method.\n     */\n    async getClaims(jwt, options = {}) {\n        try {\n            let token = jwt;\n            if (!token) {\n                const { data, error } = await this.getSession();\n                if (error || !data.session) {\n                    return { data: null, error };\n                }\n                token = data.session.access_token;\n            }\n            const { header, payload, signature, raw: { header: rawHeader, payload: rawPayload }, } = (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.decodeJWT)(token);\n            if (!(options === null || options === void 0 ? void 0 : options.allowExpired)) {\n                // Reject expired JWTs should only happen if jwt argument was passed\n                (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.validateExp)(payload.exp);\n            }\n            const signingKey = !header.alg ||\n                header.alg.startsWith('HS') ||\n                !header.kid ||\n                !('crypto' in globalThis && 'subtle' in globalThis.crypto)\n                ? null\n                : await this.fetchJwk(header.kid, (options === null || options === void 0 ? void 0 : options.keys) ? { keys: options.keys } : options === null || options === void 0 ? void 0 : options.jwks);\n            // If symmetric algorithm or WebCrypto API is unavailable, fallback to getUser()\n            if (!signingKey) {\n                const { error } = await this.getUser(token);\n                if (error) {\n                    throw error;\n                }\n                // getUser succeeds so the claims in the JWT can be trusted\n                return {\n                    data: {\n                        claims: payload,\n                        header,\n                        signature,\n                    },\n                    error: null,\n                };\n            }\n            const algorithm = (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.getAlgorithm)(header.alg);\n            // Convert JWK to CryptoKey\n            const publicKey = await crypto.subtle.importKey('jwk', signingKey, algorithm, true, [\n                'verify',\n            ]);\n            // Verify the signature\n            const isValid = await crypto.subtle.verify(algorithm, publicKey, signature, (0,_lib_base64url__WEBPACK_IMPORTED_MODULE_9__.stringToUint8Array)(`${rawHeader}.${rawPayload}`));\n            if (!isValid) {\n                throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthInvalidJwtError('Invalid JWT signature');\n            }\n            // If verification succeeds, decode and return claims\n            return {\n                data: {\n                    claims: payload,\n                    header,\n                    signature,\n                },\n                error: null,\n            };\n        }\n        catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return { data: null, error };\n            }\n            throw error;\n        }\n    }\n}\nGoTrueClient.nextInstanceID = 0;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (GoTrueClient);\n//# sourceMappingURL=GoTrueClient.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvYXV0aC1qcy9kaXN0L21vZHVsZS9Hb1RydWVDbGllbnQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUE4QztBQUNzSDtBQUM0SztBQUMvTjtBQUN3SztBQUN6TjtBQUNLO0FBQ2hCO0FBQ2I7QUFDK0I7QUFDYztBQUM2RztBQUNsTSxrRUFBa0IsSUFBSTtBQUN0QjtBQUNBLFNBQVMsc0RBQVU7QUFDbkIsZ0JBQWdCLHVEQUFXO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLGFBQWEsMkRBQWU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwSUFBMEk7QUFDMUk7QUFDQTtBQUNBLHFFQUFxRSxtQ0FBbUMsYUFBYTtBQUNySDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsbUNBQW1DLGlCQUFpQjtBQUN6SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyx1REFBUztBQUM1QztBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHVEQUFjO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EscUJBQXFCLDBEQUFZO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHVEQUFTO0FBQzFCLHdCQUF3QixxREFBYTtB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QTtBQUNBO0FBQ0E7QUFDQSx3RkFBd0Ysa0VBQWtCLElBQUksVUFBVSxHQUFHLFdBQVc7QUFDdEk7QUFDQSwwQkFBMEIsNERBQW1CO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHdEQUFXO0FBQzNCLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBZSxZQUFZLEVBQUM7QUFDNUIiLCJzb3VyY2VzIjpbIkQ6XFxuZXh0XFxvcmdcXG5vZGVfbW9kdWxlc1xcQHN1cGFiYXNlXFxhdXRoLWpzXFxkaXN0XFxtb2R1bGVcXEdvVHJ1ZUNsaWVudC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgR29UcnVlQWRtaW5BcGkgZnJvbSAnLi9Hb1RydWVBZG1pbkFwaSc7XG5pbXBvcnQgeyBBVVRPX1JFRlJFU0hfVElDS19EVVJBVElPTl9NUywgQVVUT19SRUZSRVNIX1RJQ0tfVEhSRVNIT0xELCBERUZBVUxUX0hFQURFUlMsIEVYUElSWV9NQVJHSU5fTVMsIEdPVFJVRV9VUkwsIEpXS1NfVFRMLCBTVE9SQUdFX0tFWSwgfSBmcm9tICcuL2xpYi9jb25zdGFudHMnO1xuaW1wb3J0IHsgQXV0aEltcGxpY2l0R3JhbnRSZWRpcmVjdEVycm9yLCBBdXRoSW52YWxpZENyZWRlbnRpYWxzRXJyb3IsIEF1dGhJbnZhbGlkSnd0RXJyb3IsIEF1dGhJbnZhbGlkVG9rZW5SZXNwb25zZUVycm9yLCBBdXRoUEtDRUdyYW50Q29kZUV4Y2hhbmdlRXJyb3IsIEF1dGhTZXNzaW9uTWlzc2luZ0Vycm9yLCBBdXRoVW5rbm93bkVycm9yLCBpc0F1dGhBcGlFcnJvciwgaXNBdXRoRXJyb3IsIGlzQXV0aEltcGxpY2l0R3JhbnRSZWRpcmVjdEVycm9yLCBpc0F1dGhSZXRyeWFibGVGZXRjaEVycm9yLCBpc0F1dGhTZXNzaW9uTWlzc2luZ0Vycm9yLCB9IGZyb20gJy4vbGliL2Vycm9ycyc7XG5pbXBvcnQgeyBfcmVxdWVzdCwgX3Nlc3Npb25SZXNwb25zZSwgX3Nlc3Npb25SZXNwb25zZVBhc3N3b3JkLCBfc3NvUmVzcG9uc2UsIF91c2VyUmVzcG9uc2UsIH0gZnJvbSAnLi9saWIvZmV0Y2gnO1xuaW1wb3J0IHsgZGVjb2RlSldULCBkZWVwQ2xvbmUsIERlZmVycmVkLCBnZXRBbGdvcml0aG0sIGdldENvZGVDaGFsbGVuZ2VBbmRNZXRob2QsIGdldEl0ZW1Bc3luYywgaXNCcm93c2VyLCBwYXJzZVBhcmFtZXRlcnNGcm9tVVJMLCByZW1vdmVJdGVtQXN5bmMsIHJlc29sdmVGZXRjaCwgcmV0cnlhYmxlLCBzZXRJdGVtQXN5bmMsIHNsZWVwLCBzdXBwb3J0c0xvY2FsU3RvcmFnZSwgdXNlck5vdEF2YWlsYWJsZVByb3h5LCB1dWlkLCB2YWxpZGF0ZUV4cCwgfSBmcm9tICcuL2xpYi9oZWxwZXJzJztcbmltcG9ydCB7IG1lbW9yeUxvY2FsU3RvcmFnZUFkYXB0ZXIgfSBmcm9tICcuL2xpYi9sb2NhbC1zdG9yYWdlJztcbmltcG9ydCB7IExvY2tBY3F1aXJlVGltZW91dEVycm9yLCBuYXZpZ2F0b3JMb2NrIH0gZnJvbSAnLi9saWIvbG9ja3MnO1xuaW1wb3J0IHsgcG9seWZpbGxHbG9iYWxUaGlzIH0gZnJvbSAnLi9saWIvcG9seWZpbGxzJztcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tICcuL2xpYi92ZXJzaW9uJztcbmltcG9ydCB7IGJ5dGVzVG9CYXNlNjRVUkwsIHN0cmluZ1RvVWludDhBcnJheSB9IGZyb20gJy4vbGliL2Jhc2U2NHVybCc7XG5pbXBvcnQgeyBjcmVhdGVTaXdlTWVzc2FnZSwgZnJvbUhleCwgZ2V0QWRkcmVzcywgdG9IZXgsIH0gZnJvbSAnLi9saWIvd2ViMy9ldGhlcmV1bSc7XG5pbXBvcnQgeyBkZXNlcmlhbGl6ZUNyZWRlbnRpYWxDcmVhdGlvbk9wdGlvbnMsIGRlc2VyaWFsaXplQ3JlZGVudGlhbFJlcXVlc3RPcHRpb25zLCBzZXJpYWxpemVDcmVkZW50aWFsQ3JlYXRpb25SZXNwb25zZSwgc2VyaWFsaXplQ3JlZGVudGlhbFJlcXVlc3RSZXNwb25zZSwgV2ViQXV0aG5BcGksIH0gZnJvbSAnLi9saWIvd2ViYXV0aG4nO1xucG9seWZpbGxHbG9iYWxUaGlzKCk7IC8vIE1ha2UgXCJnbG9iYWxUaGlzXCIgYXZhaWxhYmxlXG5jb25zdCBERUZBVUxUX09QVElPTlMgPSB7XG4gICAgdXJsOiBHT1RSVUVfVVJMLFxuICAgIHN0b3JhZ2VLZXk6IFNUT1JBR0VfS0VZLFxuICAgIGF1dG9SZWZyZXNoVG9rZW46IHRydWUsXG4gICAgcGVyc2lzdFNlc3Npb246IHRydWUsXG4gICAgZGV0ZWN0U2Vzc2lvbkluVXJsOiB0cnVlLFxuICAgIGhlYWRlcnM6IERFRkFVTFRfSEVBREVSUyxcbiAgICBmbG93VHlwZTogJ2ltcGxpY2l0JyxcbiAgICBkZWJ1ZzogZmFsc2UsXG4gICAgaGFzQ3VzdG9tQXV0aG9yaXphdGlvbkhlYWRlcjogZmFsc2UsXG59O1xuYXN5bmMgZnVuY3Rpb24gbG9ja05vT3AobmFtZSwgYWNxdWlyZVRpbWVvdXQsIGZuKSB7XG4gICAgcmV0dXJuIGF3YWl0IGZuKCk7XG59XG4vKipcbiAqIENhY2hlcyBKV0tTIHZhbHVlcyBmb3IgYWxsIGNsaWVudHMgY3JlYXRlZCBpbiB0aGUgc2FtZSBlbnZpcm9ubWVudC4gVGhpcyBpc1xuICogZXNwZWNpYWxseSB1c2VmdWwgZm9yIHNoYXJlZC1tZW1vcnkgZXhlY3V0aW9uIGVudmlyb25tZW50cyBzdWNoIGFzIFZlcmNlbCdzXG4gKiBGbHVpZCBDb21wdXRlLCBBV1MgTGFtYmRhIG9yIFN1cGFiYXNlJ3MgRWRnZSBGdW5jdGlvbnMuIFJlZ2FyZGxlc3Mgb2YgaG93XG4gKiBtYW55IGNsaWVudHMgYXJlIGNyZWF0ZWQsIGlmIHRoZXkgc2hhcmUgdGhlIHNhbWUgc3RvcmFnZSBrZXkgdGhleSB3aWxsIHVzZVxuICogdGhlIHNhbWUgSldLUyBjYWNoZSwgc2lnbmlmaWNhbnRseSBzcGVlZGluZyB1cCBnZXRDbGFpbXMoKSB3aXRoIGFzeW1tZXRyaWNcbiAqIEpXVHMuXG4gKi9cbmNvbnN0IEdMT0JBTF9KV0tTID0ge307XG5jbGFzcyBHb1RydWVDbGllbnQge1xuICAgIC8qKlxuICAgICAqIFRoZSBKV0tTIHVzZWQgZm9yIHZlcmlmeWluZyBhc3ltbWV0cmljIEpXVHNcbiAgICAgKi9cbiAgICBnZXQgandrcygpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgcmV0dXJuIChfYiA9IChfYSA9IEdMT0JBTF9KV0tTW3RoaXMuc3RvcmFnZUtleV0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5qd2tzKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB7IGtleXM6IFtdIH07XG4gICAgfVxuICAgIHNldCBqd2tzKHZhbHVlKSB7XG4gICAgICAgIEdMT0JBTF9KV0tTW3RoaXMuc3RvcmFnZUtleV0gPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIEdMT0JBTF9KV0tTW3RoaXMuc3RvcmFnZUtleV0pLCB7IGp3a3M6IHZhbHVlIH0pO1xuICAgIH1cbiAgICBnZXQgandrc19jYWNoZWRfYXQoKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHJldHVybiAoX2IgPSAoX2EgPSBHTE9CQUxfSldLU1t0aGlzLnN0b3JhZ2VLZXldKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FjaGVkQXQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IE51bWJlci5NSU5fU0FGRV9JTlRFR0VSO1xuICAgIH1cbiAgICBzZXQgandrc19jYWNoZWRfYXQodmFsdWUpIHtcbiAgICAgICAgR0xPQkFMX0pXS1NbdGhpcy5zdG9yYWdlS2V5XSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgR0xPQkFMX0pXS1NbdGhpcy5zdG9yYWdlS2V5XSksIHsgY2FjaGVkQXQ6IHZhbHVlIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgY2xpZW50IGZvciB1c2UgaW4gdGhlIGJyb3dzZXIuXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy51c2VyU3RvcmFnZSA9IG51bGw7XG4gICAgICAgIHRoaXMubWVtb3J5U3RvcmFnZSA9IG51bGw7XG4gICAgICAgIHRoaXMuc3RhdGVDaGFuZ2VFbWl0dGVycyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5hdXRvUmVmcmVzaFRpY2tlciA9IG51bGw7XG4gICAgICAgIHRoaXMudmlzaWJpbGl0eUNoYW5nZWRDYWxsYmFjayA9IG51bGw7XG4gICAgICAgIHRoaXMucmVmcmVzaGluZ0RlZmVycmVkID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEtlZXBzIHRyYWNrIG9mIHRoZSBhc3luYyBjbGllbnQgaW5pdGlhbGl6YXRpb24uXG4gICAgICAgICAqIFdoZW4gbnVsbCBvciBub3QgeWV0IHJlc29sdmVkIHRoZSBhdXRoIHN0YXRlIGlzIGB1bmtub3duYFxuICAgICAgICAgKiBPbmNlIHJlc29sdmVkIHRoZSBhdXRoIHN0YXRlIGlzIGtub3duIGFuZCBpdCdzIHNhZmUgdG8gY2FsbCBhbnkgZnVydGhlciBjbGllbnQgbWV0aG9kcy5cbiAgICAgICAgICogS2VlcCBleHRyYSBjYXJlIHRvIG5ldmVyIHJlamVjdCBvciB0aHJvdyB1bmNhdWdodCBlcnJvcnNcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZVByb21pc2UgPSBudWxsO1xuICAgICAgICB0aGlzLmRldGVjdFNlc3Npb25JblVybCA9IHRydWU7XG4gICAgICAgIHRoaXMuaGFzQ3VzdG9tQXV0aG9yaXphdGlvbkhlYWRlciA9IGZhbHNlO1xuICAgICAgICB0aGlzLnN1cHByZXNzR2V0U2Vzc2lvbldhcm5pbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5sb2NrQWNxdWlyZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wZW5kaW5nSW5Mb2NrID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVc2VkIHRvIGJyb2FkY2FzdCBzdGF0ZSBjaGFuZ2UgZXZlbnRzIHRvIG90aGVyIHRhYnMgbGlzdGVuaW5nLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5icm9hZGNhc3RDaGFubmVsID0gbnVsbDtcbiAgICAgICAgdGhpcy5sb2dnZXIgPSBjb25zb2xlLmxvZztcbiAgICAgICAgdGhpcy5pbnN0YW5jZUlEID0gR29UcnVlQ2xpZW50Lm5leHRJbnN0YW5jZUlEO1xuICAgICAgICBHb1RydWVDbGllbnQubmV4dEluc3RhbmNlSUQgKz0gMTtcbiAgICAgICAgaWYgKHRoaXMuaW5zdGFuY2VJRCA+IDAgJiYgaXNCcm93c2VyKCkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignTXVsdGlwbGUgR29UcnVlQ2xpZW50IGluc3RhbmNlcyBkZXRlY3RlZCBpbiB0aGUgc2FtZSBicm93c2VyIGNvbnRleHQuIEl0IGlzIG5vdCBhbiBlcnJvciwgYnV0IHRoaXMgc2hvdWxkIGJlIGF2b2lkZWQgYXMgaXQgbWF5IHByb2R1Y2UgdW5kZWZpbmVkIGJlaGF2aW9yIHdoZW4gdXNlZCBjb25jdXJyZW50bHkgdW5kZXIgdGhlIHNhbWUgc3RvcmFnZSBrZXkuJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIERFRkFVTFRfT1BUSU9OUyksIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmxvZ0RlYnVnTWVzc2FnZXMgPSAhIXNldHRpbmdzLmRlYnVnO1xuICAgICAgICBpZiAodHlwZW9mIHNldHRpbmdzLmRlYnVnID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlciA9IHNldHRpbmdzLmRlYnVnO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGVyc2lzdFNlc3Npb24gPSBzZXR0aW5ncy5wZXJzaXN0U2Vzc2lvbjtcbiAgICAgICAgdGhpcy5zdG9yYWdlS2V5ID0gc2V0dGluZ3Muc3RvcmFnZUtleTtcbiAgICAgICAgdGhpcy5hdXRvUmVmcmVzaFRva2VuID0gc2V0dGluZ3MuYXV0b1JlZnJlc2hUb2tlbjtcbiAgICAgICAgdGhpcy5hZG1pbiA9IG5ldyBHb1RydWVBZG1pbkFwaSh7XG4gICAgICAgICAgICB1cmw6IHNldHRpbmdzLnVybCxcbiAgICAgICAgICAgIGhlYWRlcnM6IHNldHRpbmdzLmhlYWRlcnMsXG4gICAgICAgICAgICBmZXRjaDogc2V0dGluZ3MuZmV0Y2gsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnVybCA9IHNldHRpbmdzLnVybDtcbiAgICAgICAgdGhpcy5oZWFkZXJzID0gc2V0dGluZ3MuaGVhZGVycztcbiAgICAgICAgdGhpcy5mZXRjaCA9IHJlc29sdmVGZXRjaChzZXR0aW5ncy5mZXRjaCk7XG4gICAgICAgIHRoaXMubG9jayA9IHNldHRpbmdzLmxvY2sgfHwgbG9ja05vT3A7XG4gICAgICAgIHRoaXMuZGV0ZWN0U2Vzc2lvbkluVXJsID0gc2V0dGluZ3MuZGV0ZWN0U2Vzc2lvbkluVXJsO1xuICAgICAgICB0aGlzLmZsb3dUeXBlID0gc2V0dGluZ3MuZmxvd1R5cGU7XG4gICAgICAgIHRoaXMuaGFzQ3VzdG9tQXV0aG9yaXphdGlvbkhlYWRlciA9IHNldHRpbmdzLmhhc0N1c3RvbUF1dGhvcml6YXRpb25IZWFkZXI7XG4gICAgICAgIGlmIChzZXR0aW5ncy5sb2NrKSB7XG4gICAgICAgICAgICB0aGlzLmxvY2sgPSBzZXR0aW5ncy5sb2NrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzQnJvd3NlcigpICYmICgoX2EgPSBnbG9iYWxUaGlzID09PSBudWxsIHx8IGdsb2JhbFRoaXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGdsb2JhbFRoaXMubmF2aWdhdG9yKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubG9ja3MpKSB7XG4gICAgICAgICAgICB0aGlzLmxvY2sgPSBuYXZpZ2F0b3JMb2NrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5sb2NrID0gbG9ja05vT3A7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmp3a3MpIHtcbiAgICAgICAgICAgIHRoaXMuandrcyA9IHsga2V5czogW10gfTtcbiAgICAgICAgICAgIHRoaXMuandrc19jYWNoZWRfYXQgPSBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1mYSA9IHtcbiAgICAgICAgICAgIHZlcmlmeTogdGhpcy5fdmVyaWZ5LmJpbmQodGhpcyksXG4gICAgICAgICAgICBlbnJvbGw6IHRoaXMuX2Vucm9sbC5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgdW5lbnJvbGw6IHRoaXMuX3VuZW5yb2xsLmJpbmQodGhpcyksXG4gICAgICAgICAgICBjaGFsbGVuZ2U6IHRoaXMuX2NoYWxsZW5nZS5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgbGlzdEZhY3RvcnM6IHRoaXMuX2xpc3RGYWN0b3JzLmJpbmQodGhpcyksXG4gICAgICAgICAgICBjaGFsbGVuZ2VBbmRWZXJpZnk6IHRoaXMuX2NoYWxsZW5nZUFuZFZlcmlmeS5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgZ2V0QXV0aGVudGljYXRvckFzc3VyYW5jZUxldmVsOiB0aGlzLl9nZXRBdXRoZW50aWNhdG9yQXNzdXJhbmNlTGV2ZWwuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIHdlYmF1dGhuOiBuZXcgV2ViQXV0aG5BcGkodGhpcyksXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLnBlcnNpc3RTZXNzaW9uKSB7XG4gICAgICAgICAgICBpZiAoc2V0dGluZ3Muc3RvcmFnZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RvcmFnZSA9IHNldHRpbmdzLnN0b3JhZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoc3VwcG9ydHNMb2NhbFN0b3JhZ2UoKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0b3JhZ2UgPSBnbG9iYWxUaGlzLmxvY2FsU3RvcmFnZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWVtb3J5U3RvcmFnZSA9IHt9O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0b3JhZ2UgPSBtZW1vcnlMb2NhbFN0b3JhZ2VBZGFwdGVyKHRoaXMubWVtb3J5U3RvcmFnZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNldHRpbmdzLnVzZXJTdG9yYWdlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51c2VyU3RvcmFnZSA9IHNldHRpbmdzLnVzZXJTdG9yYWdlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5tZW1vcnlTdG9yYWdlID0ge307XG4gICAgICAgICAgICB0aGlzLnN0b3JhZ2UgPSBtZW1vcnlMb2NhbFN0b3JhZ2VBZGFwdGVyKHRoaXMubWVtb3J5U3RvcmFnZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQnJvd3NlcigpICYmIGdsb2JhbFRoaXMuQnJvYWRjYXN0Q2hhbm5lbCAmJiB0aGlzLnBlcnNpc3RTZXNzaW9uICYmIHRoaXMuc3RvcmFnZUtleSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0aGlzLmJyb2FkY2FzdENoYW5uZWwgPSBuZXcgZ2xvYmFsVGhpcy5Ccm9hZGNhc3RDaGFubmVsKHRoaXMuc3RvcmFnZUtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBjcmVhdGUgYSBuZXcgQnJvYWRjYXN0Q2hhbm5lbCwgbXVsdGktdGFiIHN0YXRlIGNoYW5nZXMgd2lsbCBub3QgYmUgYXZhaWxhYmxlJywgZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAoX2IgPSB0aGlzLmJyb2FkY2FzdENoYW5uZWwpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgYXN5bmMgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGVidWcoJ3JlY2VpdmVkIGJyb2FkY2FzdCBub3RpZmljYXRpb24gZnJvbSBvdGhlciB0YWIgb3IgY2xpZW50JywgZXZlbnQpO1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX25vdGlmeUFsbFN1YnNjcmliZXJzKGV2ZW50LmRhdGEuZXZlbnQsIGV2ZW50LmRhdGEuc2Vzc2lvbiwgZmFsc2UpOyAvLyBicm9hZGNhc3QgPSBmYWxzZSBzbyB3ZSBkb24ndCBnZXQgYW4gZW5kbGVzcyBsb29wIG9mIG1lc3NhZ2VzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmluaXRpYWxpemUoKTtcbiAgICB9XG4gICAgX2RlYnVnKC4uLmFyZ3MpIHtcbiAgICAgICAgaWYgKHRoaXMubG9nRGVidWdNZXNzYWdlcykge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIoYEdvVHJ1ZUNsaWVudEAke3RoaXMuaW5zdGFuY2VJRH0gKCR7dmVyc2lvbn0pICR7bmV3IERhdGUoKS50b0lTT1N0cmluZygpfWAsIC4uLmFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyB0aGUgY2xpZW50IHNlc3Npb24gZWl0aGVyIGZyb20gdGhlIHVybCBvciBmcm9tIHN0b3JhZ2UuXG4gICAgICogVGhpcyBtZXRob2QgaXMgYXV0b21hdGljYWxseSBjYWxsZWQgd2hlbiBpbnN0YW50aWF0aW5nIHRoZSBjbGllbnQsIGJ1dCBzaG91bGQgYWxzbyBiZSBjYWxsZWRcbiAgICAgKiBtYW51YWxseSB3aGVuIGNoZWNraW5nIGZvciBhbiBlcnJvciBmcm9tIGFuIGF1dGggcmVkaXJlY3QgKG9hdXRoLCBtYWdpY2xpbmssIHBhc3N3b3JkIHJlY292ZXJ5LCBldGMpLlxuICAgICAqL1xuICAgIGFzeW5jIGluaXRpYWxpemUoKSB7XG4gICAgICAgIGlmICh0aGlzLmluaXRpYWxpemVQcm9taXNlKSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5pbml0aWFsaXplUHJvbWlzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmluaXRpYWxpemVQcm9taXNlID0gKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9hY3F1aXJlTG9jaygtMSwgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9pbml0aWFsaXplKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSkoKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuaW5pdGlhbGl6ZVByb21pc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElNUE9SVEFOVDpcbiAgICAgKiAxLiBOZXZlciB0aHJvdyBpbiB0aGlzIG1ldGhvZCwgYXMgaXQgaXMgY2FsbGVkIGZyb20gdGhlIGNvbnN0cnVjdG9yXG4gICAgICogMi4gTmV2ZXIgcmV0dXJuIGEgc2Vzc2lvbiBmcm9tIHRoaXMgbWV0aG9kIGFzIGl0IHdvdWxkIGJlIGNhY2hlZCBvdmVyXG4gICAgICogICAgdGhlIHdob2xlIGxpZmV0aW1lIG9mIHRoZSBjbGllbnRcbiAgICAgKi9cbiAgICBhc3luYyBfaW5pdGlhbGl6ZSgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcGFyYW1zID0gcGFyc2VQYXJhbWV0ZXJzRnJvbVVSTCh3aW5kb3cubG9jYXRpb24uaHJlZik7XG4gICAgICAgICAgICBsZXQgY2FsbGJhY2tVcmxUeXBlID0gJ25vbmUnO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2lzSW1wbGljaXRHcmFudENhbGxiYWNrKHBhcmFtcykpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFja1VybFR5cGUgPSAnaW1wbGljaXQnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYXdhaXQgdGhpcy5faXNQS0NFQ2FsbGJhY2socGFyYW1zKSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrVXJsVHlwZSA9ICdwa2NlJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQXR0ZW1wdCB0byBnZXQgdGhlIHNlc3Npb24gZnJvbSB0aGUgVVJMIG9ubHkgaWYgdGhlc2UgY29uZGl0aW9ucyBhcmUgZnVsZmlsbGVkXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogTm90ZTogSWYgdGhlIFVSTCBpc24ndCBvbmUgb2YgdGhlIGNhbGxiYWNrIHVybCB0eXBlcyAoaW1wbGljaXQgb3IgcGtjZSksXG4gICAgICAgICAgICAgKiB0aGVuIHRoZXJlIGNvdWxkIGJlIGFuIGV4aXN0aW5nIHNlc3Npb24gc28gd2UgZG9uJ3Qgd2FudCB0byBwcmVtYXR1cmVseSByZW1vdmUgaXRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKGlzQnJvd3NlcigpICYmIHRoaXMuZGV0ZWN0U2Vzc2lvbkluVXJsICYmIGNhbGxiYWNrVXJsVHlwZSAhPT0gJ25vbmUnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgdGhpcy5fZ2V0U2Vzc2lvbkZyb21VUkwocGFyYW1zLCBjYWxsYmFja1VybFR5cGUpO1xuICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kZWJ1ZygnI19pbml0aWFsaXplKCknLCAnZXJyb3IgZGV0ZWN0aW5nIHNlc3Npb24gZnJvbSBVUkwnLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0F1dGhJbXBsaWNpdEdyYW50UmVkaXJlY3RFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yQ29kZSA9IChfYSA9IGVycm9yLmRldGFpbHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yQ29kZSA9PT0gJ2lkZW50aXR5X2FscmVhZHlfZXhpc3RzJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yQ29kZSA9PT0gJ2lkZW50aXR5X25vdF9mb3VuZCcgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvckNvZGUgPT09ICdzaW5nbGVfaWRlbnRpdHlfbm90X2RlbGV0YWJsZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBlcnJvciB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIGZhaWxlZCBsb2dpbiBhdHRlbXB0IHZpYSB1cmwsXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBvbGQgc2Vzc2lvbiBhcyBpbiB2ZXJpZnlPdHAsIHNpZ25VcCBhbmQgc2lnbkluV2l0aCpcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fcmVtb3ZlU2Vzc2lvbigpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBlcnJvciB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB7IHNlc3Npb24sIHJlZGlyZWN0VHlwZSB9ID0gZGF0YTtcbiAgICAgICAgICAgICAgICB0aGlzLl9kZWJ1ZygnI19pbml0aWFsaXplKCknLCAnZGV0ZWN0ZWQgc2Vzc2lvbiBpbiBVUkwnLCBzZXNzaW9uLCAncmVkaXJlY3QgdHlwZScsIHJlZGlyZWN0VHlwZSk7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fc2F2ZVNlc3Npb24oc2Vzc2lvbik7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWRpcmVjdFR5cGUgPT09ICdyZWNvdmVyeScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX25vdGlmeUFsbFN1YnNjcmliZXJzKCdQQVNTV09SRF9SRUNPVkVSWScsIHNlc3Npb24pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fbm90aWZ5QWxsU3Vic2NyaWJlcnMoJ1NJR05FRF9JTicsIHNlc3Npb24pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZXJyb3I6IG51bGwgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIG5vIGxvZ2luIGF0dGVtcHQgdmlhIGNhbGxiYWNrIHVybCB0cnkgdG8gcmVjb3ZlciBzZXNzaW9uIGZyb20gc3RvcmFnZVxuICAgICAgICAgICAgYXdhaXQgdGhpcy5fcmVjb3ZlckFuZFJlZnJlc2goKTtcbiAgICAgICAgICAgIHJldHVybiB7IGVycm9yOiBudWxsIH07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZXJyb3I6IG5ldyBBdXRoVW5rbm93bkVycm9yKCdVbmV4cGVjdGVkIGVycm9yIGR1cmluZyBpbml0aWFsaXphdGlvbicsIGVycm9yKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9oYW5kbGVWaXNpYmlsaXR5Q2hhbmdlKCk7XG4gICAgICAgICAgICB0aGlzLl9kZWJ1ZygnI19pbml0aWFsaXplKCknLCAnZW5kJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBhbm9ueW1vdXMgdXNlci5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEgc2Vzc2lvbiB3aGVyZSB0aGUgaXNfYW5vbnltb3VzIGNsYWltIGluIHRoZSBhY2Nlc3MgdG9rZW4gSldUIHNldCB0byB0cnVlXG4gICAgICovXG4gICAgYXN5bmMgc2lnbkluQW5vbnltb3VzbHkoY3JlZGVudGlhbHMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnUE9TVCcsIGAke3RoaXMudXJsfS9zaWdudXBgLCB7XG4gICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogKF9iID0gKF9hID0gY3JlZGVudGlhbHMgPT09IG51bGwgfHwgY3JlZGVudGlhbHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNyZWRlbnRpYWxzLm9wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kYXRhKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgZ290cnVlX21ldGFfc2VjdXJpdHk6IHsgY2FwdGNoYV90b2tlbjogKF9jID0gY3JlZGVudGlhbHMgPT09IG51bGwgfHwgY3JlZGVudGlhbHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNyZWRlbnRpYWxzLm9wdGlvbnMpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5jYXB0Y2hhVG9rZW4gfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHhmb3JtOiBfc2Vzc2lvblJlc3BvbnNlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSByZXM7XG4gICAgICAgICAgICBpZiAoZXJyb3IgfHwgIWRhdGEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwgfSwgZXJyb3I6IGVycm9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzZXNzaW9uID0gZGF0YS5zZXNzaW9uO1xuICAgICAgICAgICAgY29uc3QgdXNlciA9IGRhdGEudXNlcjtcbiAgICAgICAgICAgIGlmIChkYXRhLnNlc3Npb24pIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9zYXZlU2Vzc2lvbihkYXRhLnNlc3Npb24pO1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX25vdGlmeUFsbFN1YnNjcmliZXJzKCdTSUdORURfSU4nLCBzZXNzaW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlciwgc2Vzc2lvbiB9LCBlcnJvcjogbnVsbCB9O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyB1c2VyLlxuICAgICAqXG4gICAgICogQmUgYXdhcmUgdGhhdCBpZiBhIHVzZXIgYWNjb3VudCBleGlzdHMgaW4gdGhlIHN5c3RlbSB5b3UgbWF5IGdldCBiYWNrIGFuXG4gICAgICogZXJyb3IgbWVzc2FnZSB0aGF0IGF0dGVtcHRzIHRvIGhpZGUgdGhpcyBpbmZvcm1hdGlvbiBmcm9tIHRoZSB1c2VyLlxuICAgICAqIFRoaXMgbWV0aG9kIGhhcyBzdXBwb3J0IGZvciBQS0NFIHZpYSBlbWFpbCBzaWdudXBzLiBUaGUgUEtDRSBmbG93IGNhbm5vdCBiZSB1c2VkIHdoZW4gYXV0b2NvbmZpcm0gaXMgZW5hYmxlZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEgbG9nZ2VkLWluIHNlc3Npb24gaWYgdGhlIHNlcnZlciBoYXMgXCJhdXRvY29uZmlybVwiIE9OXG4gICAgICogQHJldHVybnMgQSB1c2VyIGlmIHRoZSBzZXJ2ZXIgaGFzIFwiYXV0b2NvbmZpcm1cIiBPRkZcbiAgICAgKi9cbiAgICBhc3luYyBzaWduVXAoY3JlZGVudGlhbHMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsZXQgcmVzO1xuICAgICAgICAgICAgaWYgKCdlbWFpbCcgaW4gY3JlZGVudGlhbHMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGVtYWlsLCBwYXNzd29yZCwgb3B0aW9ucyB9ID0gY3JlZGVudGlhbHM7XG4gICAgICAgICAgICAgICAgbGV0IGNvZGVDaGFsbGVuZ2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIGxldCBjb2RlQ2hhbGxlbmdlTWV0aG9kID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5mbG93VHlwZSA9PT0gJ3BrY2UnKSB7XG4gICAgICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICAgICAgW2NvZGVDaGFsbGVuZ2UsIGNvZGVDaGFsbGVuZ2VNZXRob2RdID0gYXdhaXQgZ2V0Q29kZUNoYWxsZW5nZUFuZE1ldGhvZCh0aGlzLnN0b3JhZ2UsIHRoaXMuc3RvcmFnZUtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlcyA9IGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L3NpZ251cGAsIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICByZWRpcmVjdFRvOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZW1haWxSZWRpcmVjdFRvLFxuICAgICAgICAgICAgICAgICAgICBib2R5OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbWFpbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhc3N3b3JkLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmRhdGEpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgZ290cnVlX21ldGFfc2VjdXJpdHk6IHsgY2FwdGNoYV90b2tlbjogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmNhcHRjaGFUb2tlbiB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZV9jaGFsbGVuZ2U6IGNvZGVDaGFsbGVuZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlX2NoYWxsZW5nZV9tZXRob2Q6IGNvZGVDaGFsbGVuZ2VNZXRob2QsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHhmb3JtOiBfc2Vzc2lvblJlc3BvbnNlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoJ3Bob25lJyBpbiBjcmVkZW50aWFscykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgcGhvbmUsIHBhc3N3b3JkLCBvcHRpb25zIH0gPSBjcmVkZW50aWFscztcbiAgICAgICAgICAgICAgICByZXMgPSBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnUE9TVCcsIGAke3RoaXMudXJsfS9zaWdudXBgLCB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgYm9keToge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGhvbmUsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXNzd29yZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IChfYiA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5kYXRhKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5uZWw6IChfYyA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5jaGFubmVsKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiAnc21zJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdvdHJ1ZV9tZXRhX3NlY3VyaXR5OiB7IGNhcHRjaGFfdG9rZW46IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5jYXB0Y2hhVG9rZW4gfSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgeGZvcm06IF9zZXNzaW9uUmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXV0aEludmFsaWRDcmVkZW50aWFsc0Vycm9yKCdZb3UgbXVzdCBwcm92aWRlIGVpdGhlciBhbiBlbWFpbCBvciBwaG9uZSBudW1iZXIgYW5kIGEgcGFzc3dvcmQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IHJlcztcbiAgICAgICAgICAgIGlmIChlcnJvciB8fCAhZGF0YSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvcjogZXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHNlc3Npb24gPSBkYXRhLnNlc3Npb247XG4gICAgICAgICAgICBjb25zdCB1c2VyID0gZGF0YS51c2VyO1xuICAgICAgICAgICAgaWYgKGRhdGEuc2Vzc2lvbikge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX3NhdmVTZXNzaW9uKGRhdGEuc2Vzc2lvbik7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fbm90aWZ5QWxsU3Vic2NyaWJlcnMoJ1NJR05FRF9JTicsIHNlc3Npb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyLCBzZXNzaW9uIH0sIGVycm9yOiBudWxsIH07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb2cgaW4gYW4gZXhpc3RpbmcgdXNlciB3aXRoIGFuIGVtYWlsIGFuZCBwYXNzd29yZCBvciBwaG9uZSBhbmQgcGFzc3dvcmQuXG4gICAgICpcbiAgICAgKiBCZSBhd2FyZSB0aGF0IHlvdSBtYXkgZ2V0IGJhY2sgYW4gZXJyb3IgbWVzc2FnZSB0aGF0IHdpbGwgbm90IGRpc3Rpbmd1aXNoXG4gICAgICogYmV0d2VlbiB0aGUgY2FzZXMgd2hlcmUgdGhlIGFjY291bnQgZG9lcyBub3QgZXhpc3Qgb3IgdGhhdCB0aGVcbiAgICAgKiBlbWFpbC9waG9uZSBhbmQgcGFzc3dvcmQgY29tYmluYXRpb24gaXMgd3Jvbmcgb3IgdGhhdCB0aGUgYWNjb3VudCBjYW4gb25seVxuICAgICAqIGJlIGFjY2Vzc2VkIHZpYSBzb2NpYWwgbG9naW4uXG4gICAgICovXG4gICAgYXN5bmMgc2lnbkluV2l0aFBhc3N3b3JkKGNyZWRlbnRpYWxzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsZXQgcmVzO1xuICAgICAgICAgICAgaWYgKCdlbWFpbCcgaW4gY3JlZGVudGlhbHMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGVtYWlsLCBwYXNzd29yZCwgb3B0aW9ucyB9ID0gY3JlZGVudGlhbHM7XG4gICAgICAgICAgICAgICAgcmVzID0gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ1BPU1QnLCBgJHt0aGlzLnVybH0vdG9rZW4/Z3JhbnRfdHlwZT1wYXNzd29yZGAsIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICBib2R5OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbWFpbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhc3N3b3JkLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ290cnVlX21ldGFfc2VjdXJpdHk6IHsgY2FwdGNoYV90b2tlbjogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmNhcHRjaGFUb2tlbiB9LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB4Zm9ybTogX3Nlc3Npb25SZXNwb25zZVBhc3N3b3JkLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoJ3Bob25lJyBpbiBjcmVkZW50aWFscykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgcGhvbmUsIHBhc3N3b3JkLCBvcHRpb25zIH0gPSBjcmVkZW50aWFscztcbiAgICAgICAgICAgICAgICByZXMgPSBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnUE9TVCcsIGAke3RoaXMudXJsfS90b2tlbj9ncmFudF90eXBlPXBhc3N3b3JkYCwge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBob25lLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFzc3dvcmQsXG4gICAgICAgICAgICAgICAgICAgICAgICBnb3RydWVfbWV0YV9zZWN1cml0eTogeyBjYXB0Y2hhX3Rva2VuOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY2FwdGNoYVRva2VuIH0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHhmb3JtOiBfc2Vzc2lvblJlc3BvbnNlUGFzc3dvcmQsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXV0aEludmFsaWRDcmVkZW50aWFsc0Vycm9yKCdZb3UgbXVzdCBwcm92aWRlIGVpdGhlciBhbiBlbWFpbCBvciBwaG9uZSBudW1iZXIgYW5kIGEgcGFzc3dvcmQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IHJlcztcbiAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIWRhdGEgfHwgIWRhdGEuc2Vzc2lvbiB8fCAhZGF0YS51c2VyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yOiBuZXcgQXV0aEludmFsaWRUb2tlblJlc3BvbnNlRXJyb3IoKSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRhdGEuc2Vzc2lvbikge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX3NhdmVTZXNzaW9uKGRhdGEuc2Vzc2lvbik7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fbm90aWZ5QWxsU3Vic2NyaWJlcnMoJ1NJR05FRF9JTicsIGRhdGEuc2Vzc2lvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGRhdGE6IE9iamVjdC5hc3NpZ24oeyB1c2VyOiBkYXRhLnVzZXIsIHNlc3Npb246IGRhdGEuc2Vzc2lvbiB9LCAoZGF0YS53ZWFrX3Bhc3N3b3JkID8geyB3ZWFrUGFzc3dvcmQ6IGRhdGEud2Vha19wYXNzd29yZCB9IDogbnVsbCkpLFxuICAgICAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwgfSwgZXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvZyBpbiBhbiBleGlzdGluZyB1c2VyIHZpYSBhIHRoaXJkLXBhcnR5IHByb3ZpZGVyLlxuICAgICAqIFRoaXMgbWV0aG9kIHN1cHBvcnRzIHRoZSBQS0NFIGZsb3cuXG4gICAgICovXG4gICAgYXN5bmMgc2lnbkluV2l0aE9BdXRoKGNyZWRlbnRpYWxzKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX2hhbmRsZVByb3ZpZGVyU2lnbkluKGNyZWRlbnRpYWxzLnByb3ZpZGVyLCB7XG4gICAgICAgICAgICByZWRpcmVjdFRvOiAoX2EgPSBjcmVkZW50aWFscy5vcHRpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVkaXJlY3RUbyxcbiAgICAgICAgICAgIHNjb3BlczogKF9iID0gY3JlZGVudGlhbHMub3B0aW9ucykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnNjb3BlcyxcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiAoX2MgPSBjcmVkZW50aWFscy5vcHRpb25zKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MucXVlcnlQYXJhbXMsXG4gICAgICAgICAgICBza2lwQnJvd3NlclJlZGlyZWN0OiAoX2QgPSBjcmVkZW50aWFscy5vcHRpb25zKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Quc2tpcEJyb3dzZXJSZWRpcmVjdCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvZyBpbiBhbiBleGlzdGluZyB1c2VyIGJ5IGV4Y2hhbmdpbmcgYW4gQXV0aCBDb2RlIGlzc3VlZCBkdXJpbmcgdGhlIFBLQ0UgZmxvdy5cbiAgICAgKi9cbiAgICBhc3luYyBleGNoYW5nZUNvZGVGb3JTZXNzaW9uKGF1dGhDb2RlKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuaW5pdGlhbGl6ZVByb21pc2U7XG4gICAgICAgIHJldHVybiB0aGlzLl9hY3F1aXJlTG9jaygtMSwgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2V4Y2hhbmdlQ29kZUZvclNlc3Npb24oYXV0aENvZGUpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2lnbnMgaW4gYSB1c2VyIGJ5IHZlcmlmeWluZyBhIG1lc3NhZ2Ugc2lnbmVkIGJ5IHRoZSB1c2VyJ3MgcHJpdmF0ZSBrZXkuXG4gICAgICogU3VwcG9ydHMgRXRoZXJldW0gKHZpYSBTaWduLUluLVdpdGgtRXRoZXJldW0pICYgU29sYW5hIChTaWduLUluLVdpdGgtU29sYW5hKSBzdGFuZGFyZHMsXG4gICAgICogYm90aCBvZiB3aGljaCBkZXJpdmUgZnJvbSB0aGUgRUlQLTQzNjEgc3RhbmRhcmRcbiAgICAgKiBXaXRoIHNsaWdodCB2YXJpYXRpb24gb24gU29sYW5hJ3Mgc2lkZS5cbiAgICAgKiBAcmVmZXJlbmNlIGh0dHBzOi8vZWlwcy5ldGhlcmV1bS5vcmcvRUlQUy9laXAtNDM2MVxuICAgICAqL1xuICAgIGFzeW5jIHNpZ25JbldpdGhXZWIzKGNyZWRlbnRpYWxzKSB7XG4gICAgICAgIGNvbnN0IHsgY2hhaW4gfSA9IGNyZWRlbnRpYWxzO1xuICAgICAgICBzd2l0Y2ggKGNoYWluKSB7XG4gICAgICAgICAgICBjYXNlICdldGhlcmV1bSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuc2lnbkluV2l0aEV0aGVyZXVtKGNyZWRlbnRpYWxzKTtcbiAgICAgICAgICAgIGNhc2UgJ3NvbGFuYSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuc2lnbkluV2l0aFNvbGFuYShjcmVkZW50aWFscyk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQHN1cGFiYXNlL2F1dGgtanM6IFVuc3VwcG9ydGVkIGNoYWluIFwiJHtjaGFpbn1cImApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHNpZ25JbldpdGhFdGhlcmV1bShjcmVkZW50aWFscykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oLCBfaiwgX2ssIF9sO1xuICAgICAgICAvLyBUT0RPOiBmbGF0dGVuIHR5cGVcbiAgICAgICAgbGV0IG1lc3NhZ2U7XG4gICAgICAgIGxldCBzaWduYXR1cmU7XG4gICAgICAgIGlmICgnbWVzc2FnZScgaW4gY3JlZGVudGlhbHMpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBjcmVkZW50aWFscy5tZXNzYWdlO1xuICAgICAgICAgICAgc2lnbmF0dXJlID0gY3JlZGVudGlhbHMuc2lnbmF0dXJlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgeyBjaGFpbiwgd2FsbGV0LCBzdGF0ZW1lbnQsIG9wdGlvbnMgfSA9IGNyZWRlbnRpYWxzO1xuICAgICAgICAgICAgbGV0IHJlc29sdmVkV2FsbGV0O1xuICAgICAgICAgICAgaWYgKCFpc0Jyb3dzZXIoKSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygd2FsbGV0ICE9PSAnb2JqZWN0JyB8fCAhKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy51cmwpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQHN1cGFiYXNlL2F1dGgtanM6IEJvdGggd2FsbGV0IGFuZCB1cmwgbXVzdCBiZSBzcGVjaWZpZWQgaW4gbm9uLWJyb3dzZXIgZW52aXJvbm1lbnRzLicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXNvbHZlZFdhbGxldCA9IHdhbGxldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB3YWxsZXQgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZWRXYWxsZXQgPSB3YWxsZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCB3aW5kb3dBbnkgPSB3aW5kb3c7XG4gICAgICAgICAgICAgICAgaWYgKCdldGhlcmV1bScgaW4gd2luZG93QW55ICYmXG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiB3aW5kb3dBbnkuZXRoZXJldW0gPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICAgICAgICAgICdyZXF1ZXN0JyBpbiB3aW5kb3dBbnkuZXRoZXJldW0gJiZcbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHdpbmRvd0FueS5ldGhlcmV1bS5yZXF1ZXN0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmVkV2FsbGV0ID0gd2luZG93QW55LmV0aGVyZXVtO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBAc3VwYWJhc2UvYXV0aC1qczogTm8gY29tcGF0aWJsZSBFdGhlcmV1bSB3YWxsZXQgaW50ZXJmYWNlIG9uIHRoZSB3aW5kb3cgb2JqZWN0ICh3aW5kb3cuZXRoZXJldW0pIGRldGVjdGVkLiBNYWtlIHN1cmUgdGhlIHVzZXIgYWxyZWFkeSBoYXMgYSB3YWxsZXQgaW5zdGFsbGVkIGFuZCBjb25uZWN0ZWQgZm9yIHRoaXMgYXBwLiBQcmVmZXIgcGFzc2luZyB0aGUgd2FsbGV0IGludGVyZmFjZSBvYmplY3QgZGlyZWN0bHkgdG8gc2lnbkluV2l0aFdlYjMoeyBjaGFpbjogJ2V0aGVyZXVtJywgd2FsbGV0OiByZXNvbHZlZFVzZXJXYWxsZXQgfSkgaW5zdGVhZC5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB1cmwgPSBuZXcgVVJMKChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy51cmwpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHdpbmRvdy5sb2NhdGlvbi5ocmVmKTtcbiAgICAgICAgICAgIGNvbnN0IGFjY291bnRzID0gYXdhaXQgcmVzb2x2ZWRXYWxsZXRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnZXRoX3JlcXVlc3RBY2NvdW50cycsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChhY2NzKSA9PiBhY2NzKVxuICAgICAgICAgICAgICAgIC5jYXRjaCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBAc3VwYWJhc2UvYXV0aC1qczogV2FsbGV0IG1ldGhvZCBldGhfcmVxdWVzdEFjY291bnRzIGlzIG1pc3Npbmcgb3IgaW52YWxpZGApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoIWFjY291bnRzIHx8IGFjY291bnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQHN1cGFiYXNlL2F1dGgtanM6IE5vIGFjY291bnRzIGF2YWlsYWJsZS4gUGxlYXNlIGVuc3VyZSB0aGUgd2FsbGV0IGlzIGNvbm5lY3RlZC5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGFkZHJlc3MgPSBnZXRBZGRyZXNzKGFjY291bnRzWzBdKTtcbiAgICAgICAgICAgIGxldCBjaGFpbklkID0gKF9iID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNpZ25JbldpdGhFdGhlcmV1bSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNoYWluSWQ7XG4gICAgICAgICAgICBpZiAoIWNoYWluSWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGFpbklkSGV4ID0gYXdhaXQgcmVzb2x2ZWRXYWxsZXQucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJ2V0aF9jaGFpbklkJyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjaGFpbklkID0gZnJvbUhleChjaGFpbklkSGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHNpd2VNZXNzYWdlID0ge1xuICAgICAgICAgICAgICAgIGRvbWFpbjogdXJsLmhvc3QsXG4gICAgICAgICAgICAgICAgYWRkcmVzczogYWRkcmVzcyxcbiAgICAgICAgICAgICAgICBzdGF0ZW1lbnQ6IHN0YXRlbWVudCxcbiAgICAgICAgICAgICAgICB1cmk6IHVybC5ocmVmLFxuICAgICAgICAgICAgICAgIHZlcnNpb246ICcxJyxcbiAgICAgICAgICAgICAgICBjaGFpbklkOiBjaGFpbklkLFxuICAgICAgICAgICAgICAgIG5vbmNlOiAoX2MgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc2lnbkluV2l0aEV0aGVyZXVtKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Mubm9uY2UsXG4gICAgICAgICAgICAgICAgaXNzdWVkQXQ6IChfZSA9IChfZCA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5zaWduSW5XaXRoRXRoZXJldW0pID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5pc3N1ZWRBdCkgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogbmV3IERhdGUoKSxcbiAgICAgICAgICAgICAgICBleHBpcmF0aW9uVGltZTogKF9mID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNpZ25JbldpdGhFdGhlcmV1bSkgPT09IG51bGwgfHwgX2YgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mLmV4cGlyYXRpb25UaW1lLFxuICAgICAgICAgICAgICAgIG5vdEJlZm9yZTogKF9nID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNpZ25JbldpdGhFdGhlcmV1bSkgPT09IG51bGwgfHwgX2cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9nLm5vdEJlZm9yZSxcbiAgICAgICAgICAgICAgICByZXF1ZXN0SWQ6IChfaCA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5zaWduSW5XaXRoRXRoZXJldW0pID09PSBudWxsIHx8IF9oID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfaC5yZXF1ZXN0SWQsXG4gICAgICAgICAgICAgICAgcmVzb3VyY2VzOiAoX2ogPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc2lnbkluV2l0aEV0aGVyZXVtKSA9PT0gbnVsbCB8fCBfaiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2oucmVzb3VyY2VzLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBjcmVhdGVTaXdlTWVzc2FnZShzaXdlTWVzc2FnZSk7XG4gICAgICAgICAgICAvLyBTaWduIG1lc3NhZ2VcbiAgICAgICAgICAgIHNpZ25hdHVyZSA9IChhd2FpdCByZXNvbHZlZFdhbGxldC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdwZXJzb25hbF9zaWduJyxcbiAgICAgICAgICAgICAgICBwYXJhbXM6IFt0b0hleChtZXNzYWdlKSwgYWRkcmVzc10sXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L3Rva2VuP2dyYW50X3R5cGU9d2ViM2AsIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogT2JqZWN0LmFzc2lnbih7IGNoYWluOiAnZXRoZXJldW0nLCBtZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICBzaWduYXR1cmUgfSwgKCgoX2sgPSBjcmVkZW50aWFscy5vcHRpb25zKSA9PT0gbnVsbCB8fCBfayA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2suY2FwdGNoYVRva2VuKVxuICAgICAgICAgICAgICAgICAgICA/IHsgZ290cnVlX21ldGFfc2VjdXJpdHk6IHsgY2FwdGNoYV90b2tlbjogKF9sID0gY3JlZGVudGlhbHMub3B0aW9ucykgPT09IG51bGwgfHwgX2wgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9sLmNhcHRjaGFUb2tlbiB9IH1cbiAgICAgICAgICAgICAgICAgICAgOiBudWxsKSksXG4gICAgICAgICAgICAgICAgeGZvcm06IF9zZXNzaW9uUmVzcG9uc2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFkYXRhIHx8ICFkYXRhLnNlc3Npb24gfHwgIWRhdGEudXNlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LFxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogbmV3IEF1dGhJbnZhbGlkVG9rZW5SZXNwb25zZUVycm9yKCksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkYXRhLnNlc3Npb24pIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9zYXZlU2Vzc2lvbihkYXRhLnNlc3Npb24pO1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX25vdGlmeUFsbFN1YnNjcmliZXJzKCdTSUdORURfSU4nLCBkYXRhLnNlc3Npb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogT2JqZWN0LmFzc2lnbih7fSwgZGF0YSksIGVycm9yIH07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBzaWduSW5XaXRoU29sYW5hKGNyZWRlbnRpYWxzKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZywgX2gsIF9qLCBfaywgX2wsIF9tO1xuICAgICAgICBsZXQgbWVzc2FnZTtcbiAgICAgICAgbGV0IHNpZ25hdHVyZTtcbiAgICAgICAgaWYgKCdtZXNzYWdlJyBpbiBjcmVkZW50aWFscykge1xuICAgICAgICAgICAgbWVzc2FnZSA9IGNyZWRlbnRpYWxzLm1lc3NhZ2U7XG4gICAgICAgICAgICBzaWduYXR1cmUgPSBjcmVkZW50aWFscy5zaWduYXR1cmU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCB7IGNoYWluLCB3YWxsZXQsIHN0YXRlbWVudCwgb3B0aW9ucyB9ID0gY3JlZGVudGlhbHM7XG4gICAgICAgICAgICBsZXQgcmVzb2x2ZWRXYWxsZXQ7XG4gICAgICAgICAgICBpZiAoIWlzQnJvd3NlcigpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB3YWxsZXQgIT09ICdvYmplY3QnIHx8ICEob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnVybCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdAc3VwYWJhc2UvYXV0aC1qczogQm90aCB3YWxsZXQgYW5kIHVybCBtdXN0IGJlIHNwZWNpZmllZCBpbiBub24tYnJvd3NlciBlbnZpcm9ubWVudHMuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc29sdmVkV2FsbGV0ID0gd2FsbGV0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHdhbGxldCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlZFdhbGxldCA9IHdhbGxldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHdpbmRvd0FueSA9IHdpbmRvdztcbiAgICAgICAgICAgICAgICBpZiAoJ3NvbGFuYScgaW4gd2luZG93QW55ICYmXG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiB3aW5kb3dBbnkuc29sYW5hID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgICAgICAgICAoKCdzaWduSW4nIGluIHdpbmRvd0FueS5zb2xhbmEgJiYgdHlwZW9mIHdpbmRvd0FueS5zb2xhbmEuc2lnbkluID09PSAnZnVuY3Rpb24nKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKCdzaWduTWVzc2FnZScgaW4gd2luZG93QW55LnNvbGFuYSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiB3aW5kb3dBbnkuc29sYW5hLnNpZ25NZXNzYWdlID09PSAnZnVuY3Rpb24nKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZWRXYWxsZXQgPSB3aW5kb3dBbnkuc29sYW5hO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBAc3VwYWJhc2UvYXV0aC1qczogTm8gY29tcGF0aWJsZSBTb2xhbmEgd2FsbGV0IGludGVyZmFjZSBvbiB0aGUgd2luZG93IG9iamVjdCAod2luZG93LnNvbGFuYSkgZGV0ZWN0ZWQuIE1ha2Ugc3VyZSB0aGUgdXNlciBhbHJlYWR5IGhhcyBhIHdhbGxldCBpbnN0YWxsZWQgYW5kIGNvbm5lY3RlZCBmb3IgdGhpcyBhcHAuIFByZWZlciBwYXNzaW5nIHRoZSB3YWxsZXQgaW50ZXJmYWNlIG9iamVjdCBkaXJlY3RseSB0byBzaWduSW5XaXRoV2ViMyh7IGNoYWluOiAnc29sYW5hJywgd2FsbGV0OiByZXNvbHZlZFVzZXJXYWxsZXQgfSkgaW5zdGVhZC5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB1cmwgPSBuZXcgVVJMKChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy51cmwpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHdpbmRvdy5sb2NhdGlvbi5ocmVmKTtcbiAgICAgICAgICAgIGlmICgnc2lnbkluJyBpbiByZXNvbHZlZFdhbGxldCAmJiByZXNvbHZlZFdhbGxldC5zaWduSW4pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvdXRwdXQgPSBhd2FpdCByZXNvbHZlZFdhbGxldC5zaWduSW4oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyBpc3N1ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpIH0sIG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5zaWduSW5XaXRoU29sYW5hKSwgeyBcbiAgICAgICAgICAgICAgICAgICAgLy8gbm9uLW92ZXJyaWRhYmxlIHByb3BlcnRpZXNcbiAgICAgICAgICAgICAgICAgICAgdmVyc2lvbjogJzEnLCBkb21haW46IHVybC5ob3N0LCB1cmk6IHVybC5ocmVmIH0pLCAoc3RhdGVtZW50ID8geyBzdGF0ZW1lbnQgfSA6IG51bGwpKSk7XG4gICAgICAgICAgICAgICAgbGV0IG91dHB1dFRvUHJvY2VzcztcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvdXRwdXQpICYmIG91dHB1dFswXSAmJiB0eXBlb2Ygb3V0cHV0WzBdID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXRUb1Byb2Nlc3MgPSBvdXRwdXRbMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG91dHB1dCAmJlxuICAgICAgICAgICAgICAgICAgICB0eXBlb2Ygb3V0cHV0ID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgICAgICAgICAnc2lnbmVkTWVzc2FnZScgaW4gb3V0cHV0ICYmXG4gICAgICAgICAgICAgICAgICAgICdzaWduYXR1cmUnIGluIG91dHB1dCkge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXRUb1Byb2Nlc3MgPSBvdXRwdXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0BzdXBhYmFzZS9hdXRoLWpzOiBXYWxsZXQgbWV0aG9kIHNpZ25JbigpIHJldHVybmVkIHVucmVjb2duaXplZCB2YWx1ZScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoJ3NpZ25lZE1lc3NhZ2UnIGluIG91dHB1dFRvUHJvY2VzcyAmJlxuICAgICAgICAgICAgICAgICAgICAnc2lnbmF0dXJlJyBpbiBvdXRwdXRUb1Byb2Nlc3MgJiZcbiAgICAgICAgICAgICAgICAgICAgKHR5cGVvZiBvdXRwdXRUb1Byb2Nlc3Muc2lnbmVkTWVzc2FnZSA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dFRvUHJvY2Vzcy5zaWduZWRNZXNzYWdlIGluc3RhbmNlb2YgVWludDhBcnJheSkgJiZcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0VG9Qcm9jZXNzLnNpZ25hdHVyZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlb2Ygb3V0cHV0VG9Qcm9jZXNzLnNpZ25lZE1lc3NhZ2UgPT09ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBvdXRwdXRUb1Byb2Nlc3Muc2lnbmVkTWVzc2FnZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKG91dHB1dFRvUHJvY2Vzcy5zaWduZWRNZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgc2lnbmF0dXJlID0gb3V0cHV0VG9Qcm9jZXNzLnNpZ25hdHVyZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQHN1cGFiYXNlL2F1dGgtanM6IFdhbGxldCBtZXRob2Qgc2lnbkluKCkgQVBJIHJldHVybmVkIG9iamVjdCB3aXRob3V0IHNpZ25lZE1lc3NhZ2UgYW5kIHNpZ25hdHVyZSBmaWVsZHMnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoISgnc2lnbk1lc3NhZ2UnIGluIHJlc29sdmVkV2FsbGV0KSB8fFxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgcmVzb2x2ZWRXYWxsZXQuc2lnbk1lc3NhZ2UgIT09ICdmdW5jdGlvbicgfHxcbiAgICAgICAgICAgICAgICAgICAgISgncHVibGljS2V5JyBpbiByZXNvbHZlZFdhbGxldCkgfHxcbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHJlc29sdmVkV2FsbGV0ICE9PSAnb2JqZWN0JyB8fFxuICAgICAgICAgICAgICAgICAgICAhcmVzb2x2ZWRXYWxsZXQucHVibGljS2V5IHx8XG4gICAgICAgICAgICAgICAgICAgICEoJ3RvQmFzZTU4JyBpbiByZXNvbHZlZFdhbGxldC5wdWJsaWNLZXkpIHx8XG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiByZXNvbHZlZFdhbGxldC5wdWJsaWNLZXkudG9CYXNlNTggIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdAc3VwYWJhc2UvYXV0aC1qczogV2FsbGV0IGRvZXMgbm90IGhhdmUgYSBjb21wYXRpYmxlIHNpZ25NZXNzYWdlKCkgYW5kIHB1YmxpY0tleS50b0Jhc2U1OCgpIEFQSScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gW1xuICAgICAgICAgICAgICAgICAgICBgJHt1cmwuaG9zdH0gd2FudHMgeW91IHRvIHNpZ24gaW4gd2l0aCB5b3VyIFNvbGFuYSBhY2NvdW50OmAsXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmVkV2FsbGV0LnB1YmxpY0tleS50b0Jhc2U1OCgpLFxuICAgICAgICAgICAgICAgICAgICAuLi4oc3RhdGVtZW50ID8gWycnLCBzdGF0ZW1lbnQsICcnXSA6IFsnJ10pLFxuICAgICAgICAgICAgICAgICAgICAnVmVyc2lvbjogMScsXG4gICAgICAgICAgICAgICAgICAgIGBVUkk6ICR7dXJsLmhyZWZ9YCxcbiAgICAgICAgICAgICAgICAgICAgYElzc3VlZCBBdDogJHsoX2MgPSAoX2IgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc2lnbkluV2l0aFNvbGFuYSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmlzc3VlZEF0KSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCl9YCxcbiAgICAgICAgICAgICAgICAgICAgLi4uKCgoX2QgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc2lnbkluV2l0aFNvbGFuYSkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLm5vdEJlZm9yZSlcbiAgICAgICAgICAgICAgICAgICAgICAgID8gW2BOb3QgQmVmb3JlOiAke29wdGlvbnMuc2lnbkluV2l0aFNvbGFuYS5ub3RCZWZvcmV9YF1cbiAgICAgICAgICAgICAgICAgICAgICAgIDogW10pLFxuICAgICAgICAgICAgICAgICAgICAuLi4oKChfZSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5zaWduSW5XaXRoU29sYW5hKSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2UuZXhwaXJhdGlvblRpbWUpXG4gICAgICAgICAgICAgICAgICAgICAgICA/IFtgRXhwaXJhdGlvbiBUaW1lOiAke29wdGlvbnMuc2lnbkluV2l0aFNvbGFuYS5leHBpcmF0aW9uVGltZX1gXVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBbXSksXG4gICAgICAgICAgICAgICAgICAgIC4uLigoKF9mID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNpZ25JbldpdGhTb2xhbmEpID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi5jaGFpbklkKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBbYENoYWluIElEOiAke29wdGlvbnMuc2lnbkluV2l0aFNvbGFuYS5jaGFpbklkfWBdXG4gICAgICAgICAgICAgICAgICAgICAgICA6IFtdKSxcbiAgICAgICAgICAgICAgICAgICAgLi4uKCgoX2cgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc2lnbkluV2l0aFNvbGFuYSkgPT09IG51bGwgfHwgX2cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9nLm5vbmNlKSA/IFtgTm9uY2U6ICR7b3B0aW9ucy5zaWduSW5XaXRoU29sYW5hLm5vbmNlfWBdIDogW10pLFxuICAgICAgICAgICAgICAgICAgICAuLi4oKChfaCA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5zaWduSW5XaXRoU29sYW5hKSA9PT0gbnVsbCB8fCBfaCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2gucmVxdWVzdElkKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBbYFJlcXVlc3QgSUQ6ICR7b3B0aW9ucy5zaWduSW5XaXRoU29sYW5hLnJlcXVlc3RJZH1gXVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBbXSksXG4gICAgICAgICAgICAgICAgICAgIC4uLigoKF9rID0gKF9qID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNpZ25JbldpdGhTb2xhbmEpID09PSBudWxsIHx8IF9qID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfai5yZXNvdXJjZXMpID09PSBudWxsIHx8IF9rID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfay5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgICAgICA/IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnUmVzb3VyY2VzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5vcHRpb25zLnNpZ25JbldpdGhTb2xhbmEucmVzb3VyY2VzLm1hcCgocmVzb3VyY2UpID0+IGAtICR7cmVzb3VyY2V9YCksXG4gICAgICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICAgICAgICA6IFtdKSxcbiAgICAgICAgICAgICAgICBdLmpvaW4oJ1xcbicpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1heWJlU2lnbmF0dXJlID0gYXdhaXQgcmVzb2x2ZWRXYWxsZXQuc2lnbk1lc3NhZ2UobmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKG1lc3NhZ2UpLCAndXRmOCcpO1xuICAgICAgICAgICAgICAgIGlmICghbWF5YmVTaWduYXR1cmUgfHwgIShtYXliZVNpZ25hdHVyZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQHN1cGFiYXNlL2F1dGgtanM6IFdhbGxldCBzaWduTWVzc2FnZSgpIEFQSSByZXR1cm5lZCBhbiByZWNvZ25pemVkIHZhbHVlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNpZ25hdHVyZSA9IG1heWJlU2lnbmF0dXJlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnUE9TVCcsIGAke3RoaXMudXJsfS90b2tlbj9ncmFudF90eXBlPXdlYjNgLCB7XG4gICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IE9iamVjdC5hc3NpZ24oeyBjaGFpbjogJ3NvbGFuYScsIG1lc3NhZ2UsIHNpZ25hdHVyZTogYnl0ZXNUb0Jhc2U2NFVSTChzaWduYXR1cmUpIH0sICgoKF9sID0gY3JlZGVudGlhbHMub3B0aW9ucykgPT09IG51bGwgfHwgX2wgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9sLmNhcHRjaGFUb2tlbilcbiAgICAgICAgICAgICAgICAgICAgPyB7IGdvdHJ1ZV9tZXRhX3NlY3VyaXR5OiB7IGNhcHRjaGFfdG9rZW46IChfbSA9IGNyZWRlbnRpYWxzLm9wdGlvbnMpID09PSBudWxsIHx8IF9tID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfbS5jYXB0Y2hhVG9rZW4gfSB9XG4gICAgICAgICAgICAgICAgICAgIDogbnVsbCkpLFxuICAgICAgICAgICAgICAgIHhmb3JtOiBfc2Vzc2lvblJlc3BvbnNlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZGF0YSB8fCAhZGF0YS5zZXNzaW9uIHx8ICFkYXRhLnVzZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwgfSxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6IG5ldyBBdXRoSW52YWxpZFRva2VuUmVzcG9uc2VFcnJvcigpLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0YS5zZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fc2F2ZVNlc3Npb24oZGF0YS5zZXNzaW9uKTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9ub3RpZnlBbGxTdWJzY3JpYmVycygnU0lHTkVEX0lOJywgZGF0YS5zZXNzaW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IE9iamVjdC5hc3NpZ24oe30sIGRhdGEpLCBlcnJvciB9O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgX2V4Y2hhbmdlQ29kZUZvclNlc3Npb24oYXV0aENvZGUpIHtcbiAgICAgICAgY29uc3Qgc3RvcmFnZUl0ZW0gPSBhd2FpdCBnZXRJdGVtQXN5bmModGhpcy5zdG9yYWdlLCBgJHt0aGlzLnN0b3JhZ2VLZXl9LWNvZGUtdmVyaWZpZXJgKTtcbiAgICAgICAgY29uc3QgW2NvZGVWZXJpZmllciwgcmVkaXJlY3RUeXBlXSA9IChzdG9yYWdlSXRlbSAhPT0gbnVsbCAmJiBzdG9yYWdlSXRlbSAhPT0gdm9pZCAwID8gc3RvcmFnZUl0ZW0gOiAnJykuc3BsaXQoJy8nKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L3Rva2VuP2dyYW50X3R5cGU9cGtjZWAsIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgYm9keToge1xuICAgICAgICAgICAgICAgICAgICBhdXRoX2NvZGU6IGF1dGhDb2RlLFxuICAgICAgICAgICAgICAgICAgICBjb2RlX3ZlcmlmaWVyOiBjb2RlVmVyaWZpZXIsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB4Zm9ybTogX3Nlc3Npb25SZXNwb25zZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXdhaXQgcmVtb3ZlSXRlbUFzeW5jKHRoaXMuc3RvcmFnZSwgYCR7dGhpcy5zdG9yYWdlS2V5fS1jb2RlLXZlcmlmaWVyYCk7XG4gICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZGF0YSB8fCAhZGF0YS5zZXNzaW9uIHx8ICFkYXRhLnVzZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwsIHJlZGlyZWN0VHlwZTogbnVsbCB9LFxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogbmV3IEF1dGhJbnZhbGlkVG9rZW5SZXNwb25zZUVycm9yKCksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkYXRhLnNlc3Npb24pIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9zYXZlU2Vzc2lvbihkYXRhLnNlc3Npb24pO1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX25vdGlmeUFsbFN1YnNjcmliZXJzKCdTSUdORURfSU4nLCBkYXRhLnNlc3Npb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkYXRhKSwgeyByZWRpcmVjdFR5cGU6IHJlZGlyZWN0VHlwZSAhPT0gbnVsbCAmJiByZWRpcmVjdFR5cGUgIT09IHZvaWQgMCA/IHJlZGlyZWN0VHlwZSA6IG51bGwgfSksIGVycm9yIH07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsLCByZWRpcmVjdFR5cGU6IG51bGwgfSwgZXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFsbG93cyBzaWduaW5nIGluIHdpdGggYW4gT0lEQyBJRCB0b2tlbi4gVGhlIGF1dGhlbnRpY2F0aW9uIHByb3ZpZGVyIHVzZWRcbiAgICAgKiBzaG91bGQgYmUgZW5hYmxlZCBhbmQgY29uZmlndXJlZC5cbiAgICAgKi9cbiAgICBhc3luYyBzaWduSW5XaXRoSWRUb2tlbihjcmVkZW50aWFscykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgeyBvcHRpb25zLCBwcm92aWRlciwgdG9rZW4sIGFjY2Vzc190b2tlbiwgbm9uY2UgfSA9IGNyZWRlbnRpYWxzO1xuICAgICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ1BPU1QnLCBgJHt0aGlzLnVybH0vdG9rZW4/Z3JhbnRfdHlwZT1pZF90b2tlbmAsIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgYm9keToge1xuICAgICAgICAgICAgICAgICAgICBwcm92aWRlcixcbiAgICAgICAgICAgICAgICAgICAgaWRfdG9rZW46IHRva2VuLFxuICAgICAgICAgICAgICAgICAgICBhY2Nlc3NfdG9rZW4sXG4gICAgICAgICAgICAgICAgICAgIG5vbmNlLFxuICAgICAgICAgICAgICAgICAgICBnb3RydWVfbWV0YV9zZWN1cml0eTogeyBjYXB0Y2hhX3Rva2VuOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY2FwdGNoYVRva2VuIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB4Zm9ybTogX3Nlc3Npb25SZXNwb25zZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gcmVzO1xuICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghZGF0YSB8fCAhZGF0YS5zZXNzaW9uIHx8ICFkYXRhLnVzZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwgfSxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6IG5ldyBBdXRoSW52YWxpZFRva2VuUmVzcG9uc2VFcnJvcigpLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0YS5zZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fc2F2ZVNlc3Npb24oZGF0YS5zZXNzaW9uKTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9ub3RpZnlBbGxTdWJzY3JpYmVycygnU0lHTkVEX0lOJywgZGF0YS5zZXNzaW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IGRhdGEsIGVycm9yIH07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb2cgaW4gYSB1c2VyIHVzaW5nIG1hZ2ljbGluayBvciBhIG9uZS10aW1lIHBhc3N3b3JkIChPVFApLlxuICAgICAqXG4gICAgICogSWYgdGhlIGB7eyAuQ29uZmlybWF0aW9uVVJMIH19YCB2YXJpYWJsZSBpcyBzcGVjaWZpZWQgaW4gdGhlIGVtYWlsIHRlbXBsYXRlLCBhIG1hZ2ljbGluayB3aWxsIGJlIHNlbnQuXG4gICAgICogSWYgdGhlIGB7eyAuVG9rZW4gfX1gIHZhcmlhYmxlIGlzIHNwZWNpZmllZCBpbiB0aGUgZW1haWwgdGVtcGxhdGUsIGFuIE9UUCB3aWxsIGJlIHNlbnQuXG4gICAgICogSWYgeW91J3JlIHVzaW5nIHBob25lIHNpZ24taW5zLCBvbmx5IGFuIE9UUCB3aWxsIGJlIHNlbnQuIFlvdSB3b24ndCBiZSBhYmxlIHRvIHNlbmQgYSBtYWdpY2xpbmsgZm9yIHBob25lIHNpZ24taW5zLlxuICAgICAqXG4gICAgICogQmUgYXdhcmUgdGhhdCB5b3UgbWF5IGdldCBiYWNrIGFuIGVycm9yIG1lc3NhZ2UgdGhhdCB3aWxsIG5vdCBkaXN0aW5ndWlzaFxuICAgICAqIGJldHdlZW4gdGhlIGNhc2VzIHdoZXJlIHRoZSBhY2NvdW50IGRvZXMgbm90IGV4aXN0IG9yLCB0aGF0IHRoZSBhY2NvdW50XG4gICAgICogY2FuIG9ubHkgYmUgYWNjZXNzZWQgdmlhIHNvY2lhbCBsb2dpbi5cbiAgICAgKlxuICAgICAqIERvIG5vdGUgdGhhdCB5b3Ugd2lsbCBuZWVkIHRvIGNvbmZpZ3VyZSBhIFdoYXRzYXBwIHNlbmRlciBvbiBUd2lsaW9cbiAgICAgKiBpZiB5b3UgYXJlIHVzaW5nIHBob25lIHNpZ24gaW4gd2l0aCB0aGUgJ3doYXRzYXBwJyBjaGFubmVsLiBUaGUgd2hhdHNhcHBcbiAgICAgKiBjaGFubmVsIGlzIG5vdCBzdXBwb3J0ZWQgb24gb3RoZXIgcHJvdmlkZXJzXG4gICAgICogYXQgdGhpcyB0aW1lLlxuICAgICAqIFRoaXMgbWV0aG9kIHN1cHBvcnRzIFBLQ0Ugd2hlbiBhbiBlbWFpbCBpcyBwYXNzZWQuXG4gICAgICovXG4gICAgYXN5bmMgc2lnbkluV2l0aE90cChjcmVkZW50aWFscykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKCdlbWFpbCcgaW4gY3JlZGVudGlhbHMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGVtYWlsLCBvcHRpb25zIH0gPSBjcmVkZW50aWFscztcbiAgICAgICAgICAgICAgICBsZXQgY29kZUNoYWxsZW5nZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgbGV0IGNvZGVDaGFsbGVuZ2VNZXRob2QgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmZsb3dUeXBlID09PSAncGtjZScpIHtcbiAgICAgICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgICAgICBbY29kZUNoYWxsZW5nZSwgY29kZUNoYWxsZW5nZU1ldGhvZF0gPSBhd2FpdCBnZXRDb2RlQ2hhbGxlbmdlQW5kTWV0aG9kKHRoaXMuc3RvcmFnZSwgdGhpcy5zdG9yYWdlS2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ1BPU1QnLCBgJHt0aGlzLnVybH0vb3RwYCwge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVtYWlsLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmRhdGEpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgY3JlYXRlX3VzZXI6IChfYiA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5zaG91bGRDcmVhdGVVc2VyKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ290cnVlX21ldGFfc2VjdXJpdHk6IHsgY2FwdGNoYV90b2tlbjogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmNhcHRjaGFUb2tlbiB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZV9jaGFsbGVuZ2U6IGNvZGVDaGFsbGVuZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlX2NoYWxsZW5nZV9tZXRob2Q6IGNvZGVDaGFsbGVuZ2VNZXRob2QsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHJlZGlyZWN0VG86IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5lbWFpbFJlZGlyZWN0VG8sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoJ3Bob25lJyBpbiBjcmVkZW50aWFscykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgcGhvbmUsIG9wdGlvbnMgfSA9IGNyZWRlbnRpYWxzO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L290cGAsIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICBib2R5OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwaG9uZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IChfYyA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5kYXRhKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNyZWF0ZV91c2VyOiAoX2QgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc2hvdWxkQ3JlYXRlVXNlcikgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdvdHJ1ZV9tZXRhX3NlY3VyaXR5OiB7IGNhcHRjaGFfdG9rZW46IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5jYXB0Y2hhVG9rZW4gfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5uZWw6IChfZSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5jaGFubmVsKSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiAnc21zJyxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwsIG1lc3NhZ2VJZDogZGF0YSA9PT0gbnVsbCB8fCBkYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkYXRhLm1lc3NhZ2VfaWQgfSwgZXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBBdXRoSW52YWxpZENyZWRlbnRpYWxzRXJyb3IoJ1lvdSBtdXN0IHByb3ZpZGUgZWl0aGVyIGFuIGVtYWlsIG9yIHBob25lIG51bWJlci4nKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwgfSwgZXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvZyBpbiBhIHVzZXIgZ2l2ZW4gYSBVc2VyIHN1cHBsaWVkIE9UUCBvciBUb2tlbkhhc2ggcmVjZWl2ZWQgdGhyb3VnaCBtb2JpbGUgb3IgZW1haWwuXG4gICAgICovXG4gICAgYXN5bmMgdmVyaWZ5T3RwKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbGV0IHJlZGlyZWN0VG8gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBsZXQgY2FwdGNoYVRva2VuID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKCdvcHRpb25zJyBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgICAgICByZWRpcmVjdFRvID0gKF9hID0gcGFyYW1zLm9wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZWRpcmVjdFRvO1xuICAgICAgICAgICAgICAgIGNhcHRjaGFUb2tlbiA9IChfYiA9IHBhcmFtcy5vcHRpb25zKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FwdGNoYVRva2VuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ1BPU1QnLCBgJHt0aGlzLnVybH0vdmVyaWZ5YCwge1xuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHBhcmFtcyksIHsgZ290cnVlX21ldGFfc2VjdXJpdHk6IHsgY2FwdGNoYV90b2tlbjogY2FwdGNoYVRva2VuIH0gfSksXG4gICAgICAgICAgICAgICAgcmVkaXJlY3RUbyxcbiAgICAgICAgICAgICAgICB4Zm9ybTogX3Nlc3Npb25SZXNwb25zZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FuIGVycm9yIG9jY3VycmVkIG9uIHRva2VuIHZlcmlmaWNhdGlvbi4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHNlc3Npb24gPSBkYXRhLnNlc3Npb247XG4gICAgICAgICAgICBjb25zdCB1c2VyID0gZGF0YS51c2VyO1xuICAgICAgICAgICAgaWYgKHNlc3Npb24gPT09IG51bGwgfHwgc2Vzc2lvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2Vzc2lvbi5hY2Nlc3NfdG9rZW4pIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9zYXZlU2Vzc2lvbihzZXNzaW9uKTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9ub3RpZnlBbGxTdWJzY3JpYmVycyhwYXJhbXMudHlwZSA9PSAncmVjb3ZlcnknID8gJ1BBU1NXT1JEX1JFQ09WRVJZJyA6ICdTSUdORURfSU4nLCBzZXNzaW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlciwgc2Vzc2lvbiB9LCBlcnJvcjogbnVsbCB9O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQXR0ZW1wdHMgYSBzaW5nbGUtc2lnbiBvbiB1c2luZyBhbiBlbnRlcnByaXNlIElkZW50aXR5IFByb3ZpZGVyLiBBXG4gICAgICogc3VjY2Vzc2Z1bCBTU08gYXR0ZW1wdCB3aWxsIHJlZGlyZWN0IHRoZSBjdXJyZW50IHBhZ2UgdG8gdGhlIGlkZW50aXR5XG4gICAgICogcHJvdmlkZXIgYXV0aG9yaXphdGlvbiBwYWdlLiBUaGUgcmVkaXJlY3QgVVJMIGlzIGltcGxlbWVudGF0aW9uIGFuZCBTU09cbiAgICAgKiBwcm90b2NvbCBzcGVjaWZpYy5cbiAgICAgKlxuICAgICAqIFlvdSBjYW4gdXNlIGl0IGJ5IHByb3ZpZGluZyBhIFNTTyBkb21haW4uIFR5cGljYWxseSB5b3UgY2FuIGV4dHJhY3QgdGhpc1xuICAgICAqIGRvbWFpbiBieSBhc2tpbmcgdXNlcnMgZm9yIHRoZWlyIGVtYWlsIGFkZHJlc3MuIElmIHRoaXMgZG9tYWluIGlzXG4gICAgICogcmVnaXN0ZXJlZCBvbiB0aGUgQXV0aCBpbnN0YW5jZSB0aGUgcmVkaXJlY3Qgd2lsbCB1c2UgdGhhdCBvcmdhbml6YXRpb24nc1xuICAgICAqIGN1cnJlbnRseSBhY3RpdmUgU1NPIElkZW50aXR5IFByb3ZpZGVyIGZvciB0aGUgbG9naW4uXG4gICAgICpcbiAgICAgKiBJZiB5b3UgaGF2ZSBidWlsdCBhbiBvcmdhbml6YXRpb24tc3BlY2lmaWMgbG9naW4gcGFnZSwgeW91IGNhbiB1c2UgdGhlXG4gICAgICogb3JnYW5pemF0aW9uJ3MgU1NPIElkZW50aXR5IFByb3ZpZGVyIFVVSUQgZGlyZWN0bHkgaW5zdGVhZC5cbiAgICAgKi9cbiAgICBhc3luYyBzaWduSW5XaXRoU1NPKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxldCBjb2RlQ2hhbGxlbmdlID0gbnVsbDtcbiAgICAgICAgICAgIGxldCBjb2RlQ2hhbGxlbmdlTWV0aG9kID0gbnVsbDtcbiAgICAgICAgICAgIGlmICh0aGlzLmZsb3dUeXBlID09PSAncGtjZScpIHtcbiAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgW2NvZGVDaGFsbGVuZ2UsIGNvZGVDaGFsbGVuZ2VNZXRob2RdID0gYXdhaXQgZ2V0Q29kZUNoYWxsZW5nZUFuZE1ldGhvZCh0aGlzLnN0b3JhZ2UsIHRoaXMuc3RvcmFnZUtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ1BPU1QnLCBgJHt0aGlzLnVybH0vc3NvYCwge1xuICAgICAgICAgICAgICAgIGJvZHk6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgKCdwcm92aWRlcklkJyBpbiBwYXJhbXMgPyB7IHByb3ZpZGVyX2lkOiBwYXJhbXMucHJvdmlkZXJJZCB9IDogbnVsbCkpLCAoJ2RvbWFpbicgaW4gcGFyYW1zID8geyBkb21haW46IHBhcmFtcy5kb21haW4gfSA6IG51bGwpKSwgeyByZWRpcmVjdF90bzogKF9iID0gKF9hID0gcGFyYW1zLm9wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZWRpcmVjdFRvKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB1bmRlZmluZWQgfSksICgoKF9jID0gcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLm9wdGlvbnMpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5jYXB0Y2hhVG9rZW4pXG4gICAgICAgICAgICAgICAgICAgID8geyBnb3RydWVfbWV0YV9zZWN1cml0eTogeyBjYXB0Y2hhX3Rva2VuOiBwYXJhbXMub3B0aW9ucy5jYXB0Y2hhVG9rZW4gfSB9XG4gICAgICAgICAgICAgICAgICAgIDogbnVsbCkpLCB7IHNraXBfaHR0cF9yZWRpcmVjdDogdHJ1ZSwgY29kZV9jaGFsbGVuZ2U6IGNvZGVDaGFsbGVuZ2UsIGNvZGVfY2hhbGxlbmdlX21ldGhvZDogY29kZUNoYWxsZW5nZU1ldGhvZCB9KSxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgeGZvcm06IF9zc29SZXNwb25zZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kcyBhIHJlYXV0aGVudGljYXRpb24gT1RQIHRvIHRoZSB1c2VyJ3MgZW1haWwgb3IgcGhvbmUgbnVtYmVyLlxuICAgICAqIFJlcXVpcmVzIHRoZSB1c2VyIHRvIGJlIHNpZ25lZC1pbi5cbiAgICAgKi9cbiAgICBhc3luYyByZWF1dGhlbnRpY2F0ZSgpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5pbml0aWFsaXplUHJvbWlzZTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX2FjcXVpcmVMb2NrKC0xLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fcmVhdXRoZW50aWNhdGUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIF9yZWF1dGhlbnRpY2F0ZSgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl91c2VTZXNzaW9uKGFzeW5jIChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGRhdGE6IHsgc2Vzc2lvbiB9LCBlcnJvcjogc2Vzc2lvbkVycm9yLCB9ID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgIGlmIChzZXNzaW9uRXJyb3IpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IHNlc3Npb25FcnJvcjtcbiAgICAgICAgICAgICAgICBpZiAoIXNlc3Npb24pXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBBdXRoU2Vzc2lvbk1pc3NpbmdFcnJvcigpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdHRVQnLCBgJHt0aGlzLnVybH0vcmVhdXRoZW50aWNhdGVgLCB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgand0OiBzZXNzaW9uLmFjY2Vzc190b2tlbixcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwgfSwgZXJyb3IgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzZW5kcyBhbiBleGlzdGluZyBzaWdudXAgY29uZmlybWF0aW9uIGVtYWlsLCBlbWFpbCBjaGFuZ2UgZW1haWwsIFNNUyBPVFAgb3IgcGhvbmUgY2hhbmdlIE9UUC5cbiAgICAgKi9cbiAgICBhc3luYyByZXNlbmQoY3JlZGVudGlhbHMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGVuZHBvaW50ID0gYCR7dGhpcy51cmx9L3Jlc2VuZGA7XG4gICAgICAgICAgICBpZiAoJ2VtYWlsJyBpbiBjcmVkZW50aWFscykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZW1haWwsIHR5cGUsIG9wdGlvbnMgfSA9IGNyZWRlbnRpYWxzO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgZW5kcG9pbnQsIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICBib2R5OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbWFpbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBnb3RydWVfbWV0YV9zZWN1cml0eTogeyBjYXB0Y2hhX3Rva2VuOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY2FwdGNoYVRva2VuIH0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHJlZGlyZWN0VG86IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5lbWFpbFJlZGlyZWN0VG8sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgncGhvbmUnIGluIGNyZWRlbnRpYWxzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBwaG9uZSwgdHlwZSwgb3B0aW9ucyB9ID0gY3JlZGVudGlhbHM7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ1BPU1QnLCBlbmRwb2ludCwge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBob25lLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdvdHJ1ZV9tZXRhX3NlY3VyaXR5OiB7IGNhcHRjaGFfdG9rZW46IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5jYXB0Y2hhVG9rZW4gfSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwsIG1lc3NhZ2VJZDogZGF0YSA9PT0gbnVsbCB8fCBkYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkYXRhLm1lc3NhZ2VfaWQgfSwgZXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBBdXRoSW52YWxpZENyZWRlbnRpYWxzRXJyb3IoJ1lvdSBtdXN0IHByb3ZpZGUgZWl0aGVyIGFuIGVtYWlsIG9yIHBob25lIG51bWJlciBhbmQgYSB0eXBlJyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBzZXNzaW9uLCByZWZyZXNoaW5nIGl0IGlmIG5lY2Vzc2FyeS5cbiAgICAgKlxuICAgICAqIFRoZSBzZXNzaW9uIHJldHVybmVkIGNhbiBiZSBudWxsIGlmIHRoZSBzZXNzaW9uIGlzIG5vdCBkZXRlY3RlZCB3aGljaCBjYW4gaGFwcGVuIGluIHRoZSBldmVudCBhIHVzZXIgaXMgbm90IHNpZ25lZC1pbiBvciBoYXMgbG9nZ2VkIG91dC5cbiAgICAgKlxuICAgICAqICoqSU1QT1JUQU5UOioqIFRoaXMgbWV0aG9kIGxvYWRzIHZhbHVlcyBkaXJlY3RseSBmcm9tIHRoZSBzdG9yYWdlIGF0dGFjaGVkXG4gICAgICogdG8gdGhlIGNsaWVudC4gSWYgdGhhdCBzdG9yYWdlIGlzIGJhc2VkIG9uIHJlcXVlc3QgY29va2llcyBmb3IgZXhhbXBsZSxcbiAgICAgKiB0aGUgdmFsdWVzIGluIGl0IG1heSBub3QgYmUgYXV0aGVudGljIGFuZCB0aGVyZWZvcmUgaXQncyBzdHJvbmdseSBhZHZpc2VkXG4gICAgICogYWdhaW5zdCB1c2luZyB0aGlzIG1ldGhvZCBhbmQgaXRzIHJlc3VsdHMgaW4gc3VjaCBjaXJjdW1zdGFuY2VzLiBBIHdhcm5pbmdcbiAgICAgKiB3aWxsIGJlIGVtaXR0ZWQgaWYgdGhpcyBpcyBkZXRlY3RlZC4gVXNlIHtAbGluayAjZ2V0VXNlcigpfSBpbnN0ZWFkLlxuICAgICAqL1xuICAgIGFzeW5jIGdldFNlc3Npb24oKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuaW5pdGlhbGl6ZVByb21pc2U7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuX2FjcXVpcmVMb2NrKC0xLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdXNlU2Vzc2lvbihhc3luYyAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWNxdWlyZXMgYSBnbG9iYWwgbG9jayBiYXNlZCBvbiB0aGUgc3RvcmFnZSBrZXkuXG4gICAgICovXG4gICAgYXN5bmMgX2FjcXVpcmVMb2NrKGFjcXVpcmVUaW1lb3V0LCBmbikge1xuICAgICAgICB0aGlzLl9kZWJ1ZygnI19hY3F1aXJlTG9jaycsICdiZWdpbicsIGFjcXVpcmVUaW1lb3V0KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmxvY2tBY3F1aXJlZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxhc3QgPSB0aGlzLnBlbmRpbmdJbkxvY2subGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgID8gdGhpcy5wZW5kaW5nSW5Mb2NrW3RoaXMucGVuZGluZ0luTG9jay5sZW5ndGggLSAxXVxuICAgICAgICAgICAgICAgICAgICA6IFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IGxhc3Q7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCBmbigpO1xuICAgICAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nSW5Mb2NrLnB1c2goKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UganVzdCBjYXJlIGlmIGl0IGZpbmlzaGVkXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KSgpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMubG9jayhgbG9jazoke3RoaXMuc3RvcmFnZUtleX1gLCBhY3F1aXJlVGltZW91dCwgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RlYnVnKCcjX2FjcXVpcmVMb2NrJywgJ2xvY2sgYWNxdWlyZWQgZm9yIHN0b3JhZ2Uga2V5JywgdGhpcy5zdG9yYWdlS2V5KTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvY2tBY3F1aXJlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGZuKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ0luTG9jay5wdXNoKChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UganVzdCBjYXJlIGlmIGl0IGZpbmlzaGVkXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pKCkpO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIC8vIGtlZXAgZHJhaW5pbmcgdGhlIHF1ZXVlIHVudGlsIHRoZXJlJ3Mgbm90aGluZyB0byB3YWl0IG9uXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICh0aGlzLnBlbmRpbmdJbkxvY2subGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB3YWl0T24gPSBbLi4udGhpcy5wZW5kaW5nSW5Mb2NrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHdhaXRPbik7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdJbkxvY2suc3BsaWNlKDAsIHdhaXRPbi5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kZWJ1ZygnI19hY3F1aXJlTG9jaycsICdsb2NrIHJlbGVhc2VkIGZvciBzdG9yYWdlIGtleScsIHRoaXMuc3RvcmFnZUtleSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9ja0FjcXVpcmVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0aGlzLl9kZWJ1ZygnI19hY3F1aXJlTG9jaycsICdlbmQnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBVc2UgaW5zdGVhZCBvZiB7QGxpbmsgI2dldFNlc3Npb259IGluc2lkZSB0aGUgbGlicmFyeS4gSXQgaXNcbiAgICAgKiBzZW1hbnRpY2FsbHkgdXN1YWxseSB3aGF0IHlvdSB3YW50LCBhcyBnZXR0aW5nIGEgc2Vzc2lvbiBpbnZvbHZlcyBzb21lXG4gICAgICogcHJvY2Vzc2luZyBhZnRlcndhcmRzIHRoYXQgcmVxdWlyZXMgb25seSBvbmUgY2xpZW50IG9wZXJhdGluZyBvbiB0aGVcbiAgICAgKiBzZXNzaW9uIGF0IG9uY2UgYWNyb3NzIG11bHRpcGxlIHRhYnMgb3IgcHJvY2Vzc2VzLlxuICAgICAqL1xuICAgIGFzeW5jIF91c2VTZXNzaW9uKGZuKSB7XG4gICAgICAgIHRoaXMuX2RlYnVnKCcjX3VzZVNlc3Npb24nLCAnYmVnaW4nKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIHRoZSB1c2Ugb2YgX19sb2FkU2Vzc2lvbiBoZXJlIGlzIHRoZSBvbmx5IGNvcnJlY3QgdXNlIG9mIHRoZSBmdW5jdGlvbiFcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuX19sb2FkU2Vzc2lvbigpO1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IGZuKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0aGlzLl9kZWJ1ZygnI191c2VTZXNzaW9uJywgJ2VuZCcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE5FVkVSIFVTRSBESVJFQ1RMWSFcbiAgICAgKlxuICAgICAqIEFsd2F5cyB1c2Uge0BsaW5rICNfdXNlU2Vzc2lvbn0uXG4gICAgICovXG4gICAgYXN5bmMgX19sb2FkU2Vzc2lvbigpIHtcbiAgICAgICAgdGhpcy5fZGVidWcoJyNfX2xvYWRTZXNzaW9uKCknLCAnYmVnaW4nKTtcbiAgICAgICAgaWYgKCF0aGlzLmxvY2tBY3F1aXJlZCkge1xuICAgICAgICAgICAgdGhpcy5fZGVidWcoJyNfX2xvYWRTZXNzaW9uKCknLCAndXNlZCBvdXRzaWRlIG9mIGFuIGFjcXVpcmVkIGxvY2shJywgbmV3IEVycm9yKCkuc3RhY2spO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsZXQgY3VycmVudFNlc3Npb24gPSBudWxsO1xuICAgICAgICAgICAgY29uc3QgbWF5YmVTZXNzaW9uID0gYXdhaXQgZ2V0SXRlbUFzeW5jKHRoaXMuc3RvcmFnZSwgdGhpcy5zdG9yYWdlS2V5KTtcbiAgICAgICAgICAgIHRoaXMuX2RlYnVnKCcjZ2V0U2Vzc2lvbigpJywgJ3Nlc3Npb24gZnJvbSBzdG9yYWdlJywgbWF5YmVTZXNzaW9uKTtcbiAgICAgICAgICAgIGlmIChtYXliZVNlc3Npb24gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5faXNWYWxpZFNlc3Npb24obWF5YmVTZXNzaW9uKSkge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50U2Vzc2lvbiA9IG1heWJlU2Vzc2lvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RlYnVnKCcjZ2V0U2Vzc2lvbigpJywgJ3Nlc3Npb24gZnJvbSBzdG9yYWdlIGlzIG5vdCB2YWxpZCcpO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9yZW1vdmVTZXNzaW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFjdXJyZW50U2Vzc2lvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgc2Vzc2lvbjogbnVsbCB9LCBlcnJvcjogbnVsbCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQSBzZXNzaW9uIGlzIGNvbnNpZGVyZWQgZXhwaXJlZCBiZWZvcmUgdGhlIGFjY2VzcyB0b2tlbiBfYWN0dWFsbHlfXG4gICAgICAgICAgICAvLyBleHBpcmVzLiBXaGVuIHRoZSBhdXRvUmVmcmVzaFRva2VuIG9wdGlvbiBpcyBvZmYgKG9yIHdoZW4gdGhlIHRhYiBpc1xuICAgICAgICAgICAgLy8gaW4gdGhlIGJhY2tncm91bmQpLCB2ZXJ5IGVhZ2VyIHVzZXJzIG9mIGdldFNlc3Npb24oKSAtLSBsaWtlXG4gICAgICAgICAgICAvLyByZWFsdGltZS1qcyAtLSBtaWdodCBzZW5kIGEgdmFsaWQgSldUIHdoaWNoIHdpbGwgZXhwaXJlIGJ5IHRoZSB0aW1lIGl0XG4gICAgICAgICAgICAvLyByZWFjaGVzIHRoZSBzZXJ2ZXIuXG4gICAgICAgICAgICBjb25zdCBoYXNFeHBpcmVkID0gY3VycmVudFNlc3Npb24uZXhwaXJlc19hdFxuICAgICAgICAgICAgICAgID8gY3VycmVudFNlc3Npb24uZXhwaXJlc19hdCAqIDEwMDAgLSBEYXRlLm5vdygpIDwgRVhQSVJZX01BUkdJTl9NU1xuICAgICAgICAgICAgICAgIDogZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9kZWJ1ZygnI19fbG9hZFNlc3Npb24oKScsIGBzZXNzaW9uIGhhcyR7aGFzRXhwaXJlZCA/ICcnIDogJyBub3QnfSBleHBpcmVkYCwgJ2V4cGlyZXNfYXQnLCBjdXJyZW50U2Vzc2lvbi5leHBpcmVzX2F0KTtcbiAgICAgICAgICAgIGlmICghaGFzRXhwaXJlZCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnVzZXJTdG9yYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1heWJlVXNlciA9IChhd2FpdCBnZXRJdGVtQXN5bmModGhpcy51c2VyU3RvcmFnZSwgdGhpcy5zdG9yYWdlS2V5ICsgJy11c2VyJykpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWF5YmVVc2VyID09PSBudWxsIHx8IG1heWJlVXNlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWF5YmVVc2VyLnVzZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTZXNzaW9uLnVzZXIgPSBtYXliZVVzZXIudXNlcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTZXNzaW9uLnVzZXIgPSB1c2VyTm90QXZhaWxhYmxlUHJveHkoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdG9yYWdlLmlzU2VydmVyICYmIGN1cnJlbnRTZXNzaW9uLnVzZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHN1cHByZXNzV2FybmluZyA9IHRoaXMuc3VwcHJlc3NHZXRTZXNzaW9uV2FybmluZztcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJveHlTZXNzaW9uID0gbmV3IFByb3h5KGN1cnJlbnRTZXNzaW9uLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZXQ6ICh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzdXBwcmVzc1dhcm5pbmcgJiYgcHJvcCA9PT0gJ3VzZXInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9ubHkgc2hvdyB3YXJuaW5nIHdoZW4gdGhlIHVzZXIgb2JqZWN0IGlzIGJlaW5nIGFjY2Vzc2VkIGZyb20gdGhlIHNlcnZlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1VzaW5nIHRoZSB1c2VyIG9iamVjdCBhcyByZXR1cm5lZCBmcm9tIHN1cGFiYXNlLmF1dGguZ2V0U2Vzc2lvbigpIG9yIGZyb20gc29tZSBzdXBhYmFzZS5hdXRoLm9uQXV0aFN0YXRlQ2hhbmdlKCkgZXZlbnRzIGNvdWxkIGJlIGluc2VjdXJlISBUaGlzIHZhbHVlIGNvbWVzIGRpcmVjdGx5IGZyb20gdGhlIHN0b3JhZ2UgbWVkaXVtICh1c3VhbGx5IGNvb2tpZXMgb24gdGhlIHNlcnZlcikgYW5kIG1heSBub3QgYmUgYXV0aGVudGljLiBVc2Ugc3VwYWJhc2UuYXV0aC5nZXRVc2VyKCkgaW5zdGVhZCB3aGljaCBhdXRoZW50aWNhdGVzIHRoZSBkYXRhIGJ5IGNvbnRhY3RpbmcgdGhlIFN1cGFiYXNlIEF1dGggc2VydmVyLicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdXBwcmVzc1dhcm5pbmcgPSB0cnVlOyAvLyBrZWVwcyB0aGlzIHByb3h5IGluc3RhbmNlIGZyb20gbG9nZ2luZyBhZGRpdGlvbmFsIHdhcm5pbmdzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3VwcHJlc3NHZXRTZXNzaW9uV2FybmluZyA9IHRydWU7IC8vIGtlZXBzIHRoaXMgY2xpZW50J3MgZnV0dXJlIHByb3h5IGluc3RhbmNlcyBmcm9tIHdhcm5pbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTZXNzaW9uID0gcHJveHlTZXNzaW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHNlc3Npb246IGN1cnJlbnRTZXNzaW9uIH0sIGVycm9yOiBudWxsIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IGRhdGE6IHNlc3Npb24sIGVycm9yIH0gPSBhd2FpdCB0aGlzLl9jYWxsUmVmcmVzaFRva2VuKGN1cnJlbnRTZXNzaW9uLnJlZnJlc2hfdG9rZW4pO1xuICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyBzZXNzaW9uOiBudWxsIH0sIGVycm9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHNlc3Npb24gfSwgZXJyb3I6IG51bGwgfTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRoaXMuX2RlYnVnKCcjX19sb2FkU2Vzc2lvbigpJywgJ2VuZCcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGN1cnJlbnQgdXNlciBkZXRhaWxzIGlmIHRoZXJlIGlzIGFuIGV4aXN0aW5nIHNlc3Npb24uIFRoaXMgbWV0aG9kXG4gICAgICogcGVyZm9ybXMgYSBuZXR3b3JrIHJlcXVlc3QgdG8gdGhlIFN1cGFiYXNlIEF1dGggc2VydmVyLCBzbyB0aGUgcmV0dXJuZWRcbiAgICAgKiB2YWx1ZSBpcyBhdXRoZW50aWMgYW5kIGNhbiBiZSB1c2VkIHRvIGJhc2UgYXV0aG9yaXphdGlvbiBydWxlcyBvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBqd3QgVGFrZXMgaW4gYW4gb3B0aW9uYWwgYWNjZXNzIHRva2VuIEpXVC4gSWYgbm8gSldUIGlzIHByb3ZpZGVkLCB0aGUgSldUIGZyb20gdGhlIGN1cnJlbnQgc2Vzc2lvbiBpcyB1c2VkLlxuICAgICAqL1xuICAgIGFzeW5jIGdldFVzZXIoand0KSB7XG4gICAgICAgIGlmIChqd3QpIHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9nZXRVc2VyKGp3dCk7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgdGhpcy5pbml0aWFsaXplUHJvbWlzZTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5fYWNxdWlyZUxvY2soLTEsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9nZXRVc2VyKCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBhc3luYyBfZ2V0VXNlcihqd3QpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChqd3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ0dFVCcsIGAke3RoaXMudXJsfS91c2VyYCwge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIGp3dDogand0LFxuICAgICAgICAgICAgICAgICAgICB4Zm9ybTogX3VzZXJSZXNwb25zZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl91c2VTZXNzaW9uKGFzeW5jIChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyByZXR1cm5zIGFuIGVycm9yIGlmIHRoZXJlIGlzIG5vIGFjY2Vzc190b2tlbiBvciBjdXN0b20gYXV0aG9yaXphdGlvbiBoZWFkZXJcbiAgICAgICAgICAgICAgICBpZiAoISgoX2EgPSBkYXRhLnNlc3Npb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hY2Nlc3NfdG9rZW4pICYmICF0aGlzLmhhc0N1c3RvbUF1dGhvcml6YXRpb25IZWFkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsIH0sIGVycm9yOiBuZXcgQXV0aFNlc3Npb25NaXNzaW5nRXJyb3IoKSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ0dFVCcsIGAke3RoaXMudXJsfS91c2VyYCwge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIGp3dDogKF9jID0gKF9iID0gZGF0YS5zZXNzaW9uKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWNjZXNzX3Rva2VuKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIHhmb3JtOiBfdXNlclJlc3BvbnNlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzQXV0aFNlc3Npb25NaXNzaW5nRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEpXVCBjb250YWlucyBhIGBzZXNzaW9uX2lkYCB3aGljaCBkb2VzIG5vdCBjb3JyZXNwb25kIHRvIGFuIGFjdGl2ZVxuICAgICAgICAgICAgICAgICAgICAvLyBzZXNzaW9uIGluIHRoZSBkYXRhYmFzZSwgaW5kaWNhdGluZyB0aGUgdXNlciBpcyBzaWduZWQgb3V0LlxuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9yZW1vdmVTZXNzaW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHJlbW92ZUl0ZW1Bc3luYyh0aGlzLnN0b3JhZ2UsIGAke3RoaXMuc3RvcmFnZUtleX0tY29kZS12ZXJpZmllcmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwgfSwgZXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdXNlciBkYXRhIGZvciBhIGxvZ2dlZCBpbiB1c2VyLlxuICAgICAqL1xuICAgIGFzeW5jIHVwZGF0ZVVzZXIoYXR0cmlidXRlcywgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMuaW5pdGlhbGl6ZVByb21pc2U7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9hY3F1aXJlTG9jaygtMSwgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3VwZGF0ZVVzZXIoYXR0cmlidXRlcywgb3B0aW9ucyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBfdXBkYXRlVXNlcihhdHRyaWJ1dGVzLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl91c2VTZXNzaW9uKGFzeW5jIChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGRhdGE6IHNlc3Npb25EYXRhLCBlcnJvcjogc2Vzc2lvbkVycm9yIH0gPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgaWYgKHNlc3Npb25FcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBzZXNzaW9uRXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghc2Vzc2lvbkRhdGEuc2Vzc2lvbikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXV0aFNlc3Npb25NaXNzaW5nRXJyb3IoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qgc2Vzc2lvbiA9IHNlc3Npb25EYXRhLnNlc3Npb247XG4gICAgICAgICAgICAgICAgbGV0IGNvZGVDaGFsbGVuZ2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIGxldCBjb2RlQ2hhbGxlbmdlTWV0aG9kID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5mbG93VHlwZSA9PT0gJ3BrY2UnICYmIGF0dHJpYnV0ZXMuZW1haWwgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgICAgIFtjb2RlQ2hhbGxlbmdlLCBjb2RlQ2hhbGxlbmdlTWV0aG9kXSA9IGF3YWl0IGdldENvZGVDaGFsbGVuZ2VBbmRNZXRob2QodGhpcy5zdG9yYWdlLCB0aGlzLnN0b3JhZ2VLZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yOiB1c2VyRXJyb3IgfSA9IGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQVVQnLCBgJHt0aGlzLnVybH0vdXNlcmAsIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICByZWRpcmVjdFRvOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZW1haWxSZWRpcmVjdFRvLFxuICAgICAgICAgICAgICAgICAgICBib2R5OiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGF0dHJpYnV0ZXMpLCB7IGNvZGVfY2hhbGxlbmdlOiBjb2RlQ2hhbGxlbmdlLCBjb2RlX2NoYWxsZW5nZV9tZXRob2Q6IGNvZGVDaGFsbGVuZ2VNZXRob2QgfSksXG4gICAgICAgICAgICAgICAgICAgIGp3dDogc2Vzc2lvbi5hY2Nlc3NfdG9rZW4sXG4gICAgICAgICAgICAgICAgICAgIHhmb3JtOiBfdXNlclJlc3BvbnNlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmICh1c2VyRXJyb3IpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IHVzZXJFcnJvcjtcbiAgICAgICAgICAgICAgICBzZXNzaW9uLnVzZXIgPSBkYXRhLnVzZXI7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fc2F2ZVNlc3Npb24oc2Vzc2lvbik7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fbm90aWZ5QWxsU3Vic2NyaWJlcnMoJ1VTRVJfVVBEQVRFRCcsIHNlc3Npb24pO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogc2Vzc2lvbi51c2VyIH0sIGVycm9yOiBudWxsIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwgfSwgZXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHNlc3Npb24gZGF0YSBmcm9tIHRoZSBjdXJyZW50IHNlc3Npb24uIElmIHRoZSBjdXJyZW50IHNlc3Npb24gaXMgZXhwaXJlZCwgc2V0U2Vzc2lvbiB3aWxsIHRha2UgY2FyZSBvZiByZWZyZXNoaW5nIGl0IHRvIG9idGFpbiBhIG5ldyBzZXNzaW9uLlxuICAgICAqIElmIHRoZSByZWZyZXNoIHRva2VuIG9yIGFjY2VzcyB0b2tlbiBpbiB0aGUgY3VycmVudCBzZXNzaW9uIGlzIGludmFsaWQsIGFuIGVycm9yIHdpbGwgYmUgdGhyb3duLlxuICAgICAqIEBwYXJhbSBjdXJyZW50U2Vzc2lvbiBUaGUgY3VycmVudCBzZXNzaW9uIHRoYXQgbWluaW1hbGx5IGNvbnRhaW5zIGFuIGFjY2VzcyB0b2tlbiBhbmQgcmVmcmVzaCB0b2tlbi5cbiAgICAgKi9cbiAgICBhc3luYyBzZXRTZXNzaW9uKGN1cnJlbnRTZXNzaW9uKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuaW5pdGlhbGl6ZVByb21pc2U7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9hY3F1aXJlTG9jaygtMSwgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3NldFNlc3Npb24oY3VycmVudFNlc3Npb24pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgX3NldFNlc3Npb24oY3VycmVudFNlc3Npb24pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICghY3VycmVudFNlc3Npb24uYWNjZXNzX3Rva2VuIHx8ICFjdXJyZW50U2Vzc2lvbi5yZWZyZXNoX3Rva2VuKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEF1dGhTZXNzaW9uTWlzc2luZ0Vycm9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0aW1lTm93ID0gRGF0ZS5ub3coKSAvIDEwMDA7XG4gICAgICAgICAgICBsZXQgZXhwaXJlc0F0ID0gdGltZU5vdztcbiAgICAgICAgICAgIGxldCBoYXNFeHBpcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGxldCBzZXNzaW9uID0gbnVsbDtcbiAgICAgICAgICAgIGNvbnN0IHsgcGF5bG9hZCB9ID0gZGVjb2RlSldUKGN1cnJlbnRTZXNzaW9uLmFjY2Vzc190b2tlbik7XG4gICAgICAgICAgICBpZiAocGF5bG9hZC5leHApIHtcbiAgICAgICAgICAgICAgICBleHBpcmVzQXQgPSBwYXlsb2FkLmV4cDtcbiAgICAgICAgICAgICAgICBoYXNFeHBpcmVkID0gZXhwaXJlc0F0IDw9IHRpbWVOb3c7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaGFzRXhwaXJlZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZGF0YTogcmVmcmVzaGVkU2Vzc2lvbiwgZXJyb3IgfSA9IGF3YWl0IHRoaXMuX2NhbGxSZWZyZXNoVG9rZW4oY3VycmVudFNlc3Npb24ucmVmcmVzaF90b2tlbik7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvcjogZXJyb3IgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFyZWZyZXNoZWRTZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvcjogbnVsbCB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZXNzaW9uID0gcmVmcmVzaGVkU2Vzc2lvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHRoaXMuX2dldFVzZXIoY3VycmVudFNlc3Npb24uYWNjZXNzX3Rva2VuKTtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNlc3Npb24gPSB7XG4gICAgICAgICAgICAgICAgICAgIGFjY2Vzc190b2tlbjogY3VycmVudFNlc3Npb24uYWNjZXNzX3Rva2VuLFxuICAgICAgICAgICAgICAgICAgICByZWZyZXNoX3Rva2VuOiBjdXJyZW50U2Vzc2lvbi5yZWZyZXNoX3Rva2VuLFxuICAgICAgICAgICAgICAgICAgICB1c2VyOiBkYXRhLnVzZXIsXG4gICAgICAgICAgICAgICAgICAgIHRva2VuX3R5cGU6ICdiZWFyZXInLFxuICAgICAgICAgICAgICAgICAgICBleHBpcmVzX2luOiBleHBpcmVzQXQgLSB0aW1lTm93LFxuICAgICAgICAgICAgICAgICAgICBleHBpcmVzX2F0OiBleHBpcmVzQXQsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9zYXZlU2Vzc2lvbihzZXNzaW9uKTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9ub3RpZnlBbGxTdWJzY3JpYmVycygnU0lHTkVEX0lOJywgc2Vzc2lvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IHNlc3Npb24udXNlciwgc2Vzc2lvbiB9LCBlcnJvcjogbnVsbCB9O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgc2Vzc2lvbjogbnVsbCwgdXNlcjogbnVsbCB9LCBlcnJvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG5ldyBzZXNzaW9uLCByZWdhcmRsZXNzIG9mIGV4cGlyeSBzdGF0dXMuXG4gICAgICogVGFrZXMgaW4gYW4gb3B0aW9uYWwgY3VycmVudCBzZXNzaW9uLiBJZiBub3QgcGFzc2VkIGluLCB0aGVuIHJlZnJlc2hTZXNzaW9uKCkgd2lsbCBhdHRlbXB0IHRvIHJldHJpZXZlIGl0IGZyb20gZ2V0U2Vzc2lvbigpLlxuICAgICAqIElmIHRoZSBjdXJyZW50IHNlc3Npb24ncyByZWZyZXNoIHRva2VuIGlzIGludmFsaWQsIGFuIGVycm9yIHdpbGwgYmUgdGhyb3duLlxuICAgICAqIEBwYXJhbSBjdXJyZW50U2Vzc2lvbiBUaGUgY3VycmVudCBzZXNzaW9uLiBJZiBwYXNzZWQgaW4sIGl0IG11c3QgY29udGFpbiBhIHJlZnJlc2ggdG9rZW4uXG4gICAgICovXG4gICAgYXN5bmMgcmVmcmVzaFNlc3Npb24oY3VycmVudFNlc3Npb24pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5pbml0aWFsaXplUHJvbWlzZTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX2FjcXVpcmVMb2NrKC0xLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fcmVmcmVzaFNlc3Npb24oY3VycmVudFNlc3Npb24pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgX3JlZnJlc2hTZXNzaW9uKGN1cnJlbnRTZXNzaW9uKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fdXNlU2Vzc2lvbihhc3luYyAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIGlmICghY3VycmVudFNlc3Npb24pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTZXNzaW9uID0gKF9hID0gZGF0YS5zZXNzaW9uKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghKGN1cnJlbnRTZXNzaW9uID09PSBudWxsIHx8IGN1cnJlbnRTZXNzaW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdXJyZW50U2Vzc2lvbi5yZWZyZXNoX3Rva2VuKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXV0aFNlc3Npb25NaXNzaW5nRXJyb3IoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgeyBkYXRhOiBzZXNzaW9uLCBlcnJvciB9ID0gYXdhaXQgdGhpcy5fY2FsbFJlZnJlc2hUb2tlbihjdXJyZW50U2Vzc2lvbi5yZWZyZXNoX3Rva2VuKTtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yOiBlcnJvciB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXNlc3Npb24pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yOiBudWxsIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogc2Vzc2lvbi51c2VyLCBzZXNzaW9uIH0sIGVycm9yOiBudWxsIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwgfSwgZXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHNlc3Npb24gZGF0YSBmcm9tIGEgVVJMIHN0cmluZ1xuICAgICAqL1xuICAgIGFzeW5jIF9nZXRTZXNzaW9uRnJvbVVSTChwYXJhbXMsIGNhbGxiYWNrVXJsVHlwZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKCFpc0Jyb3dzZXIoKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXV0aEltcGxpY2l0R3JhbnRSZWRpcmVjdEVycm9yKCdObyBicm93c2VyIGRldGVjdGVkLicpO1xuICAgICAgICAgICAgLy8gSWYgdGhlcmUncyBhbiBlcnJvciBpbiB0aGUgVVJMLCBpdCBkb2Vzbid0IG1hdHRlciB3aGF0IGZsb3cgaXQgaXMsIHdlIGp1c3QgcmV0dXJuIHRoZSBlcnJvci5cbiAgICAgICAgICAgIGlmIChwYXJhbXMuZXJyb3IgfHwgcGFyYW1zLmVycm9yX2Rlc2NyaXB0aW9uIHx8IHBhcmFtcy5lcnJvcl9jb2RlKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIGVycm9yIGNsYXNzIHJldHVybmVkIGltcGxpZXMgdGhhdCB0aGUgcmVkaXJlY3QgaXMgZnJvbSBhbiBpbXBsaWNpdCBncmFudCBmbG93XG4gICAgICAgICAgICAgICAgLy8gYnV0IGl0IGNvdWxkIGFsc28gYmUgZnJvbSBhIHJlZGlyZWN0IGVycm9yIGZyb20gYSBQS0NFIGZsb3cuXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEF1dGhJbXBsaWNpdEdyYW50UmVkaXJlY3RFcnJvcihwYXJhbXMuZXJyb3JfZGVzY3JpcHRpb24gfHwgJ0Vycm9yIGluIFVSTCB3aXRoIHVuc3BlY2lmaWVkIGVycm9yX2Rlc2NyaXB0aW9uJywge1xuICAgICAgICAgICAgICAgICAgICBlcnJvcjogcGFyYW1zLmVycm9yIHx8ICd1bnNwZWNpZmllZF9lcnJvcicsXG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IHBhcmFtcy5lcnJvcl9jb2RlIHx8ICd1bnNwZWNpZmllZF9jb2RlJyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENoZWNrcyBmb3IgbWlzbWF0Y2hlcyBiZXR3ZWVuIHRoZSBmbG93VHlwZSBpbml0aWFsaXNlZCBpbiB0aGUgY2xpZW50IGFuZCB0aGUgVVJMIHBhcmFtZXRlcnNcbiAgICAgICAgICAgIHN3aXRjaCAoY2FsbGJhY2tVcmxUeXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnaW1wbGljaXQnOlxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5mbG93VHlwZSA9PT0gJ3BrY2UnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXV0aFBLQ0VHcmFudENvZGVFeGNoYW5nZUVycm9yKCdOb3QgYSB2YWxpZCBQS0NFIGZsb3cgdXJsLicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3BrY2UnOlxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5mbG93VHlwZSA9PT0gJ2ltcGxpY2l0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEF1dGhJbXBsaWNpdEdyYW50UmVkaXJlY3RFcnJvcignTm90IGEgdmFsaWQgaW1wbGljaXQgZ3JhbnQgZmxvdyB1cmwuJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAvLyB0aGVyZSdzIG5vIG1pc21hdGNoIHNvIHdlIGNvbnRpbnVlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTaW5jZSB0aGlzIGlzIGEgcmVkaXJlY3QgZm9yIFBLQ0UsIHdlIGF0dGVtcHQgdG8gcmV0cmlldmUgdGhlIGNvZGUgZnJvbSB0aGUgVVJMIGZvciB0aGUgY29kZSBleGNoYW5nZVxuICAgICAgICAgICAgaWYgKGNhbGxiYWNrVXJsVHlwZSA9PT0gJ3BrY2UnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGVidWcoJyNfaW5pdGlhbGl6ZSgpJywgJ2JlZ2luJywgJ2lzIFBLQ0UgZmxvdycsIHRydWUpO1xuICAgICAgICAgICAgICAgIGlmICghcGFyYW1zLmNvZGUpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBBdXRoUEtDRUdyYW50Q29kZUV4Y2hhbmdlRXJyb3IoJ05vIGNvZGUgZGV0ZWN0ZWQuJyk7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgdGhpcy5fZXhjaGFuZ2VDb2RlRm9yU2Vzc2lvbihwYXJhbXMuY29kZSk7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICBjb25zdCB1cmwgPSBuZXcgVVJMKHdpbmRvdy5sb2NhdGlvbi5ocmVmKTtcbiAgICAgICAgICAgICAgICB1cmwuc2VhcmNoUGFyYW1zLmRlbGV0ZSgnY29kZScpO1xuICAgICAgICAgICAgICAgIHdpbmRvdy5oaXN0b3J5LnJlcGxhY2VTdGF0ZSh3aW5kb3cuaGlzdG9yeS5zdGF0ZSwgJycsIHVybC50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHNlc3Npb246IGRhdGEuc2Vzc2lvbiwgcmVkaXJlY3RUeXBlOiBudWxsIH0sIGVycm9yOiBudWxsIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IHByb3ZpZGVyX3Rva2VuLCBwcm92aWRlcl9yZWZyZXNoX3Rva2VuLCBhY2Nlc3NfdG9rZW4sIHJlZnJlc2hfdG9rZW4sIGV4cGlyZXNfaW4sIGV4cGlyZXNfYXQsIHRva2VuX3R5cGUsIH0gPSBwYXJhbXM7XG4gICAgICAgICAgICBpZiAoIWFjY2Vzc190b2tlbiB8fCAhZXhwaXJlc19pbiB8fCAhcmVmcmVzaF90b2tlbiB8fCAhdG9rZW5fdHlwZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBdXRoSW1wbGljaXRHcmFudFJlZGlyZWN0RXJyb3IoJ05vIHNlc3Npb24gZGVmaW5lZCBpbiBVUkwnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHRpbWVOb3cgPSBNYXRoLnJvdW5kKERhdGUubm93KCkgLyAxMDAwKTtcbiAgICAgICAgICAgIGNvbnN0IGV4cGlyZXNJbiA9IHBhcnNlSW50KGV4cGlyZXNfaW4pO1xuICAgICAgICAgICAgbGV0IGV4cGlyZXNBdCA9IHRpbWVOb3cgKyBleHBpcmVzSW47XG4gICAgICAgICAgICBpZiAoZXhwaXJlc19hdCkge1xuICAgICAgICAgICAgICAgIGV4cGlyZXNBdCA9IHBhcnNlSW50KGV4cGlyZXNfYXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYWN0dWFsbHlFeHBpcmVzSW4gPSBleHBpcmVzQXQgLSB0aW1lTm93O1xuICAgICAgICAgICAgaWYgKGFjdHVhbGx5RXhwaXJlc0luICogMTAwMCA8PSBBVVRPX1JFRlJFU0hfVElDS19EVVJBVElPTl9NUykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgQHN1cGFiYXNlL2dvdHJ1ZS1qczogU2Vzc2lvbiBhcyByZXRyaWV2ZWQgZnJvbSBVUkwgZXhwaXJlcyBpbiAke2FjdHVhbGx5RXhwaXJlc0lufXMsIHNob3VsZCBoYXZlIGJlZW4gY2xvc2VyIHRvICR7ZXhwaXJlc0lufXNgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGlzc3VlZEF0ID0gZXhwaXJlc0F0IC0gZXhwaXJlc0luO1xuICAgICAgICAgICAgaWYgKHRpbWVOb3cgLSBpc3N1ZWRBdCA+PSAxMjApIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ0BzdXBhYmFzZS9nb3RydWUtanM6IFNlc3Npb24gYXMgcmV0cmlldmVkIGZyb20gVVJMIHdhcyBpc3N1ZWQgb3ZlciAxMjBzIGFnbywgVVJMIGNvdWxkIGJlIHN0YWxlJywgaXNzdWVkQXQsIGV4cGlyZXNBdCwgdGltZU5vdyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aW1lTm93IC0gaXNzdWVkQXQgPCAwKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdAc3VwYWJhc2UvZ290cnVlLWpzOiBTZXNzaW9uIGFzIHJldHJpZXZlZCBmcm9tIFVSTCB3YXMgaXNzdWVkIGluIHRoZSBmdXR1cmU/IENoZWNrIHRoZSBkZXZpY2UgY2xvY2sgZm9yIHNrZXcnLCBpc3N1ZWRBdCwgZXhwaXJlc0F0LCB0aW1lTm93KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHRoaXMuX2dldFVzZXIoYWNjZXNzX3Rva2VuKTtcbiAgICAgICAgICAgIGlmIChlcnJvcilcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIGNvbnN0IHNlc3Npb24gPSB7XG4gICAgICAgICAgICAgICAgcHJvdmlkZXJfdG9rZW4sXG4gICAgICAgICAgICAgICAgcHJvdmlkZXJfcmVmcmVzaF90b2tlbixcbiAgICAgICAgICAgICAgICBhY2Nlc3NfdG9rZW4sXG4gICAgICAgICAgICAgICAgZXhwaXJlc19pbjogZXhwaXJlc0luLFxuICAgICAgICAgICAgICAgIGV4cGlyZXNfYXQ6IGV4cGlyZXNBdCxcbiAgICAgICAgICAgICAgICByZWZyZXNoX3Rva2VuLFxuICAgICAgICAgICAgICAgIHRva2VuX3R5cGU6IHRva2VuX3R5cGUsXG4gICAgICAgICAgICAgICAgdXNlcjogZGF0YS51c2VyLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIFJlbW92ZSB0b2tlbnMgZnJvbSBVUkxcbiAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5oYXNoID0gJyc7XG4gICAgICAgICAgICB0aGlzLl9kZWJ1ZygnI19nZXRTZXNzaW9uRnJvbVVSTCgpJywgJ2NsZWFyaW5nIHdpbmRvdy5sb2NhdGlvbi5oYXNoJyk7XG4gICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHNlc3Npb24sIHJlZGlyZWN0VHlwZTogcGFyYW1zLnR5cGUgfSwgZXJyb3I6IG51bGwgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHNlc3Npb246IG51bGwsIHJlZGlyZWN0VHlwZTogbnVsbCB9LCBlcnJvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZSBjdXJyZW50IFVSTCBjb250YWlucyBwYXJhbWV0ZXJzIGdpdmVuIGJ5IGFuIGltcGxpY2l0IG9hdXRoIGdyYW50IGZsb3cgKGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM2NzQ5Lmh0bWwjc2VjdGlvbi00LjIpXG4gICAgICovXG4gICAgX2lzSW1wbGljaXRHcmFudENhbGxiYWNrKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gQm9vbGVhbihwYXJhbXMuYWNjZXNzX3Rva2VuIHx8IHBhcmFtcy5lcnJvcl9kZXNjcmlwdGlvbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgY3VycmVudCBVUkwgYW5kIGJhY2tpbmcgc3RvcmFnZSBjb250YWluIHBhcmFtZXRlcnMgZ2l2ZW4gYnkgYSBQS0NFIGZsb3dcbiAgICAgKi9cbiAgICBhc3luYyBfaXNQS0NFQ2FsbGJhY2socGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRTdG9yYWdlQ29udGVudCA9IGF3YWl0IGdldEl0ZW1Bc3luYyh0aGlzLnN0b3JhZ2UsIGAke3RoaXMuc3RvcmFnZUtleX0tY29kZS12ZXJpZmllcmApO1xuICAgICAgICByZXR1cm4gISEocGFyYW1zLmNvZGUgJiYgY3VycmVudFN0b3JhZ2VDb250ZW50KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5zaWRlIGEgYnJvd3NlciBjb250ZXh0LCBgc2lnbk91dCgpYCB3aWxsIHJlbW92ZSB0aGUgbG9nZ2VkIGluIHVzZXIgZnJvbSB0aGUgYnJvd3NlciBzZXNzaW9uIGFuZCBsb2cgdGhlbSBvdXQgLSByZW1vdmluZyBhbGwgaXRlbXMgZnJvbSBsb2NhbHN0b3JhZ2UgYW5kIHRoZW4gdHJpZ2dlciBhIGBcIlNJR05FRF9PVVRcImAgZXZlbnQuXG4gICAgICpcbiAgICAgKiBGb3Igc2VydmVyLXNpZGUgbWFuYWdlbWVudCwgeW91IGNhbiByZXZva2UgYWxsIHJlZnJlc2ggdG9rZW5zIGZvciBhIHVzZXIgYnkgcGFzc2luZyBhIHVzZXIncyBKV1QgdGhyb3VnaCB0byBgYXV0aC5hcGkuc2lnbk91dChKV1Q6IHN0cmluZylgLlxuICAgICAqIFRoZXJlIGlzIG5vIHdheSB0byByZXZva2UgYSB1c2VyJ3MgYWNjZXNzIHRva2VuIGp3dCB1bnRpbCBpdCBleHBpcmVzLiBJdCBpcyByZWNvbW1lbmRlZCB0byBzZXQgYSBzaG9ydGVyIGV4cGlyeSBvbiB0aGUgand0IGZvciB0aGlzIHJlYXNvbi5cbiAgICAgKlxuICAgICAqIElmIHVzaW5nIGBvdGhlcnNgIHNjb3BlLCBubyBgU0lHTkVEX09VVGAgZXZlbnQgaXMgZmlyZWQhXG4gICAgICovXG4gICAgYXN5bmMgc2lnbk91dChvcHRpb25zID0geyBzY29wZTogJ2dsb2JhbCcgfSkge1xuICAgICAgICBhd2FpdCB0aGlzLmluaXRpYWxpemVQcm9taXNlO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fYWNxdWlyZUxvY2soLTEsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9zaWduT3V0KG9wdGlvbnMpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgX3NpZ25PdXQoeyBzY29wZSB9ID0geyBzY29wZTogJ2dsb2JhbCcgfSkge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fdXNlU2Vzc2lvbihhc3luYyAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yOiBzZXNzaW9uRXJyb3IgfSA9IHJlc3VsdDtcbiAgICAgICAgICAgIGlmIChzZXNzaW9uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBlcnJvcjogc2Vzc2lvbkVycm9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhY2Nlc3NUb2tlbiA9IChfYSA9IGRhdGEuc2Vzc2lvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFjY2Vzc190b2tlbjtcbiAgICAgICAgICAgIGlmIChhY2Nlc3NUb2tlbikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHRoaXMuYWRtaW4uc2lnbk91dChhY2Nlc3NUb2tlbiwgc2NvcGUpO1xuICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZ25vcmUgNDA0cyBzaW5jZSB1c2VyIG1pZ2h0IG5vdCBleGlzdCBhbnltb3JlXG4gICAgICAgICAgICAgICAgICAgIC8vIGlnbm9yZSA0MDFzIHNpbmNlIGFuIGludmFsaWQgb3IgZXhwaXJlZCBKV1Qgc2hvdWxkIHNpZ24gb3V0IHRoZSBjdXJyZW50IHNlc3Npb25cbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoaXNBdXRoQXBpRXJyb3IoZXJyb3IpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAoZXJyb3Iuc3RhdHVzID09PSA0MDQgfHwgZXJyb3Iuc3RhdHVzID09PSA0MDEgfHwgZXJyb3Iuc3RhdHVzID09PSA0MDMpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZXJyb3IgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzY29wZSAhPT0gJ290aGVycycpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9yZW1vdmVTZXNzaW9uKCk7XG4gICAgICAgICAgICAgICAgYXdhaXQgcmVtb3ZlSXRlbUFzeW5jKHRoaXMuc3RvcmFnZSwgYCR7dGhpcy5zdG9yYWdlS2V5fS1jb2RlLXZlcmlmaWVyYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBlcnJvcjogbnVsbCB9O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgb25BdXRoU3RhdGVDaGFuZ2UoY2FsbGJhY2spIHtcbiAgICAgICAgY29uc3QgaWQgPSB1dWlkKCk7XG4gICAgICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IHtcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgY2FsbGJhY2ssXG4gICAgICAgICAgICB1bnN1YnNjcmliZTogKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RlYnVnKCcjdW5zdWJzY3JpYmUoKScsICdzdGF0ZSBjaGFuZ2UgY2FsbGJhY2sgd2l0aCBpZCByZW1vdmVkJywgaWQpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGVDaGFuZ2VFbWl0dGVycy5kZWxldGUoaWQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fZGVidWcoJyNvbkF1dGhTdGF0ZUNoYW5nZSgpJywgJ3JlZ2lzdGVyZWQgY2FsbGJhY2sgd2l0aCBpZCcsIGlkKTtcbiAgICAgICAgdGhpcy5zdGF0ZUNoYW5nZUVtaXR0ZXJzLnNldChpZCwgc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuaW5pdGlhbGl6ZVByb21pc2U7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9hY3F1aXJlTG9jaygtMSwgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX2VtaXRJbml0aWFsU2Vzc2lvbihpZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSkoKTtcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogeyBzdWJzY3JpcHRpb24gfSB9O1xuICAgIH1cbiAgICBhc3luYyBfZW1pdEluaXRpYWxTZXNzaW9uKGlkKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl91c2VTZXNzaW9uKGFzeW5jIChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZGF0YTogeyBzZXNzaW9uIH0sIGVycm9yLCB9ID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgIGlmIChlcnJvcilcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgYXdhaXQgKChfYSA9IHRoaXMuc3RhdGVDaGFuZ2VFbWl0dGVycy5nZXQoaWQpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbGJhY2soJ0lOSVRJQUxfU0VTU0lPTicsIHNlc3Npb24pKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9kZWJ1ZygnSU5JVElBTF9TRVNTSU9OJywgJ2NhbGxiYWNrIGlkJywgaWQsICdzZXNzaW9uJywgc2Vzc2lvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgKChfYiA9IHRoaXMuc3RhdGVDaGFuZ2VFbWl0dGVycy5nZXQoaWQpKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbGJhY2soJ0lOSVRJQUxfU0VTU0lPTicsIG51bGwpKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9kZWJ1ZygnSU5JVElBTF9TRVNTSU9OJywgJ2NhbGxiYWNrIGlkJywgaWQsICdlcnJvcicsIGVycik7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZHMgYSBwYXNzd29yZCByZXNldCByZXF1ZXN0IHRvIGFuIGVtYWlsIGFkZHJlc3MuIFRoaXMgbWV0aG9kIHN1cHBvcnRzIHRoZSBQS0NFIGZsb3cuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZW1haWwgVGhlIGVtYWlsIGFkZHJlc3Mgb2YgdGhlIHVzZXIuXG4gICAgICogQHBhcmFtIG9wdGlvbnMucmVkaXJlY3RUbyBUaGUgVVJMIHRvIHNlbmQgdGhlIHVzZXIgdG8gYWZ0ZXIgdGhleSBjbGljayB0aGUgcGFzc3dvcmQgcmVzZXQgbGluay5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5jYXB0Y2hhVG9rZW4gVmVyaWZpY2F0aW9uIHRva2VuIHJlY2VpdmVkIHdoZW4gdGhlIHVzZXIgY29tcGxldGVzIHRoZSBjYXB0Y2hhIG9uIHRoZSBzaXRlLlxuICAgICAqL1xuICAgIGFzeW5jIHJlc2V0UGFzc3dvcmRGb3JFbWFpbChlbWFpbCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGxldCBjb2RlQ2hhbGxlbmdlID0gbnVsbDtcbiAgICAgICAgbGV0IGNvZGVDaGFsbGVuZ2VNZXRob2QgPSBudWxsO1xuICAgICAgICBpZiAodGhpcy5mbG93VHlwZSA9PT0gJ3BrY2UnKSB7XG4gICAgICAgICAgICA7XG4gICAgICAgICAgICBbY29kZUNoYWxsZW5nZSwgY29kZUNoYWxsZW5nZU1ldGhvZF0gPSBhd2FpdCBnZXRDb2RlQ2hhbGxlbmdlQW5kTWV0aG9kKHRoaXMuc3RvcmFnZSwgdGhpcy5zdG9yYWdlS2V5LCB0cnVlIC8vIGlzUGFzc3dvcmRSZWNvdmVyeVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L3JlY292ZXJgLCB7XG4gICAgICAgICAgICAgICAgYm9keToge1xuICAgICAgICAgICAgICAgICAgICBlbWFpbCxcbiAgICAgICAgICAgICAgICAgICAgY29kZV9jaGFsbGVuZ2U6IGNvZGVDaGFsbGVuZ2UsXG4gICAgICAgICAgICAgICAgICAgIGNvZGVfY2hhbGxlbmdlX21ldGhvZDogY29kZUNoYWxsZW5nZU1ldGhvZCxcbiAgICAgICAgICAgICAgICAgICAgZ290cnVlX21ldGFfc2VjdXJpdHk6IHsgY2FwdGNoYV90b2tlbjogb3B0aW9ucy5jYXB0Y2hhVG9rZW4gfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICByZWRpcmVjdFRvOiBvcHRpb25zLnJlZGlyZWN0VG8sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBhbGwgdGhlIGlkZW50aXRpZXMgbGlua2VkIHRvIGEgdXNlci5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRVc2VySWRlbnRpdGllcygpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgdGhpcy5nZXRVc2VyKCk7XG4gICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IGlkZW50aXRpZXM6IChfYSA9IGRhdGEudXNlci5pZGVudGl0aWVzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXSB9LCBlcnJvcjogbnVsbCB9O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBsaW5rSWRlbnRpdHkoY3JlZGVudGlhbHMpIHtcbiAgICAgICAgaWYgKCd0b2tlbicgaW4gY3JlZGVudGlhbHMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxpbmtJZGVudGl0eUlkVG9rZW4oY3JlZGVudGlhbHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmxpbmtJZGVudGl0eU9BdXRoKGNyZWRlbnRpYWxzKTtcbiAgICB9XG4gICAgYXN5bmMgbGlua0lkZW50aXR5T0F1dGgoY3JlZGVudGlhbHMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgdGhpcy5fdXNlU2Vzc2lvbihhc3luYyAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZTtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICBjb25zdCB1cmwgPSBhd2FpdCB0aGlzLl9nZXRVcmxGb3JQcm92aWRlcihgJHt0aGlzLnVybH0vdXNlci9pZGVudGl0aWVzL2F1dGhvcml6ZWAsIGNyZWRlbnRpYWxzLnByb3ZpZGVyLCB7XG4gICAgICAgICAgICAgICAgICAgIHJlZGlyZWN0VG86IChfYSA9IGNyZWRlbnRpYWxzLm9wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZWRpcmVjdFRvLFxuICAgICAgICAgICAgICAgICAgICBzY29wZXM6IChfYiA9IGNyZWRlbnRpYWxzLm9wdGlvbnMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5zY29wZXMsXG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiAoX2MgPSBjcmVkZW50aWFscy5vcHRpb25zKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MucXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgICAgIHNraXBCcm93c2VyUmVkaXJlY3Q6IHRydWUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdHRVQnLCB1cmwsIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICBqd3Q6IChfZSA9IChfZCA9IGRhdGEuc2Vzc2lvbikgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmFjY2Vzc190b2tlbikgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICBpZiAoaXNCcm93c2VyKCkgJiYgISgoX2EgPSBjcmVkZW50aWFscy5vcHRpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2tpcEJyb3dzZXJSZWRpcmVjdCkpIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cubG9jYXRpb24uYXNzaWduKGRhdGEgPT09IG51bGwgfHwgZGF0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGF0YS51cmwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyBwcm92aWRlcjogY3JlZGVudGlhbHMucHJvdmlkZXIsIHVybDogZGF0YSA9PT0gbnVsbCB8fCBkYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkYXRhLnVybCB9LCBlcnJvcjogbnVsbCB9O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgcHJvdmlkZXI6IGNyZWRlbnRpYWxzLnByb3ZpZGVyLCB1cmw6IG51bGwgfSwgZXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGxpbmtJZGVudGl0eUlkVG9rZW4oY3JlZGVudGlhbHMpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3VzZVNlc3Npb24oYXN5bmMgKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGVycm9yOiBzZXNzaW9uRXJyb3IsIGRhdGE6IHsgc2Vzc2lvbiB9LCB9ID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgIGlmIChzZXNzaW9uRXJyb3IpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IHNlc3Npb25FcnJvcjtcbiAgICAgICAgICAgICAgICBjb25zdCB7IG9wdGlvbnMsIHByb3ZpZGVyLCB0b2tlbiwgYWNjZXNzX3Rva2VuLCBub25jZSB9ID0gY3JlZGVudGlhbHM7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ1BPU1QnLCBgJHt0aGlzLnVybH0vdG9rZW4/Z3JhbnRfdHlwZT1pZF90b2tlbmAsIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICBqd3Q6IChfYSA9IHNlc3Npb24gPT09IG51bGwgfHwgc2Vzc2lvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2Vzc2lvbi5hY2Nlc3NfdG9rZW4pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgYm9keToge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICBpZF90b2tlbjogdG9rZW4sXG4gICAgICAgICAgICAgICAgICAgICAgICBhY2Nlc3NfdG9rZW4sXG4gICAgICAgICAgICAgICAgICAgICAgICBub25jZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmtfaWRlbnRpdHk6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBnb3RydWVfbWV0YV9zZWN1cml0eTogeyBjYXB0Y2hhX3Rva2VuOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY2FwdGNoYVRva2VuIH0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHhmb3JtOiBfc2Vzc2lvblJlc3BvbnNlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IHJlcztcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFkYXRhIHx8ICFkYXRhLnNlc3Npb24gfHwgIWRhdGEudXNlcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogbmV3IEF1dGhJbnZhbGlkVG9rZW5SZXNwb25zZUVycm9yKCksXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChkYXRhLnNlc3Npb24pIHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fc2F2ZVNlc3Npb24oZGF0YS5zZXNzaW9uKTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fbm90aWZ5QWxsU3Vic2NyaWJlcnMoJ1VTRVJfVVBEQVRFRCcsIGRhdGEuc2Vzc2lvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGEsIGVycm9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvciB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVubGlua3MgYW4gaWRlbnRpdHkgZnJvbSBhIHVzZXIgYnkgZGVsZXRpbmcgaXQuIFRoZSB1c2VyIHdpbGwgbm8gbG9uZ2VyIGJlIGFibGUgdG8gc2lnbiBpbiB3aXRoIHRoYXQgaWRlbnRpdHkgb25jZSBpdCdzIHVubGlua2VkLlxuICAgICAqL1xuICAgIGFzeW5jIHVubGlua0lkZW50aXR5KGlkZW50aXR5KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fdXNlU2Vzc2lvbihhc3luYyAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ0RFTEVURScsIGAke3RoaXMudXJsfS91c2VyL2lkZW50aXRpZXMvJHtpZGVudGl0eS5pZGVudGl0eV9pZH1gLCB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgand0OiAoX2IgPSAoX2EgPSBkYXRhLnNlc3Npb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hY2Nlc3NfdG9rZW4pICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYSBuZXcgSldULlxuICAgICAqIEBwYXJhbSByZWZyZXNoVG9rZW4gQSB2YWxpZCByZWZyZXNoIHRva2VuIHRoYXQgd2FzIHJldHVybmVkIG9uIGxvZ2luLlxuICAgICAqL1xuICAgIGFzeW5jIF9yZWZyZXNoQWNjZXNzVG9rZW4ocmVmcmVzaFRva2VuKSB7XG4gICAgICAgIGNvbnN0IGRlYnVnTmFtZSA9IGAjX3JlZnJlc2hBY2Nlc3NUb2tlbigke3JlZnJlc2hUb2tlbi5zdWJzdHJpbmcoMCwgNSl9Li4uKWA7XG4gICAgICAgIHRoaXMuX2RlYnVnKGRlYnVnTmFtZSwgJ2JlZ2luJyk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBzdGFydGVkQXQgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgLy8gd2lsbCBhdHRlbXB0IHRvIHJlZnJlc2ggdGhlIHRva2VuIHdpdGggZXhwb25lbnRpYWwgYmFja29mZlxuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHJldHJ5YWJsZShhc3luYyAoYXR0ZW1wdCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChhdHRlbXB0ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBzbGVlcCgyMDAgKiBNYXRoLnBvdygyLCBhdHRlbXB0IC0gMSkpOyAvLyAyMDAsIDQwMCwgODAwLCAuLi5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fZGVidWcoZGVidWdOYW1lLCAncmVmcmVzaGluZyBhdHRlbXB0JywgYXR0ZW1wdCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L3Rva2VuP2dyYW50X3R5cGU9cmVmcmVzaF90b2tlbmAsIHtcbiAgICAgICAgICAgICAgICAgICAgYm9keTogeyByZWZyZXNoX3Rva2VuOiByZWZyZXNoVG9rZW4gfSxcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICB4Zm9ybTogX3Nlc3Npb25SZXNwb25zZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sIChhdHRlbXB0LCBlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRCYWNrT2ZmSW50ZXJ2YWwgPSAyMDAgKiBNYXRoLnBvdygyLCBhdHRlbXB0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKGVycm9yICYmXG4gICAgICAgICAgICAgICAgICAgIGlzQXV0aFJldHJ5YWJsZUZldGNoRXJyb3IoZXJyb3IpICYmXG4gICAgICAgICAgICAgICAgICAgIC8vIHJldHJ5YWJsZSBvbmx5IGlmIHRoZSByZXF1ZXN0IGNhbiBiZSBzZW50IGJlZm9yZSB0aGUgYmFja29mZiBvdmVyZmxvd3MgdGhlIHRpY2sgZHVyYXRpb25cbiAgICAgICAgICAgICAgICAgICAgRGF0ZS5ub3coKSArIG5leHRCYWNrT2ZmSW50ZXJ2YWwgLSBzdGFydGVkQXQgPCBBVVRPX1JFRlJFU0hfVElDS19EVVJBVElPTl9NUyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMuX2RlYnVnKGRlYnVnTmFtZSwgJ2Vycm9yJywgZXJyb3IpO1xuICAgICAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgc2Vzc2lvbjogbnVsbCwgdXNlcjogbnVsbCB9LCBlcnJvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0aGlzLl9kZWJ1ZyhkZWJ1Z05hbWUsICdlbmQnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfaXNWYWxpZFNlc3Npb24obWF5YmVTZXNzaW9uKSB7XG4gICAgICAgIGNvbnN0IGlzVmFsaWRTZXNzaW9uID0gdHlwZW9mIG1heWJlU2Vzc2lvbiA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgIG1heWJlU2Vzc2lvbiAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgJ2FjY2Vzc190b2tlbicgaW4gbWF5YmVTZXNzaW9uICYmXG4gICAgICAgICAgICAncmVmcmVzaF90b2tlbicgaW4gbWF5YmVTZXNzaW9uICYmXG4gICAgICAgICAgICAnZXhwaXJlc19hdCcgaW4gbWF5YmVTZXNzaW9uO1xuICAgICAgICByZXR1cm4gaXNWYWxpZFNlc3Npb247XG4gICAgfVxuICAgIGFzeW5jIF9oYW5kbGVQcm92aWRlclNpZ25Jbihwcm92aWRlciwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCB1cmwgPSBhd2FpdCB0aGlzLl9nZXRVcmxGb3JQcm92aWRlcihgJHt0aGlzLnVybH0vYXV0aG9yaXplYCwgcHJvdmlkZXIsIHtcbiAgICAgICAgICAgIHJlZGlyZWN0VG86IG9wdGlvbnMucmVkaXJlY3RUbyxcbiAgICAgICAgICAgIHNjb3Blczogb3B0aW9ucy5zY29wZXMsXG4gICAgICAgICAgICBxdWVyeVBhcmFtczogb3B0aW9ucy5xdWVyeVBhcmFtcyxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2RlYnVnKCcjX2hhbmRsZVByb3ZpZGVyU2lnbkluKCknLCAncHJvdmlkZXInLCBwcm92aWRlciwgJ29wdGlvbnMnLCBvcHRpb25zLCAndXJsJywgdXJsKTtcbiAgICAgICAgLy8gdHJ5IHRvIG9wZW4gb24gdGhlIGJyb3dzZXJcbiAgICAgICAgaWYgKGlzQnJvd3NlcigpICYmICFvcHRpb25zLnNraXBCcm93c2VyUmVkaXJlY3QpIHtcbiAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5hc3NpZ24odXJsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBkYXRhOiB7IHByb3ZpZGVyLCB1cmwgfSwgZXJyb3I6IG51bGwgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVjb3ZlcnMgdGhlIHNlc3Npb24gZnJvbSBMb2NhbFN0b3JhZ2UgYW5kIHJlZnJlc2hlcyB0aGUgdG9rZW5cbiAgICAgKiBOb3RlOiB0aGlzIG1ldGhvZCBpcyBhc3luYyB0byBhY2NvbW1vZGF0ZSBmb3IgQXN5bmNTdG9yYWdlIGUuZy4gaW4gUmVhY3QgbmF0aXZlLlxuICAgICAqL1xuICAgIGFzeW5jIF9yZWNvdmVyQW5kUmVmcmVzaCgpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgZGVidWdOYW1lID0gJyNfcmVjb3ZlckFuZFJlZnJlc2goKSc7XG4gICAgICAgIHRoaXMuX2RlYnVnKGRlYnVnTmFtZSwgJ2JlZ2luJyk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50U2Vzc2lvbiA9IChhd2FpdCBnZXRJdGVtQXN5bmModGhpcy5zdG9yYWdlLCB0aGlzLnN0b3JhZ2VLZXkpKTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50U2Vzc2lvbiAmJiB0aGlzLnVzZXJTdG9yYWdlKSB7XG4gICAgICAgICAgICAgICAgbGV0IG1heWJlVXNlciA9IChhd2FpdCBnZXRJdGVtQXN5bmModGhpcy51c2VyU3RvcmFnZSwgdGhpcy5zdG9yYWdlS2V5ICsgJy11c2VyJykpO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5zdG9yYWdlLmlzU2VydmVyICYmIE9iamVjdC5pcyh0aGlzLnN0b3JhZ2UsIHRoaXMudXNlclN0b3JhZ2UpICYmICFtYXliZVVzZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gc3RvcmFnZSBhbmQgdXNlclN0b3JhZ2UgYXJlIHRoZSBzYW1lIHN0b3JhZ2UgbWVkaXVtLCBmb3IgZXhhbXBsZVxuICAgICAgICAgICAgICAgICAgICAvLyB3aW5kb3cubG9jYWxTdG9yYWdlIGlmIHVzZXJTdG9yYWdlIGRvZXMgbm90IGhhdmUgdGhlIHVzZXIgZnJvbVxuICAgICAgICAgICAgICAgICAgICAvLyBzdG9yYWdlIHN0b3JlZCwgc3RvcmUgaXQgZmlyc3QgdGhlcmVieSBtaWdyYXRpbmcgdGhlIHVzZXIgb2JqZWN0XG4gICAgICAgICAgICAgICAgICAgIC8vIGZyb20gc3RvcmFnZSAtPiB1c2VyU3RvcmFnZVxuICAgICAgICAgICAgICAgICAgICBtYXliZVVzZXIgPSB7IHVzZXI6IGN1cnJlbnRTZXNzaW9uLnVzZXIgfTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgc2V0SXRlbUFzeW5jKHRoaXMudXNlclN0b3JhZ2UsIHRoaXMuc3RvcmFnZUtleSArICctdXNlcicsIG1heWJlVXNlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN1cnJlbnRTZXNzaW9uLnVzZXIgPSAoX2EgPSBtYXliZVVzZXIgPT09IG51bGwgfHwgbWF5YmVVc2VyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtYXliZVVzZXIudXNlcikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdXNlck5vdEF2YWlsYWJsZVByb3h5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjdXJyZW50U2Vzc2lvbiAmJiAhY3VycmVudFNlc3Npb24udXNlcikge1xuICAgICAgICAgICAgICAgIC8vIHVzZXIgc3RvcmFnZSBpcyBub3Qgc2V0LCBsZXQncyBjaGVjayBpZiBpdCB3YXMgcHJldmlvdXNseSBlbmFibGVkIHNvXG4gICAgICAgICAgICAgICAgLy8gd2UgYnJpbmcgYmFjayB0aGUgc3RvcmFnZSBhcyBpdCBzaG91bGQgYmVcbiAgICAgICAgICAgICAgICBpZiAoIWN1cnJlbnRTZXNzaW9uLnVzZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGVzdCBpZiB1c2VyU3RvcmFnZSB3YXMgcHJldmlvdXNseSBlbmFibGVkIGFuZCB0aGUgc3RvcmFnZSBtZWRpdW0gd2FzIHRoZSBzYW1lLCB0byBtb3ZlIHRoZSB1c2VyIGJhY2sgdW5kZXIgdGhlIHNhbWUga2V5XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlcGFyYXRlVXNlciA9IChhd2FpdCBnZXRJdGVtQXN5bmModGhpcy5zdG9yYWdlLCB0aGlzLnN0b3JhZ2VLZXkgKyAnLXVzZXInKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZXBhcmF0ZVVzZXIgJiYgKHNlcGFyYXRlVXNlciA9PT0gbnVsbCB8fCBzZXBhcmF0ZVVzZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNlcGFyYXRlVXNlci51c2VyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFNlc3Npb24udXNlciA9IHNlcGFyYXRlVXNlci51c2VyO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgcmVtb3ZlSXRlbUFzeW5jKHRoaXMuc3RvcmFnZSwgdGhpcy5zdG9yYWdlS2V5ICsgJy11c2VyJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBzZXRJdGVtQXN5bmModGhpcy5zdG9yYWdlLCB0aGlzLnN0b3JhZ2VLZXksIGN1cnJlbnRTZXNzaW9uKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTZXNzaW9uLnVzZXIgPSB1c2VyTm90QXZhaWxhYmxlUHJveHkoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2RlYnVnKGRlYnVnTmFtZSwgJ3Nlc3Npb24gZnJvbSBzdG9yYWdlJywgY3VycmVudFNlc3Npb24pO1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9pc1ZhbGlkU2Vzc2lvbihjdXJyZW50U2Vzc2lvbikpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kZWJ1ZyhkZWJ1Z05hbWUsICdzZXNzaW9uIGlzIG5vdCB2YWxpZCcpO1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50U2Vzc2lvbiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9yZW1vdmVTZXNzaW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGV4cGlyZXNXaXRoTWFyZ2luID0gKChfYiA9IGN1cnJlbnRTZXNzaW9uLmV4cGlyZXNfYXQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IEluZmluaXR5KSAqIDEwMDAgLSBEYXRlLm5vdygpIDwgRVhQSVJZX01BUkdJTl9NUztcbiAgICAgICAgICAgIHRoaXMuX2RlYnVnKGRlYnVnTmFtZSwgYHNlc3Npb24gaGFzJHtleHBpcmVzV2l0aE1hcmdpbiA/ICcnIDogJyBub3QnfSBleHBpcmVkIHdpdGggbWFyZ2luIG9mICR7RVhQSVJZX01BUkdJTl9NU31zYCk7XG4gICAgICAgICAgICBpZiAoZXhwaXJlc1dpdGhNYXJnaW4pIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5hdXRvUmVmcmVzaFRva2VuICYmIGN1cnJlbnRTZXNzaW9uLnJlZnJlc2hfdG9rZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgdGhpcy5fY2FsbFJlZnJlc2hUb2tlbihjdXJyZW50U2Vzc2lvbi5yZWZyZXNoX3Rva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNBdXRoUmV0cnlhYmxlRmV0Y2hFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kZWJ1ZyhkZWJ1Z05hbWUsICdyZWZyZXNoIGZhaWxlZCB3aXRoIGEgbm9uLXJldHJ5YWJsZSBlcnJvciwgcmVtb3ZpbmcgdGhlIHNlc3Npb24nLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fcmVtb3ZlU2Vzc2lvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY3VycmVudFNlc3Npb24udXNlciAmJlxuICAgICAgICAgICAgICAgIGN1cnJlbnRTZXNzaW9uLnVzZXIuX19pc1VzZXJOb3RBdmFpbGFibGVQcm94eSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgYSBwcm94eSB1c2VyLCB0cnkgdG8gZ2V0IHRoZSByZWFsIHVzZXIgZGF0YVxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3I6IHVzZXJFcnJvciB9ID0gYXdhaXQgdGhpcy5fZ2V0VXNlcihjdXJyZW50U2Vzc2lvbi5hY2Nlc3NfdG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXVzZXJFcnJvciAmJiAoZGF0YSA9PT0gbnVsbCB8fCBkYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkYXRhLnVzZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50U2Vzc2lvbi51c2VyID0gZGF0YS51c2VyO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fc2F2ZVNlc3Npb24oY3VycmVudFNlc3Npb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fbm90aWZ5QWxsU3Vic2NyaWJlcnMoJ1NJR05FRF9JTicsIGN1cnJlbnRTZXNzaW9uKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2RlYnVnKGRlYnVnTmFtZSwgJ2NvdWxkIG5vdCBnZXQgdXNlciBkYXRhLCBza2lwcGluZyBTSUdORURfSU4gbm90aWZpY2F0aW9uJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGdldFVzZXJFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZXR0aW5nIHVzZXIgZGF0YTonLCBnZXRVc2VyRXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kZWJ1ZyhkZWJ1Z05hbWUsICdlcnJvciBnZXR0aW5nIHVzZXIgZGF0YSwgc2tpcHBpbmcgU0lHTkVEX0lOIG5vdGlmaWNhdGlvbicsIGdldFVzZXJFcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gbm8gbmVlZCB0byBwZXJzaXN0IGN1cnJlbnRTZXNzaW9uIGFnYWluLCBhcyB3ZSBqdXN0IGxvYWRlZCBpdCBmcm9tXG4gICAgICAgICAgICAgICAgLy8gbG9jYWwgc3RvcmFnZTsgcGVyc2lzdGluZyBpdCBhZ2FpbiBtYXkgb3ZlcndyaXRlIGEgdmFsdWUgc2F2ZWQgYnlcbiAgICAgICAgICAgICAgICAvLyBhbm90aGVyIGNsaWVudCB3aXRoIGFjY2VzcyB0byB0aGUgc2FtZSBsb2NhbCBzdG9yYWdlXG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fbm90aWZ5QWxsU3Vic2NyaWJlcnMoJ1NJR05FRF9JTicsIGN1cnJlbnRTZXNzaW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLl9kZWJ1ZyhkZWJ1Z05hbWUsICdlcnJvcicsIGVycik7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0aGlzLl9kZWJ1ZyhkZWJ1Z05hbWUsICdlbmQnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBfY2FsbFJlZnJlc2hUb2tlbihyZWZyZXNoVG9rZW4pIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgaWYgKCFyZWZyZXNoVG9rZW4pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBdXRoU2Vzc2lvbk1pc3NpbmdFcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJlZnJlc2hpbmcgaXMgYWxyZWFkeSBpbiBwcm9ncmVzc1xuICAgICAgICBpZiAodGhpcy5yZWZyZXNoaW5nRGVmZXJyZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlZnJlc2hpbmdEZWZlcnJlZC5wcm9taXNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRlYnVnTmFtZSA9IGAjX2NhbGxSZWZyZXNoVG9rZW4oJHtyZWZyZXNoVG9rZW4uc3Vic3RyaW5nKDAsIDUpfS4uLilgO1xuICAgICAgICB0aGlzLl9kZWJ1ZyhkZWJ1Z05hbWUsICdiZWdpbicpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5yZWZyZXNoaW5nRGVmZXJyZWQgPSBuZXcgRGVmZXJyZWQoKTtcbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHRoaXMuX3JlZnJlc2hBY2Nlc3NUb2tlbihyZWZyZXNoVG9rZW4pO1xuICAgICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgaWYgKCFkYXRhLnNlc3Npb24pXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEF1dGhTZXNzaW9uTWlzc2luZ0Vycm9yKCk7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9zYXZlU2Vzc2lvbihkYXRhLnNlc3Npb24pO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fbm90aWZ5QWxsU3Vic2NyaWJlcnMoJ1RPS0VOX1JFRlJFU0hFRCcsIGRhdGEuc2Vzc2lvbik7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB7IGRhdGE6IGRhdGEuc2Vzc2lvbiwgZXJyb3I6IG51bGwgfTtcbiAgICAgICAgICAgIHRoaXMucmVmcmVzaGluZ0RlZmVycmVkLnJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLl9kZWJ1ZyhkZWJ1Z05hbWUsICdlcnJvcicsIGVycm9yKTtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB7IGRhdGE6IG51bGwsIGVycm9yIH07XG4gICAgICAgICAgICAgICAgaWYgKCFpc0F1dGhSZXRyeWFibGVGZXRjaEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9yZW1vdmVTZXNzaW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIChfYSA9IHRoaXMucmVmcmVzaGluZ0RlZmVycmVkKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAoX2IgPSB0aGlzLnJlZnJlc2hpbmdEZWZlcnJlZCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnJlamVjdChlcnJvcik7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRoaXMucmVmcmVzaGluZ0RlZmVycmVkID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX2RlYnVnKGRlYnVnTmFtZSwgJ2VuZCcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIF9ub3RpZnlBbGxTdWJzY3JpYmVycyhldmVudCwgc2Vzc2lvbiwgYnJvYWRjYXN0ID0gdHJ1ZSkge1xuICAgICAgICBjb25zdCBkZWJ1Z05hbWUgPSBgI19ub3RpZnlBbGxTdWJzY3JpYmVycygke2V2ZW50fSlgO1xuICAgICAgICB0aGlzLl9kZWJ1ZyhkZWJ1Z05hbWUsICdiZWdpbicsIHNlc3Npb24sIGBicm9hZGNhc3QgPSAke2Jyb2FkY2FzdH1gKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmJyb2FkY2FzdENoYW5uZWwgJiYgYnJvYWRjYXN0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5icm9hZGNhc3RDaGFubmVsLnBvc3RNZXNzYWdlKHsgZXZlbnQsIHNlc3Npb24gfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBlcnJvcnMgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IHByb21pc2VzID0gQXJyYXkuZnJvbSh0aGlzLnN0YXRlQ2hhbmdlRW1pdHRlcnMudmFsdWVzKCkpLm1hcChhc3luYyAoeCkgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHguY2FsbGJhY2soZXZlbnQsIHNlc3Npb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgICAgICAgICAgIGlmIChlcnJvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXJyb3JzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3JzW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3JzWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdGhpcy5fZGVidWcoZGVidWdOYW1lLCAnZW5kJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogc2V0IGN1cnJlbnRTZXNzaW9uIGFuZCBjdXJyZW50VXNlclxuICAgICAqIHByb2Nlc3MgdG8gX3N0YXJ0QXV0b1JlZnJlc2hUb2tlbiBpZiBwb3NzaWJsZVxuICAgICAqL1xuICAgIGFzeW5jIF9zYXZlU2Vzc2lvbihzZXNzaW9uKSB7XG4gICAgICAgIHRoaXMuX2RlYnVnKCcjX3NhdmVTZXNzaW9uKCknLCBzZXNzaW9uKTtcbiAgICAgICAgLy8gX3NhdmVTZXNzaW9uIGlzIGFsd2F5cyBjYWxsZWQgd2hlbmV2ZXIgYSBuZXcgc2Vzc2lvbiBoYXMgYmVlbiBhY3F1aXJlZFxuICAgICAgICAvLyBzbyB3ZSBjYW4gc2FmZWx5IHN1cHByZXNzIHRoZSB3YXJuaW5nIHJldHVybmVkIGJ5IGZ1dHVyZSBnZXRTZXNzaW9uIGNhbGxzXG4gICAgICAgIHRoaXMuc3VwcHJlc3NHZXRTZXNzaW9uV2FybmluZyA9IHRydWU7XG4gICAgICAgIC8vIENyZWF0ZSBhIHNoYWxsb3cgY29weSB0byB3b3JrIHdpdGgsIHRvIGF2b2lkIG11dGF0aW5nIHRoZSBvcmlnaW5hbCBzZXNzaW9uIG9iamVjdCBpZiBpdCdzIHVzZWQgZWxzZXdoZXJlXG4gICAgICAgIGNvbnN0IHNlc3Npb25Ub1Byb2Nlc3MgPSBPYmplY3QuYXNzaWduKHt9LCBzZXNzaW9uKTtcbiAgICAgICAgY29uc3QgdXNlcklzUHJveHkgPSBzZXNzaW9uVG9Qcm9jZXNzLnVzZXIgJiYgc2Vzc2lvblRvUHJvY2Vzcy51c2VyLl9faXNVc2VyTm90QXZhaWxhYmxlUHJveHkgPT09IHRydWU7XG4gICAgICAgIGlmICh0aGlzLnVzZXJTdG9yYWdlKSB7XG4gICAgICAgICAgICBpZiAoIXVzZXJJc1Byb3h5ICYmIHNlc3Npb25Ub1Byb2Nlc3MudXNlcikge1xuICAgICAgICAgICAgICAgIC8vIElmIGl0J3MgYSByZWFsIHVzZXIgb2JqZWN0LCBzYXZlIGl0IHRvIHVzZXJTdG9yYWdlLlxuICAgICAgICAgICAgICAgIGF3YWl0IHNldEl0ZW1Bc3luYyh0aGlzLnVzZXJTdG9yYWdlLCB0aGlzLnN0b3JhZ2VLZXkgKyAnLXVzZXInLCB7XG4gICAgICAgICAgICAgICAgICAgIHVzZXI6IHNlc3Npb25Ub1Byb2Nlc3MudXNlcixcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHVzZXJJc1Byb3h5KSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgaXQncyB0aGUgcHJveHksIGl0IG1lYW5zIHVzZXIgd2FzIG5vdCBmb3VuZCBpbiB1c2VyU3RvcmFnZS5cbiAgICAgICAgICAgICAgICAvLyBXZSBzaG91bGQgZW5zdXJlIG5vIHN0YWxlIHVzZXIgZGF0YSBmb3IgdGhpcyBrZXkgZXhpc3RzIGluIHVzZXJTdG9yYWdlIGlmIHdlIHdlcmUgdG8gc2F2ZSBudWxsLFxuICAgICAgICAgICAgICAgIC8vIG9yIHNpbXBseSBub3Qgc2F2ZSB0aGUgcHJveHkuIEZvciBub3csIHdlIGRvbid0IHNhdmUgdGhlIHByb3h5IGhlcmUuXG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlcmUncyBhIG5lZWQgdG8gY2xlYXIgdXNlclN0b3JhZ2UgaWYgdXNlciBiZWNvbWVzIHByb3h5LCB0aGF0IGxvZ2ljIHdvdWxkIGdvIGhlcmUuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBQcmVwYXJlIHRoZSBtYWluIHNlc3Npb24gZGF0YSBmb3IgcHJpbWFyeSBzdG9yYWdlOiByZW1vdmUgdGhlIHVzZXIgcHJvcGVydHkgYmVmb3JlIGNsb25pbmdcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgaW1wb3J0YW50IGJlY2F1c2UgdGhlIG9yaWdpbmFsIHNlc3Npb24udXNlciBtaWdodCBiZSB0aGUgcHJveHlcbiAgICAgICAgICAgIGNvbnN0IG1haW5TZXNzaW9uRGF0YSA9IE9iamVjdC5hc3NpZ24oe30sIHNlc3Npb25Ub1Byb2Nlc3MpO1xuICAgICAgICAgICAgZGVsZXRlIG1haW5TZXNzaW9uRGF0YS51c2VyOyAvLyBSZW1vdmUgdXNlciAocmVhbCBvciBwcm94eSkgYmVmb3JlIGNsb25pbmcgZm9yIG1haW4gc3RvcmFnZVxuICAgICAgICAgICAgY29uc3QgY2xvbmVkTWFpblNlc3Npb25EYXRhID0gZGVlcENsb25lKG1haW5TZXNzaW9uRGF0YSk7XG4gICAgICAgICAgICBhd2FpdCBzZXRJdGVtQXN5bmModGhpcy5zdG9yYWdlLCB0aGlzLnN0b3JhZ2VLZXksIGNsb25lZE1haW5TZXNzaW9uRGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBObyB1c2VyU3RvcmFnZSBpcyBjb25maWd1cmVkLlxuICAgICAgICAgICAgLy8gSW4gdGhpcyBjYXNlLCBzZXNzaW9uLnVzZXIgc2hvdWxkIGlkZWFsbHkgbm90IGJlIGEgcHJveHkuXG4gICAgICAgICAgICAvLyBJZiBpdCB3ZXJlLCBzdHJ1Y3R1cmVkQ2xvbmUgd291bGQgZmFpbC4gVGhpcyBpbXBsaWVzIGFuIGlzc3VlIGVsc2V3aGVyZSBpZiB1c2VyIGlzIGEgcHJveHkgaGVyZVxuICAgICAgICAgICAgY29uc3QgY2xvbmVkU2Vzc2lvbiA9IGRlZXBDbG9uZShzZXNzaW9uVG9Qcm9jZXNzKTsgLy8gc2Vzc2lvblRvUHJvY2VzcyBzdGlsbCBoYXMgaXRzIG9yaWdpbmFsIHVzZXIgcHJvcGVydHlcbiAgICAgICAgICAgIGF3YWl0IHNldEl0ZW1Bc3luYyh0aGlzLnN0b3JhZ2UsIHRoaXMuc3RvcmFnZUtleSwgY2xvbmVkU2Vzc2lvbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgX3JlbW92ZVNlc3Npb24oKSB7XG4gICAgICAgIHRoaXMuX2RlYnVnKCcjX3JlbW92ZVNlc3Npb24oKScpO1xuICAgICAgICBhd2FpdCByZW1vdmVJdGVtQXN5bmModGhpcy5zdG9yYWdlLCB0aGlzLnN0b3JhZ2VLZXkpO1xuICAgICAgICBhd2FpdCByZW1vdmVJdGVtQXN5bmModGhpcy5zdG9yYWdlLCB0aGlzLnN0b3JhZ2VLZXkgKyAnLWNvZGUtdmVyaWZpZXInKTtcbiAgICAgICAgYXdhaXQgcmVtb3ZlSXRlbUFzeW5jKHRoaXMuc3RvcmFnZSwgdGhpcy5zdG9yYWdlS2V5ICsgJy11c2VyJyk7XG4gICAgICAgIGlmICh0aGlzLnVzZXJTdG9yYWdlKSB7XG4gICAgICAgICAgICBhd2FpdCByZW1vdmVJdGVtQXN5bmModGhpcy51c2VyU3RvcmFnZSwgdGhpcy5zdG9yYWdlS2V5ICsgJy11c2VyJyk7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgdGhpcy5fbm90aWZ5QWxsU3Vic2NyaWJlcnMoJ1NJR05FRF9PVVQnLCBudWxsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbnkgcmVnaXN0ZXJlZCB2aXNpYmlsaXR5Y2hhbmdlIGNhbGxiYWNrLlxuICAgICAqXG4gICAgICoge0BzZWUgI3N0YXJ0QXV0b1JlZnJlc2h9XG4gICAgICoge0BzZWUgI3N0b3BBdXRvUmVmcmVzaH1cbiAgICAgKi9cbiAgICBfcmVtb3ZlVmlzaWJpbGl0eUNoYW5nZWRDYWxsYmFjaygpIHtcbiAgICAgICAgdGhpcy5fZGVidWcoJyNfcmVtb3ZlVmlzaWJpbGl0eUNoYW5nZWRDYWxsYmFjaygpJyk7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrID0gdGhpcy52aXNpYmlsaXR5Q2hhbmdlZENhbGxiYWNrO1xuICAgICAgICB0aGlzLnZpc2liaWxpdHlDaGFuZ2VkQ2FsbGJhY2sgPSBudWxsO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrICYmIGlzQnJvd3NlcigpICYmICh3aW5kb3cgPT09IG51bGwgfHwgd2luZG93ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcikpIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigndmlzaWJpbGl0eWNoYW5nZScsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcigncmVtb3ZpbmcgdmlzaWJpbGl0eWNoYW5nZSBjYWxsYmFjayBmYWlsZWQnLCBlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIGlzIHRoZSBwcml2YXRlIGltcGxlbWVudGF0aW9uIG9mIHtAbGluayAjc3RhcnRBdXRvUmVmcmVzaH0uIFVzZSB0aGlzXG4gICAgICogd2l0aGluIHRoZSBsaWJyYXJ5LlxuICAgICAqL1xuICAgIGFzeW5jIF9zdGFydEF1dG9SZWZyZXNoKCkge1xuICAgICAgICBhd2FpdCB0aGlzLl9zdG9wQXV0b1JlZnJlc2goKTtcbiAgICAgICAgdGhpcy5fZGVidWcoJyNfc3RhcnRBdXRvUmVmcmVzaCgpJyk7XG4gICAgICAgIGNvbnN0IHRpY2tlciA9IHNldEludGVydmFsKCgpID0+IHRoaXMuX2F1dG9SZWZyZXNoVG9rZW5UaWNrKCksIEFVVE9fUkVGUkVTSF9USUNLX0RVUkFUSU9OX01TKTtcbiAgICAgICAgdGhpcy5hdXRvUmVmcmVzaFRpY2tlciA9IHRpY2tlcjtcbiAgICAgICAgaWYgKHRpY2tlciAmJiB0eXBlb2YgdGlja2VyID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgdGlja2VyLnVucmVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAvLyB0aWNrZXIgaXMgYSBOb2RlSlMgVGltZW91dCBvYmplY3QgdGhhdCBoYXMgYW4gYHVucmVmYCBtZXRob2RcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvdGltZXJzLmh0bWwjdGltZW91dHVucmVmXG4gICAgICAgICAgICAvLyBXaGVuIGF1dG8gcmVmcmVzaCBpcyB1c2VkIGluIE5vZGVKUyAobGlrZSBmb3IgdGVzdGluZykgdGhlXG4gICAgICAgICAgICAvLyBgc2V0SW50ZXJ2YWxgIGlzIHByZXZlbnRpbmcgdGhlIHByb2Nlc3MgZnJvbSBiZWluZyBtYXJrZWQgYXNcbiAgICAgICAgICAgIC8vIGZpbmlzaGVkIGFuZCB0ZXN0cyBydW4gZW5kbGVzc2x5LiBUaGlzIGNhbiBiZSBwcmV2ZW50ZWQgYnkgY2FsbGluZ1xuICAgICAgICAgICAgLy8gYHVucmVmKClgIG9uIHRoZSByZXR1cm5lZCBvYmplY3QuXG4gICAgICAgICAgICB0aWNrZXIudW5yZWYoKTtcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgVFMgaGFzIG5vIGNvbnRleHQgb2YgRGVub1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBEZW5vICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgRGVuby51bnJlZlRpbWVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAvLyBzaW1pbGFyIGxpa2UgZm9yIE5vZGVKUywgYnV0IHdpdGggdGhlIERlbm8gQVBJXG4gICAgICAgICAgICAvLyBodHRwczovL2Rlbm8ubGFuZC9hcGlAbGF0ZXN0P3Vuc3RhYmxlJnM9RGVuby51bnJlZlRpbWVyXG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIFRTIGhhcyBubyBjb250ZXh0IG9mIERlbm9cbiAgICAgICAgICAgIERlbm8udW5yZWZUaW1lcih0aWNrZXIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJ1biB0aGUgdGljayBpbW1lZGlhdGVseSwgYnV0IGluIHRoZSBuZXh0IHBhc3Mgb2YgdGhlIGV2ZW50IGxvb3Agc28gdGhhdFxuICAgICAgICAvLyAjX2luaXRpYWxpemUgY2FuIGJlIGFsbG93ZWQgdG8gY29tcGxldGUgd2l0aG91dCByZWN1cnNpdmVseSB3YWl0aW5nIG9uXG4gICAgICAgIC8vIGl0c2VsZlxuICAgICAgICBzZXRUaW1lb3V0KGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuaW5pdGlhbGl6ZVByb21pc2U7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9hdXRvUmVmcmVzaFRva2VuVGljaygpO1xuICAgICAgICB9LCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBpcyB0aGUgcHJpdmF0ZSBpbXBsZW1lbnRhdGlvbiBvZiB7QGxpbmsgI3N0b3BBdXRvUmVmcmVzaH0uIFVzZSB0aGlzXG4gICAgICogd2l0aGluIHRoZSBsaWJyYXJ5LlxuICAgICAqL1xuICAgIGFzeW5jIF9zdG9wQXV0b1JlZnJlc2goKSB7XG4gICAgICAgIHRoaXMuX2RlYnVnKCcjX3N0b3BBdXRvUmVmcmVzaCgpJyk7XG4gICAgICAgIGNvbnN0IHRpY2tlciA9IHRoaXMuYXV0b1JlZnJlc2hUaWNrZXI7XG4gICAgICAgIHRoaXMuYXV0b1JlZnJlc2hUaWNrZXIgPSBudWxsO1xuICAgICAgICBpZiAodGlja2VyKSB7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKHRpY2tlcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhcnRzIGFuIGF1dG8tcmVmcmVzaCBwcm9jZXNzIGluIHRoZSBiYWNrZ3JvdW5kLiBUaGUgc2Vzc2lvbiBpcyBjaGVja2VkXG4gICAgICogZXZlcnkgZmV3IHNlY29uZHMuIENsb3NlIHRvIHRoZSB0aW1lIG9mIGV4cGlyYXRpb24gYSBwcm9jZXNzIGlzIHN0YXJ0ZWQgdG9cbiAgICAgKiByZWZyZXNoIHRoZSBzZXNzaW9uLiBJZiByZWZyZXNoaW5nIGZhaWxzIGl0IHdpbGwgYmUgcmV0cmllZCBmb3IgYXMgbG9uZyBhc1xuICAgICAqIG5lY2Vzc2FyeS5cbiAgICAgKlxuICAgICAqIElmIHlvdSBzZXQgdGhlIHtAbGluayBHb1RydWVDbGllbnRPcHRpb25zI2F1dG9SZWZyZXNoVG9rZW59IHlvdSBkb24ndCBuZWVkXG4gICAgICogdG8gY2FsbCB0aGlzIGZ1bmN0aW9uLCBpdCB3aWxsIGJlIGNhbGxlZCBmb3IgeW91LlxuICAgICAqXG4gICAgICogT24gYnJvd3NlcnMgdGhlIHJlZnJlc2ggcHJvY2VzcyB3b3JrcyBvbmx5IHdoZW4gdGhlIHRhYi93aW5kb3cgaXMgaW4gdGhlXG4gICAgICogZm9yZWdyb3VuZCB0byBjb25zZXJ2ZSByZXNvdXJjZXMgYXMgd2VsbCBhcyBwcmV2ZW50IHJhY2UgY29uZGl0aW9ucyBhbmRcbiAgICAgKiBmbG9vZGluZyBhdXRoIHdpdGggcmVxdWVzdHMuIElmIHlvdSBjYWxsIHRoaXMgbWV0aG9kIGFueSBtYW5hZ2VkXG4gICAgICogdmlzaWJpbGl0eSBjaGFuZ2UgY2FsbGJhY2sgd2lsbCBiZSByZW1vdmVkIGFuZCB5b3UgbXVzdCBtYW5hZ2UgdmlzaWJpbGl0eVxuICAgICAqIGNoYW5nZXMgb24geW91ciBvd24uXG4gICAgICpcbiAgICAgKiBPbiBub24tYnJvd3NlciBwbGF0Zm9ybXMgdGhlIHJlZnJlc2ggcHJvY2VzcyB3b3JrcyAqY29udGludW91c2x5KiBpbiB0aGVcbiAgICAgKiBiYWNrZ3JvdW5kLCB3aGljaCBtYXkgbm90IGJlIGRlc2lyYWJsZS4gWW91IHNob3VsZCBob29rIGludG8geW91clxuICAgICAqIHBsYXRmb3JtJ3MgZm9yZWdyb3VuZCBpbmRpY2F0aW9uIG1lY2hhbmlzbSBhbmQgY2FsbCB0aGVzZSBtZXRob2RzXG4gICAgICogYXBwcm9wcmlhdGVseSB0byBjb25zZXJ2ZSByZXNvdXJjZXMuXG4gICAgICpcbiAgICAgKiB7QHNlZSAjc3RvcEF1dG9SZWZyZXNofVxuICAgICAqL1xuICAgIGFzeW5jIHN0YXJ0QXV0b1JlZnJlc2goKSB7XG4gICAgICAgIHRoaXMuX3JlbW92ZVZpc2liaWxpdHlDaGFuZ2VkQ2FsbGJhY2soKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fc3RhcnRBdXRvUmVmcmVzaCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdG9wcyBhbiBhY3RpdmUgYXV0byByZWZyZXNoIHByb2Nlc3MgcnVubmluZyBpbiB0aGUgYmFja2dyb3VuZCAoaWYgYW55KS5cbiAgICAgKlxuICAgICAqIElmIHlvdSBjYWxsIHRoaXMgbWV0aG9kIGFueSBtYW5hZ2VkIHZpc2liaWxpdHkgY2hhbmdlIGNhbGxiYWNrIHdpbGwgYmVcbiAgICAgKiByZW1vdmVkIGFuZCB5b3UgbXVzdCBtYW5hZ2UgdmlzaWJpbGl0eSBjaGFuZ2VzIG9uIHlvdXIgb3duLlxuICAgICAqXG4gICAgICogU2VlIHtAbGluayAjc3RhcnRBdXRvUmVmcmVzaH0gZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKi9cbiAgICBhc3luYyBzdG9wQXV0b1JlZnJlc2goKSB7XG4gICAgICAgIHRoaXMuX3JlbW92ZVZpc2liaWxpdHlDaGFuZ2VkQ2FsbGJhY2soKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fc3RvcEF1dG9SZWZyZXNoKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJ1bnMgdGhlIGF1dG8gcmVmcmVzaCB0b2tlbiB0aWNrLlxuICAgICAqL1xuICAgIGFzeW5jIF9hdXRvUmVmcmVzaFRva2VuVGljaygpIHtcbiAgICAgICAgdGhpcy5fZGVidWcoJyNfYXV0b1JlZnJlc2hUb2tlblRpY2soKScsICdiZWdpbicpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fYWNxdWlyZUxvY2soMCwgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fdXNlU2Vzc2lvbihhc3luYyAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBkYXRhOiB7IHNlc3Npb24gfSwgfSA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXNlc3Npb24gfHwgIXNlc3Npb24ucmVmcmVzaF90b2tlbiB8fCAhc2Vzc2lvbi5leHBpcmVzX2F0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2RlYnVnKCcjX2F1dG9SZWZyZXNoVG9rZW5UaWNrKCknLCAnbm8gc2Vzc2lvbicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNlc3Npb24gd2lsbCBleHBpcmUgaW4gdGhpcyBtYW55IHRpY2tzIChvciBoYXMgYWxyZWFkeSBleHBpcmVkIGlmIDw9IDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXhwaXJlc0luVGlja3MgPSBNYXRoLmZsb29yKChzZXNzaW9uLmV4cGlyZXNfYXQgKiAxMDAwIC0gbm93KSAvIEFVVE9fUkVGUkVTSF9USUNLX0RVUkFUSU9OX01TKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kZWJ1ZygnI19hdXRvUmVmcmVzaFRva2VuVGljaygpJywgYGFjY2VzcyB0b2tlbiBleHBpcmVzIGluICR7ZXhwaXJlc0luVGlja3N9IHRpY2tzLCBhIHRpY2sgbGFzdHMgJHtBVVRPX1JFRlJFU0hfVElDS19EVVJBVElPTl9NU31tcywgcmVmcmVzaCB0aHJlc2hvbGQgaXMgJHtBVVRPX1JFRlJFU0hfVElDS19USFJFU0hPTER9IHRpY2tzYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV4cGlyZXNJblRpY2tzIDw9IEFVVE9fUkVGUkVTSF9USUNLX1RIUkVTSE9MRCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9jYWxsUmVmcmVzaFRva2VuKHNlc3Npb24ucmVmcmVzaF90b2tlbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0F1dG8gcmVmcmVzaCB0aWNrIGZhaWxlZCB3aXRoIGVycm9yLiBUaGlzIGlzIGxpa2VseSBhIHRyYW5zaWVudCBlcnJvci4nLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGVidWcoJyNfYXV0b1JlZnJlc2hUb2tlblRpY2soKScsICdlbmQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaWYgKGUuaXNBY3F1aXJlVGltZW91dCB8fCBlIGluc3RhbmNlb2YgTG9ja0FjcXVpcmVUaW1lb3V0RXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kZWJ1ZygnYXV0byByZWZyZXNoIHRva2VuIHRpY2sgbG9jayBub3QgYXZhaWxhYmxlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBjYWxsYmFja3Mgb24gdGhlIGJyb3dzZXIgLyBwbGF0Zm9ybSwgd2hpY2ggaW4tdHVybiBydW5cbiAgICAgKiBhbGdvcml0aG1zIHdoZW4gdGhlIGJyb3dzZXIgd2luZG93L3RhYiBhcmUgaW4gZm9yZWdyb3VuZC4gT24gbm9uLWJyb3dzZXJcbiAgICAgKiBwbGF0Zm9ybXMgaXQgYXNzdW1lcyBhbHdheXMgZm9yZWdyb3VuZC5cbiAgICAgKi9cbiAgICBhc3luYyBfaGFuZGxlVmlzaWJpbGl0eUNoYW5nZSgpIHtcbiAgICAgICAgdGhpcy5fZGVidWcoJyNfaGFuZGxlVmlzaWJpbGl0eUNoYW5nZSgpJyk7XG4gICAgICAgIGlmICghaXNCcm93c2VyKCkgfHwgISh3aW5kb3cgPT09IG51bGwgfHwgd2luZG93ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcikpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmF1dG9SZWZyZXNoVG9rZW4pIHtcbiAgICAgICAgICAgICAgICAvLyBpbiBub24tYnJvd3NlciBlbnZpcm9ubWVudHMgdGhlIHJlZnJlc2ggdG9rZW4gdGlja2VyIHJ1bnMgYWx3YXlzXG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydEF1dG9SZWZyZXNoKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMudmlzaWJpbGl0eUNoYW5nZWRDYWxsYmFjayA9IGFzeW5jICgpID0+IGF3YWl0IHRoaXMuX29uVmlzaWJpbGl0eUNoYW5nZWQoZmFsc2UpO1xuICAgICAgICAgICAgd2luZG93ID09PSBudWxsIHx8IHdpbmRvdyA9PT0gdm9pZCAwID8gdm9pZCAwIDogd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Zpc2liaWxpdHljaGFuZ2UnLCB0aGlzLnZpc2liaWxpdHlDaGFuZ2VkQ2FsbGJhY2spO1xuICAgICAgICAgICAgLy8gbm93IGltbWVkaWF0ZWx5IGNhbGwgdGhlIHZpc2JpbGl0eSBjaGFuZ2VkIGNhbGxiYWNrIHRvIHNldHVwIHdpdGggdGhlXG4gICAgICAgICAgICAvLyBjdXJyZW50IHZpc2JpbGl0eSBzdGF0ZVxuICAgICAgICAgICAgYXdhaXQgdGhpcy5fb25WaXNpYmlsaXR5Q2hhbmdlZCh0cnVlKTsgLy8gaW5pdGlhbCBjYWxsXG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdfaGFuZGxlVmlzaWJpbGl0eUNoYW5nZScsIGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsYmFjayByZWdpc3RlcmVkIHdpdGggYHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd2aXNpYmlsaXR5Y2hhbmdlJylgLlxuICAgICAqL1xuICAgIGFzeW5jIF9vblZpc2liaWxpdHlDaGFuZ2VkKGNhbGxlZEZyb21Jbml0aWFsaXplKSB7XG4gICAgICAgIGNvbnN0IG1ldGhvZE5hbWUgPSBgI19vblZpc2liaWxpdHlDaGFuZ2VkKCR7Y2FsbGVkRnJvbUluaXRpYWxpemV9KWA7XG4gICAgICAgIHRoaXMuX2RlYnVnKG1ldGhvZE5hbWUsICd2aXNpYmlsaXR5U3RhdGUnLCBkb2N1bWVudC52aXNpYmlsaXR5U3RhdGUpO1xuICAgICAgICBpZiAoZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlID09PSAndmlzaWJsZScpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmF1dG9SZWZyZXNoVG9rZW4pIHtcbiAgICAgICAgICAgICAgICAvLyBpbiBicm93c2VyIGVudmlyb25tZW50cyB0aGUgcmVmcmVzaCB0b2tlbiB0aWNrZXIgcnVucyBvbmx5IG9uIGZvY3VzZWQgdGFic1xuICAgICAgICAgICAgICAgIC8vIHdoaWNoIHByZXZlbnRzIHJhY2UgY29uZGl0aW9uc1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0QXV0b1JlZnJlc2goKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghY2FsbGVkRnJvbUluaXRpYWxpemUpIHtcbiAgICAgICAgICAgICAgICAvLyBjYWxsZWQgd2hlbiB0aGUgdmlzaWJpbGl0eSBoYXMgY2hhbmdlZCwgaS5lLiB0aGUgYnJvd3NlclxuICAgICAgICAgICAgICAgIC8vIHRyYW5zaXRpb25lZCBmcm9tIGhpZGRlbiAtPiB2aXNpYmxlIHNvIHdlIG5lZWQgdG8gc2VlIGlmIHRoZSBzZXNzaW9uXG4gICAgICAgICAgICAgICAgLy8gc2hvdWxkIGJlIHJlY292ZXJlZCBpbW1lZGlhdGVseS4uLiBidXQgdG8gZG8gdGhhdCB3ZSBuZWVkIHRvIGFjcXVpcmVcbiAgICAgICAgICAgICAgICAvLyB0aGUgbG9jayBmaXJzdCBhc3luY2hyb25vdXNseVxuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuaW5pdGlhbGl6ZVByb21pc2U7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fYWNxdWlyZUxvY2soLTEsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRvY3VtZW50LnZpc2liaWxpdHlTdGF0ZSAhPT0gJ3Zpc2libGUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kZWJ1ZyhtZXRob2ROYW1lLCAnYWNxdWlyZWQgdGhlIGxvY2sgdG8gcmVjb3ZlciB0aGUgc2Vzc2lvbiwgYnV0IHRoZSBicm93c2VyIHZpc2liaWxpdHlTdGF0ZSBpcyBubyBsb25nZXIgdmlzaWJsZSwgYWJvcnRpbmcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHZpc2liaWxpdHkgaGFzIGNoYW5nZWQgd2hpbGUgd2FpdGluZyBmb3IgdGhlIGxvY2ssIGFib3J0XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gcmVjb3ZlciB0aGUgc2Vzc2lvblxuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9yZWNvdmVyQW5kUmVmcmVzaCgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRvY3VtZW50LnZpc2liaWxpdHlTdGF0ZSA9PT0gJ2hpZGRlbicpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmF1dG9SZWZyZXNoVG9rZW4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdG9wQXV0b1JlZnJlc2goKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgdGhlIHJlbGV2YW50IGxvZ2luIFVSTCBmb3IgYSB0aGlyZC1wYXJ0eSBwcm92aWRlci5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5yZWRpcmVjdFRvIEEgVVJMIG9yIG1vYmlsZSBhZGRyZXNzIHRvIHNlbmQgdGhlIHVzZXIgdG8gYWZ0ZXIgdGhleSBhcmUgY29uZmlybWVkLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLnNjb3BlcyBBIHNwYWNlLXNlcGFyYXRlZCBsaXN0IG9mIHNjb3BlcyBncmFudGVkIHRvIHRoZSBPQXV0aCBhcHBsaWNhdGlvbi5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5xdWVyeVBhcmFtcyBBbiBvYmplY3Qgb2Yga2V5LXZhbHVlIHBhaXJzIGNvbnRhaW5pbmcgcXVlcnkgcGFyYW1ldGVycyBncmFudGVkIHRvIHRoZSBPQXV0aCBhcHBsaWNhdGlvbi5cbiAgICAgKi9cbiAgICBhc3luYyBfZ2V0VXJsRm9yUHJvdmlkZXIodXJsLCBwcm92aWRlciwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCB1cmxQYXJhbXMgPSBbYHByb3ZpZGVyPSR7ZW5jb2RlVVJJQ29tcG9uZW50KHByb3ZpZGVyKX1gXTtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5yZWRpcmVjdFRvKSB7XG4gICAgICAgICAgICB1cmxQYXJhbXMucHVzaChgcmVkaXJlY3RfdG89JHtlbmNvZGVVUklDb21wb25lbnQob3B0aW9ucy5yZWRpcmVjdFRvKX1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNjb3Blcykge1xuICAgICAgICAgICAgdXJsUGFyYW1zLnB1c2goYHNjb3Blcz0ke2VuY29kZVVSSUNvbXBvbmVudChvcHRpb25zLnNjb3Blcyl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZmxvd1R5cGUgPT09ICdwa2NlJykge1xuICAgICAgICAgICAgY29uc3QgW2NvZGVDaGFsbGVuZ2UsIGNvZGVDaGFsbGVuZ2VNZXRob2RdID0gYXdhaXQgZ2V0Q29kZUNoYWxsZW5nZUFuZE1ldGhvZCh0aGlzLnN0b3JhZ2UsIHRoaXMuc3RvcmFnZUtleSk7XG4gICAgICAgICAgICBjb25zdCBmbG93UGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh7XG4gICAgICAgICAgICAgICAgY29kZV9jaGFsbGVuZ2U6IGAke2VuY29kZVVSSUNvbXBvbmVudChjb2RlQ2hhbGxlbmdlKX1gLFxuICAgICAgICAgICAgICAgIGNvZGVfY2hhbGxlbmdlX21ldGhvZDogYCR7ZW5jb2RlVVJJQ29tcG9uZW50KGNvZGVDaGFsbGVuZ2VNZXRob2QpfWAsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHVybFBhcmFtcy5wdXNoKGZsb3dQYXJhbXMudG9TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5xdWVyeVBhcmFtcykge1xuICAgICAgICAgICAgY29uc3QgcXVlcnkgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKG9wdGlvbnMucXVlcnlQYXJhbXMpO1xuICAgICAgICAgICAgdXJsUGFyYW1zLnB1c2gocXVlcnkudG9TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5za2lwQnJvd3NlclJlZGlyZWN0KSB7XG4gICAgICAgICAgICB1cmxQYXJhbXMucHVzaChgc2tpcF9odHRwX3JlZGlyZWN0PSR7b3B0aW9ucy5za2lwQnJvd3NlclJlZGlyZWN0fWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgJHt1cmx9PyR7dXJsUGFyYW1zLmpvaW4oJyYnKX1gO1xuICAgIH1cbiAgICBhc3luYyBfdW5lbnJvbGwocGFyYW1zKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fdXNlU2Vzc2lvbihhc3luYyAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZGF0YTogc2Vzc2lvbkRhdGEsIGVycm9yOiBzZXNzaW9uRXJyb3IgfSA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICBpZiAoc2Vzc2lvbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yOiBzZXNzaW9uRXJyb3IgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdERUxFVEUnLCBgJHt0aGlzLnVybH0vZmFjdG9ycy8ke3BhcmFtcy5mYWN0b3JJZH1gLCB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgand0OiAoX2EgPSBzZXNzaW9uRGF0YSA9PT0gbnVsbCB8fCBzZXNzaW9uRGF0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2Vzc2lvbkRhdGEuc2Vzc2lvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFjY2Vzc190b2tlbixcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBfZW5yb2xsKHBhcmFtcykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3VzZVNlc3Npb24oYXN5bmMgKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBkYXRhOiBzZXNzaW9uRGF0YSwgZXJyb3I6IHNlc3Npb25FcnJvciB9ID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgIGlmIChzZXNzaW9uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3I6IHNlc3Npb25FcnJvciB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBib2R5ID0gT2JqZWN0LmFzc2lnbih7IGZyaWVuZGx5X25hbWU6IHBhcmFtcy5mcmllbmRseU5hbWUsIGZhY3Rvcl90eXBlOiBwYXJhbXMuZmFjdG9yVHlwZSB9LCAocGFyYW1zLmZhY3RvclR5cGUgPT09ICdwaG9uZSdcbiAgICAgICAgICAgICAgICAgICAgPyB7IHBob25lOiBwYXJhbXMucGhvbmUgfVxuICAgICAgICAgICAgICAgICAgICA6IHBhcmFtcy5mYWN0b3JUeXBlID09PSAndG90cCdcbiAgICAgICAgICAgICAgICAgICAgICAgID8geyBpc3N1ZXI6IHBhcmFtcy5pc3N1ZXIgfVxuICAgICAgICAgICAgICAgICAgICAgICAgOiB7fSkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IChhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnUE9TVCcsIGAke3RoaXMudXJsfS9mYWN0b3JzYCwge1xuICAgICAgICAgICAgICAgICAgICBib2R5LFxuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIGp3dDogKF9hID0gc2Vzc2lvbkRhdGEgPT09IG51bGwgfHwgc2Vzc2lvbkRhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNlc3Npb25EYXRhLnNlc3Npb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hY2Nlc3NfdG9rZW4sXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmZhY3RvclR5cGUgPT09ICd0b3RwJyAmJiBkYXRhLnR5cGUgPT09ICd0b3RwJyAmJiAoKF9iID0gZGF0YSA9PT0gbnVsbCB8fCBkYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkYXRhLnRvdHApID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5xcl9jb2RlKSkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhLnRvdHAucXJfY29kZSA9IGBkYXRhOmltYWdlL3N2Zyt4bWw7dXRmLTgsJHtkYXRhLnRvdHAucXJfY29kZX1gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhLCBlcnJvcjogbnVsbCB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIF92ZXJpZnkocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hY3F1aXJlTG9jaygtMSwgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fdXNlU2Vzc2lvbihhc3luYyAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBkYXRhOiBzZXNzaW9uRGF0YSwgZXJyb3I6IHNlc3Npb25FcnJvciB9ID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2Vzc2lvbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvcjogc2Vzc2lvbkVycm9yIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYm9keSA9IE9iamVjdC5hc3NpZ24oeyBjaGFsbGVuZ2VfaWQ6IHBhcmFtcy5jaGFsbGVuZ2VJZCB9LCAoJ3dlYmF1dGhuJyBpbiBwYXJhbXNcbiAgICAgICAgICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdlYmF1dGhuOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHBhcmFtcy53ZWJhdXRobiksIHsgY3JlZGVudGlhbF9yZXNwb25zZTogcGFyYW1zLndlYmF1dGhuLnR5cGUgPT09ICdjcmVhdGUnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHNlcmlhbGl6ZUNyZWRlbnRpYWxDcmVhdGlvblJlc3BvbnNlKHBhcmFtcy53ZWJhdXRobi5jcmVkZW50aWFsX3Jlc3BvbnNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBzZXJpYWxpemVDcmVkZW50aWFsUmVxdWVzdFJlc3BvbnNlKHBhcmFtcy53ZWJhdXRobi5jcmVkZW50aWFsX3Jlc3BvbnNlKSB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIDogeyBjb2RlOiBwYXJhbXMuY29kZSB9KSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L2ZhY3RvcnMvJHtwYXJhbXMuZmFjdG9ySWR9L3ZlcmlmeWAsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHksXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgICAgICBqd3Q6IChfYSA9IHNlc3Npb25EYXRhID09PSBudWxsIHx8IHNlc3Npb25EYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZXNzaW9uRGF0YS5zZXNzaW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYWNjZXNzX3Rva2VuLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX3NhdmVTZXNzaW9uKE9iamVjdC5hc3NpZ24oeyBleHBpcmVzX2F0OiBNYXRoLnJvdW5kKERhdGUubm93KCkgLyAxMDAwKSArIGRhdGEuZXhwaXJlc19pbiB9LCBkYXRhKSk7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX25vdGlmeUFsbFN1YnNjcmliZXJzKCdNRkFfQ0hBTExFTkdFX1ZFUklGSUVEJywgZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGEsIGVycm9yIH07XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgX2NoYWxsZW5nZShwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FjcXVpcmVMb2NrKC0xLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl91c2VTZXNzaW9uKGFzeW5jIChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGRhdGE6IHNlc3Npb25EYXRhLCBlcnJvcjogc2Vzc2lvbkVycm9yIH0gPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZXNzaW9uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yOiBzZXNzaW9uRXJyb3IgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IChhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnUE9TVCcsIGAke3RoaXMudXJsfS9mYWN0b3JzLyR7cGFyYW1zLmZhY3RvcklkfS9jaGFsbGVuZ2VgLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5OiBwYXJhbXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgICAgICBqd3Q6IChfYSA9IHNlc3Npb25EYXRhID09PSBudWxsIHx8IHNlc3Npb25EYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZXNzaW9uRGF0YS5zZXNzaW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYWNjZXNzX3Rva2VuLFxuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5lcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgZGF0YSB9ID0gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhLnR5cGUgIT09ICd3ZWJhdXRobicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGEsIGVycm9yOiBudWxsIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChkYXRhLndlYmF1dGhuLnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2NyZWF0ZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkYXRhKSwgeyB3ZWJhdXRobjogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkYXRhLndlYmF1dGhuKSwgeyBjcmVkZW50aWFsX29wdGlvbnM6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZGF0YS53ZWJhdXRobi5jcmVkZW50aWFsX29wdGlvbnMpLCB7IHB1YmxpY0tleTogZGVzZXJpYWxpemVDcmVkZW50aWFsQ3JlYXRpb25PcHRpb25zKGRhdGEud2ViYXV0aG4uY3JlZGVudGlhbF9vcHRpb25zLnB1YmxpY0tleSkgfSkgfSkgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdyZXF1ZXN0JzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRhdGEpLCB7IHdlYmF1dGhuOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRhdGEud2ViYXV0aG4pLCB7IGNyZWRlbnRpYWxfb3B0aW9uczogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkYXRhLndlYmF1dGhuLmNyZWRlbnRpYWxfb3B0aW9ucyksIHsgcHVibGljS2V5OiBkZXNlcmlhbGl6ZUNyZWRlbnRpYWxSZXF1ZXN0T3B0aW9ucyhkYXRhLndlYmF1dGhuLmNyZWRlbnRpYWxfb3B0aW9ucy5wdWJsaWNLZXkpIH0pIH0pIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICoge0BzZWUgR29UcnVlTUZBQXBpI2NoYWxsZW5nZUFuZFZlcmlmeX1cbiAgICAgKi9cbiAgICBhc3luYyBfY2hhbGxlbmdlQW5kVmVyaWZ5KHBhcmFtcykge1xuICAgICAgICAvLyBib3RoIF9jaGFsbGVuZ2UgYW5kIF92ZXJpZnkgaW5kZXBlbmRlbnRseSBhY3F1aXJlIHRoZSBsb2NrLCBzbyBubyBuZWVkXG4gICAgICAgIC8vIHRvIGFjcXVpcmUgaXQgaGVyZVxuICAgICAgICBjb25zdCB7IGRhdGE6IGNoYWxsZW5nZURhdGEsIGVycm9yOiBjaGFsbGVuZ2VFcnJvciB9ID0gYXdhaXQgdGhpcy5fY2hhbGxlbmdlKHtcbiAgICAgICAgICAgIGZhY3RvcklkOiBwYXJhbXMuZmFjdG9ySWQsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoY2hhbGxlbmdlRXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yOiBjaGFsbGVuZ2VFcnJvciB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl92ZXJpZnkoe1xuICAgICAgICAgICAgZmFjdG9ySWQ6IHBhcmFtcy5mYWN0b3JJZCxcbiAgICAgICAgICAgIGNoYWxsZW5nZUlkOiBjaGFsbGVuZ2VEYXRhLmlkLFxuICAgICAgICAgICAgY29kZTogcGFyYW1zLmNvZGUsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiB7QHNlZSBHb1RydWVNRkFBcGkjbGlzdEZhY3RvcnN9XG4gICAgICovXG4gICAgYXN5bmMgX2xpc3RGYWN0b3JzKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIC8vIHVzZSAjZ2V0VXNlciBpbnN0ZWFkIG9mICNfZ2V0VXNlciBhcyB0aGUgZm9ybWVyIGFjcXVpcmVzIGEgbG9ja1xuICAgICAgICBjb25zdCB7IGRhdGE6IHsgdXNlciB9LCBlcnJvcjogdXNlckVycm9yLCB9ID0gYXdhaXQgdGhpcy5nZXRVc2VyKCk7XG4gICAgICAgIGlmICh1c2VyRXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yOiB1c2VyRXJyb3IgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkYXRhID0ge1xuICAgICAgICAgICAgYWxsOiBbXSxcbiAgICAgICAgICAgIHBob25lOiBbXSxcbiAgICAgICAgICAgIHRvdHA6IFtdLFxuICAgICAgICAgICAgd2ViYXV0aG46IFtdLFxuICAgICAgICB9O1xuICAgICAgICAvLyBsb29wIG92ZXIgdGhlIGZhY3RvcnMgT05DRVxuICAgICAgICBmb3IgKGNvbnN0IGZhY3RvciBvZiAoX2EgPSB1c2VyID09PSBudWxsIHx8IHVzZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHVzZXIuZmFjdG9ycykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW10pIHtcbiAgICAgICAgICAgIGRhdGEuYWxsLnB1c2goZmFjdG9yKTtcbiAgICAgICAgICAgIGlmIChmYWN0b3Iuc3RhdHVzID09PSAndmVyaWZpZWQnKSB7XG4gICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgIGRhdGFbZmFjdG9yLmZhY3Rvcl90eXBlXS5wdXNoKGZhY3Rvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICoge0BzZWUgR29UcnVlTUZBQXBpI2dldEF1dGhlbnRpY2F0b3JBc3N1cmFuY2VMZXZlbH1cbiAgICAgKi9cbiAgICBhc3luYyBfZ2V0QXV0aGVudGljYXRvckFzc3VyYW5jZUxldmVsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWNxdWlyZUxvY2soLTEsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl91c2VTZXNzaW9uKGFzeW5jIChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZGF0YTogeyBzZXNzaW9uIH0sIGVycm9yOiBzZXNzaW9uRXJyb3IsIH0gPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgaWYgKHNlc3Npb25FcnJvcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvcjogc2Vzc2lvbkVycm9yIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghc2Vzc2lvbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogeyBjdXJyZW50TGV2ZWw6IG51bGwsIG5leHRMZXZlbDogbnVsbCwgY3VycmVudEF1dGhlbnRpY2F0aW9uTWV0aG9kczogW10gfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB7IHBheWxvYWQgfSA9IGRlY29kZUpXVChzZXNzaW9uLmFjY2Vzc190b2tlbik7XG4gICAgICAgICAgICAgICAgbGV0IGN1cnJlbnRMZXZlbCA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKHBheWxvYWQuYWFsKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRMZXZlbCA9IHBheWxvYWQuYWFsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgbmV4dExldmVsID0gY3VycmVudExldmVsO1xuICAgICAgICAgICAgICAgIGNvbnN0IHZlcmlmaWVkRmFjdG9ycyA9IChfYiA9IChfYSA9IHNlc3Npb24udXNlci5mYWN0b3JzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZmlsdGVyKChmYWN0b3IpID0+IGZhY3Rvci5zdGF0dXMgPT09ICd2ZXJpZmllZCcpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBbXTtcbiAgICAgICAgICAgICAgICBpZiAodmVyaWZpZWRGYWN0b3JzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dExldmVsID0gJ2FhbDInO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50QXV0aGVudGljYXRpb25NZXRob2RzID0gcGF5bG9hZC5hbXIgfHwgW107XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyBjdXJyZW50TGV2ZWwsIG5leHRMZXZlbCwgY3VycmVudEF1dGhlbnRpY2F0aW9uTWV0aG9kcyB9LCBlcnJvcjogbnVsbCB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBmZXRjaEp3ayhraWQsIGp3a3MgPSB7IGtleXM6IFtdIH0pIHtcbiAgICAgICAgLy8gdHJ5IGZldGNoaW5nIGZyb20gdGhlIHN1cHBsaWVkIGp3a3NcbiAgICAgICAgbGV0IGp3ayA9IGp3a3Mua2V5cy5maW5kKChrZXkpID0+IGtleS5raWQgPT09IGtpZCk7XG4gICAgICAgIGlmIChqd2spIHtcbiAgICAgICAgICAgIHJldHVybiBqd2s7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgLy8gdHJ5IGZldGNoaW5nIGZyb20gY2FjaGVcbiAgICAgICAgandrID0gdGhpcy5qd2tzLmtleXMuZmluZCgoa2V5KSA9PiBrZXkua2lkID09PSBraWQpO1xuICAgICAgICAvLyBqd2sgZXhpc3RzIGFuZCBqd2tzIGlzbid0IHN0YWxlXG4gICAgICAgIGlmIChqd2sgJiYgdGhpcy5qd2tzX2NhY2hlZF9hdCArIEpXS1NfVFRMID4gbm93KSB7XG4gICAgICAgICAgICByZXR1cm4gandrO1xuICAgICAgICB9XG4gICAgICAgIC8vIGp3ayBpc24ndCBjYWNoZWQgaW4gbWVtb3J5IHNvIHdlIG5lZWQgdG8gZmV0Y2ggaXQgZnJvbSB0aGUgd2VsbC1rbm93biBlbmRwb2ludFxuICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnR0VUJywgYCR7dGhpcy51cmx9Ly53ZWxsLWtub3duL2p3a3MuanNvbmAsIHtcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkYXRhLmtleXMgfHwgZGF0YS5rZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5qd2tzID0gZGF0YTtcbiAgICAgICAgdGhpcy5qd2tzX2NhY2hlZF9hdCA9IG5vdztcbiAgICAgICAgLy8gRmluZCB0aGUgc2lnbmluZyBrZXlcbiAgICAgICAgandrID0gZGF0YS5rZXlzLmZpbmQoKGtleSkgPT4ga2V5LmtpZCA9PT0ga2lkKTtcbiAgICAgICAgaWYgKCFqd2spIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBqd2s7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV4dHJhY3RzIHRoZSBKV1QgY2xhaW1zIHByZXNlbnQgaW4gdGhlIGFjY2VzcyB0b2tlbiBieSBmaXJzdCB2ZXJpZnlpbmcgdGhlXG4gICAgICogSldUIGFnYWluc3QgdGhlIHNlcnZlcidzIEpTT04gV2ViIEtleSBTZXQgZW5kcG9pbnRcbiAgICAgKiBgLy53ZWxsLWtub3duL2p3a3MuanNvbmAgd2hpY2ggaXMgb2Z0ZW4gY2FjaGVkLCByZXN1bHRpbmcgaW4gc2lnbmlmaWNhbnRseVxuICAgICAqIGZhc3RlciByZXNwb25zZXMuIFByZWZlciB0aGlzIG1ldGhvZCBvdmVyIHtAbGluayAjZ2V0VXNlcn0gd2hpY2ggYWx3YXlzXG4gICAgICogc2VuZHMgYSByZXF1ZXN0IHRvIHRoZSBBdXRoIHNlcnZlciBmb3IgZWFjaCBKV1QuXG4gICAgICpcbiAgICAgKiBJZiB0aGUgcHJvamVjdCBpcyBub3QgdXNpbmcgYW4gYXN5bW1ldHJpYyBKV1Qgc2lnbmluZyBrZXkgKGxpa2UgRUNDIG9yXG4gICAgICogUlNBKSBpdCBhbHdheXMgc2VuZHMgYSByZXF1ZXN0IHRvIHRoZSBBdXRoIHNlcnZlciAoc2ltaWxhciB0byB7QGxpbmtcbiAgICAgKiAjZ2V0VXNlcn0pIHRvIHZlcmlmeSB0aGUgSldULlxuICAgICAqXG4gICAgICogQHBhcmFtIGp3dCBBbiBvcHRpb25hbCBzcGVjaWZpYyBKV1QgeW91IHdpc2ggdG8gdmVyaWZ5LCBub3QgdGhlIG9uZSB5b3VcbiAgICAgKiAgICAgICAgICAgIGNhbiBvYnRhaW4gZnJvbSB7QGxpbmsgI2dldFNlc3Npb259LlxuICAgICAqIEBwYXJhbSBvcHRpb25zIFZhcmlvdXMgYWRkaXRpb25hbCBvcHRpb25zIHRoYXQgYWxsb3cgeW91IHRvIGN1c3RvbWl6ZSB0aGVcbiAgICAgKiAgICAgICAgICAgICAgICBiZWhhdmlvciBvZiB0aGlzIG1ldGhvZC5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRDbGFpbXMoand0LCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxldCB0b2tlbiA9IGp3dDtcbiAgICAgICAgICAgIGlmICghdG9rZW4pIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCB0aGlzLmdldFNlc3Npb24oKTtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IgfHwgIWRhdGEuc2Vzc2lvbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0b2tlbiA9IGRhdGEuc2Vzc2lvbi5hY2Nlc3NfdG9rZW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IGhlYWRlciwgcGF5bG9hZCwgc2lnbmF0dXJlLCByYXc6IHsgaGVhZGVyOiByYXdIZWFkZXIsIHBheWxvYWQ6IHJhd1BheWxvYWQgfSwgfSA9IGRlY29kZUpXVCh0b2tlbik7XG4gICAgICAgICAgICBpZiAoIShvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuYWxsb3dFeHBpcmVkKSkge1xuICAgICAgICAgICAgICAgIC8vIFJlamVjdCBleHBpcmVkIEpXVHMgc2hvdWxkIG9ubHkgaGFwcGVuIGlmIGp3dCBhcmd1bWVudCB3YXMgcGFzc2VkXG4gICAgICAgICAgICAgICAgdmFsaWRhdGVFeHAocGF5bG9hZC5leHApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc2lnbmluZ0tleSA9ICFoZWFkZXIuYWxnIHx8XG4gICAgICAgICAgICAgICAgaGVhZGVyLmFsZy5zdGFydHNXaXRoKCdIUycpIHx8XG4gICAgICAgICAgICAgICAgIWhlYWRlci5raWQgfHxcbiAgICAgICAgICAgICAgICAhKCdjcnlwdG8nIGluIGdsb2JhbFRoaXMgJiYgJ3N1YnRsZScgaW4gZ2xvYmFsVGhpcy5jcnlwdG8pXG4gICAgICAgICAgICAgICAgPyBudWxsXG4gICAgICAgICAgICAgICAgOiBhd2FpdCB0aGlzLmZldGNoSndrKGhlYWRlci5raWQsIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMua2V5cykgPyB7IGtleXM6IG9wdGlvbnMua2V5cyB9IDogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmp3a3MpO1xuICAgICAgICAgICAgLy8gSWYgc3ltbWV0cmljIGFsZ29yaXRobSBvciBXZWJDcnlwdG8gQVBJIGlzIHVuYXZhaWxhYmxlLCBmYWxsYmFjayB0byBnZXRVc2VyKClcbiAgICAgICAgICAgIGlmICghc2lnbmluZ0tleSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHRoaXMuZ2V0VXNlcih0b2tlbik7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBnZXRVc2VyIHN1Y2NlZWRzIHNvIHRoZSBjbGFpbXMgaW4gdGhlIEpXVCBjYW4gYmUgdHJ1c3RlZFxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYWltczogcGF5bG9hZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcixcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25hdHVyZSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGFsZ29yaXRobSA9IGdldEFsZ29yaXRobShoZWFkZXIuYWxnKTtcbiAgICAgICAgICAgIC8vIENvbnZlcnQgSldLIHRvIENyeXB0b0tleVxuICAgICAgICAgICAgY29uc3QgcHVibGljS2V5ID0gYXdhaXQgY3J5cHRvLnN1YnRsZS5pbXBvcnRLZXkoJ2p3aycsIHNpZ25pbmdLZXksIGFsZ29yaXRobSwgdHJ1ZSwgW1xuICAgICAgICAgICAgICAgICd2ZXJpZnknLFxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAvLyBWZXJpZnkgdGhlIHNpZ25hdHVyZVxuICAgICAgICAgICAgY29uc3QgaXNWYWxpZCA9IGF3YWl0IGNyeXB0by5zdWJ0bGUudmVyaWZ5KGFsZ29yaXRobSwgcHVibGljS2V5LCBzaWduYXR1cmUsIHN0cmluZ1RvVWludDhBcnJheShgJHtyYXdIZWFkZXJ9LiR7cmF3UGF5bG9hZH1gKSk7XG4gICAgICAgICAgICBpZiAoIWlzVmFsaWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXV0aEludmFsaWRKd3RFcnJvcignSW52YWxpZCBKV1Qgc2lnbmF0dXJlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiB2ZXJpZmljYXRpb24gc3VjY2VlZHMsIGRlY29kZSBhbmQgcmV0dXJuIGNsYWltc1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIGNsYWltczogcGF5bG9hZCxcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyLFxuICAgICAgICAgICAgICAgICAgICBzaWduYXR1cmUsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxufVxuR29UcnVlQ2xpZW50Lm5leHRJbnN0YW5jZUlEID0gMDtcbmV4cG9ydCBkZWZhdWx0IEdvVHJ1ZUNsaWVudDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUdvVHJ1ZUNsaWVudC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/GoTrueClient.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/module/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AuthAdminApi: () => (/* reexport safe */ _AuthAdminApi__WEBPACK_IMPORTED_MODULE_2__[\"default\"]),\n/* harmony export */   AuthApiError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.AuthApiError),\n/* harmony export */   AuthClient: () => (/* reexport safe */ _AuthClient__WEBPACK_IMPORTED_MODULE_3__[\"default\"]),\n/* harmony export */   AuthError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.AuthError),\n/* harmony export */   AuthImplicitGrantRedirectError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.AuthImplicitGrantRedirectError),\n/* harmony export */   AuthInvalidCredentialsError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.AuthInvalidCredentialsError),\n/* harmony export */   AuthInvalidJwtError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.AuthInvalidJwtError),\n/* harmony export */   AuthInvalidTokenResponseError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.AuthInvalidTokenResponseError),\n/* harmony export */   AuthPKCEGrantCodeExchangeError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.AuthPKCEGrantCodeExchangeError),\n/* harmony export */   AuthRetryableFetchError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.AuthRetryableFetchError),\n/* harmony export */   AuthSessionMissingError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.AuthSessionMissingError),\n/* harmony export */   AuthUnknownError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.AuthUnknownError),\n/* harmony export */   AuthWeakPasswordError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.AuthWeakPasswordError),\n/* harmony export */   CustomAuthError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.CustomAuthError),\n/* harmony export */   GoTrueAdminApi: () => (/* reexport safe */ _GoTrueAdminApi__WEBPACK_IMPORTED_MODULE_0__[\"default\"]),\n/* harmony export */   GoTrueClient: () => (/* reexport safe */ _GoTrueClient__WEBPACK_IMPORTED_MODULE_1__[\"default\"]),\n/* harmony export */   NavigatorLockAcquireTimeoutError: () => (/* reexport safe */ _lib_locks__WEBPACK_IMPORTED_MODULE_6__.NavigatorLockAcquireTimeoutError),\n/* harmony export */   SIGN_OUT_SCOPES: () => (/* reexport safe */ _lib_types__WEBPACK_IMPORTED_MODULE_4__.SIGN_OUT_SCOPES),\n/* harmony export */   isAuthApiError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.isAuthApiError),\n/* harmony export */   isAuthError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.isAuthError),\n/* harmony export */   isAuthImplicitGrantRedirectError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.isAuthImplicitGrantRedirectError),\n/* harmony export */   isAuthRetryableFetchError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.isAuthRetryableFetchError),\n/* harmony export */   isAuthSessionMissingError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.isAuthSessionMissingError),\n/* harmony export */   isAuthWeakPasswordError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.isAuthWeakPasswordError),\n/* harmony export */   lockInternals: () => (/* reexport safe */ _lib_locks__WEBPACK_IMPORTED_MODULE_6__.internals),\n/* harmony export */   navigatorLock: () => (/* reexport safe */ _lib_locks__WEBPACK_IMPORTED_MODULE_6__.navigatorLock),\n/* harmony export */   processLock: () => (/* reexport safe */ _lib_locks__WEBPACK_IMPORTED_MODULE_6__.processLock)\n/* harmony export */ });\n/* harmony import */ var _GoTrueAdminApi__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./GoTrueAdminApi */ \"(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/GoTrueAdminApi.js\");\n/* harmony import */ var _GoTrueClient__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./GoTrueClient */ \"(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/GoTrueClient.js\");\n/* harmony import */ var _AuthAdminApi__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./AuthAdminApi */ \"(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/AuthAdminApi.js\");\n/* harmony import */ var _AuthClient__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./AuthClient */ \"(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/AuthClient.js\");\n/* harmony import */ var _lib_types__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./lib/types */ \"(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/types.js\");\n/* harmony import */ var _lib_errors__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./lib/errors */ \"(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/errors.js\");\n/* harmony import */ var _lib_locks__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./lib/locks */ \"(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/locks.js\");\n\n\n\n\n\n\n\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvYXV0aC1qcy9kaXN0L21vZHVsZS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQThDO0FBQ0o7QUFDQTtBQUNKO0FBQzRCO0FBQ3RDO0FBQ0M7QUFDMkY7QUFDeEgiLCJzb3VyY2VzIjpbIkQ6XFxuZXh0XFxvcmdcXG5vZGVfbW9kdWxlc1xcQHN1cGFiYXNlXFxhdXRoLWpzXFxkaXN0XFxtb2R1bGVcXGluZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBHb1RydWVBZG1pbkFwaSBmcm9tICcuL0dvVHJ1ZUFkbWluQXBpJztcbmltcG9ydCBHb1RydWVDbGllbnQgZnJvbSAnLi9Hb1RydWVDbGllbnQnO1xuaW1wb3J0IEF1dGhBZG1pbkFwaSBmcm9tICcuL0F1dGhBZG1pbkFwaSc7XG5pbXBvcnQgQXV0aENsaWVudCBmcm9tICcuL0F1dGhDbGllbnQnO1xuZXhwb3J0IHsgR29UcnVlQWRtaW5BcGksIEdvVHJ1ZUNsaWVudCwgQXV0aEFkbWluQXBpLCBBdXRoQ2xpZW50IH07XG5leHBvcnQgKiBmcm9tICcuL2xpYi90eXBlcyc7XG5leHBvcnQgKiBmcm9tICcuL2xpYi9lcnJvcnMnO1xuZXhwb3J0IHsgbmF2aWdhdG9yTG9jaywgTmF2aWdhdG9yTG9ja0FjcXVpcmVUaW1lb3V0RXJyb3IsIGludGVybmFscyBhcyBsb2NrSW50ZXJuYWxzLCBwcm9jZXNzTG9jaywgfSBmcm9tICcuL2xpYi9sb2Nrcyc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/base64url.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/module/lib/base64url.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   base64UrlToUint8Array: () => (/* binding */ base64UrlToUint8Array),\n/* harmony export */   byteFromBase64URL: () => (/* binding */ byteFromBase64URL),\n/* harmony export */   byteToBase64URL: () => (/* binding */ byteToBase64URL),\n/* harmony export */   bytesToBase64URL: () => (/* binding */ bytesToBase64URL),\n/* harmony export */   codepointToUTF8: () => (/* binding */ codepointToUTF8),\n/* harmony export */   stringFromBase64URL: () => (/* binding */ stringFromBase64URL),\n/* harmony export */   stringFromUTF8: () => (/* binding */ stringFromUTF8),\n/* harmony export */   stringToBase64URL: () => (/* binding */ stringToBase64URL),\n/* harmony export */   stringToUTF8: () => (/* binding */ stringToUTF8),\n/* harmony export */   stringToUint8Array: () => (/* binding */ stringToUint8Array)\n/* harmony export */ });\n/**\n * Avoid modifying this file. It's part of\n * https://github.com/supabase-community/base64url-js.  Submit all fixes on\n * that repo!\n */\n/**\n * An array of characters that encode 6 bits into a Base64-URL alphabet\n * character.\n */\nconst TO_BASE64URL = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'.split('');\n/**\n * An array of characters that can appear in a Base64-URL encoded string but\n * should be ignored.\n */\nconst IGNORE_BASE64URL = ' \\t\\n\\r='.split('');\n/**\n * An array of 128 numbers that map a Base64-URL character to 6 bits, or if -2\n * used to skip the character, or if -1 used to error out.\n */\nconst FROM_BASE64URL = (() => {\n    const charMap = new Array(128);\n    for (let i = 0; i < charMap.length; i += 1) {\n        charMap[i] = -1;\n    }\n    for (let i = 0; i < IGNORE_BASE64URL.length; i += 1) {\n        charMap[IGNORE_BASE64URL[i].charCodeAt(0)] = -2;\n    }\n    for (let i = 0; i < TO_BASE64URL.length; i += 1) {\n        charMap[TO_BASE64URL[i].charCodeAt(0)] = i;\n    }\n    return charMap;\n})();\n/**\n * Converts a byte to a Base64-URL string.\n *\n * @param byte The byte to convert, or null to flush at the end of the byte sequence.\n * @param state The Base64 conversion state. Pass an initial value of `{ queue: 0, queuedBits: 0 }`.\n * @param emit A function called with the next Base64 character when ready.\n */\nfunction byteToBase64URL(byte, state, emit) {\n    if (byte !== null) {\n        state.queue = (state.queue << 8) | byte;\n        state.queuedBits += 8;\n        while (state.queuedBits >= 6) {\n            const pos = (state.queue >> (state.queuedBits - 6)) & 63;\n            emit(TO_BASE64URL[pos]);\n            state.queuedBits -= 6;\n        }\n    }\n    else if (state.queuedBits > 0) {\n        state.queue = state.queue << (6 - state.queuedBits);\n        state.queuedBits = 6;\n        while (state.queuedBits >= 6) {\n            const pos = (state.queue >> (state.queuedBits - 6)) & 63;\n            emit(TO_BASE64URL[pos]);\n            state.queuedBits -= 6;\n        }\n    }\n}\n/**\n * Converts a String char code (extracted using `string.charCodeAt(position)`) to a sequence of Base64-URL characters.\n *\n * @param charCode The char code of the JavaScript string.\n * @param state The Base64 state. Pass an initial value of `{ queue: 0, queuedBits: 0 }`.\n * @param emit A function called with the next byte.\n */\nfunction byteFromBase64URL(charCode, state, emit) {\n    const bits = FROM_BASE64URL[charCode];\n    if (bits > -1) {\n        // valid Base64-URL character\n        state.queue = (state.queue << 6) | bits;\n        state.queuedBits += 6;\n        while (state.queuedBits >= 8) {\n            emit((state.queue >> (state.queuedBits - 8)) & 0xff);\n            state.queuedBits -= 8;\n        }\n    }\n    else if (bits === -2) {\n        // ignore spaces, tabs, newlines, =\n        return;\n    }\n    else {\n        throw new Error(`Invalid Base64-URL character \"${String.fromCharCode(charCode)}\"`);\n    }\n}\n/**\n * Converts a JavaScript string (which may include any valid character) into a\n * Base64-URL encoded string. The string is first encoded in UTF-8 which is\n * then encoded as Base64-URL.\n *\n * @param str The string to convert.\n */\nfunction stringToBase64URL(str) {\n    const base64 = [];\n    const emitter = (char) => {\n        base64.push(char);\n    };\n    const state = { queue: 0, queuedBits: 0 };\n    stringToUTF8(str, (byte) => {\n        byteToBase64URL(byte, state, emitter);\n    });\n    byteToBase64URL(null, state, emitter);\n    return base64.join('');\n}\n/**\n * Converts a Base64-URL encoded string into a JavaScript string. It is assumed\n * that the underlying string has been encoded as UTF-8.\n *\n * @param str The Base64-URL encoded string.\n */\nfunction stringFromBase64URL(str) {\n    const conv = [];\n    const utf8Emit = (codepoint) => {\n        conv.push(String.fromCodePoint(codepoint));\n    };\n    const utf8State = {\n        utf8seq: 0,\n        codepoint: 0,\n    };\n    const b64State = { queue: 0, queuedBits: 0 };\n    const byteEmit = (byte) => {\n        stringFromUTF8(byte, utf8State, utf8Emit);\n    };\n    for (let i = 0; i < str.length; i += 1) {\n        byteFromBase64URL(str.charCodeAt(i), b64State, byteEmit);\n    }\n    return conv.join('');\n}\n/**\n * Converts a Unicode codepoint to a multi-byte UTF-8 sequence.\n *\n * @param codepoint The Unicode codepoint.\n * @param emit      Function which will be called for each UTF-8 byte that represents the codepoint.\n */\nfunction codepointToUTF8(codepoint, emit) {\n    if (codepoint <= 0x7f) {\n        emit(codepoint);\n        return;\n    }\n    else if (codepoint <= 0x7ff) {\n        emit(0xc0 | (codepoint >> 6));\n        emit(0x80 | (codepoint & 0x3f));\n        return;\n    }\n    else if (codepoint <= 0xffff) {\n        emit(0xe0 | (codepoint >> 12));\n        emit(0x80 | ((codepoint >> 6) & 0x3f));\n        emit(0x80 | (codepoint & 0x3f));\n        return;\n    }\n    else if (codepoint <= 0x10ffff) {\n        emit(0xf0 | (codepoint >> 18));\n        emit(0x80 | ((codepoint >> 12) & 0x3f));\n        emit(0x80 | ((codepoint >> 6) & 0x3f));\n        emit(0x80 | (codepoint & 0x3f));\n        return;\n    }\n    throw new Error(`Unrecognized Unicode codepoint: ${codepoint.toString(16)}`);\n}\n/**\n * Converts a JavaScript string to a sequence of UTF-8 bytes.\n *\n * @param str  The string to convert to UTF-8.\n * @param emit Function which will be called for each UTF-8 byte of the string.\n */\nfunction stringToUTF8(str, emit) {\n    for (let i = 0; i < str.length; i += 1) {\n        let codepoint = str.charCodeAt(i);\n        if (codepoint > 0xd7ff && codepoint <= 0xdbff) {\n            // most UTF-16 codepoints are Unicode codepoints, except values in this\n            // range where the next UTF-16 codepoint needs to be combined with the\n            // current one to get the Unicode codepoint\n            const highSurrogate = ((codepoint - 0xd800) * 0x400) & 0xffff;\n            const lowSurrogate = (str.charCodeAt(i + 1) - 0xdc00) & 0xffff;\n            codepoint = (lowSurrogate | highSurrogate) + 0x10000;\n            i += 1;\n        }\n        codepointToUTF8(codepoint, emit);\n    }\n}\n/**\n * Converts a UTF-8 byte to a Unicode codepoint.\n *\n * @param byte  The UTF-8 byte next in the sequence.\n * @param state The shared state between consecutive UTF-8 bytes in the\n *              sequence, an object with the shape `{ utf8seq: 0, codepoint: 0 }`.\n * @param emit  Function which will be called for each codepoint.\n */\nfunction stringFromUTF8(byte, state, emit) {\n    if (state.utf8seq === 0) {\n        if (byte <= 0x7f) {\n            emit(byte);\n            return;\n        }\n        // count the number of 1 leading bits until you reach 0\n        for (let leadingBit = 1; leadingBit < 6; leadingBit += 1) {\n            if (((byte >> (7 - leadingBit)) & 1) === 0) {\n                state.utf8seq = leadingBit;\n                break;\n            }\n        }\n        if (state.utf8seq === 2) {\n            state.codepoint = byte & 31;\n        }\n        else if (state.utf8seq === 3) {\n            state.codepoint = byte & 15;\n        }\n        else if (state.utf8seq === 4) {\n            state.codepoint = byte & 7;\n        }\n        else {\n            throw new Error('Invalid UTF-8 sequence');\n        }\n        state.utf8seq -= 1;\n    }\n    else if (state.utf8seq > 0) {\n        if (byte <= 0x7f) {\n            throw new Error('Invalid UTF-8 sequence');\n        }\n        state.codepoint = (state.codepoint << 6) | (byte & 63);\n        state.utf8seq -= 1;\n        if (state.utf8seq === 0) {\n            emit(state.codepoint);\n        }\n    }\n}\n/**\n * Helper functions to convert different types of strings to Uint8Array\n */\nfunction base64UrlToUint8Array(str) {\n    const result = [];\n    const state = { queue: 0, queuedBits: 0 };\n    const onByte = (byte) => {\n        result.push(byte);\n    };\n    for (let i = 0; i < str.length; i += 1) {\n        byteFromBase64URL(str.charCodeAt(i), state, onByte);\n    }\n    return new Uint8Array(result);\n}\nfunction stringToUint8Array(str) {\n    const result = [];\n    stringToUTF8(str, (byte) => result.push(byte));\n    return new Uint8Array(result);\n}\nfunction bytesToBase64URL(bytes) {\n    const result = [];\n    const state = { queue: 0, queuedBits: 0 };\n    const onChar = (char) => {\n        result.push(char);\n    };\n    bytes.forEach((byte) => byteToBase64URL(byte, state, onChar));\n    // always call with `null` after processing all bytes\n    byteToBase64URL(null, state, onChar);\n    return result.join('');\n}\n//# sourceMappingURL=base64url.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvYXV0aC1qcy9kaXN0L21vZHVsZS9saWIvYmFzZTY0dXJsLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7QUFDQSxvQkFBb0IsNkJBQTZCO0FBQ2pEO0FBQ0E7QUFDQSxvQkFBb0IseUJBQXlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSx5QkFBeUI7QUFDbEc7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCx5QkFBeUI7QUFDdkY7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELDhCQUE4QjtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELHVCQUF1QjtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1Asb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsMEJBQTBCO0FBQ2hGO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxnQkFBZ0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJEOlxcbmV4dFxcb3JnXFxub2RlX21vZHVsZXNcXEBzdXBhYmFzZVxcYXV0aC1qc1xcZGlzdFxcbW9kdWxlXFxsaWJcXGJhc2U2NHVybC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEF2b2lkIG1vZGlmeWluZyB0aGlzIGZpbGUuIEl0J3MgcGFydCBvZlxuICogaHR0cHM6Ly9naXRodWIuY29tL3N1cGFiYXNlLWNvbW11bml0eS9iYXNlNjR1cmwtanMuICBTdWJtaXQgYWxsIGZpeGVzIG9uXG4gKiB0aGF0IHJlcG8hXG4gKi9cbi8qKlxuICogQW4gYXJyYXkgb2YgY2hhcmFjdGVycyB0aGF0IGVuY29kZSA2IGJpdHMgaW50byBhIEJhc2U2NC1VUkwgYWxwaGFiZXRcbiAqIGNoYXJhY3Rlci5cbiAqL1xuY29uc3QgVE9fQkFTRTY0VVJMID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5LV8nLnNwbGl0KCcnKTtcbi8qKlxuICogQW4gYXJyYXkgb2YgY2hhcmFjdGVycyB0aGF0IGNhbiBhcHBlYXIgaW4gYSBCYXNlNjQtVVJMIGVuY29kZWQgc3RyaW5nIGJ1dFxuICogc2hvdWxkIGJlIGlnbm9yZWQuXG4gKi9cbmNvbnN0IElHTk9SRV9CQVNFNjRVUkwgPSAnIFxcdFxcblxccj0nLnNwbGl0KCcnKTtcbi8qKlxuICogQW4gYXJyYXkgb2YgMTI4IG51bWJlcnMgdGhhdCBtYXAgYSBCYXNlNjQtVVJMIGNoYXJhY3RlciB0byA2IGJpdHMsIG9yIGlmIC0yXG4gKiB1c2VkIHRvIHNraXAgdGhlIGNoYXJhY3Rlciwgb3IgaWYgLTEgdXNlZCB0byBlcnJvciBvdXQuXG4gKi9cbmNvbnN0IEZST01fQkFTRTY0VVJMID0gKCgpID0+IHtcbiAgICBjb25zdCBjaGFyTWFwID0gbmV3IEFycmF5KDEyOCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGFyTWFwLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGNoYXJNYXBbaV0gPSAtMTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBJR05PUkVfQkFTRTY0VVJMLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGNoYXJNYXBbSUdOT1JFX0JBU0U2NFVSTFtpXS5jaGFyQ29kZUF0KDApXSA9IC0yO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IFRPX0JBU0U2NFVSTC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBjaGFyTWFwW1RPX0JBU0U2NFVSTFtpXS5jaGFyQ29kZUF0KDApXSA9IGk7XG4gICAgfVxuICAgIHJldHVybiBjaGFyTWFwO1xufSkoKTtcbi8qKlxuICogQ29udmVydHMgYSBieXRlIHRvIGEgQmFzZTY0LVVSTCBzdHJpbmcuXG4gKlxuICogQHBhcmFtIGJ5dGUgVGhlIGJ5dGUgdG8gY29udmVydCwgb3IgbnVsbCB0byBmbHVzaCBhdCB0aGUgZW5kIG9mIHRoZSBieXRlIHNlcXVlbmNlLlxuICogQHBhcmFtIHN0YXRlIFRoZSBCYXNlNjQgY29udmVyc2lvbiBzdGF0ZS4gUGFzcyBhbiBpbml0aWFsIHZhbHVlIG9mIGB7IHF1ZXVlOiAwLCBxdWV1ZWRCaXRzOiAwIH1gLlxuICogQHBhcmFtIGVtaXQgQSBmdW5jdGlvbiBjYWxsZWQgd2l0aCB0aGUgbmV4dCBCYXNlNjQgY2hhcmFjdGVyIHdoZW4gcmVhZHkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBieXRlVG9CYXNlNjRVUkwoYnl0ZSwgc3RhdGUsIGVtaXQpIHtcbiAgICBpZiAoYnl0ZSAhPT0gbnVsbCkge1xuICAgICAgICBzdGF0ZS5xdWV1ZSA9IChzdGF0ZS5xdWV1ZSA8PCA4KSB8IGJ5dGU7XG4gICAgICAgIHN0YXRlLnF1ZXVlZEJpdHMgKz0gODtcbiAgICAgICAgd2hpbGUgKHN0YXRlLnF1ZXVlZEJpdHMgPj0gNikge1xuICAgICAgICAgICAgY29uc3QgcG9zID0gKHN0YXRlLnF1ZXVlID4+IChzdGF0ZS5xdWV1ZWRCaXRzIC0gNikpICYgNjM7XG4gICAgICAgICAgICBlbWl0KFRPX0JBU0U2NFVSTFtwb3NdKTtcbiAgICAgICAgICAgIHN0YXRlLnF1ZXVlZEJpdHMgLT0gNjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChzdGF0ZS5xdWV1ZWRCaXRzID4gMCkge1xuICAgICAgICBzdGF0ZS5xdWV1ZSA9IHN0YXRlLnF1ZXVlIDw8ICg2IC0gc3RhdGUucXVldWVkQml0cyk7XG4gICAgICAgIHN0YXRlLnF1ZXVlZEJpdHMgPSA2O1xuICAgICAgICB3aGlsZSAoc3RhdGUucXVldWVkQml0cyA+PSA2KSB7XG4gICAgICAgICAgICBjb25zdCBwb3MgPSAoc3RhdGUucXVldWUgPj4gKHN0YXRlLnF1ZXVlZEJpdHMgLSA2KSkgJiA2MztcbiAgICAgICAgICAgIGVtaXQoVE9fQkFTRTY0VVJMW3Bvc10pO1xuICAgICAgICAgICAgc3RhdGUucXVldWVkQml0cyAtPSA2O1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBDb252ZXJ0cyBhIFN0cmluZyBjaGFyIGNvZGUgKGV4dHJhY3RlZCB1c2luZyBgc3RyaW5nLmNoYXJDb2RlQXQocG9zaXRpb24pYCkgdG8gYSBzZXF1ZW5jZSBvZiBCYXNlNjQtVVJMIGNoYXJhY3RlcnMuXG4gKlxuICogQHBhcmFtIGNoYXJDb2RlIFRoZSBjaGFyIGNvZGUgb2YgdGhlIEphdmFTY3JpcHQgc3RyaW5nLlxuICogQHBhcmFtIHN0YXRlIFRoZSBCYXNlNjQgc3RhdGUuIFBhc3MgYW4gaW5pdGlhbCB2YWx1ZSBvZiBgeyBxdWV1ZTogMCwgcXVldWVkQml0czogMCB9YC5cbiAqIEBwYXJhbSBlbWl0IEEgZnVuY3Rpb24gY2FsbGVkIHdpdGggdGhlIG5leHQgYnl0ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ5dGVGcm9tQmFzZTY0VVJMKGNoYXJDb2RlLCBzdGF0ZSwgZW1pdCkge1xuICAgIGNvbnN0IGJpdHMgPSBGUk9NX0JBU0U2NFVSTFtjaGFyQ29kZV07XG4gICAgaWYgKGJpdHMgPiAtMSkge1xuICAgICAgICAvLyB2YWxpZCBCYXNlNjQtVVJMIGNoYXJhY3RlclxuICAgICAgICBzdGF0ZS5xdWV1ZSA9IChzdGF0ZS5xdWV1ZSA8PCA2KSB8IGJpdHM7XG4gICAgICAgIHN0YXRlLnF1ZXVlZEJpdHMgKz0gNjtcbiAgICAgICAgd2hpbGUgKHN0YXRlLnF1ZXVlZEJpdHMgPj0gOCkge1xuICAgICAgICAgICAgZW1pdCgoc3RhdGUucXVldWUgPj4gKHN0YXRlLnF1ZXVlZEJpdHMgLSA4KSkgJiAweGZmKTtcbiAgICAgICAgICAgIHN0YXRlLnF1ZXVlZEJpdHMgLT0gODtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChiaXRzID09PSAtMikge1xuICAgICAgICAvLyBpZ25vcmUgc3BhY2VzLCB0YWJzLCBuZXdsaW5lcywgPVxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgQmFzZTY0LVVSTCBjaGFyYWN0ZXIgXCIke1N0cmluZy5mcm9tQ2hhckNvZGUoY2hhckNvZGUpfVwiYCk7XG4gICAgfVxufVxuLyoqXG4gKiBDb252ZXJ0cyBhIEphdmFTY3JpcHQgc3RyaW5nICh3aGljaCBtYXkgaW5jbHVkZSBhbnkgdmFsaWQgY2hhcmFjdGVyKSBpbnRvIGFcbiAqIEJhc2U2NC1VUkwgZW5jb2RlZCBzdHJpbmcuIFRoZSBzdHJpbmcgaXMgZmlyc3QgZW5jb2RlZCBpbiBVVEYtOCB3aGljaCBpc1xuICogdGhlbiBlbmNvZGVkIGFzIEJhc2U2NC1VUkwuXG4gKlxuICogQHBhcmFtIHN0ciBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdHJpbmdUb0Jhc2U2NFVSTChzdHIpIHtcbiAgICBjb25zdCBiYXNlNjQgPSBbXTtcbiAgICBjb25zdCBlbWl0dGVyID0gKGNoYXIpID0+IHtcbiAgICAgICAgYmFzZTY0LnB1c2goY2hhcik7XG4gICAgfTtcbiAgICBjb25zdCBzdGF0ZSA9IHsgcXVldWU6IDAsIHF1ZXVlZEJpdHM6IDAgfTtcbiAgICBzdHJpbmdUb1VURjgoc3RyLCAoYnl0ZSkgPT4ge1xuICAgICAgICBieXRlVG9CYXNlNjRVUkwoYnl0ZSwgc3RhdGUsIGVtaXR0ZXIpO1xuICAgIH0pO1xuICAgIGJ5dGVUb0Jhc2U2NFVSTChudWxsLCBzdGF0ZSwgZW1pdHRlcik7XG4gICAgcmV0dXJuIGJhc2U2NC5qb2luKCcnKTtcbn1cbi8qKlxuICogQ29udmVydHMgYSBCYXNlNjQtVVJMIGVuY29kZWQgc3RyaW5nIGludG8gYSBKYXZhU2NyaXB0IHN0cmluZy4gSXQgaXMgYXNzdW1lZFxuICogdGhhdCB0aGUgdW5kZXJseWluZyBzdHJpbmcgaGFzIGJlZW4gZW5jb2RlZCBhcyBVVEYtOC5cbiAqXG4gKiBAcGFyYW0gc3RyIFRoZSBCYXNlNjQtVVJMIGVuY29kZWQgc3RyaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RyaW5nRnJvbUJhc2U2NFVSTChzdHIpIHtcbiAgICBjb25zdCBjb252ID0gW107XG4gICAgY29uc3QgdXRmOEVtaXQgPSAoY29kZXBvaW50KSA9PiB7XG4gICAgICAgIGNvbnYucHVzaChTdHJpbmcuZnJvbUNvZGVQb2ludChjb2RlcG9pbnQpKTtcbiAgICB9O1xuICAgIGNvbnN0IHV0ZjhTdGF0ZSA9IHtcbiAgICAgICAgdXRmOHNlcTogMCxcbiAgICAgICAgY29kZXBvaW50OiAwLFxuICAgIH07XG4gICAgY29uc3QgYjY0U3RhdGUgPSB7IHF1ZXVlOiAwLCBxdWV1ZWRCaXRzOiAwIH07XG4gICAgY29uc3QgYnl0ZUVtaXQgPSAoYnl0ZSkgPT4ge1xuICAgICAgICBzdHJpbmdGcm9tVVRGOChieXRlLCB1dGY4U3RhdGUsIHV0ZjhFbWl0KTtcbiAgICB9O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGJ5dGVGcm9tQmFzZTY0VVJMKHN0ci5jaGFyQ29kZUF0KGkpLCBiNjRTdGF0ZSwgYnl0ZUVtaXQpO1xuICAgIH1cbiAgICByZXR1cm4gY29udi5qb2luKCcnKTtcbn1cbi8qKlxuICogQ29udmVydHMgYSBVbmljb2RlIGNvZGVwb2ludCB0byBhIG11bHRpLWJ5dGUgVVRGLTggc2VxdWVuY2UuXG4gKlxuICogQHBhcmFtIGNvZGVwb2ludCBUaGUgVW5pY29kZSBjb2RlcG9pbnQuXG4gKiBAcGFyYW0gZW1pdCAgICAgIEZ1bmN0aW9uIHdoaWNoIHdpbGwgYmUgY2FsbGVkIGZvciBlYWNoIFVURi04IGJ5dGUgdGhhdCByZXByZXNlbnRzIHRoZSBjb2RlcG9pbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb2RlcG9pbnRUb1VURjgoY29kZXBvaW50LCBlbWl0KSB7XG4gICAgaWYgKGNvZGVwb2ludCA8PSAweDdmKSB7XG4gICAgICAgIGVtaXQoY29kZXBvaW50KTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlbHNlIGlmIChjb2RlcG9pbnQgPD0gMHg3ZmYpIHtcbiAgICAgICAgZW1pdCgweGMwIHwgKGNvZGVwb2ludCA+PiA2KSk7XG4gICAgICAgIGVtaXQoMHg4MCB8IChjb2RlcG9pbnQgJiAweDNmKSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZWxzZSBpZiAoY29kZXBvaW50IDw9IDB4ZmZmZikge1xuICAgICAgICBlbWl0KDB4ZTAgfCAoY29kZXBvaW50ID4+IDEyKSk7XG4gICAgICAgIGVtaXQoMHg4MCB8ICgoY29kZXBvaW50ID4+IDYpICYgMHgzZikpO1xuICAgICAgICBlbWl0KDB4ODAgfCAoY29kZXBvaW50ICYgMHgzZikpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGVsc2UgaWYgKGNvZGVwb2ludCA8PSAweDEwZmZmZikge1xuICAgICAgICBlbWl0KDB4ZjAgfCAoY29kZXBvaW50ID4+IDE4KSk7XG4gICAgICAgIGVtaXQoMHg4MCB8ICgoY29kZXBvaW50ID4+IDEyKSAmIDB4M2YpKTtcbiAgICAgICAgZW1pdCgweDgwIHwgKChjb2RlcG9pbnQgPj4gNikgJiAweDNmKSk7XG4gICAgICAgIGVtaXQoMHg4MCB8IChjb2RlcG9pbnQgJiAweDNmKSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbnJlY29nbml6ZWQgVW5pY29kZSBjb2RlcG9pbnQ6ICR7Y29kZXBvaW50LnRvU3RyaW5nKDE2KX1gKTtcbn1cbi8qKlxuICogQ29udmVydHMgYSBKYXZhU2NyaXB0IHN0cmluZyB0byBhIHNlcXVlbmNlIG9mIFVURi04IGJ5dGVzLlxuICpcbiAqIEBwYXJhbSBzdHIgIFRoZSBzdHJpbmcgdG8gY29udmVydCB0byBVVEYtOC5cbiAqIEBwYXJhbSBlbWl0IEZ1bmN0aW9uIHdoaWNoIHdpbGwgYmUgY2FsbGVkIGZvciBlYWNoIFVURi04IGJ5dGUgb2YgdGhlIHN0cmluZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0cmluZ1RvVVRGOChzdHIsIGVtaXQpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBsZXQgY29kZXBvaW50ID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmIChjb2RlcG9pbnQgPiAweGQ3ZmYgJiYgY29kZXBvaW50IDw9IDB4ZGJmZikge1xuICAgICAgICAgICAgLy8gbW9zdCBVVEYtMTYgY29kZXBvaW50cyBhcmUgVW5pY29kZSBjb2RlcG9pbnRzLCBleGNlcHQgdmFsdWVzIGluIHRoaXNcbiAgICAgICAgICAgIC8vIHJhbmdlIHdoZXJlIHRoZSBuZXh0IFVURi0xNiBjb2RlcG9pbnQgbmVlZHMgdG8gYmUgY29tYmluZWQgd2l0aCB0aGVcbiAgICAgICAgICAgIC8vIGN1cnJlbnQgb25lIHRvIGdldCB0aGUgVW5pY29kZSBjb2RlcG9pbnRcbiAgICAgICAgICAgIGNvbnN0IGhpZ2hTdXJyb2dhdGUgPSAoKGNvZGVwb2ludCAtIDB4ZDgwMCkgKiAweDQwMCkgJiAweGZmZmY7XG4gICAgICAgICAgICBjb25zdCBsb3dTdXJyb2dhdGUgPSAoc3RyLmNoYXJDb2RlQXQoaSArIDEpIC0gMHhkYzAwKSAmIDB4ZmZmZjtcbiAgICAgICAgICAgIGNvZGVwb2ludCA9IChsb3dTdXJyb2dhdGUgfCBoaWdoU3Vycm9nYXRlKSArIDB4MTAwMDA7XG4gICAgICAgICAgICBpICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgY29kZXBvaW50VG9VVEY4KGNvZGVwb2ludCwgZW1pdCk7XG4gICAgfVxufVxuLyoqXG4gKiBDb252ZXJ0cyBhIFVURi04IGJ5dGUgdG8gYSBVbmljb2RlIGNvZGVwb2ludC5cbiAqXG4gKiBAcGFyYW0gYnl0ZSAgVGhlIFVURi04IGJ5dGUgbmV4dCBpbiB0aGUgc2VxdWVuY2UuXG4gKiBAcGFyYW0gc3RhdGUgVGhlIHNoYXJlZCBzdGF0ZSBiZXR3ZWVuIGNvbnNlY3V0aXZlIFVURi04IGJ5dGVzIGluIHRoZVxuICogICAgICAgICAgICAgIHNlcXVlbmNlLCBhbiBvYmplY3Qgd2l0aCB0aGUgc2hhcGUgYHsgdXRmOHNlcTogMCwgY29kZXBvaW50OiAwIH1gLlxuICogQHBhcmFtIGVtaXQgIEZ1bmN0aW9uIHdoaWNoIHdpbGwgYmUgY2FsbGVkIGZvciBlYWNoIGNvZGVwb2ludC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0cmluZ0Zyb21VVEY4KGJ5dGUsIHN0YXRlLCBlbWl0KSB7XG4gICAgaWYgKHN0YXRlLnV0ZjhzZXEgPT09IDApIHtcbiAgICAgICAgaWYgKGJ5dGUgPD0gMHg3Zikge1xuICAgICAgICAgICAgZW1pdChieXRlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBjb3VudCB0aGUgbnVtYmVyIG9mIDEgbGVhZGluZyBiaXRzIHVudGlsIHlvdSByZWFjaCAwXG4gICAgICAgIGZvciAobGV0IGxlYWRpbmdCaXQgPSAxOyBsZWFkaW5nQml0IDwgNjsgbGVhZGluZ0JpdCArPSAxKSB7XG4gICAgICAgICAgICBpZiAoKChieXRlID4+ICg3IC0gbGVhZGluZ0JpdCkpICYgMSkgPT09IDApIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS51dGY4c2VxID0gbGVhZGluZ0JpdDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUudXRmOHNlcSA9PT0gMikge1xuICAgICAgICAgICAgc3RhdGUuY29kZXBvaW50ID0gYnl0ZSAmIDMxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0YXRlLnV0ZjhzZXEgPT09IDMpIHtcbiAgICAgICAgICAgIHN0YXRlLmNvZGVwb2ludCA9IGJ5dGUgJiAxNTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdGF0ZS51dGY4c2VxID09PSA0KSB7XG4gICAgICAgICAgICBzdGF0ZS5jb2RlcG9pbnQgPSBieXRlICYgNztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBVVEYtOCBzZXF1ZW5jZScpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLnV0ZjhzZXEgLT0gMTtcbiAgICB9XG4gICAgZWxzZSBpZiAoc3RhdGUudXRmOHNlcSA+IDApIHtcbiAgICAgICAgaWYgKGJ5dGUgPD0gMHg3Zikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIFVURi04IHNlcXVlbmNlJyk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUuY29kZXBvaW50ID0gKHN0YXRlLmNvZGVwb2ludCA8PCA2KSB8IChieXRlICYgNjMpO1xuICAgICAgICBzdGF0ZS51dGY4c2VxIC09IDE7XG4gICAgICAgIGlmIChzdGF0ZS51dGY4c2VxID09PSAwKSB7XG4gICAgICAgICAgICBlbWl0KHN0YXRlLmNvZGVwb2ludCk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbnMgdG8gY29udmVydCBkaWZmZXJlbnQgdHlwZXMgb2Ygc3RyaW5ncyB0byBVaW50OEFycmF5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiYXNlNjRVcmxUb1VpbnQ4QXJyYXkoc3RyKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgY29uc3Qgc3RhdGUgPSB7IHF1ZXVlOiAwLCBxdWV1ZWRCaXRzOiAwIH07XG4gICAgY29uc3Qgb25CeXRlID0gKGJ5dGUpID0+IHtcbiAgICAgICAgcmVzdWx0LnB1c2goYnl0ZSk7XG4gICAgfTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBieXRlRnJvbUJhc2U2NFVSTChzdHIuY2hhckNvZGVBdChpKSwgc3RhdGUsIG9uQnl0ZSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVWludDhBcnJheShyZXN1bHQpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHN0cmluZ1RvVWludDhBcnJheShzdHIpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBzdHJpbmdUb1VURjgoc3RyLCAoYnl0ZSkgPT4gcmVzdWx0LnB1c2goYnl0ZSkpO1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShyZXN1bHQpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGJ5dGVzVG9CYXNlNjRVUkwoYnl0ZXMpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBjb25zdCBzdGF0ZSA9IHsgcXVldWU6IDAsIHF1ZXVlZEJpdHM6IDAgfTtcbiAgICBjb25zdCBvbkNoYXIgPSAoY2hhcikgPT4ge1xuICAgICAgICByZXN1bHQucHVzaChjaGFyKTtcbiAgICB9O1xuICAgIGJ5dGVzLmZvckVhY2goKGJ5dGUpID0+IGJ5dGVUb0Jhc2U2NFVSTChieXRlLCBzdGF0ZSwgb25DaGFyKSk7XG4gICAgLy8gYWx3YXlzIGNhbGwgd2l0aCBgbnVsbGAgYWZ0ZXIgcHJvY2Vzc2luZyBhbGwgYnl0ZXNcbiAgICBieXRlVG9CYXNlNjRVUkwobnVsbCwgc3RhdGUsIG9uQ2hhcik7XG4gICAgcmV0dXJuIHJlc3VsdC5qb2luKCcnKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJhc2U2NHVybC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/base64url.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/constants.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/module/lib/constants.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   API_VERSIONS: () => (/* binding */ API_VERSIONS),\n/* harmony export */   API_VERSION_HEADER_NAME: () => (/* binding */ API_VERSION_HEADER_NAME),\n/* harmony export */   AUDIENCE: () => (/* binding */ AUDIENCE),\n/* harmony export */   AUTO_REFRESH_TICK_DURATION_MS: () => (/* binding */ AUTO_REFRESH_TICK_DURATION_MS),\n/* harmony export */   AUTO_REFRESH_TICK_THRESHOLD: () => (/* binding */ AUTO_REFRESH_TICK_THRESHOLD),\n/* harmony export */   BASE64URL_REGEX: () => (/* binding */ BASE64URL_REGEX),\n/* harmony export */   DEFAULT_HEADERS: () => (/* binding */ DEFAULT_HEADERS),\n/* harmony export */   EXPIRY_MARGIN_MS: () => (/* binding */ EXPIRY_MARGIN_MS),\n/* harmony export */   GOTRUE_URL: () => (/* binding */ GOTRUE_URL),\n/* harmony export */   JWKS_TTL: () => (/* binding */ JWKS_TTL),\n/* harmony export */   NETWORK_FAILURE: () => (/* binding */ NETWORK_FAILURE),\n/* harmony export */   STORAGE_KEY: () => (/* binding */ STORAGE_KEY)\n/* harmony export */ });\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./version */ \"(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/version.js\");\n\n/** Current session will be checked for refresh at this interval. */\nconst AUTO_REFRESH_TICK_DURATION_MS = 30 * 1000;\n/**\n * A token refresh will be attempted this many ticks before the current session expires. */\nconst AUTO_REFRESH_TICK_THRESHOLD = 3;\n/*\n * Earliest time before an access token expires that the session should be refreshed.\n */\nconst EXPIRY_MARGIN_MS = AUTO_REFRESH_TICK_THRESHOLD * AUTO_REFRESH_TICK_DURATION_MS;\nconst GOTRUE_URL = 'http://localhost:9999';\nconst STORAGE_KEY = 'supabase.auth.token';\nconst AUDIENCE = '';\nconst DEFAULT_HEADERS = { 'X-Client-Info': `gotrue-js/${_version__WEBPACK_IMPORTED_MODULE_0__.version}` };\nconst NETWORK_FAILURE = {\n    MAX_RETRIES: 10,\n    RETRY_INTERVAL: 2, // in deciseconds\n};\nconst API_VERSION_HEADER_NAME = 'X-Supabase-Api-Version';\nconst API_VERSIONS = {\n    '2024-01-01': {\n        timestamp: Date.parse('2024-01-01T00:00:00.0Z'),\n        name: '2024-01-01',\n    },\n};\nconst BASE64URL_REGEX = /^([a-z0-9_-]{4})*($|[a-z0-9_-]{3}$|[a-z0-9_-]{2}$)$/i;\nconst JWKS_TTL = 10 * 60 * 1000; // 10 minutes\n//# sourceMappingURL=constants.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvYXV0aC1qcy9kaXN0L21vZHVsZS9saWIvY29uc3RhbnRzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBb0M7QUFDcEM7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNPO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDhCQUE4Qiw2Q0FBTyxDQUFDO0FBQ2hFO0FBQ1A7QUFDQTtBQUNBO0FBQ087QUFDQTtBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNPLHNDQUFzQyxFQUFFLGdCQUFnQixFQUFFLGFBQWEsRUFBRTtBQUN6RSxpQ0FBaUM7QUFDeEMiLCJzb3VyY2VzIjpbIkQ6XFxuZXh0XFxvcmdcXG5vZGVfbW9kdWxlc1xcQHN1cGFiYXNlXFxhdXRoLWpzXFxkaXN0XFxtb2R1bGVcXGxpYlxcY29uc3RhbnRzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHZlcnNpb24gfSBmcm9tICcuL3ZlcnNpb24nO1xuLyoqIEN1cnJlbnQgc2Vzc2lvbiB3aWxsIGJlIGNoZWNrZWQgZm9yIHJlZnJlc2ggYXQgdGhpcyBpbnRlcnZhbC4gKi9cbmV4cG9ydCBjb25zdCBBVVRPX1JFRlJFU0hfVElDS19EVVJBVElPTl9NUyA9IDMwICogMTAwMDtcbi8qKlxuICogQSB0b2tlbiByZWZyZXNoIHdpbGwgYmUgYXR0ZW1wdGVkIHRoaXMgbWFueSB0aWNrcyBiZWZvcmUgdGhlIGN1cnJlbnQgc2Vzc2lvbiBleHBpcmVzLiAqL1xuZXhwb3J0IGNvbnN0IEFVVE9fUkVGUkVTSF9USUNLX1RIUkVTSE9MRCA9IDM7XG4vKlxuICogRWFybGllc3QgdGltZSBiZWZvcmUgYW4gYWNjZXNzIHRva2VuIGV4cGlyZXMgdGhhdCB0aGUgc2Vzc2lvbiBzaG91bGQgYmUgcmVmcmVzaGVkLlxuICovXG5leHBvcnQgY29uc3QgRVhQSVJZX01BUkdJTl9NUyA9IEFVVE9fUkVGUkVTSF9USUNLX1RIUkVTSE9MRCAqIEFVVE9fUkVGUkVTSF9USUNLX0RVUkFUSU9OX01TO1xuZXhwb3J0IGNvbnN0IEdPVFJVRV9VUkwgPSAnaHR0cDovL2xvY2FsaG9zdDo5OTk5JztcbmV4cG9ydCBjb25zdCBTVE9SQUdFX0tFWSA9ICdzdXBhYmFzZS5hdXRoLnRva2VuJztcbmV4cG9ydCBjb25zdCBBVURJRU5DRSA9ICcnO1xuZXhwb3J0IGNvbnN0IERFRkFVTFRfSEVBREVSUyA9IHsgJ1gtQ2xpZW50LUluZm8nOiBgZ290cnVlLWpzLyR7dmVyc2lvbn1gIH07XG5leHBvcnQgY29uc3QgTkVUV09SS19GQUlMVVJFID0ge1xuICAgIE1BWF9SRVRSSUVTOiAxMCxcbiAgICBSRVRSWV9JTlRFUlZBTDogMiwgLy8gaW4gZGVjaXNlY29uZHNcbn07XG5leHBvcnQgY29uc3QgQVBJX1ZFUlNJT05fSEVBREVSX05BTUUgPSAnWC1TdXBhYmFzZS1BcGktVmVyc2lvbic7XG5leHBvcnQgY29uc3QgQVBJX1ZFUlNJT05TID0ge1xuICAgICcyMDI0LTAxLTAxJzoge1xuICAgICAgICB0aW1lc3RhbXA6IERhdGUucGFyc2UoJzIwMjQtMDEtMDFUMDA6MDA6MDAuMFonKSxcbiAgICAgICAgbmFtZTogJzIwMjQtMDEtMDEnLFxuICAgIH0sXG59O1xuZXhwb3J0IGNvbnN0IEJBU0U2NFVSTF9SRUdFWCA9IC9eKFthLXowLTlfLV17NH0pKigkfFthLXowLTlfLV17M30kfFthLXowLTlfLV17Mn0kKSQvaTtcbmV4cG9ydCBjb25zdCBKV0tTX1RUTCA9IDEwICogNjAgKiAxMDAwOyAvLyAxMCBtaW51dGVzXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25zdGFudHMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/constants.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/errors.js":
/*!******************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/module/lib/errors.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AuthApiError: () => (/* binding */ AuthApiError),\n/* harmony export */   AuthError: () => (/* binding */ AuthError),\n/* harmony export */   AuthImplicitGrantRedirectError: () => (/* binding */ AuthImplicitGrantRedirectError),\n/* harmony export */   AuthInvalidCredentialsError: () => (/* binding */ AuthInvalidCredentialsError),\n/* harmony export */   AuthInvalidJwtError: () => (/* binding */ AuthInvalidJwtError),\n/* harmony export */   AuthInvalidTokenResponseError: () => (/* binding */ AuthInvalidTokenResponseError),\n/* harmony export */   AuthPKCEGrantCodeExchangeError: () => (/* binding */ AuthPKCEGrantCodeExchangeError),\n/* harmony export */   AuthRetryableFetchError: () => (/* binding */ AuthRetryableFetchError),\n/* harmony export */   AuthSessionMissingError: () => (/* binding */ AuthSessionMissingError),\n/* harmony export */   AuthUnknownError: () => (/* binding */ AuthUnknownError),\n/* harmony export */   AuthWeakPasswordError: () => (/* binding */ AuthWeakPasswordError),\n/* harmony export */   CustomAuthError: () => (/* binding */ CustomAuthError),\n/* harmony export */   isAuthApiError: () => (/* binding */ isAuthApiError),\n/* harmony export */   isAuthError: () => (/* binding */ isAuthError),\n/* harmony export */   isAuthImplicitGrantRedirectError: () => (/* binding */ isAuthImplicitGrantRedirectError),\n/* harmony export */   isAuthRetryableFetchError: () => (/* binding */ isAuthRetryableFetchError),\n/* harmony export */   isAuthSessionMissingError: () => (/* binding */ isAuthSessionMissingError),\n/* harmony export */   isAuthWeakPasswordError: () => (/* binding */ isAuthWeakPasswordError)\n/* harmony export */ });\nclass AuthError extends Error {\n    constructor(message, status, code) {\n        super(message);\n        this.__isAuthError = true;\n        this.name = 'AuthError';\n        this.status = status;\n        this.code = code;\n    }\n}\nfunction isAuthError(error) {\n    return typeof error === 'object' && error !== null && '__isAuthError' in error;\n}\nclass AuthApiError extends AuthError {\n    constructor(message, status, code) {\n        super(message, status, code);\n        this.name = 'AuthApiError';\n        this.status = status;\n        this.code = code;\n    }\n}\nfunction isAuthApiError(error) {\n    return isAuthError(error) && error.name === 'AuthApiError';\n}\nclass AuthUnknownError extends AuthError {\n    constructor(message, originalError) {\n        super(message);\n        this.name = 'AuthUnknownError';\n        this.originalError = originalError;\n    }\n}\nclass CustomAuthError extends AuthError {\n    constructor(message, name, status, code) {\n        super(message, status, code);\n        this.name = name;\n        this.status = status;\n    }\n}\nclass AuthSessionMissingError extends CustomAuthError {\n    constructor() {\n        super('Auth session missing!', 'AuthSessionMissingError', 400, undefined);\n    }\n}\nfunction isAuthSessionMissingError(error) {\n    return isAuthError(error) && error.name === 'AuthSessionMissingError';\n}\nclass AuthInvalidTokenResponseError extends CustomAuthError {\n    constructor() {\n        super('Auth session or user missing', 'AuthInvalidTokenResponseError', 500, undefined);\n    }\n}\nclass AuthInvalidCredentialsError extends CustomAuthError {\n    constructor(message) {\n        super(message, 'AuthInvalidCredentialsError', 400, undefined);\n    }\n}\nclass AuthImplicitGrantRedirectError extends CustomAuthError {\n    constructor(message, details = null) {\n        super(message, 'AuthImplicitGrantRedirectError', 500, undefined);\n        this.details = null;\n        this.details = details;\n    }\n    toJSON() {\n        return {\n            name: this.name,\n            message: this.message,\n            status: this.status,\n            details: this.details,\n        };\n    }\n}\nfunction isAuthImplicitGrantRedirectError(error) {\n    return isAuthError(error) && error.name === 'AuthImplicitGrantRedirectError';\n}\nclass AuthPKCEGrantCodeExchangeError extends CustomAuthError {\n    constructor(message, details = null) {\n        super(message, 'AuthPKCEGrantCodeExchangeError', 500, undefined);\n        this.details = null;\n        this.details = details;\n    }\n    toJSON() {\n        return {\n            name: this.name,\n            message: this.message,\n            status: this.status,\n            details: this.details,\n        };\n    }\n}\nclass AuthRetryableFetchError extends CustomAuthError {\n    constructor(message, status) {\n        super(message, 'AuthRetryableFetchError', status, undefined);\n    }\n}\nfunction isAuthRetryableFetchError(error) {\n    return isAuthError(error) && error.name === 'AuthRetryableFetchError';\n}\n/**\n * This error is thrown on certain methods when the password used is deemed\n * weak. Inspect the reasons to identify what password strength rules are\n * inadequate.\n */\nclass AuthWeakPasswordError extends CustomAuthError {\n    constructor(message, status, reasons) {\n        super(message, 'AuthWeakPasswordError', status, 'weak_password');\n        this.reasons = reasons;\n    }\n}\nfunction isAuthWeakPasswordError(error) {\n    return isAuthError(error) && error.name === 'AuthWeakPasswordError';\n}\nclass AuthInvalidJwtError extends CustomAuthError {\n    constructor(message) {\n        super(message, 'AuthInvalidJwtError', 400, 'invalid_jwt');\n    }\n}\n//# sourceMappingURL=errors.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvYXV0aC1qcy9kaXN0L21vZHVsZS9saWIvZXJyb3JzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFxuZXh0XFxvcmdcXG5vZGVfbW9kdWxlc1xcQHN1cGFiYXNlXFxhdXRoLWpzXFxkaXN0XFxtb2R1bGVcXGxpYlxcZXJyb3JzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjbGFzcyBBdXRoRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgc3RhdHVzLCBjb2RlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLl9faXNBdXRoRXJyb3IgPSB0cnVlO1xuICAgICAgICB0aGlzLm5hbWUgPSAnQXV0aEVycm9yJztcbiAgICAgICAgdGhpcy5zdGF0dXMgPSBzdGF0dXM7XG4gICAgICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGlzQXV0aEVycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBlcnJvciA9PT0gJ29iamVjdCcgJiYgZXJyb3IgIT09IG51bGwgJiYgJ19faXNBdXRoRXJyb3InIGluIGVycm9yO1xufVxuZXhwb3J0IGNsYXNzIEF1dGhBcGlFcnJvciBleHRlbmRzIEF1dGhFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgc3RhdHVzLCBjb2RlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UsIHN0YXR1cywgY29kZSk7XG4gICAgICAgIHRoaXMubmFtZSA9ICdBdXRoQXBpRXJyb3InO1xuICAgICAgICB0aGlzLnN0YXR1cyA9IHN0YXR1cztcbiAgICAgICAgdGhpcy5jb2RlID0gY29kZTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gaXNBdXRoQXBpRXJyb3IoZXJyb3IpIHtcbiAgICByZXR1cm4gaXNBdXRoRXJyb3IoZXJyb3IpICYmIGVycm9yLm5hbWUgPT09ICdBdXRoQXBpRXJyb3InO1xufVxuZXhwb3J0IGNsYXNzIEF1dGhVbmtub3duRXJyb3IgZXh0ZW5kcyBBdXRoRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIG9yaWdpbmFsRXJyb3IpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIHRoaXMubmFtZSA9ICdBdXRoVW5rbm93bkVycm9yJztcbiAgICAgICAgdGhpcy5vcmlnaW5hbEVycm9yID0gb3JpZ2luYWxFcnJvcjtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgQ3VzdG9tQXV0aEVycm9yIGV4dGVuZHMgQXV0aEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBuYW1lLCBzdGF0dXMsIGNvZGUpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSwgc3RhdHVzLCBjb2RlKTtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5zdGF0dXMgPSBzdGF0dXM7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEF1dGhTZXNzaW9uTWlzc2luZ0Vycm9yIGV4dGVuZHMgQ3VzdG9tQXV0aEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJ0F1dGggc2Vzc2lvbiBtaXNzaW5nIScsICdBdXRoU2Vzc2lvbk1pc3NpbmdFcnJvcicsIDQwMCwgdW5kZWZpbmVkKTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gaXNBdXRoU2Vzc2lvbk1pc3NpbmdFcnJvcihlcnJvcikge1xuICAgIHJldHVybiBpc0F1dGhFcnJvcihlcnJvcikgJiYgZXJyb3IubmFtZSA9PT0gJ0F1dGhTZXNzaW9uTWlzc2luZ0Vycm9yJztcbn1cbmV4cG9ydCBjbGFzcyBBdXRoSW52YWxpZFRva2VuUmVzcG9uc2VFcnJvciBleHRlbmRzIEN1c3RvbUF1dGhFcnJvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdBdXRoIHNlc3Npb24gb3IgdXNlciBtaXNzaW5nJywgJ0F1dGhJbnZhbGlkVG9rZW5SZXNwb25zZUVycm9yJywgNTAwLCB1bmRlZmluZWQpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBBdXRoSW52YWxpZENyZWRlbnRpYWxzRXJyb3IgZXh0ZW5kcyBDdXN0b21BdXRoRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSwgJ0F1dGhJbnZhbGlkQ3JlZGVudGlhbHNFcnJvcicsIDQwMCwgdW5kZWZpbmVkKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgQXV0aEltcGxpY2l0R3JhbnRSZWRpcmVjdEVycm9yIGV4dGVuZHMgQ3VzdG9tQXV0aEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBkZXRhaWxzID0gbnVsbCkge1xuICAgICAgICBzdXBlcihtZXNzYWdlLCAnQXV0aEltcGxpY2l0R3JhbnRSZWRpcmVjdEVycm9yJywgNTAwLCB1bmRlZmluZWQpO1xuICAgICAgICB0aGlzLmRldGFpbHMgPSBudWxsO1xuICAgICAgICB0aGlzLmRldGFpbHMgPSBkZXRhaWxzO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXG4gICAgICAgICAgICBzdGF0dXM6IHRoaXMuc3RhdHVzLFxuICAgICAgICAgICAgZGV0YWlsczogdGhpcy5kZXRhaWxzLFxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0F1dGhJbXBsaWNpdEdyYW50UmVkaXJlY3RFcnJvcihlcnJvcikge1xuICAgIHJldHVybiBpc0F1dGhFcnJvcihlcnJvcikgJiYgZXJyb3IubmFtZSA9PT0gJ0F1dGhJbXBsaWNpdEdyYW50UmVkaXJlY3RFcnJvcic7XG59XG5leHBvcnQgY2xhc3MgQXV0aFBLQ0VHcmFudENvZGVFeGNoYW5nZUVycm9yIGV4dGVuZHMgQ3VzdG9tQXV0aEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBkZXRhaWxzID0gbnVsbCkge1xuICAgICAgICBzdXBlcihtZXNzYWdlLCAnQXV0aFBLQ0VHcmFudENvZGVFeGNoYW5nZUVycm9yJywgNTAwLCB1bmRlZmluZWQpO1xuICAgICAgICB0aGlzLmRldGFpbHMgPSBudWxsO1xuICAgICAgICB0aGlzLmRldGFpbHMgPSBkZXRhaWxzO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXG4gICAgICAgICAgICBzdGF0dXM6IHRoaXMuc3RhdHVzLFxuICAgICAgICAgICAgZGV0YWlsczogdGhpcy5kZXRhaWxzLFxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBBdXRoUmV0cnlhYmxlRmV0Y2hFcnJvciBleHRlbmRzIEN1c3RvbUF1dGhFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgc3RhdHVzKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UsICdBdXRoUmV0cnlhYmxlRmV0Y2hFcnJvcicsIHN0YXR1cywgdW5kZWZpbmVkKTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gaXNBdXRoUmV0cnlhYmxlRmV0Y2hFcnJvcihlcnJvcikge1xuICAgIHJldHVybiBpc0F1dGhFcnJvcihlcnJvcikgJiYgZXJyb3IubmFtZSA9PT0gJ0F1dGhSZXRyeWFibGVGZXRjaEVycm9yJztcbn1cbi8qKlxuICogVGhpcyBlcnJvciBpcyB0aHJvd24gb24gY2VydGFpbiBtZXRob2RzIHdoZW4gdGhlIHBhc3N3b3JkIHVzZWQgaXMgZGVlbWVkXG4gKiB3ZWFrLiBJbnNwZWN0IHRoZSByZWFzb25zIHRvIGlkZW50aWZ5IHdoYXQgcGFzc3dvcmQgc3RyZW5ndGggcnVsZXMgYXJlXG4gKiBpbmFkZXF1YXRlLlxuICovXG5leHBvcnQgY2xhc3MgQXV0aFdlYWtQYXNzd29yZEVycm9yIGV4dGVuZHMgQ3VzdG9tQXV0aEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBzdGF0dXMsIHJlYXNvbnMpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSwgJ0F1dGhXZWFrUGFzc3dvcmRFcnJvcicsIHN0YXR1cywgJ3dlYWtfcGFzc3dvcmQnKTtcbiAgICAgICAgdGhpcy5yZWFzb25zID0gcmVhc29ucztcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gaXNBdXRoV2Vha1Bhc3N3b3JkRXJyb3IoZXJyb3IpIHtcbiAgICByZXR1cm4gaXNBdXRoRXJyb3IoZXJyb3IpICYmIGVycm9yLm5hbWUgPT09ICdBdXRoV2Vha1Bhc3N3b3JkRXJyb3InO1xufVxuZXhwb3J0IGNsYXNzIEF1dGhJbnZhbGlkSnd0RXJyb3IgZXh0ZW5kcyBDdXN0b21BdXRoRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSwgJ0F1dGhJbnZhbGlkSnd0RXJyb3InLCA0MDAsICdpbnZhbGlkX2p3dCcpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVycm9ycy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/errors.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/fetch.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/module/lib/fetch.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _generateLinkResponse: () => (/* binding */ _generateLinkResponse),\n/* harmony export */   _noResolveJsonResponse: () => (/* binding */ _noResolveJsonResponse),\n/* harmony export */   _request: () => (/* binding */ _request),\n/* harmony export */   _sessionResponse: () => (/* binding */ _sessionResponse),\n/* harmony export */   _sessionResponsePassword: () => (/* binding */ _sessionResponsePassword),\n/* harmony export */   _ssoResponse: () => (/* binding */ _ssoResponse),\n/* harmony export */   _userResponse: () => (/* binding */ _userResponse),\n/* harmony export */   handleError: () => (/* binding */ handleError)\n/* harmony export */ });\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants */ \"(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/constants.js\");\n/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helpers */ \"(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/helpers.js\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./errors */ \"(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/errors.js\");\nvar __rest = (undefined && undefined.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\n\n\n\nconst _getErrorMessage = (err) => err.msg || err.message || err.error_description || err.error || JSON.stringify(err);\nconst NETWORK_ERROR_CODES = [502, 503, 504];\nasync function handleError(error) {\n    var _a;\n    if (!(0,_helpers__WEBPACK_IMPORTED_MODULE_1__.looksLikeFetchResponse)(error)) {\n        throw new _errors__WEBPACK_IMPORTED_MODULE_2__.AuthRetryableFetchError(_getErrorMessage(error), 0);\n    }\n    if (NETWORK_ERROR_CODES.includes(error.status)) {\n        // status in 500...599 range - server had an error, request might be retryed.\n        throw new _errors__WEBPACK_IMPORTED_MODULE_2__.AuthRetryableFetchError(_getErrorMessage(error), error.status);\n    }\n    let data;\n    try {\n        data = await error.json();\n    }\n    catch (e) {\n        throw new _errors__WEBPACK_IMPORTED_MODULE_2__.AuthUnknownError(_getErrorMessage(e), e);\n    }\n    let errorCode = undefined;\n    const responseAPIVersion = (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.parseResponseAPIVersion)(error);\n    if (responseAPIVersion &&\n        responseAPIVersion.getTime() >= _constants__WEBPACK_IMPORTED_MODULE_0__.API_VERSIONS['2024-01-01'].timestamp &&\n        typeof data === 'object' &&\n        data &&\n        typeof data.code === 'string') {\n        errorCode = data.code;\n    }\n    else if (typeof data === 'object' && data && typeof data.error_code === 'string') {\n        errorCode = data.error_code;\n    }\n    if (!errorCode) {\n        // Legacy support for weak password errors, when there were no error codes\n        if (typeof data === 'object' &&\n            data &&\n            typeof data.weak_password === 'object' &&\n            data.weak_password &&\n            Array.isArray(data.weak_password.reasons) &&\n            data.weak_password.reasons.length &&\n            data.weak_password.reasons.reduce((a, i) => a && typeof i === 'string', true)) {\n            throw new _errors__WEBPACK_IMPORTED_MODULE_2__.AuthWeakPasswordError(_getErrorMessage(data), error.status, data.weak_password.reasons);\n        }\n    }\n    else if (errorCode === 'weak_password') {\n        throw new _errors__WEBPACK_IMPORTED_MODULE_2__.AuthWeakPasswordError(_getErrorMessage(data), error.status, ((_a = data.weak_password) === null || _a === void 0 ? void 0 : _a.reasons) || []);\n    }\n    else if (errorCode === 'session_not_found') {\n        // The `session_id` inside the JWT does not correspond to a row in the\n        // `sessions` table. This usually means the user has signed out, has been\n        // deleted, or their session has somehow been terminated.\n        throw new _errors__WEBPACK_IMPORTED_MODULE_2__.AuthSessionMissingError();\n    }\n    throw new _errors__WEBPACK_IMPORTED_MODULE_2__.AuthApiError(_getErrorMessage(data), error.status || 500, errorCode);\n}\nconst _getRequestParams = (method, options, parameters, body) => {\n    const params = { method, headers: (options === null || options === void 0 ? void 0 : options.headers) || {} };\n    if (method === 'GET') {\n        return params;\n    }\n    params.headers = Object.assign({ 'Content-Type': 'application/json;charset=UTF-8' }, options === null || options === void 0 ? void 0 : options.headers);\n    params.body = JSON.stringify(body);\n    return Object.assign(Object.assign({}, params), parameters);\n};\nasync function _request(fetcher, method, url, options) {\n    var _a;\n    const headers = Object.assign({}, options === null || options === void 0 ? void 0 : options.headers);\n    if (!headers[_constants__WEBPACK_IMPORTED_MODULE_0__.API_VERSION_HEADER_NAME]) {\n        headers[_constants__WEBPACK_IMPORTED_MODULE_0__.API_VERSION_HEADER_NAME] = _constants__WEBPACK_IMPORTED_MODULE_0__.API_VERSIONS['2024-01-01'].name;\n    }\n    if (options === null || options === void 0 ? void 0 : options.jwt) {\n        headers['Authorization'] = `Bearer ${options.jwt}`;\n    }\n    const qs = (_a = options === null || options === void 0 ? void 0 : options.query) !== null && _a !== void 0 ? _a : {};\n    if (options === null || options === void 0 ? void 0 : options.redirectTo) {\n        qs['redirect_to'] = options.redirectTo;\n    }\n    const queryString = Object.keys(qs).length ? '?' + new URLSearchParams(qs).toString() : '';\n    const data = await _handleRequest(fetcher, method, url + queryString, {\n        headers,\n        noResolveJson: options === null || options === void 0 ? void 0 : options.noResolveJson,\n    }, {}, options === null || options === void 0 ? void 0 : options.body);\n    return (options === null || options === void 0 ? void 0 : options.xform) ? options === null || options === void 0 ? void 0 : options.xform(data) : { data: Object.assign({}, data), error: null };\n}\nasync function _handleRequest(fetcher, method, url, options, parameters, body) {\n    const requestParams = _getRequestParams(method, options, parameters, body);\n    let result;\n    try {\n        result = await fetcher(url, Object.assign({}, requestParams));\n    }\n    catch (e) {\n        console.error(e);\n        // fetch failed, likely due to a network or CORS error\n        throw new _errors__WEBPACK_IMPORTED_MODULE_2__.AuthRetryableFetchError(_getErrorMessage(e), 0);\n    }\n    if (!result.ok) {\n        await handleError(result);\n    }\n    if (options === null || options === void 0 ? void 0 : options.noResolveJson) {\n        return result;\n    }\n    try {\n        return await result.json();\n    }\n    catch (e) {\n        await handleError(e);\n    }\n}\nfunction _sessionResponse(data) {\n    var _a;\n    let session = null;\n    if (hasSession(data)) {\n        session = Object.assign({}, data);\n        if (!data.expires_at) {\n            session.expires_at = (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.expiresAt)(data.expires_in);\n        }\n    }\n    const user = (_a = data.user) !== null && _a !== void 0 ? _a : data;\n    return { data: { session, user }, error: null };\n}\nfunction _sessionResponsePassword(data) {\n    const response = _sessionResponse(data);\n    if (!response.error &&\n        data.weak_password &&\n        typeof data.weak_password === 'object' &&\n        Array.isArray(data.weak_password.reasons) &&\n        data.weak_password.reasons.length &&\n        data.weak_password.message &&\n        typeof data.weak_password.message === 'string' &&\n        data.weak_password.reasons.reduce((a, i) => a && typeof i === 'string', true)) {\n        response.data.weak_password = data.weak_password;\n    }\n    return response;\n}\nfunction _userResponse(data) {\n    var _a;\n    const user = (_a = data.user) !== null && _a !== void 0 ? _a : data;\n    return { data: { user }, error: null };\n}\nfunction _ssoResponse(data) {\n    return { data, error: null };\n}\nfunction _generateLinkResponse(data) {\n    const { action_link, email_otp, hashed_token, redirect_to, verification_type } = data, rest = __rest(data, [\"action_link\", \"email_otp\", \"hashed_token\", \"redirect_to\", \"verification_type\"]);\n    const properties = {\n        action_link,\n        email_otp,\n        hashed_token,\n        redirect_to,\n        verification_type,\n    };\n    const user = Object.assign({}, rest);\n    return {\n        data: {\n            properties,\n            user,\n        },\n        error: null,\n    };\n}\nfunction _noResolveJsonResponse(data) {\n    return data;\n}\n/**\n * hasSession checks if the response object contains a valid session\n * @param data A response object\n * @returns true if a session is in the response\n */\nfunction hasSession(data) {\n    return data.access_token && data.refresh_token && data.expires_in;\n}\n//# sourceMappingURL=fetch.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvYXV0aC1qcy9kaXN0L21vZHVsZS9saWIvZmV0Y2guanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBQSxjQUFjLFNBQUksSUFBSSxTQUFJO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELGNBQWM7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNvRTtBQUNtQjtBQUM2QztBQUNwSTtBQUNBO0FBQ087QUFDUDtBQUNBLFNBQVMsZ0VBQXNCO0FBQy9CLGtCQUFrQiw0REFBdUI7QUFDekM7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDREQUF1QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IscURBQWdCO0FBQ2xDO0FBQ0E7QUFDQSwrQkFBK0IsaUVBQXVCO0FBQ3REO0FBQ0Esd0NBQXdDLG9EQUFZO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsMERBQXFCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiwwREFBcUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiw0REFBdUI7QUFDekM7QUFDQSxjQUFjLGlEQUFZO0FBQzFCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLGtDQUFrQyxnQkFBZ0I7QUFDdkY7QUFDQSx5Q0FBeUM7QUFDekM7QUFDTztBQUNQO0FBQ0Esb0NBQW9DO0FBQ3BDLGlCQUFpQiwrREFBdUI7QUFDeEMsZ0JBQWdCLCtEQUF1QixJQUFJLG9EQUFZO0FBQ3ZEO0FBQ0E7QUFDQSw2Q0FBNkMsWUFBWTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLElBQUk7QUFDVCx5SkFBeUosc0JBQXNCO0FBQy9LO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsNERBQXVCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBLGlDQUFpQyxtREFBUztBQUMxQztBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVEsZUFBZTtBQUNwQztBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSxhQUFhLFFBQVEsTUFBTTtBQUMzQjtBQUNPO0FBQ1AsYUFBYTtBQUNiO0FBQ087QUFDUCxZQUFZLHVFQUF1RTtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFxuZXh0XFxvcmdcXG5vZGVfbW9kdWxlc1xcQHN1cGFiYXNlXFxhdXRoLWpzXFxkaXN0XFxtb2R1bGVcXGxpYlxcZmV0Y2guanMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fcmVzdCA9ICh0aGlzICYmIHRoaXMuX19yZXN0KSB8fCBmdW5jdGlvbiAocywgZSkge1xuICAgIHZhciB0ID0ge307XG4gICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXG4gICAgICAgIHRbcF0gPSBzW3BdO1xuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKVxuICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xuICAgICAgICB9XG4gICAgcmV0dXJuIHQ7XG59O1xuaW1wb3J0IHsgQVBJX1ZFUlNJT05TLCBBUElfVkVSU0lPTl9IRUFERVJfTkFNRSB9IGZyb20gJy4vY29uc3RhbnRzJztcbmltcG9ydCB7IGV4cGlyZXNBdCwgbG9va3NMaWtlRmV0Y2hSZXNwb25zZSwgcGFyc2VSZXNwb25zZUFQSVZlcnNpb24gfSBmcm9tICcuL2hlbHBlcnMnO1xuaW1wb3J0IHsgQXV0aEFwaUVycm9yLCBBdXRoUmV0cnlhYmxlRmV0Y2hFcnJvciwgQXV0aFdlYWtQYXNzd29yZEVycm9yLCBBdXRoVW5rbm93bkVycm9yLCBBdXRoU2Vzc2lvbk1pc3NpbmdFcnJvciwgfSBmcm9tICcuL2Vycm9ycyc7XG5jb25zdCBfZ2V0RXJyb3JNZXNzYWdlID0gKGVycikgPT4gZXJyLm1zZyB8fCBlcnIubWVzc2FnZSB8fCBlcnIuZXJyb3JfZGVzY3JpcHRpb24gfHwgZXJyLmVycm9yIHx8IEpTT04uc3RyaW5naWZ5KGVycik7XG5jb25zdCBORVRXT1JLX0VSUk9SX0NPREVTID0gWzUwMiwgNTAzLCA1MDRdO1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGhhbmRsZUVycm9yKGVycm9yKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmICghbG9va3NMaWtlRmV0Y2hSZXNwb25zZShlcnJvcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEF1dGhSZXRyeWFibGVGZXRjaEVycm9yKF9nZXRFcnJvck1lc3NhZ2UoZXJyb3IpLCAwKTtcbiAgICB9XG4gICAgaWYgKE5FVFdPUktfRVJST1JfQ09ERVMuaW5jbHVkZXMoZXJyb3Iuc3RhdHVzKSkge1xuICAgICAgICAvLyBzdGF0dXMgaW4gNTAwLi4uNTk5IHJhbmdlIC0gc2VydmVyIGhhZCBhbiBlcnJvciwgcmVxdWVzdCBtaWdodCBiZSByZXRyeWVkLlxuICAgICAgICB0aHJvdyBuZXcgQXV0aFJldHJ5YWJsZUZldGNoRXJyb3IoX2dldEVycm9yTWVzc2FnZShlcnJvciksIGVycm9yLnN0YXR1cyk7XG4gICAgfVxuICAgIGxldCBkYXRhO1xuICAgIHRyeSB7XG4gICAgICAgIGRhdGEgPSBhd2FpdCBlcnJvci5qc29uKCk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93IG5ldyBBdXRoVW5rbm93bkVycm9yKF9nZXRFcnJvck1lc3NhZ2UoZSksIGUpO1xuICAgIH1cbiAgICBsZXQgZXJyb3JDb2RlID0gdW5kZWZpbmVkO1xuICAgIGNvbnN0IHJlc3BvbnNlQVBJVmVyc2lvbiA9IHBhcnNlUmVzcG9uc2VBUElWZXJzaW9uKGVycm9yKTtcbiAgICBpZiAocmVzcG9uc2VBUElWZXJzaW9uICYmXG4gICAgICAgIHJlc3BvbnNlQVBJVmVyc2lvbi5nZXRUaW1lKCkgPj0gQVBJX1ZFUlNJT05TWycyMDI0LTAxLTAxJ10udGltZXN0YW1wICYmXG4gICAgICAgIHR5cGVvZiBkYXRhID09PSAnb2JqZWN0JyAmJlxuICAgICAgICBkYXRhICYmXG4gICAgICAgIHR5cGVvZiBkYXRhLmNvZGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGVycm9yQ29kZSA9IGRhdGEuY29kZTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGRhdGEgPT09ICdvYmplY3QnICYmIGRhdGEgJiYgdHlwZW9mIGRhdGEuZXJyb3JfY29kZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZXJyb3JDb2RlID0gZGF0YS5lcnJvcl9jb2RlO1xuICAgIH1cbiAgICBpZiAoIWVycm9yQ29kZSkge1xuICAgICAgICAvLyBMZWdhY3kgc3VwcG9ydCBmb3Igd2VhayBwYXNzd29yZCBlcnJvcnMsIHdoZW4gdGhlcmUgd2VyZSBubyBlcnJvciBjb2Rlc1xuICAgICAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICBkYXRhICYmXG4gICAgICAgICAgICB0eXBlb2YgZGF0YS53ZWFrX3Bhc3N3b3JkID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgZGF0YS53ZWFrX3Bhc3N3b3JkICYmXG4gICAgICAgICAgICBBcnJheS5pc0FycmF5KGRhdGEud2Vha19wYXNzd29yZC5yZWFzb25zKSAmJlxuICAgICAgICAgICAgZGF0YS53ZWFrX3Bhc3N3b3JkLnJlYXNvbnMubGVuZ3RoICYmXG4gICAgICAgICAgICBkYXRhLndlYWtfcGFzc3dvcmQucmVhc29ucy5yZWR1Y2UoKGEsIGkpID0+IGEgJiYgdHlwZW9mIGkgPT09ICdzdHJpbmcnLCB0cnVlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEF1dGhXZWFrUGFzc3dvcmRFcnJvcihfZ2V0RXJyb3JNZXNzYWdlKGRhdGEpLCBlcnJvci5zdGF0dXMsIGRhdGEud2Vha19wYXNzd29yZC5yZWFzb25zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChlcnJvckNvZGUgPT09ICd3ZWFrX3Bhc3N3b3JkJykge1xuICAgICAgICB0aHJvdyBuZXcgQXV0aFdlYWtQYXNzd29yZEVycm9yKF9nZXRFcnJvck1lc3NhZ2UoZGF0YSksIGVycm9yLnN0YXR1cywgKChfYSA9IGRhdGEud2Vha19wYXNzd29yZCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlYXNvbnMpIHx8IFtdKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZXJyb3JDb2RlID09PSAnc2Vzc2lvbl9ub3RfZm91bmQnKSB7XG4gICAgICAgIC8vIFRoZSBgc2Vzc2lvbl9pZGAgaW5zaWRlIHRoZSBKV1QgZG9lcyBub3QgY29ycmVzcG9uZCB0byBhIHJvdyBpbiB0aGVcbiAgICAgICAgLy8gYHNlc3Npb25zYCB0YWJsZS4gVGhpcyB1c3VhbGx5IG1lYW5zIHRoZSB1c2VyIGhhcyBzaWduZWQgb3V0LCBoYXMgYmVlblxuICAgICAgICAvLyBkZWxldGVkLCBvciB0aGVpciBzZXNzaW9uIGhhcyBzb21laG93IGJlZW4gdGVybWluYXRlZC5cbiAgICAgICAgdGhyb3cgbmV3IEF1dGhTZXNzaW9uTWlzc2luZ0Vycm9yKCk7XG4gICAgfVxuICAgIHRocm93IG5ldyBBdXRoQXBpRXJyb3IoX2dldEVycm9yTWVzc2FnZShkYXRhKSwgZXJyb3Iuc3RhdHVzIHx8IDUwMCwgZXJyb3JDb2RlKTtcbn1cbmNvbnN0IF9nZXRSZXF1ZXN0UGFyYW1zID0gKG1ldGhvZCwgb3B0aW9ucywgcGFyYW1ldGVycywgYm9keSkgPT4ge1xuICAgIGNvbnN0IHBhcmFtcyA9IHsgbWV0aG9kLCBoZWFkZXJzOiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmhlYWRlcnMpIHx8IHt9IH07XG4gICAgaWYgKG1ldGhvZCA9PT0gJ0dFVCcpIHtcbiAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICB9XG4gICAgcGFyYW1zLmhlYWRlcnMgPSBPYmplY3QuYXNzaWduKHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9VVRGLTgnIH0sIG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5oZWFkZXJzKTtcbiAgICBwYXJhbXMuYm9keSA9IEpTT04uc3RyaW5naWZ5KGJvZHkpO1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHBhcmFtcyksIHBhcmFtZXRlcnMpO1xufTtcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBfcmVxdWVzdChmZXRjaGVyLCBtZXRob2QsIHVybCwgb3B0aW9ucykge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBoZWFkZXJzID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmhlYWRlcnMpO1xuICAgIGlmICghaGVhZGVyc1tBUElfVkVSU0lPTl9IRUFERVJfTkFNRV0pIHtcbiAgICAgICAgaGVhZGVyc1tBUElfVkVSU0lPTl9IRUFERVJfTkFNRV0gPSBBUElfVkVSU0lPTlNbJzIwMjQtMDEtMDEnXS5uYW1lO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmp3dCkge1xuICAgICAgICBoZWFkZXJzWydBdXRob3JpemF0aW9uJ10gPSBgQmVhcmVyICR7b3B0aW9ucy5qd3R9YDtcbiAgICB9XG4gICAgY29uc3QgcXMgPSAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucXVlcnkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHt9O1xuICAgIGlmIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucmVkaXJlY3RUbykge1xuICAgICAgICBxc1sncmVkaXJlY3RfdG8nXSA9IG9wdGlvbnMucmVkaXJlY3RUbztcbiAgICB9XG4gICAgY29uc3QgcXVlcnlTdHJpbmcgPSBPYmplY3Qua2V5cyhxcykubGVuZ3RoID8gJz8nICsgbmV3IFVSTFNlYXJjaFBhcmFtcyhxcykudG9TdHJpbmcoKSA6ICcnO1xuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBfaGFuZGxlUmVxdWVzdChmZXRjaGVyLCBtZXRob2QsIHVybCArIHF1ZXJ5U3RyaW5nLCB7XG4gICAgICAgIGhlYWRlcnMsXG4gICAgICAgIG5vUmVzb2x2ZUpzb246IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5ub1Jlc29sdmVKc29uLFxuICAgIH0sIHt9LCBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuYm9keSk7XG4gICAgcmV0dXJuIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMueGZvcm0pID8gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnhmb3JtKGRhdGEpIDogeyBkYXRhOiBPYmplY3QuYXNzaWduKHt9LCBkYXRhKSwgZXJyb3I6IG51bGwgfTtcbn1cbmFzeW5jIGZ1bmN0aW9uIF9oYW5kbGVSZXF1ZXN0KGZldGNoZXIsIG1ldGhvZCwgdXJsLCBvcHRpb25zLCBwYXJhbWV0ZXJzLCBib2R5KSB7XG4gICAgY29uc3QgcmVxdWVzdFBhcmFtcyA9IF9nZXRSZXF1ZXN0UGFyYW1zKG1ldGhvZCwgb3B0aW9ucywgcGFyYW1ldGVycywgYm9keSk7XG4gICAgbGV0IHJlc3VsdDtcbiAgICB0cnkge1xuICAgICAgICByZXN1bHQgPSBhd2FpdCBmZXRjaGVyKHVybCwgT2JqZWN0LmFzc2lnbih7fSwgcmVxdWVzdFBhcmFtcykpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgICAvLyBmZXRjaCBmYWlsZWQsIGxpa2VseSBkdWUgdG8gYSBuZXR3b3JrIG9yIENPUlMgZXJyb3JcbiAgICAgICAgdGhyb3cgbmV3IEF1dGhSZXRyeWFibGVGZXRjaEVycm9yKF9nZXRFcnJvck1lc3NhZ2UoZSksIDApO1xuICAgIH1cbiAgICBpZiAoIXJlc3VsdC5vaykge1xuICAgICAgICBhd2FpdCBoYW5kbGVFcnJvcihyZXN1bHQpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm5vUmVzb2x2ZUpzb24pIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHJlc3VsdC5qc29uKCk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGF3YWl0IGhhbmRsZUVycm9yKGUpO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBfc2Vzc2lvblJlc3BvbnNlKGRhdGEpIHtcbiAgICB2YXIgX2E7XG4gICAgbGV0IHNlc3Npb24gPSBudWxsO1xuICAgIGlmIChoYXNTZXNzaW9uKGRhdGEpKSB7XG4gICAgICAgIHNlc3Npb24gPSBPYmplY3QuYXNzaWduKHt9LCBkYXRhKTtcbiAgICAgICAgaWYgKCFkYXRhLmV4cGlyZXNfYXQpIHtcbiAgICAgICAgICAgIHNlc3Npb24uZXhwaXJlc19hdCA9IGV4cGlyZXNBdChkYXRhLmV4cGlyZXNfaW4pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHVzZXIgPSAoX2EgPSBkYXRhLnVzZXIpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGRhdGE7XG4gICAgcmV0dXJuIHsgZGF0YTogeyBzZXNzaW9uLCB1c2VyIH0sIGVycm9yOiBudWxsIH07XG59XG5leHBvcnQgZnVuY3Rpb24gX3Nlc3Npb25SZXNwb25zZVBhc3N3b3JkKGRhdGEpIHtcbiAgICBjb25zdCByZXNwb25zZSA9IF9zZXNzaW9uUmVzcG9uc2UoZGF0YSk7XG4gICAgaWYgKCFyZXNwb25zZS5lcnJvciAmJlxuICAgICAgICBkYXRhLndlYWtfcGFzc3dvcmQgJiZcbiAgICAgICAgdHlwZW9mIGRhdGEud2Vha19wYXNzd29yZCA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgQXJyYXkuaXNBcnJheShkYXRhLndlYWtfcGFzc3dvcmQucmVhc29ucykgJiZcbiAgICAgICAgZGF0YS53ZWFrX3Bhc3N3b3JkLnJlYXNvbnMubGVuZ3RoICYmXG4gICAgICAgIGRhdGEud2Vha19wYXNzd29yZC5tZXNzYWdlICYmXG4gICAgICAgIHR5cGVvZiBkYXRhLndlYWtfcGFzc3dvcmQubWVzc2FnZSA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgZGF0YS53ZWFrX3Bhc3N3b3JkLnJlYXNvbnMucmVkdWNlKChhLCBpKSA9PiBhICYmIHR5cGVvZiBpID09PSAnc3RyaW5nJywgdHJ1ZSkpIHtcbiAgICAgICAgcmVzcG9uc2UuZGF0YS53ZWFrX3Bhc3N3b3JkID0gZGF0YS53ZWFrX3Bhc3N3b3JkO1xuICAgIH1cbiAgICByZXR1cm4gcmVzcG9uc2U7XG59XG5leHBvcnQgZnVuY3Rpb24gX3VzZXJSZXNwb25zZShkYXRhKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHVzZXIgPSAoX2EgPSBkYXRhLnVzZXIpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGRhdGE7XG4gICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyIH0sIGVycm9yOiBudWxsIH07XG59XG5leHBvcnQgZnVuY3Rpb24gX3Nzb1Jlc3BvbnNlKGRhdGEpIHtcbiAgICByZXR1cm4geyBkYXRhLCBlcnJvcjogbnVsbCB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIF9nZW5lcmF0ZUxpbmtSZXNwb25zZShkYXRhKSB7XG4gICAgY29uc3QgeyBhY3Rpb25fbGluaywgZW1haWxfb3RwLCBoYXNoZWRfdG9rZW4sIHJlZGlyZWN0X3RvLCB2ZXJpZmljYXRpb25fdHlwZSB9ID0gZGF0YSwgcmVzdCA9IF9fcmVzdChkYXRhLCBbXCJhY3Rpb25fbGlua1wiLCBcImVtYWlsX290cFwiLCBcImhhc2hlZF90b2tlblwiLCBcInJlZGlyZWN0X3RvXCIsIFwidmVyaWZpY2F0aW9uX3R5cGVcIl0pO1xuICAgIGNvbnN0IHByb3BlcnRpZXMgPSB7XG4gICAgICAgIGFjdGlvbl9saW5rLFxuICAgICAgICBlbWFpbF9vdHAsXG4gICAgICAgIGhhc2hlZF90b2tlbixcbiAgICAgICAgcmVkaXJlY3RfdG8sXG4gICAgICAgIHZlcmlmaWNhdGlvbl90eXBlLFxuICAgIH07XG4gICAgY29uc3QgdXNlciA9IE9iamVjdC5hc3NpZ24oe30sIHJlc3QpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIHByb3BlcnRpZXMsXG4gICAgICAgICAgICB1c2VyLFxuICAgICAgICB9LFxuICAgICAgICBlcnJvcjogbnVsbCxcbiAgICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIF9ub1Jlc29sdmVKc29uUmVzcG9uc2UoZGF0YSkge1xuICAgIHJldHVybiBkYXRhO1xufVxuLyoqXG4gKiBoYXNTZXNzaW9uIGNoZWNrcyBpZiB0aGUgcmVzcG9uc2Ugb2JqZWN0IGNvbnRhaW5zIGEgdmFsaWQgc2Vzc2lvblxuICogQHBhcmFtIGRhdGEgQSByZXNwb25zZSBvYmplY3RcbiAqIEByZXR1cm5zIHRydWUgaWYgYSBzZXNzaW9uIGlzIGluIHRoZSByZXNwb25zZVxuICovXG5mdW5jdGlvbiBoYXNTZXNzaW9uKGRhdGEpIHtcbiAgICByZXR1cm4gZGF0YS5hY2Nlc3NfdG9rZW4gJiYgZGF0YS5yZWZyZXNoX3Rva2VuICYmIGRhdGEuZXhwaXJlc19pbjtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZldGNoLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/fetch.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/helpers.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/module/lib/helpers.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Deferred: () => (/* binding */ Deferred),\n/* harmony export */   decodeJWT: () => (/* binding */ decodeJWT),\n/* harmony export */   deepClone: () => (/* binding */ deepClone),\n/* harmony export */   expiresAt: () => (/* binding */ expiresAt),\n/* harmony export */   generatePKCEChallenge: () => (/* binding */ generatePKCEChallenge),\n/* harmony export */   generatePKCEVerifier: () => (/* binding */ generatePKCEVerifier),\n/* harmony export */   getAlgorithm: () => (/* binding */ getAlgorithm),\n/* harmony export */   getCodeChallengeAndMethod: () => (/* binding */ getCodeChallengeAndMethod),\n/* harmony export */   getItemAsync: () => (/* binding */ getItemAsync),\n/* harmony export */   isBrowser: () => (/* binding */ isBrowser),\n/* harmony export */   looksLikeFetchResponse: () => (/* binding */ looksLikeFetchResponse),\n/* harmony export */   parseParametersFromURL: () => (/* binding */ parseParametersFromURL),\n/* harmony export */   parseResponseAPIVersion: () => (/* binding */ parseResponseAPIVersion),\n/* harmony export */   removeItemAsync: () => (/* binding */ removeItemAsync),\n/* harmony export */   resolveFetch: () => (/* binding */ resolveFetch),\n/* harmony export */   retryable: () => (/* binding */ retryable),\n/* harmony export */   setItemAsync: () => (/* binding */ setItemAsync),\n/* harmony export */   sleep: () => (/* binding */ sleep),\n/* harmony export */   supportsLocalStorage: () => (/* binding */ supportsLocalStorage),\n/* harmony export */   userNotAvailableProxy: () => (/* binding */ userNotAvailableProxy),\n/* harmony export */   uuid: () => (/* binding */ uuid),\n/* harmony export */   validateExp: () => (/* binding */ validateExp),\n/* harmony export */   validateUUID: () => (/* binding */ validateUUID)\n/* harmony export */ });\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants */ \"(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/constants.js\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./errors */ \"(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/errors.js\");\n/* harmony import */ var _base64url__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./base64url */ \"(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/base64url.js\");\n\n\n\nfunction expiresAt(expiresIn) {\n    const timeNow = Math.round(Date.now() / 1000);\n    return timeNow + expiresIn;\n}\nfunction uuid() {\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n        const r = (Math.random() * 16) | 0, v = c == 'x' ? r : (r & 0x3) | 0x8;\n        return v.toString(16);\n    });\n}\nconst isBrowser = () => typeof window !== 'undefined' && typeof document !== 'undefined';\nconst localStorageWriteTests = {\n    tested: false,\n    writable: false,\n};\n/**\n * Checks whether localStorage is supported on this browser.\n */\nconst supportsLocalStorage = () => {\n    if (!isBrowser()) {\n        return false;\n    }\n    try {\n        if (typeof globalThis.localStorage !== 'object') {\n            return false;\n        }\n    }\n    catch (e) {\n        // DOM exception when accessing `localStorage`\n        return false;\n    }\n    if (localStorageWriteTests.tested) {\n        return localStorageWriteTests.writable;\n    }\n    const randomKey = `lswt-${Math.random()}${Math.random()}`;\n    try {\n        globalThis.localStorage.setItem(randomKey, randomKey);\n        globalThis.localStorage.removeItem(randomKey);\n        localStorageWriteTests.tested = true;\n        localStorageWriteTests.writable = true;\n    }\n    catch (e) {\n        // localStorage can't be written to\n        // https://www.chromium.org/for-testers/bug-reporting-guidelines/uncaught-securityerror-failed-to-read-the-localstorage-property-from-window-access-is-denied-for-this-document\n        localStorageWriteTests.tested = true;\n        localStorageWriteTests.writable = false;\n    }\n    return localStorageWriteTests.writable;\n};\n/**\n * Extracts parameters encoded in the URL both in the query and fragment.\n */\nfunction parseParametersFromURL(href) {\n    const result = {};\n    const url = new URL(href);\n    if (url.hash && url.hash[0] === '#') {\n        try {\n            const hashSearchParams = new URLSearchParams(url.hash.substring(1));\n            hashSearchParams.forEach((value, key) => {\n                result[key] = value;\n            });\n        }\n        catch (e) {\n            // hash is not a query string\n        }\n    }\n    // search parameters take precedence over hash parameters\n    url.searchParams.forEach((value, key) => {\n        result[key] = value;\n    });\n    return result;\n}\nconst resolveFetch = (customFetch) => {\n    let _fetch;\n    if (customFetch) {\n        _fetch = customFetch;\n    }\n    else if (typeof fetch === 'undefined') {\n        _fetch = (...args) => Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! @supabase/node-fetch */ \"(app-pages-browser)/./node_modules/@supabase/node-fetch/browser.js\")).then(({ default: fetch }) => fetch(...args));\n    }\n    else {\n        _fetch = fetch;\n    }\n    return (...args) => _fetch(...args);\n};\nconst looksLikeFetchResponse = (maybeResponse) => {\n    return (typeof maybeResponse === 'object' &&\n        maybeResponse !== null &&\n        'status' in maybeResponse &&\n        'ok' in maybeResponse &&\n        'json' in maybeResponse &&\n        typeof maybeResponse.json === 'function');\n};\n// Storage helpers\nconst setItemAsync = async (storage, key, data) => {\n    await storage.setItem(key, JSON.stringify(data));\n};\nconst getItemAsync = async (storage, key) => {\n    const value = await storage.getItem(key);\n    if (!value) {\n        return null;\n    }\n    try {\n        return JSON.parse(value);\n    }\n    catch (_a) {\n        return value;\n    }\n};\nconst removeItemAsync = async (storage, key) => {\n    await storage.removeItem(key);\n};\n/**\n * A deferred represents some asynchronous work that is not yet finished, which\n * may or may not culminate in a value.\n * Taken from: https://github.com/mike-north/types/blob/master/src/async.ts\n */\nclass Deferred {\n    constructor() {\n        // eslint-disable-next-line @typescript-eslint/no-extra-semi\n        ;\n        this.promise = new Deferred.promiseConstructor((res, rej) => {\n            // eslint-disable-next-line @typescript-eslint/no-extra-semi\n            ;\n            this.resolve = res;\n            this.reject = rej;\n        });\n    }\n}\nDeferred.promiseConstructor = Promise;\nfunction decodeJWT(token) {\n    const parts = token.split('.');\n    if (parts.length !== 3) {\n        throw new _errors__WEBPACK_IMPORTED_MODULE_1__.AuthInvalidJwtError('Invalid JWT structure');\n    }\n    // Regex checks for base64url format\n    for (let i = 0; i < parts.length; i++) {\n        if (!_constants__WEBPACK_IMPORTED_MODULE_0__.BASE64URL_REGEX.test(parts[i])) {\n            throw new _errors__WEBPACK_IMPORTED_MODULE_1__.AuthInvalidJwtError('JWT not in base64url format');\n        }\n    }\n    const data = {\n        // using base64url lib\n        header: JSON.parse((0,_base64url__WEBPACK_IMPORTED_MODULE_2__.stringFromBase64URL)(parts[0])),\n        payload: JSON.parse((0,_base64url__WEBPACK_IMPORTED_MODULE_2__.stringFromBase64URL)(parts[1])),\n        signature: (0,_base64url__WEBPACK_IMPORTED_MODULE_2__.base64UrlToUint8Array)(parts[2]),\n        raw: {\n            header: parts[0],\n            payload: parts[1],\n        },\n    };\n    return data;\n}\n/**\n * Creates a promise that resolves to null after some time.\n */\nasync function sleep(time) {\n    return await new Promise((accept) => {\n        setTimeout(() => accept(null), time);\n    });\n}\n/**\n * Converts the provided async function into a retryable function. Each result\n * or thrown error is sent to the isRetryable function which should return true\n * if the function should run again.\n */\nfunction retryable(fn, isRetryable) {\n    const promise = new Promise((accept, reject) => {\n        // eslint-disable-next-line @typescript-eslint/no-extra-semi\n        ;\n        (async () => {\n            for (let attempt = 0; attempt < Infinity; attempt++) {\n                try {\n                    const result = await fn(attempt);\n                    if (!isRetryable(attempt, null, result)) {\n                        accept(result);\n                        return;\n                    }\n                }\n                catch (e) {\n                    if (!isRetryable(attempt, e)) {\n                        reject(e);\n                        return;\n                    }\n                }\n            }\n        })();\n    });\n    return promise;\n}\nfunction dec2hex(dec) {\n    return ('0' + dec.toString(16)).substr(-2);\n}\n// Functions below taken from: https://stackoverflow.com/questions/63309409/creating-a-code-verifier-and-challenge-for-pkce-auth-on-spotify-api-in-reactjs\nfunction generatePKCEVerifier() {\n    const verifierLength = 56;\n    const array = new Uint32Array(verifierLength);\n    if (typeof crypto === 'undefined') {\n        const charSet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~';\n        const charSetLen = charSet.length;\n        let verifier = '';\n        for (let i = 0; i < verifierLength; i++) {\n            verifier += charSet.charAt(Math.floor(Math.random() * charSetLen));\n        }\n        return verifier;\n    }\n    crypto.getRandomValues(array);\n    return Array.from(array, dec2hex).join('');\n}\nasync function sha256(randomString) {\n    const encoder = new TextEncoder();\n    const encodedData = encoder.encode(randomString);\n    const hash = await crypto.subtle.digest('SHA-256', encodedData);\n    const bytes = new Uint8Array(hash);\n    return Array.from(bytes)\n        .map((c) => String.fromCharCode(c))\n        .join('');\n}\nasync function generatePKCEChallenge(verifier) {\n    const hasCryptoSupport = typeof crypto !== 'undefined' &&\n        typeof crypto.subtle !== 'undefined' &&\n        typeof TextEncoder !== 'undefined';\n    if (!hasCryptoSupport) {\n        console.warn('WebCrypto API is not supported. Code challenge method will default to use plain instead of sha256.');\n        return verifier;\n    }\n    const hashed = await sha256(verifier);\n    return btoa(hashed).replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=+$/, '');\n}\nasync function getCodeChallengeAndMethod(storage, storageKey, isPasswordRecovery = false) {\n    const codeVerifier = generatePKCEVerifier();\n    let storedCodeVerifier = codeVerifier;\n    if (isPasswordRecovery) {\n        storedCodeVerifier += '/PASSWORD_RECOVERY';\n    }\n    await setItemAsync(storage, `${storageKey}-code-verifier`, storedCodeVerifier);\n    const codeChallenge = await generatePKCEChallenge(codeVerifier);\n    const codeChallengeMethod = codeVerifier === codeChallenge ? 'plain' : 's256';\n    return [codeChallenge, codeChallengeMethod];\n}\n/** Parses the API version which is 2YYY-MM-DD. */\nconst API_VERSION_REGEX = /^2[0-9]{3}-(0[1-9]|1[0-2])-(0[1-9]|1[0-9]|2[0-9]|3[0-1])$/i;\nfunction parseResponseAPIVersion(response) {\n    const apiVersion = response.headers.get(_constants__WEBPACK_IMPORTED_MODULE_0__.API_VERSION_HEADER_NAME);\n    if (!apiVersion) {\n        return null;\n    }\n    if (!apiVersion.match(API_VERSION_REGEX)) {\n        return null;\n    }\n    try {\n        const date = new Date(`${apiVersion}T00:00:00.0Z`);\n        return date;\n    }\n    catch (e) {\n        return null;\n    }\n}\nfunction validateExp(exp) {\n    if (!exp) {\n        throw new Error('Missing exp claim');\n    }\n    const timeNow = Math.floor(Date.now() / 1000);\n    if (exp <= timeNow) {\n        throw new Error('JWT has expired');\n    }\n}\nfunction getAlgorithm(alg) {\n    switch (alg) {\n        case 'RS256':\n            return {\n                name: 'RSASSA-PKCS1-v1_5',\n                hash: { name: 'SHA-256' },\n            };\n        case 'ES256':\n            return {\n                name: 'ECDSA',\n                namedCurve: 'P-256',\n                hash: { name: 'SHA-256' },\n            };\n        default:\n            throw new Error('Invalid alg claim');\n    }\n}\nconst UUID_REGEX = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/;\nfunction validateUUID(str) {\n    if (!UUID_REGEX.test(str)) {\n        throw new Error('@supabase/auth-js: Expected parameter to be UUID but is not');\n    }\n}\nfunction userNotAvailableProxy() {\n    const proxyTarget = {};\n    return new Proxy(proxyTarget, {\n        get: (target, prop) => {\n            if (prop === '__isUserNotAvailableProxy') {\n                return true;\n            }\n            // Preventative check for common problematic symbols during cloning/inspection\n            // These symbols might be accessed by structuredClone or other internal mechanisms.\n            if (typeof prop === 'symbol') {\n                const sProp = prop.toString();\n                if (sProp === 'Symbol(Symbol.toPrimitive)' ||\n                    sProp === 'Symbol(Symbol.toStringTag)' ||\n                    sProp === 'Symbol(util.inspect.custom)') {\n                    // Node.js util.inspect\n                    return undefined;\n                }\n            }\n            throw new Error(`@supabase/auth-js: client was created with userStorage option and there was no user stored in the user storage. Accessing the \"${prop}\" property of the session object is not supported. Please use getUser() instead.`);\n        },\n        set: (_target, prop) => {\n            throw new Error(`@supabase/auth-js: client was created with userStorage option and there was no user stored in the user storage. Setting the \"${prop}\" property of the session object is not supported. Please use getUser() to fetch a user object you can manipulate.`);\n        },\n        deleteProperty: (_target, prop) => {\n            throw new Error(`@supabase/auth-js: client was created with userStorage option and there was no user stored in the user storage. Deleting the \"${prop}\" property of the session object is not supported. Please use getUser() to fetch a user object you can manipulate.`);\n        },\n    });\n}\n/**\n * Deep clones a JSON-serializable object using JSON.parse(JSON.stringify(obj)).\n * Note: Only works for JSON-safe data.\n */\nfunction deepClone(obj) {\n    return JSON.parse(JSON.stringify(obj));\n}\n//# sourceMappingURL=helpers.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvYXV0aC1qcy9kaXN0L21vZHVsZS9saWIvaGVscGVycy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUF1RTtBQUN4QjtBQUMwQjtBQUNsRTtBQUNQO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGNBQWMsRUFBRSxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixzTEFBOEIsU0FBUyxnQkFBZ0I7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSxrQkFBa0Isd0RBQW1CO0FBQ3JDO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDLGFBQWEsdURBQWU7QUFDNUIsc0JBQXNCLHdEQUFtQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiwrREFBbUI7QUFDOUMsNEJBQTRCLCtEQUFtQjtBQUMvQyxtQkFBbUIsaUVBQXFCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxvQkFBb0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isb0JBQW9CO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxXQUFXO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsRUFBRTtBQUM5QjtBQUNQLDRDQUE0QywrREFBdUI7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsV0FBVztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLEVBQUUsVUFBVSxFQUFFLFVBQVUsRUFBRSxVQUFVLEVBQUUsVUFBVSxHQUFHO0FBQzFFO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4SkFBOEosS0FBSztBQUNuSyxTQUFTO0FBQ1Q7QUFDQSw0SkFBNEosS0FBSztBQUNqSyxTQUFTO0FBQ1Q7QUFDQSw2SkFBNkosS0FBSztBQUNsSyxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiRDpcXG5leHRcXG9yZ1xcbm9kZV9tb2R1bGVzXFxAc3VwYWJhc2VcXGF1dGgtanNcXGRpc3RcXG1vZHVsZVxcbGliXFxoZWxwZXJzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEFQSV9WRVJTSU9OX0hFQURFUl9OQU1FLCBCQVNFNjRVUkxfUkVHRVggfSBmcm9tICcuL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBBdXRoSW52YWxpZEp3dEVycm9yIH0gZnJvbSAnLi9lcnJvcnMnO1xuaW1wb3J0IHsgYmFzZTY0VXJsVG9VaW50OEFycmF5LCBzdHJpbmdGcm9tQmFzZTY0VVJMIH0gZnJvbSAnLi9iYXNlNjR1cmwnO1xuZXhwb3J0IGZ1bmN0aW9uIGV4cGlyZXNBdChleHBpcmVzSW4pIHtcbiAgICBjb25zdCB0aW1lTm93ID0gTWF0aC5yb3VuZChEYXRlLm5vdygpIC8gMTAwMCk7XG4gICAgcmV0dXJuIHRpbWVOb3cgKyBleHBpcmVzSW47XG59XG5leHBvcnQgZnVuY3Rpb24gdXVpZCgpIHtcbiAgICByZXR1cm4gJ3h4eHh4eHh4LXh4eHgtNHh4eC15eHh4LXh4eHh4eHh4eHh4eCcucmVwbGFjZSgvW3h5XS9nLCBmdW5jdGlvbiAoYykge1xuICAgICAgICBjb25zdCByID0gKE1hdGgucmFuZG9tKCkgKiAxNikgfCAwLCB2ID0gYyA9PSAneCcgPyByIDogKHIgJiAweDMpIHwgMHg4O1xuICAgICAgICByZXR1cm4gdi50b1N0cmluZygxNik7XG4gICAgfSk7XG59XG5leHBvcnQgY29uc3QgaXNCcm93c2VyID0gKCkgPT4gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJztcbmNvbnN0IGxvY2FsU3RvcmFnZVdyaXRlVGVzdHMgPSB7XG4gICAgdGVzdGVkOiBmYWxzZSxcbiAgICB3cml0YWJsZTogZmFsc2UsXG59O1xuLyoqXG4gKiBDaGVja3Mgd2hldGhlciBsb2NhbFN0b3JhZ2UgaXMgc3VwcG9ydGVkIG9uIHRoaXMgYnJvd3Nlci5cbiAqL1xuZXhwb3J0IGNvbnN0IHN1cHBvcnRzTG9jYWxTdG9yYWdlID0gKCkgPT4ge1xuICAgIGlmICghaXNCcm93c2VyKCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGdsb2JhbFRoaXMubG9jYWxTdG9yYWdlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIC8vIERPTSBleGNlcHRpb24gd2hlbiBhY2Nlc3NpbmcgYGxvY2FsU3RvcmFnZWBcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAobG9jYWxTdG9yYWdlV3JpdGVUZXN0cy50ZXN0ZWQpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsU3RvcmFnZVdyaXRlVGVzdHMud3JpdGFibGU7XG4gICAgfVxuICAgIGNvbnN0IHJhbmRvbUtleSA9IGBsc3d0LSR7TWF0aC5yYW5kb20oKX0ke01hdGgucmFuZG9tKCl9YDtcbiAgICB0cnkge1xuICAgICAgICBnbG9iYWxUaGlzLmxvY2FsU3RvcmFnZS5zZXRJdGVtKHJhbmRvbUtleSwgcmFuZG9tS2V5KTtcbiAgICAgICAgZ2xvYmFsVGhpcy5sb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShyYW5kb21LZXkpO1xuICAgICAgICBsb2NhbFN0b3JhZ2VXcml0ZVRlc3RzLnRlc3RlZCA9IHRydWU7XG4gICAgICAgIGxvY2FsU3RvcmFnZVdyaXRlVGVzdHMud3JpdGFibGUgPSB0cnVlO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICAvLyBsb2NhbFN0b3JhZ2UgY2FuJ3QgYmUgd3JpdHRlbiB0b1xuICAgICAgICAvLyBodHRwczovL3d3dy5jaHJvbWl1bS5vcmcvZm9yLXRlc3RlcnMvYnVnLXJlcG9ydGluZy1ndWlkZWxpbmVzL3VuY2F1Z2h0LXNlY3VyaXR5ZXJyb3ItZmFpbGVkLXRvLXJlYWQtdGhlLWxvY2Fsc3RvcmFnZS1wcm9wZXJ0eS1mcm9tLXdpbmRvdy1hY2Nlc3MtaXMtZGVuaWVkLWZvci10aGlzLWRvY3VtZW50XG4gICAgICAgIGxvY2FsU3RvcmFnZVdyaXRlVGVzdHMudGVzdGVkID0gdHJ1ZTtcbiAgICAgICAgbG9jYWxTdG9yYWdlV3JpdGVUZXN0cy53cml0YWJsZSA9IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gbG9jYWxTdG9yYWdlV3JpdGVUZXN0cy53cml0YWJsZTtcbn07XG4vKipcbiAqIEV4dHJhY3RzIHBhcmFtZXRlcnMgZW5jb2RlZCBpbiB0aGUgVVJMIGJvdGggaW4gdGhlIHF1ZXJ5IGFuZCBmcmFnbWVudC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlUGFyYW1ldGVyc0Zyb21VUkwoaHJlZikge1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoaHJlZik7XG4gICAgaWYgKHVybC5oYXNoICYmIHVybC5oYXNoWzBdID09PSAnIycpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGhhc2hTZWFyY2hQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHVybC5oYXNoLnN1YnN0cmluZygxKSk7XG4gICAgICAgICAgICBoYXNoU2VhcmNoUGFyYW1zLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIGhhc2ggaXMgbm90IGEgcXVlcnkgc3RyaW5nXG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gc2VhcmNoIHBhcmFtZXRlcnMgdGFrZSBwcmVjZWRlbmNlIG92ZXIgaGFzaCBwYXJhbWV0ZXJzXG4gICAgdXJsLnNlYXJjaFBhcmFtcy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydCBjb25zdCByZXNvbHZlRmV0Y2ggPSAoY3VzdG9tRmV0Y2gpID0+IHtcbiAgICBsZXQgX2ZldGNoO1xuICAgIGlmIChjdXN0b21GZXRjaCkge1xuICAgICAgICBfZmV0Y2ggPSBjdXN0b21GZXRjaDtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGZldGNoID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBfZmV0Y2ggPSAoLi4uYXJncykgPT4gaW1wb3J0KCdAc3VwYWJhc2Uvbm9kZS1mZXRjaCcpLnRoZW4oKHsgZGVmYXVsdDogZmV0Y2ggfSkgPT4gZmV0Y2goLi4uYXJncykpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgX2ZldGNoID0gZmV0Y2g7XG4gICAgfVxuICAgIHJldHVybiAoLi4uYXJncykgPT4gX2ZldGNoKC4uLmFyZ3MpO1xufTtcbmV4cG9ydCBjb25zdCBsb29rc0xpa2VGZXRjaFJlc3BvbnNlID0gKG1heWJlUmVzcG9uc2UpID0+IHtcbiAgICByZXR1cm4gKHR5cGVvZiBtYXliZVJlc3BvbnNlID09PSAnb2JqZWN0JyAmJlxuICAgICAgICBtYXliZVJlc3BvbnNlICE9PSBudWxsICYmXG4gICAgICAgICdzdGF0dXMnIGluIG1heWJlUmVzcG9uc2UgJiZcbiAgICAgICAgJ29rJyBpbiBtYXliZVJlc3BvbnNlICYmXG4gICAgICAgICdqc29uJyBpbiBtYXliZVJlc3BvbnNlICYmXG4gICAgICAgIHR5cGVvZiBtYXliZVJlc3BvbnNlLmpzb24gPT09ICdmdW5jdGlvbicpO1xufTtcbi8vIFN0b3JhZ2UgaGVscGVyc1xuZXhwb3J0IGNvbnN0IHNldEl0ZW1Bc3luYyA9IGFzeW5jIChzdG9yYWdlLCBrZXksIGRhdGEpID0+IHtcbiAgICBhd2FpdCBzdG9yYWdlLnNldEl0ZW0oa2V5LCBKU09OLnN0cmluZ2lmeShkYXRhKSk7XG59O1xuZXhwb3J0IGNvbnN0IGdldEl0ZW1Bc3luYyA9IGFzeW5jIChzdG9yYWdlLCBrZXkpID0+IHtcbiAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IHN0b3JhZ2UuZ2V0SXRlbShrZXkpO1xuICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKHZhbHVlKTtcbiAgICB9XG4gICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG59O1xuZXhwb3J0IGNvbnN0IHJlbW92ZUl0ZW1Bc3luYyA9IGFzeW5jIChzdG9yYWdlLCBrZXkpID0+IHtcbiAgICBhd2FpdCBzdG9yYWdlLnJlbW92ZUl0ZW0oa2V5KTtcbn07XG4vKipcbiAqIEEgZGVmZXJyZWQgcmVwcmVzZW50cyBzb21lIGFzeW5jaHJvbm91cyB3b3JrIHRoYXQgaXMgbm90IHlldCBmaW5pc2hlZCwgd2hpY2hcbiAqIG1heSBvciBtYXkgbm90IGN1bG1pbmF0ZSBpbiBhIHZhbHVlLlxuICogVGFrZW4gZnJvbTogaHR0cHM6Ly9naXRodWIuY29tL21pa2Utbm9ydGgvdHlwZXMvYmxvYi9tYXN0ZXIvc3JjL2FzeW5jLnRzXG4gKi9cbmV4cG9ydCBjbGFzcyBEZWZlcnJlZCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXh0cmEtc2VtaVxuICAgICAgICA7XG4gICAgICAgIHRoaXMucHJvbWlzZSA9IG5ldyBEZWZlcnJlZC5wcm9taXNlQ29uc3RydWN0b3IoKHJlcywgcmVqKSA9PiB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4dHJhLXNlbWlcbiAgICAgICAgICAgIDtcbiAgICAgICAgICAgIHRoaXMucmVzb2x2ZSA9IHJlcztcbiAgICAgICAgICAgIHRoaXMucmVqZWN0ID0gcmVqO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5EZWZlcnJlZC5wcm9taXNlQ29uc3RydWN0b3IgPSBQcm9taXNlO1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZUpXVCh0b2tlbikge1xuICAgIGNvbnN0IHBhcnRzID0gdG9rZW4uc3BsaXQoJy4nKTtcbiAgICBpZiAocGFydHMubGVuZ3RoICE9PSAzKSB7XG4gICAgICAgIHRocm93IG5ldyBBdXRoSW52YWxpZEp3dEVycm9yKCdJbnZhbGlkIEpXVCBzdHJ1Y3R1cmUnKTtcbiAgICB9XG4gICAgLy8gUmVnZXggY2hlY2tzIGZvciBiYXNlNjR1cmwgZm9ybWF0XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoIUJBU0U2NFVSTF9SRUdFWC50ZXN0KHBhcnRzW2ldKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEF1dGhJbnZhbGlkSnd0RXJyb3IoJ0pXVCBub3QgaW4gYmFzZTY0dXJsIGZvcm1hdCcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICAgIC8vIHVzaW5nIGJhc2U2NHVybCBsaWJcbiAgICAgICAgaGVhZGVyOiBKU09OLnBhcnNlKHN0cmluZ0Zyb21CYXNlNjRVUkwocGFydHNbMF0pKSxcbiAgICAgICAgcGF5bG9hZDogSlNPTi5wYXJzZShzdHJpbmdGcm9tQmFzZTY0VVJMKHBhcnRzWzFdKSksXG4gICAgICAgIHNpZ25hdHVyZTogYmFzZTY0VXJsVG9VaW50OEFycmF5KHBhcnRzWzJdKSxcbiAgICAgICAgcmF3OiB7XG4gICAgICAgICAgICBoZWFkZXI6IHBhcnRzWzBdLFxuICAgICAgICAgICAgcGF5bG9hZDogcGFydHNbMV0sXG4gICAgICAgIH0sXG4gICAgfTtcbiAgICByZXR1cm4gZGF0YTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBudWxsIGFmdGVyIHNvbWUgdGltZS5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNsZWVwKHRpbWUpIHtcbiAgICByZXR1cm4gYXdhaXQgbmV3IFByb21pc2UoKGFjY2VwdCkgPT4ge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IGFjY2VwdChudWxsKSwgdGltZSk7XG4gICAgfSk7XG59XG4vKipcbiAqIENvbnZlcnRzIHRoZSBwcm92aWRlZCBhc3luYyBmdW5jdGlvbiBpbnRvIGEgcmV0cnlhYmxlIGZ1bmN0aW9uLiBFYWNoIHJlc3VsdFxuICogb3IgdGhyb3duIGVycm9yIGlzIHNlbnQgdG8gdGhlIGlzUmV0cnlhYmxlIGZ1bmN0aW9uIHdoaWNoIHNob3VsZCByZXR1cm4gdHJ1ZVxuICogaWYgdGhlIGZ1bmN0aW9uIHNob3VsZCBydW4gYWdhaW4uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXRyeWFibGUoZm4sIGlzUmV0cnlhYmxlKSB7XG4gICAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChhY2NlcHQsIHJlamVjdCkgPT4ge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4dHJhLXNlbWlcbiAgICAgICAgO1xuICAgICAgICAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgZm9yIChsZXQgYXR0ZW1wdCA9IDA7IGF0dGVtcHQgPCBJbmZpbml0eTsgYXR0ZW1wdCsrKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZm4oYXR0ZW1wdCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNSZXRyeWFibGUoYXR0ZW1wdCwgbnVsbCwgcmVzdWx0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWNjZXB0KHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1JldHJ5YWJsZShhdHRlbXB0LCBlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KSgpO1xuICAgIH0pO1xuICAgIHJldHVybiBwcm9taXNlO1xufVxuZnVuY3Rpb24gZGVjMmhleChkZWMpIHtcbiAgICByZXR1cm4gKCcwJyArIGRlYy50b1N0cmluZygxNikpLnN1YnN0cigtMik7XG59XG4vLyBGdW5jdGlvbnMgYmVsb3cgdGFrZW4gZnJvbTogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNjMzMDk0MDkvY3JlYXRpbmctYS1jb2RlLXZlcmlmaWVyLWFuZC1jaGFsbGVuZ2UtZm9yLXBrY2UtYXV0aC1vbi1zcG90aWZ5LWFwaS1pbi1yZWFjdGpzXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVQS0NFVmVyaWZpZXIoKSB7XG4gICAgY29uc3QgdmVyaWZpZXJMZW5ndGggPSA1NjtcbiAgICBjb25zdCBhcnJheSA9IG5ldyBVaW50MzJBcnJheSh2ZXJpZmllckxlbmd0aCk7XG4gICAgaWYgKHR5cGVvZiBjcnlwdG8gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNvbnN0IGNoYXJTZXQgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODktLl9+JztcbiAgICAgICAgY29uc3QgY2hhclNldExlbiA9IGNoYXJTZXQubGVuZ3RoO1xuICAgICAgICBsZXQgdmVyaWZpZXIgPSAnJztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2ZXJpZmllckxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2ZXJpZmllciArPSBjaGFyU2V0LmNoYXJBdChNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBjaGFyU2V0TGVuKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZlcmlmaWVyO1xuICAgIH1cbiAgICBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKGFycmF5KTtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShhcnJheSwgZGVjMmhleCkuam9pbignJyk7XG59XG5hc3luYyBmdW5jdGlvbiBzaGEyNTYocmFuZG9tU3RyaW5nKSB7XG4gICAgY29uc3QgZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuICAgIGNvbnN0IGVuY29kZWREYXRhID0gZW5jb2Rlci5lbmNvZGUocmFuZG9tU3RyaW5nKTtcbiAgICBjb25zdCBoYXNoID0gYXdhaXQgY3J5cHRvLnN1YnRsZS5kaWdlc3QoJ1NIQS0yNTYnLCBlbmNvZGVkRGF0YSk7XG4gICAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShoYXNoKTtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShieXRlcylcbiAgICAgICAgLm1hcCgoYykgPT4gU3RyaW5nLmZyb21DaGFyQ29kZShjKSlcbiAgICAgICAgLmpvaW4oJycpO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdlbmVyYXRlUEtDRUNoYWxsZW5nZSh2ZXJpZmllcikge1xuICAgIGNvbnN0IGhhc0NyeXB0b1N1cHBvcnQgPSB0eXBlb2YgY3J5cHRvICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICB0eXBlb2YgY3J5cHRvLnN1YnRsZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgdHlwZW9mIFRleHRFbmNvZGVyICE9PSAndW5kZWZpbmVkJztcbiAgICBpZiAoIWhhc0NyeXB0b1N1cHBvcnQpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdXZWJDcnlwdG8gQVBJIGlzIG5vdCBzdXBwb3J0ZWQuIENvZGUgY2hhbGxlbmdlIG1ldGhvZCB3aWxsIGRlZmF1bHQgdG8gdXNlIHBsYWluIGluc3RlYWQgb2Ygc2hhMjU2LicpO1xuICAgICAgICByZXR1cm4gdmVyaWZpZXI7XG4gICAgfVxuICAgIGNvbnN0IGhhc2hlZCA9IGF3YWl0IHNoYTI1Nih2ZXJpZmllcik7XG4gICAgcmV0dXJuIGJ0b2EoaGFzaGVkKS5yZXBsYWNlKC9cXCsvZywgJy0nKS5yZXBsYWNlKC9cXC8vZywgJ18nKS5yZXBsYWNlKC89KyQvLCAnJyk7XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0Q29kZUNoYWxsZW5nZUFuZE1ldGhvZChzdG9yYWdlLCBzdG9yYWdlS2V5LCBpc1Bhc3N3b3JkUmVjb3ZlcnkgPSBmYWxzZSkge1xuICAgIGNvbnN0IGNvZGVWZXJpZmllciA9IGdlbmVyYXRlUEtDRVZlcmlmaWVyKCk7XG4gICAgbGV0IHN0b3JlZENvZGVWZXJpZmllciA9IGNvZGVWZXJpZmllcjtcbiAgICBpZiAoaXNQYXNzd29yZFJlY292ZXJ5KSB7XG4gICAgICAgIHN0b3JlZENvZGVWZXJpZmllciArPSAnL1BBU1NXT1JEX1JFQ09WRVJZJztcbiAgICB9XG4gICAgYXdhaXQgc2V0SXRlbUFzeW5jKHN0b3JhZ2UsIGAke3N0b3JhZ2VLZXl9LWNvZGUtdmVyaWZpZXJgLCBzdG9yZWRDb2RlVmVyaWZpZXIpO1xuICAgIGNvbnN0IGNvZGVDaGFsbGVuZ2UgPSBhd2FpdCBnZW5lcmF0ZVBLQ0VDaGFsbGVuZ2UoY29kZVZlcmlmaWVyKTtcbiAgICBjb25zdCBjb2RlQ2hhbGxlbmdlTWV0aG9kID0gY29kZVZlcmlmaWVyID09PSBjb2RlQ2hhbGxlbmdlID8gJ3BsYWluJyA6ICdzMjU2JztcbiAgICByZXR1cm4gW2NvZGVDaGFsbGVuZ2UsIGNvZGVDaGFsbGVuZ2VNZXRob2RdO1xufVxuLyoqIFBhcnNlcyB0aGUgQVBJIHZlcnNpb24gd2hpY2ggaXMgMllZWS1NTS1ERC4gKi9cbmNvbnN0IEFQSV9WRVJTSU9OX1JFR0VYID0gL14yWzAtOV17M30tKDBbMS05XXwxWzAtMl0pLSgwWzEtOV18MVswLTldfDJbMC05XXwzWzAtMV0pJC9pO1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlUmVzcG9uc2VBUElWZXJzaW9uKHJlc3BvbnNlKSB7XG4gICAgY29uc3QgYXBpVmVyc2lvbiA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KEFQSV9WRVJTSU9OX0hFQURFUl9OQU1FKTtcbiAgICBpZiAoIWFwaVZlcnNpb24pIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmICghYXBpVmVyc2lvbi5tYXRjaChBUElfVkVSU0lPTl9SRUdFWCkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZShgJHthcGlWZXJzaW9ufVQwMDowMDowMC4wWmApO1xuICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlRXhwKGV4cCkge1xuICAgIGlmICghZXhwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBleHAgY2xhaW0nKTtcbiAgICB9XG4gICAgY29uc3QgdGltZU5vdyA9IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDEwMDApO1xuICAgIGlmIChleHAgPD0gdGltZU5vdykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0pXVCBoYXMgZXhwaXJlZCcpO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRBbGdvcml0aG0oYWxnKSB7XG4gICAgc3dpdGNoIChhbGcpIHtcbiAgICAgICAgY2FzZSAnUlMyNTYnOlxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnUlNBU1NBLVBLQ1MxLXYxXzUnLFxuICAgICAgICAgICAgICAgIGhhc2g6IHsgbmFtZTogJ1NIQS0yNTYnIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICBjYXNlICdFUzI1Nic6XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdFQ0RTQScsXG4gICAgICAgICAgICAgICAgbmFtZWRDdXJ2ZTogJ1AtMjU2JyxcbiAgICAgICAgICAgICAgICBoYXNoOiB7IG5hbWU6ICdTSEEtMjU2JyB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhbGcgY2xhaW0nKTtcbiAgICB9XG59XG5jb25zdCBVVUlEX1JFR0VYID0gL15bMC05YS1mXXs4fS1bMC05YS1mXXs0fS1bMC05YS1mXXs0fS1bMC05YS1mXXs0fS1bMC05YS1mXXsxMn0kLztcbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZVVVSUQoc3RyKSB7XG4gICAgaWYgKCFVVUlEX1JFR0VYLnRlc3Qoc3RyKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0BzdXBhYmFzZS9hdXRoLWpzOiBFeHBlY3RlZCBwYXJhbWV0ZXIgdG8gYmUgVVVJRCBidXQgaXMgbm90Jyk7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIHVzZXJOb3RBdmFpbGFibGVQcm94eSgpIHtcbiAgICBjb25zdCBwcm94eVRhcmdldCA9IHt9O1xuICAgIHJldHVybiBuZXcgUHJveHkocHJveHlUYXJnZXQsIHtcbiAgICAgICAgZ2V0OiAodGFyZ2V0LCBwcm9wKSA9PiB7XG4gICAgICAgICAgICBpZiAocHJvcCA9PT0gJ19faXNVc2VyTm90QXZhaWxhYmxlUHJveHknKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBQcmV2ZW50YXRpdmUgY2hlY2sgZm9yIGNvbW1vbiBwcm9ibGVtYXRpYyBzeW1ib2xzIGR1cmluZyBjbG9uaW5nL2luc3BlY3Rpb25cbiAgICAgICAgICAgIC8vIFRoZXNlIHN5bWJvbHMgbWlnaHQgYmUgYWNjZXNzZWQgYnkgc3RydWN0dXJlZENsb25lIG9yIG90aGVyIGludGVybmFsIG1lY2hhbmlzbXMuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHByb3AgPT09ICdzeW1ib2wnKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc1Byb3AgPSBwcm9wLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgaWYgKHNQcm9wID09PSAnU3ltYm9sKFN5bWJvbC50b1ByaW1pdGl2ZSknIHx8XG4gICAgICAgICAgICAgICAgICAgIHNQcm9wID09PSAnU3ltYm9sKFN5bWJvbC50b1N0cmluZ1RhZyknIHx8XG4gICAgICAgICAgICAgICAgICAgIHNQcm9wID09PSAnU3ltYm9sKHV0aWwuaW5zcGVjdC5jdXN0b20pJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBOb2RlLmpzIHV0aWwuaW5zcGVjdFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQHN1cGFiYXNlL2F1dGgtanM6IGNsaWVudCB3YXMgY3JlYXRlZCB3aXRoIHVzZXJTdG9yYWdlIG9wdGlvbiBhbmQgdGhlcmUgd2FzIG5vIHVzZXIgc3RvcmVkIGluIHRoZSB1c2VyIHN0b3JhZ2UuIEFjY2Vzc2luZyB0aGUgXCIke3Byb3B9XCIgcHJvcGVydHkgb2YgdGhlIHNlc3Npb24gb2JqZWN0IGlzIG5vdCBzdXBwb3J0ZWQuIFBsZWFzZSB1c2UgZ2V0VXNlcigpIGluc3RlYWQuYCk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogKF90YXJnZXQsIHByb3ApID0+IHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQHN1cGFiYXNlL2F1dGgtanM6IGNsaWVudCB3YXMgY3JlYXRlZCB3aXRoIHVzZXJTdG9yYWdlIG9wdGlvbiBhbmQgdGhlcmUgd2FzIG5vIHVzZXIgc3RvcmVkIGluIHRoZSB1c2VyIHN0b3JhZ2UuIFNldHRpbmcgdGhlIFwiJHtwcm9wfVwiIHByb3BlcnR5IG9mIHRoZSBzZXNzaW9uIG9iamVjdCBpcyBub3Qgc3VwcG9ydGVkLiBQbGVhc2UgdXNlIGdldFVzZXIoKSB0byBmZXRjaCBhIHVzZXIgb2JqZWN0IHlvdSBjYW4gbWFuaXB1bGF0ZS5gKTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVsZXRlUHJvcGVydHk6IChfdGFyZ2V0LCBwcm9wKSA9PiB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEBzdXBhYmFzZS9hdXRoLWpzOiBjbGllbnQgd2FzIGNyZWF0ZWQgd2l0aCB1c2VyU3RvcmFnZSBvcHRpb24gYW5kIHRoZXJlIHdhcyBubyB1c2VyIHN0b3JlZCBpbiB0aGUgdXNlciBzdG9yYWdlLiBEZWxldGluZyB0aGUgXCIke3Byb3B9XCIgcHJvcGVydHkgb2YgdGhlIHNlc3Npb24gb2JqZWN0IGlzIG5vdCBzdXBwb3J0ZWQuIFBsZWFzZSB1c2UgZ2V0VXNlcigpIHRvIGZldGNoIGEgdXNlciBvYmplY3QgeW91IGNhbiBtYW5pcHVsYXRlLmApO1xuICAgICAgICB9LFxuICAgIH0pO1xufVxuLyoqXG4gKiBEZWVwIGNsb25lcyBhIEpTT04tc2VyaWFsaXphYmxlIG9iamVjdCB1c2luZyBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG9iaikpLlxuICogTm90ZTogT25seSB3b3JrcyBmb3IgSlNPTi1zYWZlIGRhdGEuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWVwQ2xvbmUob2JqKSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkob2JqKSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oZWxwZXJzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/helpers.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/local-storage.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/module/lib/local-storage.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   memoryLocalStorageAdapter: () => (/* binding */ memoryLocalStorageAdapter)\n/* harmony export */ });\n/**\n * Returns a localStorage-like object that stores the key-value pairs in\n * memory.\n */\nfunction memoryLocalStorageAdapter(store = {}) {\n    return {\n        getItem: (key) => {\n            return store[key] || null;\n        },\n        setItem: (key, value) => {\n            store[key] = value;\n        },\n        removeItem: (key) => {\n            delete store[key];\n        },\n    };\n}\n//# sourceMappingURL=local-storage.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvYXV0aC1qcy9kaXN0L21vZHVsZS9saWIvbG9jYWwtc3RvcmFnZS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDTyw2Q0FBNkM7QUFDcEQ7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFxuZXh0XFxvcmdcXG5vZGVfbW9kdWxlc1xcQHN1cGFiYXNlXFxhdXRoLWpzXFxkaXN0XFxtb2R1bGVcXGxpYlxcbG9jYWwtc3RvcmFnZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFJldHVybnMgYSBsb2NhbFN0b3JhZ2UtbGlrZSBvYmplY3QgdGhhdCBzdG9yZXMgdGhlIGtleS12YWx1ZSBwYWlycyBpblxuICogbWVtb3J5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWVtb3J5TG9jYWxTdG9yYWdlQWRhcHRlcihzdG9yZSA9IHt9KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZ2V0SXRlbTogKGtleSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHN0b3JlW2tleV0gfHwgbnVsbDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0SXRlbTogKGtleSwgdmFsdWUpID0+IHtcbiAgICAgICAgICAgIHN0b3JlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVtb3ZlSXRlbTogKGtleSkgPT4ge1xuICAgICAgICAgICAgZGVsZXRlIHN0b3JlW2tleV07XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvY2FsLXN0b3JhZ2UuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/local-storage.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/locks.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/module/lib/locks.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LockAcquireTimeoutError: () => (/* binding */ LockAcquireTimeoutError),\n/* harmony export */   NavigatorLockAcquireTimeoutError: () => (/* binding */ NavigatorLockAcquireTimeoutError),\n/* harmony export */   ProcessLockAcquireTimeoutError: () => (/* binding */ ProcessLockAcquireTimeoutError),\n/* harmony export */   internals: () => (/* binding */ internals),\n/* harmony export */   navigatorLock: () => (/* binding */ navigatorLock),\n/* harmony export */   processLock: () => (/* binding */ processLock)\n/* harmony export */ });\n/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helpers */ \"(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/helpers.js\");\n\n/**\n * @experimental\n */\nconst internals = {\n    /**\n     * @experimental\n     */\n    debug: !!(globalThis &&\n        (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.supportsLocalStorage)() &&\n        globalThis.localStorage &&\n        globalThis.localStorage.getItem('supabase.gotrue-js.locks.debug') === 'true'),\n};\n/**\n * An error thrown when a lock cannot be acquired after some amount of time.\n *\n * Use the {@link #isAcquireTimeout} property instead of checking with `instanceof`.\n */\nclass LockAcquireTimeoutError extends Error {\n    constructor(message) {\n        super(message);\n        this.isAcquireTimeout = true;\n    }\n}\nclass NavigatorLockAcquireTimeoutError extends LockAcquireTimeoutError {\n}\nclass ProcessLockAcquireTimeoutError extends LockAcquireTimeoutError {\n}\n/**\n * Implements a global exclusive lock using the Navigator LockManager API. It\n * is available on all browsers released after 2022-03-15 with Safari being the\n * last one to release support. If the API is not available, this function will\n * throw. Make sure you check availablility before configuring {@link\n * GoTrueClient}.\n *\n * You can turn on debugging by setting the `supabase.gotrue-js.locks.debug`\n * local storage item to `true`.\n *\n * Internals:\n *\n * Since the LockManager API does not preserve stack traces for the async\n * function passed in the `request` method, a trick is used where acquiring the\n * lock releases a previously started promise to run the operation in the `fn`\n * function. The lock waits for that promise to finish (with or without error),\n * while the function will finally wait for the result anyway.\n *\n * @param name Name of the lock to be acquired.\n * @param acquireTimeout If negative, no timeout. If 0 an error is thrown if\n *                       the lock can't be acquired without waiting. If positive, the lock acquire\n *                       will time out after so many milliseconds. An error is\n *                       a timeout if it has `isAcquireTimeout` set to true.\n * @param fn The operation to run once the lock is acquired.\n */\nasync function navigatorLock(name, acquireTimeout, fn) {\n    if (internals.debug) {\n        console.log('@supabase/gotrue-js: navigatorLock: acquire lock', name, acquireTimeout);\n    }\n    const abortController = new globalThis.AbortController();\n    if (acquireTimeout > 0) {\n        setTimeout(() => {\n            abortController.abort();\n            if (internals.debug) {\n                console.log('@supabase/gotrue-js: navigatorLock acquire timed out', name);\n            }\n        }, acquireTimeout);\n    }\n    // MDN article: https://developer.mozilla.org/en-US/docs/Web/API/LockManager/request\n    // Wrapping navigator.locks.request() with a plain Promise is done as some\n    // libraries like zone.js patch the Promise object to track the execution\n    // context. However, it appears that most browsers use an internal promise\n    // implementation when using the navigator.locks.request() API causing them\n    // to lose context and emit confusing log messages or break certain features.\n    // This wrapping is believed to help zone.js track the execution context\n    // better.\n    return await Promise.resolve().then(() => globalThis.navigator.locks.request(name, acquireTimeout === 0\n        ? {\n            mode: 'exclusive',\n            ifAvailable: true,\n        }\n        : {\n            mode: 'exclusive',\n            signal: abortController.signal,\n        }, async (lock) => {\n        if (lock) {\n            if (internals.debug) {\n                console.log('@supabase/gotrue-js: navigatorLock: acquired', name, lock.name);\n            }\n            try {\n                return await fn();\n            }\n            finally {\n                if (internals.debug) {\n                    console.log('@supabase/gotrue-js: navigatorLock: released', name, lock.name);\n                }\n            }\n        }\n        else {\n            if (acquireTimeout === 0) {\n                if (internals.debug) {\n                    console.log('@supabase/gotrue-js: navigatorLock: not immediately available', name);\n                }\n                throw new NavigatorLockAcquireTimeoutError(`Acquiring an exclusive Navigator LockManager lock \"${name}\" immediately failed`);\n            }\n            else {\n                if (internals.debug) {\n                    try {\n                        const result = await globalThis.navigator.locks.query();\n                        console.log('@supabase/gotrue-js: Navigator LockManager state', JSON.stringify(result, null, '  '));\n                    }\n                    catch (e) {\n                        console.warn('@supabase/gotrue-js: Error when querying Navigator LockManager state', e);\n                    }\n                }\n                // Browser is not following the Navigator LockManager spec, it\n                // returned a null lock when we didn't use ifAvailable. So we can\n                // pretend the lock is acquired in the name of backward compatibility\n                // and user experience and just run the function.\n                console.warn('@supabase/gotrue-js: Navigator LockManager returned a null lock when using #request without ifAvailable set to true, it appears this browser is not following the LockManager spec https://developer.mozilla.org/en-US/docs/Web/API/LockManager/request');\n                return await fn();\n            }\n        }\n    }));\n}\nconst PROCESS_LOCKS = {};\n/**\n * Implements a global exclusive lock that works only in the current process.\n * Useful for environments like React Native or other non-browser\n * single-process (i.e. no concept of \"tabs\") environments.\n *\n * Use {@link #navigatorLock} in browser environments.\n *\n * @param name Name of the lock to be acquired.\n * @param acquireTimeout If negative, no timeout. If 0 an error is thrown if\n *                       the lock can't be acquired without waiting. If positive, the lock acquire\n *                       will time out after so many milliseconds. An error is\n *                       a timeout if it has `isAcquireTimeout` set to true.\n * @param fn The operation to run once the lock is acquired.\n */\nasync function processLock(name, acquireTimeout, fn) {\n    var _a;\n    const previousOperation = (_a = PROCESS_LOCKS[name]) !== null && _a !== void 0 ? _a : Promise.resolve();\n    const currentOperation = Promise.race([\n        previousOperation.catch(() => {\n            // ignore error of previous operation that we're waiting to finish\n            return null;\n        }),\n        acquireTimeout >= 0\n            ? new Promise((_, reject) => {\n                setTimeout(() => {\n                    reject(new ProcessLockAcquireTimeoutError(`Acquring process lock with name \"${name}\" timed out`));\n                }, acquireTimeout);\n            })\n            : null,\n    ].filter((x) => x))\n        .catch((e) => {\n        if (e && e.isAcquireTimeout) {\n            throw e;\n        }\n        return null;\n    })\n        .then(async () => {\n        // previous operations finished and we didn't get a race on the acquire\n        // timeout, so the current operation can finally start\n        return await fn();\n    });\n    PROCESS_LOCKS[name] = currentOperation.catch(async (e) => {\n        if (e && e.isAcquireTimeout) {\n            // if the current operation timed out, it doesn't mean that the previous\n            // operation finished, so we need contnue waiting for it to finish\n            await previousOperation;\n            return null;\n        }\n        throw e;\n    });\n    // finally wait for the current operation to finish successfully, with an\n    // error or with an acquire timeout error\n    return await currentOperation;\n}\n//# sourceMappingURL=locks.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvYXV0aC1qcy9kaXN0L21vZHVsZS9saWIvbG9ja3MuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSw4REFBb0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx5QkFBeUI7QUFDckM7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFO0FBQ2hFLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpSEFBaUgsS0FBSztBQUN0SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsc0JBQXNCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxrR0FBa0csS0FBSztBQUN2RyxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiRDpcXG5leHRcXG9yZ1xcbm9kZV9tb2R1bGVzXFxAc3VwYWJhc2VcXGF1dGgtanNcXGRpc3RcXG1vZHVsZVxcbGliXFxsb2Nrcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBzdXBwb3J0c0xvY2FsU3RvcmFnZSB9IGZyb20gJy4vaGVscGVycyc7XG4vKipcbiAqIEBleHBlcmltZW50YWxcbiAqL1xuZXhwb3J0IGNvbnN0IGludGVybmFscyA9IHtcbiAgICAvKipcbiAgICAgKiBAZXhwZXJpbWVudGFsXG4gICAgICovXG4gICAgZGVidWc6ICEhKGdsb2JhbFRoaXMgJiZcbiAgICAgICAgc3VwcG9ydHNMb2NhbFN0b3JhZ2UoKSAmJlxuICAgICAgICBnbG9iYWxUaGlzLmxvY2FsU3RvcmFnZSAmJlxuICAgICAgICBnbG9iYWxUaGlzLmxvY2FsU3RvcmFnZS5nZXRJdGVtKCdzdXBhYmFzZS5nb3RydWUtanMubG9ja3MuZGVidWcnKSA9PT0gJ3RydWUnKSxcbn07XG4vKipcbiAqIEFuIGVycm9yIHRocm93biB3aGVuIGEgbG9jayBjYW5ub3QgYmUgYWNxdWlyZWQgYWZ0ZXIgc29tZSBhbW91bnQgb2YgdGltZS5cbiAqXG4gKiBVc2UgdGhlIHtAbGluayAjaXNBY3F1aXJlVGltZW91dH0gcHJvcGVydHkgaW5zdGVhZCBvZiBjaGVja2luZyB3aXRoIGBpbnN0YW5jZW9mYC5cbiAqL1xuZXhwb3J0IGNsYXNzIExvY2tBY3F1aXJlVGltZW91dEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIHRoaXMuaXNBY3F1aXJlVGltZW91dCA9IHRydWU7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIE5hdmlnYXRvckxvY2tBY3F1aXJlVGltZW91dEVycm9yIGV4dGVuZHMgTG9ja0FjcXVpcmVUaW1lb3V0RXJyb3Ige1xufVxuZXhwb3J0IGNsYXNzIFByb2Nlc3NMb2NrQWNxdWlyZVRpbWVvdXRFcnJvciBleHRlbmRzIExvY2tBY3F1aXJlVGltZW91dEVycm9yIHtcbn1cbi8qKlxuICogSW1wbGVtZW50cyBhIGdsb2JhbCBleGNsdXNpdmUgbG9jayB1c2luZyB0aGUgTmF2aWdhdG9yIExvY2tNYW5hZ2VyIEFQSS4gSXRcbiAqIGlzIGF2YWlsYWJsZSBvbiBhbGwgYnJvd3NlcnMgcmVsZWFzZWQgYWZ0ZXIgMjAyMi0wMy0xNSB3aXRoIFNhZmFyaSBiZWluZyB0aGVcbiAqIGxhc3Qgb25lIHRvIHJlbGVhc2Ugc3VwcG9ydC4gSWYgdGhlIEFQSSBpcyBub3QgYXZhaWxhYmxlLCB0aGlzIGZ1bmN0aW9uIHdpbGxcbiAqIHRocm93LiBNYWtlIHN1cmUgeW91IGNoZWNrIGF2YWlsYWJsaWxpdHkgYmVmb3JlIGNvbmZpZ3VyaW5nIHtAbGlua1xuICogR29UcnVlQ2xpZW50fS5cbiAqXG4gKiBZb3UgY2FuIHR1cm4gb24gZGVidWdnaW5nIGJ5IHNldHRpbmcgdGhlIGBzdXBhYmFzZS5nb3RydWUtanMubG9ja3MuZGVidWdgXG4gKiBsb2NhbCBzdG9yYWdlIGl0ZW0gdG8gYHRydWVgLlxuICpcbiAqIEludGVybmFsczpcbiAqXG4gKiBTaW5jZSB0aGUgTG9ja01hbmFnZXIgQVBJIGRvZXMgbm90IHByZXNlcnZlIHN0YWNrIHRyYWNlcyBmb3IgdGhlIGFzeW5jXG4gKiBmdW5jdGlvbiBwYXNzZWQgaW4gdGhlIGByZXF1ZXN0YCBtZXRob2QsIGEgdHJpY2sgaXMgdXNlZCB3aGVyZSBhY3F1aXJpbmcgdGhlXG4gKiBsb2NrIHJlbGVhc2VzIGEgcHJldmlvdXNseSBzdGFydGVkIHByb21pc2UgdG8gcnVuIHRoZSBvcGVyYXRpb24gaW4gdGhlIGBmbmBcbiAqIGZ1bmN0aW9uLiBUaGUgbG9jayB3YWl0cyBmb3IgdGhhdCBwcm9taXNlIHRvIGZpbmlzaCAod2l0aCBvciB3aXRob3V0IGVycm9yKSxcbiAqIHdoaWxlIHRoZSBmdW5jdGlvbiB3aWxsIGZpbmFsbHkgd2FpdCBmb3IgdGhlIHJlc3VsdCBhbnl3YXkuXG4gKlxuICogQHBhcmFtIG5hbWUgTmFtZSBvZiB0aGUgbG9jayB0byBiZSBhY3F1aXJlZC5cbiAqIEBwYXJhbSBhY3F1aXJlVGltZW91dCBJZiBuZWdhdGl2ZSwgbm8gdGltZW91dC4gSWYgMCBhbiBlcnJvciBpcyB0aHJvd24gaWZcbiAqICAgICAgICAgICAgICAgICAgICAgICB0aGUgbG9jayBjYW4ndCBiZSBhY3F1aXJlZCB3aXRob3V0IHdhaXRpbmcuIElmIHBvc2l0aXZlLCB0aGUgbG9jayBhY3F1aXJlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgd2lsbCB0aW1lIG91dCBhZnRlciBzbyBtYW55IG1pbGxpc2Vjb25kcy4gQW4gZXJyb3IgaXNcbiAqICAgICAgICAgICAgICAgICAgICAgICBhIHRpbWVvdXQgaWYgaXQgaGFzIGBpc0FjcXVpcmVUaW1lb3V0YCBzZXQgdG8gdHJ1ZS5cbiAqIEBwYXJhbSBmbiBUaGUgb3BlcmF0aW9uIHRvIHJ1biBvbmNlIHRoZSBsb2NrIGlzIGFjcXVpcmVkLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gbmF2aWdhdG9yTG9jayhuYW1lLCBhY3F1aXJlVGltZW91dCwgZm4pIHtcbiAgICBpZiAoaW50ZXJuYWxzLmRlYnVnKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdAc3VwYWJhc2UvZ290cnVlLWpzOiBuYXZpZ2F0b3JMb2NrOiBhY3F1aXJlIGxvY2snLCBuYW1lLCBhY3F1aXJlVGltZW91dCk7XG4gICAgfVxuICAgIGNvbnN0IGFib3J0Q29udHJvbGxlciA9IG5ldyBnbG9iYWxUaGlzLkFib3J0Q29udHJvbGxlcigpO1xuICAgIGlmIChhY3F1aXJlVGltZW91dCA+IDApIHtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBhYm9ydENvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICAgICAgICAgIGlmIChpbnRlcm5hbHMuZGVidWcpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnQHN1cGFiYXNlL2dvdHJ1ZS1qczogbmF2aWdhdG9yTG9jayBhY3F1aXJlIHRpbWVkIG91dCcsIG5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBhY3F1aXJlVGltZW91dCk7XG4gICAgfVxuICAgIC8vIE1ETiBhcnRpY2xlOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTG9ja01hbmFnZXIvcmVxdWVzdFxuICAgIC8vIFdyYXBwaW5nIG5hdmlnYXRvci5sb2Nrcy5yZXF1ZXN0KCkgd2l0aCBhIHBsYWluIFByb21pc2UgaXMgZG9uZSBhcyBzb21lXG4gICAgLy8gbGlicmFyaWVzIGxpa2Ugem9uZS5qcyBwYXRjaCB0aGUgUHJvbWlzZSBvYmplY3QgdG8gdHJhY2sgdGhlIGV4ZWN1dGlvblxuICAgIC8vIGNvbnRleHQuIEhvd2V2ZXIsIGl0IGFwcGVhcnMgdGhhdCBtb3N0IGJyb3dzZXJzIHVzZSBhbiBpbnRlcm5hbCBwcm9taXNlXG4gICAgLy8gaW1wbGVtZW50YXRpb24gd2hlbiB1c2luZyB0aGUgbmF2aWdhdG9yLmxvY2tzLnJlcXVlc3QoKSBBUEkgY2F1c2luZyB0aGVtXG4gICAgLy8gdG8gbG9zZSBjb250ZXh0IGFuZCBlbWl0IGNvbmZ1c2luZyBsb2cgbWVzc2FnZXMgb3IgYnJlYWsgY2VydGFpbiBmZWF0dXJlcy5cbiAgICAvLyBUaGlzIHdyYXBwaW5nIGlzIGJlbGlldmVkIHRvIGhlbHAgem9uZS5qcyB0cmFjayB0aGUgZXhlY3V0aW9uIGNvbnRleHRcbiAgICAvLyBiZXR0ZXIuXG4gICAgcmV0dXJuIGF3YWl0IFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4gZ2xvYmFsVGhpcy5uYXZpZ2F0b3IubG9ja3MucmVxdWVzdChuYW1lLCBhY3F1aXJlVGltZW91dCA9PT0gMFxuICAgICAgICA/IHtcbiAgICAgICAgICAgIG1vZGU6ICdleGNsdXNpdmUnLFxuICAgICAgICAgICAgaWZBdmFpbGFibGU6IHRydWUsXG4gICAgICAgIH1cbiAgICAgICAgOiB7XG4gICAgICAgICAgICBtb2RlOiAnZXhjbHVzaXZlJyxcbiAgICAgICAgICAgIHNpZ25hbDogYWJvcnRDb250cm9sbGVyLnNpZ25hbCxcbiAgICAgICAgfSwgYXN5bmMgKGxvY2spID0+IHtcbiAgICAgICAgaWYgKGxvY2spIHtcbiAgICAgICAgICAgIGlmIChpbnRlcm5hbHMuZGVidWcpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnQHN1cGFiYXNlL2dvdHJ1ZS1qczogbmF2aWdhdG9yTG9jazogYWNxdWlyZWQnLCBuYW1lLCBsb2NrLm5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgZm4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIGlmIChpbnRlcm5hbHMuZGVidWcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0BzdXBhYmFzZS9nb3RydWUtanM6IG5hdmlnYXRvckxvY2s6IHJlbGVhc2VkJywgbmFtZSwgbG9jay5uYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoYWNxdWlyZVRpbWVvdXQgPT09IDApIHtcbiAgICAgICAgICAgICAgICBpZiAoaW50ZXJuYWxzLmRlYnVnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdAc3VwYWJhc2UvZ290cnVlLWpzOiBuYXZpZ2F0b3JMb2NrOiBub3QgaW1tZWRpYXRlbHkgYXZhaWxhYmxlJywgbmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBOYXZpZ2F0b3JMb2NrQWNxdWlyZVRpbWVvdXRFcnJvcihgQWNxdWlyaW5nIGFuIGV4Y2x1c2l2ZSBOYXZpZ2F0b3IgTG9ja01hbmFnZXIgbG9jayBcIiR7bmFtZX1cIiBpbW1lZGlhdGVseSBmYWlsZWRgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChpbnRlcm5hbHMuZGVidWcpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGdsb2JhbFRoaXMubmF2aWdhdG9yLmxvY2tzLnF1ZXJ5KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnQHN1cGFiYXNlL2dvdHJ1ZS1qczogTmF2aWdhdG9yIExvY2tNYW5hZ2VyIHN0YXRlJywgSlNPTi5zdHJpbmdpZnkocmVzdWx0LCBudWxsLCAnICAnKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignQHN1cGFiYXNlL2dvdHJ1ZS1qczogRXJyb3Igd2hlbiBxdWVyeWluZyBOYXZpZ2F0b3IgTG9ja01hbmFnZXIgc3RhdGUnLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBCcm93c2VyIGlzIG5vdCBmb2xsb3dpbmcgdGhlIE5hdmlnYXRvciBMb2NrTWFuYWdlciBzcGVjLCBpdFxuICAgICAgICAgICAgICAgIC8vIHJldHVybmVkIGEgbnVsbCBsb2NrIHdoZW4gd2UgZGlkbid0IHVzZSBpZkF2YWlsYWJsZS4gU28gd2UgY2FuXG4gICAgICAgICAgICAgICAgLy8gcHJldGVuZCB0aGUgbG9jayBpcyBhY3F1aXJlZCBpbiB0aGUgbmFtZSBvZiBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG4gICAgICAgICAgICAgICAgLy8gYW5kIHVzZXIgZXhwZXJpZW5jZSBhbmQganVzdCBydW4gdGhlIGZ1bmN0aW9uLlxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignQHN1cGFiYXNlL2dvdHJ1ZS1qczogTmF2aWdhdG9yIExvY2tNYW5hZ2VyIHJldHVybmVkIGEgbnVsbCBsb2NrIHdoZW4gdXNpbmcgI3JlcXVlc3Qgd2l0aG91dCBpZkF2YWlsYWJsZSBzZXQgdG8gdHJ1ZSwgaXQgYXBwZWFycyB0aGlzIGJyb3dzZXIgaXMgbm90IGZvbGxvd2luZyB0aGUgTG9ja01hbmFnZXIgc3BlYyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTG9ja01hbmFnZXIvcmVxdWVzdCcpO1xuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCBmbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSkpO1xufVxuY29uc3QgUFJPQ0VTU19MT0NLUyA9IHt9O1xuLyoqXG4gKiBJbXBsZW1lbnRzIGEgZ2xvYmFsIGV4Y2x1c2l2ZSBsb2NrIHRoYXQgd29ya3Mgb25seSBpbiB0aGUgY3VycmVudCBwcm9jZXNzLlxuICogVXNlZnVsIGZvciBlbnZpcm9ubWVudHMgbGlrZSBSZWFjdCBOYXRpdmUgb3Igb3RoZXIgbm9uLWJyb3dzZXJcbiAqIHNpbmdsZS1wcm9jZXNzIChpLmUuIG5vIGNvbmNlcHQgb2YgXCJ0YWJzXCIpIGVudmlyb25tZW50cy5cbiAqXG4gKiBVc2Uge0BsaW5rICNuYXZpZ2F0b3JMb2NrfSBpbiBicm93c2VyIGVudmlyb25tZW50cy5cbiAqXG4gKiBAcGFyYW0gbmFtZSBOYW1lIG9mIHRoZSBsb2NrIHRvIGJlIGFjcXVpcmVkLlxuICogQHBhcmFtIGFjcXVpcmVUaW1lb3V0IElmIG5lZ2F0aXZlLCBubyB0aW1lb3V0LiBJZiAwIGFuIGVycm9yIGlzIHRocm93biBpZlxuICogICAgICAgICAgICAgICAgICAgICAgIHRoZSBsb2NrIGNhbid0IGJlIGFjcXVpcmVkIHdpdGhvdXQgd2FpdGluZy4gSWYgcG9zaXRpdmUsIHRoZSBsb2NrIGFjcXVpcmVcbiAqICAgICAgICAgICAgICAgICAgICAgICB3aWxsIHRpbWUgb3V0IGFmdGVyIHNvIG1hbnkgbWlsbGlzZWNvbmRzLiBBbiBlcnJvciBpc1xuICogICAgICAgICAgICAgICAgICAgICAgIGEgdGltZW91dCBpZiBpdCBoYXMgYGlzQWNxdWlyZVRpbWVvdXRgIHNldCB0byB0cnVlLlxuICogQHBhcmFtIGZuIFRoZSBvcGVyYXRpb24gdG8gcnVuIG9uY2UgdGhlIGxvY2sgaXMgYWNxdWlyZWQuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwcm9jZXNzTG9jayhuYW1lLCBhY3F1aXJlVGltZW91dCwgZm4pIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgcHJldmlvdXNPcGVyYXRpb24gPSAoX2EgPSBQUk9DRVNTX0xPQ0tTW25hbWVdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICBjb25zdCBjdXJyZW50T3BlcmF0aW9uID0gUHJvbWlzZS5yYWNlKFtcbiAgICAgICAgcHJldmlvdXNPcGVyYXRpb24uY2F0Y2goKCkgPT4ge1xuICAgICAgICAgICAgLy8gaWdub3JlIGVycm9yIG9mIHByZXZpb3VzIG9wZXJhdGlvbiB0aGF0IHdlJ3JlIHdhaXRpbmcgdG8gZmluaXNoXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSksXG4gICAgICAgIGFjcXVpcmVUaW1lb3V0ID49IDBcbiAgICAgICAgICAgID8gbmV3IFByb21pc2UoKF8sIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IFByb2Nlc3NMb2NrQWNxdWlyZVRpbWVvdXRFcnJvcihgQWNxdXJpbmcgcHJvY2VzcyBsb2NrIHdpdGggbmFtZSBcIiR7bmFtZX1cIiB0aW1lZCBvdXRgKSk7XG4gICAgICAgICAgICAgICAgfSwgYWNxdWlyZVRpbWVvdXQpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIDogbnVsbCxcbiAgICBdLmZpbHRlcigoeCkgPT4geCkpXG4gICAgICAgIC5jYXRjaCgoZSkgPT4ge1xuICAgICAgICBpZiAoZSAmJiBlLmlzQWNxdWlyZVRpbWVvdXQpIHtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSlcbiAgICAgICAgLnRoZW4oYXN5bmMgKCkgPT4ge1xuICAgICAgICAvLyBwcmV2aW91cyBvcGVyYXRpb25zIGZpbmlzaGVkIGFuZCB3ZSBkaWRuJ3QgZ2V0IGEgcmFjZSBvbiB0aGUgYWNxdWlyZVxuICAgICAgICAvLyB0aW1lb3V0LCBzbyB0aGUgY3VycmVudCBvcGVyYXRpb24gY2FuIGZpbmFsbHkgc3RhcnRcbiAgICAgICAgcmV0dXJuIGF3YWl0IGZuKCk7XG4gICAgfSk7XG4gICAgUFJPQ0VTU19MT0NLU1tuYW1lXSA9IGN1cnJlbnRPcGVyYXRpb24uY2F0Y2goYXN5bmMgKGUpID0+IHtcbiAgICAgICAgaWYgKGUgJiYgZS5pc0FjcXVpcmVUaW1lb3V0KSB7XG4gICAgICAgICAgICAvLyBpZiB0aGUgY3VycmVudCBvcGVyYXRpb24gdGltZWQgb3V0LCBpdCBkb2Vzbid0IG1lYW4gdGhhdCB0aGUgcHJldmlvdXNcbiAgICAgICAgICAgIC8vIG9wZXJhdGlvbiBmaW5pc2hlZCwgc28gd2UgbmVlZCBjb250bnVlIHdhaXRpbmcgZm9yIGl0IHRvIGZpbmlzaFxuICAgICAgICAgICAgYXdhaXQgcHJldmlvdXNPcGVyYXRpb247XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlO1xuICAgIH0pO1xuICAgIC8vIGZpbmFsbHkgd2FpdCBmb3IgdGhlIGN1cnJlbnQgb3BlcmF0aW9uIHRvIGZpbmlzaCBzdWNjZXNzZnVsbHksIHdpdGggYW5cbiAgICAvLyBlcnJvciBvciB3aXRoIGFuIGFjcXVpcmUgdGltZW91dCBlcnJvclxuICAgIHJldHVybiBhd2FpdCBjdXJyZW50T3BlcmF0aW9uO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9ja3MuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/locks.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/polyfills.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/module/lib/polyfills.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   polyfillGlobalThis: () => (/* binding */ polyfillGlobalThis)\n/* harmony export */ });\n/**\n * https://mathiasbynens.be/notes/globalthis\n */\nfunction polyfillGlobalThis() {\n    if (typeof globalThis === 'object')\n        return;\n    try {\n        Object.defineProperty(Object.prototype, '__magic__', {\n            get: function () {\n                return this;\n            },\n            configurable: true,\n        });\n        // @ts-expect-error 'Allow access to magic'\n        __magic__.globalThis = __magic__;\n        // @ts-expect-error 'Allow access to magic'\n        delete Object.prototype.__magic__;\n    }\n    catch (e) {\n        if (typeof self !== 'undefined') {\n            // @ts-expect-error 'Allow access to globals'\n            self.globalThis = self;\n        }\n    }\n}\n//# sourceMappingURL=polyfills.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvYXV0aC1qcy9kaXN0L21vZHVsZS9saWIvcG9seWZpbGxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiRDpcXG5leHRcXG9yZ1xcbm9kZV9tb2R1bGVzXFxAc3VwYWJhc2VcXGF1dGgtanNcXGRpc3RcXG1vZHVsZVxcbGliXFxwb2x5ZmlsbHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvZ2xvYmFsdGhpc1xuICovXG5leHBvcnQgZnVuY3Rpb24gcG9seWZpbGxHbG9iYWxUaGlzKCkge1xuICAgIGlmICh0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ29iamVjdCcpXG4gICAgICAgIHJldHVybjtcbiAgICB0cnkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoT2JqZWN0LnByb3RvdHlwZSwgJ19fbWFnaWNfXycsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgJ0FsbG93IGFjY2VzcyB0byBtYWdpYydcbiAgICAgICAgX19tYWdpY19fLmdsb2JhbFRoaXMgPSBfX21hZ2ljX187XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgJ0FsbG93IGFjY2VzcyB0byBtYWdpYydcbiAgICAgICAgZGVsZXRlIE9iamVjdC5wcm90b3R5cGUuX19tYWdpY19fO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yICdBbGxvdyBhY2Nlc3MgdG8gZ2xvYmFscydcbiAgICAgICAgICAgIHNlbGYuZ2xvYmFsVGhpcyA9IHNlbGY7XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wb2x5ZmlsbHMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/polyfills.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/types.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/module/lib/types.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SIGN_OUT_SCOPES: () => (/* binding */ SIGN_OUT_SCOPES)\n/* harmony export */ });\nconst WeakPasswordReasons = ['length', 'characters', 'pwned'];\nconst AMRMethods = [\n    'password',\n    'otp',\n    'oauth',\n    'totp',\n    'mfa/totp',\n    'mfa/phone',\n    'mfa/webauthn',\n    'anonymous',\n    'sso/saml',\n    'magiclink',\n    'web3',\n];\nconst FactorTypes = ['totp', 'phone', 'webauthn'];\nconst FactorVerificationStatuses = ['verified', 'unverified'];\nconst MFATOTPChannels = ['sms', 'whatsapp'];\nconst SIGN_OUT_SCOPES = ['global', 'local', 'others'];\n//# sourceMappingURL=types.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvYXV0aC1qcy9kaXN0L21vZHVsZS9saWIvdHlwZXMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQIiwic291cmNlcyI6WyJEOlxcbmV4dFxcb3JnXFxub2RlX21vZHVsZXNcXEBzdXBhYmFzZVxcYXV0aC1qc1xcZGlzdFxcbW9kdWxlXFxsaWJcXHR5cGVzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IFdlYWtQYXNzd29yZFJlYXNvbnMgPSBbJ2xlbmd0aCcsICdjaGFyYWN0ZXJzJywgJ3B3bmVkJ107XG5jb25zdCBBTVJNZXRob2RzID0gW1xuICAgICdwYXNzd29yZCcsXG4gICAgJ290cCcsXG4gICAgJ29hdXRoJyxcbiAgICAndG90cCcsXG4gICAgJ21mYS90b3RwJyxcbiAgICAnbWZhL3Bob25lJyxcbiAgICAnbWZhL3dlYmF1dGhuJyxcbiAgICAnYW5vbnltb3VzJyxcbiAgICAnc3NvL3NhbWwnLFxuICAgICdtYWdpY2xpbmsnLFxuICAgICd3ZWIzJyxcbl07XG5jb25zdCBGYWN0b3JUeXBlcyA9IFsndG90cCcsICdwaG9uZScsICd3ZWJhdXRobiddO1xuY29uc3QgRmFjdG9yVmVyaWZpY2F0aW9uU3RhdHVzZXMgPSBbJ3ZlcmlmaWVkJywgJ3VudmVyaWZpZWQnXTtcbmNvbnN0IE1GQVRPVFBDaGFubmVscyA9IFsnc21zJywgJ3doYXRzYXBwJ107XG5leHBvcnQgY29uc3QgU0lHTl9PVVRfU0NPUEVTID0gWydnbG9iYWwnLCAnbG9jYWwnLCAnb3RoZXJzJ107XG4vLyMgc291cmNlTWFwcGluZ1VSTD10eXBlcy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/types.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/version.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/module/lib/version.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\n// Generated automatically during releases by scripts/update-version-files.ts\n// This file provides runtime access to the package version for:\n// - HTTP request headers (e.g., X-Client-Info header for API requests)\n// - Debugging and support (identifying which version is running)\n// - Telemetry and logging (version reporting in errors/analytics)\n// - Ensuring build artifacts match the published package version\nconst version = '2.74.0';\n//# sourceMappingURL=version.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvYXV0aC1qcy9kaXN0L21vZHVsZS9saWIvdmVyc2lvbi5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCIsInNvdXJjZXMiOlsiRDpcXG5leHRcXG9yZ1xcbm9kZV9tb2R1bGVzXFxAc3VwYWJhc2VcXGF1dGgtanNcXGRpc3RcXG1vZHVsZVxcbGliXFx2ZXJzaW9uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEdlbmVyYXRlZCBhdXRvbWF0aWNhbGx5IGR1cmluZyByZWxlYXNlcyBieSBzY3JpcHRzL3VwZGF0ZS12ZXJzaW9uLWZpbGVzLnRzXG4vLyBUaGlzIGZpbGUgcHJvdmlkZXMgcnVudGltZSBhY2Nlc3MgdG8gdGhlIHBhY2thZ2UgdmVyc2lvbiBmb3I6XG4vLyAtIEhUVFAgcmVxdWVzdCBoZWFkZXJzIChlLmcuLCBYLUNsaWVudC1JbmZvIGhlYWRlciBmb3IgQVBJIHJlcXVlc3RzKVxuLy8gLSBEZWJ1Z2dpbmcgYW5kIHN1cHBvcnQgKGlkZW50aWZ5aW5nIHdoaWNoIHZlcnNpb24gaXMgcnVubmluZylcbi8vIC0gVGVsZW1ldHJ5IGFuZCBsb2dnaW5nICh2ZXJzaW9uIHJlcG9ydGluZyBpbiBlcnJvcnMvYW5hbHl0aWNzKVxuLy8gLSBFbnN1cmluZyBidWlsZCBhcnRpZmFjdHMgbWF0Y2ggdGhlIHB1Ymxpc2hlZCBwYWNrYWdlIHZlcnNpb25cbmV4cG9ydCBjb25zdCB2ZXJzaW9uID0gJzIuNzQuMCc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD12ZXJzaW9uLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/version.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/web3/ethereum.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/module/lib/web3/ethereum.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createSiweMessage: () => (/* binding */ createSiweMessage),\n/* harmony export */   fromHex: () => (/* binding */ fromHex),\n/* harmony export */   getAddress: () => (/* binding */ getAddress),\n/* harmony export */   toHex: () => (/* binding */ toHex)\n/* harmony export */ });\n// types and functions copied over from viem so this library doesn't depend on it\nfunction getAddress(address) {\n    if (!/^0x[a-fA-F0-9]{40}$/.test(address)) {\n        throw new Error(`@supabase/auth-js: Address \"${address}\" is invalid.`);\n    }\n    return address.toLowerCase();\n}\nfunction fromHex(hex) {\n    return parseInt(hex, 16);\n}\nfunction toHex(value) {\n    const bytes = new TextEncoder().encode(value);\n    const hex = Array.from(bytes, (byte) => byte.toString(16).padStart(2, '0')).join('');\n    return ('0x' + hex);\n}\n/**\n * Creates EIP-4361 formatted message.\n */\nfunction createSiweMessage(parameters) {\n    var _a;\n    const { chainId, domain, expirationTime, issuedAt = new Date(), nonce, notBefore, requestId, resources, scheme, uri, version, } = parameters;\n    // Validate fields\n    {\n        if (!Number.isInteger(chainId))\n            throw new Error(`@supabase/auth-js: Invalid SIWE message field \"chainId\". Chain ID must be a EIP-155 chain ID. Provided value: ${chainId}`);\n        if (!domain)\n            throw new Error(`@supabase/auth-js: Invalid SIWE message field \"domain\". Domain must be provided.`);\n        if (nonce && nonce.length < 8)\n            throw new Error(`@supabase/auth-js: Invalid SIWE message field \"nonce\". Nonce must be at least 8 characters. Provided value: ${nonce}`);\n        if (!uri)\n            throw new Error(`@supabase/auth-js: Invalid SIWE message field \"uri\". URI must be provided.`);\n        if (version !== '1')\n            throw new Error(`@supabase/auth-js: Invalid SIWE message field \"version\". Version must be '1'. Provided value: ${version}`);\n        if ((_a = parameters.statement) === null || _a === void 0 ? void 0 : _a.includes('\\n'))\n            throw new Error(`@supabase/auth-js: Invalid SIWE message field \"statement\". Statement must not include '\\\\n'. Provided value: ${parameters.statement}`);\n    }\n    // Construct message\n    const address = getAddress(parameters.address);\n    const origin = scheme ? `${scheme}://${domain}` : domain;\n    const statement = parameters.statement ? `${parameters.statement}\\n` : '';\n    const prefix = `${origin} wants you to sign in with your Ethereum account:\\n${address}\\n\\n${statement}`;\n    let suffix = `URI: ${uri}\\nVersion: ${version}\\nChain ID: ${chainId}${nonce ? `\\nNonce: ${nonce}` : ''}\\nIssued At: ${issuedAt.toISOString()}`;\n    if (expirationTime)\n        suffix += `\\nExpiration Time: ${expirationTime.toISOString()}`;\n    if (notBefore)\n        suffix += `\\nNot Before: ${notBefore.toISOString()}`;\n    if (requestId)\n        suffix += `\\nRequest ID: ${requestId}`;\n    if (resources) {\n        let content = '\\nResources:';\n        for (const resource of resources) {\n            if (!resource || typeof resource !== 'string')\n                throw new Error(`@supabase/auth-js: Invalid SIWE message field \"resources\". Every resource must be a valid string. Provided value: ${resource}`);\n            content += `\\n- ${resource}`;\n        }\n        suffix += content;\n    }\n    return `${prefix}\\n${suffix}`;\n}\n//# sourceMappingURL=ethereum.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvYXV0aC1qcy9kaXN0L21vZHVsZS9saWIvd2ViMy9ldGhlcmV1bS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDTztBQUNQLHlCQUF5QixHQUFHO0FBQzVCLHVEQUF1RCxRQUFRO0FBQy9EO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsWUFBWSx3SEFBd0g7QUFDcEk7QUFDQTtBQUNBO0FBQ0EsNklBQTZJLFFBQVE7QUFDcko7QUFDQTtBQUNBO0FBQ0EsMklBQTJJLE1BQU07QUFDako7QUFDQTtBQUNBO0FBQ0EsNkhBQTZILFFBQVE7QUFDckk7QUFDQSw0SUFBNEkscUJBQXFCO0FBQ2pLO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixPQUFPLEtBQUssT0FBTztBQUNsRCxnREFBZ0QscUJBQXFCO0FBQ3JFLHNCQUFzQixRQUFRLG9EQUFvRCxRQUFRLE1BQU0sVUFBVTtBQUMxRyx5QkFBeUIsSUFBSSxhQUFhLFFBQVEsY0FBYyxRQUFRLEVBQUUsb0JBQW9CLE1BQU0sT0FBTyxlQUFlLHVCQUF1QjtBQUNqSjtBQUNBLHdDQUF3Qyw2QkFBNkI7QUFDckU7QUFDQSxtQ0FBbUMsd0JBQXdCO0FBQzNEO0FBQ0EsbUNBQW1DLFVBQVU7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxSkFBcUosU0FBUztBQUM5Siw4QkFBOEIsU0FBUztBQUN2QztBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU8sSUFBSSxPQUFPO0FBQ2hDO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFxuZXh0XFxvcmdcXG5vZGVfbW9kdWxlc1xcQHN1cGFiYXNlXFxhdXRoLWpzXFxkaXN0XFxtb2R1bGVcXGxpYlxcd2ViM1xcZXRoZXJldW0uanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gdHlwZXMgYW5kIGZ1bmN0aW9ucyBjb3BpZWQgb3ZlciBmcm9tIHZpZW0gc28gdGhpcyBsaWJyYXJ5IGRvZXNuJ3QgZGVwZW5kIG9uIGl0XG5leHBvcnQgZnVuY3Rpb24gZ2V0QWRkcmVzcyhhZGRyZXNzKSB7XG4gICAgaWYgKCEvXjB4W2EtZkEtRjAtOV17NDB9JC8udGVzdChhZGRyZXNzKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEBzdXBhYmFzZS9hdXRoLWpzOiBBZGRyZXNzIFwiJHthZGRyZXNzfVwiIGlzIGludmFsaWQuYCk7XG4gICAgfVxuICAgIHJldHVybiBhZGRyZXNzLnRvTG93ZXJDYXNlKCk7XG59XG5leHBvcnQgZnVuY3Rpb24gZnJvbUhleChoZXgpIHtcbiAgICByZXR1cm4gcGFyc2VJbnQoaGV4LCAxNik7XG59XG5leHBvcnQgZnVuY3Rpb24gdG9IZXgodmFsdWUpIHtcbiAgICBjb25zdCBieXRlcyA9IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZSh2YWx1ZSk7XG4gICAgY29uc3QgaGV4ID0gQXJyYXkuZnJvbShieXRlcywgKGJ5dGUpID0+IGJ5dGUudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJykpLmpvaW4oJycpO1xuICAgIHJldHVybiAoJzB4JyArIGhleCk7XG59XG4vKipcbiAqIENyZWF0ZXMgRUlQLTQzNjEgZm9ybWF0dGVkIG1lc3NhZ2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTaXdlTWVzc2FnZShwYXJhbWV0ZXJzKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHsgY2hhaW5JZCwgZG9tYWluLCBleHBpcmF0aW9uVGltZSwgaXNzdWVkQXQgPSBuZXcgRGF0ZSgpLCBub25jZSwgbm90QmVmb3JlLCByZXF1ZXN0SWQsIHJlc291cmNlcywgc2NoZW1lLCB1cmksIHZlcnNpb24sIH0gPSBwYXJhbWV0ZXJzO1xuICAgIC8vIFZhbGlkYXRlIGZpZWxkc1xuICAgIHtcbiAgICAgICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKGNoYWluSWQpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBAc3VwYWJhc2UvYXV0aC1qczogSW52YWxpZCBTSVdFIG1lc3NhZ2UgZmllbGQgXCJjaGFpbklkXCIuIENoYWluIElEIG11c3QgYmUgYSBFSVAtMTU1IGNoYWluIElELiBQcm92aWRlZCB2YWx1ZTogJHtjaGFpbklkfWApO1xuICAgICAgICBpZiAoIWRvbWFpbilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQHN1cGFiYXNlL2F1dGgtanM6IEludmFsaWQgU0lXRSBtZXNzYWdlIGZpZWxkIFwiZG9tYWluXCIuIERvbWFpbiBtdXN0IGJlIHByb3ZpZGVkLmApO1xuICAgICAgICBpZiAobm9uY2UgJiYgbm9uY2UubGVuZ3RoIDwgOClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQHN1cGFiYXNlL2F1dGgtanM6IEludmFsaWQgU0lXRSBtZXNzYWdlIGZpZWxkIFwibm9uY2VcIi4gTm9uY2UgbXVzdCBiZSBhdCBsZWFzdCA4IGNoYXJhY3RlcnMuIFByb3ZpZGVkIHZhbHVlOiAke25vbmNlfWApO1xuICAgICAgICBpZiAoIXVyaSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQHN1cGFiYXNlL2F1dGgtanM6IEludmFsaWQgU0lXRSBtZXNzYWdlIGZpZWxkIFwidXJpXCIuIFVSSSBtdXN0IGJlIHByb3ZpZGVkLmApO1xuICAgICAgICBpZiAodmVyc2lvbiAhPT0gJzEnKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBAc3VwYWJhc2UvYXV0aC1qczogSW52YWxpZCBTSVdFIG1lc3NhZ2UgZmllbGQgXCJ2ZXJzaW9uXCIuIFZlcnNpb24gbXVzdCBiZSAnMScuIFByb3ZpZGVkIHZhbHVlOiAke3ZlcnNpb259YCk7XG4gICAgICAgIGlmICgoX2EgPSBwYXJhbWV0ZXJzLnN0YXRlbWVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmluY2x1ZGVzKCdcXG4nKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQHN1cGFiYXNlL2F1dGgtanM6IEludmFsaWQgU0lXRSBtZXNzYWdlIGZpZWxkIFwic3RhdGVtZW50XCIuIFN0YXRlbWVudCBtdXN0IG5vdCBpbmNsdWRlICdcXFxcbicuIFByb3ZpZGVkIHZhbHVlOiAke3BhcmFtZXRlcnMuc3RhdGVtZW50fWApO1xuICAgIH1cbiAgICAvLyBDb25zdHJ1Y3QgbWVzc2FnZVxuICAgIGNvbnN0IGFkZHJlc3MgPSBnZXRBZGRyZXNzKHBhcmFtZXRlcnMuYWRkcmVzcyk7XG4gICAgY29uc3Qgb3JpZ2luID0gc2NoZW1lID8gYCR7c2NoZW1lfTovLyR7ZG9tYWlufWAgOiBkb21haW47XG4gICAgY29uc3Qgc3RhdGVtZW50ID0gcGFyYW1ldGVycy5zdGF0ZW1lbnQgPyBgJHtwYXJhbWV0ZXJzLnN0YXRlbWVudH1cXG5gIDogJyc7XG4gICAgY29uc3QgcHJlZml4ID0gYCR7b3JpZ2lufSB3YW50cyB5b3UgdG8gc2lnbiBpbiB3aXRoIHlvdXIgRXRoZXJldW0gYWNjb3VudDpcXG4ke2FkZHJlc3N9XFxuXFxuJHtzdGF0ZW1lbnR9YDtcbiAgICBsZXQgc3VmZml4ID0gYFVSSTogJHt1cml9XFxuVmVyc2lvbjogJHt2ZXJzaW9ufVxcbkNoYWluIElEOiAke2NoYWluSWR9JHtub25jZSA/IGBcXG5Ob25jZTogJHtub25jZX1gIDogJyd9XFxuSXNzdWVkIEF0OiAke2lzc3VlZEF0LnRvSVNPU3RyaW5nKCl9YDtcbiAgICBpZiAoZXhwaXJhdGlvblRpbWUpXG4gICAgICAgIHN1ZmZpeCArPSBgXFxuRXhwaXJhdGlvbiBUaW1lOiAke2V4cGlyYXRpb25UaW1lLnRvSVNPU3RyaW5nKCl9YDtcbiAgICBpZiAobm90QmVmb3JlKVxuICAgICAgICBzdWZmaXggKz0gYFxcbk5vdCBCZWZvcmU6ICR7bm90QmVmb3JlLnRvSVNPU3RyaW5nKCl9YDtcbiAgICBpZiAocmVxdWVzdElkKVxuICAgICAgICBzdWZmaXggKz0gYFxcblJlcXVlc3QgSUQ6ICR7cmVxdWVzdElkfWA7XG4gICAgaWYgKHJlc291cmNlcykge1xuICAgICAgICBsZXQgY29udGVudCA9ICdcXG5SZXNvdXJjZXM6JztcbiAgICAgICAgZm9yIChjb25zdCByZXNvdXJjZSBvZiByZXNvdXJjZXMpIHtcbiAgICAgICAgICAgIGlmICghcmVzb3VyY2UgfHwgdHlwZW9mIHJlc291cmNlICE9PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEBzdXBhYmFzZS9hdXRoLWpzOiBJbnZhbGlkIFNJV0UgbWVzc2FnZSBmaWVsZCBcInJlc291cmNlc1wiLiBFdmVyeSByZXNvdXJjZSBtdXN0IGJlIGEgdmFsaWQgc3RyaW5nLiBQcm92aWRlZCB2YWx1ZTogJHtyZXNvdXJjZX1gKTtcbiAgICAgICAgICAgIGNvbnRlbnQgKz0gYFxcbi0gJHtyZXNvdXJjZX1gO1xuICAgICAgICB9XG4gICAgICAgIHN1ZmZpeCArPSBjb250ZW50O1xuICAgIH1cbiAgICByZXR1cm4gYCR7cHJlZml4fVxcbiR7c3VmZml4fWA7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ldGhlcmV1bS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/web3/ethereum.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/webauthn.errors.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/module/lib/webauthn.errors.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WebAuthnError: () => (/* binding */ WebAuthnError),\n/* harmony export */   WebAuthnUnknownError: () => (/* binding */ WebAuthnUnknownError),\n/* harmony export */   identifyAuthenticationError: () => (/* binding */ identifyAuthenticationError),\n/* harmony export */   identifyRegistrationError: () => (/* binding */ identifyRegistrationError),\n/* harmony export */   isWebAuthnError: () => (/* binding */ isWebAuthnError)\n/* harmony export */ });\n/* harmony import */ var _webauthn__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./webauthn */ \"(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/webauthn.js\");\n/* eslint-disable @typescript-eslint/ban-ts-comment */\n\n/**\n * A custom Error used to return a more nuanced error detailing _why_ one of the eight documented\n * errors in the spec was raised after calling `navigator.credentials.create()` or\n * `navigator.credentials.get()`:\n *\n * - `AbortError`\n * - `ConstraintError`\n * - `InvalidStateError`\n * - `NotAllowedError`\n * - `NotSupportedError`\n * - `SecurityError`\n * - `TypeError`\n * - `UnknownError`\n *\n * Error messages were determined through investigation of the spec to determine under which\n * scenarios a given error would be raised.\n */\nclass WebAuthnError extends Error {\n    constructor({ message, code, cause, name, }) {\n        var _a;\n        // @ts-ignore: help Rollup understand that `cause` is okay to set\n        super(message, { cause });\n        this.__isWebAuthnError = true;\n        this.name = (_a = name !== null && name !== void 0 ? name : (cause instanceof Error ? cause.name : undefined)) !== null && _a !== void 0 ? _a : 'Unknown Error';\n        this.code = code;\n    }\n}\n/**\n * Error class for unknown WebAuthn errors.\n * Wraps unexpected errors that don't match known WebAuthn error conditions.\n */\nclass WebAuthnUnknownError extends WebAuthnError {\n    constructor(message, originalError) {\n        super({\n            code: 'ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY',\n            cause: originalError,\n            message,\n        });\n        this.name = 'WebAuthnUnknownError';\n        this.originalError = originalError;\n    }\n}\n/**\n * Type guard to check if an error is a WebAuthnError.\n * @param {unknown} error - The error to check\n * @returns {boolean} True if the error is a WebAuthnError\n */\nfunction isWebAuthnError(error) {\n    return typeof error === 'object' && error !== null && '__isWebAuthnError' in error;\n}\n/**\n * Attempt to intuit _why_ an error was raised after calling `navigator.credentials.create()`.\n * Maps browser errors to specific WebAuthn error codes for better debugging.\n * @param {Object} params - Error identification parameters\n * @param {Error} params.error - The error thrown by the browser\n * @param {CredentialCreationOptions} params.options - The options passed to credentials.create()\n * @returns {WebAuthnError} A WebAuthnError with a specific error code\n * @see {@link https://w3c.github.io/webauthn/#sctn-createCredential W3C WebAuthn Spec - Create Credential}\n */\nfunction identifyRegistrationError({ error, options, }) {\n    var _a, _b, _c;\n    const { publicKey } = options;\n    if (!publicKey) {\n        throw Error('options was missing required publicKey property');\n    }\n    if (error.name === 'AbortError') {\n        if (options.signal instanceof AbortSignal) {\n            // https://www.w3.org/TR/webauthn-2/#sctn-createCredential (Step 16)\n            return new WebAuthnError({\n                message: 'Registration ceremony was sent an abort signal',\n                code: 'ERROR_CEREMONY_ABORTED',\n                cause: error,\n            });\n        }\n    }\n    else if (error.name === 'ConstraintError') {\n        if (((_a = publicKey.authenticatorSelection) === null || _a === void 0 ? void 0 : _a.requireResidentKey) === true) {\n            // https://www.w3.org/TR/webauthn-2/#sctn-op-make-cred (Step 4)\n            return new WebAuthnError({\n                message: 'Discoverable credentials were required but no available authenticator supported it',\n                code: 'ERROR_AUTHENTICATOR_MISSING_DISCOVERABLE_CREDENTIAL_SUPPORT',\n                cause: error,\n            });\n        }\n        else if (\n        // @ts-ignore: `mediation` doesn't yet exist on CredentialCreationOptions but it's possible as of Sept 2024\n        options.mediation === 'conditional' &&\n            ((_b = publicKey.authenticatorSelection) === null || _b === void 0 ? void 0 : _b.userVerification) === 'required') {\n            // https://w3c.github.io/webauthn/#sctn-createCredential (Step 22.4)\n            return new WebAuthnError({\n                message: 'User verification was required during automatic registration but it could not be performed',\n                code: 'ERROR_AUTO_REGISTER_USER_VERIFICATION_FAILURE',\n                cause: error,\n            });\n        }\n        else if (((_c = publicKey.authenticatorSelection) === null || _c === void 0 ? void 0 : _c.userVerification) === 'required') {\n            // https://www.w3.org/TR/webauthn-2/#sctn-op-make-cred (Step 5)\n            return new WebAuthnError({\n                message: 'User verification was required but no available authenticator supported it',\n                code: 'ERROR_AUTHENTICATOR_MISSING_USER_VERIFICATION_SUPPORT',\n                cause: error,\n            });\n        }\n    }\n    else if (error.name === 'InvalidStateError') {\n        // https://www.w3.org/TR/webauthn-2/#sctn-createCredential (Step 20)\n        // https://www.w3.org/TR/webauthn-2/#sctn-op-make-cred (Step 3)\n        return new WebAuthnError({\n            message: 'The authenticator was previously registered',\n            code: 'ERROR_AUTHENTICATOR_PREVIOUSLY_REGISTERED',\n            cause: error,\n        });\n    }\n    else if (error.name === 'NotAllowedError') {\n        /**\n         * Pass the error directly through. Platforms are overloading this error beyond what the spec\n         * defines and we don't want to overwrite potentially useful error messages.\n         */\n        return new WebAuthnError({\n            message: error.message,\n            code: 'ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY',\n            cause: error,\n        });\n    }\n    else if (error.name === 'NotSupportedError') {\n        const validPubKeyCredParams = publicKey.pubKeyCredParams.filter((param) => param.type === 'public-key');\n        if (validPubKeyCredParams.length === 0) {\n            // https://www.w3.org/TR/webauthn-2/#sctn-createCredential (Step 10)\n            return new WebAuthnError({\n                message: 'No entry in pubKeyCredParams was of type \"public-key\"',\n                code: 'ERROR_MALFORMED_PUBKEYCREDPARAMS',\n                cause: error,\n            });\n        }\n        // https://www.w3.org/TR/webauthn-2/#sctn-op-make-cred (Step 2)\n        return new WebAuthnError({\n            message: 'No available authenticator supported any of the specified pubKeyCredParams algorithms',\n            code: 'ERROR_AUTHENTICATOR_NO_SUPPORTED_PUBKEYCREDPARAMS_ALG',\n            cause: error,\n        });\n    }\n    else if (error.name === 'SecurityError') {\n        const effectiveDomain = window.location.hostname;\n        if (!(0,_webauthn__WEBPACK_IMPORTED_MODULE_0__.isValidDomain)(effectiveDomain)) {\n            // https://www.w3.org/TR/webauthn-2/#sctn-createCredential (Step 7)\n            return new WebAuthnError({\n                message: `${window.location.hostname} is an invalid domain`,\n                code: 'ERROR_INVALID_DOMAIN',\n                cause: error,\n            });\n        }\n        else if (publicKey.rp.id !== effectiveDomain) {\n            // https://www.w3.org/TR/webauthn-2/#sctn-createCredential (Step 8)\n            return new WebAuthnError({\n                message: `The RP ID \"${publicKey.rp.id}\" is invalid for this domain`,\n                code: 'ERROR_INVALID_RP_ID',\n                cause: error,\n            });\n        }\n    }\n    else if (error.name === 'TypeError') {\n        if (publicKey.user.id.byteLength < 1 || publicKey.user.id.byteLength > 64) {\n            // https://www.w3.org/TR/webauthn-2/#sctn-createCredential (Step 5)\n            return new WebAuthnError({\n                message: 'User ID was not between 1 and 64 characters',\n                code: 'ERROR_INVALID_USER_ID_LENGTH',\n                cause: error,\n            });\n        }\n    }\n    else if (error.name === 'UnknownError') {\n        // https://www.w3.org/TR/webauthn-2/#sctn-op-make-cred (Step 1)\n        // https://www.w3.org/TR/webauthn-2/#sctn-op-make-cred (Step 8)\n        return new WebAuthnError({\n            message: 'The authenticator was unable to process the specified options, or could not create a new credential',\n            code: 'ERROR_AUTHENTICATOR_GENERAL_ERROR',\n            cause: error,\n        });\n    }\n    return new WebAuthnError({\n        message: 'a Non-Webauthn related error has occurred',\n        code: 'ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY',\n        cause: error,\n    });\n}\n/**\n * Attempt to intuit _why_ an error was raised after calling `navigator.credentials.get()`.\n * Maps browser errors to specific WebAuthn error codes for better debugging.\n * @param {Object} params - Error identification parameters\n * @param {Error} params.error - The error thrown by the browser\n * @param {CredentialRequestOptions} params.options - The options passed to credentials.get()\n * @returns {WebAuthnError} A WebAuthnError with a specific error code\n * @see {@link https://w3c.github.io/webauthn/#sctn-getAssertion W3C WebAuthn Spec - Get Assertion}\n */\nfunction identifyAuthenticationError({ error, options, }) {\n    const { publicKey } = options;\n    if (!publicKey) {\n        throw Error('options was missing required publicKey property');\n    }\n    if (error.name === 'AbortError') {\n        if (options.signal instanceof AbortSignal) {\n            // https://www.w3.org/TR/webauthn-2/#sctn-createCredential (Step 16)\n            return new WebAuthnError({\n                message: 'Authentication ceremony was sent an abort signal',\n                code: 'ERROR_CEREMONY_ABORTED',\n                cause: error,\n            });\n        }\n    }\n    else if (error.name === 'NotAllowedError') {\n        /**\n         * Pass the error directly through. Platforms are overloading this error beyond what the spec\n         * defines and we don't want to overwrite potentially useful error messages.\n         */\n        return new WebAuthnError({\n            message: error.message,\n            code: 'ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY',\n            cause: error,\n        });\n    }\n    else if (error.name === 'SecurityError') {\n        const effectiveDomain = window.location.hostname;\n        if (!(0,_webauthn__WEBPACK_IMPORTED_MODULE_0__.isValidDomain)(effectiveDomain)) {\n            // https://www.w3.org/TR/webauthn-2/#sctn-discover-from-external-source (Step 5)\n            return new WebAuthnError({\n                message: `${window.location.hostname} is an invalid domain`,\n                code: 'ERROR_INVALID_DOMAIN',\n                cause: error,\n            });\n        }\n        else if (publicKey.rpId !== effectiveDomain) {\n            // https://www.w3.org/TR/webauthn-2/#sctn-discover-from-external-source (Step 6)\n            return new WebAuthnError({\n                message: `The RP ID \"${publicKey.rpId}\" is invalid for this domain`,\n                code: 'ERROR_INVALID_RP_ID',\n                cause: error,\n            });\n        }\n    }\n    else if (error.name === 'UnknownError') {\n        // https://www.w3.org/TR/webauthn-2/#sctn-op-get-assertion (Step 1)\n        // https://www.w3.org/TR/webauthn-2/#sctn-op-get-assertion (Step 12)\n        return new WebAuthnError({\n            message: 'The authenticator was unable to process the specified options, or could not create a new assertion signature',\n            code: 'ERROR_AUTHENTICATOR_GENERAL_ERROR',\n            cause: error,\n        });\n    }\n    return new WebAuthnError({\n        message: 'a Non-Webauthn related error has occurred',\n        code: 'ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY',\n        cause: error,\n    });\n}\n//# sourceMappingURL=webauthn.errors.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvYXV0aC1qcy9kaXN0L21vZHVsZS9saWIvd2ViYXV0aG4uZXJyb3JzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQzJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLGtCQUFrQiw2QkFBNkI7QUFDL0M7QUFDQTtBQUNBLHlCQUF5QixPQUFPO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsYUFBYSxTQUFTO0FBQ3RCO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsT0FBTztBQUNsQixXQUFXLDJCQUEyQjtBQUN0QyxhQUFhLGVBQWU7QUFDNUIsU0FBUztBQUNUO0FBQ08scUNBQXFDLGlCQUFpQjtBQUM3RDtBQUNBLFlBQVksWUFBWTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsYUFBYSx3REFBYTtBQUMxQjtBQUNBO0FBQ0EsNEJBQTRCLDBCQUEwQjtBQUN0RDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGdCQUFnQjtBQUN2RDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLE9BQU87QUFDbEIsV0FBVywwQkFBMEI7QUFDckMsYUFBYSxlQUFlO0FBQzVCLFNBQVM7QUFDVDtBQUNPLHVDQUF1QyxpQkFBaUI7QUFDL0QsWUFBWSxZQUFZO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsYUFBYSx3REFBYTtBQUMxQjtBQUNBO0FBQ0EsNEJBQTRCLDBCQUEwQjtBQUN0RDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGVBQWU7QUFDdEQ7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBIiwic291cmNlcyI6WyJEOlxcbmV4dFxcb3JnXFxub2RlX21vZHVsZXNcXEBzdXBhYmFzZVxcYXV0aC1qc1xcZGlzdFxcbW9kdWxlXFxsaWJcXHdlYmF1dGhuLmVycm9ycy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnQgKi9cbmltcG9ydCB7IGlzVmFsaWREb21haW4gfSBmcm9tICcuL3dlYmF1dGhuJztcbi8qKlxuICogQSBjdXN0b20gRXJyb3IgdXNlZCB0byByZXR1cm4gYSBtb3JlIG51YW5jZWQgZXJyb3IgZGV0YWlsaW5nIF93aHlfIG9uZSBvZiB0aGUgZWlnaHQgZG9jdW1lbnRlZFxuICogZXJyb3JzIGluIHRoZSBzcGVjIHdhcyByYWlzZWQgYWZ0ZXIgY2FsbGluZyBgbmF2aWdhdG9yLmNyZWRlbnRpYWxzLmNyZWF0ZSgpYCBvclxuICogYG5hdmlnYXRvci5jcmVkZW50aWFscy5nZXQoKWA6XG4gKlxuICogLSBgQWJvcnRFcnJvcmBcbiAqIC0gYENvbnN0cmFpbnRFcnJvcmBcbiAqIC0gYEludmFsaWRTdGF0ZUVycm9yYFxuICogLSBgTm90QWxsb3dlZEVycm9yYFxuICogLSBgTm90U3VwcG9ydGVkRXJyb3JgXG4gKiAtIGBTZWN1cml0eUVycm9yYFxuICogLSBgVHlwZUVycm9yYFxuICogLSBgVW5rbm93bkVycm9yYFxuICpcbiAqIEVycm9yIG1lc3NhZ2VzIHdlcmUgZGV0ZXJtaW5lZCB0aHJvdWdoIGludmVzdGlnYXRpb24gb2YgdGhlIHNwZWMgdG8gZGV0ZXJtaW5lIHVuZGVyIHdoaWNoXG4gKiBzY2VuYXJpb3MgYSBnaXZlbiBlcnJvciB3b3VsZCBiZSByYWlzZWQuXG4gKi9cbmV4cG9ydCBjbGFzcyBXZWJBdXRobkVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgbWVzc2FnZSwgY29kZSwgY2F1c2UsIG5hbWUsIH0pIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAvLyBAdHMtaWdub3JlOiBoZWxwIFJvbGx1cCB1bmRlcnN0YW5kIHRoYXQgYGNhdXNlYCBpcyBva2F5IHRvIHNldFxuICAgICAgICBzdXBlcihtZXNzYWdlLCB7IGNhdXNlIH0pO1xuICAgICAgICB0aGlzLl9faXNXZWJBdXRobkVycm9yID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5uYW1lID0gKF9hID0gbmFtZSAhPT0gbnVsbCAmJiBuYW1lICE9PSB2b2lkIDAgPyBuYW1lIDogKGNhdXNlIGluc3RhbmNlb2YgRXJyb3IgPyBjYXVzZS5uYW1lIDogdW5kZWZpbmVkKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJ1Vua25vd24gRXJyb3InO1xuICAgICAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICAgIH1cbn1cbi8qKlxuICogRXJyb3IgY2xhc3MgZm9yIHVua25vd24gV2ViQXV0aG4gZXJyb3JzLlxuICogV3JhcHMgdW5leHBlY3RlZCBlcnJvcnMgdGhhdCBkb24ndCBtYXRjaCBrbm93biBXZWJBdXRobiBlcnJvciBjb25kaXRpb25zLlxuICovXG5leHBvcnQgY2xhc3MgV2ViQXV0aG5Vbmtub3duRXJyb3IgZXh0ZW5kcyBXZWJBdXRobkVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBvcmlnaW5hbEVycm9yKSB7XG4gICAgICAgIHN1cGVyKHtcbiAgICAgICAgICAgIGNvZGU6ICdFUlJPUl9QQVNTVEhST1VHSF9TRUVfQ0FVU0VfUFJPUEVSVFknLFxuICAgICAgICAgICAgY2F1c2U6IG9yaWdpbmFsRXJyb3IsXG4gICAgICAgICAgICBtZXNzYWdlLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ1dlYkF1dGhuVW5rbm93bkVycm9yJztcbiAgICAgICAgdGhpcy5vcmlnaW5hbEVycm9yID0gb3JpZ2luYWxFcnJvcjtcbiAgICB9XG59XG4vKipcbiAqIFR5cGUgZ3VhcmQgdG8gY2hlY2sgaWYgYW4gZXJyb3IgaXMgYSBXZWJBdXRobkVycm9yLlxuICogQHBhcmFtIHt1bmtub3dufSBlcnJvciAtIFRoZSBlcnJvciB0byBjaGVja1xuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIGVycm9yIGlzIGEgV2ViQXV0aG5FcnJvclxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNXZWJBdXRobkVycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBlcnJvciA9PT0gJ29iamVjdCcgJiYgZXJyb3IgIT09IG51bGwgJiYgJ19faXNXZWJBdXRobkVycm9yJyBpbiBlcnJvcjtcbn1cbi8qKlxuICogQXR0ZW1wdCB0byBpbnR1aXQgX3doeV8gYW4gZXJyb3Igd2FzIHJhaXNlZCBhZnRlciBjYWxsaW5nIGBuYXZpZ2F0b3IuY3JlZGVudGlhbHMuY3JlYXRlKClgLlxuICogTWFwcyBicm93c2VyIGVycm9ycyB0byBzcGVjaWZpYyBXZWJBdXRobiBlcnJvciBjb2RlcyBmb3IgYmV0dGVyIGRlYnVnZ2luZy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgLSBFcnJvciBpZGVudGlmaWNhdGlvbiBwYXJhbWV0ZXJzXG4gKiBAcGFyYW0ge0Vycm9yfSBwYXJhbXMuZXJyb3IgLSBUaGUgZXJyb3IgdGhyb3duIGJ5IHRoZSBicm93c2VyXG4gKiBAcGFyYW0ge0NyZWRlbnRpYWxDcmVhdGlvbk9wdGlvbnN9IHBhcmFtcy5vcHRpb25zIC0gVGhlIG9wdGlvbnMgcGFzc2VkIHRvIGNyZWRlbnRpYWxzLmNyZWF0ZSgpXG4gKiBAcmV0dXJucyB7V2ViQXV0aG5FcnJvcn0gQSBXZWJBdXRobkVycm9yIHdpdGggYSBzcGVjaWZpYyBlcnJvciBjb2RlXG4gKiBAc2VlIHtAbGluayBodHRwczovL3czYy5naXRodWIuaW8vd2ViYXV0aG4vI3NjdG4tY3JlYXRlQ3JlZGVudGlhbCBXM0MgV2ViQXV0aG4gU3BlYyAtIENyZWF0ZSBDcmVkZW50aWFsfVxuICovXG5leHBvcnQgZnVuY3Rpb24gaWRlbnRpZnlSZWdpc3RyYXRpb25FcnJvcih7IGVycm9yLCBvcHRpb25zLCB9KSB7XG4gICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgY29uc3QgeyBwdWJsaWNLZXkgfSA9IG9wdGlvbnM7XG4gICAgaWYgKCFwdWJsaWNLZXkpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ29wdGlvbnMgd2FzIG1pc3NpbmcgcmVxdWlyZWQgcHVibGljS2V5IHByb3BlcnR5Jyk7XG4gICAgfVxuICAgIGlmIChlcnJvci5uYW1lID09PSAnQWJvcnRFcnJvcicpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuc2lnbmFsIGluc3RhbmNlb2YgQWJvcnRTaWduYWwpIHtcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi93ZWJhdXRobi0yLyNzY3RuLWNyZWF0ZUNyZWRlbnRpYWwgKFN0ZXAgMTYpXG4gICAgICAgICAgICByZXR1cm4gbmV3IFdlYkF1dGhuRXJyb3Ioe1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdSZWdpc3RyYXRpb24gY2VyZW1vbnkgd2FzIHNlbnQgYW4gYWJvcnQgc2lnbmFsJyxcbiAgICAgICAgICAgICAgICBjb2RlOiAnRVJST1JfQ0VSRU1PTllfQUJPUlRFRCcsXG4gICAgICAgICAgICAgICAgY2F1c2U6IGVycm9yLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoZXJyb3IubmFtZSA9PT0gJ0NvbnN0cmFpbnRFcnJvcicpIHtcbiAgICAgICAgaWYgKCgoX2EgPSBwdWJsaWNLZXkuYXV0aGVudGljYXRvclNlbGVjdGlvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlcXVpcmVSZXNpZGVudEtleSkgPT09IHRydWUpIHtcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi93ZWJhdXRobi0yLyNzY3RuLW9wLW1ha2UtY3JlZCAoU3RlcCA0KVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBXZWJBdXRobkVycm9yKHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiAnRGlzY292ZXJhYmxlIGNyZWRlbnRpYWxzIHdlcmUgcmVxdWlyZWQgYnV0IG5vIGF2YWlsYWJsZSBhdXRoZW50aWNhdG9yIHN1cHBvcnRlZCBpdCcsXG4gICAgICAgICAgICAgICAgY29kZTogJ0VSUk9SX0FVVEhFTlRJQ0FUT1JfTUlTU0lOR19ESVNDT1ZFUkFCTEVfQ1JFREVOVElBTF9TVVBQT1JUJyxcbiAgICAgICAgICAgICAgICBjYXVzZTogZXJyb3IsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChcbiAgICAgICAgLy8gQHRzLWlnbm9yZTogYG1lZGlhdGlvbmAgZG9lc24ndCB5ZXQgZXhpc3Qgb24gQ3JlZGVudGlhbENyZWF0aW9uT3B0aW9ucyBidXQgaXQncyBwb3NzaWJsZSBhcyBvZiBTZXB0IDIwMjRcbiAgICAgICAgb3B0aW9ucy5tZWRpYXRpb24gPT09ICdjb25kaXRpb25hbCcgJiZcbiAgICAgICAgICAgICgoX2IgPSBwdWJsaWNLZXkuYXV0aGVudGljYXRvclNlbGVjdGlvbikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnVzZXJWZXJpZmljYXRpb24pID09PSAncmVxdWlyZWQnKSB7XG4gICAgICAgICAgICAvLyBodHRwczovL3czYy5naXRodWIuaW8vd2ViYXV0aG4vI3NjdG4tY3JlYXRlQ3JlZGVudGlhbCAoU3RlcCAyMi40KVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBXZWJBdXRobkVycm9yKHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiAnVXNlciB2ZXJpZmljYXRpb24gd2FzIHJlcXVpcmVkIGR1cmluZyBhdXRvbWF0aWMgcmVnaXN0cmF0aW9uIGJ1dCBpdCBjb3VsZCBub3QgYmUgcGVyZm9ybWVkJyxcbiAgICAgICAgICAgICAgICBjb2RlOiAnRVJST1JfQVVUT19SRUdJU1RFUl9VU0VSX1ZFUklGSUNBVElPTl9GQUlMVVJFJyxcbiAgICAgICAgICAgICAgICBjYXVzZTogZXJyb3IsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoKF9jID0gcHVibGljS2V5LmF1dGhlbnRpY2F0b3JTZWxlY3Rpb24pID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy51c2VyVmVyaWZpY2F0aW9uKSA9PT0gJ3JlcXVpcmVkJykge1xuICAgICAgICAgICAgLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL3dlYmF1dGhuLTIvI3NjdG4tb3AtbWFrZS1jcmVkIChTdGVwIDUpXG4gICAgICAgICAgICByZXR1cm4gbmV3IFdlYkF1dGhuRXJyb3Ioe1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdVc2VyIHZlcmlmaWNhdGlvbiB3YXMgcmVxdWlyZWQgYnV0IG5vIGF2YWlsYWJsZSBhdXRoZW50aWNhdG9yIHN1cHBvcnRlZCBpdCcsXG4gICAgICAgICAgICAgICAgY29kZTogJ0VSUk9SX0FVVEhFTlRJQ0FUT1JfTUlTU0lOR19VU0VSX1ZFUklGSUNBVElPTl9TVVBQT1JUJyxcbiAgICAgICAgICAgICAgICBjYXVzZTogZXJyb3IsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChlcnJvci5uYW1lID09PSAnSW52YWxpZFN0YXRlRXJyb3InKSB7XG4gICAgICAgIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi93ZWJhdXRobi0yLyNzY3RuLWNyZWF0ZUNyZWRlbnRpYWwgKFN0ZXAgMjApXG4gICAgICAgIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi93ZWJhdXRobi0yLyNzY3RuLW9wLW1ha2UtY3JlZCAoU3RlcCAzKVxuICAgICAgICByZXR1cm4gbmV3IFdlYkF1dGhuRXJyb3Ioe1xuICAgICAgICAgICAgbWVzc2FnZTogJ1RoZSBhdXRoZW50aWNhdG9yIHdhcyBwcmV2aW91c2x5IHJlZ2lzdGVyZWQnLFxuICAgICAgICAgICAgY29kZTogJ0VSUk9SX0FVVEhFTlRJQ0FUT1JfUFJFVklPVVNMWV9SRUdJU1RFUkVEJyxcbiAgICAgICAgICAgIGNhdXNlOiBlcnJvcixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGVycm9yLm5hbWUgPT09ICdOb3RBbGxvd2VkRXJyb3InKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQYXNzIHRoZSBlcnJvciBkaXJlY3RseSB0aHJvdWdoLiBQbGF0Zm9ybXMgYXJlIG92ZXJsb2FkaW5nIHRoaXMgZXJyb3IgYmV5b25kIHdoYXQgdGhlIHNwZWNcbiAgICAgICAgICogZGVmaW5lcyBhbmQgd2UgZG9uJ3Qgd2FudCB0byBvdmVyd3JpdGUgcG90ZW50aWFsbHkgdXNlZnVsIGVycm9yIG1lc3NhZ2VzLlxuICAgICAgICAgKi9cbiAgICAgICAgcmV0dXJuIG5ldyBXZWJBdXRobkVycm9yKHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2UsXG4gICAgICAgICAgICBjb2RlOiAnRVJST1JfUEFTU1RIUk9VR0hfU0VFX0NBVVNFX1BST1BFUlRZJyxcbiAgICAgICAgICAgIGNhdXNlOiBlcnJvcixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGVycm9yLm5hbWUgPT09ICdOb3RTdXBwb3J0ZWRFcnJvcicpIHtcbiAgICAgICAgY29uc3QgdmFsaWRQdWJLZXlDcmVkUGFyYW1zID0gcHVibGljS2V5LnB1YktleUNyZWRQYXJhbXMuZmlsdGVyKChwYXJhbSkgPT4gcGFyYW0udHlwZSA9PT0gJ3B1YmxpYy1rZXknKTtcbiAgICAgICAgaWYgKHZhbGlkUHViS2V5Q3JlZFBhcmFtcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi93ZWJhdXRobi0yLyNzY3RuLWNyZWF0ZUNyZWRlbnRpYWwgKFN0ZXAgMTApXG4gICAgICAgICAgICByZXR1cm4gbmV3IFdlYkF1dGhuRXJyb3Ioe1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdObyBlbnRyeSBpbiBwdWJLZXlDcmVkUGFyYW1zIHdhcyBvZiB0eXBlIFwicHVibGljLWtleVwiJyxcbiAgICAgICAgICAgICAgICBjb2RlOiAnRVJST1JfTUFMRk9STUVEX1BVQktFWUNSRURQQVJBTVMnLFxuICAgICAgICAgICAgICAgIGNhdXNlOiBlcnJvcixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi93ZWJhdXRobi0yLyNzY3RuLW9wLW1ha2UtY3JlZCAoU3RlcCAyKVxuICAgICAgICByZXR1cm4gbmV3IFdlYkF1dGhuRXJyb3Ioe1xuICAgICAgICAgICAgbWVzc2FnZTogJ05vIGF2YWlsYWJsZSBhdXRoZW50aWNhdG9yIHN1cHBvcnRlZCBhbnkgb2YgdGhlIHNwZWNpZmllZCBwdWJLZXlDcmVkUGFyYW1zIGFsZ29yaXRobXMnLFxuICAgICAgICAgICAgY29kZTogJ0VSUk9SX0FVVEhFTlRJQ0FUT1JfTk9fU1VQUE9SVEVEX1BVQktFWUNSRURQQVJBTVNfQUxHJyxcbiAgICAgICAgICAgIGNhdXNlOiBlcnJvcixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGVycm9yLm5hbWUgPT09ICdTZWN1cml0eUVycm9yJykge1xuICAgICAgICBjb25zdCBlZmZlY3RpdmVEb21haW4gPSB3aW5kb3cubG9jYXRpb24uaG9zdG5hbWU7XG4gICAgICAgIGlmICghaXNWYWxpZERvbWFpbihlZmZlY3RpdmVEb21haW4pKSB7XG4gICAgICAgICAgICAvLyBodHRwczovL3d3dy53My5vcmcvVFIvd2ViYXV0aG4tMi8jc2N0bi1jcmVhdGVDcmVkZW50aWFsIChTdGVwIDcpXG4gICAgICAgICAgICByZXR1cm4gbmV3IFdlYkF1dGhuRXJyb3Ioe1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGAke3dpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZX0gaXMgYW4gaW52YWxpZCBkb21haW5gLFxuICAgICAgICAgICAgICAgIGNvZGU6ICdFUlJPUl9JTlZBTElEX0RPTUFJTicsXG4gICAgICAgICAgICAgICAgY2F1c2U6IGVycm9yLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHVibGljS2V5LnJwLmlkICE9PSBlZmZlY3RpdmVEb21haW4pIHtcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi93ZWJhdXRobi0yLyNzY3RuLWNyZWF0ZUNyZWRlbnRpYWwgKFN0ZXAgOClcbiAgICAgICAgICAgIHJldHVybiBuZXcgV2ViQXV0aG5FcnJvcih7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogYFRoZSBSUCBJRCBcIiR7cHVibGljS2V5LnJwLmlkfVwiIGlzIGludmFsaWQgZm9yIHRoaXMgZG9tYWluYCxcbiAgICAgICAgICAgICAgICBjb2RlOiAnRVJST1JfSU5WQUxJRF9SUF9JRCcsXG4gICAgICAgICAgICAgICAgY2F1c2U6IGVycm9yLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoZXJyb3IubmFtZSA9PT0gJ1R5cGVFcnJvcicpIHtcbiAgICAgICAgaWYgKHB1YmxpY0tleS51c2VyLmlkLmJ5dGVMZW5ndGggPCAxIHx8IHB1YmxpY0tleS51c2VyLmlkLmJ5dGVMZW5ndGggPiA2NCkge1xuICAgICAgICAgICAgLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL3dlYmF1dGhuLTIvI3NjdG4tY3JlYXRlQ3JlZGVudGlhbCAoU3RlcCA1KVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBXZWJBdXRobkVycm9yKHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiAnVXNlciBJRCB3YXMgbm90IGJldHdlZW4gMSBhbmQgNjQgY2hhcmFjdGVycycsXG4gICAgICAgICAgICAgICAgY29kZTogJ0VSUk9SX0lOVkFMSURfVVNFUl9JRF9MRU5HVEgnLFxuICAgICAgICAgICAgICAgIGNhdXNlOiBlcnJvcixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGVycm9yLm5hbWUgPT09ICdVbmtub3duRXJyb3InKSB7XG4gICAgICAgIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi93ZWJhdXRobi0yLyNzY3RuLW9wLW1ha2UtY3JlZCAoU3RlcCAxKVxuICAgICAgICAvLyBodHRwczovL3d3dy53My5vcmcvVFIvd2ViYXV0aG4tMi8jc2N0bi1vcC1tYWtlLWNyZWQgKFN0ZXAgOClcbiAgICAgICAgcmV0dXJuIG5ldyBXZWJBdXRobkVycm9yKHtcbiAgICAgICAgICAgIG1lc3NhZ2U6ICdUaGUgYXV0aGVudGljYXRvciB3YXMgdW5hYmxlIHRvIHByb2Nlc3MgdGhlIHNwZWNpZmllZCBvcHRpb25zLCBvciBjb3VsZCBub3QgY3JlYXRlIGEgbmV3IGNyZWRlbnRpYWwnLFxuICAgICAgICAgICAgY29kZTogJ0VSUk9SX0FVVEhFTlRJQ0FUT1JfR0VORVJBTF9FUlJPUicsXG4gICAgICAgICAgICBjYXVzZTogZXJyb3IsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFdlYkF1dGhuRXJyb3Ioe1xuICAgICAgICBtZXNzYWdlOiAnYSBOb24tV2ViYXV0aG4gcmVsYXRlZCBlcnJvciBoYXMgb2NjdXJyZWQnLFxuICAgICAgICBjb2RlOiAnRVJST1JfUEFTU1RIUk9VR0hfU0VFX0NBVVNFX1BST1BFUlRZJyxcbiAgICAgICAgY2F1c2U6IGVycm9yLFxuICAgIH0pO1xufVxuLyoqXG4gKiBBdHRlbXB0IHRvIGludHVpdCBfd2h5XyBhbiBlcnJvciB3YXMgcmFpc2VkIGFmdGVyIGNhbGxpbmcgYG5hdmlnYXRvci5jcmVkZW50aWFscy5nZXQoKWAuXG4gKiBNYXBzIGJyb3dzZXIgZXJyb3JzIHRvIHNwZWNpZmljIFdlYkF1dGhuIGVycm9yIGNvZGVzIGZvciBiZXR0ZXIgZGVidWdnaW5nLlxuICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyAtIEVycm9yIGlkZW50aWZpY2F0aW9uIHBhcmFtZXRlcnNcbiAqIEBwYXJhbSB7RXJyb3J9IHBhcmFtcy5lcnJvciAtIFRoZSBlcnJvciB0aHJvd24gYnkgdGhlIGJyb3dzZXJcbiAqIEBwYXJhbSB7Q3JlZGVudGlhbFJlcXVlc3RPcHRpb25zfSBwYXJhbXMub3B0aW9ucyAtIFRoZSBvcHRpb25zIHBhc3NlZCB0byBjcmVkZW50aWFscy5nZXQoKVxuICogQHJldHVybnMge1dlYkF1dGhuRXJyb3J9IEEgV2ViQXV0aG5FcnJvciB3aXRoIGEgc3BlY2lmaWMgZXJyb3IgY29kZVxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmF1dGhuLyNzY3RuLWdldEFzc2VydGlvbiBXM0MgV2ViQXV0aG4gU3BlYyAtIEdldCBBc3NlcnRpb259XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpZGVudGlmeUF1dGhlbnRpY2F0aW9uRXJyb3IoeyBlcnJvciwgb3B0aW9ucywgfSkge1xuICAgIGNvbnN0IHsgcHVibGljS2V5IH0gPSBvcHRpb25zO1xuICAgIGlmICghcHVibGljS2V5KSB7XG4gICAgICAgIHRocm93IEVycm9yKCdvcHRpb25zIHdhcyBtaXNzaW5nIHJlcXVpcmVkIHB1YmxpY0tleSBwcm9wZXJ0eScpO1xuICAgIH1cbiAgICBpZiAoZXJyb3IubmFtZSA9PT0gJ0Fib3J0RXJyb3InKSB7XG4gICAgICAgIGlmIChvcHRpb25zLnNpZ25hbCBpbnN0YW5jZW9mIEFib3J0U2lnbmFsKSB7XG4gICAgICAgICAgICAvLyBodHRwczovL3d3dy53My5vcmcvVFIvd2ViYXV0aG4tMi8jc2N0bi1jcmVhdGVDcmVkZW50aWFsIChTdGVwIDE2KVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBXZWJBdXRobkVycm9yKHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiAnQXV0aGVudGljYXRpb24gY2VyZW1vbnkgd2FzIHNlbnQgYW4gYWJvcnQgc2lnbmFsJyxcbiAgICAgICAgICAgICAgICBjb2RlOiAnRVJST1JfQ0VSRU1PTllfQUJPUlRFRCcsXG4gICAgICAgICAgICAgICAgY2F1c2U6IGVycm9yLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoZXJyb3IubmFtZSA9PT0gJ05vdEFsbG93ZWRFcnJvcicpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBhc3MgdGhlIGVycm9yIGRpcmVjdGx5IHRocm91Z2guIFBsYXRmb3JtcyBhcmUgb3ZlcmxvYWRpbmcgdGhpcyBlcnJvciBiZXlvbmQgd2hhdCB0aGUgc3BlY1xuICAgICAgICAgKiBkZWZpbmVzIGFuZCB3ZSBkb24ndCB3YW50IHRvIG92ZXJ3cml0ZSBwb3RlbnRpYWxseSB1c2VmdWwgZXJyb3IgbWVzc2FnZXMuXG4gICAgICAgICAqL1xuICAgICAgICByZXR1cm4gbmV3IFdlYkF1dGhuRXJyb3Ioe1xuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3IubWVzc2FnZSxcbiAgICAgICAgICAgIGNvZGU6ICdFUlJPUl9QQVNTVEhST1VHSF9TRUVfQ0FVU0VfUFJPUEVSVFknLFxuICAgICAgICAgICAgY2F1c2U6IGVycm9yLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZXJyb3IubmFtZSA9PT0gJ1NlY3VyaXR5RXJyb3InKSB7XG4gICAgICAgIGNvbnN0IGVmZmVjdGl2ZURvbWFpbiA9IHdpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZTtcbiAgICAgICAgaWYgKCFpc1ZhbGlkRG9tYWluKGVmZmVjdGl2ZURvbWFpbikpIHtcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi93ZWJhdXRobi0yLyNzY3RuLWRpc2NvdmVyLWZyb20tZXh0ZXJuYWwtc291cmNlIChTdGVwIDUpXG4gICAgICAgICAgICByZXR1cm4gbmV3IFdlYkF1dGhuRXJyb3Ioe1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGAke3dpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZX0gaXMgYW4gaW52YWxpZCBkb21haW5gLFxuICAgICAgICAgICAgICAgIGNvZGU6ICdFUlJPUl9JTlZBTElEX0RPTUFJTicsXG4gICAgICAgICAgICAgICAgY2F1c2U6IGVycm9yLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHVibGljS2V5LnJwSWQgIT09IGVmZmVjdGl2ZURvbWFpbikge1xuICAgICAgICAgICAgLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL3dlYmF1dGhuLTIvI3NjdG4tZGlzY292ZXItZnJvbS1leHRlcm5hbC1zb3VyY2UgKFN0ZXAgNilcbiAgICAgICAgICAgIHJldHVybiBuZXcgV2ViQXV0aG5FcnJvcih7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogYFRoZSBSUCBJRCBcIiR7cHVibGljS2V5LnJwSWR9XCIgaXMgaW52YWxpZCBmb3IgdGhpcyBkb21haW5gLFxuICAgICAgICAgICAgICAgIGNvZGU6ICdFUlJPUl9JTlZBTElEX1JQX0lEJyxcbiAgICAgICAgICAgICAgICBjYXVzZTogZXJyb3IsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChlcnJvci5uYW1lID09PSAnVW5rbm93bkVycm9yJykge1xuICAgICAgICAvLyBodHRwczovL3d3dy53My5vcmcvVFIvd2ViYXV0aG4tMi8jc2N0bi1vcC1nZXQtYXNzZXJ0aW9uIChTdGVwIDEpXG4gICAgICAgIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi93ZWJhdXRobi0yLyNzY3RuLW9wLWdldC1hc3NlcnRpb24gKFN0ZXAgMTIpXG4gICAgICAgIHJldHVybiBuZXcgV2ViQXV0aG5FcnJvcih7XG4gICAgICAgICAgICBtZXNzYWdlOiAnVGhlIGF1dGhlbnRpY2F0b3Igd2FzIHVuYWJsZSB0byBwcm9jZXNzIHRoZSBzcGVjaWZpZWQgb3B0aW9ucywgb3IgY291bGQgbm90IGNyZWF0ZSBhIG5ldyBhc3NlcnRpb24gc2lnbmF0dXJlJyxcbiAgICAgICAgICAgIGNvZGU6ICdFUlJPUl9BVVRIRU5USUNBVE9SX0dFTkVSQUxfRVJST1InLFxuICAgICAgICAgICAgY2F1c2U6IGVycm9yLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBXZWJBdXRobkVycm9yKHtcbiAgICAgICAgbWVzc2FnZTogJ2EgTm9uLVdlYmF1dGhuIHJlbGF0ZWQgZXJyb3IgaGFzIG9jY3VycmVkJyxcbiAgICAgICAgY29kZTogJ0VSUk9SX1BBU1NUSFJPVUdIX1NFRV9DQVVTRV9QUk9QRVJUWScsXG4gICAgICAgIGNhdXNlOiBlcnJvcixcbiAgICB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdlYmF1dGhuLmVycm9ycy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/webauthn.errors.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/webauthn.js":
/*!********************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/module/lib/webauthn.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEFAULT_CREATION_OPTIONS: () => (/* binding */ DEFAULT_CREATION_OPTIONS),\n/* harmony export */   DEFAULT_REQUEST_OPTIONS: () => (/* binding */ DEFAULT_REQUEST_OPTIONS),\n/* harmony export */   WebAuthnAbortService: () => (/* binding */ WebAuthnAbortService),\n/* harmony export */   WebAuthnApi: () => (/* binding */ WebAuthnApi),\n/* harmony export */   WebAuthnError: () => (/* reexport safe */ _webauthn_errors__WEBPACK_IMPORTED_MODULE_3__.WebAuthnError),\n/* harmony export */   createCredential: () => (/* binding */ createCredential),\n/* harmony export */   deserializeCredentialCreationOptions: () => (/* binding */ deserializeCredentialCreationOptions),\n/* harmony export */   deserializeCredentialRequestOptions: () => (/* binding */ deserializeCredentialRequestOptions),\n/* harmony export */   getCredential: () => (/* binding */ getCredential),\n/* harmony export */   identifyAuthenticationError: () => (/* reexport safe */ _webauthn_errors__WEBPACK_IMPORTED_MODULE_3__.identifyAuthenticationError),\n/* harmony export */   identifyRegistrationError: () => (/* reexport safe */ _webauthn_errors__WEBPACK_IMPORTED_MODULE_3__.identifyRegistrationError),\n/* harmony export */   isValidDomain: () => (/* binding */ isValidDomain),\n/* harmony export */   isWebAuthnError: () => (/* reexport safe */ _webauthn_errors__WEBPACK_IMPORTED_MODULE_3__.isWebAuthnError),\n/* harmony export */   mergeCredentialCreationOptions: () => (/* binding */ mergeCredentialCreationOptions),\n/* harmony export */   mergeCredentialRequestOptions: () => (/* binding */ mergeCredentialRequestOptions),\n/* harmony export */   serializeCredentialCreationResponse: () => (/* binding */ serializeCredentialCreationResponse),\n/* harmony export */   serializeCredentialRequestResponse: () => (/* binding */ serializeCredentialRequestResponse),\n/* harmony export */   webAuthnAbortService: () => (/* binding */ webAuthnAbortService)\n/* harmony export */ });\n/* harmony import */ var _base64url__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base64url */ \"(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/base64url.js\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./errors */ \"(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/errors.js\");\n/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./helpers */ \"(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/helpers.js\");\n/* harmony import */ var _webauthn_errors__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./webauthn.errors */ \"(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/webauthn.errors.js\");\nvar __rest = (undefined && undefined.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\n\n\n\n\n\n/**\n * WebAuthn abort service to manage ceremony cancellation.\n * Ensures only one WebAuthn ceremony is active at a time to prevent \"operation already in progress\" errors.\n *\n * @experimental This class is experimental and may change in future releases\n * @see {@link https://w3c.github.io/webauthn/#sctn-automation-webdriver-capability W3C WebAuthn Spec - Aborting Ceremonies}\n */\nclass WebAuthnAbortService {\n    /**\n     * Create an abort signal for a new WebAuthn operation.\n     * Automatically cancels any existing operation.\n     *\n     * @returns {AbortSignal} Signal to pass to navigator.credentials.create() or .get()\n     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal MDN - AbortSignal}\n     */\n    createNewAbortSignal() {\n        // Abort any existing calls to navigator.credentials.create() or navigator.credentials.get()\n        if (this.controller) {\n            const abortError = new Error('Cancelling existing WebAuthn API call for new one');\n            abortError.name = 'AbortError';\n            this.controller.abort(abortError);\n        }\n        const newController = new AbortController();\n        this.controller = newController;\n        return newController.signal;\n    }\n    /**\n     * Manually cancel the current WebAuthn operation.\n     * Useful for cleaning up when user cancels or navigates away.\n     *\n     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/AbortController/abort MDN - AbortController.abort}\n     */\n    cancelCeremony() {\n        if (this.controller) {\n            const abortError = new Error('Manually cancelling existing WebAuthn API call');\n            abortError.name = 'AbortError';\n            this.controller.abort(abortError);\n            this.controller = undefined;\n        }\n    }\n}\n/**\n * Singleton instance to ensure only one WebAuthn ceremony is active at a time.\n * This prevents \"operation already in progress\" errors when retrying WebAuthn operations.\n *\n * @experimental This instance is experimental and may change in future releases\n */\nconst webAuthnAbortService = new WebAuthnAbortService();\n/**\n * Convert base64url encoded strings in WebAuthn credential creation options to ArrayBuffers\n * as required by the WebAuthn browser API.\n * Supports both native WebAuthn Level 3 parseCreationOptionsFromJSON and manual fallback.\n *\n * @param {ServerCredentialCreationOptions} options - JSON options from server with base64url encoded fields\n * @returns {PublicKeyCredentialCreationOptionsFuture} Options ready for navigator.credentials.create()\n * @see {@link https://w3c.github.io/webauthn/#sctn-parseCreationOptionsFromJSON W3C WebAuthn Spec - parseCreationOptionsFromJSON}\n */\nfunction deserializeCredentialCreationOptions(options) {\n    if (!options) {\n        throw new Error('Credential creation options are required');\n    }\n    // Check if the native parseCreationOptionsFromJSON method is available\n    if (typeof PublicKeyCredential !== 'undefined' &&\n        'parseCreationOptionsFromJSON' in PublicKeyCredential &&\n        typeof PublicKeyCredential\n            .parseCreationOptionsFromJSON === 'function') {\n        // Use the native WebAuthn Level 3 method\n        return PublicKeyCredential.parseCreationOptionsFromJSON(\n        /** we assert the options here as typescript still doesn't know about future webauthn types */\n        options);\n    }\n    // Fallback to manual parsing for browsers that don't support the native method\n    // Destructure to separate fields that need transformation\n    const { challenge: challengeStr, user: userOpts, excludeCredentials } = options, restOptions = __rest(options\n    // Convert challenge from base64url to ArrayBuffer\n    , [\"challenge\", \"user\", \"excludeCredentials\"]);\n    // Convert challenge from base64url to ArrayBuffer\n    const challenge = (0,_base64url__WEBPACK_IMPORTED_MODULE_0__.base64UrlToUint8Array)(challengeStr).buffer;\n    // Convert user.id from base64url to ArrayBuffer\n    const user = Object.assign(Object.assign({}, userOpts), { id: (0,_base64url__WEBPACK_IMPORTED_MODULE_0__.base64UrlToUint8Array)(userOpts.id).buffer });\n    // Build the result object\n    const result = Object.assign(Object.assign({}, restOptions), { challenge,\n        user });\n    // Only add excludeCredentials if it exists\n    if (excludeCredentials && excludeCredentials.length > 0) {\n        result.excludeCredentials = new Array(excludeCredentials.length);\n        for (let i = 0; i < excludeCredentials.length; i++) {\n            const cred = excludeCredentials[i];\n            result.excludeCredentials[i] = Object.assign(Object.assign({}, cred), { id: (0,_base64url__WEBPACK_IMPORTED_MODULE_0__.base64UrlToUint8Array)(cred.id).buffer, type: cred.type || 'public-key', \n                // Cast transports to handle future transport types like \"cable\"\n                transports: cred.transports });\n        }\n    }\n    return result;\n}\n/**\n * Convert base64url encoded strings in WebAuthn credential request options to ArrayBuffers\n * as required by the WebAuthn browser API.\n * Supports both native WebAuthn Level 3 parseRequestOptionsFromJSON and manual fallback.\n *\n * @param {ServerCredentialRequestOptions} options - JSON options from server with base64url encoded fields\n * @returns {PublicKeyCredentialRequestOptionsFuture} Options ready for navigator.credentials.get()\n * @see {@link https://w3c.github.io/webauthn/#sctn-parseRequestOptionsFromJSON W3C WebAuthn Spec - parseRequestOptionsFromJSON}\n */\nfunction deserializeCredentialRequestOptions(options) {\n    if (!options) {\n        throw new Error('Credential request options are required');\n    }\n    // Check if the native parseRequestOptionsFromJSON method is available\n    if (typeof PublicKeyCredential !== 'undefined' &&\n        'parseRequestOptionsFromJSON' in PublicKeyCredential &&\n        typeof PublicKeyCredential\n            .parseRequestOptionsFromJSON === 'function') {\n        // Use the native WebAuthn Level 3 method\n        return PublicKeyCredential.parseRequestOptionsFromJSON(options);\n    }\n    // Fallback to manual parsing for browsers that don't support the native method\n    // Destructure to separate fields that need transformation\n    const { challenge: challengeStr, allowCredentials } = options, restOptions = __rest(options\n    // Convert challenge from base64url to ArrayBuffer\n    , [\"challenge\", \"allowCredentials\"]);\n    // Convert challenge from base64url to ArrayBuffer\n    const challenge = (0,_base64url__WEBPACK_IMPORTED_MODULE_0__.base64UrlToUint8Array)(challengeStr).buffer;\n    // Build the result object\n    const result = Object.assign(Object.assign({}, restOptions), { challenge });\n    // Only add allowCredentials if it exists\n    if (allowCredentials && allowCredentials.length > 0) {\n        result.allowCredentials = new Array(allowCredentials.length);\n        for (let i = 0; i < allowCredentials.length; i++) {\n            const cred = allowCredentials[i];\n            result.allowCredentials[i] = Object.assign(Object.assign({}, cred), { id: (0,_base64url__WEBPACK_IMPORTED_MODULE_0__.base64UrlToUint8Array)(cred.id).buffer, type: cred.type || 'public-key', \n                // Cast transports to handle future transport types like \"cable\"\n                transports: cred.transports });\n        }\n    }\n    return result;\n}\n/**\n * Convert a registration/enrollment credential response to server format.\n * Serializes binary fields to base64url for JSON transmission.\n * Supports both native WebAuthn Level 3 toJSON and manual fallback.\n *\n * @param {RegistrationCredential} credential - Credential from navigator.credentials.create()\n * @returns {RegistrationResponseJSON} JSON-serializable credential for server\n * @see {@link https://w3c.github.io/webauthn/#dom-publickeycredential-tojson W3C WebAuthn Spec - toJSON}\n */\nfunction serializeCredentialCreationResponse(credential) {\n    var _a;\n    // Check if the credential instance has the toJSON method\n    if ('toJSON' in credential && typeof credential.toJSON === 'function') {\n        // Use the native WebAuthn Level 3 method\n        return credential.toJSON();\n    }\n    const credentialWithAttachment = credential;\n    return {\n        id: credential.id,\n        rawId: credential.id,\n        response: {\n            attestationObject: (0,_base64url__WEBPACK_IMPORTED_MODULE_0__.bytesToBase64URL)(new Uint8Array(credential.response.attestationObject)),\n            clientDataJSON: (0,_base64url__WEBPACK_IMPORTED_MODULE_0__.bytesToBase64URL)(new Uint8Array(credential.response.clientDataJSON)),\n        },\n        type: 'public-key',\n        clientExtensionResults: credential.getClientExtensionResults(),\n        // Convert null to undefined and cast to AuthenticatorAttachment type\n        authenticatorAttachment: ((_a = credentialWithAttachment.authenticatorAttachment) !== null && _a !== void 0 ? _a : undefined),\n    };\n}\n/**\n * Convert an authentication/verification credential response to server format.\n * Serializes binary fields to base64url for JSON transmission.\n * Supports both native WebAuthn Level 3 toJSON and manual fallback.\n *\n * @param {AuthenticationCredential} credential - Credential from navigator.credentials.get()\n * @returns {AuthenticationResponseJSON} JSON-serializable credential for server\n * @see {@link https://w3c.github.io/webauthn/#dom-publickeycredential-tojson W3C WebAuthn Spec - toJSON}\n */\nfunction serializeCredentialRequestResponse(credential) {\n    var _a;\n    // Check if the credential instance has the toJSON method\n    if ('toJSON' in credential && typeof credential.toJSON === 'function') {\n        // Use the native WebAuthn Level 3 method\n        return credential.toJSON();\n    }\n    // Fallback to manual conversion for browsers that don't support toJSON\n    // Access authenticatorAttachment via type assertion to handle TypeScript version differences\n    // @simplewebauthn/types includes this property but base TypeScript 4.7.4 doesn't\n    const credentialWithAttachment = credential;\n    const clientExtensionResults = credential.getClientExtensionResults();\n    const assertionResponse = credential.response;\n    return {\n        id: credential.id,\n        rawId: credential.id, // W3C spec expects rawId to match id for JSON format\n        response: {\n            authenticatorData: (0,_base64url__WEBPACK_IMPORTED_MODULE_0__.bytesToBase64URL)(new Uint8Array(assertionResponse.authenticatorData)),\n            clientDataJSON: (0,_base64url__WEBPACK_IMPORTED_MODULE_0__.bytesToBase64URL)(new Uint8Array(assertionResponse.clientDataJSON)),\n            signature: (0,_base64url__WEBPACK_IMPORTED_MODULE_0__.bytesToBase64URL)(new Uint8Array(assertionResponse.signature)),\n            userHandle: assertionResponse.userHandle\n                ? (0,_base64url__WEBPACK_IMPORTED_MODULE_0__.bytesToBase64URL)(new Uint8Array(assertionResponse.userHandle))\n                : undefined,\n        },\n        type: 'public-key',\n        clientExtensionResults,\n        // Convert null to undefined and cast to AuthenticatorAttachment type\n        authenticatorAttachment: ((_a = credentialWithAttachment.authenticatorAttachment) !== null && _a !== void 0 ? _a : undefined),\n    };\n}\n/**\n * A simple test to determine if a hostname is a properly-formatted domain name.\n * Considers localhost valid for development environments.\n *\n * A \"valid domain\" is defined here: https://url.spec.whatwg.org/#valid-domain\n *\n * Regex sourced from here:\n * https://www.oreilly.com/library/view/regular-expressions-cookbook/9781449327453/ch08s15.html\n *\n * @param {string} hostname - The hostname to validate\n * @returns {boolean} True if valid domain or localhost\n * @see {@link https://url.spec.whatwg.org/#valid-domain WHATWG URL Spec - Valid Domain}\n */\nfunction isValidDomain(hostname) {\n    return (\n    // Consider localhost valid as well since it's okay wrt Secure Contexts\n    hostname === 'localhost' || /^([a-z0-9]+(-[a-z0-9]+)*\\.)+[a-z]{2,}$/i.test(hostname));\n}\n/**\n * Determine if the browser is capable of WebAuthn.\n * Checks for necessary Web APIs: PublicKeyCredential and Credential Management.\n *\n * @returns {boolean} True if browser supports WebAuthn\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/PublicKeyCredential#browser_compatibility MDN - PublicKeyCredential Browser Compatibility}\n */\nfunction browserSupportsWebAuthn() {\n    var _a, _b;\n    return !!((0,_helpers__WEBPACK_IMPORTED_MODULE_2__.isBrowser)() &&\n        'PublicKeyCredential' in window &&\n        window.PublicKeyCredential &&\n        'credentials' in navigator &&\n        typeof ((_a = navigator === null || navigator === void 0 ? void 0 : navigator.credentials) === null || _a === void 0 ? void 0 : _a.create) === 'function' &&\n        typeof ((_b = navigator === null || navigator === void 0 ? void 0 : navigator.credentials) === null || _b === void 0 ? void 0 : _b.get) === 'function');\n}\n/**\n * Create a WebAuthn credential using the browser's credentials API.\n * Wraps navigator.credentials.create() with error handling.\n *\n * @param {CredentialCreationOptions} options - Options including publicKey parameters\n * @returns {Promise<RequestResult<RegistrationCredential, WebAuthnError>>} Created credential or error\n * @see {@link https://w3c.github.io/webauthn/#sctn-createCredential W3C WebAuthn Spec - Create Credential}\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/CredentialsContainer/create MDN - credentials.create}\n */\nasync function createCredential(options) {\n    try {\n        const response = await navigator.credentials.create(\n        /** we assert the type here until typescript types are updated */\n        options);\n        if (!response) {\n            return {\n                data: null,\n                error: new _webauthn_errors__WEBPACK_IMPORTED_MODULE_3__.WebAuthnUnknownError('Empty credential response', response),\n            };\n        }\n        if (!(response instanceof PublicKeyCredential)) {\n            return {\n                data: null,\n                error: new _webauthn_errors__WEBPACK_IMPORTED_MODULE_3__.WebAuthnUnknownError('Browser returned unexpected credential type', response),\n            };\n        }\n        return { data: response, error: null };\n    }\n    catch (err) {\n        return {\n            data: null,\n            error: (0,_webauthn_errors__WEBPACK_IMPORTED_MODULE_3__.identifyRegistrationError)({\n                error: err,\n                options,\n            }),\n        };\n    }\n}\n/**\n * Get a WebAuthn credential using the browser's credentials API.\n * Wraps navigator.credentials.get() with error handling.\n *\n * @param {CredentialRequestOptions} options - Options including publicKey parameters\n * @returns {Promise<RequestResult<AuthenticationCredential, WebAuthnError>>} Retrieved credential or error\n * @see {@link https://w3c.github.io/webauthn/#sctn-getAssertion W3C WebAuthn Spec - Get Assertion}\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/CredentialsContainer/get MDN - credentials.get}\n */\nasync function getCredential(options) {\n    try {\n        const response = await navigator.credentials.get(\n        /** we assert the type here until typescript types are updated */\n        options);\n        if (!response) {\n            return {\n                data: null,\n                error: new _webauthn_errors__WEBPACK_IMPORTED_MODULE_3__.WebAuthnUnknownError('Empty credential response', response),\n            };\n        }\n        if (!(response instanceof PublicKeyCredential)) {\n            return {\n                data: null,\n                error: new _webauthn_errors__WEBPACK_IMPORTED_MODULE_3__.WebAuthnUnknownError('Browser returned unexpected credential type', response),\n            };\n        }\n        return { data: response, error: null };\n    }\n    catch (err) {\n        return {\n            data: null,\n            error: (0,_webauthn_errors__WEBPACK_IMPORTED_MODULE_3__.identifyAuthenticationError)({\n                error: err,\n                options,\n            }),\n        };\n    }\n}\nconst DEFAULT_CREATION_OPTIONS = {\n    hints: ['security-key'],\n    authenticatorSelection: {\n        authenticatorAttachment: 'cross-platform',\n        requireResidentKey: false,\n        /** set to preferred because older yubikeys don't have PIN/Biometric */\n        userVerification: 'preferred',\n        residentKey: 'discouraged',\n    },\n    attestation: 'none',\n};\nconst DEFAULT_REQUEST_OPTIONS = {\n    /** set to preferred because older yubikeys don't have PIN/Biometric */\n    userVerification: 'preferred',\n    hints: ['security-key'],\n};\nfunction deepMerge(...sources) {\n    const isObject = (val) => val !== null && typeof val === 'object' && !Array.isArray(val);\n    const isArrayBufferLike = (val) => val instanceof ArrayBuffer || ArrayBuffer.isView(val);\n    const result = {};\n    for (const source of sources) {\n        if (!source)\n            continue;\n        for (const key in source) {\n            const value = source[key];\n            if (value === undefined)\n                continue;\n            if (Array.isArray(value)) {\n                // preserve array reference, including unions like AuthenticatorTransport[]\n                result[key] = value;\n            }\n            else if (isArrayBufferLike(value)) {\n                result[key] = value;\n            }\n            else if (isObject(value)) {\n                const existing = result[key];\n                if (isObject(existing)) {\n                    result[key] = deepMerge(existing, value);\n                }\n                else {\n                    result[key] = deepMerge(value);\n                }\n            }\n            else {\n                result[key] = value;\n            }\n        }\n    }\n    return result;\n}\n/**\n * Merges WebAuthn credential creation options with overrides.\n * Sets sensible defaults for authenticator selection and extensions.\n *\n * @param {PublicKeyCredentialCreationOptionsFuture} baseOptions - The base options from the server\n * @param {PublicKeyCredentialCreationOptionsFuture} overrides - Optional overrides to apply\n * @param {string} friendlyName - Optional friendly name for the credential\n * @returns {PublicKeyCredentialCreationOptionsFuture} Merged credential creation options\n * @see {@link https://w3c.github.io/webauthn/#dictdef-authenticatorselectioncriteria W3C WebAuthn Spec - AuthenticatorSelectionCriteria}\n */\nfunction mergeCredentialCreationOptions(baseOptions, overrides) {\n    return deepMerge(DEFAULT_CREATION_OPTIONS, baseOptions, overrides || {});\n}\n/**\n * Merges WebAuthn credential request options with overrides.\n * Sets sensible defaults for user verification and hints.\n *\n * @param {PublicKeyCredentialRequestOptionsFuture} baseOptions - The base options from the server\n * @param {PublicKeyCredentialRequestOptionsFuture} overrides - Optional overrides to apply\n * @returns {PublicKeyCredentialRequestOptionsFuture} Merged credential request options\n * @see {@link https://w3c.github.io/webauthn/#dictdef-publickeycredentialrequestoptions W3C WebAuthn Spec - PublicKeyCredentialRequestOptions}\n */\nfunction mergeCredentialRequestOptions(baseOptions, overrides) {\n    return deepMerge(DEFAULT_REQUEST_OPTIONS, baseOptions, overrides || {});\n}\n/**\n * WebAuthn API wrapper for Supabase Auth.\n * Provides methods for enrolling, challenging, verifying, authenticating, and registering WebAuthn credentials.\n *\n * @experimental This API is experimental and may change in future releases\n * @see {@link https://w3c.github.io/webauthn/ W3C WebAuthn Specification}\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Authentication_API MDN - Web Authentication API}\n */\nclass WebAuthnApi {\n    constructor(client) {\n        this.client = client;\n        // Bind all methods so they can be destructured\n        this.enroll = this._enroll.bind(this);\n        this.challenge = this._challenge.bind(this);\n        this.verify = this._verify.bind(this);\n        this.authenticate = this._authenticate.bind(this);\n        this.register = this._register.bind(this);\n    }\n    /**\n     * Enroll a new WebAuthn factor.\n     * Creates an unverified WebAuthn factor that must be verified with a credential.\n     *\n     * @experimental This method is experimental and may change in future releases\n     * @param {Omit<MFAEnrollWebauthnParams, 'factorType'>} params - Enrollment parameters (friendlyName required)\n     * @returns {Promise<AuthMFAEnrollWebauthnResponse>} Enrolled factor details or error\n     * @see {@link https://w3c.github.io/webauthn/#sctn-registering-a-new-credential W3C WebAuthn Spec - Registering a New Credential}\n     */\n    async _enroll(params) {\n        return this.client.mfa.enroll(Object.assign(Object.assign({}, params), { factorType: 'webauthn' }));\n    }\n    /**\n     * Challenge for WebAuthn credential creation or authentication.\n     * Combines server challenge with browser credential operations.\n     * Handles both registration (create) and authentication (request) flows.\n     *\n     * @experimental This method is experimental and may change in future releases\n     * @param {MFAChallengeWebauthnParams & { friendlyName?: string; signal?: AbortSignal }} params - Challenge parameters including factorId\n     * @param {Object} overrides - Allows you to override the parameters passed to navigator.credentials\n     * @param {PublicKeyCredentialCreationOptionsFuture} overrides.create - Override options for credential creation\n     * @param {PublicKeyCredentialRequestOptionsFuture} overrides.request - Override options for credential request\n     * @returns {Promise<RequestResult>} Challenge response with credential or error\n     * @see {@link https://w3c.github.io/webauthn/#sctn-credential-creation W3C WebAuthn Spec - Credential Creation}\n     * @see {@link https://w3c.github.io/webauthn/#sctn-verifying-assertion W3C WebAuthn Spec - Verifying Assertion}\n     */\n    async _challenge({ factorId, webauthn, friendlyName, signal, }, overrides) {\n        try {\n            // Get challenge from server using the client's MFA methods\n            const { data: challengeResponse, error: challengeError } = await this.client.mfa.challenge({\n                factorId,\n                webauthn,\n            });\n            if (!challengeResponse) {\n                return { data: null, error: challengeError };\n            }\n            const abortSignal = signal !== null && signal !== void 0 ? signal : webAuthnAbortService.createNewAbortSignal();\n            /** webauthn will fail if either of the name/displayname are blank */\n            if (challengeResponse.webauthn.type === 'create') {\n                const { user } = challengeResponse.webauthn.credential_options.publicKey;\n                if (!user.name) {\n                    user.name = `${user.id}:${friendlyName}`;\n                }\n                if (!user.displayName) {\n                    user.displayName = user.name;\n                }\n            }\n            switch (challengeResponse.webauthn.type) {\n                case 'create': {\n                    const options = mergeCredentialCreationOptions(challengeResponse.webauthn.credential_options.publicKey, overrides === null || overrides === void 0 ? void 0 : overrides.create);\n                    const { data, error } = await createCredential({\n                        publicKey: options,\n                        signal: abortSignal,\n                    });\n                    if (data) {\n                        return {\n                            data: {\n                                factorId,\n                                challengeId: challengeResponse.id,\n                                webauthn: {\n                                    type: challengeResponse.webauthn.type,\n                                    credential_response: data,\n                                },\n                            },\n                            error: null,\n                        };\n                    }\n                    return { data: null, error };\n                }\n                case 'request': {\n                    const options = mergeCredentialRequestOptions(challengeResponse.webauthn.credential_options.publicKey, overrides === null || overrides === void 0 ? void 0 : overrides.request);\n                    const { data, error } = await getCredential(Object.assign(Object.assign({}, challengeResponse.webauthn.credential_options), { publicKey: options, signal: abortSignal }));\n                    if (data) {\n                        return {\n                            data: {\n                                factorId,\n                                challengeId: challengeResponse.id,\n                                webauthn: {\n                                    type: challengeResponse.webauthn.type,\n                                    credential_response: data,\n                                },\n                            },\n                            error: null,\n                        };\n                    }\n                    return { data: null, error };\n                }\n            }\n        }\n        catch (error) {\n            if ((0,_errors__WEBPACK_IMPORTED_MODULE_1__.isAuthError)(error)) {\n                return { data: null, error };\n            }\n            return {\n                data: null,\n                error: new _errors__WEBPACK_IMPORTED_MODULE_1__.AuthUnknownError('Unexpected error in challenge', error),\n            };\n        }\n    }\n    /**\n     * Verify a WebAuthn credential with the server.\n     * Completes the WebAuthn ceremony by sending the credential to the server for verification.\n     *\n     * @experimental This method is experimental and may change in future releases\n     * @param {Object} params - Verification parameters\n     * @param {string} params.challengeId - ID of the challenge being verified\n     * @param {string} params.factorId - ID of the WebAuthn factor\n     * @param {MFAVerifyWebauthnParams<T>['webauthn']} params.webauthn - WebAuthn credential response\n     * @returns {Promise<AuthMFAVerifyResponse>} Verification result with session or error\n     * @see {@link https://w3c.github.io/webauthn/#sctn-verifying-assertion W3C WebAuthn Spec - Verifying an Authentication Assertion}\n     * */\n    async _verify({ challengeId, factorId, webauthn, }) {\n        return this.client.mfa.verify({\n            factorId,\n            challengeId,\n            webauthn: webauthn,\n        });\n    }\n    /**\n     * Complete WebAuthn authentication flow.\n     * Performs challenge and verification in a single operation for existing credentials.\n     *\n     * @experimental This method is experimental and may change in future releases\n     * @param {Object} params - Authentication parameters\n     * @param {string} params.factorId - ID of the WebAuthn factor to authenticate with\n     * @param {Object} params.webauthn - WebAuthn configuration\n     * @param {string} params.webauthn.rpId - Relying Party ID (defaults to current hostname)\n     * @param {string[]} params.webauthn.rpOrigins - Allowed origins (defaults to current origin)\n     * @param {AbortSignal} params.webauthn.signal - Optional abort signal\n     * @param {PublicKeyCredentialRequestOptionsFuture} overrides - Override options for navigator.credentials.get\n     * @returns {Promise<RequestResult<AuthMFAVerifyResponseData, WebAuthnError | AuthError>>} Authentication result\n     * @see {@link https://w3c.github.io/webauthn/#sctn-authentication W3C WebAuthn Spec - Authentication Ceremony}\n     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/PublicKeyCredentialRequestOptions MDN - PublicKeyCredentialRequestOptions}\n     */\n    async _authenticate({ factorId, webauthn: { rpId = typeof window !== 'undefined' ? window.location.hostname : undefined, rpOrigins = typeof window !== 'undefined' ? [window.location.origin] : undefined, signal, }, }, overrides) {\n        if (!rpId) {\n            return {\n                data: null,\n                error: new _errors__WEBPACK_IMPORTED_MODULE_1__.AuthError('rpId is required for WebAuthn authentication'),\n            };\n        }\n        try {\n            if (!browserSupportsWebAuthn()) {\n                return {\n                    data: null,\n                    error: new _errors__WEBPACK_IMPORTED_MODULE_1__.AuthUnknownError('Browser does not support WebAuthn', null),\n                };\n            }\n            // Get challenge and credential\n            const { data: challengeResponse, error: challengeError } = await this.challenge({\n                factorId,\n                webauthn: { rpId, rpOrigins },\n                signal,\n            }, { request: overrides });\n            if (!challengeResponse) {\n                return { data: null, error: challengeError };\n            }\n            const { webauthn } = challengeResponse;\n            // Verify credential\n            return this._verify({\n                factorId,\n                challengeId: challengeResponse.challengeId,\n                webauthn: {\n                    type: webauthn.type,\n                    rpId,\n                    rpOrigins,\n                    credential_response: webauthn.credential_response,\n                },\n            });\n        }\n        catch (error) {\n            if ((0,_errors__WEBPACK_IMPORTED_MODULE_1__.isAuthError)(error)) {\n                return { data: null, error };\n            }\n            return {\n                data: null,\n                error: new _errors__WEBPACK_IMPORTED_MODULE_1__.AuthUnknownError('Unexpected error in authenticate', error),\n            };\n        }\n    }\n    /**\n     * Complete WebAuthn registration flow.\n     * Performs enrollment, challenge, and verification in a single operation for new credentials.\n     *\n     * @experimental This method is experimental and may change in future releases\n     * @param {Object} params - Registration parameters\n     * @param {string} params.friendlyName - User-friendly name for the credential\n     * @param {string} params.rpId - Relying Party ID (defaults to current hostname)\n     * @param {string[]} params.rpOrigins - Allowed origins (defaults to current origin)\n     * @param {AbortSignal} params.signal - Optional abort signal\n     * @param {PublicKeyCredentialCreationOptionsFuture} overrides - Override options for navigator.credentials.create\n     * @returns {Promise<RequestResult<AuthMFAVerifyResponseData, WebAuthnError | AuthError>>} Registration result\n     * @see {@link https://w3c.github.io/webauthn/#sctn-registering-a-new-credential W3C WebAuthn Spec - Registration Ceremony}\n     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/PublicKeyCredentialCreationOptions MDN - PublicKeyCredentialCreationOptions}\n     */\n    async _register({ friendlyName, rpId = typeof window !== 'undefined' ? window.location.hostname : undefined, rpOrigins = typeof window !== 'undefined' ? [window.location.origin] : undefined, signal, }, overrides) {\n        if (!rpId) {\n            return {\n                data: null,\n                error: new _errors__WEBPACK_IMPORTED_MODULE_1__.AuthError('rpId is required for WebAuthn registration'),\n            };\n        }\n        try {\n            if (!browserSupportsWebAuthn()) {\n                return {\n                    data: null,\n                    error: new _errors__WEBPACK_IMPORTED_MODULE_1__.AuthUnknownError('Browser does not support WebAuthn', null),\n                };\n            }\n            // Enroll factor\n            const { data: factor, error: enrollError } = await this._enroll({\n                friendlyName,\n            });\n            if (!factor) {\n                await this.client.mfa\n                    .listFactors()\n                    .then((factors) => {\n                    var _a;\n                    return (_a = factors.data) === null || _a === void 0 ? void 0 : _a.all.find((v) => v.factor_type === 'webauthn' &&\n                        v.friendly_name === friendlyName &&\n                        v.status !== 'unverified');\n                })\n                    .then((factor) => (factor ? this.client.mfa.unenroll({ factorId: factor === null || factor === void 0 ? void 0 : factor.id }) : void 0));\n                return { data: null, error: enrollError };\n            }\n            // Get challenge and create credential\n            const { data: challengeResponse, error: challengeError } = await this._challenge({\n                factorId: factor.id,\n                friendlyName: factor.friendly_name,\n                webauthn: { rpId, rpOrigins },\n                signal,\n            }, {\n                create: overrides,\n            });\n            if (!challengeResponse) {\n                return { data: null, error: challengeError };\n            }\n            return this._verify({\n                factorId: factor.id,\n                challengeId: challengeResponse.challengeId,\n                webauthn: {\n                    rpId,\n                    rpOrigins,\n                    type: challengeResponse.webauthn.type,\n                    credential_response: challengeResponse.webauthn.credential_response,\n                },\n            });\n        }\n        catch (error) {\n            if ((0,_errors__WEBPACK_IMPORTED_MODULE_1__.isAuthError)(error)) {\n                return { data: null, error };\n            }\n            return {\n                data: null,\n                error: new _errors__WEBPACK_IMPORTED_MODULE_1__.AuthUnknownError('Unexpected error in register', error),\n            };\n        }\n    }\n}\n//# sourceMappingURL=webauthn.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvYXV0aC1qcy9kaXN0L21vZHVsZS9saWIvd2ViYXV0aG4uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLGNBQWMsU0FBSSxJQUFJLFNBQUk7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsY0FBYztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ3NFO0FBQ0Y7QUFDOUI7QUFDNEc7QUFDaEQ7QUFDbEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsYUFBYTtBQUM5QixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlDQUFpQztBQUM1QyxhQUFhLDBDQUEwQztBQUN2RCxTQUFTO0FBQ1Q7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksOERBQThEO0FBQzFFO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixpRUFBcUI7QUFDM0M7QUFDQSwrQ0FBK0MsZUFBZSxJQUFJLGlFQUFxQixzQkFBc0I7QUFDN0c7QUFDQSxpREFBaUQsa0JBQWtCO0FBQ25FLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsK0JBQStCO0FBQ3ZEO0FBQ0EseUVBQXlFLFdBQVcsSUFBSSxpRUFBcUI7QUFDN0c7QUFDQSw2Q0FBNkM7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QUFXO0FBQzNCLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIscURBQWdCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFxuZXh0XFxvcmdcXG5vZGVfbW9kdWxlc1xcQHN1cGFiYXNlXFxhdXRoLWpzXFxkaXN0XFxtb2R1bGVcXGxpYlxcd2ViYXV0aG4uanMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fcmVzdCA9ICh0aGlzICYmIHRoaXMuX19yZXN0KSB8fCBmdW5jdGlvbiAocywgZSkge1xuICAgIHZhciB0ID0ge307XG4gICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXG4gICAgICAgIHRbcF0gPSBzW3BdO1xuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKVxuICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xuICAgICAgICB9XG4gICAgcmV0dXJuIHQ7XG59O1xuaW1wb3J0IHsgYmFzZTY0VXJsVG9VaW50OEFycmF5LCBieXRlc1RvQmFzZTY0VVJMIH0gZnJvbSAnLi9iYXNlNjR1cmwnO1xuaW1wb3J0IHsgQXV0aEVycm9yLCBBdXRoVW5rbm93bkVycm9yLCBpc0F1dGhFcnJvciB9IGZyb20gJy4vZXJyb3JzJztcbmltcG9ydCB7IGlzQnJvd3NlciB9IGZyb20gJy4vaGVscGVycyc7XG5pbXBvcnQgeyBpZGVudGlmeUF1dGhlbnRpY2F0aW9uRXJyb3IsIGlkZW50aWZ5UmVnaXN0cmF0aW9uRXJyb3IsIGlzV2ViQXV0aG5FcnJvciwgV2ViQXV0aG5FcnJvciwgV2ViQXV0aG5Vbmtub3duRXJyb3IsIH0gZnJvbSAnLi93ZWJhdXRobi5lcnJvcnMnO1xuZXhwb3J0IHsgV2ViQXV0aG5FcnJvciwgaXNXZWJBdXRobkVycm9yLCBpZGVudGlmeVJlZ2lzdHJhdGlvbkVycm9yLCBpZGVudGlmeUF1dGhlbnRpY2F0aW9uRXJyb3IgfTtcbi8qKlxuICogV2ViQXV0aG4gYWJvcnQgc2VydmljZSB0byBtYW5hZ2UgY2VyZW1vbnkgY2FuY2VsbGF0aW9uLlxuICogRW5zdXJlcyBvbmx5IG9uZSBXZWJBdXRobiBjZXJlbW9ueSBpcyBhY3RpdmUgYXQgYSB0aW1lIHRvIHByZXZlbnQgXCJvcGVyYXRpb24gYWxyZWFkeSBpbiBwcm9ncmVzc1wiIGVycm9ycy5cbiAqXG4gKiBAZXhwZXJpbWVudGFsIFRoaXMgY2xhc3MgaXMgZXhwZXJpbWVudGFsIGFuZCBtYXkgY2hhbmdlIGluIGZ1dHVyZSByZWxlYXNlc1xuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmF1dGhuLyNzY3RuLWF1dG9tYXRpb24td2ViZHJpdmVyLWNhcGFiaWxpdHkgVzNDIFdlYkF1dGhuIFNwZWMgLSBBYm9ydGluZyBDZXJlbW9uaWVzfVxuICovXG5leHBvcnQgY2xhc3MgV2ViQXV0aG5BYm9ydFNlcnZpY2Uge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhbiBhYm9ydCBzaWduYWwgZm9yIGEgbmV3IFdlYkF1dGhuIG9wZXJhdGlvbi5cbiAgICAgKiBBdXRvbWF0aWNhbGx5IGNhbmNlbHMgYW55IGV4aXN0aW5nIG9wZXJhdGlvbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtBYm9ydFNpZ25hbH0gU2lnbmFsIHRvIHBhc3MgdG8gbmF2aWdhdG9yLmNyZWRlbnRpYWxzLmNyZWF0ZSgpIG9yIC5nZXQoKVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9BYm9ydFNpZ25hbCBNRE4gLSBBYm9ydFNpZ25hbH1cbiAgICAgKi9cbiAgICBjcmVhdGVOZXdBYm9ydFNpZ25hbCgpIHtcbiAgICAgICAgLy8gQWJvcnQgYW55IGV4aXN0aW5nIGNhbGxzIHRvIG5hdmlnYXRvci5jcmVkZW50aWFscy5jcmVhdGUoKSBvciBuYXZpZ2F0b3IuY3JlZGVudGlhbHMuZ2V0KClcbiAgICAgICAgaWYgKHRoaXMuY29udHJvbGxlcikge1xuICAgICAgICAgICAgY29uc3QgYWJvcnRFcnJvciA9IG5ldyBFcnJvcignQ2FuY2VsbGluZyBleGlzdGluZyBXZWJBdXRobiBBUEkgY2FsbCBmb3IgbmV3IG9uZScpO1xuICAgICAgICAgICAgYWJvcnRFcnJvci5uYW1lID0gJ0Fib3J0RXJyb3InO1xuICAgICAgICAgICAgdGhpcy5jb250cm9sbGVyLmFib3J0KGFib3J0RXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5ld0NvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgICAgIHRoaXMuY29udHJvbGxlciA9IG5ld0NvbnRyb2xsZXI7XG4gICAgICAgIHJldHVybiBuZXdDb250cm9sbGVyLnNpZ25hbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWFudWFsbHkgY2FuY2VsIHRoZSBjdXJyZW50IFdlYkF1dGhuIG9wZXJhdGlvbi5cbiAgICAgKiBVc2VmdWwgZm9yIGNsZWFuaW5nIHVwIHdoZW4gdXNlciBjYW5jZWxzIG9yIG5hdmlnYXRlcyBhd2F5LlxuICAgICAqXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0Fib3J0Q29udHJvbGxlci9hYm9ydCBNRE4gLSBBYm9ydENvbnRyb2xsZXIuYWJvcnR9XG4gICAgICovXG4gICAgY2FuY2VsQ2VyZW1vbnkoKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IGFib3J0RXJyb3IgPSBuZXcgRXJyb3IoJ01hbnVhbGx5IGNhbmNlbGxpbmcgZXhpc3RpbmcgV2ViQXV0aG4gQVBJIGNhbGwnKTtcbiAgICAgICAgICAgIGFib3J0RXJyb3IubmFtZSA9ICdBYm9ydEVycm9yJztcbiAgICAgICAgICAgIHRoaXMuY29udHJvbGxlci5hYm9ydChhYm9ydEVycm9yKTtcbiAgICAgICAgICAgIHRoaXMuY29udHJvbGxlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogU2luZ2xldG9uIGluc3RhbmNlIHRvIGVuc3VyZSBvbmx5IG9uZSBXZWJBdXRobiBjZXJlbW9ueSBpcyBhY3RpdmUgYXQgYSB0aW1lLlxuICogVGhpcyBwcmV2ZW50cyBcIm9wZXJhdGlvbiBhbHJlYWR5IGluIHByb2dyZXNzXCIgZXJyb3JzIHdoZW4gcmV0cnlpbmcgV2ViQXV0aG4gb3BlcmF0aW9ucy5cbiAqXG4gKiBAZXhwZXJpbWVudGFsIFRoaXMgaW5zdGFuY2UgaXMgZXhwZXJpbWVudGFsIGFuZCBtYXkgY2hhbmdlIGluIGZ1dHVyZSByZWxlYXNlc1xuICovXG5leHBvcnQgY29uc3Qgd2ViQXV0aG5BYm9ydFNlcnZpY2UgPSBuZXcgV2ViQXV0aG5BYm9ydFNlcnZpY2UoKTtcbi8qKlxuICogQ29udmVydCBiYXNlNjR1cmwgZW5jb2RlZCBzdHJpbmdzIGluIFdlYkF1dGhuIGNyZWRlbnRpYWwgY3JlYXRpb24gb3B0aW9ucyB0byBBcnJheUJ1ZmZlcnNcbiAqIGFzIHJlcXVpcmVkIGJ5IHRoZSBXZWJBdXRobiBicm93c2VyIEFQSS5cbiAqIFN1cHBvcnRzIGJvdGggbmF0aXZlIFdlYkF1dGhuIExldmVsIDMgcGFyc2VDcmVhdGlvbk9wdGlvbnNGcm9tSlNPTiBhbmQgbWFudWFsIGZhbGxiYWNrLlxuICpcbiAqIEBwYXJhbSB7U2VydmVyQ3JlZGVudGlhbENyZWF0aW9uT3B0aW9uc30gb3B0aW9ucyAtIEpTT04gb3B0aW9ucyBmcm9tIHNlcnZlciB3aXRoIGJhc2U2NHVybCBlbmNvZGVkIGZpZWxkc1xuICogQHJldHVybnMge1B1YmxpY0tleUNyZWRlbnRpYWxDcmVhdGlvbk9wdGlvbnNGdXR1cmV9IE9wdGlvbnMgcmVhZHkgZm9yIG5hdmlnYXRvci5jcmVkZW50aWFscy5jcmVhdGUoKVxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmF1dGhuLyNzY3RuLXBhcnNlQ3JlYXRpb25PcHRpb25zRnJvbUpTT04gVzNDIFdlYkF1dGhuIFNwZWMgLSBwYXJzZUNyZWF0aW9uT3B0aW9uc0Zyb21KU09OfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVzZXJpYWxpemVDcmVkZW50aWFsQ3JlYXRpb25PcHRpb25zKG9wdGlvbnMpIHtcbiAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDcmVkZW50aWFsIGNyZWF0aW9uIG9wdGlvbnMgYXJlIHJlcXVpcmVkJyk7XG4gICAgfVxuICAgIC8vIENoZWNrIGlmIHRoZSBuYXRpdmUgcGFyc2VDcmVhdGlvbk9wdGlvbnNGcm9tSlNPTiBtZXRob2QgaXMgYXZhaWxhYmxlXG4gICAgaWYgKHR5cGVvZiBQdWJsaWNLZXlDcmVkZW50aWFsICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAncGFyc2VDcmVhdGlvbk9wdGlvbnNGcm9tSlNPTicgaW4gUHVibGljS2V5Q3JlZGVudGlhbCAmJlxuICAgICAgICB0eXBlb2YgUHVibGljS2V5Q3JlZGVudGlhbFxuICAgICAgICAgICAgLnBhcnNlQ3JlYXRpb25PcHRpb25zRnJvbUpTT04gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gVXNlIHRoZSBuYXRpdmUgV2ViQXV0aG4gTGV2ZWwgMyBtZXRob2RcbiAgICAgICAgcmV0dXJuIFB1YmxpY0tleUNyZWRlbnRpYWwucGFyc2VDcmVhdGlvbk9wdGlvbnNGcm9tSlNPTihcbiAgICAgICAgLyoqIHdlIGFzc2VydCB0aGUgb3B0aW9ucyBoZXJlIGFzIHR5cGVzY3JpcHQgc3RpbGwgZG9lc24ndCBrbm93IGFib3V0IGZ1dHVyZSB3ZWJhdXRobiB0eXBlcyAqL1xuICAgICAgICBvcHRpb25zKTtcbiAgICB9XG4gICAgLy8gRmFsbGJhY2sgdG8gbWFudWFsIHBhcnNpbmcgZm9yIGJyb3dzZXJzIHRoYXQgZG9uJ3Qgc3VwcG9ydCB0aGUgbmF0aXZlIG1ldGhvZFxuICAgIC8vIERlc3RydWN0dXJlIHRvIHNlcGFyYXRlIGZpZWxkcyB0aGF0IG5lZWQgdHJhbnNmb3JtYXRpb25cbiAgICBjb25zdCB7IGNoYWxsZW5nZTogY2hhbGxlbmdlU3RyLCB1c2VyOiB1c2VyT3B0cywgZXhjbHVkZUNyZWRlbnRpYWxzIH0gPSBvcHRpb25zLCByZXN0T3B0aW9ucyA9IF9fcmVzdChvcHRpb25zXG4gICAgLy8gQ29udmVydCBjaGFsbGVuZ2UgZnJvbSBiYXNlNjR1cmwgdG8gQXJyYXlCdWZmZXJcbiAgICAsIFtcImNoYWxsZW5nZVwiLCBcInVzZXJcIiwgXCJleGNsdWRlQ3JlZGVudGlhbHNcIl0pO1xuICAgIC8vIENvbnZlcnQgY2hhbGxlbmdlIGZyb20gYmFzZTY0dXJsIHRvIEFycmF5QnVmZmVyXG4gICAgY29uc3QgY2hhbGxlbmdlID0gYmFzZTY0VXJsVG9VaW50OEFycmF5KGNoYWxsZW5nZVN0cikuYnVmZmVyO1xuICAgIC8vIENvbnZlcnQgdXNlci5pZCBmcm9tIGJhc2U2NHVybCB0byBBcnJheUJ1ZmZlclxuICAgIGNvbnN0IHVzZXIgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHVzZXJPcHRzKSwgeyBpZDogYmFzZTY0VXJsVG9VaW50OEFycmF5KHVzZXJPcHRzLmlkKS5idWZmZXIgfSk7XG4gICAgLy8gQnVpbGQgdGhlIHJlc3VsdCBvYmplY3RcbiAgICBjb25zdCByZXN1bHQgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJlc3RPcHRpb25zKSwgeyBjaGFsbGVuZ2UsXG4gICAgICAgIHVzZXIgfSk7XG4gICAgLy8gT25seSBhZGQgZXhjbHVkZUNyZWRlbnRpYWxzIGlmIGl0IGV4aXN0c1xuICAgIGlmIChleGNsdWRlQ3JlZGVudGlhbHMgJiYgZXhjbHVkZUNyZWRlbnRpYWxzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmVzdWx0LmV4Y2x1ZGVDcmVkZW50aWFscyA9IG5ldyBBcnJheShleGNsdWRlQ3JlZGVudGlhbHMubGVuZ3RoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBleGNsdWRlQ3JlZGVudGlhbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGNyZWQgPSBleGNsdWRlQ3JlZGVudGlhbHNbaV07XG4gICAgICAgICAgICByZXN1bHQuZXhjbHVkZUNyZWRlbnRpYWxzW2ldID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBjcmVkKSwgeyBpZDogYmFzZTY0VXJsVG9VaW50OEFycmF5KGNyZWQuaWQpLmJ1ZmZlciwgdHlwZTogY3JlZC50eXBlIHx8ICdwdWJsaWMta2V5JywgXG4gICAgICAgICAgICAgICAgLy8gQ2FzdCB0cmFuc3BvcnRzIHRvIGhhbmRsZSBmdXR1cmUgdHJhbnNwb3J0IHR5cGVzIGxpa2UgXCJjYWJsZVwiXG4gICAgICAgICAgICAgICAgdHJhbnNwb3J0czogY3JlZC50cmFuc3BvcnRzIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIENvbnZlcnQgYmFzZTY0dXJsIGVuY29kZWQgc3RyaW5ncyBpbiBXZWJBdXRobiBjcmVkZW50aWFsIHJlcXVlc3Qgb3B0aW9ucyB0byBBcnJheUJ1ZmZlcnNcbiAqIGFzIHJlcXVpcmVkIGJ5IHRoZSBXZWJBdXRobiBicm93c2VyIEFQSS5cbiAqIFN1cHBvcnRzIGJvdGggbmF0aXZlIFdlYkF1dGhuIExldmVsIDMgcGFyc2VSZXF1ZXN0T3B0aW9uc0Zyb21KU09OIGFuZCBtYW51YWwgZmFsbGJhY2suXG4gKlxuICogQHBhcmFtIHtTZXJ2ZXJDcmVkZW50aWFsUmVxdWVzdE9wdGlvbnN9IG9wdGlvbnMgLSBKU09OIG9wdGlvbnMgZnJvbSBzZXJ2ZXIgd2l0aCBiYXNlNjR1cmwgZW5jb2RlZCBmaWVsZHNcbiAqIEByZXR1cm5zIHtQdWJsaWNLZXlDcmVkZW50aWFsUmVxdWVzdE9wdGlvbnNGdXR1cmV9IE9wdGlvbnMgcmVhZHkgZm9yIG5hdmlnYXRvci5jcmVkZW50aWFscy5nZXQoKVxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmF1dGhuLyNzY3RuLXBhcnNlUmVxdWVzdE9wdGlvbnNGcm9tSlNPTiBXM0MgV2ViQXV0aG4gU3BlYyAtIHBhcnNlUmVxdWVzdE9wdGlvbnNGcm9tSlNPTn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlc2VyaWFsaXplQ3JlZGVudGlhbFJlcXVlc3RPcHRpb25zKG9wdGlvbnMpIHtcbiAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDcmVkZW50aWFsIHJlcXVlc3Qgb3B0aW9ucyBhcmUgcmVxdWlyZWQnKTtcbiAgICB9XG4gICAgLy8gQ2hlY2sgaWYgdGhlIG5hdGl2ZSBwYXJzZVJlcXVlc3RPcHRpb25zRnJvbUpTT04gbWV0aG9kIGlzIGF2YWlsYWJsZVxuICAgIGlmICh0eXBlb2YgUHVibGljS2V5Q3JlZGVudGlhbCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgJ3BhcnNlUmVxdWVzdE9wdGlvbnNGcm9tSlNPTicgaW4gUHVibGljS2V5Q3JlZGVudGlhbCAmJlxuICAgICAgICB0eXBlb2YgUHVibGljS2V5Q3JlZGVudGlhbFxuICAgICAgICAgICAgLnBhcnNlUmVxdWVzdE9wdGlvbnNGcm9tSlNPTiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBVc2UgdGhlIG5hdGl2ZSBXZWJBdXRobiBMZXZlbCAzIG1ldGhvZFxuICAgICAgICByZXR1cm4gUHVibGljS2V5Q3JlZGVudGlhbC5wYXJzZVJlcXVlc3RPcHRpb25zRnJvbUpTT04ob3B0aW9ucyk7XG4gICAgfVxuICAgIC8vIEZhbGxiYWNrIHRvIG1hbnVhbCBwYXJzaW5nIGZvciBicm93c2VycyB0aGF0IGRvbid0IHN1cHBvcnQgdGhlIG5hdGl2ZSBtZXRob2RcbiAgICAvLyBEZXN0cnVjdHVyZSB0byBzZXBhcmF0ZSBmaWVsZHMgdGhhdCBuZWVkIHRyYW5zZm9ybWF0aW9uXG4gICAgY29uc3QgeyBjaGFsbGVuZ2U6IGNoYWxsZW5nZVN0ciwgYWxsb3dDcmVkZW50aWFscyB9ID0gb3B0aW9ucywgcmVzdE9wdGlvbnMgPSBfX3Jlc3Qob3B0aW9uc1xuICAgIC8vIENvbnZlcnQgY2hhbGxlbmdlIGZyb20gYmFzZTY0dXJsIHRvIEFycmF5QnVmZmVyXG4gICAgLCBbXCJjaGFsbGVuZ2VcIiwgXCJhbGxvd0NyZWRlbnRpYWxzXCJdKTtcbiAgICAvLyBDb252ZXJ0IGNoYWxsZW5nZSBmcm9tIGJhc2U2NHVybCB0byBBcnJheUJ1ZmZlclxuICAgIGNvbnN0IGNoYWxsZW5nZSA9IGJhc2U2NFVybFRvVWludDhBcnJheShjaGFsbGVuZ2VTdHIpLmJ1ZmZlcjtcbiAgICAvLyBCdWlsZCB0aGUgcmVzdWx0IG9iamVjdFxuICAgIGNvbnN0IHJlc3VsdCA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcmVzdE9wdGlvbnMpLCB7IGNoYWxsZW5nZSB9KTtcbiAgICAvLyBPbmx5IGFkZCBhbGxvd0NyZWRlbnRpYWxzIGlmIGl0IGV4aXN0c1xuICAgIGlmIChhbGxvd0NyZWRlbnRpYWxzICYmIGFsbG93Q3JlZGVudGlhbHMubGVuZ3RoID4gMCkge1xuICAgICAgICByZXN1bHQuYWxsb3dDcmVkZW50aWFscyA9IG5ldyBBcnJheShhbGxvd0NyZWRlbnRpYWxzLmxlbmd0aCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWxsb3dDcmVkZW50aWFscy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgY3JlZCA9IGFsbG93Q3JlZGVudGlhbHNbaV07XG4gICAgICAgICAgICByZXN1bHQuYWxsb3dDcmVkZW50aWFsc1tpXSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY3JlZCksIHsgaWQ6IGJhc2U2NFVybFRvVWludDhBcnJheShjcmVkLmlkKS5idWZmZXIsIHR5cGU6IGNyZWQudHlwZSB8fCAncHVibGljLWtleScsIFxuICAgICAgICAgICAgICAgIC8vIENhc3QgdHJhbnNwb3J0cyB0byBoYW5kbGUgZnV0dXJlIHRyYW5zcG9ydCB0eXBlcyBsaWtlIFwiY2FibGVcIlxuICAgICAgICAgICAgICAgIHRyYW5zcG9ydHM6IGNyZWQudHJhbnNwb3J0cyB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiBDb252ZXJ0IGEgcmVnaXN0cmF0aW9uL2Vucm9sbG1lbnQgY3JlZGVudGlhbCByZXNwb25zZSB0byBzZXJ2ZXIgZm9ybWF0LlxuICogU2VyaWFsaXplcyBiaW5hcnkgZmllbGRzIHRvIGJhc2U2NHVybCBmb3IgSlNPTiB0cmFuc21pc3Npb24uXG4gKiBTdXBwb3J0cyBib3RoIG5hdGl2ZSBXZWJBdXRobiBMZXZlbCAzIHRvSlNPTiBhbmQgbWFudWFsIGZhbGxiYWNrLlxuICpcbiAqIEBwYXJhbSB7UmVnaXN0cmF0aW9uQ3JlZGVudGlhbH0gY3JlZGVudGlhbCAtIENyZWRlbnRpYWwgZnJvbSBuYXZpZ2F0b3IuY3JlZGVudGlhbHMuY3JlYXRlKClcbiAqIEByZXR1cm5zIHtSZWdpc3RyYXRpb25SZXNwb25zZUpTT059IEpTT04tc2VyaWFsaXphYmxlIGNyZWRlbnRpYWwgZm9yIHNlcnZlclxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmF1dGhuLyNkb20tcHVibGlja2V5Y3JlZGVudGlhbC10b2pzb24gVzNDIFdlYkF1dGhuIFNwZWMgLSB0b0pTT059XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXJpYWxpemVDcmVkZW50aWFsQ3JlYXRpb25SZXNwb25zZShjcmVkZW50aWFsKSB7XG4gICAgdmFyIF9hO1xuICAgIC8vIENoZWNrIGlmIHRoZSBjcmVkZW50aWFsIGluc3RhbmNlIGhhcyB0aGUgdG9KU09OIG1ldGhvZFxuICAgIGlmICgndG9KU09OJyBpbiBjcmVkZW50aWFsICYmIHR5cGVvZiBjcmVkZW50aWFsLnRvSlNPTiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBVc2UgdGhlIG5hdGl2ZSBXZWJBdXRobiBMZXZlbCAzIG1ldGhvZFxuICAgICAgICByZXR1cm4gY3JlZGVudGlhbC50b0pTT04oKTtcbiAgICB9XG4gICAgY29uc3QgY3JlZGVudGlhbFdpdGhBdHRhY2htZW50ID0gY3JlZGVudGlhbDtcbiAgICByZXR1cm4ge1xuICAgICAgICBpZDogY3JlZGVudGlhbC5pZCxcbiAgICAgICAgcmF3SWQ6IGNyZWRlbnRpYWwuaWQsXG4gICAgICAgIHJlc3BvbnNlOiB7XG4gICAgICAgICAgICBhdHRlc3RhdGlvbk9iamVjdDogYnl0ZXNUb0Jhc2U2NFVSTChuZXcgVWludDhBcnJheShjcmVkZW50aWFsLnJlc3BvbnNlLmF0dGVzdGF0aW9uT2JqZWN0KSksXG4gICAgICAgICAgICBjbGllbnREYXRhSlNPTjogYnl0ZXNUb0Jhc2U2NFVSTChuZXcgVWludDhBcnJheShjcmVkZW50aWFsLnJlc3BvbnNlLmNsaWVudERhdGFKU09OKSksXG4gICAgICAgIH0sXG4gICAgICAgIHR5cGU6ICdwdWJsaWMta2V5JyxcbiAgICAgICAgY2xpZW50RXh0ZW5zaW9uUmVzdWx0czogY3JlZGVudGlhbC5nZXRDbGllbnRFeHRlbnNpb25SZXN1bHRzKCksXG4gICAgICAgIC8vIENvbnZlcnQgbnVsbCB0byB1bmRlZmluZWQgYW5kIGNhc3QgdG8gQXV0aGVudGljYXRvckF0dGFjaG1lbnQgdHlwZVxuICAgICAgICBhdXRoZW50aWNhdG9yQXR0YWNobWVudDogKChfYSA9IGNyZWRlbnRpYWxXaXRoQXR0YWNobWVudC5hdXRoZW50aWNhdG9yQXR0YWNobWVudCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdW5kZWZpbmVkKSxcbiAgICB9O1xufVxuLyoqXG4gKiBDb252ZXJ0IGFuIGF1dGhlbnRpY2F0aW9uL3ZlcmlmaWNhdGlvbiBjcmVkZW50aWFsIHJlc3BvbnNlIHRvIHNlcnZlciBmb3JtYXQuXG4gKiBTZXJpYWxpemVzIGJpbmFyeSBmaWVsZHMgdG8gYmFzZTY0dXJsIGZvciBKU09OIHRyYW5zbWlzc2lvbi5cbiAqIFN1cHBvcnRzIGJvdGggbmF0aXZlIFdlYkF1dGhuIExldmVsIDMgdG9KU09OIGFuZCBtYW51YWwgZmFsbGJhY2suXG4gKlxuICogQHBhcmFtIHtBdXRoZW50aWNhdGlvbkNyZWRlbnRpYWx9IGNyZWRlbnRpYWwgLSBDcmVkZW50aWFsIGZyb20gbmF2aWdhdG9yLmNyZWRlbnRpYWxzLmdldCgpXG4gKiBAcmV0dXJucyB7QXV0aGVudGljYXRpb25SZXNwb25zZUpTT059IEpTT04tc2VyaWFsaXphYmxlIGNyZWRlbnRpYWwgZm9yIHNlcnZlclxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmF1dGhuLyNkb20tcHVibGlja2V5Y3JlZGVudGlhbC10b2pzb24gVzNDIFdlYkF1dGhuIFNwZWMgLSB0b0pTT059XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXJpYWxpemVDcmVkZW50aWFsUmVxdWVzdFJlc3BvbnNlKGNyZWRlbnRpYWwpIHtcbiAgICB2YXIgX2E7XG4gICAgLy8gQ2hlY2sgaWYgdGhlIGNyZWRlbnRpYWwgaW5zdGFuY2UgaGFzIHRoZSB0b0pTT04gbWV0aG9kXG4gICAgaWYgKCd0b0pTT04nIGluIGNyZWRlbnRpYWwgJiYgdHlwZW9mIGNyZWRlbnRpYWwudG9KU09OID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIFVzZSB0aGUgbmF0aXZlIFdlYkF1dGhuIExldmVsIDMgbWV0aG9kXG4gICAgICAgIHJldHVybiBjcmVkZW50aWFsLnRvSlNPTigpO1xuICAgIH1cbiAgICAvLyBGYWxsYmFjayB0byBtYW51YWwgY29udmVyc2lvbiBmb3IgYnJvd3NlcnMgdGhhdCBkb24ndCBzdXBwb3J0IHRvSlNPTlxuICAgIC8vIEFjY2VzcyBhdXRoZW50aWNhdG9yQXR0YWNobWVudCB2aWEgdHlwZSBhc3NlcnRpb24gdG8gaGFuZGxlIFR5cGVTY3JpcHQgdmVyc2lvbiBkaWZmZXJlbmNlc1xuICAgIC8vIEBzaW1wbGV3ZWJhdXRobi90eXBlcyBpbmNsdWRlcyB0aGlzIHByb3BlcnR5IGJ1dCBiYXNlIFR5cGVTY3JpcHQgNC43LjQgZG9lc24ndFxuICAgIGNvbnN0IGNyZWRlbnRpYWxXaXRoQXR0YWNobWVudCA9IGNyZWRlbnRpYWw7XG4gICAgY29uc3QgY2xpZW50RXh0ZW5zaW9uUmVzdWx0cyA9IGNyZWRlbnRpYWwuZ2V0Q2xpZW50RXh0ZW5zaW9uUmVzdWx0cygpO1xuICAgIGNvbnN0IGFzc2VydGlvblJlc3BvbnNlID0gY3JlZGVudGlhbC5yZXNwb25zZTtcbiAgICByZXR1cm4ge1xuICAgICAgICBpZDogY3JlZGVudGlhbC5pZCxcbiAgICAgICAgcmF3SWQ6IGNyZWRlbnRpYWwuaWQsIC8vIFczQyBzcGVjIGV4cGVjdHMgcmF3SWQgdG8gbWF0Y2ggaWQgZm9yIEpTT04gZm9ybWF0XG4gICAgICAgIHJlc3BvbnNlOiB7XG4gICAgICAgICAgICBhdXRoZW50aWNhdG9yRGF0YTogYnl0ZXNUb0Jhc2U2NFVSTChuZXcgVWludDhBcnJheShhc3NlcnRpb25SZXNwb25zZS5hdXRoZW50aWNhdG9yRGF0YSkpLFxuICAgICAgICAgICAgY2xpZW50RGF0YUpTT046IGJ5dGVzVG9CYXNlNjRVUkwobmV3IFVpbnQ4QXJyYXkoYXNzZXJ0aW9uUmVzcG9uc2UuY2xpZW50RGF0YUpTT04pKSxcbiAgICAgICAgICAgIHNpZ25hdHVyZTogYnl0ZXNUb0Jhc2U2NFVSTChuZXcgVWludDhBcnJheShhc3NlcnRpb25SZXNwb25zZS5zaWduYXR1cmUpKSxcbiAgICAgICAgICAgIHVzZXJIYW5kbGU6IGFzc2VydGlvblJlc3BvbnNlLnVzZXJIYW5kbGVcbiAgICAgICAgICAgICAgICA/IGJ5dGVzVG9CYXNlNjRVUkwobmV3IFVpbnQ4QXJyYXkoYXNzZXJ0aW9uUmVzcG9uc2UudXNlckhhbmRsZSkpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgIH0sXG4gICAgICAgIHR5cGU6ICdwdWJsaWMta2V5JyxcbiAgICAgICAgY2xpZW50RXh0ZW5zaW9uUmVzdWx0cyxcbiAgICAgICAgLy8gQ29udmVydCBudWxsIHRvIHVuZGVmaW5lZCBhbmQgY2FzdCB0byBBdXRoZW50aWNhdG9yQXR0YWNobWVudCB0eXBlXG4gICAgICAgIGF1dGhlbnRpY2F0b3JBdHRhY2htZW50OiAoKF9hID0gY3JlZGVudGlhbFdpdGhBdHRhY2htZW50LmF1dGhlbnRpY2F0b3JBdHRhY2htZW50KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB1bmRlZmluZWQpLFxuICAgIH07XG59XG4vKipcbiAqIEEgc2ltcGxlIHRlc3QgdG8gZGV0ZXJtaW5lIGlmIGEgaG9zdG5hbWUgaXMgYSBwcm9wZXJseS1mb3JtYXR0ZWQgZG9tYWluIG5hbWUuXG4gKiBDb25zaWRlcnMgbG9jYWxob3N0IHZhbGlkIGZvciBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMuXG4gKlxuICogQSBcInZhbGlkIGRvbWFpblwiIGlzIGRlZmluZWQgaGVyZTogaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyN2YWxpZC1kb21haW5cbiAqXG4gKiBSZWdleCBzb3VyY2VkIGZyb20gaGVyZTpcbiAqIGh0dHBzOi8vd3d3Lm9yZWlsbHkuY29tL2xpYnJhcnkvdmlldy9yZWd1bGFyLWV4cHJlc3Npb25zLWNvb2tib29rLzk3ODE0NDkzMjc0NTMvY2gwOHMxNS5odG1sXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGhvc3RuYW1lIC0gVGhlIGhvc3RuYW1lIHRvIHZhbGlkYXRlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWxpZCBkb21haW4gb3IgbG9jYWxob3N0XG4gKiBAc2VlIHtAbGluayBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI3ZhbGlkLWRvbWFpbiBXSEFUV0cgVVJMIFNwZWMgLSBWYWxpZCBEb21haW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1ZhbGlkRG9tYWluKGhvc3RuYW1lKSB7XG4gICAgcmV0dXJuIChcbiAgICAvLyBDb25zaWRlciBsb2NhbGhvc3QgdmFsaWQgYXMgd2VsbCBzaW5jZSBpdCdzIG9rYXkgd3J0IFNlY3VyZSBDb250ZXh0c1xuICAgIGhvc3RuYW1lID09PSAnbG9jYWxob3N0JyB8fCAvXihbYS16MC05XSsoLVthLXowLTldKykqXFwuKStbYS16XXsyLH0kL2kudGVzdChob3N0bmFtZSkpO1xufVxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgdGhlIGJyb3dzZXIgaXMgY2FwYWJsZSBvZiBXZWJBdXRobi5cbiAqIENoZWNrcyBmb3IgbmVjZXNzYXJ5IFdlYiBBUElzOiBQdWJsaWNLZXlDcmVkZW50aWFsIGFuZCBDcmVkZW50aWFsIE1hbmFnZW1lbnQuXG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgYnJvd3NlciBzdXBwb3J0cyBXZWJBdXRoblxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1B1YmxpY0tleUNyZWRlbnRpYWwjYnJvd3Nlcl9jb21wYXRpYmlsaXR5IE1ETiAtIFB1YmxpY0tleUNyZWRlbnRpYWwgQnJvd3NlciBDb21wYXRpYmlsaXR5fVxuICovXG5mdW5jdGlvbiBicm93c2VyU3VwcG9ydHNXZWJBdXRobigpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHJldHVybiAhIShpc0Jyb3dzZXIoKSAmJlxuICAgICAgICAnUHVibGljS2V5Q3JlZGVudGlhbCcgaW4gd2luZG93ICYmXG4gICAgICAgIHdpbmRvdy5QdWJsaWNLZXlDcmVkZW50aWFsICYmXG4gICAgICAgICdjcmVkZW50aWFscycgaW4gbmF2aWdhdG9yICYmXG4gICAgICAgIHR5cGVvZiAoKF9hID0gbmF2aWdhdG9yID09PSBudWxsIHx8IG5hdmlnYXRvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogbmF2aWdhdG9yLmNyZWRlbnRpYWxzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY3JlYXRlKSA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgICB0eXBlb2YgKChfYiA9IG5hdmlnYXRvciA9PT0gbnVsbCB8fCBuYXZpZ2F0b3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG5hdmlnYXRvci5jcmVkZW50aWFscykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmdldCkgPT09ICdmdW5jdGlvbicpO1xufVxuLyoqXG4gKiBDcmVhdGUgYSBXZWJBdXRobiBjcmVkZW50aWFsIHVzaW5nIHRoZSBicm93c2VyJ3MgY3JlZGVudGlhbHMgQVBJLlxuICogV3JhcHMgbmF2aWdhdG9yLmNyZWRlbnRpYWxzLmNyZWF0ZSgpIHdpdGggZXJyb3IgaGFuZGxpbmcuXG4gKlxuICogQHBhcmFtIHtDcmVkZW50aWFsQ3JlYXRpb25PcHRpb25zfSBvcHRpb25zIC0gT3B0aW9ucyBpbmNsdWRpbmcgcHVibGljS2V5IHBhcmFtZXRlcnNcbiAqIEByZXR1cm5zIHtQcm9taXNlPFJlcXVlc3RSZXN1bHQ8UmVnaXN0cmF0aW9uQ3JlZGVudGlhbCwgV2ViQXV0aG5FcnJvcj4+fSBDcmVhdGVkIGNyZWRlbnRpYWwgb3IgZXJyb3JcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJhdXRobi8jc2N0bi1jcmVhdGVDcmVkZW50aWFsIFczQyBXZWJBdXRobiBTcGVjIC0gQ3JlYXRlIENyZWRlbnRpYWx9XG4gKiBAc2VlIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ3JlZGVudGlhbHNDb250YWluZXIvY3JlYXRlIE1ETiAtIGNyZWRlbnRpYWxzLmNyZWF0ZX1cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZUNyZWRlbnRpYWwob3B0aW9ucykge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgbmF2aWdhdG9yLmNyZWRlbnRpYWxzLmNyZWF0ZShcbiAgICAgICAgLyoqIHdlIGFzc2VydCB0aGUgdHlwZSBoZXJlIHVudGlsIHR5cGVzY3JpcHQgdHlwZXMgYXJlIHVwZGF0ZWQgKi9cbiAgICAgICAgb3B0aW9ucyk7XG4gICAgICAgIGlmICghcmVzcG9uc2UpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgICAgICAgICBlcnJvcjogbmV3IFdlYkF1dGhuVW5rbm93bkVycm9yKCdFbXB0eSBjcmVkZW50aWFsIHJlc3BvbnNlJywgcmVzcG9uc2UpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShyZXNwb25zZSBpbnN0YW5jZW9mIFB1YmxpY0tleUNyZWRlbnRpYWwpKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgICAgICAgICAgZXJyb3I6IG5ldyBXZWJBdXRoblVua25vd25FcnJvcignQnJvd3NlciByZXR1cm5lZCB1bmV4cGVjdGVkIGNyZWRlbnRpYWwgdHlwZScsIHJlc3BvbnNlKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgZGF0YTogcmVzcG9uc2UsIGVycm9yOiBudWxsIH07XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgICAgICBlcnJvcjogaWRlbnRpZnlSZWdpc3RyYXRpb25FcnJvcih7XG4gICAgICAgICAgICAgICAgZXJyb3I6IGVycixcbiAgICAgICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgfSksXG4gICAgICAgIH07XG4gICAgfVxufVxuLyoqXG4gKiBHZXQgYSBXZWJBdXRobiBjcmVkZW50aWFsIHVzaW5nIHRoZSBicm93c2VyJ3MgY3JlZGVudGlhbHMgQVBJLlxuICogV3JhcHMgbmF2aWdhdG9yLmNyZWRlbnRpYWxzLmdldCgpIHdpdGggZXJyb3IgaGFuZGxpbmcuXG4gKlxuICogQHBhcmFtIHtDcmVkZW50aWFsUmVxdWVzdE9wdGlvbnN9IG9wdGlvbnMgLSBPcHRpb25zIGluY2x1ZGluZyBwdWJsaWNLZXkgcGFyYW1ldGVyc1xuICogQHJldHVybnMge1Byb21pc2U8UmVxdWVzdFJlc3VsdDxBdXRoZW50aWNhdGlvbkNyZWRlbnRpYWwsIFdlYkF1dGhuRXJyb3I+Pn0gUmV0cmlldmVkIGNyZWRlbnRpYWwgb3IgZXJyb3JcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJhdXRobi8jc2N0bi1nZXRBc3NlcnRpb24gVzNDIFdlYkF1dGhuIFNwZWMgLSBHZXQgQXNzZXJ0aW9ufVxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0NyZWRlbnRpYWxzQ29udGFpbmVyL2dldCBNRE4gLSBjcmVkZW50aWFscy5nZXR9XG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRDcmVkZW50aWFsKG9wdGlvbnMpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IG5hdmlnYXRvci5jcmVkZW50aWFscy5nZXQoXG4gICAgICAgIC8qKiB3ZSBhc3NlcnQgdGhlIHR5cGUgaGVyZSB1bnRpbCB0eXBlc2NyaXB0IHR5cGVzIGFyZSB1cGRhdGVkICovXG4gICAgICAgIG9wdGlvbnMpO1xuICAgICAgICBpZiAoIXJlc3BvbnNlKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgICAgICAgICAgZXJyb3I6IG5ldyBXZWJBdXRoblVua25vd25FcnJvcignRW1wdHkgY3JlZGVudGlhbCByZXNwb25zZScsIHJlc3BvbnNlKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEocmVzcG9uc2UgaW5zdGFuY2VvZiBQdWJsaWNLZXlDcmVkZW50aWFsKSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkYXRhOiBudWxsLFxuICAgICAgICAgICAgICAgIGVycm9yOiBuZXcgV2ViQXV0aG5Vbmtub3duRXJyb3IoJ0Jyb3dzZXIgcmV0dXJuZWQgdW5leHBlY3RlZCBjcmVkZW50aWFsIHR5cGUnLCByZXNwb25zZSksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGRhdGE6IHJlc3BvbnNlLCBlcnJvcjogbnVsbCB9O1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkYXRhOiBudWxsLFxuICAgICAgICAgICAgZXJyb3I6IGlkZW50aWZ5QXV0aGVudGljYXRpb25FcnJvcih7XG4gICAgICAgICAgICAgICAgZXJyb3I6IGVycixcbiAgICAgICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgfSksXG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0IGNvbnN0IERFRkFVTFRfQ1JFQVRJT05fT1BUSU9OUyA9IHtcbiAgICBoaW50czogWydzZWN1cml0eS1rZXknXSxcbiAgICBhdXRoZW50aWNhdG9yU2VsZWN0aW9uOiB7XG4gICAgICAgIGF1dGhlbnRpY2F0b3JBdHRhY2htZW50OiAnY3Jvc3MtcGxhdGZvcm0nLFxuICAgICAgICByZXF1aXJlUmVzaWRlbnRLZXk6IGZhbHNlLFxuICAgICAgICAvKiogc2V0IHRvIHByZWZlcnJlZCBiZWNhdXNlIG9sZGVyIHl1YmlrZXlzIGRvbid0IGhhdmUgUElOL0Jpb21ldHJpYyAqL1xuICAgICAgICB1c2VyVmVyaWZpY2F0aW9uOiAncHJlZmVycmVkJyxcbiAgICAgICAgcmVzaWRlbnRLZXk6ICdkaXNjb3VyYWdlZCcsXG4gICAgfSxcbiAgICBhdHRlc3RhdGlvbjogJ25vbmUnLFxufTtcbmV4cG9ydCBjb25zdCBERUZBVUxUX1JFUVVFU1RfT1BUSU9OUyA9IHtcbiAgICAvKiogc2V0IHRvIHByZWZlcnJlZCBiZWNhdXNlIG9sZGVyIHl1YmlrZXlzIGRvbid0IGhhdmUgUElOL0Jpb21ldHJpYyAqL1xuICAgIHVzZXJWZXJpZmljYXRpb246ICdwcmVmZXJyZWQnLFxuICAgIGhpbnRzOiBbJ3NlY3VyaXR5LWtleSddLFxufTtcbmZ1bmN0aW9uIGRlZXBNZXJnZSguLi5zb3VyY2VzKSB7XG4gICAgY29uc3QgaXNPYmplY3QgPSAodmFsKSA9PiB2YWwgIT09IG51bGwgJiYgdHlwZW9mIHZhbCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkodmFsKTtcbiAgICBjb25zdCBpc0FycmF5QnVmZmVyTGlrZSA9ICh2YWwpID0+IHZhbCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyIHx8IEFycmF5QnVmZmVyLmlzVmlldyh2YWwpO1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGZvciAoY29uc3Qgc291cmNlIG9mIHNvdXJjZXMpIHtcbiAgICAgICAgaWYgKCFzb3VyY2UpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHNvdXJjZVtrZXldO1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAvLyBwcmVzZXJ2ZSBhcnJheSByZWZlcmVuY2UsIGluY2x1ZGluZyB1bmlvbnMgbGlrZSBBdXRoZW50aWNhdG9yVHJhbnNwb3J0W11cbiAgICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNBcnJheUJ1ZmZlckxpa2UodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nID0gcmVzdWx0W2tleV07XG4gICAgICAgICAgICAgICAgaWYgKGlzT2JqZWN0KGV4aXN0aW5nKSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IGRlZXBNZXJnZShleGlzdGluZywgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBkZWVwTWVyZ2UodmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogTWVyZ2VzIFdlYkF1dGhuIGNyZWRlbnRpYWwgY3JlYXRpb24gb3B0aW9ucyB3aXRoIG92ZXJyaWRlcy5cbiAqIFNldHMgc2Vuc2libGUgZGVmYXVsdHMgZm9yIGF1dGhlbnRpY2F0b3Igc2VsZWN0aW9uIGFuZCBleHRlbnNpb25zLlxuICpcbiAqIEBwYXJhbSB7UHVibGljS2V5Q3JlZGVudGlhbENyZWF0aW9uT3B0aW9uc0Z1dHVyZX0gYmFzZU9wdGlvbnMgLSBUaGUgYmFzZSBvcHRpb25zIGZyb20gdGhlIHNlcnZlclxuICogQHBhcmFtIHtQdWJsaWNLZXlDcmVkZW50aWFsQ3JlYXRpb25PcHRpb25zRnV0dXJlfSBvdmVycmlkZXMgLSBPcHRpb25hbCBvdmVycmlkZXMgdG8gYXBwbHlcbiAqIEBwYXJhbSB7c3RyaW5nfSBmcmllbmRseU5hbWUgLSBPcHRpb25hbCBmcmllbmRseSBuYW1lIGZvciB0aGUgY3JlZGVudGlhbFxuICogQHJldHVybnMge1B1YmxpY0tleUNyZWRlbnRpYWxDcmVhdGlvbk9wdGlvbnNGdXR1cmV9IE1lcmdlZCBjcmVkZW50aWFsIGNyZWF0aW9uIG9wdGlvbnNcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJhdXRobi8jZGljdGRlZi1hdXRoZW50aWNhdG9yc2VsZWN0aW9uY3JpdGVyaWEgVzNDIFdlYkF1dGhuIFNwZWMgLSBBdXRoZW50aWNhdG9yU2VsZWN0aW9uQ3JpdGVyaWF9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtZXJnZUNyZWRlbnRpYWxDcmVhdGlvbk9wdGlvbnMoYmFzZU9wdGlvbnMsIG92ZXJyaWRlcykge1xuICAgIHJldHVybiBkZWVwTWVyZ2UoREVGQVVMVF9DUkVBVElPTl9PUFRJT05TLCBiYXNlT3B0aW9ucywgb3ZlcnJpZGVzIHx8IHt9KTtcbn1cbi8qKlxuICogTWVyZ2VzIFdlYkF1dGhuIGNyZWRlbnRpYWwgcmVxdWVzdCBvcHRpb25zIHdpdGggb3ZlcnJpZGVzLlxuICogU2V0cyBzZW5zaWJsZSBkZWZhdWx0cyBmb3IgdXNlciB2ZXJpZmljYXRpb24gYW5kIGhpbnRzLlxuICpcbiAqIEBwYXJhbSB7UHVibGljS2V5Q3JlZGVudGlhbFJlcXVlc3RPcHRpb25zRnV0dXJlfSBiYXNlT3B0aW9ucyAtIFRoZSBiYXNlIG9wdGlvbnMgZnJvbSB0aGUgc2VydmVyXG4gKiBAcGFyYW0ge1B1YmxpY0tleUNyZWRlbnRpYWxSZXF1ZXN0T3B0aW9uc0Z1dHVyZX0gb3ZlcnJpZGVzIC0gT3B0aW9uYWwgb3ZlcnJpZGVzIHRvIGFwcGx5XG4gKiBAcmV0dXJucyB7UHVibGljS2V5Q3JlZGVudGlhbFJlcXVlc3RPcHRpb25zRnV0dXJlfSBNZXJnZWQgY3JlZGVudGlhbCByZXF1ZXN0IG9wdGlvbnNcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJhdXRobi8jZGljdGRlZi1wdWJsaWNrZXljcmVkZW50aWFscmVxdWVzdG9wdGlvbnMgVzNDIFdlYkF1dGhuIFNwZWMgLSBQdWJsaWNLZXlDcmVkZW50aWFsUmVxdWVzdE9wdGlvbnN9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtZXJnZUNyZWRlbnRpYWxSZXF1ZXN0T3B0aW9ucyhiYXNlT3B0aW9ucywgb3ZlcnJpZGVzKSB7XG4gICAgcmV0dXJuIGRlZXBNZXJnZShERUZBVUxUX1JFUVVFU1RfT1BUSU9OUywgYmFzZU9wdGlvbnMsIG92ZXJyaWRlcyB8fCB7fSk7XG59XG4vKipcbiAqIFdlYkF1dGhuIEFQSSB3cmFwcGVyIGZvciBTdXBhYmFzZSBBdXRoLlxuICogUHJvdmlkZXMgbWV0aG9kcyBmb3IgZW5yb2xsaW5nLCBjaGFsbGVuZ2luZywgdmVyaWZ5aW5nLCBhdXRoZW50aWNhdGluZywgYW5kIHJlZ2lzdGVyaW5nIFdlYkF1dGhuIGNyZWRlbnRpYWxzLlxuICpcbiAqIEBleHBlcmltZW50YWwgVGhpcyBBUEkgaXMgZXhwZXJpbWVudGFsIGFuZCBtYXkgY2hhbmdlIGluIGZ1dHVyZSByZWxlYXNlc1xuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmF1dGhuLyBXM0MgV2ViQXV0aG4gU3BlY2lmaWNhdGlvbn1cbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9XZWJfQXV0aGVudGljYXRpb25fQVBJIE1ETiAtIFdlYiBBdXRoZW50aWNhdGlvbiBBUEl9XG4gKi9cbmV4cG9ydCBjbGFzcyBXZWJBdXRobkFwaSB7XG4gICAgY29uc3RydWN0b3IoY2xpZW50KSB7XG4gICAgICAgIHRoaXMuY2xpZW50ID0gY2xpZW50O1xuICAgICAgICAvLyBCaW5kIGFsbCBtZXRob2RzIHNvIHRoZXkgY2FuIGJlIGRlc3RydWN0dXJlZFxuICAgICAgICB0aGlzLmVucm9sbCA9IHRoaXMuX2Vucm9sbC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmNoYWxsZW5nZSA9IHRoaXMuX2NoYWxsZW5nZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnZlcmlmeSA9IHRoaXMuX3ZlcmlmeS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmF1dGhlbnRpY2F0ZSA9IHRoaXMuX2F1dGhlbnRpY2F0ZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyID0gdGhpcy5fcmVnaXN0ZXIuYmluZCh0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5yb2xsIGEgbmV3IFdlYkF1dGhuIGZhY3Rvci5cbiAgICAgKiBDcmVhdGVzIGFuIHVudmVyaWZpZWQgV2ViQXV0aG4gZmFjdG9yIHRoYXQgbXVzdCBiZSB2ZXJpZmllZCB3aXRoIGEgY3JlZGVudGlhbC5cbiAgICAgKlxuICAgICAqIEBleHBlcmltZW50YWwgVGhpcyBtZXRob2QgaXMgZXhwZXJpbWVudGFsIGFuZCBtYXkgY2hhbmdlIGluIGZ1dHVyZSByZWxlYXNlc1xuICAgICAqIEBwYXJhbSB7T21pdDxNRkFFbnJvbGxXZWJhdXRoblBhcmFtcywgJ2ZhY3RvclR5cGUnPn0gcGFyYW1zIC0gRW5yb2xsbWVudCBwYXJhbWV0ZXJzIChmcmllbmRseU5hbWUgcmVxdWlyZWQpXG4gICAgICogQHJldHVybnMge1Byb21pc2U8QXV0aE1GQUVucm9sbFdlYmF1dGhuUmVzcG9uc2U+fSBFbnJvbGxlZCBmYWN0b3IgZGV0YWlscyBvciBlcnJvclxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJhdXRobi8jc2N0bi1yZWdpc3RlcmluZy1hLW5ldy1jcmVkZW50aWFsIFczQyBXZWJBdXRobiBTcGVjIC0gUmVnaXN0ZXJpbmcgYSBOZXcgQ3JlZGVudGlhbH1cbiAgICAgKi9cbiAgICBhc3luYyBfZW5yb2xsKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQubWZhLmVucm9sbChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHBhcmFtcyksIHsgZmFjdG9yVHlwZTogJ3dlYmF1dGhuJyB9KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoYWxsZW5nZSBmb3IgV2ViQXV0aG4gY3JlZGVudGlhbCBjcmVhdGlvbiBvciBhdXRoZW50aWNhdGlvbi5cbiAgICAgKiBDb21iaW5lcyBzZXJ2ZXIgY2hhbGxlbmdlIHdpdGggYnJvd3NlciBjcmVkZW50aWFsIG9wZXJhdGlvbnMuXG4gICAgICogSGFuZGxlcyBib3RoIHJlZ2lzdHJhdGlvbiAoY3JlYXRlKSBhbmQgYXV0aGVudGljYXRpb24gKHJlcXVlc3QpIGZsb3dzLlxuICAgICAqXG4gICAgICogQGV4cGVyaW1lbnRhbCBUaGlzIG1ldGhvZCBpcyBleHBlcmltZW50YWwgYW5kIG1heSBjaGFuZ2UgaW4gZnV0dXJlIHJlbGVhc2VzXG4gICAgICogQHBhcmFtIHtNRkFDaGFsbGVuZ2VXZWJhdXRoblBhcmFtcyAmIHsgZnJpZW5kbHlOYW1lPzogc3RyaW5nOyBzaWduYWw/OiBBYm9ydFNpZ25hbCB9fSBwYXJhbXMgLSBDaGFsbGVuZ2UgcGFyYW1ldGVycyBpbmNsdWRpbmcgZmFjdG9ySWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3ZlcnJpZGVzIC0gQWxsb3dzIHlvdSB0byBvdmVycmlkZSB0aGUgcGFyYW1ldGVycyBwYXNzZWQgdG8gbmF2aWdhdG9yLmNyZWRlbnRpYWxzXG4gICAgICogQHBhcmFtIHtQdWJsaWNLZXlDcmVkZW50aWFsQ3JlYXRpb25PcHRpb25zRnV0dXJlfSBvdmVycmlkZXMuY3JlYXRlIC0gT3ZlcnJpZGUgb3B0aW9ucyBmb3IgY3JlZGVudGlhbCBjcmVhdGlvblxuICAgICAqIEBwYXJhbSB7UHVibGljS2V5Q3JlZGVudGlhbFJlcXVlc3RPcHRpb25zRnV0dXJlfSBvdmVycmlkZXMucmVxdWVzdCAtIE92ZXJyaWRlIG9wdGlvbnMgZm9yIGNyZWRlbnRpYWwgcmVxdWVzdFxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFJlcXVlc3RSZXN1bHQ+fSBDaGFsbGVuZ2UgcmVzcG9uc2Ugd2l0aCBjcmVkZW50aWFsIG9yIGVycm9yXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmF1dGhuLyNzY3RuLWNyZWRlbnRpYWwtY3JlYXRpb24gVzNDIFdlYkF1dGhuIFNwZWMgLSBDcmVkZW50aWFsIENyZWF0aW9ufVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJhdXRobi8jc2N0bi12ZXJpZnlpbmctYXNzZXJ0aW9uIFczQyBXZWJBdXRobiBTcGVjIC0gVmVyaWZ5aW5nIEFzc2VydGlvbn1cbiAgICAgKi9cbiAgICBhc3luYyBfY2hhbGxlbmdlKHsgZmFjdG9ySWQsIHdlYmF1dGhuLCBmcmllbmRseU5hbWUsIHNpZ25hbCwgfSwgb3ZlcnJpZGVzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBHZXQgY2hhbGxlbmdlIGZyb20gc2VydmVyIHVzaW5nIHRoZSBjbGllbnQncyBNRkEgbWV0aG9kc1xuICAgICAgICAgICAgY29uc3QgeyBkYXRhOiBjaGFsbGVuZ2VSZXNwb25zZSwgZXJyb3I6IGNoYWxsZW5nZUVycm9yIH0gPSBhd2FpdCB0aGlzLmNsaWVudC5tZmEuY2hhbGxlbmdlKHtcbiAgICAgICAgICAgICAgICBmYWN0b3JJZCxcbiAgICAgICAgICAgICAgICB3ZWJhdXRobixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKCFjaGFsbGVuZ2VSZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yOiBjaGFsbGVuZ2VFcnJvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYWJvcnRTaWduYWwgPSBzaWduYWwgIT09IG51bGwgJiYgc2lnbmFsICE9PSB2b2lkIDAgPyBzaWduYWwgOiB3ZWJBdXRobkFib3J0U2VydmljZS5jcmVhdGVOZXdBYm9ydFNpZ25hbCgpO1xuICAgICAgICAgICAgLyoqIHdlYmF1dGhuIHdpbGwgZmFpbCBpZiBlaXRoZXIgb2YgdGhlIG5hbWUvZGlzcGxheW5hbWUgYXJlIGJsYW5rICovXG4gICAgICAgICAgICBpZiAoY2hhbGxlbmdlUmVzcG9uc2Uud2ViYXV0aG4udHlwZSA9PT0gJ2NyZWF0ZScpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHVzZXIgfSA9IGNoYWxsZW5nZVJlc3BvbnNlLndlYmF1dGhuLmNyZWRlbnRpYWxfb3B0aW9ucy5wdWJsaWNLZXk7XG4gICAgICAgICAgICAgICAgaWYgKCF1c2VyLm5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdXNlci5uYW1lID0gYCR7dXNlci5pZH06JHtmcmllbmRseU5hbWV9YDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCF1c2VyLmRpc3BsYXlOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHVzZXIuZGlzcGxheU5hbWUgPSB1c2VyLm5hbWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3dpdGNoIChjaGFsbGVuZ2VSZXNwb25zZS53ZWJhdXRobi50eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnY3JlYXRlJzoge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvcHRpb25zID0gbWVyZ2VDcmVkZW50aWFsQ3JlYXRpb25PcHRpb25zKGNoYWxsZW5nZVJlc3BvbnNlLndlYmF1dGhuLmNyZWRlbnRpYWxfb3B0aW9ucy5wdWJsaWNLZXksIG92ZXJyaWRlcyA9PT0gbnVsbCB8fCBvdmVycmlkZXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG92ZXJyaWRlcy5jcmVhdGUpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBjcmVhdGVDcmVkZW50aWFsKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHB1YmxpY0tleTogb3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25hbDogYWJvcnRTaWduYWwsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhY3RvcklkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFsbGVuZ2VJZDogY2hhbGxlbmdlUmVzcG9uc2UuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdlYmF1dGhuOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBjaGFsbGVuZ2VSZXNwb25zZS53ZWJhdXRobi50eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3JlZGVudGlhbF9yZXNwb25zZTogZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICdyZXF1ZXN0Jzoge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvcHRpb25zID0gbWVyZ2VDcmVkZW50aWFsUmVxdWVzdE9wdGlvbnMoY2hhbGxlbmdlUmVzcG9uc2Uud2ViYXV0aG4uY3JlZGVudGlhbF9vcHRpb25zLnB1YmxpY0tleSwgb3ZlcnJpZGVzID09PSBudWxsIHx8IG92ZXJyaWRlcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3ZlcnJpZGVzLnJlcXVlc3QpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBnZXRDcmVkZW50aWFsKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY2hhbGxlbmdlUmVzcG9uc2Uud2ViYXV0aG4uY3JlZGVudGlhbF9vcHRpb25zKSwgeyBwdWJsaWNLZXk6IG9wdGlvbnMsIHNpZ25hbDogYWJvcnRTaWduYWwgfSkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhY3RvcklkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFsbGVuZ2VJZDogY2hhbGxlbmdlUmVzcG9uc2UuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdlYmF1dGhuOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBjaGFsbGVuZ2VSZXNwb25zZS53ZWJhdXRobi50eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3JlZGVudGlhbF9yZXNwb25zZTogZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkYXRhOiBudWxsLFxuICAgICAgICAgICAgICAgIGVycm9yOiBuZXcgQXV0aFVua25vd25FcnJvcignVW5leHBlY3RlZCBlcnJvciBpbiBjaGFsbGVuZ2UnLCBlcnJvciksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFZlcmlmeSBhIFdlYkF1dGhuIGNyZWRlbnRpYWwgd2l0aCB0aGUgc2VydmVyLlxuICAgICAqIENvbXBsZXRlcyB0aGUgV2ViQXV0aG4gY2VyZW1vbnkgYnkgc2VuZGluZyB0aGUgY3JlZGVudGlhbCB0byB0aGUgc2VydmVyIGZvciB2ZXJpZmljYXRpb24uXG4gICAgICpcbiAgICAgKiBAZXhwZXJpbWVudGFsIFRoaXMgbWV0aG9kIGlzIGV4cGVyaW1lbnRhbCBhbmQgbWF5IGNoYW5nZSBpbiBmdXR1cmUgcmVsZWFzZXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIC0gVmVyaWZpY2F0aW9uIHBhcmFtZXRlcnNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLmNoYWxsZW5nZUlkIC0gSUQgb2YgdGhlIGNoYWxsZW5nZSBiZWluZyB2ZXJpZmllZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMuZmFjdG9ySWQgLSBJRCBvZiB0aGUgV2ViQXV0aG4gZmFjdG9yXG4gICAgICogQHBhcmFtIHtNRkFWZXJpZnlXZWJhdXRoblBhcmFtczxUPlsnd2ViYXV0aG4nXX0gcGFyYW1zLndlYmF1dGhuIC0gV2ViQXV0aG4gY3JlZGVudGlhbCByZXNwb25zZVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEF1dGhNRkFWZXJpZnlSZXNwb25zZT59IFZlcmlmaWNhdGlvbiByZXN1bHQgd2l0aCBzZXNzaW9uIG9yIGVycm9yXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmF1dGhuLyNzY3RuLXZlcmlmeWluZy1hc3NlcnRpb24gVzNDIFdlYkF1dGhuIFNwZWMgLSBWZXJpZnlpbmcgYW4gQXV0aGVudGljYXRpb24gQXNzZXJ0aW9ufVxuICAgICAqICovXG4gICAgYXN5bmMgX3ZlcmlmeSh7IGNoYWxsZW5nZUlkLCBmYWN0b3JJZCwgd2ViYXV0aG4sIH0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50Lm1mYS52ZXJpZnkoe1xuICAgICAgICAgICAgZmFjdG9ySWQsXG4gICAgICAgICAgICBjaGFsbGVuZ2VJZCxcbiAgICAgICAgICAgIHdlYmF1dGhuOiB3ZWJhdXRobixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbXBsZXRlIFdlYkF1dGhuIGF1dGhlbnRpY2F0aW9uIGZsb3cuXG4gICAgICogUGVyZm9ybXMgY2hhbGxlbmdlIGFuZCB2ZXJpZmljYXRpb24gaW4gYSBzaW5nbGUgb3BlcmF0aW9uIGZvciBleGlzdGluZyBjcmVkZW50aWFscy5cbiAgICAgKlxuICAgICAqIEBleHBlcmltZW50YWwgVGhpcyBtZXRob2QgaXMgZXhwZXJpbWVudGFsIGFuZCBtYXkgY2hhbmdlIGluIGZ1dHVyZSByZWxlYXNlc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgLSBBdXRoZW50aWNhdGlvbiBwYXJhbWV0ZXJzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5mYWN0b3JJZCAtIElEIG9mIHRoZSBXZWJBdXRobiBmYWN0b3IgdG8gYXV0aGVudGljYXRlIHdpdGhcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zLndlYmF1dGhuIC0gV2ViQXV0aG4gY29uZmlndXJhdGlvblxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMud2ViYXV0aG4ucnBJZCAtIFJlbHlpbmcgUGFydHkgSUQgKGRlZmF1bHRzIHRvIGN1cnJlbnQgaG9zdG5hbWUpXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gcGFyYW1zLndlYmF1dGhuLnJwT3JpZ2lucyAtIEFsbG93ZWQgb3JpZ2lucyAoZGVmYXVsdHMgdG8gY3VycmVudCBvcmlnaW4pXG4gICAgICogQHBhcmFtIHtBYm9ydFNpZ25hbH0gcGFyYW1zLndlYmF1dGhuLnNpZ25hbCAtIE9wdGlvbmFsIGFib3J0IHNpZ25hbFxuICAgICAqIEBwYXJhbSB7UHVibGljS2V5Q3JlZGVudGlhbFJlcXVlc3RPcHRpb25zRnV0dXJlfSBvdmVycmlkZXMgLSBPdmVycmlkZSBvcHRpb25zIGZvciBuYXZpZ2F0b3IuY3JlZGVudGlhbHMuZ2V0XG4gICAgICogQHJldHVybnMge1Byb21pc2U8UmVxdWVzdFJlc3VsdDxBdXRoTUZBVmVyaWZ5UmVzcG9uc2VEYXRhLCBXZWJBdXRobkVycm9yIHwgQXV0aEVycm9yPj59IEF1dGhlbnRpY2F0aW9uIHJlc3VsdFxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJhdXRobi8jc2N0bi1hdXRoZW50aWNhdGlvbiBXM0MgV2ViQXV0aG4gU3BlYyAtIEF1dGhlbnRpY2F0aW9uIENlcmVtb255fVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9QdWJsaWNLZXlDcmVkZW50aWFsUmVxdWVzdE9wdGlvbnMgTUROIC0gUHVibGljS2V5Q3JlZGVudGlhbFJlcXVlc3RPcHRpb25zfVxuICAgICAqL1xuICAgIGFzeW5jIF9hdXRoZW50aWNhdGUoeyBmYWN0b3JJZCwgd2ViYXV0aG46IHsgcnBJZCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93LmxvY2F0aW9uLmhvc3RuYW1lIDogdW5kZWZpbmVkLCBycE9yaWdpbnMgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IFt3aW5kb3cubG9jYXRpb24ub3JpZ2luXSA6IHVuZGVmaW5lZCwgc2lnbmFsLCB9LCB9LCBvdmVycmlkZXMpIHtcbiAgICAgICAgaWYgKCFycElkKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgICAgICAgICAgZXJyb3I6IG5ldyBBdXRoRXJyb3IoJ3JwSWQgaXMgcmVxdWlyZWQgZm9yIFdlYkF1dGhuIGF1dGhlbnRpY2F0aW9uJyksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoIWJyb3dzZXJTdXBwb3J0c1dlYkF1dGhuKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogbmV3IEF1dGhVbmtub3duRXJyb3IoJ0Jyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBXZWJBdXRobicsIG51bGwpLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBHZXQgY2hhbGxlbmdlIGFuZCBjcmVkZW50aWFsXG4gICAgICAgICAgICBjb25zdCB7IGRhdGE6IGNoYWxsZW5nZVJlc3BvbnNlLCBlcnJvcjogY2hhbGxlbmdlRXJyb3IgfSA9IGF3YWl0IHRoaXMuY2hhbGxlbmdlKHtcbiAgICAgICAgICAgICAgICBmYWN0b3JJZCxcbiAgICAgICAgICAgICAgICB3ZWJhdXRobjogeyBycElkLCBycE9yaWdpbnMgfSxcbiAgICAgICAgICAgICAgICBzaWduYWwsXG4gICAgICAgICAgICB9LCB7IHJlcXVlc3Q6IG92ZXJyaWRlcyB9KTtcbiAgICAgICAgICAgIGlmICghY2hhbGxlbmdlUmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvcjogY2hhbGxlbmdlRXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgd2ViYXV0aG4gfSA9IGNoYWxsZW5nZVJlc3BvbnNlO1xuICAgICAgICAgICAgLy8gVmVyaWZ5IGNyZWRlbnRpYWxcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl92ZXJpZnkoe1xuICAgICAgICAgICAgICAgIGZhY3RvcklkLFxuICAgICAgICAgICAgICAgIGNoYWxsZW5nZUlkOiBjaGFsbGVuZ2VSZXNwb25zZS5jaGFsbGVuZ2VJZCxcbiAgICAgICAgICAgICAgICB3ZWJhdXRobjoge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiB3ZWJhdXRobi50eXBlLFxuICAgICAgICAgICAgICAgICAgICBycElkLFxuICAgICAgICAgICAgICAgICAgICBycE9yaWdpbnMsXG4gICAgICAgICAgICAgICAgICAgIGNyZWRlbnRpYWxfcmVzcG9uc2U6IHdlYmF1dGhuLmNyZWRlbnRpYWxfcmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgICAgICAgICAgZXJyb3I6IG5ldyBBdXRoVW5rbm93bkVycm9yKCdVbmV4cGVjdGVkIGVycm9yIGluIGF1dGhlbnRpY2F0ZScsIGVycm9yKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tcGxldGUgV2ViQXV0aG4gcmVnaXN0cmF0aW9uIGZsb3cuXG4gICAgICogUGVyZm9ybXMgZW5yb2xsbWVudCwgY2hhbGxlbmdlLCBhbmQgdmVyaWZpY2F0aW9uIGluIGEgc2luZ2xlIG9wZXJhdGlvbiBmb3IgbmV3IGNyZWRlbnRpYWxzLlxuICAgICAqXG4gICAgICogQGV4cGVyaW1lbnRhbCBUaGlzIG1ldGhvZCBpcyBleHBlcmltZW50YWwgYW5kIG1heSBjaGFuZ2UgaW4gZnV0dXJlIHJlbGVhc2VzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyAtIFJlZ2lzdHJhdGlvbiBwYXJhbWV0ZXJzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5mcmllbmRseU5hbWUgLSBVc2VyLWZyaWVuZGx5IG5hbWUgZm9yIHRoZSBjcmVkZW50aWFsXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5ycElkIC0gUmVseWluZyBQYXJ0eSBJRCAoZGVmYXVsdHMgdG8gY3VycmVudCBob3N0bmFtZSlcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBwYXJhbXMucnBPcmlnaW5zIC0gQWxsb3dlZCBvcmlnaW5zIChkZWZhdWx0cyB0byBjdXJyZW50IG9yaWdpbilcbiAgICAgKiBAcGFyYW0ge0Fib3J0U2lnbmFsfSBwYXJhbXMuc2lnbmFsIC0gT3B0aW9uYWwgYWJvcnQgc2lnbmFsXG4gICAgICogQHBhcmFtIHtQdWJsaWNLZXlDcmVkZW50aWFsQ3JlYXRpb25PcHRpb25zRnV0dXJlfSBvdmVycmlkZXMgLSBPdmVycmlkZSBvcHRpb25zIGZvciBuYXZpZ2F0b3IuY3JlZGVudGlhbHMuY3JlYXRlXG4gICAgICogQHJldHVybnMge1Byb21pc2U8UmVxdWVzdFJlc3VsdDxBdXRoTUZBVmVyaWZ5UmVzcG9uc2VEYXRhLCBXZWJBdXRobkVycm9yIHwgQXV0aEVycm9yPj59IFJlZ2lzdHJhdGlvbiByZXN1bHRcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL3czYy5naXRodWIuaW8vd2ViYXV0aG4vI3NjdG4tcmVnaXN0ZXJpbmctYS1uZXctY3JlZGVudGlhbCBXM0MgV2ViQXV0aG4gU3BlYyAtIFJlZ2lzdHJhdGlvbiBDZXJlbW9ueX1cbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvUHVibGljS2V5Q3JlZGVudGlhbENyZWF0aW9uT3B0aW9ucyBNRE4gLSBQdWJsaWNLZXlDcmVkZW50aWFsQ3JlYXRpb25PcHRpb25zfVxuICAgICAqL1xuICAgIGFzeW5jIF9yZWdpc3Rlcih7IGZyaWVuZGx5TmFtZSwgcnBJZCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93LmxvY2F0aW9uLmhvc3RuYW1lIDogdW5kZWZpbmVkLCBycE9yaWdpbnMgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IFt3aW5kb3cubG9jYXRpb24ub3JpZ2luXSA6IHVuZGVmaW5lZCwgc2lnbmFsLCB9LCBvdmVycmlkZXMpIHtcbiAgICAgICAgaWYgKCFycElkKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgICAgICAgICAgZXJyb3I6IG5ldyBBdXRoRXJyb3IoJ3JwSWQgaXMgcmVxdWlyZWQgZm9yIFdlYkF1dGhuIHJlZ2lzdHJhdGlvbicpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKCFicm93c2VyU3VwcG9ydHNXZWJBdXRobigpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6IG5ldyBBdXRoVW5rbm93bkVycm9yKCdCcm93c2VyIGRvZXMgbm90IHN1cHBvcnQgV2ViQXV0aG4nLCBudWxsKSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRW5yb2xsIGZhY3RvclxuICAgICAgICAgICAgY29uc3QgeyBkYXRhOiBmYWN0b3IsIGVycm9yOiBlbnJvbGxFcnJvciB9ID0gYXdhaXQgdGhpcy5fZW5yb2xsKHtcbiAgICAgICAgICAgICAgICBmcmllbmRseU5hbWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICghZmFjdG9yKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5jbGllbnQubWZhXG4gICAgICAgICAgICAgICAgICAgIC5saXN0RmFjdG9ycygpXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKChmYWN0b3JzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChfYSA9IGZhY3RvcnMuZGF0YSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFsbC5maW5kKCh2KSA9PiB2LmZhY3Rvcl90eXBlID09PSAnd2ViYXV0aG4nICYmXG4gICAgICAgICAgICAgICAgICAgICAgICB2LmZyaWVuZGx5X25hbWUgPT09IGZyaWVuZGx5TmFtZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgdi5zdGF0dXMgIT09ICd1bnZlcmlmaWVkJyk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oKGZhY3RvcikgPT4gKGZhY3RvciA/IHRoaXMuY2xpZW50Lm1mYS51bmVucm9sbCh7IGZhY3RvcklkOiBmYWN0b3IgPT09IG51bGwgfHwgZmFjdG9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmYWN0b3IuaWQgfSkgOiB2b2lkIDApKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvcjogZW5yb2xsRXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEdldCBjaGFsbGVuZ2UgYW5kIGNyZWF0ZSBjcmVkZW50aWFsXG4gICAgICAgICAgICBjb25zdCB7IGRhdGE6IGNoYWxsZW5nZVJlc3BvbnNlLCBlcnJvcjogY2hhbGxlbmdlRXJyb3IgfSA9IGF3YWl0IHRoaXMuX2NoYWxsZW5nZSh7XG4gICAgICAgICAgICAgICAgZmFjdG9ySWQ6IGZhY3Rvci5pZCxcbiAgICAgICAgICAgICAgICBmcmllbmRseU5hbWU6IGZhY3Rvci5mcmllbmRseV9uYW1lLFxuICAgICAgICAgICAgICAgIHdlYmF1dGhuOiB7IHJwSWQsIHJwT3JpZ2lucyB9LFxuICAgICAgICAgICAgICAgIHNpZ25hbCxcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBjcmVhdGU6IG92ZXJyaWRlcyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKCFjaGFsbGVuZ2VSZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yOiBjaGFsbGVuZ2VFcnJvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ZlcmlmeSh7XG4gICAgICAgICAgICAgICAgZmFjdG9ySWQ6IGZhY3Rvci5pZCxcbiAgICAgICAgICAgICAgICBjaGFsbGVuZ2VJZDogY2hhbGxlbmdlUmVzcG9uc2UuY2hhbGxlbmdlSWQsXG4gICAgICAgICAgICAgICAgd2ViYXV0aG46IHtcbiAgICAgICAgICAgICAgICAgICAgcnBJZCxcbiAgICAgICAgICAgICAgICAgICAgcnBPcmlnaW5zLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBjaGFsbGVuZ2VSZXNwb25zZS53ZWJhdXRobi50eXBlLFxuICAgICAgICAgICAgICAgICAgICBjcmVkZW50aWFsX3Jlc3BvbnNlOiBjaGFsbGVuZ2VSZXNwb25zZS53ZWJhdXRobi5jcmVkZW50aWFsX3Jlc3BvbnNlLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkYXRhOiBudWxsLFxuICAgICAgICAgICAgICAgIGVycm9yOiBuZXcgQXV0aFVua25vd25FcnJvcignVW5leHBlY3RlZCBlcnJvciBpbiByZWdpc3RlcicsIGVycm9yKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD13ZWJhdXRobi5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/lib/webauthn.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/functions-js/dist/module/FunctionsClient.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@supabase/functions-js/dist/module/FunctionsClient.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FunctionsClient: () => (/* binding */ FunctionsClient)\n/* harmony export */ });\n/* harmony import */ var _helper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helper */ \"(app-pages-browser)/./node_modules/@supabase/functions-js/dist/module/helper.js\");\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types */ \"(app-pages-browser)/./node_modules/@supabase/functions-js/dist/module/types.js\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\nclass FunctionsClient {\n    constructor(url, { headers = {}, customFetch, region = _types__WEBPACK_IMPORTED_MODULE_0__.FunctionRegion.Any, } = {}) {\n        this.url = url;\n        this.headers = headers;\n        this.region = region;\n        this.fetch = (0,_helper__WEBPACK_IMPORTED_MODULE_1__.resolveFetch)(customFetch);\n    }\n    /**\n     * Updates the authorization header\n     * @param token - the new jwt token sent in the authorisation header\n     */\n    setAuth(token) {\n        this.headers.Authorization = `Bearer ${token}`;\n    }\n    /**\n     * Invokes a function\n     * @param functionName - The name of the Function to invoke.\n     * @param options - Options for invoking the Function.\n     */\n    invoke(functionName_1) {\n        return __awaiter(this, arguments, void 0, function* (functionName, options = {}) {\n            var _a;\n            try {\n                const { headers, method, body: functionArgs, signal } = options;\n                let _headers = {};\n                let { region } = options;\n                if (!region) {\n                    region = this.region;\n                }\n                // Add region as query parameter using URL API\n                const url = new URL(`${this.url}/${functionName}`);\n                if (region && region !== 'any') {\n                    _headers['x-region'] = region;\n                    url.searchParams.set('forceFunctionRegion', region);\n                }\n                let body;\n                if (functionArgs &&\n                    ((headers && !Object.prototype.hasOwnProperty.call(headers, 'Content-Type')) || !headers)) {\n                    if ((typeof Blob !== 'undefined' && functionArgs instanceof Blob) ||\n                        functionArgs instanceof ArrayBuffer) {\n                        // will work for File as File inherits Blob\n                        // also works for ArrayBuffer as it is the same underlying structure as a Blob\n                        _headers['Content-Type'] = 'application/octet-stream';\n                        body = functionArgs;\n                    }\n                    else if (typeof functionArgs === 'string') {\n                        // plain string\n                        _headers['Content-Type'] = 'text/plain';\n                        body = functionArgs;\n                    }\n                    else if (typeof FormData !== 'undefined' && functionArgs instanceof FormData) {\n                        // don't set content-type headers\n                        // Request will automatically add the right boundary value\n                        body = functionArgs;\n                    }\n                    else {\n                        // default, assume this is JSON\n                        _headers['Content-Type'] = 'application/json';\n                        body = JSON.stringify(functionArgs);\n                    }\n                }\n                const response = yield this.fetch(url.toString(), {\n                    method: method || 'POST',\n                    // headers priority is (high to low):\n                    // 1. invoke-level headers\n                    // 2. client-level headers\n                    // 3. default Content-Type header\n                    headers: Object.assign(Object.assign(Object.assign({}, _headers), this.headers), headers),\n                    body,\n                    signal,\n                }).catch((fetchError) => {\n                    if (fetchError.name === 'AbortError') {\n                        throw fetchError;\n                    }\n                    throw new _types__WEBPACK_IMPORTED_MODULE_0__.FunctionsFetchError(fetchError);\n                });\n                const isRelayError = response.headers.get('x-relay-error');\n                if (isRelayError && isRelayError === 'true') {\n                    throw new _types__WEBPACK_IMPORTED_MODULE_0__.FunctionsRelayError(response);\n                }\n                if (!response.ok) {\n                    throw new _types__WEBPACK_IMPORTED_MODULE_0__.FunctionsHttpError(response);\n                }\n                let responseType = ((_a = response.headers.get('Content-Type')) !== null && _a !== void 0 ? _a : 'text/plain').split(';')[0].trim();\n                let data;\n                if (responseType === 'application/json') {\n                    data = yield response.json();\n                }\n                else if (responseType === 'application/octet-stream') {\n                    data = yield response.blob();\n                }\n                else if (responseType === 'text/event-stream') {\n                    data = response;\n                }\n                else if (responseType === 'multipart/form-data') {\n                    data = yield response.formData();\n                }\n                else {\n                    // default to text\n                    data = yield response.text();\n                }\n                return { data, error: null, response };\n            }\n            catch (error) {\n                if (error instanceof Error && error.name === 'AbortError') {\n                    return { data: null, error: new _types__WEBPACK_IMPORTED_MODULE_0__.FunctionsFetchError(error) };\n                }\n                return {\n                    data: null,\n                    error,\n                    response: error instanceof _types__WEBPACK_IMPORTED_MODULE_0__.FunctionsHttpError || error instanceof _types__WEBPACK_IMPORTED_MODULE_0__.FunctionsRelayError\n                        ? error.context\n                        : undefined,\n                };\n            }\n        });\n    }\n}\n//# sourceMappingURL=FunctionsClient.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvZnVuY3Rpb25zLWpzL2Rpc3QvbW9kdWxlL0Z1bmN0aW9uc0NsaWVudC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSxpQkFBaUIsU0FBSSxJQUFJLFNBQUk7QUFDN0IsNEJBQTRCLCtEQUErRCxpQkFBaUI7QUFDNUc7QUFDQSxvQ0FBb0MsTUFBTSwrQkFBK0IsWUFBWTtBQUNyRixtQ0FBbUMsTUFBTSxtQ0FBbUMsWUFBWTtBQUN4RixnQ0FBZ0M7QUFDaEM7QUFDQSxLQUFLO0FBQ0w7QUFDd0M7QUFDZ0U7QUFDakc7QUFDUCx1QkFBdUIsWUFBWSx3QkFBd0Isa0RBQWMsUUFBUSxJQUFJO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixxREFBWTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsTUFBTTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVGQUF1RjtBQUN2RjtBQUNBO0FBQ0Esd0JBQXdCLDhDQUE4QztBQUN0RTtBQUNBLHNCQUFzQixTQUFTO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFNBQVMsR0FBRyxhQUFhO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RTtBQUN6RTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qix1REFBbUI7QUFDakQsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSw4QkFBOEIsdURBQW1CO0FBQ2pEO0FBQ0E7QUFDQSw4QkFBOEIsc0RBQWtCO0FBQ2hEO0FBQ0EsdUlBQXVJO0FBQ3ZJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHVCQUF1Qix1REFBbUI7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0Msc0RBQWtCLHFCQUFxQix1REFBbUI7QUFDekc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBIiwic291cmNlcyI6WyJEOlxcbmV4dFxcb3JnXFxub2RlX21vZHVsZXNcXEBzdXBhYmFzZVxcZnVuY3Rpb25zLWpzXFxkaXN0XFxtb2R1bGVcXEZ1bmN0aW9uc0NsaWVudC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbmltcG9ydCB7IHJlc29sdmVGZXRjaCB9IGZyb20gJy4vaGVscGVyJztcbmltcG9ydCB7IEZ1bmN0aW9uUmVnaW9uLCBGdW5jdGlvbnNGZXRjaEVycm9yLCBGdW5jdGlvbnNIdHRwRXJyb3IsIEZ1bmN0aW9uc1JlbGF5RXJyb3IsIH0gZnJvbSAnLi90eXBlcyc7XG5leHBvcnQgY2xhc3MgRnVuY3Rpb25zQ2xpZW50IHtcbiAgICBjb25zdHJ1Y3Rvcih1cmwsIHsgaGVhZGVycyA9IHt9LCBjdXN0b21GZXRjaCwgcmVnaW9uID0gRnVuY3Rpb25SZWdpb24uQW55LCB9ID0ge30pIHtcbiAgICAgICAgdGhpcy51cmwgPSB1cmw7XG4gICAgICAgIHRoaXMuaGVhZGVycyA9IGhlYWRlcnM7XG4gICAgICAgIHRoaXMucmVnaW9uID0gcmVnaW9uO1xuICAgICAgICB0aGlzLmZldGNoID0gcmVzb2x2ZUZldGNoKGN1c3RvbUZldGNoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgYXV0aG9yaXphdGlvbiBoZWFkZXJcbiAgICAgKiBAcGFyYW0gdG9rZW4gLSB0aGUgbmV3IGp3dCB0b2tlbiBzZW50IGluIHRoZSBhdXRob3Jpc2F0aW9uIGhlYWRlclxuICAgICAqL1xuICAgIHNldEF1dGgodG9rZW4pIHtcbiAgICAgICAgdGhpcy5oZWFkZXJzLkF1dGhvcml6YXRpb24gPSBgQmVhcmVyICR7dG9rZW59YDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW52b2tlcyBhIGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIGZ1bmN0aW9uTmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBGdW5jdGlvbiB0byBpbnZva2UuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIGZvciBpbnZva2luZyB0aGUgRnVuY3Rpb24uXG4gICAgICovXG4gICAgaW52b2tlKGZ1bmN0aW9uTmFtZV8xKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgYXJndW1lbnRzLCB2b2lkIDAsIGZ1bmN0aW9uKiAoZnVuY3Rpb25OYW1lLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBoZWFkZXJzLCBtZXRob2QsIGJvZHk6IGZ1bmN0aW9uQXJncywgc2lnbmFsIH0gPSBvcHRpb25zO1xuICAgICAgICAgICAgICAgIGxldCBfaGVhZGVycyA9IHt9O1xuICAgICAgICAgICAgICAgIGxldCB7IHJlZ2lvbiB9ID0gb3B0aW9ucztcbiAgICAgICAgICAgICAgICBpZiAoIXJlZ2lvbikge1xuICAgICAgICAgICAgICAgICAgICByZWdpb24gPSB0aGlzLnJlZ2lvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQWRkIHJlZ2lvbiBhcyBxdWVyeSBwYXJhbWV0ZXIgdXNpbmcgVVJMIEFQSVxuICAgICAgICAgICAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoYCR7dGhpcy51cmx9LyR7ZnVuY3Rpb25OYW1lfWApO1xuICAgICAgICAgICAgICAgIGlmIChyZWdpb24gJiYgcmVnaW9uICE9PSAnYW55Jykge1xuICAgICAgICAgICAgICAgICAgICBfaGVhZGVyc1sneC1yZWdpb24nXSA9IHJlZ2lvbjtcbiAgICAgICAgICAgICAgICAgICAgdXJsLnNlYXJjaFBhcmFtcy5zZXQoJ2ZvcmNlRnVuY3Rpb25SZWdpb24nLCByZWdpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgYm9keTtcbiAgICAgICAgICAgICAgICBpZiAoZnVuY3Rpb25BcmdzICYmXG4gICAgICAgICAgICAgICAgICAgICgoaGVhZGVycyAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGhlYWRlcnMsICdDb250ZW50LVR5cGUnKSkgfHwgIWhlYWRlcnMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgodHlwZW9mIEJsb2IgIT09ICd1bmRlZmluZWQnICYmIGZ1bmN0aW9uQXJncyBpbnN0YW5jZW9mIEJsb2IpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbkFyZ3MgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2lsbCB3b3JrIGZvciBGaWxlIGFzIEZpbGUgaW5oZXJpdHMgQmxvYlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWxzbyB3b3JrcyBmb3IgQXJyYXlCdWZmZXIgYXMgaXQgaXMgdGhlIHNhbWUgdW5kZXJseWluZyBzdHJ1Y3R1cmUgYXMgYSBCbG9iXG4gICAgICAgICAgICAgICAgICAgICAgICBfaGVhZGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHkgPSBmdW5jdGlvbkFyZ3M7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGZ1bmN0aW9uQXJncyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHBsYWluIHN0cmluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgX2hlYWRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ3RleHQvcGxhaW4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgYm9keSA9IGZ1bmN0aW9uQXJncztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgRm9ybURhdGEgIT09ICd1bmRlZmluZWQnICYmIGZ1bmN0aW9uQXJncyBpbnN0YW5jZW9mIEZvcm1EYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBkb24ndCBzZXQgY29udGVudC10eXBlIGhlYWRlcnNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlcXVlc3Qgd2lsbCBhdXRvbWF0aWNhbGx5IGFkZCB0aGUgcmlnaHQgYm91bmRhcnkgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHkgPSBmdW5jdGlvbkFyZ3M7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBkZWZhdWx0LCBhc3N1bWUgdGhpcyBpcyBKU09OXG4gICAgICAgICAgICAgICAgICAgICAgICBfaGVhZGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5ID0gSlNPTi5zdHJpbmdpZnkoZnVuY3Rpb25BcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuZmV0Y2godXJsLnRvU3RyaW5nKCksIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBtZXRob2QgfHwgJ1BPU1QnLFxuICAgICAgICAgICAgICAgICAgICAvLyBoZWFkZXJzIHByaW9yaXR5IGlzIChoaWdoIHRvIGxvdyk6XG4gICAgICAgICAgICAgICAgICAgIC8vIDEuIGludm9rZS1sZXZlbCBoZWFkZXJzXG4gICAgICAgICAgICAgICAgICAgIC8vIDIuIGNsaWVudC1sZXZlbCBoZWFkZXJzXG4gICAgICAgICAgICAgICAgICAgIC8vIDMuIGRlZmF1bHQgQ29udGVudC1UeXBlIGhlYWRlclxuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgX2hlYWRlcnMpLCB0aGlzLmhlYWRlcnMpLCBoZWFkZXJzKSxcbiAgICAgICAgICAgICAgICAgICAgYm9keSxcbiAgICAgICAgICAgICAgICAgICAgc2lnbmFsLFxuICAgICAgICAgICAgICAgIH0pLmNhdGNoKChmZXRjaEVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmZXRjaEVycm9yLm5hbWUgPT09ICdBYm9ydEVycm9yJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZmV0Y2hFcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRnVuY3Rpb25zRmV0Y2hFcnJvcihmZXRjaEVycm9yKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCBpc1JlbGF5RXJyb3IgPSByZXNwb25zZS5oZWFkZXJzLmdldCgneC1yZWxheS1lcnJvcicpO1xuICAgICAgICAgICAgICAgIGlmIChpc1JlbGF5RXJyb3IgJiYgaXNSZWxheUVycm9yID09PSAndHJ1ZScpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZ1bmN0aW9uc1JlbGF5RXJyb3IocmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBGdW5jdGlvbnNIdHRwRXJyb3IocmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgcmVzcG9uc2VUeXBlID0gKChfYSA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdDb250ZW50LVR5cGUnKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJ3RleHQvcGxhaW4nKS5zcGxpdCgnOycpWzBdLnRyaW0oKTtcbiAgICAgICAgICAgICAgICBsZXQgZGF0YTtcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2VUeXBlID09PSAnYXBwbGljYXRpb24vanNvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IHlpZWxkIHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocmVzcG9uc2VUeXBlID09PSAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJykge1xuICAgICAgICAgICAgICAgICAgICBkYXRhID0geWllbGQgcmVzcG9uc2UuYmxvYigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyZXNwb25zZVR5cGUgPT09ICd0ZXh0L2V2ZW50LXN0cmVhbScpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyZXNwb25zZVR5cGUgPT09ICdtdWx0aXBhcnQvZm9ybS1kYXRhJykge1xuICAgICAgICAgICAgICAgICAgICBkYXRhID0geWllbGQgcmVzcG9uc2UuZm9ybURhdGEoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGRlZmF1bHQgdG8gdGV4dFxuICAgICAgICAgICAgICAgICAgICBkYXRhID0geWllbGQgcmVzcG9uc2UudGV4dCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhLCBlcnJvcjogbnVsbCwgcmVzcG9uc2UgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmIGVycm9yLm5hbWUgPT09ICdBYm9ydEVycm9yJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvcjogbmV3IEZ1bmN0aW9uc0ZldGNoRXJyb3IoZXJyb3IpIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgICAgICAgICByZXNwb25zZTogZXJyb3IgaW5zdGFuY2VvZiBGdW5jdGlvbnNIdHRwRXJyb3IgfHwgZXJyb3IgaW5zdGFuY2VvZiBGdW5jdGlvbnNSZWxheUVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGVycm9yLmNvbnRleHRcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUZ1bmN0aW9uc0NsaWVudC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/functions-js/dist/module/FunctionsClient.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/functions-js/dist/module/helper.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@supabase/functions-js/dist/module/helper.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   resolveFetch: () => (/* binding */ resolveFetch)\n/* harmony export */ });\nconst resolveFetch = (customFetch) => {\n    let _fetch;\n    if (customFetch) {\n        _fetch = customFetch;\n    }\n    else if (typeof fetch === 'undefined') {\n        _fetch = (...args) => Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! @supabase/node-fetch */ \"(app-pages-browser)/./node_modules/@supabase/node-fetch/browser.js\")).then(({ default: fetch }) => fetch(...args));\n    }\n    else {\n        _fetch = fetch;\n    }\n    return (...args) => _fetch(...args);\n};\n//# sourceMappingURL=helper.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvZnVuY3Rpb25zLWpzL2Rpc3QvbW9kdWxlL2hlbHBlci5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHNMQUE4QixTQUFTLGdCQUFnQjtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiRDpcXG5leHRcXG9yZ1xcbm9kZV9tb2R1bGVzXFxAc3VwYWJhc2VcXGZ1bmN0aW9ucy1qc1xcZGlzdFxcbW9kdWxlXFxoZWxwZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IHJlc29sdmVGZXRjaCA9IChjdXN0b21GZXRjaCkgPT4ge1xuICAgIGxldCBfZmV0Y2g7XG4gICAgaWYgKGN1c3RvbUZldGNoKSB7XG4gICAgICAgIF9mZXRjaCA9IGN1c3RvbUZldGNoO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgZmV0Y2ggPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIF9mZXRjaCA9ICguLi5hcmdzKSA9PiBpbXBvcnQoJ0BzdXBhYmFzZS9ub2RlLWZldGNoJykudGhlbigoeyBkZWZhdWx0OiBmZXRjaCB9KSA9PiBmZXRjaCguLi5hcmdzKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBfZmV0Y2ggPSBmZXRjaDtcbiAgICB9XG4gICAgcmV0dXJuICguLi5hcmdzKSA9PiBfZmV0Y2goLi4uYXJncyk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGVscGVyLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/functions-js/dist/module/helper.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/functions-js/dist/module/types.js":
/*!******************************************************************!*\
  !*** ./node_modules/@supabase/functions-js/dist/module/types.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FunctionRegion: () => (/* binding */ FunctionRegion),\n/* harmony export */   FunctionsError: () => (/* binding */ FunctionsError),\n/* harmony export */   FunctionsFetchError: () => (/* binding */ FunctionsFetchError),\n/* harmony export */   FunctionsHttpError: () => (/* binding */ FunctionsHttpError),\n/* harmony export */   FunctionsRelayError: () => (/* binding */ FunctionsRelayError)\n/* harmony export */ });\nclass FunctionsError extends Error {\n    constructor(message, name = 'FunctionsError', context) {\n        super(message);\n        this.name = name;\n        this.context = context;\n    }\n}\nclass FunctionsFetchError extends FunctionsError {\n    constructor(context) {\n        super('Failed to send a request to the Edge Function', 'FunctionsFetchError', context);\n    }\n}\nclass FunctionsRelayError extends FunctionsError {\n    constructor(context) {\n        super('Relay Error invoking the Edge Function', 'FunctionsRelayError', context);\n    }\n}\nclass FunctionsHttpError extends FunctionsError {\n    constructor(context) {\n        super('Edge Function returned a non-2xx status code', 'FunctionsHttpError', context);\n    }\n}\n// Define the enum for the 'region' property\nvar FunctionRegion;\n(function (FunctionRegion) {\n    FunctionRegion[\"Any\"] = \"any\";\n    FunctionRegion[\"ApNortheast1\"] = \"ap-northeast-1\";\n    FunctionRegion[\"ApNortheast2\"] = \"ap-northeast-2\";\n    FunctionRegion[\"ApSouth1\"] = \"ap-south-1\";\n    FunctionRegion[\"ApSoutheast1\"] = \"ap-southeast-1\";\n    FunctionRegion[\"ApSoutheast2\"] = \"ap-southeast-2\";\n    FunctionRegion[\"CaCentral1\"] = \"ca-central-1\";\n    FunctionRegion[\"EuCentral1\"] = \"eu-central-1\";\n    FunctionRegion[\"EuWest1\"] = \"eu-west-1\";\n    FunctionRegion[\"EuWest2\"] = \"eu-west-2\";\n    FunctionRegion[\"EuWest3\"] = \"eu-west-3\";\n    FunctionRegion[\"SaEast1\"] = \"sa-east-1\";\n    FunctionRegion[\"UsEast1\"] = \"us-east-1\";\n    FunctionRegion[\"UsWest1\"] = \"us-west-1\";\n    FunctionRegion[\"UsWest2\"] = \"us-west-2\";\n})(FunctionRegion || (FunctionRegion = {}));\n//# sourceMappingURL=types.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvZnVuY3Rpb25zLWpzL2Rpc3QvbW9kdWxlL3R5cGVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHdDQUF3QztBQUN6QyIsInNvdXJjZXMiOlsiRDpcXG5leHRcXG9yZ1xcbm9kZV9tb2R1bGVzXFxAc3VwYWJhc2VcXGZ1bmN0aW9ucy1qc1xcZGlzdFxcbW9kdWxlXFx0eXBlcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY2xhc3MgRnVuY3Rpb25zRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgbmFtZSA9ICdGdW5jdGlvbnNFcnJvcicsIGNvbnRleHQpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEZ1bmN0aW9uc0ZldGNoRXJyb3IgZXh0ZW5kcyBGdW5jdGlvbnNFcnJvciB7XG4gICAgY29uc3RydWN0b3IoY29udGV4dCkge1xuICAgICAgICBzdXBlcignRmFpbGVkIHRvIHNlbmQgYSByZXF1ZXN0IHRvIHRoZSBFZGdlIEZ1bmN0aW9uJywgJ0Z1bmN0aW9uc0ZldGNoRXJyb3InLCBjb250ZXh0KTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgRnVuY3Rpb25zUmVsYXlFcnJvciBleHRlbmRzIEZ1bmN0aW9uc0Vycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcihjb250ZXh0KSB7XG4gICAgICAgIHN1cGVyKCdSZWxheSBFcnJvciBpbnZva2luZyB0aGUgRWRnZSBGdW5jdGlvbicsICdGdW5jdGlvbnNSZWxheUVycm9yJywgY29udGV4dCk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEZ1bmN0aW9uc0h0dHBFcnJvciBleHRlbmRzIEZ1bmN0aW9uc0Vycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcihjb250ZXh0KSB7XG4gICAgICAgIHN1cGVyKCdFZGdlIEZ1bmN0aW9uIHJldHVybmVkIGEgbm9uLTJ4eCBzdGF0dXMgY29kZScsICdGdW5jdGlvbnNIdHRwRXJyb3InLCBjb250ZXh0KTtcbiAgICB9XG59XG4vLyBEZWZpbmUgdGhlIGVudW0gZm9yIHRoZSAncmVnaW9uJyBwcm9wZXJ0eVxuZXhwb3J0IHZhciBGdW5jdGlvblJlZ2lvbjtcbihmdW5jdGlvbiAoRnVuY3Rpb25SZWdpb24pIHtcbiAgICBGdW5jdGlvblJlZ2lvbltcIkFueVwiXSA9IFwiYW55XCI7XG4gICAgRnVuY3Rpb25SZWdpb25bXCJBcE5vcnRoZWFzdDFcIl0gPSBcImFwLW5vcnRoZWFzdC0xXCI7XG4gICAgRnVuY3Rpb25SZWdpb25bXCJBcE5vcnRoZWFzdDJcIl0gPSBcImFwLW5vcnRoZWFzdC0yXCI7XG4gICAgRnVuY3Rpb25SZWdpb25bXCJBcFNvdXRoMVwiXSA9IFwiYXAtc291dGgtMVwiO1xuICAgIEZ1bmN0aW9uUmVnaW9uW1wiQXBTb3V0aGVhc3QxXCJdID0gXCJhcC1zb3V0aGVhc3QtMVwiO1xuICAgIEZ1bmN0aW9uUmVnaW9uW1wiQXBTb3V0aGVhc3QyXCJdID0gXCJhcC1zb3V0aGVhc3QtMlwiO1xuICAgIEZ1bmN0aW9uUmVnaW9uW1wiQ2FDZW50cmFsMVwiXSA9IFwiY2EtY2VudHJhbC0xXCI7XG4gICAgRnVuY3Rpb25SZWdpb25bXCJFdUNlbnRyYWwxXCJdID0gXCJldS1jZW50cmFsLTFcIjtcbiAgICBGdW5jdGlvblJlZ2lvbltcIkV1V2VzdDFcIl0gPSBcImV1LXdlc3QtMVwiO1xuICAgIEZ1bmN0aW9uUmVnaW9uW1wiRXVXZXN0MlwiXSA9IFwiZXUtd2VzdC0yXCI7XG4gICAgRnVuY3Rpb25SZWdpb25bXCJFdVdlc3QzXCJdID0gXCJldS13ZXN0LTNcIjtcbiAgICBGdW5jdGlvblJlZ2lvbltcIlNhRWFzdDFcIl0gPSBcInNhLWVhc3QtMVwiO1xuICAgIEZ1bmN0aW9uUmVnaW9uW1wiVXNFYXN0MVwiXSA9IFwidXMtZWFzdC0xXCI7XG4gICAgRnVuY3Rpb25SZWdpb25bXCJVc1dlc3QxXCJdID0gXCJ1cy13ZXN0LTFcIjtcbiAgICBGdW5jdGlvblJlZ2lvbltcIlVzV2VzdDJcIl0gPSBcInVzLXdlc3QtMlwiO1xufSkoRnVuY3Rpb25SZWdpb24gfHwgKEZ1bmN0aW9uUmVnaW9uID0ge30pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXR5cGVzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/functions-js/dist/module/types.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/node-fetch/browser.js":
/*!******************************************************!*\
  !*** ./node_modules/@supabase/node-fetch/browser.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Headers: () => (/* binding */ Headers),\n/* harmony export */   Request: () => (/* binding */ Request),\n/* harmony export */   Response: () => (/* binding */ Response),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   fetch: () => (/* binding */ fetch)\n/* harmony export */ });\n\n\n// ref: https://github.com/tc39/proposal-global\nvar getGlobal = function() {\n    // the only reliable means to get the global object is\n    // `Function('return this')()`\n    // However, this causes CSP violations in Chrome apps.\n    if (typeof self !== 'undefined') { return self; }\n    if (typeof window !== 'undefined') { return window; }\n    if (typeof __webpack_require__.g !== 'undefined') { return __webpack_require__.g; }\n    throw new Error('unable to locate global object');\n}\n\nvar globalObject = getGlobal();\n\nconst fetch = globalObject.fetch;\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (globalObject.fetch.bind(globalObject));\n\nconst Headers = globalObject.Headers;\nconst Request = globalObject.Request;\nconst Response = globalObject.Response;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2Uvbm9kZS1mZXRjaC9icm93c2VyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2Qyx5Q0FBeUM7QUFDekMsZUFBZSxxQkFBTSxvQkFBb0IsT0FBTyxxQkFBTTtBQUN0RDtBQUNBOztBQUVBOztBQUVPOztBQUVQLGlFQUFlLHFDQUFxQyxFQUFDOztBQUU5QztBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFxuZXh0XFxvcmdcXG5vZGVfbW9kdWxlc1xcQHN1cGFiYXNlXFxub2RlLWZldGNoXFxicm93c2VyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG4vLyByZWY6IGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLWdsb2JhbFxudmFyIGdldEdsb2JhbCA9IGZ1bmN0aW9uKCkge1xuICAgIC8vIHRoZSBvbmx5IHJlbGlhYmxlIG1lYW5zIHRvIGdldCB0aGUgZ2xvYmFsIG9iamVjdCBpc1xuICAgIC8vIGBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpYFxuICAgIC8vIEhvd2V2ZXIsIHRoaXMgY2F1c2VzIENTUCB2aW9sYXRpb25zIGluIENocm9tZSBhcHBzLlxuICAgIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcpIHsgcmV0dXJuIHNlbGY7IH1cbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHsgcmV0dXJuIHdpbmRvdzsgfVxuICAgIGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykgeyByZXR1cm4gZ2xvYmFsOyB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCd1bmFibGUgdG8gbG9jYXRlIGdsb2JhbCBvYmplY3QnKTtcbn1cblxudmFyIGdsb2JhbE9iamVjdCA9IGdldEdsb2JhbCgpO1xuXG5leHBvcnQgY29uc3QgZmV0Y2ggPSBnbG9iYWxPYmplY3QuZmV0Y2g7XG5cbmV4cG9ydCBkZWZhdWx0IGdsb2JhbE9iamVjdC5mZXRjaC5iaW5kKGdsb2JhbE9iamVjdCk7XG5cbmV4cG9ydCBjb25zdCBIZWFkZXJzID0gZ2xvYmFsT2JqZWN0LkhlYWRlcnM7XG5leHBvcnQgY29uc3QgUmVxdWVzdCA9IGdsb2JhbE9iamVjdC5SZXF1ZXN0O1xuZXhwb3J0IGNvbnN0IFJlc3BvbnNlID0gZ2xvYmFsT2JqZWN0LlJlc3BvbnNlO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/node-fetch/browser.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestBuilder.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestBuilder.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n// @ts-ignore\nconst node_fetch_1 = __importDefault(__webpack_require__(/*! @supabase/node-fetch */ \"(app-pages-browser)/./node_modules/@supabase/node-fetch/browser.js\"));\nconst PostgrestError_1 = __importDefault(__webpack_require__(/*! ./PostgrestError */ \"(app-pages-browser)/./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestError.js\"));\nclass PostgrestBuilder {\n    constructor(builder) {\n        var _a, _b;\n        this.shouldThrowOnError = false;\n        this.method = builder.method;\n        this.url = builder.url;\n        this.headers = new Headers(builder.headers);\n        this.schema = builder.schema;\n        this.body = builder.body;\n        this.shouldThrowOnError = (_a = builder.shouldThrowOnError) !== null && _a !== void 0 ? _a : false;\n        this.signal = builder.signal;\n        this.isMaybeSingle = (_b = builder.isMaybeSingle) !== null && _b !== void 0 ? _b : false;\n        if (builder.fetch) {\n            this.fetch = builder.fetch;\n        }\n        else if (typeof fetch === 'undefined') {\n            this.fetch = node_fetch_1.default;\n        }\n        else {\n            this.fetch = fetch;\n        }\n    }\n    /**\n     * If there's an error with the query, throwOnError will reject the promise by\n     * throwing the error instead of returning it as part of a successful response.\n     *\n     * {@link https://github.com/supabase/supabase-js/issues/92}\n     */\n    throwOnError() {\n        this.shouldThrowOnError = true;\n        return this;\n    }\n    /**\n     * Set an HTTP header for the request.\n     */\n    setHeader(name, value) {\n        this.headers = new Headers(this.headers);\n        this.headers.set(name, value);\n        return this;\n    }\n    then(onfulfilled, onrejected) {\n        // https://postgrest.org/en/stable/api.html#switching-schemas\n        if (this.schema === undefined) {\n            // skip\n        }\n        else if (['GET', 'HEAD'].includes(this.method)) {\n            this.headers.set('Accept-Profile', this.schema);\n        }\n        else {\n            this.headers.set('Content-Profile', this.schema);\n        }\n        if (this.method !== 'GET' && this.method !== 'HEAD') {\n            this.headers.set('Content-Type', 'application/json');\n        }\n        // NOTE: Invoke w/o `this` to avoid illegal invocation error.\n        // https://github.com/supabase/postgrest-js/pull/247\n        const _fetch = this.fetch;\n        let res = _fetch(this.url.toString(), {\n            method: this.method,\n            headers: this.headers,\n            body: JSON.stringify(this.body),\n            signal: this.signal,\n        }).then(async (res) => {\n            var _a, _b, _c, _d;\n            let error = null;\n            let data = null;\n            let count = null;\n            let status = res.status;\n            let statusText = res.statusText;\n            if (res.ok) {\n                if (this.method !== 'HEAD') {\n                    const body = await res.text();\n                    if (body === '') {\n                        // Prefer: return=minimal\n                    }\n                    else if (this.headers.get('Accept') === 'text/csv') {\n                        data = body;\n                    }\n                    else if (this.headers.get('Accept') &&\n                        ((_a = this.headers.get('Accept')) === null || _a === void 0 ? void 0 : _a.includes('application/vnd.pgrst.plan+text'))) {\n                        data = body;\n                    }\n                    else {\n                        data = JSON.parse(body);\n                    }\n                }\n                const countHeader = (_b = this.headers.get('Prefer')) === null || _b === void 0 ? void 0 : _b.match(/count=(exact|planned|estimated)/);\n                const contentRange = (_c = res.headers.get('content-range')) === null || _c === void 0 ? void 0 : _c.split('/');\n                if (countHeader && contentRange && contentRange.length > 1) {\n                    count = parseInt(contentRange[1]);\n                }\n                // Temporary partial fix for https://github.com/supabase/postgrest-js/issues/361\n                // Issue persists e.g. for `.insert([...]).select().maybeSingle()`\n                if (this.isMaybeSingle && this.method === 'GET' && Array.isArray(data)) {\n                    if (data.length > 1) {\n                        error = {\n                            // https://github.com/PostgREST/postgrest/blob/a867d79c42419af16c18c3fb019eba8df992626f/src/PostgREST/Error.hs#L553\n                            code: 'PGRST116',\n                            details: `Results contain ${data.length} rows, application/vnd.pgrst.object+json requires 1 row`,\n                            hint: null,\n                            message: 'JSON object requested, multiple (or no) rows returned',\n                        };\n                        data = null;\n                        count = null;\n                        status = 406;\n                        statusText = 'Not Acceptable';\n                    }\n                    else if (data.length === 1) {\n                        data = data[0];\n                    }\n                    else {\n                        data = null;\n                    }\n                }\n            }\n            else {\n                const body = await res.text();\n                try {\n                    error = JSON.parse(body);\n                    // Workaround for https://github.com/supabase/postgrest-js/issues/295\n                    if (Array.isArray(error) && res.status === 404) {\n                        data = [];\n                        error = null;\n                        status = 200;\n                        statusText = 'OK';\n                    }\n                }\n                catch (_e) {\n                    // Workaround for https://github.com/supabase/postgrest-js/issues/295\n                    if (res.status === 404 && body === '') {\n                        status = 204;\n                        statusText = 'No Content';\n                    }\n                    else {\n                        error = {\n                            message: body,\n                        };\n                    }\n                }\n                if (error && this.isMaybeSingle && ((_d = error === null || error === void 0 ? void 0 : error.details) === null || _d === void 0 ? void 0 : _d.includes('0 rows'))) {\n                    error = null;\n                    status = 200;\n                    statusText = 'OK';\n                }\n                if (error && this.shouldThrowOnError) {\n                    throw new PostgrestError_1.default(error);\n                }\n            }\n            const postgrestResponse = {\n                error,\n                data,\n                count,\n                status,\n                statusText,\n            };\n            return postgrestResponse;\n        });\n        if (!this.shouldThrowOnError) {\n            res = res.catch((fetchError) => {\n                var _a, _b, _c;\n                return ({\n                    error: {\n                        message: `${(_a = fetchError === null || fetchError === void 0 ? void 0 : fetchError.name) !== null && _a !== void 0 ? _a : 'FetchError'}: ${fetchError === null || fetchError === void 0 ? void 0 : fetchError.message}`,\n                        details: `${(_b = fetchError === null || fetchError === void 0 ? void 0 : fetchError.stack) !== null && _b !== void 0 ? _b : ''}`,\n                        hint: '',\n                        code: `${(_c = fetchError === null || fetchError === void 0 ? void 0 : fetchError.code) !== null && _c !== void 0 ? _c : ''}`,\n                    },\n                    data: null,\n                    count: null,\n                    status: 0,\n                    statusText: '',\n                });\n            });\n        }\n        return res.then(onfulfilled, onrejected);\n    }\n    /**\n     * Override the type of the returned `data`.\n     *\n     * @typeParam NewResult - The new result type to override with\n     * @deprecated Use overrideTypes<yourType, { merge: false }>() method at the end of your call chain instead\n     */\n    returns() {\n        /* istanbul ignore next */\n        return this;\n    }\n    /**\n     * Override the type of the returned `data` field in the response.\n     *\n     * @typeParam NewResult - The new type to cast the response data to\n     * @typeParam Options - Optional type configuration (defaults to { merge: true })\n     * @typeParam Options.merge - When true, merges the new type with existing return type. When false, replaces the existing types entirely (defaults to true)\n     * @example\n     * ```typescript\n     * // Merge with existing types (default behavior)\n     * const query = supabase\n     *   .from('users')\n     *   .select()\n     *   .overrideTypes<{ custom_field: string }>()\n     *\n     * // Replace existing types completely\n     * const replaceQuery = supabase\n     *   .from('users')\n     *   .select()\n     *   .overrideTypes<{ id: number; name: string }, { merge: false }>()\n     * ```\n     * @returns A PostgrestBuilder instance with the new type\n     */\n    overrideTypes() {\n        return this;\n    }\n}\nexports[\"default\"] = PostgrestBuilder;\n//# sourceMappingURL=PostgrestBuilder.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcG9zdGdyZXN0LWpzL2Rpc3QvY2pzL1Bvc3RncmVzdEJ1aWxkZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RDtBQUNBLHFDQUFxQyxtQkFBTyxDQUFDLGdHQUFzQjtBQUNuRSx5Q0FBeUMsbUJBQU8sQ0FBQyw4R0FBa0I7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsYUFBYTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyw2SEFBNkgsSUFBSSwyRUFBMkU7QUFDaFAsb0NBQW9DLG9IQUFvSDtBQUN4SjtBQUNBLGlDQUFpQyxtSEFBbUg7QUFDcEoscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxjQUFjO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSxhQUFhO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHNCQUFzQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFlBQVksY0FBYyxJQUFJLGNBQWM7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBZTtBQUNmIiwic291cmNlcyI6WyJEOlxcbmV4dFxcb3JnXFxub2RlX21vZHVsZXNcXEBzdXBhYmFzZVxccG9zdGdyZXN0LWpzXFxkaXN0XFxjanNcXFBvc3RncmVzdEJ1aWxkZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vLyBAdHMtaWdub3JlXG5jb25zdCBub2RlX2ZldGNoXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIkBzdXBhYmFzZS9ub2RlLWZldGNoXCIpKTtcbmNvbnN0IFBvc3RncmVzdEVycm9yXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vUG9zdGdyZXN0RXJyb3JcIikpO1xuY2xhc3MgUG9zdGdyZXN0QnVpbGRlciB7XG4gICAgY29uc3RydWN0b3IoYnVpbGRlcikge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICB0aGlzLnNob3VsZFRocm93T25FcnJvciA9IGZhbHNlO1xuICAgICAgICB0aGlzLm1ldGhvZCA9IGJ1aWxkZXIubWV0aG9kO1xuICAgICAgICB0aGlzLnVybCA9IGJ1aWxkZXIudXJsO1xuICAgICAgICB0aGlzLmhlYWRlcnMgPSBuZXcgSGVhZGVycyhidWlsZGVyLmhlYWRlcnMpO1xuICAgICAgICB0aGlzLnNjaGVtYSA9IGJ1aWxkZXIuc2NoZW1hO1xuICAgICAgICB0aGlzLmJvZHkgPSBidWlsZGVyLmJvZHk7XG4gICAgICAgIHRoaXMuc2hvdWxkVGhyb3dPbkVycm9yID0gKF9hID0gYnVpbGRlci5zaG91bGRUaHJvd09uRXJyb3IpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZhbHNlO1xuICAgICAgICB0aGlzLnNpZ25hbCA9IGJ1aWxkZXIuc2lnbmFsO1xuICAgICAgICB0aGlzLmlzTWF5YmVTaW5nbGUgPSAoX2IgPSBidWlsZGVyLmlzTWF5YmVTaW5nbGUpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGZhbHNlO1xuICAgICAgICBpZiAoYnVpbGRlci5mZXRjaCkge1xuICAgICAgICAgICAgdGhpcy5mZXRjaCA9IGJ1aWxkZXIuZmV0Y2g7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGZldGNoID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhpcy5mZXRjaCA9IG5vZGVfZmV0Y2hfMS5kZWZhdWx0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5mZXRjaCA9IGZldGNoO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElmIHRoZXJlJ3MgYW4gZXJyb3Igd2l0aCB0aGUgcXVlcnksIHRocm93T25FcnJvciB3aWxsIHJlamVjdCB0aGUgcHJvbWlzZSBieVxuICAgICAqIHRocm93aW5nIHRoZSBlcnJvciBpbnN0ZWFkIG9mIHJldHVybmluZyBpdCBhcyBwYXJ0IG9mIGEgc3VjY2Vzc2Z1bCByZXNwb25zZS5cbiAgICAgKlxuICAgICAqIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vc3VwYWJhc2Uvc3VwYWJhc2UtanMvaXNzdWVzLzkyfVxuICAgICAqL1xuICAgIHRocm93T25FcnJvcigpIHtcbiAgICAgICAgdGhpcy5zaG91bGRUaHJvd09uRXJyb3IgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IGFuIEhUVFAgaGVhZGVyIGZvciB0aGUgcmVxdWVzdC5cbiAgICAgKi9cbiAgICBzZXRIZWFkZXIobmFtZSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5oZWFkZXJzID0gbmV3IEhlYWRlcnModGhpcy5oZWFkZXJzKTtcbiAgICAgICAgdGhpcy5oZWFkZXJzLnNldChuYW1lLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB0aGVuKG9uZnVsZmlsbGVkLCBvbnJlamVjdGVkKSB7XG4gICAgICAgIC8vIGh0dHBzOi8vcG9zdGdyZXN0Lm9yZy9lbi9zdGFibGUvYXBpLmh0bWwjc3dpdGNoaW5nLXNjaGVtYXNcbiAgICAgICAgaWYgKHRoaXMuc2NoZW1hID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIHNraXBcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChbJ0dFVCcsICdIRUFEJ10uaW5jbHVkZXModGhpcy5tZXRob2QpKSB7XG4gICAgICAgICAgICB0aGlzLmhlYWRlcnMuc2V0KCdBY2NlcHQtUHJvZmlsZScsIHRoaXMuc2NoZW1hKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaGVhZGVycy5zZXQoJ0NvbnRlbnQtUHJvZmlsZScsIHRoaXMuc2NoZW1hKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5tZXRob2QgIT09ICdHRVQnICYmIHRoaXMubWV0aG9kICE9PSAnSEVBRCcpIHtcbiAgICAgICAgICAgIHRoaXMuaGVhZGVycy5zZXQoJ0NvbnRlbnQtVHlwZScsICdhcHBsaWNhdGlvbi9qc29uJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTk9URTogSW52b2tlIHcvbyBgdGhpc2AgdG8gYXZvaWQgaWxsZWdhbCBpbnZvY2F0aW9uIGVycm9yLlxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vc3VwYWJhc2UvcG9zdGdyZXN0LWpzL3B1bGwvMjQ3XG4gICAgICAgIGNvbnN0IF9mZXRjaCA9IHRoaXMuZmV0Y2g7XG4gICAgICAgIGxldCByZXMgPSBfZmV0Y2godGhpcy51cmwudG9TdHJpbmcoKSwge1xuICAgICAgICAgICAgbWV0aG9kOiB0aGlzLm1ldGhvZCxcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHRoaXMuYm9keSksXG4gICAgICAgICAgICBzaWduYWw6IHRoaXMuc2lnbmFsLFxuICAgICAgICB9KS50aGVuKGFzeW5jIChyZXMpID0+IHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgICAgIGxldCBlcnJvciA9IG51bGw7XG4gICAgICAgICAgICBsZXQgZGF0YSA9IG51bGw7XG4gICAgICAgICAgICBsZXQgY291bnQgPSBudWxsO1xuICAgICAgICAgICAgbGV0IHN0YXR1cyA9IHJlcy5zdGF0dXM7XG4gICAgICAgICAgICBsZXQgc3RhdHVzVGV4dCA9IHJlcy5zdGF0dXNUZXh0O1xuICAgICAgICAgICAgaWYgKHJlcy5vaykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm1ldGhvZCAhPT0gJ0hFQUQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBhd2FpdCByZXMudGV4dCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYm9keSA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFByZWZlcjogcmV0dXJuPW1pbmltYWxcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLmhlYWRlcnMuZ2V0KCdBY2NlcHQnKSA9PT0gJ3RleHQvY3N2Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGJvZHk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5oZWFkZXJzLmdldCgnQWNjZXB0JykgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICgoX2EgPSB0aGlzLmhlYWRlcnMuZ2V0KCdBY2NlcHQnKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmluY2x1ZGVzKCdhcHBsaWNhdGlvbi92bmQucGdyc3QucGxhbit0ZXh0JykpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gYm9keTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBKU09OLnBhcnNlKGJvZHkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGNvdW50SGVhZGVyID0gKF9iID0gdGhpcy5oZWFkZXJzLmdldCgnUHJlZmVyJykpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5tYXRjaCgvY291bnQ9KGV4YWN0fHBsYW5uZWR8ZXN0aW1hdGVkKS8pO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRlbnRSYW5nZSA9IChfYyA9IHJlcy5oZWFkZXJzLmdldCgnY29udGVudC1yYW5nZScpKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Muc3BsaXQoJy8nKTtcbiAgICAgICAgICAgICAgICBpZiAoY291bnRIZWFkZXIgJiYgY29udGVudFJhbmdlICYmIGNvbnRlbnRSYW5nZS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ID0gcGFyc2VJbnQoY29udGVudFJhbmdlWzFdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVGVtcG9yYXJ5IHBhcnRpYWwgZml4IGZvciBodHRwczovL2dpdGh1Yi5jb20vc3VwYWJhc2UvcG9zdGdyZXN0LWpzL2lzc3Vlcy8zNjFcbiAgICAgICAgICAgICAgICAvLyBJc3N1ZSBwZXJzaXN0cyBlLmcuIGZvciBgLmluc2VydChbLi4uXSkuc2VsZWN0KCkubWF5YmVTaW5nbGUoKWBcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc01heWJlU2luZ2xlICYmIHRoaXMubWV0aG9kID09PSAnR0VUJyAmJiBBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9Qb3N0Z1JFU1QvcG9zdGdyZXN0L2Jsb2IvYTg2N2Q3OWM0MjQxOWFmMTZjMThjM2ZiMDE5ZWJhOGRmOTkyNjI2Zi9zcmMvUG9zdGdSRVNUL0Vycm9yLmhzI0w1NTNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiAnUEdSU1QxMTYnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRldGFpbHM6IGBSZXN1bHRzIGNvbnRhaW4gJHtkYXRhLmxlbmd0aH0gcm93cywgYXBwbGljYXRpb24vdm5kLnBncnN0Lm9iamVjdCtqc29uIHJlcXVpcmVzIDEgcm93YCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaW50OiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdKU09OIG9iamVjdCByZXF1ZXN0ZWQsIG11bHRpcGxlIChvciBubykgcm93cyByZXR1cm5lZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXMgPSA0MDY7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXNUZXh0ID0gJ05vdCBBY2NlcHRhYmxlJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChkYXRhLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGRhdGFbMF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBhd2FpdCByZXMudGV4dCgpO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yID0gSlNPTi5wYXJzZShib2R5KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gV29ya2Fyb3VuZCBmb3IgaHR0cHM6Ly9naXRodWIuY29tL3N1cGFiYXNlL3Bvc3RncmVzdC1qcy9pc3N1ZXMvMjk1XG4gICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGVycm9yKSAmJiByZXMuc3RhdHVzID09PSA0MDQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1cyA9IDIwMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1c1RleHQgPSAnT0snO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChfZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBXb3JrYXJvdW5kIGZvciBodHRwczovL2dpdGh1Yi5jb20vc3VwYWJhc2UvcG9zdGdyZXN0LWpzL2lzc3Vlcy8yOTVcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlcy5zdGF0dXMgPT09IDQwNCAmJiBib2R5ID09PSAnJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzID0gMjA0O1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzVGV4dCA9ICdObyBDb250ZW50JztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGJvZHksXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChlcnJvciAmJiB0aGlzLmlzTWF5YmVTaW5nbGUgJiYgKChfZCA9IGVycm9yID09PSBudWxsIHx8IGVycm9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlcnJvci5kZXRhaWxzKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuaW5jbHVkZXMoJzAgcm93cycpKSkge1xuICAgICAgICAgICAgICAgICAgICBlcnJvciA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cyA9IDIwMDtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzVGV4dCA9ICdPSyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChlcnJvciAmJiB0aGlzLnNob3VsZFRocm93T25FcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUG9zdGdyZXN0RXJyb3JfMS5kZWZhdWx0KGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwb3N0Z3Jlc3RSZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgICAgIGNvdW50LFxuICAgICAgICAgICAgICAgIHN0YXR1cyxcbiAgICAgICAgICAgICAgICBzdGF0dXNUZXh0LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBwb3N0Z3Jlc3RSZXNwb25zZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghdGhpcy5zaG91bGRUaHJvd09uRXJyb3IpIHtcbiAgICAgICAgICAgIHJlcyA9IHJlcy5jYXRjaCgoZmV0Y2hFcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICAgICAgICAgIHJldHVybiAoe1xuICAgICAgICAgICAgICAgICAgICBlcnJvcjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogYCR7KF9hID0gZmV0Y2hFcnJvciA9PT0gbnVsbCB8fCBmZXRjaEVycm9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmZXRjaEVycm9yLm5hbWUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICdGZXRjaEVycm9yJ306ICR7ZmV0Y2hFcnJvciA9PT0gbnVsbCB8fCBmZXRjaEVycm9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmZXRjaEVycm9yLm1lc3NhZ2V9YCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRldGFpbHM6IGAkeyhfYiA9IGZldGNoRXJyb3IgPT09IG51bGwgfHwgZmV0Y2hFcnJvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZmV0Y2hFcnJvci5zdGFjaykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogJyd9YCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhpbnQ6ICcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogYCR7KF9jID0gZmV0Y2hFcnJvciA9PT0gbnVsbCB8fCBmZXRjaEVycm9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmZXRjaEVycm9yLmNvZGUpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6ICcnfWAsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIGNvdW50OiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IDAsXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1c1RleHQ6ICcnLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcy50aGVuKG9uZnVsZmlsbGVkLCBvbnJlamVjdGVkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGUgdGhlIHR5cGUgb2YgdGhlIHJldHVybmVkIGBkYXRhYC5cbiAgICAgKlxuICAgICAqIEB0eXBlUGFyYW0gTmV3UmVzdWx0IC0gVGhlIG5ldyByZXN1bHQgdHlwZSB0byBvdmVycmlkZSB3aXRoXG4gICAgICogQGRlcHJlY2F0ZWQgVXNlIG92ZXJyaWRlVHlwZXM8eW91clR5cGUsIHsgbWVyZ2U6IGZhbHNlIH0+KCkgbWV0aG9kIGF0IHRoZSBlbmQgb2YgeW91ciBjYWxsIGNoYWluIGluc3RlYWRcbiAgICAgKi9cbiAgICByZXR1cm5zKCkge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGUgdGhlIHR5cGUgb2YgdGhlIHJldHVybmVkIGBkYXRhYCBmaWVsZCBpbiB0aGUgcmVzcG9uc2UuXG4gICAgICpcbiAgICAgKiBAdHlwZVBhcmFtIE5ld1Jlc3VsdCAtIFRoZSBuZXcgdHlwZSB0byBjYXN0IHRoZSByZXNwb25zZSBkYXRhIHRvXG4gICAgICogQHR5cGVQYXJhbSBPcHRpb25zIC0gT3B0aW9uYWwgdHlwZSBjb25maWd1cmF0aW9uIChkZWZhdWx0cyB0byB7IG1lcmdlOiB0cnVlIH0pXG4gICAgICogQHR5cGVQYXJhbSBPcHRpb25zLm1lcmdlIC0gV2hlbiB0cnVlLCBtZXJnZXMgdGhlIG5ldyB0eXBlIHdpdGggZXhpc3RpbmcgcmV0dXJuIHR5cGUuIFdoZW4gZmFsc2UsIHJlcGxhY2VzIHRoZSBleGlzdGluZyB0eXBlcyBlbnRpcmVseSAoZGVmYXVsdHMgdG8gdHJ1ZSlcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiAvLyBNZXJnZSB3aXRoIGV4aXN0aW5nIHR5cGVzIChkZWZhdWx0IGJlaGF2aW9yKVxuICAgICAqIGNvbnN0IHF1ZXJ5ID0gc3VwYWJhc2VcbiAgICAgKiAgIC5mcm9tKCd1c2VycycpXG4gICAgICogICAuc2VsZWN0KClcbiAgICAgKiAgIC5vdmVycmlkZVR5cGVzPHsgY3VzdG9tX2ZpZWxkOiBzdHJpbmcgfT4oKVxuICAgICAqXG4gICAgICogLy8gUmVwbGFjZSBleGlzdGluZyB0eXBlcyBjb21wbGV0ZWx5XG4gICAgICogY29uc3QgcmVwbGFjZVF1ZXJ5ID0gc3VwYWJhc2VcbiAgICAgKiAgIC5mcm9tKCd1c2VycycpXG4gICAgICogICAuc2VsZWN0KClcbiAgICAgKiAgIC5vdmVycmlkZVR5cGVzPHsgaWQ6IG51bWJlcjsgbmFtZTogc3RyaW5nIH0sIHsgbWVyZ2U6IGZhbHNlIH0+KClcbiAgICAgKiBgYGBcbiAgICAgKiBAcmV0dXJucyBBIFBvc3RncmVzdEJ1aWxkZXIgaW5zdGFuY2Ugd2l0aCB0aGUgbmV3IHR5cGVcbiAgICAgKi9cbiAgICBvdmVycmlkZVR5cGVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBQb3N0Z3Jlc3RCdWlsZGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UG9zdGdyZXN0QnVpbGRlci5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestBuilder.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestClient.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestClient.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst PostgrestQueryBuilder_1 = __importDefault(__webpack_require__(/*! ./PostgrestQueryBuilder */ \"(app-pages-browser)/./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestQueryBuilder.js\"));\nconst PostgrestFilterBuilder_1 = __importDefault(__webpack_require__(/*! ./PostgrestFilterBuilder */ \"(app-pages-browser)/./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestFilterBuilder.js\"));\n/**\n * PostgREST client.\n *\n * @typeParam Database - Types for the schema from the [type\n * generator](https://supabase.com/docs/reference/javascript/next/typescript-support)\n *\n * @typeParam SchemaName - Postgres schema to switch to. Must be a string\n * literal, the same one passed to the constructor. If the schema is not\n * `\"public\"`, this must be supplied manually.\n */\nclass PostgrestClient {\n    // TODO: Add back shouldThrowOnError once we figure out the typings\n    /**\n     * Creates a PostgREST client.\n     *\n     * @param url - URL of the PostgREST endpoint\n     * @param options - Named parameters\n     * @param options.headers - Custom headers\n     * @param options.schema - Postgres schema to switch to\n     * @param options.fetch - Custom fetch\n     */\n    constructor(url, { headers = {}, schema, fetch, } = {}) {\n        this.url = url;\n        this.headers = new Headers(headers);\n        this.schemaName = schema;\n        this.fetch = fetch;\n    }\n    /**\n     * Perform a query on a table or a view.\n     *\n     * @param relation - The table or view name to query\n     */\n    from(relation) {\n        const url = new URL(`${this.url}/${relation}`);\n        return new PostgrestQueryBuilder_1.default(url, {\n            headers: new Headers(this.headers),\n            schema: this.schemaName,\n            fetch: this.fetch,\n        });\n    }\n    /**\n     * Select a schema to query or perform an function (rpc) call.\n     *\n     * The schema needs to be on the list of exposed schemas inside Supabase.\n     *\n     * @param schema - The schema to query\n     */\n    schema(schema) {\n        return new PostgrestClient(this.url, {\n            headers: this.headers,\n            schema,\n            fetch: this.fetch,\n        });\n    }\n    /**\n     * Perform a function call.\n     *\n     * @param fn - The function name to call\n     * @param args - The arguments to pass to the function call\n     * @param options - Named parameters\n     * @param options.head - When set to `true`, `data` will not be returned.\n     * Useful if you only need the count.\n     * @param options.get - When set to `true`, the function will be called with\n     * read-only access mode.\n     * @param options.count - Count algorithm to use to count rows returned by the\n     * function. Only applicable for [set-returning\n     * functions](https://www.postgresql.org/docs/current/functions-srf.html).\n     *\n     * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n     * hood.\n     *\n     * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n     * statistics under the hood.\n     *\n     * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n     * numbers.\n     */\n    rpc(fn, args = {}, { head = false, get = false, count, } = {}) {\n        var _a;\n        let method;\n        const url = new URL(`${this.url}/rpc/${fn}`);\n        let body;\n        if (head || get) {\n            method = head ? 'HEAD' : 'GET';\n            Object.entries(args)\n                // params with undefined value needs to be filtered out, otherwise it'll\n                // show up as `?param=undefined`\n                .filter(([_, value]) => value !== undefined)\n                // array values need special syntax\n                .map(([name, value]) => [name, Array.isArray(value) ? `{${value.join(',')}}` : `${value}`])\n                .forEach(([name, value]) => {\n                url.searchParams.append(name, value);\n            });\n        }\n        else {\n            method = 'POST';\n            body = args;\n        }\n        const headers = new Headers(this.headers);\n        if (count) {\n            headers.set('Prefer', `count=${count}`);\n        }\n        return new PostgrestFilterBuilder_1.default({\n            method,\n            url,\n            headers,\n            schema: this.schemaName,\n            body,\n            fetch: (_a = this.fetch) !== null && _a !== void 0 ? _a : fetch,\n        });\n    }\n}\nexports[\"default\"] = PostgrestClient;\n//# sourceMappingURL=PostgrestClient.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcG9zdGdyZXN0LWpzL2Rpc3QvY2pzL1Bvc3RncmVzdENsaWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdEQUFnRCxtQkFBTyxDQUFDLDRIQUF5QjtBQUNqRixpREFBaUQsbUJBQU8sQ0FBQyw4SEFBMEI7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFlBQVksbUJBQW1CLElBQUk7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixTQUFTLEdBQUcsU0FBUztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsSUFBSSxvQ0FBb0MsSUFBSTtBQUNqRTtBQUNBO0FBQ0EsK0JBQStCLFNBQVMsT0FBTyxHQUFHO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0UsRUFBRSxpQkFBaUIsT0FBTyxNQUFNO0FBQ3hHO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsTUFBTTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxrQkFBZTtBQUNmIiwic291cmNlcyI6WyJEOlxcbmV4dFxcb3JnXFxub2RlX21vZHVsZXNcXEBzdXBhYmFzZVxccG9zdGdyZXN0LWpzXFxkaXN0XFxjanNcXFBvc3RncmVzdENsaWVudC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IFBvc3RncmVzdFF1ZXJ5QnVpbGRlcl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL1Bvc3RncmVzdFF1ZXJ5QnVpbGRlclwiKSk7XG5jb25zdCBQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vUG9zdGdyZXN0RmlsdGVyQnVpbGRlclwiKSk7XG4vKipcbiAqIFBvc3RnUkVTVCBjbGllbnQuXG4gKlxuICogQHR5cGVQYXJhbSBEYXRhYmFzZSAtIFR5cGVzIGZvciB0aGUgc2NoZW1hIGZyb20gdGhlIFt0eXBlXG4gKiBnZW5lcmF0b3JdKGh0dHBzOi8vc3VwYWJhc2UuY29tL2RvY3MvcmVmZXJlbmNlL2phdmFzY3JpcHQvbmV4dC90eXBlc2NyaXB0LXN1cHBvcnQpXG4gKlxuICogQHR5cGVQYXJhbSBTY2hlbWFOYW1lIC0gUG9zdGdyZXMgc2NoZW1hIHRvIHN3aXRjaCB0by4gTXVzdCBiZSBhIHN0cmluZ1xuICogbGl0ZXJhbCwgdGhlIHNhbWUgb25lIHBhc3NlZCB0byB0aGUgY29uc3RydWN0b3IuIElmIHRoZSBzY2hlbWEgaXMgbm90XG4gKiBgXCJwdWJsaWNcImAsIHRoaXMgbXVzdCBiZSBzdXBwbGllZCBtYW51YWxseS5cbiAqL1xuY2xhc3MgUG9zdGdyZXN0Q2xpZW50IHtcbiAgICAvLyBUT0RPOiBBZGQgYmFjayBzaG91bGRUaHJvd09uRXJyb3Igb25jZSB3ZSBmaWd1cmUgb3V0IHRoZSB0eXBpbmdzXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIFBvc3RnUkVTVCBjbGllbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdXJsIC0gVVJMIG9mIHRoZSBQb3N0Z1JFU1QgZW5kcG9pbnRcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIE5hbWVkIHBhcmFtZXRlcnNcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5oZWFkZXJzIC0gQ3VzdG9tIGhlYWRlcnNcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5zY2hlbWEgLSBQb3N0Z3JlcyBzY2hlbWEgdG8gc3dpdGNoIHRvXG4gICAgICogQHBhcmFtIG9wdGlvbnMuZmV0Y2ggLSBDdXN0b20gZmV0Y2hcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih1cmwsIHsgaGVhZGVycyA9IHt9LCBzY2hlbWEsIGZldGNoLCB9ID0ge30pIHtcbiAgICAgICAgdGhpcy51cmwgPSB1cmw7XG4gICAgICAgIHRoaXMuaGVhZGVycyA9IG5ldyBIZWFkZXJzKGhlYWRlcnMpO1xuICAgICAgICB0aGlzLnNjaGVtYU5hbWUgPSBzY2hlbWE7XG4gICAgICAgIHRoaXMuZmV0Y2ggPSBmZXRjaDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGVyZm9ybSBhIHF1ZXJ5IG9uIGEgdGFibGUgb3IgYSB2aWV3LlxuICAgICAqXG4gICAgICogQHBhcmFtIHJlbGF0aW9uIC0gVGhlIHRhYmxlIG9yIHZpZXcgbmFtZSB0byBxdWVyeVxuICAgICAqL1xuICAgIGZyb20ocmVsYXRpb24pIHtcbiAgICAgICAgY29uc3QgdXJsID0gbmV3IFVSTChgJHt0aGlzLnVybH0vJHtyZWxhdGlvbn1gKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQb3N0Z3Jlc3RRdWVyeUJ1aWxkZXJfMS5kZWZhdWx0KHVybCwge1xuICAgICAgICAgICAgaGVhZGVyczogbmV3IEhlYWRlcnModGhpcy5oZWFkZXJzKSxcbiAgICAgICAgICAgIHNjaGVtYTogdGhpcy5zY2hlbWFOYW1lLFxuICAgICAgICAgICAgZmV0Y2g6IHRoaXMuZmV0Y2gsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZWxlY3QgYSBzY2hlbWEgdG8gcXVlcnkgb3IgcGVyZm9ybSBhbiBmdW5jdGlvbiAocnBjKSBjYWxsLlxuICAgICAqXG4gICAgICogVGhlIHNjaGVtYSBuZWVkcyB0byBiZSBvbiB0aGUgbGlzdCBvZiBleHBvc2VkIHNjaGVtYXMgaW5zaWRlIFN1cGFiYXNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHNjaGVtYSAtIFRoZSBzY2hlbWEgdG8gcXVlcnlcbiAgICAgKi9cbiAgICBzY2hlbWEoc2NoZW1hKSB7XG4gICAgICAgIHJldHVybiBuZXcgUG9zdGdyZXN0Q2xpZW50KHRoaXMudXJsLCB7XG4gICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICBzY2hlbWEsXG4gICAgICAgICAgICBmZXRjaDogdGhpcy5mZXRjaCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBlcmZvcm0gYSBmdW5jdGlvbiBjYWxsLlxuICAgICAqXG4gICAgICogQHBhcmFtIGZuIC0gVGhlIGZ1bmN0aW9uIG5hbWUgdG8gY2FsbFxuICAgICAqIEBwYXJhbSBhcmdzIC0gVGhlIGFyZ3VtZW50cyB0byBwYXNzIHRvIHRoZSBmdW5jdGlvbiBjYWxsXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBOYW1lZCBwYXJhbWV0ZXJzXG4gICAgICogQHBhcmFtIG9wdGlvbnMuaGVhZCAtIFdoZW4gc2V0IHRvIGB0cnVlYCwgYGRhdGFgIHdpbGwgbm90IGJlIHJldHVybmVkLlxuICAgICAqIFVzZWZ1bCBpZiB5b3Ugb25seSBuZWVkIHRoZSBjb3VudC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5nZXQgLSBXaGVuIHNldCB0byBgdHJ1ZWAsIHRoZSBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCB3aXRoXG4gICAgICogcmVhZC1vbmx5IGFjY2VzcyBtb2RlLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmNvdW50IC0gQ291bnQgYWxnb3JpdGhtIHRvIHVzZSB0byBjb3VudCByb3dzIHJldHVybmVkIGJ5IHRoZVxuICAgICAqIGZ1bmN0aW9uLiBPbmx5IGFwcGxpY2FibGUgZm9yIFtzZXQtcmV0dXJuaW5nXG4gICAgICogZnVuY3Rpb25zXShodHRwczovL3d3dy5wb3N0Z3Jlc3FsLm9yZy9kb2NzL2N1cnJlbnQvZnVuY3Rpb25zLXNyZi5odG1sKS5cbiAgICAgKlxuICAgICAqIGBcImV4YWN0XCJgOiBFeGFjdCBidXQgc2xvdyBjb3VudCBhbGdvcml0aG0uIFBlcmZvcm1zIGEgYENPVU5UKCopYCB1bmRlciB0aGVcbiAgICAgKiBob29kLlxuICAgICAqXG4gICAgICogYFwicGxhbm5lZFwiYDogQXBwcm94aW1hdGVkIGJ1dCBmYXN0IGNvdW50IGFsZ29yaXRobS4gVXNlcyB0aGUgUG9zdGdyZXNcbiAgICAgKiBzdGF0aXN0aWNzIHVuZGVyIHRoZSBob29kLlxuICAgICAqXG4gICAgICogYFwiZXN0aW1hdGVkXCJgOiBVc2VzIGV4YWN0IGNvdW50IGZvciBsb3cgbnVtYmVycyBhbmQgcGxhbm5lZCBjb3VudCBmb3IgaGlnaFxuICAgICAqIG51bWJlcnMuXG4gICAgICovXG4gICAgcnBjKGZuLCBhcmdzID0ge30sIHsgaGVhZCA9IGZhbHNlLCBnZXQgPSBmYWxzZSwgY291bnQsIH0gPSB7fSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGxldCBtZXRob2Q7XG4gICAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoYCR7dGhpcy51cmx9L3JwYy8ke2ZufWApO1xuICAgICAgICBsZXQgYm9keTtcbiAgICAgICAgaWYgKGhlYWQgfHwgZ2V0KSB7XG4gICAgICAgICAgICBtZXRob2QgPSBoZWFkID8gJ0hFQUQnIDogJ0dFVCc7XG4gICAgICAgICAgICBPYmplY3QuZW50cmllcyhhcmdzKVxuICAgICAgICAgICAgICAgIC8vIHBhcmFtcyB3aXRoIHVuZGVmaW5lZCB2YWx1ZSBuZWVkcyB0byBiZSBmaWx0ZXJlZCBvdXQsIG90aGVyd2lzZSBpdCdsbFxuICAgICAgICAgICAgICAgIC8vIHNob3cgdXAgYXMgYD9wYXJhbT11bmRlZmluZWRgXG4gICAgICAgICAgICAgICAgLmZpbHRlcigoW18sIHZhbHVlXSkgPT4gdmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAvLyBhcnJheSB2YWx1ZXMgbmVlZCBzcGVjaWFsIHN5bnRheFxuICAgICAgICAgICAgICAgIC5tYXAoKFtuYW1lLCB2YWx1ZV0pID0+IFtuYW1lLCBBcnJheS5pc0FycmF5KHZhbHVlKSA/IGB7JHt2YWx1ZS5qb2luKCcsJyl9fWAgOiBgJHt2YWx1ZX1gXSlcbiAgICAgICAgICAgICAgICAuZm9yRWFjaCgoW25hbWUsIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgICAgIHVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKG5hbWUsIHZhbHVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWV0aG9kID0gJ1BPU1QnO1xuICAgICAgICAgICAgYm9keSA9IGFyZ3M7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaGVhZGVycyA9IG5ldyBIZWFkZXJzKHRoaXMuaGVhZGVycyk7XG4gICAgICAgIGlmIChjb3VudCkge1xuICAgICAgICAgICAgaGVhZGVycy5zZXQoJ1ByZWZlcicsIGBjb3VudD0ke2NvdW50fWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUG9zdGdyZXN0RmlsdGVyQnVpbGRlcl8xLmRlZmF1bHQoe1xuICAgICAgICAgICAgbWV0aG9kLFxuICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICAgIHNjaGVtYTogdGhpcy5zY2hlbWFOYW1lLFxuICAgICAgICAgICAgYm9keSxcbiAgICAgICAgICAgIGZldGNoOiAoX2EgPSB0aGlzLmZldGNoKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmZXRjaCxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gUG9zdGdyZXN0Q2xpZW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UG9zdGdyZXN0Q2xpZW50LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestClient.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestError.js":
/*!************************************************************************!*\
  !*** ./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestError.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/**\n * Error format\n *\n * {@link https://postgrest.org/en/stable/api.html?highlight=options#errors-and-http-status-codes}\n */\nclass PostgrestError extends Error {\n    constructor(context) {\n        super(context.message);\n        this.name = 'PostgrestError';\n        this.details = context.details;\n        this.hint = context.hint;\n        this.code = context.code;\n    }\n}\nexports[\"default\"] = PostgrestError;\n//# sourceMappingURL=PostgrestError.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcG9zdGdyZXN0LWpzL2Rpc3QvY2pzL1Bvc3RncmVzdEVycm9yLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFlO0FBQ2YiLCJzb3VyY2VzIjpbIkQ6XFxuZXh0XFxvcmdcXG5vZGVfbW9kdWxlc1xcQHN1cGFiYXNlXFxwb3N0Z3Jlc3QtanNcXGRpc3RcXGNqc1xcUG9zdGdyZXN0RXJyb3IuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIEVycm9yIGZvcm1hdFxuICpcbiAqIHtAbGluayBodHRwczovL3Bvc3RncmVzdC5vcmcvZW4vc3RhYmxlL2FwaS5odG1sP2hpZ2hsaWdodD1vcHRpb25zI2Vycm9ycy1hbmQtaHR0cC1zdGF0dXMtY29kZXN9XG4gKi9cbmNsYXNzIFBvc3RncmVzdEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGNvbnRleHQpIHtcbiAgICAgICAgc3VwZXIoY29udGV4dC5tZXNzYWdlKTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ1Bvc3RncmVzdEVycm9yJztcbiAgICAgICAgdGhpcy5kZXRhaWxzID0gY29udGV4dC5kZXRhaWxzO1xuICAgICAgICB0aGlzLmhpbnQgPSBjb250ZXh0LmhpbnQ7XG4gICAgICAgIHRoaXMuY29kZSA9IGNvbnRleHQuY29kZTtcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBQb3N0Z3Jlc3RFcnJvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVBvc3RncmVzdEVycm9yLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestError.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestFilterBuilder.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestFilterBuilder.js ***!
  \********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst PostgrestTransformBuilder_1 = __importDefault(__webpack_require__(/*! ./PostgrestTransformBuilder */ \"(app-pages-browser)/./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestTransformBuilder.js\"));\nclass PostgrestFilterBuilder extends PostgrestTransformBuilder_1.default {\n    /**\n     * Match only rows where `column` is equal to `value`.\n     *\n     * To check if the value of `column` is NULL, you should use `.is()` instead.\n     *\n     * @param column - The column to filter on\n     * @param value - The value to filter with\n     */\n    eq(column, value) {\n        this.url.searchParams.append(column, `eq.${value}`);\n        return this;\n    }\n    /**\n     * Match only rows where `column` is not equal to `value`.\n     *\n     * @param column - The column to filter on\n     * @param value - The value to filter with\n     */\n    neq(column, value) {\n        this.url.searchParams.append(column, `neq.${value}`);\n        return this;\n    }\n    /**\n     * Match only rows where `column` is greater than `value`.\n     *\n     * @param column - The column to filter on\n     * @param value - The value to filter with\n     */\n    gt(column, value) {\n        this.url.searchParams.append(column, `gt.${value}`);\n        return this;\n    }\n    /**\n     * Match only rows where `column` is greater than or equal to `value`.\n     *\n     * @param column - The column to filter on\n     * @param value - The value to filter with\n     */\n    gte(column, value) {\n        this.url.searchParams.append(column, `gte.${value}`);\n        return this;\n    }\n    /**\n     * Match only rows where `column` is less than `value`.\n     *\n     * @param column - The column to filter on\n     * @param value - The value to filter with\n     */\n    lt(column, value) {\n        this.url.searchParams.append(column, `lt.${value}`);\n        return this;\n    }\n    /**\n     * Match only rows where `column` is less than or equal to `value`.\n     *\n     * @param column - The column to filter on\n     * @param value - The value to filter with\n     */\n    lte(column, value) {\n        this.url.searchParams.append(column, `lte.${value}`);\n        return this;\n    }\n    /**\n     * Match only rows where `column` matches `pattern` case-sensitively.\n     *\n     * @param column - The column to filter on\n     * @param pattern - The pattern to match with\n     */\n    like(column, pattern) {\n        this.url.searchParams.append(column, `like.${pattern}`);\n        return this;\n    }\n    /**\n     * Match only rows where `column` matches all of `patterns` case-sensitively.\n     *\n     * @param column - The column to filter on\n     * @param patterns - The patterns to match with\n     */\n    likeAllOf(column, patterns) {\n        this.url.searchParams.append(column, `like(all).{${patterns.join(',')}}`);\n        return this;\n    }\n    /**\n     * Match only rows where `column` matches any of `patterns` case-sensitively.\n     *\n     * @param column - The column to filter on\n     * @param patterns - The patterns to match with\n     */\n    likeAnyOf(column, patterns) {\n        this.url.searchParams.append(column, `like(any).{${patterns.join(',')}}`);\n        return this;\n    }\n    /**\n     * Match only rows where `column` matches `pattern` case-insensitively.\n     *\n     * @param column - The column to filter on\n     * @param pattern - The pattern to match with\n     */\n    ilike(column, pattern) {\n        this.url.searchParams.append(column, `ilike.${pattern}`);\n        return this;\n    }\n    /**\n     * Match only rows where `column` matches all of `patterns` case-insensitively.\n     *\n     * @param column - The column to filter on\n     * @param patterns - The patterns to match with\n     */\n    ilikeAllOf(column, patterns) {\n        this.url.searchParams.append(column, `ilike(all).{${patterns.join(',')}}`);\n        return this;\n    }\n    /**\n     * Match only rows where `column` matches any of `patterns` case-insensitively.\n     *\n     * @param column - The column to filter on\n     * @param patterns - The patterns to match with\n     */\n    ilikeAnyOf(column, patterns) {\n        this.url.searchParams.append(column, `ilike(any).{${patterns.join(',')}}`);\n        return this;\n    }\n    /**\n     * Match only rows where `column` IS `value`.\n     *\n     * For non-boolean columns, this is only relevant for checking if the value of\n     * `column` is NULL by setting `value` to `null`.\n     *\n     * For boolean columns, you can also set `value` to `true` or `false` and it\n     * will behave the same way as `.eq()`.\n     *\n     * @param column - The column to filter on\n     * @param value - The value to filter with\n     */\n    is(column, value) {\n        this.url.searchParams.append(column, `is.${value}`);\n        return this;\n    }\n    /**\n     * Match only rows where `column` is included in the `values` array.\n     *\n     * @param column - The column to filter on\n     * @param values - The values array to filter with\n     */\n    in(column, values) {\n        const cleanedValues = Array.from(new Set(values))\n            .map((s) => {\n            // handle postgrest reserved characters\n            // https://postgrest.org/en/v7.0.0/api.html#reserved-characters\n            if (typeof s === 'string' && new RegExp('[,()]').test(s))\n                return `\"${s}\"`;\n            else\n                return `${s}`;\n        })\n            .join(',');\n        this.url.searchParams.append(column, `in.(${cleanedValues})`);\n        return this;\n    }\n    /**\n     * Only relevant for jsonb, array, and range columns. Match only rows where\n     * `column` contains every element appearing in `value`.\n     *\n     * @param column - The jsonb, array, or range column to filter on\n     * @param value - The jsonb, array, or range value to filter with\n     */\n    contains(column, value) {\n        if (typeof value === 'string') {\n            // range types can be inclusive '[', ']' or exclusive '(', ')' so just\n            // keep it simple and accept a string\n            this.url.searchParams.append(column, `cs.${value}`);\n        }\n        else if (Array.isArray(value)) {\n            // array\n            this.url.searchParams.append(column, `cs.{${value.join(',')}}`);\n        }\n        else {\n            // json\n            this.url.searchParams.append(column, `cs.${JSON.stringify(value)}`);\n        }\n        return this;\n    }\n    /**\n     * Only relevant for jsonb, array, and range columns. Match only rows where\n     * every element appearing in `column` is contained by `value`.\n     *\n     * @param column - The jsonb, array, or range column to filter on\n     * @param value - The jsonb, array, or range value to filter with\n     */\n    containedBy(column, value) {\n        if (typeof value === 'string') {\n            // range\n            this.url.searchParams.append(column, `cd.${value}`);\n        }\n        else if (Array.isArray(value)) {\n            // array\n            this.url.searchParams.append(column, `cd.{${value.join(',')}}`);\n        }\n        else {\n            // json\n            this.url.searchParams.append(column, `cd.${JSON.stringify(value)}`);\n        }\n        return this;\n    }\n    /**\n     * Only relevant for range columns. Match only rows where every element in\n     * `column` is greater than any element in `range`.\n     *\n     * @param column - The range column to filter on\n     * @param range - The range to filter with\n     */\n    rangeGt(column, range) {\n        this.url.searchParams.append(column, `sr.${range}`);\n        return this;\n    }\n    /**\n     * Only relevant for range columns. Match only rows where every element in\n     * `column` is either contained in `range` or greater than any element in\n     * `range`.\n     *\n     * @param column - The range column to filter on\n     * @param range - The range to filter with\n     */\n    rangeGte(column, range) {\n        this.url.searchParams.append(column, `nxl.${range}`);\n        return this;\n    }\n    /**\n     * Only relevant for range columns. Match only rows where every element in\n     * `column` is less than any element in `range`.\n     *\n     * @param column - The range column to filter on\n     * @param range - The range to filter with\n     */\n    rangeLt(column, range) {\n        this.url.searchParams.append(column, `sl.${range}`);\n        return this;\n    }\n    /**\n     * Only relevant for range columns. Match only rows where every element in\n     * `column` is either contained in `range` or less than any element in\n     * `range`.\n     *\n     * @param column - The range column to filter on\n     * @param range - The range to filter with\n     */\n    rangeLte(column, range) {\n        this.url.searchParams.append(column, `nxr.${range}`);\n        return this;\n    }\n    /**\n     * Only relevant for range columns. Match only rows where `column` is\n     * mutually exclusive to `range` and there can be no element between the two\n     * ranges.\n     *\n     * @param column - The range column to filter on\n     * @param range - The range to filter with\n     */\n    rangeAdjacent(column, range) {\n        this.url.searchParams.append(column, `adj.${range}`);\n        return this;\n    }\n    /**\n     * Only relevant for array and range columns. Match only rows where\n     * `column` and `value` have an element in common.\n     *\n     * @param column - The array or range column to filter on\n     * @param value - The array or range value to filter with\n     */\n    overlaps(column, value) {\n        if (typeof value === 'string') {\n            // range\n            this.url.searchParams.append(column, `ov.${value}`);\n        }\n        else {\n            // array\n            this.url.searchParams.append(column, `ov.{${value.join(',')}}`);\n        }\n        return this;\n    }\n    /**\n     * Only relevant for text and tsvector columns. Match only rows where\n     * `column` matches the query string in `query`.\n     *\n     * @param column - The text or tsvector column to filter on\n     * @param query - The query text to match with\n     * @param options - Named parameters\n     * @param options.config - The text search configuration to use\n     * @param options.type - Change how the `query` text is interpreted\n     */\n    textSearch(column, query, { config, type } = {}) {\n        let typePart = '';\n        if (type === 'plain') {\n            typePart = 'pl';\n        }\n        else if (type === 'phrase') {\n            typePart = 'ph';\n        }\n        else if (type === 'websearch') {\n            typePart = 'w';\n        }\n        const configPart = config === undefined ? '' : `(${config})`;\n        this.url.searchParams.append(column, `${typePart}fts${configPart}.${query}`);\n        return this;\n    }\n    /**\n     * Match only rows where each column in `query` keys is equal to its\n     * associated value. Shorthand for multiple `.eq()`s.\n     *\n     * @param query - The object to filter with, with column names as keys mapped\n     * to their filter values\n     */\n    match(query) {\n        Object.entries(query).forEach(([column, value]) => {\n            this.url.searchParams.append(column, `eq.${value}`);\n        });\n        return this;\n    }\n    /**\n     * Match only rows which doesn't satisfy the filter.\n     *\n     * Unlike most filters, `opearator` and `value` are used as-is and need to\n     * follow [PostgREST\n     * syntax](https://postgrest.org/en/stable/api.html#operators). You also need\n     * to make sure they are properly sanitized.\n     *\n     * @param column - The column to filter on\n     * @param operator - The operator to be negated to filter with, following\n     * PostgREST syntax\n     * @param value - The value to filter with, following PostgREST syntax\n     */\n    not(column, operator, value) {\n        this.url.searchParams.append(column, `not.${operator}.${value}`);\n        return this;\n    }\n    /**\n     * Match only rows which satisfy at least one of the filters.\n     *\n     * Unlike most filters, `filters` is used as-is and needs to follow [PostgREST\n     * syntax](https://postgrest.org/en/stable/api.html#operators). You also need\n     * to make sure it's properly sanitized.\n     *\n     * It's currently not possible to do an `.or()` filter across multiple tables.\n     *\n     * @param filters - The filters to use, following PostgREST syntax\n     * @param options - Named parameters\n     * @param options.referencedTable - Set this to filter on referenced tables\n     * instead of the parent table\n     * @param options.foreignTable - Deprecated, use `referencedTable` instead\n     */\n    or(filters, { foreignTable, referencedTable = foreignTable, } = {}) {\n        const key = referencedTable ? `${referencedTable}.or` : 'or';\n        this.url.searchParams.append(key, `(${filters})`);\n        return this;\n    }\n    /**\n     * Match only rows which satisfy the filter. This is an escape hatch - you\n     * should use the specific filter methods wherever possible.\n     *\n     * Unlike most filters, `opearator` and `value` are used as-is and need to\n     * follow [PostgREST\n     * syntax](https://postgrest.org/en/stable/api.html#operators). You also need\n     * to make sure they are properly sanitized.\n     *\n     * @param column - The column to filter on\n     * @param operator - The operator to filter with, following PostgREST syntax\n     * @param value - The value to filter with, following PostgREST syntax\n     */\n    filter(column, operator, value) {\n        this.url.searchParams.append(column, `${operator}.${value}`);\n        return this;\n    }\n}\nexports[\"default\"] = PostgrestFilterBuilder;\n//# sourceMappingURL=PostgrestFilterBuilder.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcG9zdGdyZXN0LWpzL2Rpc3QvY2pzL1Bvc3RncmVzdEZpbHRlckJ1aWxkZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxvREFBb0QsbUJBQU8sQ0FBQyxvSUFBNkI7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsTUFBTTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsTUFBTTtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsTUFBTTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsTUFBTTtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsTUFBTTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsTUFBTTtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsUUFBUTtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsRUFBRSxvQkFBb0I7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELEVBQUUsb0JBQW9CO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxRQUFRO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ2YiLCJzb3VyY2VzIjpbIkQ6XFxuZXh0XFxvcmdcXG5vZGVfbW9kdWxlc1xcQHN1cGFiYXNlXFxwb3N0Z3Jlc3QtanNcXGRpc3RcXGNqc1xcUG9zdGdyZXN0RmlsdGVyQnVpbGRlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IFBvc3RncmVzdFRyYW5zZm9ybUJ1aWxkZXJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9Qb3N0Z3Jlc3RUcmFuc2Zvcm1CdWlsZGVyXCIpKTtcbmNsYXNzIFBvc3RncmVzdEZpbHRlckJ1aWxkZXIgZXh0ZW5kcyBQb3N0Z3Jlc3RUcmFuc2Zvcm1CdWlsZGVyXzEuZGVmYXVsdCB7XG4gICAgLyoqXG4gICAgICogTWF0Y2ggb25seSByb3dzIHdoZXJlIGBjb2x1bW5gIGlzIGVxdWFsIHRvIGB2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBUbyBjaGVjayBpZiB0aGUgdmFsdWUgb2YgYGNvbHVtbmAgaXMgTlVMTCwgeW91IHNob3VsZCB1c2UgYC5pcygpYCBpbnN0ZWFkLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbHVtbiAtIFRoZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG4gICAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGZpbHRlciB3aXRoXG4gICAgICovXG4gICAgZXEoY29sdW1uLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYGVxLiR7dmFsdWV9YCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgYGNvbHVtbmAgaXMgbm90IGVxdWFsIHRvIGB2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29sdW1uIC0gVGhlIGNvbHVtbiB0byBmaWx0ZXIgb25cbiAgICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gZmlsdGVyIHdpdGhcbiAgICAgKi9cbiAgICBuZXEoY29sdW1uLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYG5lcS4ke3ZhbHVlfWApO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWF0Y2ggb25seSByb3dzIHdoZXJlIGBjb2x1bW5gIGlzIGdyZWF0ZXIgdGhhbiBgdmFsdWVgLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbHVtbiAtIFRoZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG4gICAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGZpbHRlciB3aXRoXG4gICAgICovXG4gICAgZ3QoY29sdW1uLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYGd0LiR7dmFsdWV9YCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgYGNvbHVtbmAgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIGB2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29sdW1uIC0gVGhlIGNvbHVtbiB0byBmaWx0ZXIgb25cbiAgICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gZmlsdGVyIHdpdGhcbiAgICAgKi9cbiAgICBndGUoY29sdW1uLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYGd0ZS4ke3ZhbHVlfWApO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWF0Y2ggb25seSByb3dzIHdoZXJlIGBjb2x1bW5gIGlzIGxlc3MgdGhhbiBgdmFsdWVgLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbHVtbiAtIFRoZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG4gICAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGZpbHRlciB3aXRoXG4gICAgICovXG4gICAgbHQoY29sdW1uLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYGx0LiR7dmFsdWV9YCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgYGNvbHVtbmAgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGB2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29sdW1uIC0gVGhlIGNvbHVtbiB0byBmaWx0ZXIgb25cbiAgICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gZmlsdGVyIHdpdGhcbiAgICAgKi9cbiAgICBsdGUoY29sdW1uLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYGx0ZS4ke3ZhbHVlfWApO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWF0Y2ggb25seSByb3dzIHdoZXJlIGBjb2x1bW5gIG1hdGNoZXMgYHBhdHRlcm5gIGNhc2Utc2Vuc2l0aXZlbHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29sdW1uIC0gVGhlIGNvbHVtbiB0byBmaWx0ZXIgb25cbiAgICAgKiBAcGFyYW0gcGF0dGVybiAtIFRoZSBwYXR0ZXJuIHRvIG1hdGNoIHdpdGhcbiAgICAgKi9cbiAgICBsaWtlKGNvbHVtbiwgcGF0dGVybikge1xuICAgICAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYGxpa2UuJHtwYXR0ZXJufWApO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWF0Y2ggb25seSByb3dzIHdoZXJlIGBjb2x1bW5gIG1hdGNoZXMgYWxsIG9mIGBwYXR0ZXJuc2AgY2FzZS1zZW5zaXRpdmVseS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb2x1bW4gLSBUaGUgY29sdW1uIHRvIGZpbHRlciBvblxuICAgICAqIEBwYXJhbSBwYXR0ZXJucyAtIFRoZSBwYXR0ZXJucyB0byBtYXRjaCB3aXRoXG4gICAgICovXG4gICAgbGlrZUFsbE9mKGNvbHVtbiwgcGF0dGVybnMpIHtcbiAgICAgICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBsaWtlKGFsbCkueyR7cGF0dGVybnMuam9pbignLCcpfX1gKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1hdGNoIG9ubHkgcm93cyB3aGVyZSBgY29sdW1uYCBtYXRjaGVzIGFueSBvZiBgcGF0dGVybnNgIGNhc2Utc2Vuc2l0aXZlbHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29sdW1uIC0gVGhlIGNvbHVtbiB0byBmaWx0ZXIgb25cbiAgICAgKiBAcGFyYW0gcGF0dGVybnMgLSBUaGUgcGF0dGVybnMgdG8gbWF0Y2ggd2l0aFxuICAgICAqL1xuICAgIGxpa2VBbnlPZihjb2x1bW4sIHBhdHRlcm5zKSB7XG4gICAgICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgbGlrZShhbnkpLnske3BhdHRlcm5zLmpvaW4oJywnKX19YCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgYGNvbHVtbmAgbWF0Y2hlcyBgcGF0dGVybmAgY2FzZS1pbnNlbnNpdGl2ZWx5LlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbHVtbiAtIFRoZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG4gICAgICogQHBhcmFtIHBhdHRlcm4gLSBUaGUgcGF0dGVybiB0byBtYXRjaCB3aXRoXG4gICAgICovXG4gICAgaWxpa2UoY29sdW1uLCBwYXR0ZXJuKSB7XG4gICAgICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgaWxpa2UuJHtwYXR0ZXJufWApO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWF0Y2ggb25seSByb3dzIHdoZXJlIGBjb2x1bW5gIG1hdGNoZXMgYWxsIG9mIGBwYXR0ZXJuc2AgY2FzZS1pbnNlbnNpdGl2ZWx5LlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbHVtbiAtIFRoZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG4gICAgICogQHBhcmFtIHBhdHRlcm5zIC0gVGhlIHBhdHRlcm5zIHRvIG1hdGNoIHdpdGhcbiAgICAgKi9cbiAgICBpbGlrZUFsbE9mKGNvbHVtbiwgcGF0dGVybnMpIHtcbiAgICAgICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBpbGlrZShhbGwpLnske3BhdHRlcm5zLmpvaW4oJywnKX19YCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgYGNvbHVtbmAgbWF0Y2hlcyBhbnkgb2YgYHBhdHRlcm5zYCBjYXNlLWluc2Vuc2l0aXZlbHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29sdW1uIC0gVGhlIGNvbHVtbiB0byBmaWx0ZXIgb25cbiAgICAgKiBAcGFyYW0gcGF0dGVybnMgLSBUaGUgcGF0dGVybnMgdG8gbWF0Y2ggd2l0aFxuICAgICAqL1xuICAgIGlsaWtlQW55T2YoY29sdW1uLCBwYXR0ZXJucykge1xuICAgICAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYGlsaWtlKGFueSkueyR7cGF0dGVybnMuam9pbignLCcpfX1gKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1hdGNoIG9ubHkgcm93cyB3aGVyZSBgY29sdW1uYCBJUyBgdmFsdWVgLlxuICAgICAqXG4gICAgICogRm9yIG5vbi1ib29sZWFuIGNvbHVtbnMsIHRoaXMgaXMgb25seSByZWxldmFudCBmb3IgY2hlY2tpbmcgaWYgdGhlIHZhbHVlIG9mXG4gICAgICogYGNvbHVtbmAgaXMgTlVMTCBieSBzZXR0aW5nIGB2YWx1ZWAgdG8gYG51bGxgLlxuICAgICAqXG4gICAgICogRm9yIGJvb2xlYW4gY29sdW1ucywgeW91IGNhbiBhbHNvIHNldCBgdmFsdWVgIHRvIGB0cnVlYCBvciBgZmFsc2VgIGFuZCBpdFxuICAgICAqIHdpbGwgYmVoYXZlIHRoZSBzYW1lIHdheSBhcyBgLmVxKClgLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbHVtbiAtIFRoZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG4gICAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGZpbHRlciB3aXRoXG4gICAgICovXG4gICAgaXMoY29sdW1uLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYGlzLiR7dmFsdWV9YCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgYGNvbHVtbmAgaXMgaW5jbHVkZWQgaW4gdGhlIGB2YWx1ZXNgIGFycmF5LlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbHVtbiAtIFRoZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG4gICAgICogQHBhcmFtIHZhbHVlcyAtIFRoZSB2YWx1ZXMgYXJyYXkgdG8gZmlsdGVyIHdpdGhcbiAgICAgKi9cbiAgICBpbihjb2x1bW4sIHZhbHVlcykge1xuICAgICAgICBjb25zdCBjbGVhbmVkVmFsdWVzID0gQXJyYXkuZnJvbShuZXcgU2V0KHZhbHVlcykpXG4gICAgICAgICAgICAubWFwKChzKSA9PiB7XG4gICAgICAgICAgICAvLyBoYW5kbGUgcG9zdGdyZXN0IHJlc2VydmVkIGNoYXJhY3RlcnNcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vcG9zdGdyZXN0Lm9yZy9lbi92Ny4wLjAvYXBpLmh0bWwjcmVzZXJ2ZWQtY2hhcmFjdGVyc1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzID09PSAnc3RyaW5nJyAmJiBuZXcgUmVnRXhwKCdbLCgpXScpLnRlc3QocykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGBcIiR7c31cImA7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcmV0dXJuIGAke3N9YDtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5qb2luKCcsJyk7XG4gICAgICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgaW4uKCR7Y2xlYW5lZFZhbHVlc30pYCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPbmx5IHJlbGV2YW50IGZvciBqc29uYiwgYXJyYXksIGFuZCByYW5nZSBjb2x1bW5zLiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmVcbiAgICAgKiBgY29sdW1uYCBjb250YWlucyBldmVyeSBlbGVtZW50IGFwcGVhcmluZyBpbiBgdmFsdWVgLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbHVtbiAtIFRoZSBqc29uYiwgYXJyYXksIG9yIHJhbmdlIGNvbHVtbiB0byBmaWx0ZXIgb25cbiAgICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUganNvbmIsIGFycmF5LCBvciByYW5nZSB2YWx1ZSB0byBmaWx0ZXIgd2l0aFxuICAgICAqL1xuICAgIGNvbnRhaW5zKGNvbHVtbiwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIC8vIHJhbmdlIHR5cGVzIGNhbiBiZSBpbmNsdXNpdmUgJ1snLCAnXScgb3IgZXhjbHVzaXZlICcoJywgJyknIHNvIGp1c3RcbiAgICAgICAgICAgIC8vIGtlZXAgaXQgc2ltcGxlIGFuZCBhY2NlcHQgYSBzdHJpbmdcbiAgICAgICAgICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgY3MuJHt2YWx1ZX1gKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgLy8gYXJyYXlcbiAgICAgICAgICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgY3MueyR7dmFsdWUuam9pbignLCcpfX1gKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGpzb25cbiAgICAgICAgICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgY3MuJHtKU09OLnN0cmluZ2lmeSh2YWx1ZSl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE9ubHkgcmVsZXZhbnQgZm9yIGpzb25iLCBhcnJheSwgYW5kIHJhbmdlIGNvbHVtbnMuIE1hdGNoIG9ubHkgcm93cyB3aGVyZVxuICAgICAqIGV2ZXJ5IGVsZW1lbnQgYXBwZWFyaW5nIGluIGBjb2x1bW5gIGlzIGNvbnRhaW5lZCBieSBgdmFsdWVgLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbHVtbiAtIFRoZSBqc29uYiwgYXJyYXksIG9yIHJhbmdlIGNvbHVtbiB0byBmaWx0ZXIgb25cbiAgICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUganNvbmIsIGFycmF5LCBvciByYW5nZSB2YWx1ZSB0byBmaWx0ZXIgd2l0aFxuICAgICAqL1xuICAgIGNvbnRhaW5lZEJ5KGNvbHVtbiwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIC8vIHJhbmdlXG4gICAgICAgICAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYGNkLiR7dmFsdWV9YCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIC8vIGFycmF5XG4gICAgICAgICAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYGNkLnske3ZhbHVlLmpvaW4oJywnKX19YCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBqc29uXG4gICAgICAgICAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYGNkLiR7SlNPTi5zdHJpbmdpZnkodmFsdWUpfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPbmx5IHJlbGV2YW50IGZvciByYW5nZSBjb2x1bW5zLiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgZXZlcnkgZWxlbWVudCBpblxuICAgICAqIGBjb2x1bW5gIGlzIGdyZWF0ZXIgdGhhbiBhbnkgZWxlbWVudCBpbiBgcmFuZ2VgLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbHVtbiAtIFRoZSByYW5nZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG4gICAgICogQHBhcmFtIHJhbmdlIC0gVGhlIHJhbmdlIHRvIGZpbHRlciB3aXRoXG4gICAgICovXG4gICAgcmFuZ2VHdChjb2x1bW4sIHJhbmdlKSB7XG4gICAgICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgc3IuJHtyYW5nZX1gKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE9ubHkgcmVsZXZhbnQgZm9yIHJhbmdlIGNvbHVtbnMuIE1hdGNoIG9ubHkgcm93cyB3aGVyZSBldmVyeSBlbGVtZW50IGluXG4gICAgICogYGNvbHVtbmAgaXMgZWl0aGVyIGNvbnRhaW5lZCBpbiBgcmFuZ2VgIG9yIGdyZWF0ZXIgdGhhbiBhbnkgZWxlbWVudCBpblxuICAgICAqIGByYW5nZWAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29sdW1uIC0gVGhlIHJhbmdlIGNvbHVtbiB0byBmaWx0ZXIgb25cbiAgICAgKiBAcGFyYW0gcmFuZ2UgLSBUaGUgcmFuZ2UgdG8gZmlsdGVyIHdpdGhcbiAgICAgKi9cbiAgICByYW5nZUd0ZShjb2x1bW4sIHJhbmdlKSB7XG4gICAgICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgbnhsLiR7cmFuZ2V9YCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPbmx5IHJlbGV2YW50IGZvciByYW5nZSBjb2x1bW5zLiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgZXZlcnkgZWxlbWVudCBpblxuICAgICAqIGBjb2x1bW5gIGlzIGxlc3MgdGhhbiBhbnkgZWxlbWVudCBpbiBgcmFuZ2VgLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbHVtbiAtIFRoZSByYW5nZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG4gICAgICogQHBhcmFtIHJhbmdlIC0gVGhlIHJhbmdlIHRvIGZpbHRlciB3aXRoXG4gICAgICovXG4gICAgcmFuZ2VMdChjb2x1bW4sIHJhbmdlKSB7XG4gICAgICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgc2wuJHtyYW5nZX1gKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE9ubHkgcmVsZXZhbnQgZm9yIHJhbmdlIGNvbHVtbnMuIE1hdGNoIG9ubHkgcm93cyB3aGVyZSBldmVyeSBlbGVtZW50IGluXG4gICAgICogYGNvbHVtbmAgaXMgZWl0aGVyIGNvbnRhaW5lZCBpbiBgcmFuZ2VgIG9yIGxlc3MgdGhhbiBhbnkgZWxlbWVudCBpblxuICAgICAqIGByYW5nZWAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29sdW1uIC0gVGhlIHJhbmdlIGNvbHVtbiB0byBmaWx0ZXIgb25cbiAgICAgKiBAcGFyYW0gcmFuZ2UgLSBUaGUgcmFuZ2UgdG8gZmlsdGVyIHdpdGhcbiAgICAgKi9cbiAgICByYW5nZUx0ZShjb2x1bW4sIHJhbmdlKSB7XG4gICAgICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgbnhyLiR7cmFuZ2V9YCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPbmx5IHJlbGV2YW50IGZvciByYW5nZSBjb2x1bW5zLiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgYGNvbHVtbmAgaXNcbiAgICAgKiBtdXR1YWxseSBleGNsdXNpdmUgdG8gYHJhbmdlYCBhbmQgdGhlcmUgY2FuIGJlIG5vIGVsZW1lbnQgYmV0d2VlbiB0aGUgdHdvXG4gICAgICogcmFuZ2VzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbHVtbiAtIFRoZSByYW5nZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG4gICAgICogQHBhcmFtIHJhbmdlIC0gVGhlIHJhbmdlIHRvIGZpbHRlciB3aXRoXG4gICAgICovXG4gICAgcmFuZ2VBZGphY2VudChjb2x1bW4sIHJhbmdlKSB7XG4gICAgICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgYWRqLiR7cmFuZ2V9YCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPbmx5IHJlbGV2YW50IGZvciBhcnJheSBhbmQgcmFuZ2UgY29sdW1ucy4gTWF0Y2ggb25seSByb3dzIHdoZXJlXG4gICAgICogYGNvbHVtbmAgYW5kIGB2YWx1ZWAgaGF2ZSBhbiBlbGVtZW50IGluIGNvbW1vbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb2x1bW4gLSBUaGUgYXJyYXkgb3IgcmFuZ2UgY29sdW1uIHRvIGZpbHRlciBvblxuICAgICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBhcnJheSBvciByYW5nZSB2YWx1ZSB0byBmaWx0ZXIgd2l0aFxuICAgICAqL1xuICAgIG92ZXJsYXBzKGNvbHVtbiwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIC8vIHJhbmdlXG4gICAgICAgICAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYG92LiR7dmFsdWV9YCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBhcnJheVxuICAgICAgICAgICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBvdi57JHt2YWx1ZS5qb2luKCcsJyl9fWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPbmx5IHJlbGV2YW50IGZvciB0ZXh0IGFuZCB0c3ZlY3RvciBjb2x1bW5zLiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmVcbiAgICAgKiBgY29sdW1uYCBtYXRjaGVzIHRoZSBxdWVyeSBzdHJpbmcgaW4gYHF1ZXJ5YC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb2x1bW4gLSBUaGUgdGV4dCBvciB0c3ZlY3RvciBjb2x1bW4gdG8gZmlsdGVyIG9uXG4gICAgICogQHBhcmFtIHF1ZXJ5IC0gVGhlIHF1ZXJ5IHRleHQgdG8gbWF0Y2ggd2l0aFxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gTmFtZWQgcGFyYW1ldGVyc1xuICAgICAqIEBwYXJhbSBvcHRpb25zLmNvbmZpZyAtIFRoZSB0ZXh0IHNlYXJjaCBjb25maWd1cmF0aW9uIHRvIHVzZVxuICAgICAqIEBwYXJhbSBvcHRpb25zLnR5cGUgLSBDaGFuZ2UgaG93IHRoZSBgcXVlcnlgIHRleHQgaXMgaW50ZXJwcmV0ZWRcbiAgICAgKi9cbiAgICB0ZXh0U2VhcmNoKGNvbHVtbiwgcXVlcnksIHsgY29uZmlnLCB0eXBlIH0gPSB7fSkge1xuICAgICAgICBsZXQgdHlwZVBhcnQgPSAnJztcbiAgICAgICAgaWYgKHR5cGUgPT09ICdwbGFpbicpIHtcbiAgICAgICAgICAgIHR5cGVQYXJ0ID0gJ3BsJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlID09PSAncGhyYXNlJykge1xuICAgICAgICAgICAgdHlwZVBhcnQgPSAncGgnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGUgPT09ICd3ZWJzZWFyY2gnKSB7XG4gICAgICAgICAgICB0eXBlUGFydCA9ICd3JztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb25maWdQYXJ0ID0gY29uZmlnID09PSB1bmRlZmluZWQgPyAnJyA6IGAoJHtjb25maWd9KWA7XG4gICAgICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgJHt0eXBlUGFydH1mdHMke2NvbmZpZ1BhcnR9LiR7cXVlcnl9YCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgZWFjaCBjb2x1bW4gaW4gYHF1ZXJ5YCBrZXlzIGlzIGVxdWFsIHRvIGl0c1xuICAgICAqIGFzc29jaWF0ZWQgdmFsdWUuIFNob3J0aGFuZCBmb3IgbXVsdGlwbGUgYC5lcSgpYHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcXVlcnkgLSBUaGUgb2JqZWN0IHRvIGZpbHRlciB3aXRoLCB3aXRoIGNvbHVtbiBuYW1lcyBhcyBrZXlzIG1hcHBlZFxuICAgICAqIHRvIHRoZWlyIGZpbHRlciB2YWx1ZXNcbiAgICAgKi9cbiAgICBtYXRjaChxdWVyeSkge1xuICAgICAgICBPYmplY3QuZW50cmllcyhxdWVyeSkuZm9yRWFjaCgoW2NvbHVtbiwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYGVxLiR7dmFsdWV9YCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWF0Y2ggb25seSByb3dzIHdoaWNoIGRvZXNuJ3Qgc2F0aXNmeSB0aGUgZmlsdGVyLlxuICAgICAqXG4gICAgICogVW5saWtlIG1vc3QgZmlsdGVycywgYG9wZWFyYXRvcmAgYW5kIGB2YWx1ZWAgYXJlIHVzZWQgYXMtaXMgYW5kIG5lZWQgdG9cbiAgICAgKiBmb2xsb3cgW1Bvc3RnUkVTVFxuICAgICAqIHN5bnRheF0oaHR0cHM6Ly9wb3N0Z3Jlc3Qub3JnL2VuL3N0YWJsZS9hcGkuaHRtbCNvcGVyYXRvcnMpLiBZb3UgYWxzbyBuZWVkXG4gICAgICogdG8gbWFrZSBzdXJlIHRoZXkgYXJlIHByb3Blcmx5IHNhbml0aXplZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb2x1bW4gLSBUaGUgY29sdW1uIHRvIGZpbHRlciBvblxuICAgICAqIEBwYXJhbSBvcGVyYXRvciAtIFRoZSBvcGVyYXRvciB0byBiZSBuZWdhdGVkIHRvIGZpbHRlciB3aXRoLCBmb2xsb3dpbmdcbiAgICAgKiBQb3N0Z1JFU1Qgc3ludGF4XG4gICAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGZpbHRlciB3aXRoLCBmb2xsb3dpbmcgUG9zdGdSRVNUIHN5bnRheFxuICAgICAqL1xuICAgIG5vdChjb2x1bW4sIG9wZXJhdG9yLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYG5vdC4ke29wZXJhdG9yfS4ke3ZhbHVlfWApO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWF0Y2ggb25seSByb3dzIHdoaWNoIHNhdGlzZnkgYXQgbGVhc3Qgb25lIG9mIHRoZSBmaWx0ZXJzLlxuICAgICAqXG4gICAgICogVW5saWtlIG1vc3QgZmlsdGVycywgYGZpbHRlcnNgIGlzIHVzZWQgYXMtaXMgYW5kIG5lZWRzIHRvIGZvbGxvdyBbUG9zdGdSRVNUXG4gICAgICogc3ludGF4XShodHRwczovL3Bvc3RncmVzdC5vcmcvZW4vc3RhYmxlL2FwaS5odG1sI29wZXJhdG9ycykuIFlvdSBhbHNvIG5lZWRcbiAgICAgKiB0byBtYWtlIHN1cmUgaXQncyBwcm9wZXJseSBzYW5pdGl6ZWQuXG4gICAgICpcbiAgICAgKiBJdCdzIGN1cnJlbnRseSBub3QgcG9zc2libGUgdG8gZG8gYW4gYC5vcigpYCBmaWx0ZXIgYWNyb3NzIG11bHRpcGxlIHRhYmxlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmaWx0ZXJzIC0gVGhlIGZpbHRlcnMgdG8gdXNlLCBmb2xsb3dpbmcgUG9zdGdSRVNUIHN5bnRheFxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gTmFtZWQgcGFyYW1ldGVyc1xuICAgICAqIEBwYXJhbSBvcHRpb25zLnJlZmVyZW5jZWRUYWJsZSAtIFNldCB0aGlzIHRvIGZpbHRlciBvbiByZWZlcmVuY2VkIHRhYmxlc1xuICAgICAqIGluc3RlYWQgb2YgdGhlIHBhcmVudCB0YWJsZVxuICAgICAqIEBwYXJhbSBvcHRpb25zLmZvcmVpZ25UYWJsZSAtIERlcHJlY2F0ZWQsIHVzZSBgcmVmZXJlbmNlZFRhYmxlYCBpbnN0ZWFkXG4gICAgICovXG4gICAgb3IoZmlsdGVycywgeyBmb3JlaWduVGFibGUsIHJlZmVyZW5jZWRUYWJsZSA9IGZvcmVpZ25UYWJsZSwgfSA9IHt9KSB7XG4gICAgICAgIGNvbnN0IGtleSA9IHJlZmVyZW5jZWRUYWJsZSA/IGAke3JlZmVyZW5jZWRUYWJsZX0ub3JgIDogJ29yJztcbiAgICAgICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChrZXksIGAoJHtmaWx0ZXJzfSlgKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1hdGNoIG9ubHkgcm93cyB3aGljaCBzYXRpc2Z5IHRoZSBmaWx0ZXIuIFRoaXMgaXMgYW4gZXNjYXBlIGhhdGNoIC0geW91XG4gICAgICogc2hvdWxkIHVzZSB0aGUgc3BlY2lmaWMgZmlsdGVyIG1ldGhvZHMgd2hlcmV2ZXIgcG9zc2libGUuXG4gICAgICpcbiAgICAgKiBVbmxpa2UgbW9zdCBmaWx0ZXJzLCBgb3BlYXJhdG9yYCBhbmQgYHZhbHVlYCBhcmUgdXNlZCBhcy1pcyBhbmQgbmVlZCB0b1xuICAgICAqIGZvbGxvdyBbUG9zdGdSRVNUXG4gICAgICogc3ludGF4XShodHRwczovL3Bvc3RncmVzdC5vcmcvZW4vc3RhYmxlL2FwaS5odG1sI29wZXJhdG9ycykuIFlvdSBhbHNvIG5lZWRcbiAgICAgKiB0byBtYWtlIHN1cmUgdGhleSBhcmUgcHJvcGVybHkgc2FuaXRpemVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbHVtbiAtIFRoZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG4gICAgICogQHBhcmFtIG9wZXJhdG9yIC0gVGhlIG9wZXJhdG9yIHRvIGZpbHRlciB3aXRoLCBmb2xsb3dpbmcgUG9zdGdSRVNUIHN5bnRheFxuICAgICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBmaWx0ZXIgd2l0aCwgZm9sbG93aW5nIFBvc3RnUkVTVCBzeW50YXhcbiAgICAgKi9cbiAgICBmaWx0ZXIoY29sdW1uLCBvcGVyYXRvciwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGAke29wZXJhdG9yfS4ke3ZhbHVlfWApO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UG9zdGdyZXN0RmlsdGVyQnVpbGRlci5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestFilterBuilder.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestQueryBuilder.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestQueryBuilder.js ***!
  \*******************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst PostgrestFilterBuilder_1 = __importDefault(__webpack_require__(/*! ./PostgrestFilterBuilder */ \"(app-pages-browser)/./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestFilterBuilder.js\"));\nclass PostgrestQueryBuilder {\n    constructor(url, { headers = {}, schema, fetch, }) {\n        this.url = url;\n        this.headers = new Headers(headers);\n        this.schema = schema;\n        this.fetch = fetch;\n    }\n    /**\n     * Perform a SELECT query on the table or view.\n     *\n     * @param columns - The columns to retrieve, separated by commas. Columns can be renamed when returned with `customName:columnName`\n     *\n     * @param options - Named parameters\n     *\n     * @param options.head - When set to `true`, `data` will not be returned.\n     * Useful if you only need the count.\n     *\n     * @param options.count - Count algorithm to use to count rows in the table or view.\n     *\n     * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n     * hood.\n     *\n     * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n     * statistics under the hood.\n     *\n     * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n     * numbers.\n     */\n    select(columns, options) {\n        const { head = false, count } = options !== null && options !== void 0 ? options : {};\n        const method = head ? 'HEAD' : 'GET';\n        // Remove whitespaces except when quoted\n        let quoted = false;\n        const cleanedColumns = (columns !== null && columns !== void 0 ? columns : '*')\n            .split('')\n            .map((c) => {\n            if (/\\s/.test(c) && !quoted) {\n                return '';\n            }\n            if (c === '\"') {\n                quoted = !quoted;\n            }\n            return c;\n        })\n            .join('');\n        this.url.searchParams.set('select', cleanedColumns);\n        if (count) {\n            this.headers.append('Prefer', `count=${count}`);\n        }\n        return new PostgrestFilterBuilder_1.default({\n            method,\n            url: this.url,\n            headers: this.headers,\n            schema: this.schema,\n            fetch: this.fetch,\n        });\n    }\n    /**\n     * Perform an INSERT into the table or view.\n     *\n     * By default, inserted rows are not returned. To return it, chain the call\n     * with `.select()`.\n     *\n     * @param values - The values to insert. Pass an object to insert a single row\n     * or an array to insert multiple rows.\n     *\n     * @param options - Named parameters\n     *\n     * @param options.count - Count algorithm to use to count inserted rows.\n     *\n     * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n     * hood.\n     *\n     * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n     * statistics under the hood.\n     *\n     * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n     * numbers.\n     *\n     * @param options.defaultToNull - Make missing fields default to `null`.\n     * Otherwise, use the default value for the column. Only applies for bulk\n     * inserts.\n     */\n    insert(values, { count, defaultToNull = true, } = {}) {\n        var _a;\n        const method = 'POST';\n        if (count) {\n            this.headers.append('Prefer', `count=${count}`);\n        }\n        if (!defaultToNull) {\n            this.headers.append('Prefer', `missing=default`);\n        }\n        if (Array.isArray(values)) {\n            const columns = values.reduce((acc, x) => acc.concat(Object.keys(x)), []);\n            if (columns.length > 0) {\n                const uniqueColumns = [...new Set(columns)].map((column) => `\"${column}\"`);\n                this.url.searchParams.set('columns', uniqueColumns.join(','));\n            }\n        }\n        return new PostgrestFilterBuilder_1.default({\n            method,\n            url: this.url,\n            headers: this.headers,\n            schema: this.schema,\n            body: values,\n            fetch: (_a = this.fetch) !== null && _a !== void 0 ? _a : fetch,\n        });\n    }\n    /**\n     * Perform an UPSERT on the table or view. Depending on the column(s) passed\n     * to `onConflict`, `.upsert()` allows you to perform the equivalent of\n     * `.insert()` if a row with the corresponding `onConflict` columns doesn't\n     * exist, or if it does exist, perform an alternative action depending on\n     * `ignoreDuplicates`.\n     *\n     * By default, upserted rows are not returned. To return it, chain the call\n     * with `.select()`.\n     *\n     * @param values - The values to upsert with. Pass an object to upsert a\n     * single row or an array to upsert multiple rows.\n     *\n     * @param options - Named parameters\n     *\n     * @param options.onConflict - Comma-separated UNIQUE column(s) to specify how\n     * duplicate rows are determined. Two rows are duplicates if all the\n     * `onConflict` columns are equal.\n     *\n     * @param options.ignoreDuplicates - If `true`, duplicate rows are ignored. If\n     * `false`, duplicate rows are merged with existing rows.\n     *\n     * @param options.count - Count algorithm to use to count upserted rows.\n     *\n     * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n     * hood.\n     *\n     * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n     * statistics under the hood.\n     *\n     * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n     * numbers.\n     *\n     * @param options.defaultToNull - Make missing fields default to `null`.\n     * Otherwise, use the default value for the column. This only applies when\n     * inserting new rows, not when merging with existing rows under\n     * `ignoreDuplicates: false`. This also only applies when doing bulk upserts.\n     */\n    upsert(values, { onConflict, ignoreDuplicates = false, count, defaultToNull = true, } = {}) {\n        var _a;\n        const method = 'POST';\n        this.headers.append('Prefer', `resolution=${ignoreDuplicates ? 'ignore' : 'merge'}-duplicates`);\n        if (onConflict !== undefined)\n            this.url.searchParams.set('on_conflict', onConflict);\n        if (count) {\n            this.headers.append('Prefer', `count=${count}`);\n        }\n        if (!defaultToNull) {\n            this.headers.append('Prefer', 'missing=default');\n        }\n        if (Array.isArray(values)) {\n            const columns = values.reduce((acc, x) => acc.concat(Object.keys(x)), []);\n            if (columns.length > 0) {\n                const uniqueColumns = [...new Set(columns)].map((column) => `\"${column}\"`);\n                this.url.searchParams.set('columns', uniqueColumns.join(','));\n            }\n        }\n        return new PostgrestFilterBuilder_1.default({\n            method,\n            url: this.url,\n            headers: this.headers,\n            schema: this.schema,\n            body: values,\n            fetch: (_a = this.fetch) !== null && _a !== void 0 ? _a : fetch,\n        });\n    }\n    /**\n     * Perform an UPDATE on the table or view.\n     *\n     * By default, updated rows are not returned. To return it, chain the call\n     * with `.select()` after filters.\n     *\n     * @param values - The values to update with\n     *\n     * @param options - Named parameters\n     *\n     * @param options.count - Count algorithm to use to count updated rows.\n     *\n     * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n     * hood.\n     *\n     * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n     * statistics under the hood.\n     *\n     * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n     * numbers.\n     */\n    update(values, { count, } = {}) {\n        var _a;\n        const method = 'PATCH';\n        if (count) {\n            this.headers.append('Prefer', `count=${count}`);\n        }\n        return new PostgrestFilterBuilder_1.default({\n            method,\n            url: this.url,\n            headers: this.headers,\n            schema: this.schema,\n            body: values,\n            fetch: (_a = this.fetch) !== null && _a !== void 0 ? _a : fetch,\n        });\n    }\n    /**\n     * Perform a DELETE on the table or view.\n     *\n     * By default, deleted rows are not returned. To return it, chain the call\n     * with `.select()` after filters.\n     *\n     * @param options - Named parameters\n     *\n     * @param options.count - Count algorithm to use to count deleted rows.\n     *\n     * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n     * hood.\n     *\n     * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n     * statistics under the hood.\n     *\n     * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n     * numbers.\n     */\n    delete({ count, } = {}) {\n        var _a;\n        const method = 'DELETE';\n        if (count) {\n            this.headers.append('Prefer', `count=${count}`);\n        }\n        return new PostgrestFilterBuilder_1.default({\n            method,\n            url: this.url,\n            headers: this.headers,\n            schema: this.schema,\n            fetch: (_a = this.fetch) !== null && _a !== void 0 ? _a : fetch,\n        });\n    }\n}\nexports[\"default\"] = PostgrestQueryBuilder;\n//# sourceMappingURL=PostgrestQueryBuilder.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcG9zdGdyZXN0LWpzL2Rpc3QvY2pzL1Bvc3RncmVzdFF1ZXJ5QnVpbGRlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGlEQUFpRCxtQkFBTyxDQUFDLDhIQUEwQjtBQUNuRjtBQUNBLHVCQUF1QixZQUFZLGtCQUFrQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isc0JBQXNCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxNQUFNO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiwrQkFBK0IsSUFBSTtBQUN4RDtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsTUFBTTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRixPQUFPO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixxRUFBcUUsSUFBSTtBQUM5RjtBQUNBO0FBQ0Esb0RBQW9ELHNDQUFzQztBQUMxRjtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsTUFBTTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRixPQUFPO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFNBQVMsSUFBSTtBQUNsQztBQUNBO0FBQ0E7QUFDQSxtREFBbUQsTUFBTTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVMsSUFBSTtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsTUFBTTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esa0JBQWU7QUFDZiIsInNvdXJjZXMiOlsiRDpcXG5leHRcXG9yZ1xcbm9kZV9tb2R1bGVzXFxAc3VwYWJhc2VcXHBvc3RncmVzdC1qc1xcZGlzdFxcY2pzXFxQb3N0Z3Jlc3RRdWVyeUJ1aWxkZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vUG9zdGdyZXN0RmlsdGVyQnVpbGRlclwiKSk7XG5jbGFzcyBQb3N0Z3Jlc3RRdWVyeUJ1aWxkZXIge1xuICAgIGNvbnN0cnVjdG9yKHVybCwgeyBoZWFkZXJzID0ge30sIHNjaGVtYSwgZmV0Y2gsIH0pIHtcbiAgICAgICAgdGhpcy51cmwgPSB1cmw7XG4gICAgICAgIHRoaXMuaGVhZGVycyA9IG5ldyBIZWFkZXJzKGhlYWRlcnMpO1xuICAgICAgICB0aGlzLnNjaGVtYSA9IHNjaGVtYTtcbiAgICAgICAgdGhpcy5mZXRjaCA9IGZldGNoO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtIGEgU0VMRUNUIHF1ZXJ5IG9uIHRoZSB0YWJsZSBvciB2aWV3LlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbHVtbnMgLSBUaGUgY29sdW1ucyB0byByZXRyaWV2ZSwgc2VwYXJhdGVkIGJ5IGNvbW1hcy4gQ29sdW1ucyBjYW4gYmUgcmVuYW1lZCB3aGVuIHJldHVybmVkIHdpdGggYGN1c3RvbU5hbWU6Y29sdW1uTmFtZWBcbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gTmFtZWQgcGFyYW1ldGVyc1xuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMuaGVhZCAtIFdoZW4gc2V0IHRvIGB0cnVlYCwgYGRhdGFgIHdpbGwgbm90IGJlIHJldHVybmVkLlxuICAgICAqIFVzZWZ1bCBpZiB5b3Ugb25seSBuZWVkIHRoZSBjb3VudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmNvdW50IC0gQ291bnQgYWxnb3JpdGhtIHRvIHVzZSB0byBjb3VudCByb3dzIGluIHRoZSB0YWJsZSBvciB2aWV3LlxuICAgICAqXG4gICAgICogYFwiZXhhY3RcImA6IEV4YWN0IGJ1dCBzbG93IGNvdW50IGFsZ29yaXRobS4gUGVyZm9ybXMgYSBgQ09VTlQoKilgIHVuZGVyIHRoZVxuICAgICAqIGhvb2QuXG4gICAgICpcbiAgICAgKiBgXCJwbGFubmVkXCJgOiBBcHByb3hpbWF0ZWQgYnV0IGZhc3QgY291bnQgYWxnb3JpdGhtLiBVc2VzIHRoZSBQb3N0Z3Jlc1xuICAgICAqIHN0YXRpc3RpY3MgdW5kZXIgdGhlIGhvb2QuXG4gICAgICpcbiAgICAgKiBgXCJlc3RpbWF0ZWRcImA6IFVzZXMgZXhhY3QgY291bnQgZm9yIGxvdyBudW1iZXJzIGFuZCBwbGFubmVkIGNvdW50IGZvciBoaWdoXG4gICAgICogbnVtYmVycy5cbiAgICAgKi9cbiAgICBzZWxlY3QoY29sdW1ucywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCB7IGhlYWQgPSBmYWxzZSwgY291bnQgfSA9IG9wdGlvbnMgIT09IG51bGwgJiYgb3B0aW9ucyAhPT0gdm9pZCAwID8gb3B0aW9ucyA6IHt9O1xuICAgICAgICBjb25zdCBtZXRob2QgPSBoZWFkID8gJ0hFQUQnIDogJ0dFVCc7XG4gICAgICAgIC8vIFJlbW92ZSB3aGl0ZXNwYWNlcyBleGNlcHQgd2hlbiBxdW90ZWRcbiAgICAgICAgbGV0IHF1b3RlZCA9IGZhbHNlO1xuICAgICAgICBjb25zdCBjbGVhbmVkQ29sdW1ucyA9IChjb2x1bW5zICE9PSBudWxsICYmIGNvbHVtbnMgIT09IHZvaWQgMCA/IGNvbHVtbnMgOiAnKicpXG4gICAgICAgICAgICAuc3BsaXQoJycpXG4gICAgICAgICAgICAubWFwKChjKSA9PiB7XG4gICAgICAgICAgICBpZiAoL1xccy8udGVzdChjKSAmJiAhcXVvdGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGMgPT09ICdcIicpIHtcbiAgICAgICAgICAgICAgICBxdW90ZWQgPSAhcXVvdGVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGM7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuam9pbignJyk7XG4gICAgICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5zZXQoJ3NlbGVjdCcsIGNsZWFuZWRDb2x1bW5zKTtcbiAgICAgICAgaWYgKGNvdW50KSB7XG4gICAgICAgICAgICB0aGlzLmhlYWRlcnMuYXBwZW5kKCdQcmVmZXInLCBgY291bnQ9JHtjb3VudH1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFBvc3RncmVzdEZpbHRlckJ1aWxkZXJfMS5kZWZhdWx0KHtcbiAgICAgICAgICAgIG1ldGhvZCxcbiAgICAgICAgICAgIHVybDogdGhpcy51cmwsXG4gICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICBzY2hlbWE6IHRoaXMuc2NoZW1hLFxuICAgICAgICAgICAgZmV0Y2g6IHRoaXMuZmV0Y2gsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtIGFuIElOU0VSVCBpbnRvIHRoZSB0YWJsZSBvciB2aWV3LlxuICAgICAqXG4gICAgICogQnkgZGVmYXVsdCwgaW5zZXJ0ZWQgcm93cyBhcmUgbm90IHJldHVybmVkLiBUbyByZXR1cm4gaXQsIGNoYWluIHRoZSBjYWxsXG4gICAgICogd2l0aCBgLnNlbGVjdCgpYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZXMgLSBUaGUgdmFsdWVzIHRvIGluc2VydC4gUGFzcyBhbiBvYmplY3QgdG8gaW5zZXJ0IGEgc2luZ2xlIHJvd1xuICAgICAqIG9yIGFuIGFycmF5IHRvIGluc2VydCBtdWx0aXBsZSByb3dzLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBOYW1lZCBwYXJhbWV0ZXJzXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5jb3VudCAtIENvdW50IGFsZ29yaXRobSB0byB1c2UgdG8gY291bnQgaW5zZXJ0ZWQgcm93cy5cbiAgICAgKlxuICAgICAqIGBcImV4YWN0XCJgOiBFeGFjdCBidXQgc2xvdyBjb3VudCBhbGdvcml0aG0uIFBlcmZvcm1zIGEgYENPVU5UKCopYCB1bmRlciB0aGVcbiAgICAgKiBob29kLlxuICAgICAqXG4gICAgICogYFwicGxhbm5lZFwiYDogQXBwcm94aW1hdGVkIGJ1dCBmYXN0IGNvdW50IGFsZ29yaXRobS4gVXNlcyB0aGUgUG9zdGdyZXNcbiAgICAgKiBzdGF0aXN0aWNzIHVuZGVyIHRoZSBob29kLlxuICAgICAqXG4gICAgICogYFwiZXN0aW1hdGVkXCJgOiBVc2VzIGV4YWN0IGNvdW50IGZvciBsb3cgbnVtYmVycyBhbmQgcGxhbm5lZCBjb3VudCBmb3IgaGlnaFxuICAgICAqIG51bWJlcnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5kZWZhdWx0VG9OdWxsIC0gTWFrZSBtaXNzaW5nIGZpZWxkcyBkZWZhdWx0IHRvIGBudWxsYC5cbiAgICAgKiBPdGhlcndpc2UsIHVzZSB0aGUgZGVmYXVsdCB2YWx1ZSBmb3IgdGhlIGNvbHVtbi4gT25seSBhcHBsaWVzIGZvciBidWxrXG4gICAgICogaW5zZXJ0cy5cbiAgICAgKi9cbiAgICBpbnNlcnQodmFsdWVzLCB7IGNvdW50LCBkZWZhdWx0VG9OdWxsID0gdHJ1ZSwgfSA9IHt9KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ1BPU1QnO1xuICAgICAgICBpZiAoY291bnQpIHtcbiAgICAgICAgICAgIHRoaXMuaGVhZGVycy5hcHBlbmQoJ1ByZWZlcicsIGBjb3VudD0ke2NvdW50fWApO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZGVmYXVsdFRvTnVsbCkge1xuICAgICAgICAgICAgdGhpcy5oZWFkZXJzLmFwcGVuZCgnUHJlZmVyJywgYG1pc3Npbmc9ZGVmYXVsdGApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlcykpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbHVtbnMgPSB2YWx1ZXMucmVkdWNlKChhY2MsIHgpID0+IGFjYy5jb25jYXQoT2JqZWN0LmtleXMoeCkpLCBbXSk7XG4gICAgICAgICAgICBpZiAoY29sdW1ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdW5pcXVlQ29sdW1ucyA9IFsuLi5uZXcgU2V0KGNvbHVtbnMpXS5tYXAoKGNvbHVtbikgPT4gYFwiJHtjb2x1bW59XCJgKTtcbiAgICAgICAgICAgICAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuc2V0KCdjb2x1bW5zJywgdW5pcXVlQ29sdW1ucy5qb2luKCcsJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUG9zdGdyZXN0RmlsdGVyQnVpbGRlcl8xLmRlZmF1bHQoe1xuICAgICAgICAgICAgbWV0aG9kLFxuICAgICAgICAgICAgdXJsOiB0aGlzLnVybCxcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgIHNjaGVtYTogdGhpcy5zY2hlbWEsXG4gICAgICAgICAgICBib2R5OiB2YWx1ZXMsXG4gICAgICAgICAgICBmZXRjaDogKF9hID0gdGhpcy5mZXRjaCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZmV0Y2gsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtIGFuIFVQU0VSVCBvbiB0aGUgdGFibGUgb3Igdmlldy4gRGVwZW5kaW5nIG9uIHRoZSBjb2x1bW4ocykgcGFzc2VkXG4gICAgICogdG8gYG9uQ29uZmxpY3RgLCBgLnVwc2VydCgpYCBhbGxvd3MgeW91IHRvIHBlcmZvcm0gdGhlIGVxdWl2YWxlbnQgb2ZcbiAgICAgKiBgLmluc2VydCgpYCBpZiBhIHJvdyB3aXRoIHRoZSBjb3JyZXNwb25kaW5nIGBvbkNvbmZsaWN0YCBjb2x1bW5zIGRvZXNuJ3RcbiAgICAgKiBleGlzdCwgb3IgaWYgaXQgZG9lcyBleGlzdCwgcGVyZm9ybSBhbiBhbHRlcm5hdGl2ZSBhY3Rpb24gZGVwZW5kaW5nIG9uXG4gICAgICogYGlnbm9yZUR1cGxpY2F0ZXNgLlxuICAgICAqXG4gICAgICogQnkgZGVmYXVsdCwgdXBzZXJ0ZWQgcm93cyBhcmUgbm90IHJldHVybmVkLiBUbyByZXR1cm4gaXQsIGNoYWluIHRoZSBjYWxsXG4gICAgICogd2l0aCBgLnNlbGVjdCgpYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZXMgLSBUaGUgdmFsdWVzIHRvIHVwc2VydCB3aXRoLiBQYXNzIGFuIG9iamVjdCB0byB1cHNlcnQgYVxuICAgICAqIHNpbmdsZSByb3cgb3IgYW4gYXJyYXkgdG8gdXBzZXJ0IG11bHRpcGxlIHJvd3MuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIE5hbWVkIHBhcmFtZXRlcnNcbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zLm9uQ29uZmxpY3QgLSBDb21tYS1zZXBhcmF0ZWQgVU5JUVVFIGNvbHVtbihzKSB0byBzcGVjaWZ5IGhvd1xuICAgICAqIGR1cGxpY2F0ZSByb3dzIGFyZSBkZXRlcm1pbmVkLiBUd28gcm93cyBhcmUgZHVwbGljYXRlcyBpZiBhbGwgdGhlXG4gICAgICogYG9uQ29uZmxpY3RgIGNvbHVtbnMgYXJlIGVxdWFsLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMuaWdub3JlRHVwbGljYXRlcyAtIElmIGB0cnVlYCwgZHVwbGljYXRlIHJvd3MgYXJlIGlnbm9yZWQuIElmXG4gICAgICogYGZhbHNlYCwgZHVwbGljYXRlIHJvd3MgYXJlIG1lcmdlZCB3aXRoIGV4aXN0aW5nIHJvd3MuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5jb3VudCAtIENvdW50IGFsZ29yaXRobSB0byB1c2UgdG8gY291bnQgdXBzZXJ0ZWQgcm93cy5cbiAgICAgKlxuICAgICAqIGBcImV4YWN0XCJgOiBFeGFjdCBidXQgc2xvdyBjb3VudCBhbGdvcml0aG0uIFBlcmZvcm1zIGEgYENPVU5UKCopYCB1bmRlciB0aGVcbiAgICAgKiBob29kLlxuICAgICAqXG4gICAgICogYFwicGxhbm5lZFwiYDogQXBwcm94aW1hdGVkIGJ1dCBmYXN0IGNvdW50IGFsZ29yaXRobS4gVXNlcyB0aGUgUG9zdGdyZXNcbiAgICAgKiBzdGF0aXN0aWNzIHVuZGVyIHRoZSBob29kLlxuICAgICAqXG4gICAgICogYFwiZXN0aW1hdGVkXCJgOiBVc2VzIGV4YWN0IGNvdW50IGZvciBsb3cgbnVtYmVycyBhbmQgcGxhbm5lZCBjb3VudCBmb3IgaGlnaFxuICAgICAqIG51bWJlcnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5kZWZhdWx0VG9OdWxsIC0gTWFrZSBtaXNzaW5nIGZpZWxkcyBkZWZhdWx0IHRvIGBudWxsYC5cbiAgICAgKiBPdGhlcndpc2UsIHVzZSB0aGUgZGVmYXVsdCB2YWx1ZSBmb3IgdGhlIGNvbHVtbi4gVGhpcyBvbmx5IGFwcGxpZXMgd2hlblxuICAgICAqIGluc2VydGluZyBuZXcgcm93cywgbm90IHdoZW4gbWVyZ2luZyB3aXRoIGV4aXN0aW5nIHJvd3MgdW5kZXJcbiAgICAgKiBgaWdub3JlRHVwbGljYXRlczogZmFsc2VgLiBUaGlzIGFsc28gb25seSBhcHBsaWVzIHdoZW4gZG9pbmcgYnVsayB1cHNlcnRzLlxuICAgICAqL1xuICAgIHVwc2VydCh2YWx1ZXMsIHsgb25Db25mbGljdCwgaWdub3JlRHVwbGljYXRlcyA9IGZhbHNlLCBjb3VudCwgZGVmYXVsdFRvTnVsbCA9IHRydWUsIH0gPSB7fSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9ICdQT1NUJztcbiAgICAgICAgdGhpcy5oZWFkZXJzLmFwcGVuZCgnUHJlZmVyJywgYHJlc29sdXRpb249JHtpZ25vcmVEdXBsaWNhdGVzID8gJ2lnbm9yZScgOiAnbWVyZ2UnfS1kdXBsaWNhdGVzYCk7XG4gICAgICAgIGlmIChvbkNvbmZsaWN0ICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuc2V0KCdvbl9jb25mbGljdCcsIG9uQ29uZmxpY3QpO1xuICAgICAgICBpZiAoY291bnQpIHtcbiAgICAgICAgICAgIHRoaXMuaGVhZGVycy5hcHBlbmQoJ1ByZWZlcicsIGBjb3VudD0ke2NvdW50fWApO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZGVmYXVsdFRvTnVsbCkge1xuICAgICAgICAgICAgdGhpcy5oZWFkZXJzLmFwcGVuZCgnUHJlZmVyJywgJ21pc3Npbmc9ZGVmYXVsdCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlcykpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbHVtbnMgPSB2YWx1ZXMucmVkdWNlKChhY2MsIHgpID0+IGFjYy5jb25jYXQoT2JqZWN0LmtleXMoeCkpLCBbXSk7XG4gICAgICAgICAgICBpZiAoY29sdW1ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdW5pcXVlQ29sdW1ucyA9IFsuLi5uZXcgU2V0KGNvbHVtbnMpXS5tYXAoKGNvbHVtbikgPT4gYFwiJHtjb2x1bW59XCJgKTtcbiAgICAgICAgICAgICAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuc2V0KCdjb2x1bW5zJywgdW5pcXVlQ29sdW1ucy5qb2luKCcsJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUG9zdGdyZXN0RmlsdGVyQnVpbGRlcl8xLmRlZmF1bHQoe1xuICAgICAgICAgICAgbWV0aG9kLFxuICAgICAgICAgICAgdXJsOiB0aGlzLnVybCxcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgIHNjaGVtYTogdGhpcy5zY2hlbWEsXG4gICAgICAgICAgICBib2R5OiB2YWx1ZXMsXG4gICAgICAgICAgICBmZXRjaDogKF9hID0gdGhpcy5mZXRjaCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZmV0Y2gsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtIGFuIFVQREFURSBvbiB0aGUgdGFibGUgb3Igdmlldy5cbiAgICAgKlxuICAgICAqIEJ5IGRlZmF1bHQsIHVwZGF0ZWQgcm93cyBhcmUgbm90IHJldHVybmVkLiBUbyByZXR1cm4gaXQsIGNoYWluIHRoZSBjYWxsXG4gICAgICogd2l0aCBgLnNlbGVjdCgpYCBhZnRlciBmaWx0ZXJzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlcyAtIFRoZSB2YWx1ZXMgdG8gdXBkYXRlIHdpdGhcbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gTmFtZWQgcGFyYW1ldGVyc1xuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMuY291bnQgLSBDb3VudCBhbGdvcml0aG0gdG8gdXNlIHRvIGNvdW50IHVwZGF0ZWQgcm93cy5cbiAgICAgKlxuICAgICAqIGBcImV4YWN0XCJgOiBFeGFjdCBidXQgc2xvdyBjb3VudCBhbGdvcml0aG0uIFBlcmZvcm1zIGEgYENPVU5UKCopYCB1bmRlciB0aGVcbiAgICAgKiBob29kLlxuICAgICAqXG4gICAgICogYFwicGxhbm5lZFwiYDogQXBwcm94aW1hdGVkIGJ1dCBmYXN0IGNvdW50IGFsZ29yaXRobS4gVXNlcyB0aGUgUG9zdGdyZXNcbiAgICAgKiBzdGF0aXN0aWNzIHVuZGVyIHRoZSBob29kLlxuICAgICAqXG4gICAgICogYFwiZXN0aW1hdGVkXCJgOiBVc2VzIGV4YWN0IGNvdW50IGZvciBsb3cgbnVtYmVycyBhbmQgcGxhbm5lZCBjb3VudCBmb3IgaGlnaFxuICAgICAqIG51bWJlcnMuXG4gICAgICovXG4gICAgdXBkYXRlKHZhbHVlcywgeyBjb3VudCwgfSA9IHt9KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ1BBVENIJztcbiAgICAgICAgaWYgKGNvdW50KSB7XG4gICAgICAgICAgICB0aGlzLmhlYWRlcnMuYXBwZW5kKCdQcmVmZXInLCBgY291bnQ9JHtjb3VudH1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFBvc3RncmVzdEZpbHRlckJ1aWxkZXJfMS5kZWZhdWx0KHtcbiAgICAgICAgICAgIG1ldGhvZCxcbiAgICAgICAgICAgIHVybDogdGhpcy51cmwsXG4gICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICBzY2hlbWE6IHRoaXMuc2NoZW1hLFxuICAgICAgICAgICAgYm9keTogdmFsdWVzLFxuICAgICAgICAgICAgZmV0Y2g6IChfYSA9IHRoaXMuZmV0Y2gpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZldGNoLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGVyZm9ybSBhIERFTEVURSBvbiB0aGUgdGFibGUgb3Igdmlldy5cbiAgICAgKlxuICAgICAqIEJ5IGRlZmF1bHQsIGRlbGV0ZWQgcm93cyBhcmUgbm90IHJldHVybmVkLiBUbyByZXR1cm4gaXQsIGNoYWluIHRoZSBjYWxsXG4gICAgICogd2l0aCBgLnNlbGVjdCgpYCBhZnRlciBmaWx0ZXJzLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBOYW1lZCBwYXJhbWV0ZXJzXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5jb3VudCAtIENvdW50IGFsZ29yaXRobSB0byB1c2UgdG8gY291bnQgZGVsZXRlZCByb3dzLlxuICAgICAqXG4gICAgICogYFwiZXhhY3RcImA6IEV4YWN0IGJ1dCBzbG93IGNvdW50IGFsZ29yaXRobS4gUGVyZm9ybXMgYSBgQ09VTlQoKilgIHVuZGVyIHRoZVxuICAgICAqIGhvb2QuXG4gICAgICpcbiAgICAgKiBgXCJwbGFubmVkXCJgOiBBcHByb3hpbWF0ZWQgYnV0IGZhc3QgY291bnQgYWxnb3JpdGhtLiBVc2VzIHRoZSBQb3N0Z3Jlc1xuICAgICAqIHN0YXRpc3RpY3MgdW5kZXIgdGhlIGhvb2QuXG4gICAgICpcbiAgICAgKiBgXCJlc3RpbWF0ZWRcImA6IFVzZXMgZXhhY3QgY291bnQgZm9yIGxvdyBudW1iZXJzIGFuZCBwbGFubmVkIGNvdW50IGZvciBoaWdoXG4gICAgICogbnVtYmVycy5cbiAgICAgKi9cbiAgICBkZWxldGUoeyBjb3VudCwgfSA9IHt9KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ0RFTEVURSc7XG4gICAgICAgIGlmIChjb3VudCkge1xuICAgICAgICAgICAgdGhpcy5oZWFkZXJzLmFwcGVuZCgnUHJlZmVyJywgYGNvdW50PSR7Y291bnR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyXzEuZGVmYXVsdCh7XG4gICAgICAgICAgICBtZXRob2QsXG4gICAgICAgICAgICB1cmw6IHRoaXMudXJsLFxuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgc2NoZW1hOiB0aGlzLnNjaGVtYSxcbiAgICAgICAgICAgIGZldGNoOiAoX2EgPSB0aGlzLmZldGNoKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmZXRjaCxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gUG9zdGdyZXN0UXVlcnlCdWlsZGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UG9zdGdyZXN0UXVlcnlCdWlsZGVyLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestQueryBuilder.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestTransformBuilder.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestTransformBuilder.js ***!
  \***********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst PostgrestBuilder_1 = __importDefault(__webpack_require__(/*! ./PostgrestBuilder */ \"(app-pages-browser)/./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestBuilder.js\"));\nclass PostgrestTransformBuilder extends PostgrestBuilder_1.default {\n    /**\n     * Perform a SELECT on the query result.\n     *\n     * By default, `.insert()`, `.update()`, `.upsert()`, and `.delete()` do not\n     * return modified rows. By calling this method, modified rows are returned in\n     * `data`.\n     *\n     * @param columns - The columns to retrieve, separated by commas\n     */\n    select(columns) {\n        // Remove whitespaces except when quoted\n        let quoted = false;\n        const cleanedColumns = (columns !== null && columns !== void 0 ? columns : '*')\n            .split('')\n            .map((c) => {\n            if (/\\s/.test(c) && !quoted) {\n                return '';\n            }\n            if (c === '\"') {\n                quoted = !quoted;\n            }\n            return c;\n        })\n            .join('');\n        this.url.searchParams.set('select', cleanedColumns);\n        this.headers.append('Prefer', 'return=representation');\n        return this;\n    }\n    /**\n     * Order the query result by `column`.\n     *\n     * You can call this method multiple times to order by multiple columns.\n     *\n     * You can order referenced tables, but it only affects the ordering of the\n     * parent table if you use `!inner` in the query.\n     *\n     * @param column - The column to order by\n     * @param options - Named parameters\n     * @param options.ascending - If `true`, the result will be in ascending order\n     * @param options.nullsFirst - If `true`, `null`s appear first. If `false`,\n     * `null`s appear last.\n     * @param options.referencedTable - Set this to order a referenced table by\n     * its columns\n     * @param options.foreignTable - Deprecated, use `options.referencedTable`\n     * instead\n     */\n    order(column, { ascending = true, nullsFirst, foreignTable, referencedTable = foreignTable, } = {}) {\n        const key = referencedTable ? `${referencedTable}.order` : 'order';\n        const existingOrder = this.url.searchParams.get(key);\n        this.url.searchParams.set(key, `${existingOrder ? `${existingOrder},` : ''}${column}.${ascending ? 'asc' : 'desc'}${nullsFirst === undefined ? '' : nullsFirst ? '.nullsfirst' : '.nullslast'}`);\n        return this;\n    }\n    /**\n     * Limit the query result by `count`.\n     *\n     * @param count - The maximum number of rows to return\n     * @param options - Named parameters\n     * @param options.referencedTable - Set this to limit rows of referenced\n     * tables instead of the parent table\n     * @param options.foreignTable - Deprecated, use `options.referencedTable`\n     * instead\n     */\n    limit(count, { foreignTable, referencedTable = foreignTable, } = {}) {\n        const key = typeof referencedTable === 'undefined' ? 'limit' : `${referencedTable}.limit`;\n        this.url.searchParams.set(key, `${count}`);\n        return this;\n    }\n    /**\n     * Limit the query result by starting at an offset `from` and ending at the offset `to`.\n     * Only records within this range are returned.\n     * This respects the query order and if there is no order clause the range could behave unexpectedly.\n     * The `from` and `to` values are 0-based and inclusive: `range(1, 3)` will include the second, third\n     * and fourth rows of the query.\n     *\n     * @param from - The starting index from which to limit the result\n     * @param to - The last index to which to limit the result\n     * @param options - Named parameters\n     * @param options.referencedTable - Set this to limit rows of referenced\n     * tables instead of the parent table\n     * @param options.foreignTable - Deprecated, use `options.referencedTable`\n     * instead\n     */\n    range(from, to, { foreignTable, referencedTable = foreignTable, } = {}) {\n        const keyOffset = typeof referencedTable === 'undefined' ? 'offset' : `${referencedTable}.offset`;\n        const keyLimit = typeof referencedTable === 'undefined' ? 'limit' : `${referencedTable}.limit`;\n        this.url.searchParams.set(keyOffset, `${from}`);\n        // Range is inclusive, so add 1\n        this.url.searchParams.set(keyLimit, `${to - from + 1}`);\n        return this;\n    }\n    /**\n     * Set the AbortSignal for the fetch request.\n     *\n     * @param signal - The AbortSignal to use for the fetch request\n     */\n    abortSignal(signal) {\n        this.signal = signal;\n        return this;\n    }\n    /**\n     * Return `data` as a single object instead of an array of objects.\n     *\n     * Query result must be one row (e.g. using `.limit(1)`), otherwise this\n     * returns an error.\n     */\n    single() {\n        this.headers.set('Accept', 'application/vnd.pgrst.object+json');\n        return this;\n    }\n    /**\n     * Return `data` as a single object instead of an array of objects.\n     *\n     * Query result must be zero or one row (e.g. using `.limit(1)`), otherwise\n     * this returns an error.\n     */\n    maybeSingle() {\n        // Temporary partial fix for https://github.com/supabase/postgrest-js/issues/361\n        // Issue persists e.g. for `.insert([...]).select().maybeSingle()`\n        if (this.method === 'GET') {\n            this.headers.set('Accept', 'application/json');\n        }\n        else {\n            this.headers.set('Accept', 'application/vnd.pgrst.object+json');\n        }\n        this.isMaybeSingle = true;\n        return this;\n    }\n    /**\n     * Return `data` as a string in CSV format.\n     */\n    csv() {\n        this.headers.set('Accept', 'text/csv');\n        return this;\n    }\n    /**\n     * Return `data` as an object in [GeoJSON](https://geojson.org) format.\n     */\n    geojson() {\n        this.headers.set('Accept', 'application/geo+json');\n        return this;\n    }\n    /**\n     * Return `data` as the EXPLAIN plan for the query.\n     *\n     * You need to enable the\n     * [db_plan_enabled](https://supabase.com/docs/guides/database/debugging-performance#enabling-explain)\n     * setting before using this method.\n     *\n     * @param options - Named parameters\n     *\n     * @param options.analyze - If `true`, the query will be executed and the\n     * actual run time will be returned\n     *\n     * @param options.verbose - If `true`, the query identifier will be returned\n     * and `data` will include the output columns of the query\n     *\n     * @param options.settings - If `true`, include information on configuration\n     * parameters that affect query planning\n     *\n     * @param options.buffers - If `true`, include information on buffer usage\n     *\n     * @param options.wal - If `true`, include information on WAL record generation\n     *\n     * @param options.format - The format of the output, can be `\"text\"` (default)\n     * or `\"json\"`\n     */\n    explain({ analyze = false, verbose = false, settings = false, buffers = false, wal = false, format = 'text', } = {}) {\n        var _a;\n        const options = [\n            analyze ? 'analyze' : null,\n            verbose ? 'verbose' : null,\n            settings ? 'settings' : null,\n            buffers ? 'buffers' : null,\n            wal ? 'wal' : null,\n        ]\n            .filter(Boolean)\n            .join('|');\n        // An Accept header can carry multiple media types but postgrest-js always sends one\n        const forMediatype = (_a = this.headers.get('Accept')) !== null && _a !== void 0 ? _a : 'application/json';\n        this.headers.set('Accept', `application/vnd.pgrst.plan+${format}; for=\"${forMediatype}\"; options=${options};`);\n        if (format === 'json') {\n            return this;\n        }\n        else {\n            return this;\n        }\n    }\n    /**\n     * Rollback the query.\n     *\n     * `data` will still be returned, but the query is not committed.\n     */\n    rollback() {\n        this.headers.append('Prefer', 'tx=rollback');\n        return this;\n    }\n    /**\n     * Override the type of the returned `data`.\n     *\n     * @typeParam NewResult - The new result type to override with\n     * @deprecated Use overrideTypes<yourType, { merge: false }>() method at the end of your call chain instead\n     */\n    returns() {\n        return this;\n    }\n    /**\n     * Set the maximum number of rows that can be affected by the query.\n     * Only available in PostgREST v13+ and only works with PATCH and DELETE methods.\n     *\n     * @param value - The maximum number of rows that can be affected\n     */\n    maxAffected(value) {\n        this.headers.append('Prefer', 'handling=strict');\n        this.headers.append('Prefer', `max-affected=${value}`);\n        return this;\n    }\n}\nexports[\"default\"] = PostgrestTransformBuilder;\n//# sourceMappingURL=PostgrestTransformBuilder.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcG9zdGdyZXN0LWpzL2Rpc3QvY2pzL1Bvc3RncmVzdFRyYW5zZm9ybUJ1aWxkZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwyQ0FBMkMsbUJBQU8sQ0FBQyxrSEFBb0I7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDhFQUE4RSxJQUFJO0FBQ3RHLHlDQUF5QyxnQkFBZ0I7QUFDekQ7QUFDQSwwQ0FBMEMsbUJBQW1CLGNBQWMsUUFBUSxFQUFFLE9BQU8sR0FBRywyQkFBMkIsRUFBRSwwRUFBMEU7QUFDdE07QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGdEQUFnRCxJQUFJO0FBQ3ZFLDBFQUEwRSxnQkFBZ0I7QUFDMUYsMENBQTBDLE1BQU07QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixnREFBZ0QsSUFBSTtBQUMxRSxpRkFBaUYsZ0JBQWdCO0FBQ2pHLCtFQUErRSxnQkFBZ0I7QUFDL0YsZ0RBQWdELEtBQUs7QUFDckQ7QUFDQSwrQ0FBK0MsY0FBYztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHFHQUFxRyxJQUFJO0FBQ3ZIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxTQUFTLE9BQU8sYUFBYSxHQUFHLFVBQVUsU0FBUztBQUNwSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELGNBQWM7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELE1BQU07QUFDNUQ7QUFDQTtBQUNBO0FBQ0Esa0JBQWU7QUFDZiIsInNvdXJjZXMiOlsiRDpcXG5leHRcXG9yZ1xcbm9kZV9tb2R1bGVzXFxAc3VwYWJhc2VcXHBvc3RncmVzdC1qc1xcZGlzdFxcY2pzXFxQb3N0Z3Jlc3RUcmFuc2Zvcm1CdWlsZGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgUG9zdGdyZXN0QnVpbGRlcl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL1Bvc3RncmVzdEJ1aWxkZXJcIikpO1xuY2xhc3MgUG9zdGdyZXN0VHJhbnNmb3JtQnVpbGRlciBleHRlbmRzIFBvc3RncmVzdEJ1aWxkZXJfMS5kZWZhdWx0IHtcbiAgICAvKipcbiAgICAgKiBQZXJmb3JtIGEgU0VMRUNUIG9uIHRoZSBxdWVyeSByZXN1bHQuXG4gICAgICpcbiAgICAgKiBCeSBkZWZhdWx0LCBgLmluc2VydCgpYCwgYC51cGRhdGUoKWAsIGAudXBzZXJ0KClgLCBhbmQgYC5kZWxldGUoKWAgZG8gbm90XG4gICAgICogcmV0dXJuIG1vZGlmaWVkIHJvd3MuIEJ5IGNhbGxpbmcgdGhpcyBtZXRob2QsIG1vZGlmaWVkIHJvd3MgYXJlIHJldHVybmVkIGluXG4gICAgICogYGRhdGFgLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbHVtbnMgLSBUaGUgY29sdW1ucyB0byByZXRyaWV2ZSwgc2VwYXJhdGVkIGJ5IGNvbW1hc1xuICAgICAqL1xuICAgIHNlbGVjdChjb2x1bW5zKSB7XG4gICAgICAgIC8vIFJlbW92ZSB3aGl0ZXNwYWNlcyBleGNlcHQgd2hlbiBxdW90ZWRcbiAgICAgICAgbGV0IHF1b3RlZCA9IGZhbHNlO1xuICAgICAgICBjb25zdCBjbGVhbmVkQ29sdW1ucyA9IChjb2x1bW5zICE9PSBudWxsICYmIGNvbHVtbnMgIT09IHZvaWQgMCA/IGNvbHVtbnMgOiAnKicpXG4gICAgICAgICAgICAuc3BsaXQoJycpXG4gICAgICAgICAgICAubWFwKChjKSA9PiB7XG4gICAgICAgICAgICBpZiAoL1xccy8udGVzdChjKSAmJiAhcXVvdGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGMgPT09ICdcIicpIHtcbiAgICAgICAgICAgICAgICBxdW90ZWQgPSAhcXVvdGVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGM7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuam9pbignJyk7XG4gICAgICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5zZXQoJ3NlbGVjdCcsIGNsZWFuZWRDb2x1bW5zKTtcbiAgICAgICAgdGhpcy5oZWFkZXJzLmFwcGVuZCgnUHJlZmVyJywgJ3JldHVybj1yZXByZXNlbnRhdGlvbicpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogT3JkZXIgdGhlIHF1ZXJ5IHJlc3VsdCBieSBgY29sdW1uYC5cbiAgICAgKlxuICAgICAqIFlvdSBjYW4gY2FsbCB0aGlzIG1ldGhvZCBtdWx0aXBsZSB0aW1lcyB0byBvcmRlciBieSBtdWx0aXBsZSBjb2x1bW5zLlxuICAgICAqXG4gICAgICogWW91IGNhbiBvcmRlciByZWZlcmVuY2VkIHRhYmxlcywgYnV0IGl0IG9ubHkgYWZmZWN0cyB0aGUgb3JkZXJpbmcgb2YgdGhlXG4gICAgICogcGFyZW50IHRhYmxlIGlmIHlvdSB1c2UgYCFpbm5lcmAgaW4gdGhlIHF1ZXJ5LlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbHVtbiAtIFRoZSBjb2x1bW4gdG8gb3JkZXIgYnlcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIE5hbWVkIHBhcmFtZXRlcnNcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5hc2NlbmRpbmcgLSBJZiBgdHJ1ZWAsIHRoZSByZXN1bHQgd2lsbCBiZSBpbiBhc2NlbmRpbmcgb3JkZXJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5udWxsc0ZpcnN0IC0gSWYgYHRydWVgLCBgbnVsbGBzIGFwcGVhciBmaXJzdC4gSWYgYGZhbHNlYCxcbiAgICAgKiBgbnVsbGBzIGFwcGVhciBsYXN0LlxuICAgICAqIEBwYXJhbSBvcHRpb25zLnJlZmVyZW5jZWRUYWJsZSAtIFNldCB0aGlzIHRvIG9yZGVyIGEgcmVmZXJlbmNlZCB0YWJsZSBieVxuICAgICAqIGl0cyBjb2x1bW5zXG4gICAgICogQHBhcmFtIG9wdGlvbnMuZm9yZWlnblRhYmxlIC0gRGVwcmVjYXRlZCwgdXNlIGBvcHRpb25zLnJlZmVyZW5jZWRUYWJsZWBcbiAgICAgKiBpbnN0ZWFkXG4gICAgICovXG4gICAgb3JkZXIoY29sdW1uLCB7IGFzY2VuZGluZyA9IHRydWUsIG51bGxzRmlyc3QsIGZvcmVpZ25UYWJsZSwgcmVmZXJlbmNlZFRhYmxlID0gZm9yZWlnblRhYmxlLCB9ID0ge30pIHtcbiAgICAgICAgY29uc3Qga2V5ID0gcmVmZXJlbmNlZFRhYmxlID8gYCR7cmVmZXJlbmNlZFRhYmxlfS5vcmRlcmAgOiAnb3JkZXInO1xuICAgICAgICBjb25zdCBleGlzdGluZ09yZGVyID0gdGhpcy51cmwuc2VhcmNoUGFyYW1zLmdldChrZXkpO1xuICAgICAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuc2V0KGtleSwgYCR7ZXhpc3RpbmdPcmRlciA/IGAke2V4aXN0aW5nT3JkZXJ9LGAgOiAnJ30ke2NvbHVtbn0uJHthc2NlbmRpbmcgPyAnYXNjJyA6ICdkZXNjJ30ke251bGxzRmlyc3QgPT09IHVuZGVmaW5lZCA/ICcnIDogbnVsbHNGaXJzdCA/ICcubnVsbHNmaXJzdCcgOiAnLm51bGxzbGFzdCd9YCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMaW1pdCB0aGUgcXVlcnkgcmVzdWx0IGJ5IGBjb3VudGAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY291bnQgLSBUaGUgbWF4aW11bSBudW1iZXIgb2Ygcm93cyB0byByZXR1cm5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIE5hbWVkIHBhcmFtZXRlcnNcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5yZWZlcmVuY2VkVGFibGUgLSBTZXQgdGhpcyB0byBsaW1pdCByb3dzIG9mIHJlZmVyZW5jZWRcbiAgICAgKiB0YWJsZXMgaW5zdGVhZCBvZiB0aGUgcGFyZW50IHRhYmxlXG4gICAgICogQHBhcmFtIG9wdGlvbnMuZm9yZWlnblRhYmxlIC0gRGVwcmVjYXRlZCwgdXNlIGBvcHRpb25zLnJlZmVyZW5jZWRUYWJsZWBcbiAgICAgKiBpbnN0ZWFkXG4gICAgICovXG4gICAgbGltaXQoY291bnQsIHsgZm9yZWlnblRhYmxlLCByZWZlcmVuY2VkVGFibGUgPSBmb3JlaWduVGFibGUsIH0gPSB7fSkge1xuICAgICAgICBjb25zdCBrZXkgPSB0eXBlb2YgcmVmZXJlbmNlZFRhYmxlID09PSAndW5kZWZpbmVkJyA/ICdsaW1pdCcgOiBgJHtyZWZlcmVuY2VkVGFibGV9LmxpbWl0YDtcbiAgICAgICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLnNldChrZXksIGAke2NvdW50fWApO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGltaXQgdGhlIHF1ZXJ5IHJlc3VsdCBieSBzdGFydGluZyBhdCBhbiBvZmZzZXQgYGZyb21gIGFuZCBlbmRpbmcgYXQgdGhlIG9mZnNldCBgdG9gLlxuICAgICAqIE9ubHkgcmVjb3JkcyB3aXRoaW4gdGhpcyByYW5nZSBhcmUgcmV0dXJuZWQuXG4gICAgICogVGhpcyByZXNwZWN0cyB0aGUgcXVlcnkgb3JkZXIgYW5kIGlmIHRoZXJlIGlzIG5vIG9yZGVyIGNsYXVzZSB0aGUgcmFuZ2UgY291bGQgYmVoYXZlIHVuZXhwZWN0ZWRseS5cbiAgICAgKiBUaGUgYGZyb21gIGFuZCBgdG9gIHZhbHVlcyBhcmUgMC1iYXNlZCBhbmQgaW5jbHVzaXZlOiBgcmFuZ2UoMSwgMylgIHdpbGwgaW5jbHVkZSB0aGUgc2Vjb25kLCB0aGlyZFxuICAgICAqIGFuZCBmb3VydGggcm93cyBvZiB0aGUgcXVlcnkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZnJvbSAtIFRoZSBzdGFydGluZyBpbmRleCBmcm9tIHdoaWNoIHRvIGxpbWl0IHRoZSByZXN1bHRcbiAgICAgKiBAcGFyYW0gdG8gLSBUaGUgbGFzdCBpbmRleCB0byB3aGljaCB0byBsaW1pdCB0aGUgcmVzdWx0XG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBOYW1lZCBwYXJhbWV0ZXJzXG4gICAgICogQHBhcmFtIG9wdGlvbnMucmVmZXJlbmNlZFRhYmxlIC0gU2V0IHRoaXMgdG8gbGltaXQgcm93cyBvZiByZWZlcmVuY2VkXG4gICAgICogdGFibGVzIGluc3RlYWQgb2YgdGhlIHBhcmVudCB0YWJsZVxuICAgICAqIEBwYXJhbSBvcHRpb25zLmZvcmVpZ25UYWJsZSAtIERlcHJlY2F0ZWQsIHVzZSBgb3B0aW9ucy5yZWZlcmVuY2VkVGFibGVgXG4gICAgICogaW5zdGVhZFxuICAgICAqL1xuICAgIHJhbmdlKGZyb20sIHRvLCB7IGZvcmVpZ25UYWJsZSwgcmVmZXJlbmNlZFRhYmxlID0gZm9yZWlnblRhYmxlLCB9ID0ge30pIHtcbiAgICAgICAgY29uc3Qga2V5T2Zmc2V0ID0gdHlwZW9mIHJlZmVyZW5jZWRUYWJsZSA9PT0gJ3VuZGVmaW5lZCcgPyAnb2Zmc2V0JyA6IGAke3JlZmVyZW5jZWRUYWJsZX0ub2Zmc2V0YDtcbiAgICAgICAgY29uc3Qga2V5TGltaXQgPSB0eXBlb2YgcmVmZXJlbmNlZFRhYmxlID09PSAndW5kZWZpbmVkJyA/ICdsaW1pdCcgOiBgJHtyZWZlcmVuY2VkVGFibGV9LmxpbWl0YDtcbiAgICAgICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLnNldChrZXlPZmZzZXQsIGAke2Zyb219YCk7XG4gICAgICAgIC8vIFJhbmdlIGlzIGluY2x1c2l2ZSwgc28gYWRkIDFcbiAgICAgICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLnNldChrZXlMaW1pdCwgYCR7dG8gLSBmcm9tICsgMX1gKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgQWJvcnRTaWduYWwgZm9yIHRoZSBmZXRjaCByZXF1ZXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHNpZ25hbCAtIFRoZSBBYm9ydFNpZ25hbCB0byB1c2UgZm9yIHRoZSBmZXRjaCByZXF1ZXN0XG4gICAgICovXG4gICAgYWJvcnRTaWduYWwoc2lnbmFsKSB7XG4gICAgICAgIHRoaXMuc2lnbmFsID0gc2lnbmFsO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGBkYXRhYCBhcyBhIHNpbmdsZSBvYmplY3QgaW5zdGVhZCBvZiBhbiBhcnJheSBvZiBvYmplY3RzLlxuICAgICAqXG4gICAgICogUXVlcnkgcmVzdWx0IG11c3QgYmUgb25lIHJvdyAoZS5nLiB1c2luZyBgLmxpbWl0KDEpYCksIG90aGVyd2lzZSB0aGlzXG4gICAgICogcmV0dXJucyBhbiBlcnJvci5cbiAgICAgKi9cbiAgICBzaW5nbGUoKSB7XG4gICAgICAgIHRoaXMuaGVhZGVycy5zZXQoJ0FjY2VwdCcsICdhcHBsaWNhdGlvbi92bmQucGdyc3Qub2JqZWN0K2pzb24nKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiBgZGF0YWAgYXMgYSBzaW5nbGUgb2JqZWN0IGluc3RlYWQgb2YgYW4gYXJyYXkgb2Ygb2JqZWN0cy5cbiAgICAgKlxuICAgICAqIFF1ZXJ5IHJlc3VsdCBtdXN0IGJlIHplcm8gb3Igb25lIHJvdyAoZS5nLiB1c2luZyBgLmxpbWl0KDEpYCksIG90aGVyd2lzZVxuICAgICAqIHRoaXMgcmV0dXJucyBhbiBlcnJvci5cbiAgICAgKi9cbiAgICBtYXliZVNpbmdsZSgpIHtcbiAgICAgICAgLy8gVGVtcG9yYXJ5IHBhcnRpYWwgZml4IGZvciBodHRwczovL2dpdGh1Yi5jb20vc3VwYWJhc2UvcG9zdGdyZXN0LWpzL2lzc3Vlcy8zNjFcbiAgICAgICAgLy8gSXNzdWUgcGVyc2lzdHMgZS5nLiBmb3IgYC5pbnNlcnQoWy4uLl0pLnNlbGVjdCgpLm1heWJlU2luZ2xlKClgXG4gICAgICAgIGlmICh0aGlzLm1ldGhvZCA9PT0gJ0dFVCcpIHtcbiAgICAgICAgICAgIHRoaXMuaGVhZGVycy5zZXQoJ0FjY2VwdCcsICdhcHBsaWNhdGlvbi9qc29uJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmhlYWRlcnMuc2V0KCdBY2NlcHQnLCAnYXBwbGljYXRpb24vdm5kLnBncnN0Lm9iamVjdCtqc29uJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc01heWJlU2luZ2xlID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiBgZGF0YWAgYXMgYSBzdHJpbmcgaW4gQ1NWIGZvcm1hdC5cbiAgICAgKi9cbiAgICBjc3YoKSB7XG4gICAgICAgIHRoaXMuaGVhZGVycy5zZXQoJ0FjY2VwdCcsICd0ZXh0L2NzdicpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGBkYXRhYCBhcyBhbiBvYmplY3QgaW4gW0dlb0pTT05dKGh0dHBzOi8vZ2VvanNvbi5vcmcpIGZvcm1hdC5cbiAgICAgKi9cbiAgICBnZW9qc29uKCkge1xuICAgICAgICB0aGlzLmhlYWRlcnMuc2V0KCdBY2NlcHQnLCAnYXBwbGljYXRpb24vZ2VvK2pzb24nKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiBgZGF0YWAgYXMgdGhlIEVYUExBSU4gcGxhbiBmb3IgdGhlIHF1ZXJ5LlxuICAgICAqXG4gICAgICogWW91IG5lZWQgdG8gZW5hYmxlIHRoZVxuICAgICAqIFtkYl9wbGFuX2VuYWJsZWRdKGh0dHBzOi8vc3VwYWJhc2UuY29tL2RvY3MvZ3VpZGVzL2RhdGFiYXNlL2RlYnVnZ2luZy1wZXJmb3JtYW5jZSNlbmFibGluZy1leHBsYWluKVxuICAgICAqIHNldHRpbmcgYmVmb3JlIHVzaW5nIHRoaXMgbWV0aG9kLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBOYW1lZCBwYXJhbWV0ZXJzXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5hbmFseXplIC0gSWYgYHRydWVgLCB0aGUgcXVlcnkgd2lsbCBiZSBleGVjdXRlZCBhbmQgdGhlXG4gICAgICogYWN0dWFsIHJ1biB0aW1lIHdpbGwgYmUgcmV0dXJuZWRcbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zLnZlcmJvc2UgLSBJZiBgdHJ1ZWAsIHRoZSBxdWVyeSBpZGVudGlmaWVyIHdpbGwgYmUgcmV0dXJuZWRcbiAgICAgKiBhbmQgYGRhdGFgIHdpbGwgaW5jbHVkZSB0aGUgb3V0cHV0IGNvbHVtbnMgb2YgdGhlIHF1ZXJ5XG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5zZXR0aW5ncyAtIElmIGB0cnVlYCwgaW5jbHVkZSBpbmZvcm1hdGlvbiBvbiBjb25maWd1cmF0aW9uXG4gICAgICogcGFyYW1ldGVycyB0aGF0IGFmZmVjdCBxdWVyeSBwbGFubmluZ1xuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMuYnVmZmVycyAtIElmIGB0cnVlYCwgaW5jbHVkZSBpbmZvcm1hdGlvbiBvbiBidWZmZXIgdXNhZ2VcbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zLndhbCAtIElmIGB0cnVlYCwgaW5jbHVkZSBpbmZvcm1hdGlvbiBvbiBXQUwgcmVjb3JkIGdlbmVyYXRpb25cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmZvcm1hdCAtIFRoZSBmb3JtYXQgb2YgdGhlIG91dHB1dCwgY2FuIGJlIGBcInRleHRcImAgKGRlZmF1bHQpXG4gICAgICogb3IgYFwianNvblwiYFxuICAgICAqL1xuICAgIGV4cGxhaW4oeyBhbmFseXplID0gZmFsc2UsIHZlcmJvc2UgPSBmYWxzZSwgc2V0dGluZ3MgPSBmYWxzZSwgYnVmZmVycyA9IGZhbHNlLCB3YWwgPSBmYWxzZSwgZm9ybWF0ID0gJ3RleHQnLCB9ID0ge30pIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gW1xuICAgICAgICAgICAgYW5hbHl6ZSA/ICdhbmFseXplJyA6IG51bGwsXG4gICAgICAgICAgICB2ZXJib3NlID8gJ3ZlcmJvc2UnIDogbnVsbCxcbiAgICAgICAgICAgIHNldHRpbmdzID8gJ3NldHRpbmdzJyA6IG51bGwsXG4gICAgICAgICAgICBidWZmZXJzID8gJ2J1ZmZlcnMnIDogbnVsbCxcbiAgICAgICAgICAgIHdhbCA/ICd3YWwnIDogbnVsbCxcbiAgICAgICAgXVxuICAgICAgICAgICAgLmZpbHRlcihCb29sZWFuKVxuICAgICAgICAgICAgLmpvaW4oJ3wnKTtcbiAgICAgICAgLy8gQW4gQWNjZXB0IGhlYWRlciBjYW4gY2FycnkgbXVsdGlwbGUgbWVkaWEgdHlwZXMgYnV0IHBvc3RncmVzdC1qcyBhbHdheXMgc2VuZHMgb25lXG4gICAgICAgIGNvbnN0IGZvck1lZGlhdHlwZSA9IChfYSA9IHRoaXMuaGVhZGVycy5nZXQoJ0FjY2VwdCcpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgIHRoaXMuaGVhZGVycy5zZXQoJ0FjY2VwdCcsIGBhcHBsaWNhdGlvbi92bmQucGdyc3QucGxhbiske2Zvcm1hdH07IGZvcj1cIiR7Zm9yTWVkaWF0eXBlfVwiOyBvcHRpb25zPSR7b3B0aW9uc307YCk7XG4gICAgICAgIGlmIChmb3JtYXQgPT09ICdqc29uJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSb2xsYmFjayB0aGUgcXVlcnkuXG4gICAgICpcbiAgICAgKiBgZGF0YWAgd2lsbCBzdGlsbCBiZSByZXR1cm5lZCwgYnV0IHRoZSBxdWVyeSBpcyBub3QgY29tbWl0dGVkLlxuICAgICAqL1xuICAgIHJvbGxiYWNrKCkge1xuICAgICAgICB0aGlzLmhlYWRlcnMuYXBwZW5kKCdQcmVmZXInLCAndHg9cm9sbGJhY2snKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIHRoZSB0eXBlIG9mIHRoZSByZXR1cm5lZCBgZGF0YWAuXG4gICAgICpcbiAgICAgKiBAdHlwZVBhcmFtIE5ld1Jlc3VsdCAtIFRoZSBuZXcgcmVzdWx0IHR5cGUgdG8gb3ZlcnJpZGUgd2l0aFxuICAgICAqIEBkZXByZWNhdGVkIFVzZSBvdmVycmlkZVR5cGVzPHlvdXJUeXBlLCB7IG1lcmdlOiBmYWxzZSB9PigpIG1ldGhvZCBhdCB0aGUgZW5kIG9mIHlvdXIgY2FsbCBjaGFpbiBpbnN0ZWFkXG4gICAgICovXG4gICAgcmV0dXJucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgbWF4aW11bSBudW1iZXIgb2Ygcm93cyB0aGF0IGNhbiBiZSBhZmZlY3RlZCBieSB0aGUgcXVlcnkuXG4gICAgICogT25seSBhdmFpbGFibGUgaW4gUG9zdGdSRVNUIHYxMysgYW5kIG9ubHkgd29ya3Mgd2l0aCBQQVRDSCBhbmQgREVMRVRFIG1ldGhvZHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgbWF4aW11bSBudW1iZXIgb2Ygcm93cyB0aGF0IGNhbiBiZSBhZmZlY3RlZFxuICAgICAqL1xuICAgIG1heEFmZmVjdGVkKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuaGVhZGVycy5hcHBlbmQoJ1ByZWZlcicsICdoYW5kbGluZz1zdHJpY3QnKTtcbiAgICAgICAgdGhpcy5oZWFkZXJzLmFwcGVuZCgnUHJlZmVyJywgYG1heC1hZmZlY3RlZD0ke3ZhbHVlfWApO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBQb3N0Z3Jlc3RUcmFuc2Zvcm1CdWlsZGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UG9zdGdyZXN0VHJhbnNmb3JtQnVpbGRlci5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestTransformBuilder.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/postgrest-js/dist/cjs/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/@supabase/postgrest-js/dist/cjs/index.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PostgrestError = exports.PostgrestBuilder = exports.PostgrestTransformBuilder = exports.PostgrestFilterBuilder = exports.PostgrestQueryBuilder = exports.PostgrestClient = void 0;\n// Always update wrapper.mjs when updating this file.\nconst PostgrestClient_1 = __importDefault(__webpack_require__(/*! ./PostgrestClient */ \"(app-pages-browser)/./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestClient.js\"));\nexports.PostgrestClient = PostgrestClient_1.default;\nconst PostgrestQueryBuilder_1 = __importDefault(__webpack_require__(/*! ./PostgrestQueryBuilder */ \"(app-pages-browser)/./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestQueryBuilder.js\"));\nexports.PostgrestQueryBuilder = PostgrestQueryBuilder_1.default;\nconst PostgrestFilterBuilder_1 = __importDefault(__webpack_require__(/*! ./PostgrestFilterBuilder */ \"(app-pages-browser)/./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestFilterBuilder.js\"));\nexports.PostgrestFilterBuilder = PostgrestFilterBuilder_1.default;\nconst PostgrestTransformBuilder_1 = __importDefault(__webpack_require__(/*! ./PostgrestTransformBuilder */ \"(app-pages-browser)/./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestTransformBuilder.js\"));\nexports.PostgrestTransformBuilder = PostgrestTransformBuilder_1.default;\nconst PostgrestBuilder_1 = __importDefault(__webpack_require__(/*! ./PostgrestBuilder */ \"(app-pages-browser)/./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestBuilder.js\"));\nexports.PostgrestBuilder = PostgrestBuilder_1.default;\nconst PostgrestError_1 = __importDefault(__webpack_require__(/*! ./PostgrestError */ \"(app-pages-browser)/./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestError.js\"));\nexports.PostgrestError = PostgrestError_1.default;\nexports[\"default\"] = {\n    PostgrestClient: PostgrestClient_1.default,\n    PostgrestQueryBuilder: PostgrestQueryBuilder_1.default,\n    PostgrestFilterBuilder: PostgrestFilterBuilder_1.default,\n    PostgrestTransformBuilder: PostgrestTransformBuilder_1.default,\n    PostgrestBuilder: PostgrestBuilder_1.default,\n    PostgrestError: PostgrestError_1.default,\n};\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcG9zdGdyZXN0LWpzL2Rpc3QvY2pzL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsc0JBQXNCLEdBQUcsd0JBQXdCLEdBQUcsaUNBQWlDLEdBQUcsOEJBQThCLEdBQUcsNkJBQTZCLEdBQUcsdUJBQXVCO0FBQ2hMO0FBQ0EsMENBQTBDLG1CQUFPLENBQUMsZ0hBQW1CO0FBQ3JFLHVCQUF1QjtBQUN2QixnREFBZ0QsbUJBQU8sQ0FBQyw0SEFBeUI7QUFDakYsNkJBQTZCO0FBQzdCLGlEQUFpRCxtQkFBTyxDQUFDLDhIQUEwQjtBQUNuRiw4QkFBOEI7QUFDOUIsb0RBQW9ELG1CQUFPLENBQUMsb0lBQTZCO0FBQ3pGLGlDQUFpQztBQUNqQywyQ0FBMkMsbUJBQU8sQ0FBQyxrSEFBb0I7QUFDdkUsd0JBQXdCO0FBQ3hCLHlDQUF5QyxtQkFBTyxDQUFDLDhHQUFrQjtBQUNuRSxzQkFBc0I7QUFDdEIsa0JBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJEOlxcbmV4dFxcb3JnXFxub2RlX21vZHVsZXNcXEBzdXBhYmFzZVxccG9zdGdyZXN0LWpzXFxkaXN0XFxjanNcXGluZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Qb3N0Z3Jlc3RFcnJvciA9IGV4cG9ydHMuUG9zdGdyZXN0QnVpbGRlciA9IGV4cG9ydHMuUG9zdGdyZXN0VHJhbnNmb3JtQnVpbGRlciA9IGV4cG9ydHMuUG9zdGdyZXN0RmlsdGVyQnVpbGRlciA9IGV4cG9ydHMuUG9zdGdyZXN0UXVlcnlCdWlsZGVyID0gZXhwb3J0cy5Qb3N0Z3Jlc3RDbGllbnQgPSB2b2lkIDA7XG4vLyBBbHdheXMgdXBkYXRlIHdyYXBwZXIubWpzIHdoZW4gdXBkYXRpbmcgdGhpcyBmaWxlLlxuY29uc3QgUG9zdGdyZXN0Q2xpZW50XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vUG9zdGdyZXN0Q2xpZW50XCIpKTtcbmV4cG9ydHMuUG9zdGdyZXN0Q2xpZW50ID0gUG9zdGdyZXN0Q2xpZW50XzEuZGVmYXVsdDtcbmNvbnN0IFBvc3RncmVzdFF1ZXJ5QnVpbGRlcl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL1Bvc3RncmVzdFF1ZXJ5QnVpbGRlclwiKSk7XG5leHBvcnRzLlBvc3RncmVzdFF1ZXJ5QnVpbGRlciA9IFBvc3RncmVzdFF1ZXJ5QnVpbGRlcl8xLmRlZmF1bHQ7XG5jb25zdCBQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vUG9zdGdyZXN0RmlsdGVyQnVpbGRlclwiKSk7XG5leHBvcnRzLlBvc3RncmVzdEZpbHRlckJ1aWxkZXIgPSBQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyXzEuZGVmYXVsdDtcbmNvbnN0IFBvc3RncmVzdFRyYW5zZm9ybUJ1aWxkZXJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9Qb3N0Z3Jlc3RUcmFuc2Zvcm1CdWlsZGVyXCIpKTtcbmV4cG9ydHMuUG9zdGdyZXN0VHJhbnNmb3JtQnVpbGRlciA9IFBvc3RncmVzdFRyYW5zZm9ybUJ1aWxkZXJfMS5kZWZhdWx0O1xuY29uc3QgUG9zdGdyZXN0QnVpbGRlcl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL1Bvc3RncmVzdEJ1aWxkZXJcIikpO1xuZXhwb3J0cy5Qb3N0Z3Jlc3RCdWlsZGVyID0gUG9zdGdyZXN0QnVpbGRlcl8xLmRlZmF1bHQ7XG5jb25zdCBQb3N0Z3Jlc3RFcnJvcl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL1Bvc3RncmVzdEVycm9yXCIpKTtcbmV4cG9ydHMuUG9zdGdyZXN0RXJyb3IgPSBQb3N0Z3Jlc3RFcnJvcl8xLmRlZmF1bHQ7XG5leHBvcnRzLmRlZmF1bHQgPSB7XG4gICAgUG9zdGdyZXN0Q2xpZW50OiBQb3N0Z3Jlc3RDbGllbnRfMS5kZWZhdWx0LFxuICAgIFBvc3RncmVzdFF1ZXJ5QnVpbGRlcjogUG9zdGdyZXN0UXVlcnlCdWlsZGVyXzEuZGVmYXVsdCxcbiAgICBQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyOiBQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyXzEuZGVmYXVsdCxcbiAgICBQb3N0Z3Jlc3RUcmFuc2Zvcm1CdWlsZGVyOiBQb3N0Z3Jlc3RUcmFuc2Zvcm1CdWlsZGVyXzEuZGVmYXVsdCxcbiAgICBQb3N0Z3Jlc3RCdWlsZGVyOiBQb3N0Z3Jlc3RCdWlsZGVyXzEuZGVmYXVsdCxcbiAgICBQb3N0Z3Jlc3RFcnJvcjogUG9zdGdyZXN0RXJyb3JfMS5kZWZhdWx0LFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/postgrest-js/dist/cjs/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/postgrest-js/dist/esm/wrapper.mjs":
/*!******************************************************************!*\
  !*** ./node_modules/@supabase/postgrest-js/dist/esm/wrapper.mjs ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PostgrestBuilder: () => (/* binding */ PostgrestBuilder),\n/* harmony export */   PostgrestClient: () => (/* binding */ PostgrestClient),\n/* harmony export */   PostgrestError: () => (/* binding */ PostgrestError),\n/* harmony export */   PostgrestFilterBuilder: () => (/* binding */ PostgrestFilterBuilder),\n/* harmony export */   PostgrestQueryBuilder: () => (/* binding */ PostgrestQueryBuilder),\n/* harmony export */   PostgrestTransformBuilder: () => (/* binding */ PostgrestTransformBuilder),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _cjs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../cjs/index.js */ \"(app-pages-browser)/./node_modules/@supabase/postgrest-js/dist/cjs/index.js\");\n\nconst {\n  PostgrestClient,\n  PostgrestQueryBuilder,\n  PostgrestFilterBuilder,\n  PostgrestTransformBuilder,\n  PostgrestBuilder,\n  PostgrestError,\n} = _cjs_index_js__WEBPACK_IMPORTED_MODULE_0__\n\n\n\n// compatibility with CJS output\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  PostgrestClient,\n  PostgrestQueryBuilder,\n  PostgrestFilterBuilder,\n  PostgrestTransformBuilder,\n  PostgrestBuilder,\n  PostgrestError,\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcG9zdGdyZXN0LWpzL2Rpc3QvZXNtL3dyYXBwZXIubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxFQUFFLDBDQUFLOztBQVNSOztBQUVEO0FBQ0EsaUVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyJEOlxcbmV4dFxcb3JnXFxub2RlX21vZHVsZXNcXEBzdXBhYmFzZVxccG9zdGdyZXN0LWpzXFxkaXN0XFxlc21cXHdyYXBwZXIubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBpbmRleCBmcm9tICcuLi9janMvaW5kZXguanMnXG5jb25zdCB7XG4gIFBvc3RncmVzdENsaWVudCxcbiAgUG9zdGdyZXN0UXVlcnlCdWlsZGVyLFxuICBQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyLFxuICBQb3N0Z3Jlc3RUcmFuc2Zvcm1CdWlsZGVyLFxuICBQb3N0Z3Jlc3RCdWlsZGVyLFxuICBQb3N0Z3Jlc3RFcnJvcixcbn0gPSBpbmRleFxuXG5leHBvcnQge1xuICBQb3N0Z3Jlc3RCdWlsZGVyLFxuICBQb3N0Z3Jlc3RDbGllbnQsXG4gIFBvc3RncmVzdEZpbHRlckJ1aWxkZXIsXG4gIFBvc3RncmVzdFF1ZXJ5QnVpbGRlcixcbiAgUG9zdGdyZXN0VHJhbnNmb3JtQnVpbGRlcixcbiAgUG9zdGdyZXN0RXJyb3IsXG59XG5cbi8vIGNvbXBhdGliaWxpdHkgd2l0aCBDSlMgb3V0cHV0XG5leHBvcnQgZGVmYXVsdCB7XG4gIFBvc3RncmVzdENsaWVudCxcbiAgUG9zdGdyZXN0UXVlcnlCdWlsZGVyLFxuICBQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyLFxuICBQb3N0Z3Jlc3RUcmFuc2Zvcm1CdWlsZGVyLFxuICBQb3N0Z3Jlc3RCdWlsZGVyLFxuICBQb3N0Z3Jlc3RFcnJvcixcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/postgrest-js/dist/esm/wrapper.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/realtime-js/dist/module/RealtimeChannel.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@supabase/realtime-js/dist/module/RealtimeChannel.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   REALTIME_CHANNEL_STATES: () => (/* binding */ REALTIME_CHANNEL_STATES),\n/* harmony export */   REALTIME_LISTEN_TYPES: () => (/* binding */ REALTIME_LISTEN_TYPES),\n/* harmony export */   REALTIME_POSTGRES_CHANGES_LISTEN_EVENT: () => (/* binding */ REALTIME_POSTGRES_CHANGES_LISTEN_EVENT),\n/* harmony export */   REALTIME_SUBSCRIBE_STATES: () => (/* binding */ REALTIME_SUBSCRIBE_STATES),\n/* harmony export */   \"default\": () => (/* binding */ RealtimeChannel)\n/* harmony export */ });\n/* harmony import */ var _lib_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/constants */ \"(app-pages-browser)/./node_modules/@supabase/realtime-js/dist/module/lib/constants.js\");\n/* harmony import */ var _lib_push__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/push */ \"(app-pages-browser)/./node_modules/@supabase/realtime-js/dist/module/lib/push.js\");\n/* harmony import */ var _lib_timer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/timer */ \"(app-pages-browser)/./node_modules/@supabase/realtime-js/dist/module/lib/timer.js\");\n/* harmony import */ var _RealtimePresence__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./RealtimePresence */ \"(app-pages-browser)/./node_modules/@supabase/realtime-js/dist/module/RealtimePresence.js\");\n/* harmony import */ var _lib_transformers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./lib/transformers */ \"(app-pages-browser)/./node_modules/@supabase/realtime-js/dist/module/lib/transformers.js\");\n\n\n\n\n\n\nvar REALTIME_POSTGRES_CHANGES_LISTEN_EVENT;\n(function (REALTIME_POSTGRES_CHANGES_LISTEN_EVENT) {\n    REALTIME_POSTGRES_CHANGES_LISTEN_EVENT[\"ALL\"] = \"*\";\n    REALTIME_POSTGRES_CHANGES_LISTEN_EVENT[\"INSERT\"] = \"INSERT\";\n    REALTIME_POSTGRES_CHANGES_LISTEN_EVENT[\"UPDATE\"] = \"UPDATE\";\n    REALTIME_POSTGRES_CHANGES_LISTEN_EVENT[\"DELETE\"] = \"DELETE\";\n})(REALTIME_POSTGRES_CHANGES_LISTEN_EVENT || (REALTIME_POSTGRES_CHANGES_LISTEN_EVENT = {}));\nvar REALTIME_LISTEN_TYPES;\n(function (REALTIME_LISTEN_TYPES) {\n    REALTIME_LISTEN_TYPES[\"BROADCAST\"] = \"broadcast\";\n    REALTIME_LISTEN_TYPES[\"PRESENCE\"] = \"presence\";\n    REALTIME_LISTEN_TYPES[\"POSTGRES_CHANGES\"] = \"postgres_changes\";\n    REALTIME_LISTEN_TYPES[\"SYSTEM\"] = \"system\";\n})(REALTIME_LISTEN_TYPES || (REALTIME_LISTEN_TYPES = {}));\nvar REALTIME_SUBSCRIBE_STATES;\n(function (REALTIME_SUBSCRIBE_STATES) {\n    REALTIME_SUBSCRIBE_STATES[\"SUBSCRIBED\"] = \"SUBSCRIBED\";\n    REALTIME_SUBSCRIBE_STATES[\"TIMED_OUT\"] = \"TIMED_OUT\";\n    REALTIME_SUBSCRIBE_STATES[\"CLOSED\"] = \"CLOSED\";\n    REALTIME_SUBSCRIBE_STATES[\"CHANNEL_ERROR\"] = \"CHANNEL_ERROR\";\n})(REALTIME_SUBSCRIBE_STATES || (REALTIME_SUBSCRIBE_STATES = {}));\nconst REALTIME_CHANNEL_STATES = _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_STATES;\n/** A channel is the basic building block of Realtime\n * and narrows the scope of data flow to subscribed clients.\n * You can think of a channel as a chatroom where participants are able to see who's online\n * and send and receive messages.\n */\nclass RealtimeChannel {\n    constructor(\n    /** Topic name can be any string. */\n    topic, params = { config: {} }, socket) {\n        var _a, _b;\n        this.topic = topic;\n        this.params = params;\n        this.socket = socket;\n        this.bindings = {};\n        this.state = _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_STATES.closed;\n        this.joinedOnce = false;\n        this.pushBuffer = [];\n        this.subTopic = topic.replace(/^realtime:/i, '');\n        this.params.config = Object.assign({\n            broadcast: { ack: false, self: false },\n            presence: { key: '', enabled: false },\n            private: false,\n        }, params.config);\n        this.timeout = this.socket.timeout;\n        this.joinPush = new _lib_push__WEBPACK_IMPORTED_MODULE_1__[\"default\"](this, _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_EVENTS.join, this.params, this.timeout);\n        this.rejoinTimer = new _lib_timer__WEBPACK_IMPORTED_MODULE_2__[\"default\"](() => this._rejoinUntilConnected(), this.socket.reconnectAfterMs);\n        this.joinPush.receive('ok', () => {\n            this.state = _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_STATES.joined;\n            this.rejoinTimer.reset();\n            this.pushBuffer.forEach((pushEvent) => pushEvent.send());\n            this.pushBuffer = [];\n        });\n        this._onClose(() => {\n            this.rejoinTimer.reset();\n            this.socket.log('channel', `close ${this.topic} ${this._joinRef()}`);\n            this.state = _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_STATES.closed;\n            this.socket._remove(this);\n        });\n        this._onError((reason) => {\n            if (this._isLeaving() || this._isClosed()) {\n                return;\n            }\n            this.socket.log('channel', `error ${this.topic}`, reason);\n            this.state = _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_STATES.errored;\n            this.rejoinTimer.scheduleTimeout();\n        });\n        this.joinPush.receive('timeout', () => {\n            if (!this._isJoining()) {\n                return;\n            }\n            this.socket.log('channel', `timeout ${this.topic}`, this.joinPush.timeout);\n            this.state = _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_STATES.errored;\n            this.rejoinTimer.scheduleTimeout();\n        });\n        this.joinPush.receive('error', (reason) => {\n            if (this._isLeaving() || this._isClosed()) {\n                return;\n            }\n            this.socket.log('channel', `error ${this.topic}`, reason);\n            this.state = _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_STATES.errored;\n            this.rejoinTimer.scheduleTimeout();\n        });\n        this._on(_lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_EVENTS.reply, {}, (payload, ref) => {\n            this._trigger(this._replyEventName(ref), payload);\n        });\n        this.presence = new _RealtimePresence__WEBPACK_IMPORTED_MODULE_3__[\"default\"](this);\n        this.broadcastEndpointURL = (0,_lib_transformers__WEBPACK_IMPORTED_MODULE_4__.httpEndpointURL)(this.socket.endPoint);\n        this.private = this.params.config.private || false;\n        if (!this.private && ((_b = (_a = this.params.config) === null || _a === void 0 ? void 0 : _a.broadcast) === null || _b === void 0 ? void 0 : _b.replay)) {\n            throw `tried to use replay on public channel '${this.topic}'. It must be a private channel.`;\n        }\n    }\n    /** Subscribe registers your client with the server */\n    subscribe(callback, timeout = this.timeout) {\n        var _a, _b, _c;\n        if (!this.socket.isConnected()) {\n            this.socket.connect();\n        }\n        if (this.state == _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_STATES.closed) {\n            const { config: { broadcast, presence, private: isPrivate }, } = this.params;\n            const postgres_changes = (_b = (_a = this.bindings.postgres_changes) === null || _a === void 0 ? void 0 : _a.map((r) => r.filter)) !== null && _b !== void 0 ? _b : [];\n            const presence_enabled = (!!this.bindings[REALTIME_LISTEN_TYPES.PRESENCE] &&\n                this.bindings[REALTIME_LISTEN_TYPES.PRESENCE].length > 0) ||\n                ((_c = this.params.config.presence) === null || _c === void 0 ? void 0 : _c.enabled) === true;\n            const accessTokenPayload = {};\n            const config = {\n                broadcast,\n                presence: Object.assign(Object.assign({}, presence), { enabled: presence_enabled }),\n                postgres_changes,\n                private: isPrivate,\n            };\n            if (this.socket.accessTokenValue) {\n                accessTokenPayload.access_token = this.socket.accessTokenValue;\n            }\n            this._onError((e) => callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR, e));\n            this._onClose(() => callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.CLOSED));\n            this.updateJoinPayload(Object.assign({ config }, accessTokenPayload));\n            this.joinedOnce = true;\n            this._rejoin(timeout);\n            this.joinPush\n                .receive('ok', async ({ postgres_changes }) => {\n                var _a;\n                this.socket.setAuth();\n                if (postgres_changes === undefined) {\n                    callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.SUBSCRIBED);\n                    return;\n                }\n                else {\n                    const clientPostgresBindings = this.bindings.postgres_changes;\n                    const bindingsLen = (_a = clientPostgresBindings === null || clientPostgresBindings === void 0 ? void 0 : clientPostgresBindings.length) !== null && _a !== void 0 ? _a : 0;\n                    const newPostgresBindings = [];\n                    for (let i = 0; i < bindingsLen; i++) {\n                        const clientPostgresBinding = clientPostgresBindings[i];\n                        const { filter: { event, schema, table, filter }, } = clientPostgresBinding;\n                        const serverPostgresFilter = postgres_changes && postgres_changes[i];\n                        if (serverPostgresFilter &&\n                            serverPostgresFilter.event === event &&\n                            serverPostgresFilter.schema === schema &&\n                            serverPostgresFilter.table === table &&\n                            serverPostgresFilter.filter === filter) {\n                            newPostgresBindings.push(Object.assign(Object.assign({}, clientPostgresBinding), { id: serverPostgresFilter.id }));\n                        }\n                        else {\n                            this.unsubscribe();\n                            this.state = _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_STATES.errored;\n                            callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR, new Error('mismatch between server and client bindings for postgres changes'));\n                            return;\n                        }\n                    }\n                    this.bindings.postgres_changes = newPostgresBindings;\n                    callback && callback(REALTIME_SUBSCRIBE_STATES.SUBSCRIBED);\n                    return;\n                }\n            })\n                .receive('error', (error) => {\n                this.state = _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_STATES.errored;\n                callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR, new Error(JSON.stringify(Object.values(error).join(', ') || 'error')));\n                return;\n            })\n                .receive('timeout', () => {\n                callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.TIMED_OUT);\n                return;\n            });\n        }\n        return this;\n    }\n    presenceState() {\n        return this.presence.state;\n    }\n    async track(payload, opts = {}) {\n        return await this.send({\n            type: 'presence',\n            event: 'track',\n            payload,\n        }, opts.timeout || this.timeout);\n    }\n    async untrack(opts = {}) {\n        return await this.send({\n            type: 'presence',\n            event: 'untrack',\n        }, opts);\n    }\n    on(type, filter, callback) {\n        if (this.state === _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_STATES.joined && type === REALTIME_LISTEN_TYPES.PRESENCE) {\n            this.socket.log('channel', `resubscribe to ${this.topic} due to change in presence callbacks on joined channel`);\n            this.unsubscribe().then(() => this.subscribe());\n        }\n        return this._on(type, filter, callback);\n    }\n    /**\n     * Sends a message into the channel.\n     *\n     * @param args Arguments to send to channel\n     * @param args.type The type of event to send\n     * @param args.event The name of the event being sent\n     * @param args.payload Payload to be sent\n     * @param opts Options to be used during the send process\n     */\n    async send(args, opts = {}) {\n        var _a, _b;\n        if (!this._canPush() && args.type === 'broadcast') {\n            const { event, payload: endpoint_payload } = args;\n            const authorization = this.socket.accessTokenValue\n                ? `Bearer ${this.socket.accessTokenValue}`\n                : '';\n            const options = {\n                method: 'POST',\n                headers: {\n                    Authorization: authorization,\n                    apikey: this.socket.apiKey ? this.socket.apiKey : '',\n                    'Content-Type': 'application/json',\n                },\n                body: JSON.stringify({\n                    messages: [\n                        {\n                            topic: this.subTopic,\n                            event,\n                            payload: endpoint_payload,\n                            private: this.private,\n                        },\n                    ],\n                }),\n            };\n            try {\n                const response = await this._fetchWithTimeout(this.broadcastEndpointURL, options, (_a = opts.timeout) !== null && _a !== void 0 ? _a : this.timeout);\n                await ((_b = response.body) === null || _b === void 0 ? void 0 : _b.cancel());\n                return response.ok ? 'ok' : 'error';\n            }\n            catch (error) {\n                if (error.name === 'AbortError') {\n                    return 'timed out';\n                }\n                else {\n                    return 'error';\n                }\n            }\n        }\n        else {\n            return new Promise((resolve) => {\n                var _a, _b, _c;\n                const push = this._push(args.type, args, opts.timeout || this.timeout);\n                if (args.type === 'broadcast' && !((_c = (_b = (_a = this.params) === null || _a === void 0 ? void 0 : _a.config) === null || _b === void 0 ? void 0 : _b.broadcast) === null || _c === void 0 ? void 0 : _c.ack)) {\n                    resolve('ok');\n                }\n                push.receive('ok', () => resolve('ok'));\n                push.receive('error', () => resolve('error'));\n                push.receive('timeout', () => resolve('timed out'));\n            });\n        }\n    }\n    updateJoinPayload(payload) {\n        this.joinPush.updatePayload(payload);\n    }\n    /**\n     * Leaves the channel.\n     *\n     * Unsubscribes from server events, and instructs channel to terminate on server.\n     * Triggers onClose() hooks.\n     *\n     * To receive leave acknowledgements, use the a `receive` hook to bind to the server ack, ie:\n     * channel.unsubscribe().receive(\"ok\", () => alert(\"left!\") )\n     */\n    unsubscribe(timeout = this.timeout) {\n        this.state = _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_STATES.leaving;\n        const onClose = () => {\n            this.socket.log('channel', `leave ${this.topic}`);\n            this._trigger(_lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_EVENTS.close, 'leave', this._joinRef());\n        };\n        this.joinPush.destroy();\n        let leavePush = null;\n        return new Promise((resolve) => {\n            leavePush = new _lib_push__WEBPACK_IMPORTED_MODULE_1__[\"default\"](this, _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_EVENTS.leave, {}, timeout);\n            leavePush\n                .receive('ok', () => {\n                onClose();\n                resolve('ok');\n            })\n                .receive('timeout', () => {\n                onClose();\n                resolve('timed out');\n            })\n                .receive('error', () => {\n                resolve('error');\n            });\n            leavePush.send();\n            if (!this._canPush()) {\n                leavePush.trigger('ok', {});\n            }\n        }).finally(() => {\n            leavePush === null || leavePush === void 0 ? void 0 : leavePush.destroy();\n        });\n    }\n    /**\n     * Teardown the channel.\n     *\n     * Destroys and stops related timers.\n     */\n    teardown() {\n        this.pushBuffer.forEach((push) => push.destroy());\n        this.pushBuffer = [];\n        this.rejoinTimer.reset();\n        this.joinPush.destroy();\n        this.state = _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_STATES.closed;\n        this.bindings = {};\n    }\n    /** @internal */\n    async _fetchWithTimeout(url, options, timeout) {\n        const controller = new AbortController();\n        const id = setTimeout(() => controller.abort(), timeout);\n        const response = await this.socket.fetch(url, Object.assign(Object.assign({}, options), { signal: controller.signal }));\n        clearTimeout(id);\n        return response;\n    }\n    /** @internal */\n    _push(event, payload, timeout = this.timeout) {\n        if (!this.joinedOnce) {\n            throw `tried to push '${event}' to '${this.topic}' before joining. Use channel.subscribe() before pushing events`;\n        }\n        let pushEvent = new _lib_push__WEBPACK_IMPORTED_MODULE_1__[\"default\"](this, event, payload, timeout);\n        if (this._canPush()) {\n            pushEvent.send();\n        }\n        else {\n            this._addToPushBuffer(pushEvent);\n        }\n        return pushEvent;\n    }\n    /** @internal */\n    _addToPushBuffer(pushEvent) {\n        pushEvent.startTimeout();\n        this.pushBuffer.push(pushEvent);\n        // Enforce buffer size limit\n        if (this.pushBuffer.length > _lib_constants__WEBPACK_IMPORTED_MODULE_0__.MAX_PUSH_BUFFER_SIZE) {\n            const removedPush = this.pushBuffer.shift();\n            if (removedPush) {\n                removedPush.destroy();\n                this.socket.log('channel', `discarded push due to buffer overflow: ${removedPush.event}`, removedPush.payload);\n            }\n        }\n    }\n    /**\n     * Overridable message hook\n     *\n     * Receives all events for specialized message handling before dispatching to the channel callbacks.\n     * Must return the payload, modified or unmodified.\n     *\n     * @internal\n     */\n    _onMessage(_event, payload, _ref) {\n        return payload;\n    }\n    /** @internal */\n    _isMember(topic) {\n        return this.topic === topic;\n    }\n    /** @internal */\n    _joinRef() {\n        return this.joinPush.ref;\n    }\n    /** @internal */\n    _trigger(type, payload, ref) {\n        var _a, _b;\n        const typeLower = type.toLocaleLowerCase();\n        const { close, error, leave, join } = _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_EVENTS;\n        const events = [close, error, leave, join];\n        if (ref && events.indexOf(typeLower) >= 0 && ref !== this._joinRef()) {\n            return;\n        }\n        let handledPayload = this._onMessage(typeLower, payload, ref);\n        if (payload && !handledPayload) {\n            throw 'channel onMessage callbacks must return the payload, modified or unmodified';\n        }\n        if (['insert', 'update', 'delete'].includes(typeLower)) {\n            (_a = this.bindings.postgres_changes) === null || _a === void 0 ? void 0 : _a.filter((bind) => {\n                var _a, _b, _c;\n                return ((_a = bind.filter) === null || _a === void 0 ? void 0 : _a.event) === '*' || ((_c = (_b = bind.filter) === null || _b === void 0 ? void 0 : _b.event) === null || _c === void 0 ? void 0 : _c.toLocaleLowerCase()) === typeLower;\n            }).map((bind) => bind.callback(handledPayload, ref));\n        }\n        else {\n            (_b = this.bindings[typeLower]) === null || _b === void 0 ? void 0 : _b.filter((bind) => {\n                var _a, _b, _c, _d, _e, _f;\n                if (['broadcast', 'presence', 'postgres_changes'].includes(typeLower)) {\n                    if ('id' in bind) {\n                        const bindId = bind.id;\n                        const bindEvent = (_a = bind.filter) === null || _a === void 0 ? void 0 : _a.event;\n                        return (bindId &&\n                            ((_b = payload.ids) === null || _b === void 0 ? void 0 : _b.includes(bindId)) &&\n                            (bindEvent === '*' ||\n                                (bindEvent === null || bindEvent === void 0 ? void 0 : bindEvent.toLocaleLowerCase()) === ((_c = payload.data) === null || _c === void 0 ? void 0 : _c.type.toLocaleLowerCase())));\n                    }\n                    else {\n                        const bindEvent = (_e = (_d = bind === null || bind === void 0 ? void 0 : bind.filter) === null || _d === void 0 ? void 0 : _d.event) === null || _e === void 0 ? void 0 : _e.toLocaleLowerCase();\n                        return bindEvent === '*' || bindEvent === ((_f = payload === null || payload === void 0 ? void 0 : payload.event) === null || _f === void 0 ? void 0 : _f.toLocaleLowerCase());\n                    }\n                }\n                else {\n                    return bind.type.toLocaleLowerCase() === typeLower;\n                }\n            }).map((bind) => {\n                if (typeof handledPayload === 'object' && 'ids' in handledPayload) {\n                    const postgresChanges = handledPayload.data;\n                    const { schema, table, commit_timestamp, type, errors } = postgresChanges;\n                    const enrichedPayload = {\n                        schema: schema,\n                        table: table,\n                        commit_timestamp: commit_timestamp,\n                        eventType: type,\n                        new: {},\n                        old: {},\n                        errors: errors,\n                    };\n                    handledPayload = Object.assign(Object.assign({}, enrichedPayload), this._getPayloadRecords(postgresChanges));\n                }\n                bind.callback(handledPayload, ref);\n            });\n        }\n    }\n    /** @internal */\n    _isClosed() {\n        return this.state === _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_STATES.closed;\n    }\n    /** @internal */\n    _isJoined() {\n        return this.state === _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_STATES.joined;\n    }\n    /** @internal */\n    _isJoining() {\n        return this.state === _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_STATES.joining;\n    }\n    /** @internal */\n    _isLeaving() {\n        return this.state === _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_STATES.leaving;\n    }\n    /** @internal */\n    _replyEventName(ref) {\n        return `chan_reply_${ref}`;\n    }\n    /** @internal */\n    _on(type, filter, callback) {\n        const typeLower = type.toLocaleLowerCase();\n        const binding = {\n            type: typeLower,\n            filter: filter,\n            callback: callback,\n        };\n        if (this.bindings[typeLower]) {\n            this.bindings[typeLower].push(binding);\n        }\n        else {\n            this.bindings[typeLower] = [binding];\n        }\n        return this;\n    }\n    /** @internal */\n    _off(type, filter) {\n        const typeLower = type.toLocaleLowerCase();\n        if (this.bindings[typeLower]) {\n            this.bindings[typeLower] = this.bindings[typeLower].filter((bind) => {\n                var _a;\n                return !(((_a = bind.type) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase()) === typeLower &&\n                    RealtimeChannel.isEqual(bind.filter, filter));\n            });\n        }\n        return this;\n    }\n    /** @internal */\n    static isEqual(obj1, obj2) {\n        if (Object.keys(obj1).length !== Object.keys(obj2).length) {\n            return false;\n        }\n        for (const k in obj1) {\n            if (obj1[k] !== obj2[k]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /** @internal */\n    _rejoinUntilConnected() {\n        this.rejoinTimer.scheduleTimeout();\n        if (this.socket.isConnected()) {\n            this._rejoin();\n        }\n    }\n    /**\n     * Registers a callback that will be executed when the channel closes.\n     *\n     * @internal\n     */\n    _onClose(callback) {\n        this._on(_lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_EVENTS.close, {}, callback);\n    }\n    /**\n     * Registers a callback that will be executed when the channel encounteres an error.\n     *\n     * @internal\n     */\n    _onError(callback) {\n        this._on(_lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_EVENTS.error, {}, (reason) => callback(reason));\n    }\n    /**\n     * Returns `true` if the socket is connected and the channel has been joined.\n     *\n     * @internal\n     */\n    _canPush() {\n        return this.socket.isConnected() && this._isJoined();\n    }\n    /** @internal */\n    _rejoin(timeout = this.timeout) {\n        if (this._isLeaving()) {\n            return;\n        }\n        this.socket._leaveOpenTopic(this.topic);\n        this.state = _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_STATES.joining;\n        this.joinPush.resend(timeout);\n    }\n    /** @internal */\n    _getPayloadRecords(payload) {\n        const records = {\n            new: {},\n            old: {},\n        };\n        if (payload.type === 'INSERT' || payload.type === 'UPDATE') {\n            records.new = _lib_transformers__WEBPACK_IMPORTED_MODULE_4__.convertChangeData(payload.columns, payload.record);\n        }\n        if (payload.type === 'UPDATE' || payload.type === 'DELETE') {\n            records.old = _lib_transformers__WEBPACK_IMPORTED_MODULE_4__.convertChangeData(payload.columns, payload.old_record);\n        }\n        return records;\n    }\n}\n//# sourceMappingURL=RealtimeChannel.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcmVhbHRpbWUtanMvZGlzdC9tb2R1bGUvUmVhbHRpbWVDaGFubmVsLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBdUY7QUFDekQ7QUFDRTtBQUNrQjtBQUNDO0FBQ0U7QUFDOUM7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx3RkFBd0Y7QUFDbEY7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxzREFBc0Q7QUFDaEQ7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw4REFBOEQ7QUFDeEQsZ0NBQWdDLDBEQUFjO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDZTtBQUNmO0FBQ0E7QUFDQSxzQkFBc0IsWUFBWTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDBEQUFjO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHlCQUF5QjtBQUNsRCx3QkFBd0IseUJBQXlCO0FBQ2pEO0FBQ0EsU0FBUztBQUNUO0FBQ0EsNEJBQTRCLGlEQUFJLE9BQU8sMERBQWM7QUFDckQsK0JBQStCLGtEQUFLO0FBQ3BDO0FBQ0EseUJBQXlCLDBEQUFjO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsZ0RBQWdELFlBQVksRUFBRSxnQkFBZ0I7QUFDOUUseUJBQXlCLDBEQUFjO0FBQ3ZDO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFdBQVc7QUFDM0QseUJBQXlCLDBEQUFjO0FBQ3ZDO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELFdBQVc7QUFDN0QseUJBQXlCLDBEQUFjO0FBQ3ZDO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFdBQVc7QUFDM0QseUJBQXlCLDBEQUFjO0FBQ3ZDO0FBQ0EsU0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDBEQUFjLFVBQVU7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsMERBQWMsVUFBVTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsMERBQWM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQixtQkFBbUI7QUFDbkI7QUFDQTtBQUNBLDBCQUEwQixnRUFBOEI7QUFDeEQ7QUFDQTtBQUNBLDBCQUEwQixnRUFBOEI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiRDpcXG5leHRcXG9yZ1xcbm9kZV9tb2R1bGVzXFxAc3VwYWJhc2VcXHJlYWx0aW1lLWpzXFxkaXN0XFxtb2R1bGVcXFJlYWx0aW1lQ2hhbm5lbC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDSEFOTkVMX0VWRU5UUywgQ0hBTk5FTF9TVEFURVMsIE1BWF9QVVNIX0JVRkZFUl9TSVpFIH0gZnJvbSAnLi9saWIvY29uc3RhbnRzJztcbmltcG9ydCBQdXNoIGZyb20gJy4vbGliL3B1c2gnO1xuaW1wb3J0IFRpbWVyIGZyb20gJy4vbGliL3RpbWVyJztcbmltcG9ydCBSZWFsdGltZVByZXNlbmNlIGZyb20gJy4vUmVhbHRpbWVQcmVzZW5jZSc7XG5pbXBvcnQgKiBhcyBUcmFuc2Zvcm1lcnMgZnJvbSAnLi9saWIvdHJhbnNmb3JtZXJzJztcbmltcG9ydCB7IGh0dHBFbmRwb2ludFVSTCB9IGZyb20gJy4vbGliL3RyYW5zZm9ybWVycyc7XG5leHBvcnQgdmFyIFJFQUxUSU1FX1BPU1RHUkVTX0NIQU5HRVNfTElTVEVOX0VWRU5UO1xuKGZ1bmN0aW9uIChSRUFMVElNRV9QT1NUR1JFU19DSEFOR0VTX0xJU1RFTl9FVkVOVCkge1xuICAgIFJFQUxUSU1FX1BPU1RHUkVTX0NIQU5HRVNfTElTVEVOX0VWRU5UW1wiQUxMXCJdID0gXCIqXCI7XG4gICAgUkVBTFRJTUVfUE9TVEdSRVNfQ0hBTkdFU19MSVNURU5fRVZFTlRbXCJJTlNFUlRcIl0gPSBcIklOU0VSVFwiO1xuICAgIFJFQUxUSU1FX1BPU1RHUkVTX0NIQU5HRVNfTElTVEVOX0VWRU5UW1wiVVBEQVRFXCJdID0gXCJVUERBVEVcIjtcbiAgICBSRUFMVElNRV9QT1NUR1JFU19DSEFOR0VTX0xJU1RFTl9FVkVOVFtcIkRFTEVURVwiXSA9IFwiREVMRVRFXCI7XG59KShSRUFMVElNRV9QT1NUR1JFU19DSEFOR0VTX0xJU1RFTl9FVkVOVCB8fCAoUkVBTFRJTUVfUE9TVEdSRVNfQ0hBTkdFU19MSVNURU5fRVZFTlQgPSB7fSkpO1xuZXhwb3J0IHZhciBSRUFMVElNRV9MSVNURU5fVFlQRVM7XG4oZnVuY3Rpb24gKFJFQUxUSU1FX0xJU1RFTl9UWVBFUykge1xuICAgIFJFQUxUSU1FX0xJU1RFTl9UWVBFU1tcIkJST0FEQ0FTVFwiXSA9IFwiYnJvYWRjYXN0XCI7XG4gICAgUkVBTFRJTUVfTElTVEVOX1RZUEVTW1wiUFJFU0VOQ0VcIl0gPSBcInByZXNlbmNlXCI7XG4gICAgUkVBTFRJTUVfTElTVEVOX1RZUEVTW1wiUE9TVEdSRVNfQ0hBTkdFU1wiXSA9IFwicG9zdGdyZXNfY2hhbmdlc1wiO1xuICAgIFJFQUxUSU1FX0xJU1RFTl9UWVBFU1tcIlNZU1RFTVwiXSA9IFwic3lzdGVtXCI7XG59KShSRUFMVElNRV9MSVNURU5fVFlQRVMgfHwgKFJFQUxUSU1FX0xJU1RFTl9UWVBFUyA9IHt9KSk7XG5leHBvcnQgdmFyIFJFQUxUSU1FX1NVQlNDUklCRV9TVEFURVM7XG4oZnVuY3Rpb24gKFJFQUxUSU1FX1NVQlNDUklCRV9TVEFURVMpIHtcbiAgICBSRUFMVElNRV9TVUJTQ1JJQkVfU1RBVEVTW1wiU1VCU0NSSUJFRFwiXSA9IFwiU1VCU0NSSUJFRFwiO1xuICAgIFJFQUxUSU1FX1NVQlNDUklCRV9TVEFURVNbXCJUSU1FRF9PVVRcIl0gPSBcIlRJTUVEX09VVFwiO1xuICAgIFJFQUxUSU1FX1NVQlNDUklCRV9TVEFURVNbXCJDTE9TRURcIl0gPSBcIkNMT1NFRFwiO1xuICAgIFJFQUxUSU1FX1NVQlNDUklCRV9TVEFURVNbXCJDSEFOTkVMX0VSUk9SXCJdID0gXCJDSEFOTkVMX0VSUk9SXCI7XG59KShSRUFMVElNRV9TVUJTQ1JJQkVfU1RBVEVTIHx8IChSRUFMVElNRV9TVUJTQ1JJQkVfU1RBVEVTID0ge30pKTtcbmV4cG9ydCBjb25zdCBSRUFMVElNRV9DSEFOTkVMX1NUQVRFUyA9IENIQU5ORUxfU1RBVEVTO1xuLyoqIEEgY2hhbm5lbCBpcyB0aGUgYmFzaWMgYnVpbGRpbmcgYmxvY2sgb2YgUmVhbHRpbWVcbiAqIGFuZCBuYXJyb3dzIHRoZSBzY29wZSBvZiBkYXRhIGZsb3cgdG8gc3Vic2NyaWJlZCBjbGllbnRzLlxuICogWW91IGNhbiB0aGluayBvZiBhIGNoYW5uZWwgYXMgYSBjaGF0cm9vbSB3aGVyZSBwYXJ0aWNpcGFudHMgYXJlIGFibGUgdG8gc2VlIHdobydzIG9ubGluZVxuICogYW5kIHNlbmQgYW5kIHJlY2VpdmUgbWVzc2FnZXMuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlYWx0aW1lQ2hhbm5lbCB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqIFRvcGljIG5hbWUgY2FuIGJlIGFueSBzdHJpbmcuICovXG4gICAgdG9waWMsIHBhcmFtcyA9IHsgY29uZmlnOiB7fSB9LCBzb2NrZXQpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgdGhpcy50b3BpYyA9IHRvcGljO1xuICAgICAgICB0aGlzLnBhcmFtcyA9IHBhcmFtcztcbiAgICAgICAgdGhpcy5zb2NrZXQgPSBzb2NrZXQ7XG4gICAgICAgIHRoaXMuYmluZGluZ3MgPSB7fTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IENIQU5ORUxfU1RBVEVTLmNsb3NlZDtcbiAgICAgICAgdGhpcy5qb2luZWRPbmNlID0gZmFsc2U7XG4gICAgICAgIHRoaXMucHVzaEJ1ZmZlciA9IFtdO1xuICAgICAgICB0aGlzLnN1YlRvcGljID0gdG9waWMucmVwbGFjZSgvXnJlYWx0aW1lOi9pLCAnJyk7XG4gICAgICAgIHRoaXMucGFyYW1zLmNvbmZpZyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgYnJvYWRjYXN0OiB7IGFjazogZmFsc2UsIHNlbGY6IGZhbHNlIH0sXG4gICAgICAgICAgICBwcmVzZW5jZTogeyBrZXk6ICcnLCBlbmFibGVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgcHJpdmF0ZTogZmFsc2UsXG4gICAgICAgIH0sIHBhcmFtcy5jb25maWcpO1xuICAgICAgICB0aGlzLnRpbWVvdXQgPSB0aGlzLnNvY2tldC50aW1lb3V0O1xuICAgICAgICB0aGlzLmpvaW5QdXNoID0gbmV3IFB1c2godGhpcywgQ0hBTk5FTF9FVkVOVFMuam9pbiwgdGhpcy5wYXJhbXMsIHRoaXMudGltZW91dCk7XG4gICAgICAgIHRoaXMucmVqb2luVGltZXIgPSBuZXcgVGltZXIoKCkgPT4gdGhpcy5fcmVqb2luVW50aWxDb25uZWN0ZWQoKSwgdGhpcy5zb2NrZXQucmVjb25uZWN0QWZ0ZXJNcyk7XG4gICAgICAgIHRoaXMuam9pblB1c2gucmVjZWl2ZSgnb2snLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gQ0hBTk5FTF9TVEFURVMuam9pbmVkO1xuICAgICAgICAgICAgdGhpcy5yZWpvaW5UaW1lci5yZXNldCgpO1xuICAgICAgICAgICAgdGhpcy5wdXNoQnVmZmVyLmZvckVhY2goKHB1c2hFdmVudCkgPT4gcHVzaEV2ZW50LnNlbmQoKSk7XG4gICAgICAgICAgICB0aGlzLnB1c2hCdWZmZXIgPSBbXTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX29uQ2xvc2UoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5yZWpvaW5UaW1lci5yZXNldCgpO1xuICAgICAgICAgICAgdGhpcy5zb2NrZXQubG9nKCdjaGFubmVsJywgYGNsb3NlICR7dGhpcy50b3BpY30gJHt0aGlzLl9qb2luUmVmKCl9YCk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gQ0hBTk5FTF9TVEFURVMuY2xvc2VkO1xuICAgICAgICAgICAgdGhpcy5zb2NrZXQuX3JlbW92ZSh0aGlzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX29uRXJyb3IoKHJlYXNvbikgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2lzTGVhdmluZygpIHx8IHRoaXMuX2lzQ2xvc2VkKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNvY2tldC5sb2coJ2NoYW5uZWwnLCBgZXJyb3IgJHt0aGlzLnRvcGljfWAsIHJlYXNvbik7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gQ0hBTk5FTF9TVEFURVMuZXJyb3JlZDtcbiAgICAgICAgICAgIHRoaXMucmVqb2luVGltZXIuc2NoZWR1bGVUaW1lb3V0KCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmpvaW5QdXNoLnJlY2VpdmUoJ3RpbWVvdXQnLCAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2lzSm9pbmluZygpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zb2NrZXQubG9nKCdjaGFubmVsJywgYHRpbWVvdXQgJHt0aGlzLnRvcGljfWAsIHRoaXMuam9pblB1c2gudGltZW91dCk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gQ0hBTk5FTF9TVEFURVMuZXJyb3JlZDtcbiAgICAgICAgICAgIHRoaXMucmVqb2luVGltZXIuc2NoZWR1bGVUaW1lb3V0KCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmpvaW5QdXNoLnJlY2VpdmUoJ2Vycm9yJywgKHJlYXNvbikgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2lzTGVhdmluZygpIHx8IHRoaXMuX2lzQ2xvc2VkKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNvY2tldC5sb2coJ2NoYW5uZWwnLCBgZXJyb3IgJHt0aGlzLnRvcGljfWAsIHJlYXNvbik7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gQ0hBTk5FTF9TVEFURVMuZXJyb3JlZDtcbiAgICAgICAgICAgIHRoaXMucmVqb2luVGltZXIuc2NoZWR1bGVUaW1lb3V0KCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9vbihDSEFOTkVMX0VWRU5UUy5yZXBseSwge30sIChwYXlsb2FkLCByZWYpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3RyaWdnZXIodGhpcy5fcmVwbHlFdmVudE5hbWUocmVmKSwgcGF5bG9hZCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnByZXNlbmNlID0gbmV3IFJlYWx0aW1lUHJlc2VuY2UodGhpcyk7XG4gICAgICAgIHRoaXMuYnJvYWRjYXN0RW5kcG9pbnRVUkwgPSBodHRwRW5kcG9pbnRVUkwodGhpcy5zb2NrZXQuZW5kUG9pbnQpO1xuICAgICAgICB0aGlzLnByaXZhdGUgPSB0aGlzLnBhcmFtcy5jb25maWcucHJpdmF0ZSB8fCBmYWxzZTtcbiAgICAgICAgaWYgKCF0aGlzLnByaXZhdGUgJiYgKChfYiA9IChfYSA9IHRoaXMucGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmJyb2FkY2FzdCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnJlcGxheSkpIHtcbiAgICAgICAgICAgIHRocm93IGB0cmllZCB0byB1c2UgcmVwbGF5IG9uIHB1YmxpYyBjaGFubmVsICcke3RoaXMudG9waWN9Jy4gSXQgbXVzdCBiZSBhIHByaXZhdGUgY2hhbm5lbC5gO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBTdWJzY3JpYmUgcmVnaXN0ZXJzIHlvdXIgY2xpZW50IHdpdGggdGhlIHNlcnZlciAqL1xuICAgIHN1YnNjcmliZShjYWxsYmFjaywgdGltZW91dCA9IHRoaXMudGltZW91dCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgaWYgKCF0aGlzLnNvY2tldC5pc0Nvbm5lY3RlZCgpKSB7XG4gICAgICAgICAgICB0aGlzLnNvY2tldC5jb25uZWN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT0gQ0hBTk5FTF9TVEFURVMuY2xvc2VkKSB7XG4gICAgICAgICAgICBjb25zdCB7IGNvbmZpZzogeyBicm9hZGNhc3QsIHByZXNlbmNlLCBwcml2YXRlOiBpc1ByaXZhdGUgfSwgfSA9IHRoaXMucGFyYW1zO1xuICAgICAgICAgICAgY29uc3QgcG9zdGdyZXNfY2hhbmdlcyA9IChfYiA9IChfYSA9IHRoaXMuYmluZGluZ3MucG9zdGdyZXNfY2hhbmdlcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1hcCgocikgPT4gci5maWx0ZXIpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBbXTtcbiAgICAgICAgICAgIGNvbnN0IHByZXNlbmNlX2VuYWJsZWQgPSAoISF0aGlzLmJpbmRpbmdzW1JFQUxUSU1FX0xJU1RFTl9UWVBFUy5QUkVTRU5DRV0gJiZcbiAgICAgICAgICAgICAgICB0aGlzLmJpbmRpbmdzW1JFQUxUSU1FX0xJU1RFTl9UWVBFUy5QUkVTRU5DRV0ubGVuZ3RoID4gMCkgfHxcbiAgICAgICAgICAgICAgICAoKF9jID0gdGhpcy5wYXJhbXMuY29uZmlnLnByZXNlbmNlKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuZW5hYmxlZCkgPT09IHRydWU7XG4gICAgICAgICAgICBjb25zdCBhY2Nlc3NUb2tlblBheWxvYWQgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGNvbmZpZyA9IHtcbiAgICAgICAgICAgICAgICBicm9hZGNhc3QsXG4gICAgICAgICAgICAgICAgcHJlc2VuY2U6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcHJlc2VuY2UpLCB7IGVuYWJsZWQ6IHByZXNlbmNlX2VuYWJsZWQgfSksXG4gICAgICAgICAgICAgICAgcG9zdGdyZXNfY2hhbmdlcyxcbiAgICAgICAgICAgICAgICBwcml2YXRlOiBpc1ByaXZhdGUsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHRoaXMuc29ja2V0LmFjY2Vzc1Rva2VuVmFsdWUpIHtcbiAgICAgICAgICAgICAgICBhY2Nlc3NUb2tlblBheWxvYWQuYWNjZXNzX3Rva2VuID0gdGhpcy5zb2NrZXQuYWNjZXNzVG9rZW5WYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX29uRXJyb3IoKGUpID0+IGNhbGxiYWNrID09PSBudWxsIHx8IGNhbGxiYWNrID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjYWxsYmFjayhSRUFMVElNRV9TVUJTQ1JJQkVfU1RBVEVTLkNIQU5ORUxfRVJST1IsIGUpKTtcbiAgICAgICAgICAgIHRoaXMuX29uQ2xvc2UoKCkgPT4gY2FsbGJhY2sgPT09IG51bGwgfHwgY2FsbGJhY2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNhbGxiYWNrKFJFQUxUSU1FX1NVQlNDUklCRV9TVEFURVMuQ0xPU0VEKSk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUpvaW5QYXlsb2FkKE9iamVjdC5hc3NpZ24oeyBjb25maWcgfSwgYWNjZXNzVG9rZW5QYXlsb2FkKSk7XG4gICAgICAgICAgICB0aGlzLmpvaW5lZE9uY2UgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fcmVqb2luKHRpbWVvdXQpO1xuICAgICAgICAgICAgdGhpcy5qb2luUHVzaFxuICAgICAgICAgICAgICAgIC5yZWNlaXZlKCdvaycsIGFzeW5jICh7IHBvc3RncmVzX2NoYW5nZXMgfSkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICB0aGlzLnNvY2tldC5zZXRBdXRoKCk7XG4gICAgICAgICAgICAgICAgaWYgKHBvc3RncmVzX2NoYW5nZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayA9PT0gbnVsbCB8fCBjYWxsYmFjayA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2FsbGJhY2soUkVBTFRJTUVfU1VCU0NSSUJFX1NUQVRFUy5TVUJTQ1JJQkVEKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2xpZW50UG9zdGdyZXNCaW5kaW5ncyA9IHRoaXMuYmluZGluZ3MucG9zdGdyZXNfY2hhbmdlcztcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYmluZGluZ3NMZW4gPSAoX2EgPSBjbGllbnRQb3N0Z3Jlc0JpbmRpbmdzID09PSBudWxsIHx8IGNsaWVudFBvc3RncmVzQmluZGluZ3MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNsaWVudFBvc3RncmVzQmluZGluZ3MubGVuZ3RoKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdQb3N0Z3Jlc0JpbmRpbmdzID0gW107XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmluZGluZ3NMZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2xpZW50UG9zdGdyZXNCaW5kaW5nID0gY2xpZW50UG9zdGdyZXNCaW5kaW5nc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgZmlsdGVyOiB7IGV2ZW50LCBzY2hlbWEsIHRhYmxlLCBmaWx0ZXIgfSwgfSA9IGNsaWVudFBvc3RncmVzQmluZGluZztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlcnZlclBvc3RncmVzRmlsdGVyID0gcG9zdGdyZXNfY2hhbmdlcyAmJiBwb3N0Z3Jlc19jaGFuZ2VzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlcnZlclBvc3RncmVzRmlsdGVyICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VydmVyUG9zdGdyZXNGaWx0ZXIuZXZlbnQgPT09IGV2ZW50ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VydmVyUG9zdGdyZXNGaWx0ZXIuc2NoZW1hID09PSBzY2hlbWEgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXJ2ZXJQb3N0Z3Jlc0ZpbHRlci50YWJsZSA9PT0gdGFibGUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXJ2ZXJQb3N0Z3Jlc0ZpbHRlci5maWx0ZXIgPT09IGZpbHRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1Bvc3RncmVzQmluZGluZ3MucHVzaChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGNsaWVudFBvc3RncmVzQmluZGluZyksIHsgaWQ6IHNlcnZlclBvc3RncmVzRmlsdGVyLmlkIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gQ0hBTk5FTF9TVEFURVMuZXJyb3JlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayA9PT0gbnVsbCB8fCBjYWxsYmFjayA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2FsbGJhY2soUkVBTFRJTUVfU1VCU0NSSUJFX1NUQVRFUy5DSEFOTkVMX0VSUk9SLCBuZXcgRXJyb3IoJ21pc21hdGNoIGJldHdlZW4gc2VydmVyIGFuZCBjbGllbnQgYmluZGluZ3MgZm9yIHBvc3RncmVzIGNoYW5nZXMnKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYmluZGluZ3MucG9zdGdyZXNfY2hhbmdlcyA9IG5ld1Bvc3RncmVzQmluZGluZ3M7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKFJFQUxUSU1FX1NVQlNDUklCRV9TVEFURVMuU1VCU0NSSUJFRCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5yZWNlaXZlKCdlcnJvcicsIChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBDSEFOTkVMX1NUQVRFUy5lcnJvcmVkO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrID09PSBudWxsIHx8IGNhbGxiYWNrID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjYWxsYmFjayhSRUFMVElNRV9TVUJTQ1JJQkVfU1RBVEVTLkNIQU5ORUxfRVJST1IsIG5ldyBFcnJvcihKU09OLnN0cmluZ2lmeShPYmplY3QudmFsdWVzKGVycm9yKS5qb2luKCcsICcpIHx8ICdlcnJvcicpKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAucmVjZWl2ZSgndGltZW91dCcsICgpID0+IHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayA9PT0gbnVsbCB8fCBjYWxsYmFjayA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2FsbGJhY2soUkVBTFRJTUVfU1VCU0NSSUJFX1NUQVRFUy5USU1FRF9PVVQpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBwcmVzZW5jZVN0YXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcmVzZW5jZS5zdGF0ZTtcbiAgICB9XG4gICAgYXN5bmMgdHJhY2socGF5bG9hZCwgb3B0cyA9IHt9KSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnNlbmQoe1xuICAgICAgICAgICAgdHlwZTogJ3ByZXNlbmNlJyxcbiAgICAgICAgICAgIGV2ZW50OiAndHJhY2snLFxuICAgICAgICAgICAgcGF5bG9hZCxcbiAgICAgICAgfSwgb3B0cy50aW1lb3V0IHx8IHRoaXMudGltZW91dCk7XG4gICAgfVxuICAgIGFzeW5jIHVudHJhY2sob3B0cyA9IHt9KSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnNlbmQoe1xuICAgICAgICAgICAgdHlwZTogJ3ByZXNlbmNlJyxcbiAgICAgICAgICAgIGV2ZW50OiAndW50cmFjaycsXG4gICAgICAgIH0sIG9wdHMpO1xuICAgIH1cbiAgICBvbih0eXBlLCBmaWx0ZXIsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09PSBDSEFOTkVMX1NUQVRFUy5qb2luZWQgJiYgdHlwZSA9PT0gUkVBTFRJTUVfTElTVEVOX1RZUEVTLlBSRVNFTkNFKSB7XG4gICAgICAgICAgICB0aGlzLnNvY2tldC5sb2coJ2NoYW5uZWwnLCBgcmVzdWJzY3JpYmUgdG8gJHt0aGlzLnRvcGljfSBkdWUgdG8gY2hhbmdlIGluIHByZXNlbmNlIGNhbGxiYWNrcyBvbiBqb2luZWQgY2hhbm5lbGApO1xuICAgICAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpLnRoZW4oKCkgPT4gdGhpcy5zdWJzY3JpYmUoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX29uKHR5cGUsIGZpbHRlciwgY2FsbGJhY2spO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kcyBhIG1lc3NhZ2UgaW50byB0aGUgY2hhbm5lbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhcmdzIEFyZ3VtZW50cyB0byBzZW5kIHRvIGNoYW5uZWxcbiAgICAgKiBAcGFyYW0gYXJncy50eXBlIFRoZSB0eXBlIG9mIGV2ZW50IHRvIHNlbmRcbiAgICAgKiBAcGFyYW0gYXJncy5ldmVudCBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgYmVpbmcgc2VudFxuICAgICAqIEBwYXJhbSBhcmdzLnBheWxvYWQgUGF5bG9hZCB0byBiZSBzZW50XG4gICAgICogQHBhcmFtIG9wdHMgT3B0aW9ucyB0byBiZSB1c2VkIGR1cmluZyB0aGUgc2VuZCBwcm9jZXNzXG4gICAgICovXG4gICAgYXN5bmMgc2VuZChhcmdzLCBvcHRzID0ge30pIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgaWYgKCF0aGlzLl9jYW5QdXNoKCkgJiYgYXJncy50eXBlID09PSAnYnJvYWRjYXN0Jykge1xuICAgICAgICAgICAgY29uc3QgeyBldmVudCwgcGF5bG9hZDogZW5kcG9pbnRfcGF5bG9hZCB9ID0gYXJncztcbiAgICAgICAgICAgIGNvbnN0IGF1dGhvcml6YXRpb24gPSB0aGlzLnNvY2tldC5hY2Nlc3NUb2tlblZhbHVlXG4gICAgICAgICAgICAgICAgPyBgQmVhcmVyICR7dGhpcy5zb2NrZXQuYWNjZXNzVG9rZW5WYWx1ZX1gXG4gICAgICAgICAgICAgICAgOiAnJztcbiAgICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICAgICBBdXRob3JpemF0aW9uOiBhdXRob3JpemF0aW9uLFxuICAgICAgICAgICAgICAgICAgICBhcGlrZXk6IHRoaXMuc29ja2V0LmFwaUtleSA/IHRoaXMuc29ja2V0LmFwaUtleSA6ICcnLFxuICAgICAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlczogW1xuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcGljOiB0aGlzLnN1YlRvcGljLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBheWxvYWQ6IGVuZHBvaW50X3BheWxvYWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJpdmF0ZTogdGhpcy5wcml2YXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5fZmV0Y2hXaXRoVGltZW91dCh0aGlzLmJyb2FkY2FzdEVuZHBvaW50VVJMLCBvcHRpb25zLCAoX2EgPSBvcHRzLnRpbWVvdXQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHRoaXMudGltZW91dCk7XG4gICAgICAgICAgICAgICAgYXdhaXQgKChfYiA9IHJlc3BvbnNlLmJvZHkpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYW5jZWwoKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLm9rID8gJ29rJyA6ICdlcnJvcic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IubmFtZSA9PT0gJ0Fib3J0RXJyb3InKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAndGltZWQgb3V0JztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnZXJyb3InO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICAgICAgICAgIGNvbnN0IHB1c2ggPSB0aGlzLl9wdXNoKGFyZ3MudHlwZSwgYXJncywgb3B0cy50aW1lb3V0IHx8IHRoaXMudGltZW91dCk7XG4gICAgICAgICAgICAgICAgaWYgKGFyZ3MudHlwZSA9PT0gJ2Jyb2FkY2FzdCcgJiYgISgoX2MgPSAoX2IgPSAoX2EgPSB0aGlzLnBhcmFtcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmJyb2FkY2FzdCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmFjaykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgnb2snKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcHVzaC5yZWNlaXZlKCdvaycsICgpID0+IHJlc29sdmUoJ29rJykpO1xuICAgICAgICAgICAgICAgIHB1c2gucmVjZWl2ZSgnZXJyb3InLCAoKSA9PiByZXNvbHZlKCdlcnJvcicpKTtcbiAgICAgICAgICAgICAgICBwdXNoLnJlY2VpdmUoJ3RpbWVvdXQnLCAoKSA9PiByZXNvbHZlKCd0aW1lZCBvdXQnKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGVKb2luUGF5bG9hZChwYXlsb2FkKSB7XG4gICAgICAgIHRoaXMuam9pblB1c2gudXBkYXRlUGF5bG9hZChwYXlsb2FkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGVhdmVzIHRoZSBjaGFubmVsLlxuICAgICAqXG4gICAgICogVW5zdWJzY3JpYmVzIGZyb20gc2VydmVyIGV2ZW50cywgYW5kIGluc3RydWN0cyBjaGFubmVsIHRvIHRlcm1pbmF0ZSBvbiBzZXJ2ZXIuXG4gICAgICogVHJpZ2dlcnMgb25DbG9zZSgpIGhvb2tzLlxuICAgICAqXG4gICAgICogVG8gcmVjZWl2ZSBsZWF2ZSBhY2tub3dsZWRnZW1lbnRzLCB1c2UgdGhlIGEgYHJlY2VpdmVgIGhvb2sgdG8gYmluZCB0byB0aGUgc2VydmVyIGFjaywgaWU6XG4gICAgICogY2hhbm5lbC51bnN1YnNjcmliZSgpLnJlY2VpdmUoXCJva1wiLCAoKSA9PiBhbGVydChcImxlZnQhXCIpIClcbiAgICAgKi9cbiAgICB1bnN1YnNjcmliZSh0aW1lb3V0ID0gdGhpcy50aW1lb3V0KSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBDSEFOTkVMX1NUQVRFUy5sZWF2aW5nO1xuICAgICAgICBjb25zdCBvbkNsb3NlID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zb2NrZXQubG9nKCdjaGFubmVsJywgYGxlYXZlICR7dGhpcy50b3BpY31gKTtcbiAgICAgICAgICAgIHRoaXMuX3RyaWdnZXIoQ0hBTk5FTF9FVkVOVFMuY2xvc2UsICdsZWF2ZScsIHRoaXMuX2pvaW5SZWYoKSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuam9pblB1c2guZGVzdHJveSgpO1xuICAgICAgICBsZXQgbGVhdmVQdXNoID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICBsZWF2ZVB1c2ggPSBuZXcgUHVzaCh0aGlzLCBDSEFOTkVMX0VWRU5UUy5sZWF2ZSwge30sIHRpbWVvdXQpO1xuICAgICAgICAgICAgbGVhdmVQdXNoXG4gICAgICAgICAgICAgICAgLnJlY2VpdmUoJ29rJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIG9uQ2xvc2UoKTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKCdvaycpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAucmVjZWl2ZSgndGltZW91dCcsICgpID0+IHtcbiAgICAgICAgICAgICAgICBvbkNsb3NlKCk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgndGltZWQgb3V0Jyk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5yZWNlaXZlKCdlcnJvcicsICgpID0+IHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKCdlcnJvcicpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBsZWF2ZVB1c2guc2VuZCgpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9jYW5QdXNoKCkpIHtcbiAgICAgICAgICAgICAgICBsZWF2ZVB1c2gudHJpZ2dlcignb2snLCB7fSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgICAgICAgbGVhdmVQdXNoID09PSBudWxsIHx8IGxlYXZlUHVzaCA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGVhdmVQdXNoLmRlc3Ryb3koKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRlYXJkb3duIHRoZSBjaGFubmVsLlxuICAgICAqXG4gICAgICogRGVzdHJveXMgYW5kIHN0b3BzIHJlbGF0ZWQgdGltZXJzLlxuICAgICAqL1xuICAgIHRlYXJkb3duKCkge1xuICAgICAgICB0aGlzLnB1c2hCdWZmZXIuZm9yRWFjaCgocHVzaCkgPT4gcHVzaC5kZXN0cm95KCkpO1xuICAgICAgICB0aGlzLnB1c2hCdWZmZXIgPSBbXTtcbiAgICAgICAgdGhpcy5yZWpvaW5UaW1lci5yZXNldCgpO1xuICAgICAgICB0aGlzLmpvaW5QdXNoLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IENIQU5ORUxfU1RBVEVTLmNsb3NlZDtcbiAgICAgICAgdGhpcy5iaW5kaW5ncyA9IHt9O1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgYXN5bmMgX2ZldGNoV2l0aFRpbWVvdXQodXJsLCBvcHRpb25zLCB0aW1lb3V0KSB7XG4gICAgICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgICAgIGNvbnN0IGlkID0gc2V0VGltZW91dCgoKSA9PiBjb250cm9sbGVyLmFib3J0KCksIHRpbWVvdXQpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuc29ja2V0LmZldGNoKHVybCwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKSwgeyBzaWduYWw6IGNvbnRyb2xsZXIuc2lnbmFsIH0pKTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KGlkKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX3B1c2goZXZlbnQsIHBheWxvYWQsIHRpbWVvdXQgPSB0aGlzLnRpbWVvdXQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmpvaW5lZE9uY2UpIHtcbiAgICAgICAgICAgIHRocm93IGB0cmllZCB0byBwdXNoICcke2V2ZW50fScgdG8gJyR7dGhpcy50b3BpY30nIGJlZm9yZSBqb2luaW5nLiBVc2UgY2hhbm5lbC5zdWJzY3JpYmUoKSBiZWZvcmUgcHVzaGluZyBldmVudHNgO1xuICAgICAgICB9XG4gICAgICAgIGxldCBwdXNoRXZlbnQgPSBuZXcgUHVzaCh0aGlzLCBldmVudCwgcGF5bG9hZCwgdGltZW91dCk7XG4gICAgICAgIGlmICh0aGlzLl9jYW5QdXNoKCkpIHtcbiAgICAgICAgICAgIHB1c2hFdmVudC5zZW5kKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9hZGRUb1B1c2hCdWZmZXIocHVzaEV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHVzaEV2ZW50O1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX2FkZFRvUHVzaEJ1ZmZlcihwdXNoRXZlbnQpIHtcbiAgICAgICAgcHVzaEV2ZW50LnN0YXJ0VGltZW91dCgpO1xuICAgICAgICB0aGlzLnB1c2hCdWZmZXIucHVzaChwdXNoRXZlbnQpO1xuICAgICAgICAvLyBFbmZvcmNlIGJ1ZmZlciBzaXplIGxpbWl0XG4gICAgICAgIGlmICh0aGlzLnB1c2hCdWZmZXIubGVuZ3RoID4gTUFYX1BVU0hfQlVGRkVSX1NJWkUpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlbW92ZWRQdXNoID0gdGhpcy5wdXNoQnVmZmVyLnNoaWZ0KCk7XG4gICAgICAgICAgICBpZiAocmVtb3ZlZFB1c2gpIHtcbiAgICAgICAgICAgICAgICByZW1vdmVkUHVzaC5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zb2NrZXQubG9nKCdjaGFubmVsJywgYGRpc2NhcmRlZCBwdXNoIGR1ZSB0byBidWZmZXIgb3ZlcmZsb3c6ICR7cmVtb3ZlZFB1c2guZXZlbnR9YCwgcmVtb3ZlZFB1c2gucGF5bG9hZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGFibGUgbWVzc2FnZSBob29rXG4gICAgICpcbiAgICAgKiBSZWNlaXZlcyBhbGwgZXZlbnRzIGZvciBzcGVjaWFsaXplZCBtZXNzYWdlIGhhbmRsaW5nIGJlZm9yZSBkaXNwYXRjaGluZyB0byB0aGUgY2hhbm5lbCBjYWxsYmFja3MuXG4gICAgICogTXVzdCByZXR1cm4gdGhlIHBheWxvYWQsIG1vZGlmaWVkIG9yIHVubW9kaWZpZWQuXG4gICAgICpcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBfb25NZXNzYWdlKF9ldmVudCwgcGF5bG9hZCwgX3JlZikge1xuICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9pc01lbWJlcih0b3BpYykge1xuICAgICAgICByZXR1cm4gdGhpcy50b3BpYyA9PT0gdG9waWM7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfam9pblJlZigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuam9pblB1c2gucmVmO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX3RyaWdnZXIodHlwZSwgcGF5bG9hZCwgcmVmKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IHR5cGVMb3dlciA9IHR5cGUudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgY29uc3QgeyBjbG9zZSwgZXJyb3IsIGxlYXZlLCBqb2luIH0gPSBDSEFOTkVMX0VWRU5UUztcbiAgICAgICAgY29uc3QgZXZlbnRzID0gW2Nsb3NlLCBlcnJvciwgbGVhdmUsIGpvaW5dO1xuICAgICAgICBpZiAocmVmICYmIGV2ZW50cy5pbmRleE9mKHR5cGVMb3dlcikgPj0gMCAmJiByZWYgIT09IHRoaXMuX2pvaW5SZWYoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBoYW5kbGVkUGF5bG9hZCA9IHRoaXMuX29uTWVzc2FnZSh0eXBlTG93ZXIsIHBheWxvYWQsIHJlZik7XG4gICAgICAgIGlmIChwYXlsb2FkICYmICFoYW5kbGVkUGF5bG9hZCkge1xuICAgICAgICAgICAgdGhyb3cgJ2NoYW5uZWwgb25NZXNzYWdlIGNhbGxiYWNrcyBtdXN0IHJldHVybiB0aGUgcGF5bG9hZCwgbW9kaWZpZWQgb3IgdW5tb2RpZmllZCc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFsnaW5zZXJ0JywgJ3VwZGF0ZScsICdkZWxldGUnXS5pbmNsdWRlcyh0eXBlTG93ZXIpKSB7XG4gICAgICAgICAgICAoX2EgPSB0aGlzLmJpbmRpbmdzLnBvc3RncmVzX2NoYW5nZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5maWx0ZXIoKGJpbmQpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgICAgICAgICByZXR1cm4gKChfYSA9IGJpbmQuZmlsdGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZXZlbnQpID09PSAnKicgfHwgKChfYyA9IChfYiA9IGJpbmQuZmlsdGVyKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZXZlbnQpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy50b0xvY2FsZUxvd2VyQ2FzZSgpKSA9PT0gdHlwZUxvd2VyO1xuICAgICAgICAgICAgfSkubWFwKChiaW5kKSA9PiBiaW5kLmNhbGxiYWNrKGhhbmRsZWRQYXlsb2FkLCByZWYpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIChfYiA9IHRoaXMuYmluZGluZ3NbdHlwZUxvd2VyXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmZpbHRlcigoYmluZCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mO1xuICAgICAgICAgICAgICAgIGlmIChbJ2Jyb2FkY2FzdCcsICdwcmVzZW5jZScsICdwb3N0Z3Jlc19jaGFuZ2VzJ10uaW5jbHVkZXModHlwZUxvd2VyKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoJ2lkJyBpbiBiaW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBiaW5kSWQgPSBiaW5kLmlkO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYmluZEV2ZW50ID0gKF9hID0gYmluZC5maWx0ZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5ldmVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoYmluZElkICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKChfYiA9IHBheWxvYWQuaWRzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuaW5jbHVkZXMoYmluZElkKSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoYmluZEV2ZW50ID09PSAnKicgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGJpbmRFdmVudCA9PT0gbnVsbCB8fCBiaW5kRXZlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGJpbmRFdmVudC50b0xvY2FsZUxvd2VyQ2FzZSgpKSA9PT0gKChfYyA9IHBheWxvYWQuZGF0YSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnR5cGUudG9Mb2NhbGVMb3dlckNhc2UoKSkpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGJpbmRFdmVudCA9IChfZSA9IChfZCA9IGJpbmQgPT09IG51bGwgfHwgYmluZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogYmluZC5maWx0ZXIpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5ldmVudCkgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmluZEV2ZW50ID09PSAnKicgfHwgYmluZEV2ZW50ID09PSAoKF9mID0gcGF5bG9hZCA9PT0gbnVsbCB8fCBwYXlsb2FkID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXlsb2FkLmV2ZW50KSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2YudG9Mb2NhbGVMb3dlckNhc2UoKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBiaW5kLnR5cGUudG9Mb2NhbGVMb3dlckNhc2UoKSA9PT0gdHlwZUxvd2VyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLm1hcCgoYmluZCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaGFuZGxlZFBheWxvYWQgPT09ICdvYmplY3QnICYmICdpZHMnIGluIGhhbmRsZWRQYXlsb2FkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBvc3RncmVzQ2hhbmdlcyA9IGhhbmRsZWRQYXlsb2FkLmRhdGE7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgc2NoZW1hLCB0YWJsZSwgY29tbWl0X3RpbWVzdGFtcCwgdHlwZSwgZXJyb3JzIH0gPSBwb3N0Z3Jlc0NoYW5nZXM7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVucmljaGVkUGF5bG9hZCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjaGVtYTogc2NoZW1hLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFibGU6IHRhYmxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29tbWl0X3RpbWVzdGFtcDogY29tbWl0X3RpbWVzdGFtcCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50VHlwZTogdHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldzoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICBvbGQ6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzOiBlcnJvcnMsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZWRQYXlsb2FkID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBlbnJpY2hlZFBheWxvYWQpLCB0aGlzLl9nZXRQYXlsb2FkUmVjb3Jkcyhwb3N0Z3Jlc0NoYW5nZXMpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYmluZC5jYWxsYmFjayhoYW5kbGVkUGF5bG9hZCwgcmVmKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfaXNDbG9zZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlID09PSBDSEFOTkVMX1NUQVRFUy5jbG9zZWQ7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfaXNKb2luZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlID09PSBDSEFOTkVMX1NUQVRFUy5qb2luZWQ7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfaXNKb2luaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZSA9PT0gQ0hBTk5FTF9TVEFURVMuam9pbmluZztcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9pc0xlYXZpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlID09PSBDSEFOTkVMX1NUQVRFUy5sZWF2aW5nO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX3JlcGx5RXZlbnROYW1lKHJlZikge1xuICAgICAgICByZXR1cm4gYGNoYW5fcmVwbHlfJHtyZWZ9YDtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9vbih0eXBlLCBmaWx0ZXIsIGNhbGxiYWNrKSB7XG4gICAgICAgIGNvbnN0IHR5cGVMb3dlciA9IHR5cGUudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgY29uc3QgYmluZGluZyA9IHtcbiAgICAgICAgICAgIHR5cGU6IHR5cGVMb3dlcixcbiAgICAgICAgICAgIGZpbHRlcjogZmlsdGVyLFxuICAgICAgICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrLFxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5iaW5kaW5nc1t0eXBlTG93ZXJdKSB7XG4gICAgICAgICAgICB0aGlzLmJpbmRpbmdzW3R5cGVMb3dlcl0ucHVzaChiaW5kaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYmluZGluZ3NbdHlwZUxvd2VyXSA9IFtiaW5kaW5nXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9vZmYodHlwZSwgZmlsdGVyKSB7XG4gICAgICAgIGNvbnN0IHR5cGVMb3dlciA9IHR5cGUudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKHRoaXMuYmluZGluZ3NbdHlwZUxvd2VyXSkge1xuICAgICAgICAgICAgdGhpcy5iaW5kaW5nc1t0eXBlTG93ZXJdID0gdGhpcy5iaW5kaW5nc1t0eXBlTG93ZXJdLmZpbHRlcigoYmluZCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICByZXR1cm4gISgoKF9hID0gYmluZC50eXBlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudG9Mb2NhbGVMb3dlckNhc2UoKSkgPT09IHR5cGVMb3dlciAmJlxuICAgICAgICAgICAgICAgICAgICBSZWFsdGltZUNoYW5uZWwuaXNFcXVhbChiaW5kLmZpbHRlciwgZmlsdGVyKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHN0YXRpYyBpc0VxdWFsKG9iajEsIG9iajIpIHtcbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKG9iajEpLmxlbmd0aCAhPT0gT2JqZWN0LmtleXMob2JqMikubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBrIGluIG9iajEpIHtcbiAgICAgICAgICAgIGlmIChvYmoxW2tdICE9PSBvYmoyW2tdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX3Jlam9pblVudGlsQ29ubmVjdGVkKCkge1xuICAgICAgICB0aGlzLnJlam9pblRpbWVyLnNjaGVkdWxlVGltZW91dCgpO1xuICAgICAgICBpZiAodGhpcy5zb2NrZXQuaXNDb25uZWN0ZWQoKSkge1xuICAgICAgICAgICAgdGhpcy5fcmVqb2luKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIGEgY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIHdoZW4gdGhlIGNoYW5uZWwgY2xvc2VzLlxuICAgICAqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgX29uQ2xvc2UoY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5fb24oQ0hBTk5FTF9FVkVOVFMuY2xvc2UsIHt9LCBjYWxsYmFjayk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBhIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBleGVjdXRlZCB3aGVuIHRoZSBjaGFubmVsIGVuY291bnRlcmVzIGFuIGVycm9yLlxuICAgICAqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgX29uRXJyb3IoY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5fb24oQ0hBTk5FTF9FVkVOVFMuZXJyb3IsIHt9LCAocmVhc29uKSA9PiBjYWxsYmFjayhyZWFzb24pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHNvY2tldCBpcyBjb25uZWN0ZWQgYW5kIHRoZSBjaGFubmVsIGhhcyBiZWVuIGpvaW5lZC5cbiAgICAgKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIF9jYW5QdXNoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zb2NrZXQuaXNDb25uZWN0ZWQoKSAmJiB0aGlzLl9pc0pvaW5lZCgpO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX3Jlam9pbih0aW1lb3V0ID0gdGhpcy50aW1lb3V0KSB7XG4gICAgICAgIGlmICh0aGlzLl9pc0xlYXZpbmcoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc29ja2V0Ll9sZWF2ZU9wZW5Ub3BpYyh0aGlzLnRvcGljKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IENIQU5ORUxfU1RBVEVTLmpvaW5pbmc7XG4gICAgICAgIHRoaXMuam9pblB1c2gucmVzZW5kKHRpbWVvdXQpO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX2dldFBheWxvYWRSZWNvcmRzKHBheWxvYWQpIHtcbiAgICAgICAgY29uc3QgcmVjb3JkcyA9IHtcbiAgICAgICAgICAgIG5ldzoge30sXG4gICAgICAgICAgICBvbGQ6IHt9LFxuICAgICAgICB9O1xuICAgICAgICBpZiAocGF5bG9hZC50eXBlID09PSAnSU5TRVJUJyB8fCBwYXlsb2FkLnR5cGUgPT09ICdVUERBVEUnKSB7XG4gICAgICAgICAgICByZWNvcmRzLm5ldyA9IFRyYW5zZm9ybWVycy5jb252ZXJ0Q2hhbmdlRGF0YShwYXlsb2FkLmNvbHVtbnMsIHBheWxvYWQucmVjb3JkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGF5bG9hZC50eXBlID09PSAnVVBEQVRFJyB8fCBwYXlsb2FkLnR5cGUgPT09ICdERUxFVEUnKSB7XG4gICAgICAgICAgICByZWNvcmRzLm9sZCA9IFRyYW5zZm9ybWVycy5jb252ZXJ0Q2hhbmdlRGF0YShwYXlsb2FkLmNvbHVtbnMsIHBheWxvYWQub2xkX3JlY29yZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlY29yZHM7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UmVhbHRpbWVDaGFubmVsLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/realtime-js/dist/module/RealtimeChannel.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/realtime-js/dist/module/RealtimeClient.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@supabase/realtime-js/dist/module/RealtimeClient.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ RealtimeClient)\n/* harmony export */ });\n/* harmony import */ var _lib_websocket_factory__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/websocket-factory */ \"(app-pages-browser)/./node_modules/@supabase/realtime-js/dist/module/lib/websocket-factory.js\");\n/* harmony import */ var _lib_constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/constants */ \"(app-pages-browser)/./node_modules/@supabase/realtime-js/dist/module/lib/constants.js\");\n/* harmony import */ var _lib_serializer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/serializer */ \"(app-pages-browser)/./node_modules/@supabase/realtime-js/dist/module/lib/serializer.js\");\n/* harmony import */ var _lib_timer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lib/timer */ \"(app-pages-browser)/./node_modules/@supabase/realtime-js/dist/module/lib/timer.js\");\n/* harmony import */ var _lib_transformers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./lib/transformers */ \"(app-pages-browser)/./node_modules/@supabase/realtime-js/dist/module/lib/transformers.js\");\n/* harmony import */ var _RealtimeChannel__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./RealtimeChannel */ \"(app-pages-browser)/./node_modules/@supabase/realtime-js/dist/module/RealtimeChannel.js\");\n\n\n\n\n\n\nconst noop = () => { };\n// Connection-related constants\nconst CONNECTION_TIMEOUTS = {\n    HEARTBEAT_INTERVAL: 25000,\n    RECONNECT_DELAY: 10,\n    HEARTBEAT_TIMEOUT_FALLBACK: 100,\n};\nconst RECONNECT_INTERVALS = [1000, 2000, 5000, 10000];\nconst DEFAULT_RECONNECT_FALLBACK = 10000;\nconst WORKER_SCRIPT = `\n  addEventListener(\"message\", (e) => {\n    if (e.data.event === \"start\") {\n      setInterval(() => postMessage({ event: \"keepAlive\" }), e.data.interval);\n    }\n  });`;\nclass RealtimeClient {\n    /**\n     * Initializes the Socket.\n     *\n     * @param endPoint The string WebSocket endpoint, ie, \"ws://example.com/socket\", \"wss://example.com\", \"/socket\" (inherited host & protocol)\n     * @param httpEndpoint The string HTTP endpoint, ie, \"https://example.com\", \"/\" (inherited host & protocol)\n     * @param options.transport The Websocket Transport, for example WebSocket. This can be a custom implementation\n     * @param options.timeout The default timeout in milliseconds to trigger push timeouts.\n     * @param options.params The optional params to pass when connecting.\n     * @param options.headers Deprecated: headers cannot be set on websocket connections and this option will be removed in the future.\n     * @param options.heartbeatIntervalMs The millisec interval to send a heartbeat message.\n     * @param options.heartbeatCallback The optional function to handle heartbeat status.\n     * @param options.logger The optional function for specialized logging, ie: logger: (kind, msg, data) => { console.log(`${kind}: ${msg}`, data) }\n     * @param options.logLevel Sets the log level for Realtime\n     * @param options.encode The function to encode outgoing messages. Defaults to JSON: (payload, callback) => callback(JSON.stringify(payload))\n     * @param options.decode The function to decode incoming messages. Defaults to Serializer's decode.\n     * @param options.reconnectAfterMs he optional function that returns the millsec reconnect interval. Defaults to stepped backoff off.\n     * @param options.worker Use Web Worker to set a side flow. Defaults to false.\n     * @param options.workerUrl The URL of the worker script. Defaults to https://realtime.supabase.com/worker.js that includes a heartbeat event call to keep the connection alive.\n     */\n    constructor(endPoint, options) {\n        var _a;\n        this.accessTokenValue = null;\n        this.apiKey = null;\n        this.channels = new Array();\n        this.endPoint = '';\n        this.httpEndpoint = '';\n        /** @deprecated headers cannot be set on websocket connections */\n        this.headers = {};\n        this.params = {};\n        this.timeout = _lib_constants__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_TIMEOUT;\n        this.transport = null;\n        this.heartbeatIntervalMs = CONNECTION_TIMEOUTS.HEARTBEAT_INTERVAL;\n        this.heartbeatTimer = undefined;\n        this.pendingHeartbeatRef = null;\n        this.heartbeatCallback = noop;\n        this.ref = 0;\n        this.reconnectTimer = null;\n        this.logger = noop;\n        this.conn = null;\n        this.sendBuffer = [];\n        this.serializer = new _lib_serializer__WEBPACK_IMPORTED_MODULE_2__[\"default\"]();\n        this.stateChangeCallbacks = {\n            open: [],\n            close: [],\n            error: [],\n            message: [],\n        };\n        this.accessToken = null;\n        this._connectionState = 'disconnected';\n        this._wasManualDisconnect = false;\n        this._authPromise = null;\n        /**\n         * Use either custom fetch, if provided, or default fetch to make HTTP requests\n         *\n         * @internal\n         */\n        this._resolveFetch = (customFetch) => {\n            let _fetch;\n            if (customFetch) {\n                _fetch = customFetch;\n            }\n            else if (typeof fetch === 'undefined') {\n                // Node.js environment without native fetch\n                _fetch = (...args) => Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! @supabase/node-fetch */ \"(app-pages-browser)/./node_modules/@supabase/node-fetch/browser.js\"))\n                    .then(({ default: fetch }) => fetch(...args))\n                    .catch((error) => {\n                    throw new Error(`Failed to load @supabase/node-fetch: ${error.message}. ` +\n                        `This is required for HTTP requests in Node.js environments without native fetch.`);\n                });\n            }\n            else {\n                _fetch = fetch;\n            }\n            return (...args) => _fetch(...args);\n        };\n        // Validate required parameters\n        if (!((_a = options === null || options === void 0 ? void 0 : options.params) === null || _a === void 0 ? void 0 : _a.apikey)) {\n            throw new Error('API key is required to connect to Realtime');\n        }\n        this.apiKey = options.params.apikey;\n        // Initialize endpoint URLs\n        this.endPoint = `${endPoint}/${_lib_constants__WEBPACK_IMPORTED_MODULE_1__.TRANSPORTS.websocket}`;\n        this.httpEndpoint = (0,_lib_transformers__WEBPACK_IMPORTED_MODULE_4__.httpEndpointURL)(endPoint);\n        this._initializeOptions(options);\n        this._setupReconnectionTimer();\n        this.fetch = this._resolveFetch(options === null || options === void 0 ? void 0 : options.fetch);\n    }\n    /**\n     * Connects the socket, unless already connected.\n     */\n    connect() {\n        // Skip if already connecting, disconnecting, or connected\n        if (this.isConnecting() ||\n            this.isDisconnecting() ||\n            (this.conn !== null && this.isConnected())) {\n            return;\n        }\n        this._setConnectionState('connecting');\n        this._setAuthSafely('connect');\n        // Establish WebSocket connection\n        if (this.transport) {\n            // Use custom transport if provided\n            this.conn = new this.transport(this.endpointURL());\n        }\n        else {\n            // Try to use native WebSocket\n            try {\n                this.conn = _lib_websocket_factory__WEBPACK_IMPORTED_MODULE_0__[\"default\"].createWebSocket(this.endpointURL());\n            }\n            catch (error) {\n                this._setConnectionState('disconnected');\n                const errorMessage = error.message;\n                // Provide helpful error message based on environment\n                if (errorMessage.includes('Node.js')) {\n                    throw new Error(`${errorMessage}\\n\\n` +\n                        'To use Realtime in Node.js, you need to provide a WebSocket implementation:\\n\\n' +\n                        'Option 1: Use Node.js 22+ which has native WebSocket support\\n' +\n                        'Option 2: Install and provide the \"ws\" package:\\n\\n' +\n                        '  npm install ws\\n\\n' +\n                        '  import ws from \"ws\"\\n' +\n                        '  const client = new RealtimeClient(url, {\\n' +\n                        '    ...options,\\n' +\n                        '    transport: ws\\n' +\n                        '  })');\n                }\n                throw new Error(`WebSocket not available: ${errorMessage}`);\n            }\n        }\n        this._setupConnectionHandlers();\n    }\n    /**\n     * Returns the URL of the websocket.\n     * @returns string The URL of the websocket.\n     */\n    endpointURL() {\n        return this._appendParams(this.endPoint, Object.assign({}, this.params, { vsn: _lib_constants__WEBPACK_IMPORTED_MODULE_1__.VSN }));\n    }\n    /**\n     * Disconnects the socket.\n     *\n     * @param code A numeric status code to send on disconnect.\n     * @param reason A custom reason for the disconnect.\n     */\n    disconnect(code, reason) {\n        if (this.isDisconnecting()) {\n            return;\n        }\n        this._setConnectionState('disconnecting', true);\n        if (this.conn) {\n            // Setup fallback timer to prevent hanging in disconnecting state\n            const fallbackTimer = setTimeout(() => {\n                this._setConnectionState('disconnected');\n            }, 100);\n            this.conn.onclose = () => {\n                clearTimeout(fallbackTimer);\n                this._setConnectionState('disconnected');\n            };\n            // Close the WebSocket connection\n            if (code) {\n                this.conn.close(code, reason !== null && reason !== void 0 ? reason : '');\n            }\n            else {\n                this.conn.close();\n            }\n            this._teardownConnection();\n        }\n        else {\n            this._setConnectionState('disconnected');\n        }\n    }\n    /**\n     * Returns all created channels\n     */\n    getChannels() {\n        return this.channels;\n    }\n    /**\n     * Unsubscribes and removes a single channel\n     * @param channel A RealtimeChannel instance\n     */\n    async removeChannel(channel) {\n        const status = await channel.unsubscribe();\n        if (this.channels.length === 0) {\n            this.disconnect();\n        }\n        return status;\n    }\n    /**\n     * Unsubscribes and removes all channels\n     */\n    async removeAllChannels() {\n        const values_1 = await Promise.all(this.channels.map((channel) => channel.unsubscribe()));\n        this.channels = [];\n        this.disconnect();\n        return values_1;\n    }\n    /**\n     * Logs the message.\n     *\n     * For customized logging, `this.logger` can be overridden.\n     */\n    log(kind, msg, data) {\n        this.logger(kind, msg, data);\n    }\n    /**\n     * Returns the current state of the socket.\n     */\n    connectionState() {\n        switch (this.conn && this.conn.readyState) {\n            case _lib_constants__WEBPACK_IMPORTED_MODULE_1__.SOCKET_STATES.connecting:\n                return _lib_constants__WEBPACK_IMPORTED_MODULE_1__.CONNECTION_STATE.Connecting;\n            case _lib_constants__WEBPACK_IMPORTED_MODULE_1__.SOCKET_STATES.open:\n                return _lib_constants__WEBPACK_IMPORTED_MODULE_1__.CONNECTION_STATE.Open;\n            case _lib_constants__WEBPACK_IMPORTED_MODULE_1__.SOCKET_STATES.closing:\n                return _lib_constants__WEBPACK_IMPORTED_MODULE_1__.CONNECTION_STATE.Closing;\n            default:\n                return _lib_constants__WEBPACK_IMPORTED_MODULE_1__.CONNECTION_STATE.Closed;\n        }\n    }\n    /**\n     * Returns `true` is the connection is open.\n     */\n    isConnected() {\n        return this.connectionState() === _lib_constants__WEBPACK_IMPORTED_MODULE_1__.CONNECTION_STATE.Open;\n    }\n    /**\n     * Returns `true` if the connection is currently connecting.\n     */\n    isConnecting() {\n        return this._connectionState === 'connecting';\n    }\n    /**\n     * Returns `true` if the connection is currently disconnecting.\n     */\n    isDisconnecting() {\n        return this._connectionState === 'disconnecting';\n    }\n    channel(topic, params = { config: {} }) {\n        const realtimeTopic = `realtime:${topic}`;\n        const exists = this.getChannels().find((c) => c.topic === realtimeTopic);\n        if (!exists) {\n            const chan = new _RealtimeChannel__WEBPACK_IMPORTED_MODULE_5__[\"default\"](`realtime:${topic}`, params, this);\n            this.channels.push(chan);\n            return chan;\n        }\n        else {\n            return exists;\n        }\n    }\n    /**\n     * Push out a message if the socket is connected.\n     *\n     * If the socket is not connected, the message gets enqueued within a local buffer, and sent out when a connection is next established.\n     */\n    push(data) {\n        const { topic, event, payload, ref } = data;\n        const callback = () => {\n            this.encode(data, (result) => {\n                var _a;\n                (_a = this.conn) === null || _a === void 0 ? void 0 : _a.send(result);\n            });\n        };\n        this.log('push', `${topic} ${event} (${ref})`, payload);\n        if (this.isConnected()) {\n            callback();\n        }\n        else {\n            this.sendBuffer.push(callback);\n        }\n    }\n    /**\n     * Sets the JWT access token used for channel subscription authorization and Realtime RLS.\n     *\n     * If param is null it will use the `accessToken` callback function or the token set on the client.\n     *\n     * On callback used, it will set the value of the token internal to the client.\n     *\n     * @param token A JWT string to override the token set on the client.\n     */\n    async setAuth(token = null) {\n        this._authPromise = this._performAuth(token);\n        try {\n            await this._authPromise;\n        }\n        finally {\n            this._authPromise = null;\n        }\n    }\n    /**\n     * Sends a heartbeat message if the socket is connected.\n     */\n    async sendHeartbeat() {\n        var _a;\n        if (!this.isConnected()) {\n            try {\n                this.heartbeatCallback('disconnected');\n            }\n            catch (e) {\n                this.log('error', 'error in heartbeat callback', e);\n            }\n            return;\n        }\n        // Handle heartbeat timeout and force reconnection if needed\n        if (this.pendingHeartbeatRef) {\n            this.pendingHeartbeatRef = null;\n            this.log('transport', 'heartbeat timeout. Attempting to re-establish connection');\n            try {\n                this.heartbeatCallback('timeout');\n            }\n            catch (e) {\n                this.log('error', 'error in heartbeat callback', e);\n            }\n            // Force reconnection after heartbeat timeout\n            this._wasManualDisconnect = false;\n            (_a = this.conn) === null || _a === void 0 ? void 0 : _a.close(_lib_constants__WEBPACK_IMPORTED_MODULE_1__.WS_CLOSE_NORMAL, 'heartbeat timeout');\n            setTimeout(() => {\n                var _a;\n                if (!this.isConnected()) {\n                    (_a = this.reconnectTimer) === null || _a === void 0 ? void 0 : _a.scheduleTimeout();\n                }\n            }, CONNECTION_TIMEOUTS.HEARTBEAT_TIMEOUT_FALLBACK);\n            return;\n        }\n        // Send heartbeat message to server\n        this.pendingHeartbeatRef = this._makeRef();\n        this.push({\n            topic: 'phoenix',\n            event: 'heartbeat',\n            payload: {},\n            ref: this.pendingHeartbeatRef,\n        });\n        try {\n            this.heartbeatCallback('sent');\n        }\n        catch (e) {\n            this.log('error', 'error in heartbeat callback', e);\n        }\n        this._setAuthSafely('heartbeat');\n    }\n    onHeartbeat(callback) {\n        this.heartbeatCallback = callback;\n    }\n    /**\n     * Flushes send buffer\n     */\n    flushSendBuffer() {\n        if (this.isConnected() && this.sendBuffer.length > 0) {\n            this.sendBuffer.forEach((callback) => callback());\n            this.sendBuffer = [];\n        }\n    }\n    /**\n     * Return the next message ref, accounting for overflows\n     *\n     * @internal\n     */\n    _makeRef() {\n        let newRef = this.ref + 1;\n        if (newRef === this.ref) {\n            this.ref = 0;\n        }\n        else {\n            this.ref = newRef;\n        }\n        return this.ref.toString();\n    }\n    /**\n     * Unsubscribe from channels with the specified topic.\n     *\n     * @internal\n     */\n    _leaveOpenTopic(topic) {\n        let dupChannel = this.channels.find((c) => c.topic === topic && (c._isJoined() || c._isJoining()));\n        if (dupChannel) {\n            this.log('transport', `leaving duplicate topic \"${topic}\"`);\n            dupChannel.unsubscribe();\n        }\n    }\n    /**\n     * Removes a subscription from the socket.\n     *\n     * @param channel An open subscription.\n     *\n     * @internal\n     */\n    _remove(channel) {\n        this.channels = this.channels.filter((c) => c.topic !== channel.topic);\n    }\n    /** @internal */\n    _onConnMessage(rawMessage) {\n        this.decode(rawMessage.data, (msg) => {\n            // Handle heartbeat responses\n            if (msg.topic === 'phoenix' && msg.event === 'phx_reply') {\n                try {\n                    this.heartbeatCallback(msg.payload.status === 'ok' ? 'ok' : 'error');\n                }\n                catch (e) {\n                    this.log('error', 'error in heartbeat callback', e);\n                }\n            }\n            // Handle pending heartbeat reference cleanup\n            if (msg.ref && msg.ref === this.pendingHeartbeatRef) {\n                this.pendingHeartbeatRef = null;\n            }\n            // Log incoming message\n            const { topic, event, payload, ref } = msg;\n            const refString = ref ? `(${ref})` : '';\n            const status = payload.status || '';\n            this.log('receive', `${status} ${topic} ${event} ${refString}`.trim(), payload);\n            // Route message to appropriate channels\n            this.channels\n                .filter((channel) => channel._isMember(topic))\n                .forEach((channel) => channel._trigger(event, payload, ref));\n            this._triggerStateCallbacks('message', msg);\n        });\n    }\n    /**\n     * Clear specific timer\n     * @internal\n     */\n    _clearTimer(timer) {\n        var _a;\n        if (timer === 'heartbeat' && this.heartbeatTimer) {\n            clearInterval(this.heartbeatTimer);\n            this.heartbeatTimer = undefined;\n        }\n        else if (timer === 'reconnect') {\n            (_a = this.reconnectTimer) === null || _a === void 0 ? void 0 : _a.reset();\n        }\n    }\n    /**\n     * Clear all timers\n     * @internal\n     */\n    _clearAllTimers() {\n        this._clearTimer('heartbeat');\n        this._clearTimer('reconnect');\n    }\n    /**\n     * Setup connection handlers for WebSocket events\n     * @internal\n     */\n    _setupConnectionHandlers() {\n        if (!this.conn)\n            return;\n        // Set binary type if supported (browsers and most WebSocket implementations)\n        if ('binaryType' in this.conn) {\n            ;\n            this.conn.binaryType = 'arraybuffer';\n        }\n        this.conn.onopen = () => this._onConnOpen();\n        this.conn.onerror = (error) => this._onConnError(error);\n        this.conn.onmessage = (event) => this._onConnMessage(event);\n        this.conn.onclose = (event) => this._onConnClose(event);\n    }\n    /**\n     * Teardown connection and cleanup resources\n     * @internal\n     */\n    _teardownConnection() {\n        if (this.conn) {\n            this.conn.onopen = null;\n            this.conn.onerror = null;\n            this.conn.onmessage = null;\n            this.conn.onclose = null;\n            this.conn = null;\n        }\n        this._clearAllTimers();\n        this.channels.forEach((channel) => channel.teardown());\n    }\n    /** @internal */\n    _onConnOpen() {\n        this._setConnectionState('connected');\n        this.log('transport', `connected to ${this.endpointURL()}`);\n        this.flushSendBuffer();\n        this._clearTimer('reconnect');\n        if (!this.worker) {\n            this._startHeartbeat();\n        }\n        else {\n            if (!this.workerRef) {\n                this._startWorkerHeartbeat();\n            }\n        }\n        this._triggerStateCallbacks('open');\n    }\n    /** @internal */\n    _startHeartbeat() {\n        this.heartbeatTimer && clearInterval(this.heartbeatTimer);\n        this.heartbeatTimer = setInterval(() => this.sendHeartbeat(), this.heartbeatIntervalMs);\n    }\n    /** @internal */\n    _startWorkerHeartbeat() {\n        if (this.workerUrl) {\n            this.log('worker', `starting worker for from ${this.workerUrl}`);\n        }\n        else {\n            this.log('worker', `starting default worker`);\n        }\n        const objectUrl = this._workerObjectUrl(this.workerUrl);\n        this.workerRef = new Worker(objectUrl);\n        this.workerRef.onerror = (error) => {\n            this.log('worker', 'worker error', error.message);\n            this.workerRef.terminate();\n        };\n        this.workerRef.onmessage = (event) => {\n            if (event.data.event === 'keepAlive') {\n                this.sendHeartbeat();\n            }\n        };\n        this.workerRef.postMessage({\n            event: 'start',\n            interval: this.heartbeatIntervalMs,\n        });\n    }\n    /** @internal */\n    _onConnClose(event) {\n        var _a;\n        this._setConnectionState('disconnected');\n        this.log('transport', 'close', event);\n        this._triggerChanError();\n        this._clearTimer('heartbeat');\n        // Only schedule reconnection if it wasn't a manual disconnect\n        if (!this._wasManualDisconnect) {\n            (_a = this.reconnectTimer) === null || _a === void 0 ? void 0 : _a.scheduleTimeout();\n        }\n        this._triggerStateCallbacks('close', event);\n    }\n    /** @internal */\n    _onConnError(error) {\n        this._setConnectionState('disconnected');\n        this.log('transport', `${error}`);\n        this._triggerChanError();\n        this._triggerStateCallbacks('error', error);\n    }\n    /** @internal */\n    _triggerChanError() {\n        this.channels.forEach((channel) => channel._trigger(_lib_constants__WEBPACK_IMPORTED_MODULE_1__.CHANNEL_EVENTS.error));\n    }\n    /** @internal */\n    _appendParams(url, params) {\n        if (Object.keys(params).length === 0) {\n            return url;\n        }\n        const prefix = url.match(/\\?/) ? '&' : '?';\n        const query = new URLSearchParams(params);\n        return `${url}${prefix}${query}`;\n    }\n    _workerObjectUrl(url) {\n        let result_url;\n        if (url) {\n            result_url = url;\n        }\n        else {\n            const blob = new Blob([WORKER_SCRIPT], { type: 'application/javascript' });\n            result_url = URL.createObjectURL(blob);\n        }\n        return result_url;\n    }\n    /**\n     * Set connection state with proper state management\n     * @internal\n     */\n    _setConnectionState(state, manual = false) {\n        this._connectionState = state;\n        if (state === 'connecting') {\n            this._wasManualDisconnect = false;\n        }\n        else if (state === 'disconnecting') {\n            this._wasManualDisconnect = manual;\n        }\n    }\n    /**\n     * Perform the actual auth operation\n     * @internal\n     */\n    async _performAuth(token = null) {\n        let tokenToSend;\n        if (token) {\n            tokenToSend = token;\n        }\n        else if (this.accessToken) {\n            // Always call the accessToken callback to get fresh token\n            tokenToSend = await this.accessToken();\n        }\n        else {\n            tokenToSend = this.accessTokenValue;\n        }\n        if (this.accessTokenValue != tokenToSend) {\n            this.accessTokenValue = tokenToSend;\n            this.channels.forEach((channel) => {\n                const payload = {\n                    access_token: tokenToSend,\n                    version: _lib_constants__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_VERSION,\n                };\n                tokenToSend && channel.updateJoinPayload(payload);\n                if (channel.joinedOnce && channel._isJoined()) {\n                    channel._push(_lib_constants__WEBPACK_IMPORTED_MODULE_1__.CHANNEL_EVENTS.access_token, {\n                        access_token: tokenToSend,\n                    });\n                }\n            });\n        }\n    }\n    /**\n     * Wait for any in-flight auth operations to complete\n     * @internal\n     */\n    async _waitForAuthIfNeeded() {\n        if (this._authPromise) {\n            await this._authPromise;\n        }\n    }\n    /**\n     * Safely call setAuth with standardized error handling\n     * @internal\n     */\n    _setAuthSafely(context = 'general') {\n        this.setAuth().catch((e) => {\n            this.log('error', `error setting auth in ${context}`, e);\n        });\n    }\n    /**\n     * Trigger state change callbacks with proper error handling\n     * @internal\n     */\n    _triggerStateCallbacks(event, data) {\n        try {\n            this.stateChangeCallbacks[event].forEach((callback) => {\n                try {\n                    callback(data);\n                }\n                catch (e) {\n                    this.log('error', `error in ${event} callback`, e);\n                }\n            });\n        }\n        catch (e) {\n            this.log('error', `error triggering ${event} callbacks`, e);\n        }\n    }\n    /**\n     * Setup reconnection timer with proper configuration\n     * @internal\n     */\n    _setupReconnectionTimer() {\n        this.reconnectTimer = new _lib_timer__WEBPACK_IMPORTED_MODULE_3__[\"default\"](async () => {\n            setTimeout(async () => {\n                await this._waitForAuthIfNeeded();\n                if (!this.isConnected()) {\n                    this.connect();\n                }\n            }, CONNECTION_TIMEOUTS.RECONNECT_DELAY);\n        }, this.reconnectAfterMs);\n    }\n    /**\n     * Initialize client options with defaults\n     * @internal\n     */\n    _initializeOptions(options) {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j;\n        // Set defaults\n        this.transport = (_a = options === null || options === void 0 ? void 0 : options.transport) !== null && _a !== void 0 ? _a : null;\n        this.timeout = (_b = options === null || options === void 0 ? void 0 : options.timeout) !== null && _b !== void 0 ? _b : _lib_constants__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_TIMEOUT;\n        this.heartbeatIntervalMs =\n            (_c = options === null || options === void 0 ? void 0 : options.heartbeatIntervalMs) !== null && _c !== void 0 ? _c : CONNECTION_TIMEOUTS.HEARTBEAT_INTERVAL;\n        this.worker = (_d = options === null || options === void 0 ? void 0 : options.worker) !== null && _d !== void 0 ? _d : false;\n        this.accessToken = (_e = options === null || options === void 0 ? void 0 : options.accessToken) !== null && _e !== void 0 ? _e : null;\n        this.heartbeatCallback = (_f = options === null || options === void 0 ? void 0 : options.heartbeatCallback) !== null && _f !== void 0 ? _f : noop;\n        // Handle special cases\n        if (options === null || options === void 0 ? void 0 : options.params)\n            this.params = options.params;\n        if (options === null || options === void 0 ? void 0 : options.logger)\n            this.logger = options.logger;\n        if ((options === null || options === void 0 ? void 0 : options.logLevel) || (options === null || options === void 0 ? void 0 : options.log_level)) {\n            this.logLevel = options.logLevel || options.log_level;\n            this.params = Object.assign(Object.assign({}, this.params), { log_level: this.logLevel });\n        }\n        // Set up functions with defaults\n        this.reconnectAfterMs =\n            (_g = options === null || options === void 0 ? void 0 : options.reconnectAfterMs) !== null && _g !== void 0 ? _g : ((tries) => {\n                return RECONNECT_INTERVALS[tries - 1] || DEFAULT_RECONNECT_FALLBACK;\n            });\n        this.encode =\n            (_h = options === null || options === void 0 ? void 0 : options.encode) !== null && _h !== void 0 ? _h : ((payload, callback) => {\n                return callback(JSON.stringify(payload));\n            });\n        this.decode = (_j = options === null || options === void 0 ? void 0 : options.decode) !== null && _j !== void 0 ? _j : this.serializer.decode.bind(this.serializer);\n        // Handle worker setup\n        if (this.worker) {\n            if (typeof window !== 'undefined' && !window.Worker) {\n                throw new Error('Web Worker is not supported');\n            }\n            this.workerUrl = options === null || options === void 0 ? void 0 : options.workerUrl;\n        }\n    }\n}\n//# sourceMappingURL=RealtimeClient.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcmVhbHRpbWUtanMvZGlzdC9tb2R1bGUvUmVhbHRpbWVDbGllbnQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUF1RDtBQUNnRztBQUM3RztBQUNWO0FBQ3FCO0FBQ0w7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLG9CQUFvQjtBQUMxRDtBQUNBLEdBQUcsRUFBRTtBQUNVO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtHQUErRyxlQUFlLEtBQUssSUFBSSxJQUFJO0FBQzNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsMkRBQWU7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsdURBQVU7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0Msc0xBQThCO0FBQ3BFLDZCQUE2QixnQkFBZ0I7QUFDN0M7QUFDQSw0RUFBNEUsY0FBYztBQUMxRjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsU0FBUyxHQUFHLHNEQUFVLFdBQVc7QUFDNUQsNEJBQTRCLGtFQUFlO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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cEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiRDpcXG5leHRcXG9yZ1xcbm9kZV9tb2R1bGVzXFxAc3VwYWJhc2VcXHJlYWx0aW1lLWpzXFxkaXN0XFxtb2R1bGVcXFJlYWx0aW1lQ2xpZW50LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBXZWJTb2NrZXRGYWN0b3J5IGZyb20gJy4vbGliL3dlYnNvY2tldC1mYWN0b3J5JztcbmltcG9ydCB7IENIQU5ORUxfRVZFTlRTLCBDT05ORUNUSU9OX1NUQVRFLCBERUZBVUxUX1ZFUlNJT04sIERFRkFVTFRfVElNRU9VVCwgU09DS0VUX1NUQVRFUywgVFJBTlNQT1JUUywgVlNOLCBXU19DTE9TRV9OT1JNQUwsIH0gZnJvbSAnLi9saWIvY29uc3RhbnRzJztcbmltcG9ydCBTZXJpYWxpemVyIGZyb20gJy4vbGliL3NlcmlhbGl6ZXInO1xuaW1wb3J0IFRpbWVyIGZyb20gJy4vbGliL3RpbWVyJztcbmltcG9ydCB7IGh0dHBFbmRwb2ludFVSTCB9IGZyb20gJy4vbGliL3RyYW5zZm9ybWVycyc7XG5pbXBvcnQgUmVhbHRpbWVDaGFubmVsIGZyb20gJy4vUmVhbHRpbWVDaGFubmVsJztcbmNvbnN0IG5vb3AgPSAoKSA9PiB7IH07XG4vLyBDb25uZWN0aW9uLXJlbGF0ZWQgY29uc3RhbnRzXG5jb25zdCBDT05ORUNUSU9OX1RJTUVPVVRTID0ge1xuICAgIEhFQVJUQkVBVF9JTlRFUlZBTDogMjUwMDAsXG4gICAgUkVDT05ORUNUX0RFTEFZOiAxMCxcbiAgICBIRUFSVEJFQVRfVElNRU9VVF9GQUxMQkFDSzogMTAwLFxufTtcbmNvbnN0IFJFQ09OTkVDVF9JTlRFUlZBTFMgPSBbMTAwMCwgMjAwMCwgNTAwMCwgMTAwMDBdO1xuY29uc3QgREVGQVVMVF9SRUNPTk5FQ1RfRkFMTEJBQ0sgPSAxMDAwMDtcbmNvbnN0IFdPUktFUl9TQ1JJUFQgPSBgXG4gIGFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIChlKSA9PiB7XG4gICAgaWYgKGUuZGF0YS5ldmVudCA9PT0gXCJzdGFydFwiKSB7XG4gICAgICBzZXRJbnRlcnZhbCgoKSA9PiBwb3N0TWVzc2FnZSh7IGV2ZW50OiBcImtlZXBBbGl2ZVwiIH0pLCBlLmRhdGEuaW50ZXJ2YWwpO1xuICAgIH1cbiAgfSk7YDtcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlYWx0aW1lQ2xpZW50IHtcbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyB0aGUgU29ja2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGVuZFBvaW50IFRoZSBzdHJpbmcgV2ViU29ja2V0IGVuZHBvaW50LCBpZSwgXCJ3czovL2V4YW1wbGUuY29tL3NvY2tldFwiLCBcIndzczovL2V4YW1wbGUuY29tXCIsIFwiL3NvY2tldFwiIChpbmhlcml0ZWQgaG9zdCAmIHByb3RvY29sKVxuICAgICAqIEBwYXJhbSBodHRwRW5kcG9pbnQgVGhlIHN0cmluZyBIVFRQIGVuZHBvaW50LCBpZSwgXCJodHRwczovL2V4YW1wbGUuY29tXCIsIFwiL1wiIChpbmhlcml0ZWQgaG9zdCAmIHByb3RvY29sKVxuICAgICAqIEBwYXJhbSBvcHRpb25zLnRyYW5zcG9ydCBUaGUgV2Vic29ja2V0IFRyYW5zcG9ydCwgZm9yIGV4YW1wbGUgV2ViU29ja2V0LiBUaGlzIGNhbiBiZSBhIGN1c3RvbSBpbXBsZW1lbnRhdGlvblxuICAgICAqIEBwYXJhbSBvcHRpb25zLnRpbWVvdXQgVGhlIGRlZmF1bHQgdGltZW91dCBpbiBtaWxsaXNlY29uZHMgdG8gdHJpZ2dlciBwdXNoIHRpbWVvdXRzLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLnBhcmFtcyBUaGUgb3B0aW9uYWwgcGFyYW1zIHRvIHBhc3Mgd2hlbiBjb25uZWN0aW5nLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmhlYWRlcnMgRGVwcmVjYXRlZDogaGVhZGVycyBjYW5ub3QgYmUgc2V0IG9uIHdlYnNvY2tldCBjb25uZWN0aW9ucyBhbmQgdGhpcyBvcHRpb24gd2lsbCBiZSByZW1vdmVkIGluIHRoZSBmdXR1cmUuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuaGVhcnRiZWF0SW50ZXJ2YWxNcyBUaGUgbWlsbGlzZWMgaW50ZXJ2YWwgdG8gc2VuZCBhIGhlYXJ0YmVhdCBtZXNzYWdlLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmhlYXJ0YmVhdENhbGxiYWNrIFRoZSBvcHRpb25hbCBmdW5jdGlvbiB0byBoYW5kbGUgaGVhcnRiZWF0IHN0YXR1cy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5sb2dnZXIgVGhlIG9wdGlvbmFsIGZ1bmN0aW9uIGZvciBzcGVjaWFsaXplZCBsb2dnaW5nLCBpZTogbG9nZ2VyOiAoa2luZCwgbXNnLCBkYXRhKSA9PiB7IGNvbnNvbGUubG9nKGAke2tpbmR9OiAke21zZ31gLCBkYXRhKSB9XG4gICAgICogQHBhcmFtIG9wdGlvbnMubG9nTGV2ZWwgU2V0cyB0aGUgbG9nIGxldmVsIGZvciBSZWFsdGltZVxuICAgICAqIEBwYXJhbSBvcHRpb25zLmVuY29kZSBUaGUgZnVuY3Rpb24gdG8gZW5jb2RlIG91dGdvaW5nIG1lc3NhZ2VzLiBEZWZhdWx0cyB0byBKU09OOiAocGF5bG9hZCwgY2FsbGJhY2spID0+IGNhbGxiYWNrKEpTT04uc3RyaW5naWZ5KHBheWxvYWQpKVxuICAgICAqIEBwYXJhbSBvcHRpb25zLmRlY29kZSBUaGUgZnVuY3Rpb24gdG8gZGVjb2RlIGluY29taW5nIG1lc3NhZ2VzLiBEZWZhdWx0cyB0byBTZXJpYWxpemVyJ3MgZGVjb2RlLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLnJlY29ubmVjdEFmdGVyTXMgaGUgb3B0aW9uYWwgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBtaWxsc2VjIHJlY29ubmVjdCBpbnRlcnZhbC4gRGVmYXVsdHMgdG8gc3RlcHBlZCBiYWNrb2ZmIG9mZi5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy53b3JrZXIgVXNlIFdlYiBXb3JrZXIgdG8gc2V0IGEgc2lkZSBmbG93LiBEZWZhdWx0cyB0byBmYWxzZS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy53b3JrZXJVcmwgVGhlIFVSTCBvZiB0aGUgd29ya2VyIHNjcmlwdC4gRGVmYXVsdHMgdG8gaHR0cHM6Ly9yZWFsdGltZS5zdXBhYmFzZS5jb20vd29ya2VyLmpzIHRoYXQgaW5jbHVkZXMgYSBoZWFydGJlYXQgZXZlbnQgY2FsbCB0byBrZWVwIHRoZSBjb25uZWN0aW9uIGFsaXZlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGVuZFBvaW50LCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdGhpcy5hY2Nlc3NUb2tlblZhbHVlID0gbnVsbDtcbiAgICAgICAgdGhpcy5hcGlLZXkgPSBudWxsO1xuICAgICAgICB0aGlzLmNoYW5uZWxzID0gbmV3IEFycmF5KCk7XG4gICAgICAgIHRoaXMuZW5kUG9pbnQgPSAnJztcbiAgICAgICAgdGhpcy5odHRwRW5kcG9pbnQgPSAnJztcbiAgICAgICAgLyoqIEBkZXByZWNhdGVkIGhlYWRlcnMgY2Fubm90IGJlIHNldCBvbiB3ZWJzb2NrZXQgY29ubmVjdGlvbnMgKi9cbiAgICAgICAgdGhpcy5oZWFkZXJzID0ge307XG4gICAgICAgIHRoaXMucGFyYW1zID0ge307XG4gICAgICAgIHRoaXMudGltZW91dCA9IERFRkFVTFRfVElNRU9VVDtcbiAgICAgICAgdGhpcy50cmFuc3BvcnQgPSBudWxsO1xuICAgICAgICB0aGlzLmhlYXJ0YmVhdEludGVydmFsTXMgPSBDT05ORUNUSU9OX1RJTUVPVVRTLkhFQVJUQkVBVF9JTlRFUlZBTDtcbiAgICAgICAgdGhpcy5oZWFydGJlYXRUaW1lciA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5wZW5kaW5nSGVhcnRiZWF0UmVmID0gbnVsbDtcbiAgICAgICAgdGhpcy5oZWFydGJlYXRDYWxsYmFjayA9IG5vb3A7XG4gICAgICAgIHRoaXMucmVmID0gMDtcbiAgICAgICAgdGhpcy5yZWNvbm5lY3RUaW1lciA9IG51bGw7XG4gICAgICAgIHRoaXMubG9nZ2VyID0gbm9vcDtcbiAgICAgICAgdGhpcy5jb25uID0gbnVsbDtcbiAgICAgICAgdGhpcy5zZW5kQnVmZmVyID0gW107XG4gICAgICAgIHRoaXMuc2VyaWFsaXplciA9IG5ldyBTZXJpYWxpemVyKCk7XG4gICAgICAgIHRoaXMuc3RhdGVDaGFuZ2VDYWxsYmFja3MgPSB7XG4gICAgICAgICAgICBvcGVuOiBbXSxcbiAgICAgICAgICAgIGNsb3NlOiBbXSxcbiAgICAgICAgICAgIGVycm9yOiBbXSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IFtdLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmFjY2Vzc1Rva2VuID0gbnVsbDtcbiAgICAgICAgdGhpcy5fY29ubmVjdGlvblN0YXRlID0gJ2Rpc2Nvbm5lY3RlZCc7XG4gICAgICAgIHRoaXMuX3dhc01hbnVhbERpc2Nvbm5lY3QgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fYXV0aFByb21pc2UgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogVXNlIGVpdGhlciBjdXN0b20gZmV0Y2gsIGlmIHByb3ZpZGVkLCBvciBkZWZhdWx0IGZldGNoIHRvIG1ha2UgSFRUUCByZXF1ZXN0c1xuICAgICAgICAgKlxuICAgICAgICAgKiBAaW50ZXJuYWxcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3Jlc29sdmVGZXRjaCA9IChjdXN0b21GZXRjaCkgPT4ge1xuICAgICAgICAgICAgbGV0IF9mZXRjaDtcbiAgICAgICAgICAgIGlmIChjdXN0b21GZXRjaCkge1xuICAgICAgICAgICAgICAgIF9mZXRjaCA9IGN1c3RvbUZldGNoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGZldGNoID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIC8vIE5vZGUuanMgZW52aXJvbm1lbnQgd2l0aG91dCBuYXRpdmUgZmV0Y2hcbiAgICAgICAgICAgICAgICBfZmV0Y2ggPSAoLi4uYXJncykgPT4gaW1wb3J0KCdAc3VwYWJhc2Uvbm9kZS1mZXRjaCcpXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKCh7IGRlZmF1bHQ6IGZldGNoIH0pID0+IGZldGNoKC4uLmFyZ3MpKVxuICAgICAgICAgICAgICAgICAgICAuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGxvYWQgQHN1cGFiYXNlL25vZGUtZmV0Y2g6ICR7ZXJyb3IubWVzc2FnZX0uIGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYFRoaXMgaXMgcmVxdWlyZWQgZm9yIEhUVFAgcmVxdWVzdHMgaW4gTm9kZS5qcyBlbnZpcm9ubWVudHMgd2l0aG91dCBuYXRpdmUgZmV0Y2guYCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBfZmV0Y2ggPSBmZXRjaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAoLi4uYXJncykgPT4gX2ZldGNoKC4uLmFyZ3MpO1xuICAgICAgICB9O1xuICAgICAgICAvLyBWYWxpZGF0ZSByZXF1aXJlZCBwYXJhbWV0ZXJzXG4gICAgICAgIGlmICghKChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5wYXJhbXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hcGlrZXkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FQSSBrZXkgaXMgcmVxdWlyZWQgdG8gY29ubmVjdCB0byBSZWFsdGltZScpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYXBpS2V5ID0gb3B0aW9ucy5wYXJhbXMuYXBpa2V5O1xuICAgICAgICAvLyBJbml0aWFsaXplIGVuZHBvaW50IFVSTHNcbiAgICAgICAgdGhpcy5lbmRQb2ludCA9IGAke2VuZFBvaW50fS8ke1RSQU5TUE9SVFMud2Vic29ja2V0fWA7XG4gICAgICAgIHRoaXMuaHR0cEVuZHBvaW50ID0gaHR0cEVuZHBvaW50VVJMKGVuZFBvaW50KTtcbiAgICAgICAgdGhpcy5faW5pdGlhbGl6ZU9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIHRoaXMuX3NldHVwUmVjb25uZWN0aW9uVGltZXIoKTtcbiAgICAgICAgdGhpcy5mZXRjaCA9IHRoaXMuX3Jlc29sdmVGZXRjaChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZmV0Y2gpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb25uZWN0cyB0aGUgc29ja2V0LCB1bmxlc3MgYWxyZWFkeSBjb25uZWN0ZWQuXG4gICAgICovXG4gICAgY29ubmVjdCgpIHtcbiAgICAgICAgLy8gU2tpcCBpZiBhbHJlYWR5IGNvbm5lY3RpbmcsIGRpc2Nvbm5lY3RpbmcsIG9yIGNvbm5lY3RlZFxuICAgICAgICBpZiAodGhpcy5pc0Nvbm5lY3RpbmcoKSB8fFxuICAgICAgICAgICAgdGhpcy5pc0Rpc2Nvbm5lY3RpbmcoKSB8fFxuICAgICAgICAgICAgKHRoaXMuY29ubiAhPT0gbnVsbCAmJiB0aGlzLmlzQ29ubmVjdGVkKCkpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc2V0Q29ubmVjdGlvblN0YXRlKCdjb25uZWN0aW5nJyk7XG4gICAgICAgIHRoaXMuX3NldEF1dGhTYWZlbHkoJ2Nvbm5lY3QnKTtcbiAgICAgICAgLy8gRXN0YWJsaXNoIFdlYlNvY2tldCBjb25uZWN0aW9uXG4gICAgICAgIGlmICh0aGlzLnRyYW5zcG9ydCkge1xuICAgICAgICAgICAgLy8gVXNlIGN1c3RvbSB0cmFuc3BvcnQgaWYgcHJvdmlkZWRcbiAgICAgICAgICAgIHRoaXMuY29ubiA9IG5ldyB0aGlzLnRyYW5zcG9ydCh0aGlzLmVuZHBvaW50VVJMKCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gVHJ5IHRvIHVzZSBuYXRpdmUgV2ViU29ja2V0XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29ubiA9IFdlYlNvY2tldEZhY3RvcnkuY3JlYXRlV2ViU29ja2V0KHRoaXMuZW5kcG9pbnRVUkwoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRDb25uZWN0aW9uU3RhdGUoJ2Rpc2Nvbm5lY3RlZCcpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGVycm9yLm1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgLy8gUHJvdmlkZSBoZWxwZnVsIGVycm9yIG1lc3NhZ2UgYmFzZWQgb24gZW52aXJvbm1lbnRcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3JNZXNzYWdlLmluY2x1ZGVzKCdOb2RlLmpzJykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2Vycm9yTWVzc2FnZX1cXG5cXG5gICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdUbyB1c2UgUmVhbHRpbWUgaW4gTm9kZS5qcywgeW91IG5lZWQgdG8gcHJvdmlkZSBhIFdlYlNvY2tldCBpbXBsZW1lbnRhdGlvbjpcXG5cXG4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdPcHRpb24gMTogVXNlIE5vZGUuanMgMjIrIHdoaWNoIGhhcyBuYXRpdmUgV2ViU29ja2V0IHN1cHBvcnRcXG4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdPcHRpb24gMjogSW5zdGFsbCBhbmQgcHJvdmlkZSB0aGUgXCJ3c1wiIHBhY2thZ2U6XFxuXFxuJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnICBucG0gaW5zdGFsbCB3c1xcblxcbicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJyAgaW1wb3J0IHdzIGZyb20gXCJ3c1wiXFxuJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnICBjb25zdCBjbGllbnQgPSBuZXcgUmVhbHRpbWVDbGllbnQodXJsLCB7XFxuJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnICAgIC4uLm9wdGlvbnMsXFxuJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnICAgIHRyYW5zcG9ydDogd3NcXG4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICcgIH0pJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgV2ViU29ja2V0IG5vdCBhdmFpbGFibGU6ICR7ZXJyb3JNZXNzYWdlfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NldHVwQ29ubmVjdGlvbkhhbmRsZXJzKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIFVSTCBvZiB0aGUgd2Vic29ja2V0LlxuICAgICAqIEByZXR1cm5zIHN0cmluZyBUaGUgVVJMIG9mIHRoZSB3ZWJzb2NrZXQuXG4gICAgICovXG4gICAgZW5kcG9pbnRVUkwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hcHBlbmRQYXJhbXModGhpcy5lbmRQb2ludCwgT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5wYXJhbXMsIHsgdnNuOiBWU04gfSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXNjb25uZWN0cyB0aGUgc29ja2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvZGUgQSBudW1lcmljIHN0YXR1cyBjb2RlIHRvIHNlbmQgb24gZGlzY29ubmVjdC5cbiAgICAgKiBAcGFyYW0gcmVhc29uIEEgY3VzdG9tIHJlYXNvbiBmb3IgdGhlIGRpc2Nvbm5lY3QuXG4gICAgICovXG4gICAgZGlzY29ubmVjdChjb2RlLCByZWFzb24pIHtcbiAgICAgICAgaWYgKHRoaXMuaXNEaXNjb25uZWN0aW5nKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zZXRDb25uZWN0aW9uU3RhdGUoJ2Rpc2Nvbm5lY3RpbmcnLCB0cnVlKTtcbiAgICAgICAgaWYgKHRoaXMuY29ubikge1xuICAgICAgICAgICAgLy8gU2V0dXAgZmFsbGJhY2sgdGltZXIgdG8gcHJldmVudCBoYW5naW5nIGluIGRpc2Nvbm5lY3Rpbmcgc3RhdGVcbiAgICAgICAgICAgIGNvbnN0IGZhbGxiYWNrVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRDb25uZWN0aW9uU3RhdGUoJ2Rpc2Nvbm5lY3RlZCcpO1xuICAgICAgICAgICAgfSwgMTAwKTtcbiAgICAgICAgICAgIHRoaXMuY29ubi5vbmNsb3NlID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChmYWxsYmFja1RpbWVyKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRDb25uZWN0aW9uU3RhdGUoJ2Rpc2Nvbm5lY3RlZCcpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIENsb3NlIHRoZSBXZWJTb2NrZXQgY29ubmVjdGlvblxuICAgICAgICAgICAgaWYgKGNvZGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbm4uY2xvc2UoY29kZSwgcmVhc29uICE9PSBudWxsICYmIHJlYXNvbiAhPT0gdm9pZCAwID8gcmVhc29uIDogJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb25uLmNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl90ZWFyZG93bkNvbm5lY3Rpb24oKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3NldENvbm5lY3Rpb25TdGF0ZSgnZGlzY29ubmVjdGVkJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbGwgY3JlYXRlZCBjaGFubmVsc1xuICAgICAqL1xuICAgIGdldENoYW5uZWxzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGFubmVscztcbiAgICB9XG4gICAgLyoqXG4gICAgICogVW5zdWJzY3JpYmVzIGFuZCByZW1vdmVzIGEgc2luZ2xlIGNoYW5uZWxcbiAgICAgKiBAcGFyYW0gY2hhbm5lbCBBIFJlYWx0aW1lQ2hhbm5lbCBpbnN0YW5jZVxuICAgICAqL1xuICAgIGFzeW5jIHJlbW92ZUNoYW5uZWwoY2hhbm5lbCkge1xuICAgICAgICBjb25zdCBzdGF0dXMgPSBhd2FpdCBjaGFubmVsLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIGlmICh0aGlzLmNoYW5uZWxzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5kaXNjb25uZWN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0YXR1cztcbiAgICB9XG4gICAgLyoqXG4gICAgICogVW5zdWJzY3JpYmVzIGFuZCByZW1vdmVzIGFsbCBjaGFubmVsc1xuICAgICAqL1xuICAgIGFzeW5jIHJlbW92ZUFsbENoYW5uZWxzKCkge1xuICAgICAgICBjb25zdCB2YWx1ZXNfMSA9IGF3YWl0IFByb21pc2UuYWxsKHRoaXMuY2hhbm5lbHMubWFwKChjaGFubmVsKSA9PiBjaGFubmVsLnVuc3Vic2NyaWJlKCkpKTtcbiAgICAgICAgdGhpcy5jaGFubmVscyA9IFtdO1xuICAgICAgICB0aGlzLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlc18xO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb2dzIHRoZSBtZXNzYWdlLlxuICAgICAqXG4gICAgICogRm9yIGN1c3RvbWl6ZWQgbG9nZ2luZywgYHRoaXMubG9nZ2VyYCBjYW4gYmUgb3ZlcnJpZGRlbi5cbiAgICAgKi9cbiAgICBsb2coa2luZCwgbXNnLCBkYXRhKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyKGtpbmQsIG1zZywgZGF0YSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIHNvY2tldC5cbiAgICAgKi9cbiAgICBjb25uZWN0aW9uU3RhdGUoKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5jb25uICYmIHRoaXMuY29ubi5yZWFkeVN0YXRlKSB7XG4gICAgICAgICAgICBjYXNlIFNPQ0tFVF9TVEFURVMuY29ubmVjdGluZzpcbiAgICAgICAgICAgICAgICByZXR1cm4gQ09OTkVDVElPTl9TVEFURS5Db25uZWN0aW5nO1xuICAgICAgICAgICAgY2FzZSBTT0NLRVRfU1RBVEVTLm9wZW46XG4gICAgICAgICAgICAgICAgcmV0dXJuIENPTk5FQ1RJT05fU1RBVEUuT3BlbjtcbiAgICAgICAgICAgIGNhc2UgU09DS0VUX1NUQVRFUy5jbG9zaW5nOlxuICAgICAgICAgICAgICAgIHJldHVybiBDT05ORUNUSU9OX1NUQVRFLkNsb3Npbmc7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBDT05ORUNUSU9OX1NUQVRFLkNsb3NlZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGB0cnVlYCBpcyB0aGUgY29ubmVjdGlvbiBpcyBvcGVuLlxuICAgICAqL1xuICAgIGlzQ29ubmVjdGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25uZWN0aW9uU3RhdGUoKSA9PT0gQ09OTkVDVElPTl9TVEFURS5PcGVuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgY29ubmVjdGlvbiBpcyBjdXJyZW50bHkgY29ubmVjdGluZy5cbiAgICAgKi9cbiAgICBpc0Nvbm5lY3RpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb25uZWN0aW9uU3RhdGUgPT09ICdjb25uZWN0aW5nJztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGNvbm5lY3Rpb24gaXMgY3VycmVudGx5IGRpc2Nvbm5lY3RpbmcuXG4gICAgICovXG4gICAgaXNEaXNjb25uZWN0aW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29ubmVjdGlvblN0YXRlID09PSAnZGlzY29ubmVjdGluZyc7XG4gICAgfVxuICAgIGNoYW5uZWwodG9waWMsIHBhcmFtcyA9IHsgY29uZmlnOiB7fSB9KSB7XG4gICAgICAgIGNvbnN0IHJlYWx0aW1lVG9waWMgPSBgcmVhbHRpbWU6JHt0b3BpY31gO1xuICAgICAgICBjb25zdCBleGlzdHMgPSB0aGlzLmdldENoYW5uZWxzKCkuZmluZCgoYykgPT4gYy50b3BpYyA9PT0gcmVhbHRpbWVUb3BpYyk7XG4gICAgICAgIGlmICghZXhpc3RzKSB7XG4gICAgICAgICAgICBjb25zdCBjaGFuID0gbmV3IFJlYWx0aW1lQ2hhbm5lbChgcmVhbHRpbWU6JHt0b3BpY31gLCBwYXJhbXMsIHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5jaGFubmVscy5wdXNoKGNoYW4pO1xuICAgICAgICAgICAgcmV0dXJuIGNoYW47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZXhpc3RzO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFB1c2ggb3V0IGEgbWVzc2FnZSBpZiB0aGUgc29ja2V0IGlzIGNvbm5lY3RlZC5cbiAgICAgKlxuICAgICAqIElmIHRoZSBzb2NrZXQgaXMgbm90IGNvbm5lY3RlZCwgdGhlIG1lc3NhZ2UgZ2V0cyBlbnF1ZXVlZCB3aXRoaW4gYSBsb2NhbCBidWZmZXIsIGFuZCBzZW50IG91dCB3aGVuIGEgY29ubmVjdGlvbiBpcyBuZXh0IGVzdGFibGlzaGVkLlxuICAgICAqL1xuICAgIHB1c2goZGF0YSkge1xuICAgICAgICBjb25zdCB7IHRvcGljLCBldmVudCwgcGF5bG9hZCwgcmVmIH0gPSBkYXRhO1xuICAgICAgICBjb25zdCBjYWxsYmFjayA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZW5jb2RlKGRhdGEsIChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgKF9hID0gdGhpcy5jb25uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2VuZChyZXN1bHQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMubG9nKCdwdXNoJywgYCR7dG9waWN9ICR7ZXZlbnR9ICgke3JlZn0pYCwgcGF5bG9hZCk7XG4gICAgICAgIGlmICh0aGlzLmlzQ29ubmVjdGVkKCkpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNlbmRCdWZmZXIucHVzaChjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgSldUIGFjY2VzcyB0b2tlbiB1c2VkIGZvciBjaGFubmVsIHN1YnNjcmlwdGlvbiBhdXRob3JpemF0aW9uIGFuZCBSZWFsdGltZSBSTFMuXG4gICAgICpcbiAgICAgKiBJZiBwYXJhbSBpcyBudWxsIGl0IHdpbGwgdXNlIHRoZSBgYWNjZXNzVG9rZW5gIGNhbGxiYWNrIGZ1bmN0aW9uIG9yIHRoZSB0b2tlbiBzZXQgb24gdGhlIGNsaWVudC5cbiAgICAgKlxuICAgICAqIE9uIGNhbGxiYWNrIHVzZWQsIGl0IHdpbGwgc2V0IHRoZSB2YWx1ZSBvZiB0aGUgdG9rZW4gaW50ZXJuYWwgdG8gdGhlIGNsaWVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0b2tlbiBBIEpXVCBzdHJpbmcgdG8gb3ZlcnJpZGUgdGhlIHRva2VuIHNldCBvbiB0aGUgY2xpZW50LlxuICAgICAqL1xuICAgIGFzeW5jIHNldEF1dGgodG9rZW4gPSBudWxsKSB7XG4gICAgICAgIHRoaXMuX2F1dGhQcm9taXNlID0gdGhpcy5fcGVyZm9ybUF1dGgodG9rZW4pO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fYXV0aFByb21pc2U7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0aGlzLl9hdXRoUHJvbWlzZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZHMgYSBoZWFydGJlYXQgbWVzc2FnZSBpZiB0aGUgc29ja2V0IGlzIGNvbm5lY3RlZC5cbiAgICAgKi9cbiAgICBhc3luYyBzZW5kSGVhcnRiZWF0KCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICghdGhpcy5pc0Nvbm5lY3RlZCgpKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMuaGVhcnRiZWF0Q2FsbGJhY2soJ2Rpc2Nvbm5lY3RlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZygnZXJyb3InLCAnZXJyb3IgaW4gaGVhcnRiZWF0IGNhbGxiYWNrJywgZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gSGFuZGxlIGhlYXJ0YmVhdCB0aW1lb3V0IGFuZCBmb3JjZSByZWNvbm5lY3Rpb24gaWYgbmVlZGVkXG4gICAgICAgIGlmICh0aGlzLnBlbmRpbmdIZWFydGJlYXRSZWYpIHtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ0hlYXJ0YmVhdFJlZiA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmxvZygndHJhbnNwb3J0JywgJ2hlYXJ0YmVhdCB0aW1lb3V0LiBBdHRlbXB0aW5nIHRvIHJlLWVzdGFibGlzaCBjb25uZWN0aW9uJyk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMuaGVhcnRiZWF0Q2FsbGJhY2soJ3RpbWVvdXQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2coJ2Vycm9yJywgJ2Vycm9yIGluIGhlYXJ0YmVhdCBjYWxsYmFjaycsIGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRm9yY2UgcmVjb25uZWN0aW9uIGFmdGVyIGhlYXJ0YmVhdCB0aW1lb3V0XG4gICAgICAgICAgICB0aGlzLl93YXNNYW51YWxEaXNjb25uZWN0ID0gZmFsc2U7XG4gICAgICAgICAgICAoX2EgPSB0aGlzLmNvbm4pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jbG9zZShXU19DTE9TRV9OT1JNQUwsICdoZWFydGJlYXQgdGltZW91dCcpO1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5pc0Nvbm5lY3RlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIChfYSA9IHRoaXMucmVjb25uZWN0VGltZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zY2hlZHVsZVRpbWVvdXQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBDT05ORUNUSU9OX1RJTUVPVVRTLkhFQVJUQkVBVF9USU1FT1VUX0ZBTExCQUNLKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBTZW5kIGhlYXJ0YmVhdCBtZXNzYWdlIHRvIHNlcnZlclxuICAgICAgICB0aGlzLnBlbmRpbmdIZWFydGJlYXRSZWYgPSB0aGlzLl9tYWtlUmVmKCk7XG4gICAgICAgIHRoaXMucHVzaCh7XG4gICAgICAgICAgICB0b3BpYzogJ3Bob2VuaXgnLFxuICAgICAgICAgICAgZXZlbnQ6ICdoZWFydGJlYXQnLFxuICAgICAgICAgICAgcGF5bG9hZDoge30sXG4gICAgICAgICAgICByZWY6IHRoaXMucGVuZGluZ0hlYXJ0YmVhdFJlZixcbiAgICAgICAgfSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLmhlYXJ0YmVhdENhbGxiYWNrKCdzZW50Jyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRoaXMubG9nKCdlcnJvcicsICdlcnJvciBpbiBoZWFydGJlYXQgY2FsbGJhY2snLCBlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zZXRBdXRoU2FmZWx5KCdoZWFydGJlYXQnKTtcbiAgICB9XG4gICAgb25IZWFydGJlYXQoY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5oZWFydGJlYXRDYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGbHVzaGVzIHNlbmQgYnVmZmVyXG4gICAgICovXG4gICAgZmx1c2hTZW5kQnVmZmVyKCkge1xuICAgICAgICBpZiAodGhpcy5pc0Nvbm5lY3RlZCgpICYmIHRoaXMuc2VuZEJ1ZmZlci5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLnNlbmRCdWZmZXIuZm9yRWFjaCgoY2FsbGJhY2spID0+IGNhbGxiYWNrKCkpO1xuICAgICAgICAgICAgdGhpcy5zZW5kQnVmZmVyID0gW107XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBuZXh0IG1lc3NhZ2UgcmVmLCBhY2NvdW50aW5nIGZvciBvdmVyZmxvd3NcbiAgICAgKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIF9tYWtlUmVmKCkge1xuICAgICAgICBsZXQgbmV3UmVmID0gdGhpcy5yZWYgKyAxO1xuICAgICAgICBpZiAobmV3UmVmID09PSB0aGlzLnJlZikge1xuICAgICAgICAgICAgdGhpcy5yZWYgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yZWYgPSBuZXdSZWY7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucmVmLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVuc3Vic2NyaWJlIGZyb20gY2hhbm5lbHMgd2l0aCB0aGUgc3BlY2lmaWVkIHRvcGljLlxuICAgICAqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgX2xlYXZlT3BlblRvcGljKHRvcGljKSB7XG4gICAgICAgIGxldCBkdXBDaGFubmVsID0gdGhpcy5jaGFubmVscy5maW5kKChjKSA9PiBjLnRvcGljID09PSB0b3BpYyAmJiAoYy5faXNKb2luZWQoKSB8fCBjLl9pc0pvaW5pbmcoKSkpO1xuICAgICAgICBpZiAoZHVwQ2hhbm5lbCkge1xuICAgICAgICAgICAgdGhpcy5sb2coJ3RyYW5zcG9ydCcsIGBsZWF2aW5nIGR1cGxpY2F0ZSB0b3BpYyBcIiR7dG9waWN9XCJgKTtcbiAgICAgICAgICAgIGR1cENoYW5uZWwudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgc3Vic2NyaXB0aW9uIGZyb20gdGhlIHNvY2tldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjaGFubmVsIEFuIG9wZW4gc3Vic2NyaXB0aW9uLlxuICAgICAqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgX3JlbW92ZShjaGFubmVsKSB7XG4gICAgICAgIHRoaXMuY2hhbm5lbHMgPSB0aGlzLmNoYW5uZWxzLmZpbHRlcigoYykgPT4gYy50b3BpYyAhPT0gY2hhbm5lbC50b3BpYyk7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfb25Db25uTWVzc2FnZShyYXdNZXNzYWdlKSB7XG4gICAgICAgIHRoaXMuZGVjb2RlKHJhd01lc3NhZ2UuZGF0YSwgKG1zZykgPT4ge1xuICAgICAgICAgICAgLy8gSGFuZGxlIGhlYXJ0YmVhdCByZXNwb25zZXNcbiAgICAgICAgICAgIGlmIChtc2cudG9waWMgPT09ICdwaG9lbml4JyAmJiBtc2cuZXZlbnQgPT09ICdwaHhfcmVwbHknKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oZWFydGJlYXRDYWxsYmFjayhtc2cucGF5bG9hZC5zdGF0dXMgPT09ICdvaycgPyAnb2snIDogJ2Vycm9yJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nKCdlcnJvcicsICdlcnJvciBpbiBoZWFydGJlYXQgY2FsbGJhY2snLCBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBIYW5kbGUgcGVuZGluZyBoZWFydGJlYXQgcmVmZXJlbmNlIGNsZWFudXBcbiAgICAgICAgICAgIGlmIChtc2cucmVmICYmIG1zZy5yZWYgPT09IHRoaXMucGVuZGluZ0hlYXJ0YmVhdFJlZikge1xuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ0hlYXJ0YmVhdFJlZiA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBMb2cgaW5jb21pbmcgbWVzc2FnZVxuICAgICAgICAgICAgY29uc3QgeyB0b3BpYywgZXZlbnQsIHBheWxvYWQsIHJlZiB9ID0gbXNnO1xuICAgICAgICAgICAgY29uc3QgcmVmU3RyaW5nID0gcmVmID8gYCgke3JlZn0pYCA6ICcnO1xuICAgICAgICAgICAgY29uc3Qgc3RhdHVzID0gcGF5bG9hZC5zdGF0dXMgfHwgJyc7XG4gICAgICAgICAgICB0aGlzLmxvZygncmVjZWl2ZScsIGAke3N0YXR1c30gJHt0b3BpY30gJHtldmVudH0gJHtyZWZTdHJpbmd9YC50cmltKCksIHBheWxvYWQpO1xuICAgICAgICAgICAgLy8gUm91dGUgbWVzc2FnZSB0byBhcHByb3ByaWF0ZSBjaGFubmVsc1xuICAgICAgICAgICAgdGhpcy5jaGFubmVsc1xuICAgICAgICAgICAgICAgIC5maWx0ZXIoKGNoYW5uZWwpID0+IGNoYW5uZWwuX2lzTWVtYmVyKHRvcGljKSlcbiAgICAgICAgICAgICAgICAuZm9yRWFjaCgoY2hhbm5lbCkgPT4gY2hhbm5lbC5fdHJpZ2dlcihldmVudCwgcGF5bG9hZCwgcmVmKSk7XG4gICAgICAgICAgICB0aGlzLl90cmlnZ2VyU3RhdGVDYWxsYmFja3MoJ21lc3NhZ2UnLCBtc2cpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xlYXIgc3BlY2lmaWMgdGltZXJcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBfY2xlYXJUaW1lcih0aW1lcikge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICh0aW1lciA9PT0gJ2hlYXJ0YmVhdCcgJiYgdGhpcy5oZWFydGJlYXRUaW1lcikge1xuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmhlYXJ0YmVhdFRpbWVyKTtcbiAgICAgICAgICAgIHRoaXMuaGVhcnRiZWF0VGltZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGltZXIgPT09ICdyZWNvbm5lY3QnKSB7XG4gICAgICAgICAgICAoX2EgPSB0aGlzLnJlY29ubmVjdFRpbWVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVzZXQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbGVhciBhbGwgdGltZXJzXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgX2NsZWFyQWxsVGltZXJzKCkge1xuICAgICAgICB0aGlzLl9jbGVhclRpbWVyKCdoZWFydGJlYXQnKTtcbiAgICAgICAgdGhpcy5fY2xlYXJUaW1lcigncmVjb25uZWN0Jyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHVwIGNvbm5lY3Rpb24gaGFuZGxlcnMgZm9yIFdlYlNvY2tldCBldmVudHNcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBfc2V0dXBDb25uZWN0aW9uSGFuZGxlcnMoKSB7XG4gICAgICAgIGlmICghdGhpcy5jb25uKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAvLyBTZXQgYmluYXJ5IHR5cGUgaWYgc3VwcG9ydGVkIChicm93c2VycyBhbmQgbW9zdCBXZWJTb2NrZXQgaW1wbGVtZW50YXRpb25zKVxuICAgICAgICBpZiAoJ2JpbmFyeVR5cGUnIGluIHRoaXMuY29ubikge1xuICAgICAgICAgICAgO1xuICAgICAgICAgICAgdGhpcy5jb25uLmJpbmFyeVR5cGUgPSAnYXJyYXlidWZmZXInO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29ubi5vbm9wZW4gPSAoKSA9PiB0aGlzLl9vbkNvbm5PcGVuKCk7XG4gICAgICAgIHRoaXMuY29ubi5vbmVycm9yID0gKGVycm9yKSA9PiB0aGlzLl9vbkNvbm5FcnJvcihlcnJvcik7XG4gICAgICAgIHRoaXMuY29ubi5vbm1lc3NhZ2UgPSAoZXZlbnQpID0+IHRoaXMuX29uQ29ubk1lc3NhZ2UoZXZlbnQpO1xuICAgICAgICB0aGlzLmNvbm4ub25jbG9zZSA9IChldmVudCkgPT4gdGhpcy5fb25Db25uQ2xvc2UoZXZlbnQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUZWFyZG93biBjb25uZWN0aW9uIGFuZCBjbGVhbnVwIHJlc291cmNlc1xuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIF90ZWFyZG93bkNvbm5lY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbm4pIHtcbiAgICAgICAgICAgIHRoaXMuY29ubi5vbm9wZW4gPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5jb25uLm9uZXJyb3IgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5jb25uLm9ubWVzc2FnZSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmNvbm4ub25jbG9zZSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmNvbm4gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NsZWFyQWxsVGltZXJzKCk7XG4gICAgICAgIHRoaXMuY2hhbm5lbHMuZm9yRWFjaCgoY2hhbm5lbCkgPT4gY2hhbm5lbC50ZWFyZG93bigpKTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9vbkNvbm5PcGVuKCkge1xuICAgICAgICB0aGlzLl9zZXRDb25uZWN0aW9uU3RhdGUoJ2Nvbm5lY3RlZCcpO1xuICAgICAgICB0aGlzLmxvZygndHJhbnNwb3J0JywgYGNvbm5lY3RlZCB0byAke3RoaXMuZW5kcG9pbnRVUkwoKX1gKTtcbiAgICAgICAgdGhpcy5mbHVzaFNlbmRCdWZmZXIoKTtcbiAgICAgICAgdGhpcy5fY2xlYXJUaW1lcigncmVjb25uZWN0Jyk7XG4gICAgICAgIGlmICghdGhpcy53b3JrZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0SGVhcnRiZWF0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMud29ya2VyUmVmKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhcnRXb3JrZXJIZWFydGJlYXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl90cmlnZ2VyU3RhdGVDYWxsYmFja3MoJ29wZW4nKTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9zdGFydEhlYXJ0YmVhdCgpIHtcbiAgICAgICAgdGhpcy5oZWFydGJlYXRUaW1lciAmJiBjbGVhckludGVydmFsKHRoaXMuaGVhcnRiZWF0VGltZXIpO1xuICAgICAgICB0aGlzLmhlYXJ0YmVhdFRpbWVyID0gc2V0SW50ZXJ2YWwoKCkgPT4gdGhpcy5zZW5kSGVhcnRiZWF0KCksIHRoaXMuaGVhcnRiZWF0SW50ZXJ2YWxNcyk7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfc3RhcnRXb3JrZXJIZWFydGJlYXQoKSB7XG4gICAgICAgIGlmICh0aGlzLndvcmtlclVybCkge1xuICAgICAgICAgICAgdGhpcy5sb2coJ3dvcmtlcicsIGBzdGFydGluZyB3b3JrZXIgZm9yIGZyb20gJHt0aGlzLndvcmtlclVybH1gKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubG9nKCd3b3JrZXInLCBgc3RhcnRpbmcgZGVmYXVsdCB3b3JrZXJgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvYmplY3RVcmwgPSB0aGlzLl93b3JrZXJPYmplY3RVcmwodGhpcy53b3JrZXJVcmwpO1xuICAgICAgICB0aGlzLndvcmtlclJlZiA9IG5ldyBXb3JrZXIob2JqZWN0VXJsKTtcbiAgICAgICAgdGhpcy53b3JrZXJSZWYub25lcnJvciA9IChlcnJvcikgPT4ge1xuICAgICAgICAgICAgdGhpcy5sb2coJ3dvcmtlcicsICd3b3JrZXIgZXJyb3InLCBlcnJvci5tZXNzYWdlKTtcbiAgICAgICAgICAgIHRoaXMud29ya2VyUmVmLnRlcm1pbmF0ZSgpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLndvcmtlclJlZi5vbm1lc3NhZ2UgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmIChldmVudC5kYXRhLmV2ZW50ID09PSAna2VlcEFsaXZlJykge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VuZEhlYXJ0YmVhdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLndvcmtlclJlZi5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICBldmVudDogJ3N0YXJ0JyxcbiAgICAgICAgICAgIGludGVydmFsOiB0aGlzLmhlYXJ0YmVhdEludGVydmFsTXMsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX29uQ29ubkNsb3NlKGV2ZW50KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdGhpcy5fc2V0Q29ubmVjdGlvblN0YXRlKCdkaXNjb25uZWN0ZWQnKTtcbiAgICAgICAgdGhpcy5sb2coJ3RyYW5zcG9ydCcsICdjbG9zZScsIGV2ZW50KTtcbiAgICAgICAgdGhpcy5fdHJpZ2dlckNoYW5FcnJvcigpO1xuICAgICAgICB0aGlzLl9jbGVhclRpbWVyKCdoZWFydGJlYXQnKTtcbiAgICAgICAgLy8gT25seSBzY2hlZHVsZSByZWNvbm5lY3Rpb24gaWYgaXQgd2Fzbid0IGEgbWFudWFsIGRpc2Nvbm5lY3RcbiAgICAgICAgaWYgKCF0aGlzLl93YXNNYW51YWxEaXNjb25uZWN0KSB7XG4gICAgICAgICAgICAoX2EgPSB0aGlzLnJlY29ubmVjdFRpbWVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2NoZWR1bGVUaW1lb3V0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdHJpZ2dlclN0YXRlQ2FsbGJhY2tzKCdjbG9zZScsIGV2ZW50KTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9vbkNvbm5FcnJvcihlcnJvcikge1xuICAgICAgICB0aGlzLl9zZXRDb25uZWN0aW9uU3RhdGUoJ2Rpc2Nvbm5lY3RlZCcpO1xuICAgICAgICB0aGlzLmxvZygndHJhbnNwb3J0JywgYCR7ZXJyb3J9YCk7XG4gICAgICAgIHRoaXMuX3RyaWdnZXJDaGFuRXJyb3IoKTtcbiAgICAgICAgdGhpcy5fdHJpZ2dlclN0YXRlQ2FsbGJhY2tzKCdlcnJvcicsIGVycm9yKTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF90cmlnZ2VyQ2hhbkVycm9yKCkge1xuICAgICAgICB0aGlzLmNoYW5uZWxzLmZvckVhY2goKGNoYW5uZWwpID0+IGNoYW5uZWwuX3RyaWdnZXIoQ0hBTk5FTF9FVkVOVFMuZXJyb3IpKTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9hcHBlbmRQYXJhbXModXJsLCBwYXJhbXMpIHtcbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKHBhcmFtcykubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdXJsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByZWZpeCA9IHVybC5tYXRjaCgvXFw/LykgPyAnJicgOiAnPyc7XG4gICAgICAgIGNvbnN0IHF1ZXJ5ID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhwYXJhbXMpO1xuICAgICAgICByZXR1cm4gYCR7dXJsfSR7cHJlZml4fSR7cXVlcnl9YDtcbiAgICB9XG4gICAgX3dvcmtlck9iamVjdFVybCh1cmwpIHtcbiAgICAgICAgbGV0IHJlc3VsdF91cmw7XG4gICAgICAgIGlmICh1cmwpIHtcbiAgICAgICAgICAgIHJlc3VsdF91cmwgPSB1cmw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBibG9iID0gbmV3IEJsb2IoW1dPUktFUl9TQ1JJUFRdLCB7IHR5cGU6ICdhcHBsaWNhdGlvbi9qYXZhc2NyaXB0JyB9KTtcbiAgICAgICAgICAgIHJlc3VsdF91cmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRfdXJsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgY29ubmVjdGlvbiBzdGF0ZSB3aXRoIHByb3BlciBzdGF0ZSBtYW5hZ2VtZW50XG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgX3NldENvbm5lY3Rpb25TdGF0ZShzdGF0ZSwgbWFudWFsID0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5fY29ubmVjdGlvblN0YXRlID0gc3RhdGU7XG4gICAgICAgIGlmIChzdGF0ZSA9PT0gJ2Nvbm5lY3RpbmcnKSB7XG4gICAgICAgICAgICB0aGlzLl93YXNNYW51YWxEaXNjb25uZWN0ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3RhdGUgPT09ICdkaXNjb25uZWN0aW5nJykge1xuICAgICAgICAgICAgdGhpcy5fd2FzTWFudWFsRGlzY29ubmVjdCA9IG1hbnVhbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtIHRoZSBhY3R1YWwgYXV0aCBvcGVyYXRpb25cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBhc3luYyBfcGVyZm9ybUF1dGgodG9rZW4gPSBudWxsKSB7XG4gICAgICAgIGxldCB0b2tlblRvU2VuZDtcbiAgICAgICAgaWYgKHRva2VuKSB7XG4gICAgICAgICAgICB0b2tlblRvU2VuZCA9IHRva2VuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuYWNjZXNzVG9rZW4pIHtcbiAgICAgICAgICAgIC8vIEFsd2F5cyBjYWxsIHRoZSBhY2Nlc3NUb2tlbiBjYWxsYmFjayB0byBnZXQgZnJlc2ggdG9rZW5cbiAgICAgICAgICAgIHRva2VuVG9TZW5kID0gYXdhaXQgdGhpcy5hY2Nlc3NUb2tlbigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdG9rZW5Ub1NlbmQgPSB0aGlzLmFjY2Vzc1Rva2VuVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYWNjZXNzVG9rZW5WYWx1ZSAhPSB0b2tlblRvU2VuZCkge1xuICAgICAgICAgICAgdGhpcy5hY2Nlc3NUb2tlblZhbHVlID0gdG9rZW5Ub1NlbmQ7XG4gICAgICAgICAgICB0aGlzLmNoYW5uZWxzLmZvckVhY2goKGNoYW5uZWwpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXlsb2FkID0ge1xuICAgICAgICAgICAgICAgICAgICBhY2Nlc3NfdG9rZW46IHRva2VuVG9TZW5kLFxuICAgICAgICAgICAgICAgICAgICB2ZXJzaW9uOiBERUZBVUxUX1ZFUlNJT04sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0b2tlblRvU2VuZCAmJiBjaGFubmVsLnVwZGF0ZUpvaW5QYXlsb2FkKHBheWxvYWQpO1xuICAgICAgICAgICAgICAgIGlmIChjaGFubmVsLmpvaW5lZE9uY2UgJiYgY2hhbm5lbC5faXNKb2luZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICBjaGFubmVsLl9wdXNoKENIQU5ORUxfRVZFTlRTLmFjY2Vzc190b2tlbiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWNjZXNzX3Rva2VuOiB0b2tlblRvU2VuZCxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogV2FpdCBmb3IgYW55IGluLWZsaWdodCBhdXRoIG9wZXJhdGlvbnMgdG8gY29tcGxldGVcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBhc3luYyBfd2FpdEZvckF1dGhJZk5lZWRlZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2F1dGhQcm9taXNlKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9hdXRoUHJvbWlzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTYWZlbHkgY2FsbCBzZXRBdXRoIHdpdGggc3RhbmRhcmRpemVkIGVycm9yIGhhbmRsaW5nXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgX3NldEF1dGhTYWZlbHkoY29udGV4dCA9ICdnZW5lcmFsJykge1xuICAgICAgICB0aGlzLnNldEF1dGgoKS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5sb2coJ2Vycm9yJywgYGVycm9yIHNldHRpbmcgYXV0aCBpbiAke2NvbnRleHR9YCwgZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyIHN0YXRlIGNoYW5nZSBjYWxsYmFja3Mgd2l0aCBwcm9wZXIgZXJyb3IgaGFuZGxpbmdcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBfdHJpZ2dlclN0YXRlQ2FsbGJhY2tzKGV2ZW50LCBkYXRhKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlQ2hhbmdlQ2FsbGJhY2tzW2V2ZW50XS5mb3JFYWNoKChjYWxsYmFjaykgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZygnZXJyb3InLCBgZXJyb3IgaW4gJHtldmVudH0gY2FsbGJhY2tgLCBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhpcy5sb2coJ2Vycm9yJywgYGVycm9yIHRyaWdnZXJpbmcgJHtldmVudH0gY2FsbGJhY2tzYCwgZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0dXAgcmVjb25uZWN0aW9uIHRpbWVyIHdpdGggcHJvcGVyIGNvbmZpZ3VyYXRpb25cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBfc2V0dXBSZWNvbm5lY3Rpb25UaW1lcigpIHtcbiAgICAgICAgdGhpcy5yZWNvbm5lY3RUaW1lciA9IG5ldyBUaW1lcihhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl93YWl0Rm9yQXV0aElmTmVlZGVkKCk7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmlzQ29ubmVjdGVkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgQ09OTkVDVElPTl9USU1FT1VUUy5SRUNPTk5FQ1RfREVMQVkpO1xuICAgICAgICB9LCB0aGlzLnJlY29ubmVjdEFmdGVyTXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplIGNsaWVudCBvcHRpb25zIHdpdGggZGVmYXVsdHNcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBfaW5pdGlhbGl6ZU9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oLCBfajtcbiAgICAgICAgLy8gU2V0IGRlZmF1bHRzXG4gICAgICAgIHRoaXMudHJhbnNwb3J0ID0gKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnRyYW5zcG9ydCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbnVsbDtcbiAgICAgICAgdGhpcy50aW1lb3V0ID0gKF9iID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnRpbWVvdXQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IERFRkFVTFRfVElNRU9VVDtcbiAgICAgICAgdGhpcy5oZWFydGJlYXRJbnRlcnZhbE1zID1cbiAgICAgICAgICAgIChfYyA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5oZWFydGJlYXRJbnRlcnZhbE1zKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBDT05ORUNUSU9OX1RJTUVPVVRTLkhFQVJUQkVBVF9JTlRFUlZBTDtcbiAgICAgICAgdGhpcy53b3JrZXIgPSAoX2QgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMud29ya2VyKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiBmYWxzZTtcbiAgICAgICAgdGhpcy5hY2Nlc3NUb2tlbiA9IChfZSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5hY2Nlc3NUb2tlbikgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogbnVsbDtcbiAgICAgICAgdGhpcy5oZWFydGJlYXRDYWxsYmFjayA9IChfZiA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5oZWFydGJlYXRDYWxsYmFjaykgIT09IG51bGwgJiYgX2YgIT09IHZvaWQgMCA/IF9mIDogbm9vcDtcbiAgICAgICAgLy8gSGFuZGxlIHNwZWNpYWwgY2FzZXNcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5wYXJhbXMpXG4gICAgICAgICAgICB0aGlzLnBhcmFtcyA9IG9wdGlvbnMucGFyYW1zO1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmxvZ2dlcilcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyID0gb3B0aW9ucy5sb2dnZXI7XG4gICAgICAgIGlmICgob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmxvZ0xldmVsKSB8fCAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmxvZ19sZXZlbCkpIHtcbiAgICAgICAgICAgIHRoaXMubG9nTGV2ZWwgPSBvcHRpb25zLmxvZ0xldmVsIHx8IG9wdGlvbnMubG9nX2xldmVsO1xuICAgICAgICAgICAgdGhpcy5wYXJhbXMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMucGFyYW1zKSwgeyBsb2dfbGV2ZWw6IHRoaXMubG9nTGV2ZWwgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2V0IHVwIGZ1bmN0aW9ucyB3aXRoIGRlZmF1bHRzXG4gICAgICAgIHRoaXMucmVjb25uZWN0QWZ0ZXJNcyA9XG4gICAgICAgICAgICAoX2cgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucmVjb25uZWN0QWZ0ZXJNcykgIT09IG51bGwgJiYgX2cgIT09IHZvaWQgMCA/IF9nIDogKCh0cmllcykgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBSRUNPTk5FQ1RfSU5URVJWQUxTW3RyaWVzIC0gMV0gfHwgREVGQVVMVF9SRUNPTk5FQ1RfRkFMTEJBQ0s7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5lbmNvZGUgPVxuICAgICAgICAgICAgKF9oID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmVuY29kZSkgIT09IG51bGwgJiYgX2ggIT09IHZvaWQgMCA/IF9oIDogKChwYXlsb2FkLCBjYWxsYmFjaykgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhKU09OLnN0cmluZ2lmeShwYXlsb2FkKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5kZWNvZGUgPSAoX2ogPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZGVjb2RlKSAhPT0gbnVsbCAmJiBfaiAhPT0gdm9pZCAwID8gX2ogOiB0aGlzLnNlcmlhbGl6ZXIuZGVjb2RlLmJpbmQodGhpcy5zZXJpYWxpemVyKTtcbiAgICAgICAgLy8gSGFuZGxlIHdvcmtlciBzZXR1cFxuICAgICAgICBpZiAodGhpcy53b3JrZXIpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiAhd2luZG93Lldvcmtlcikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignV2ViIFdvcmtlciBpcyBub3Qgc3VwcG9ydGVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLndvcmtlclVybCA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy53b3JrZXJVcmw7XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1SZWFsdGltZUNsaWVudC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/realtime-js/dist/module/RealtimeClient.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/realtime-js/dist/module/RealtimePresence.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@supabase/realtime-js/dist/module/RealtimePresence.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   REALTIME_PRESENCE_LISTEN_EVENTS: () => (/* binding */ REALTIME_PRESENCE_LISTEN_EVENTS),\n/* harmony export */   \"default\": () => (/* binding */ RealtimePresence)\n/* harmony export */ });\n/*\n  This file draws heavily from https://github.com/phoenixframework/phoenix/blob/d344ec0a732ab4ee204215b31de69cf4be72e3bf/assets/js/phoenix/presence.js\n  License: https://github.com/phoenixframework/phoenix/blob/d344ec0a732ab4ee204215b31de69cf4be72e3bf/LICENSE.md\n*/\nvar REALTIME_PRESENCE_LISTEN_EVENTS;\n(function (REALTIME_PRESENCE_LISTEN_EVENTS) {\n    REALTIME_PRESENCE_LISTEN_EVENTS[\"SYNC\"] = \"sync\";\n    REALTIME_PRESENCE_LISTEN_EVENTS[\"JOIN\"] = \"join\";\n    REALTIME_PRESENCE_LISTEN_EVENTS[\"LEAVE\"] = \"leave\";\n})(REALTIME_PRESENCE_LISTEN_EVENTS || (REALTIME_PRESENCE_LISTEN_EVENTS = {}));\nclass RealtimePresence {\n    /**\n     * Initializes the Presence.\n     *\n     * @param channel - The RealtimeChannel\n     * @param opts - The options,\n     *        for example `{events: {state: 'state', diff: 'diff'}}`\n     */\n    constructor(channel, opts) {\n        this.channel = channel;\n        this.state = {};\n        this.pendingDiffs = [];\n        this.joinRef = null;\n        this.enabled = false;\n        this.caller = {\n            onJoin: () => { },\n            onLeave: () => { },\n            onSync: () => { },\n        };\n        const events = (opts === null || opts === void 0 ? void 0 : opts.events) || {\n            state: 'presence_state',\n            diff: 'presence_diff',\n        };\n        this.channel._on(events.state, {}, (newState) => {\n            const { onJoin, onLeave, onSync } = this.caller;\n            this.joinRef = this.channel._joinRef();\n            this.state = RealtimePresence.syncState(this.state, newState, onJoin, onLeave);\n            this.pendingDiffs.forEach((diff) => {\n                this.state = RealtimePresence.syncDiff(this.state, diff, onJoin, onLeave);\n            });\n            this.pendingDiffs = [];\n            onSync();\n        });\n        this.channel._on(events.diff, {}, (diff) => {\n            const { onJoin, onLeave, onSync } = this.caller;\n            if (this.inPendingSyncState()) {\n                this.pendingDiffs.push(diff);\n            }\n            else {\n                this.state = RealtimePresence.syncDiff(this.state, diff, onJoin, onLeave);\n                onSync();\n            }\n        });\n        this.onJoin((key, currentPresences, newPresences) => {\n            this.channel._trigger('presence', {\n                event: 'join',\n                key,\n                currentPresences,\n                newPresences,\n            });\n        });\n        this.onLeave((key, currentPresences, leftPresences) => {\n            this.channel._trigger('presence', {\n                event: 'leave',\n                key,\n                currentPresences,\n                leftPresences,\n            });\n        });\n        this.onSync(() => {\n            this.channel._trigger('presence', { event: 'sync' });\n        });\n    }\n    /**\n     * Used to sync the list of presences on the server with the\n     * client's state.\n     *\n     * An optional `onJoin` and `onLeave` callback can be provided to\n     * react to changes in the client's local presences across\n     * disconnects and reconnects with the server.\n     *\n     * @internal\n     */\n    static syncState(currentState, newState, onJoin, onLeave) {\n        const state = this.cloneDeep(currentState);\n        const transformedState = this.transformState(newState);\n        const joins = {};\n        const leaves = {};\n        this.map(state, (key, presences) => {\n            if (!transformedState[key]) {\n                leaves[key] = presences;\n            }\n        });\n        this.map(transformedState, (key, newPresences) => {\n            const currentPresences = state[key];\n            if (currentPresences) {\n                const newPresenceRefs = newPresences.map((m) => m.presence_ref);\n                const curPresenceRefs = currentPresences.map((m) => m.presence_ref);\n                const joinedPresences = newPresences.filter((m) => curPresenceRefs.indexOf(m.presence_ref) < 0);\n                const leftPresences = currentPresences.filter((m) => newPresenceRefs.indexOf(m.presence_ref) < 0);\n                if (joinedPresences.length > 0) {\n                    joins[key] = joinedPresences;\n                }\n                if (leftPresences.length > 0) {\n                    leaves[key] = leftPresences;\n                }\n            }\n            else {\n                joins[key] = newPresences;\n            }\n        });\n        return this.syncDiff(state, { joins, leaves }, onJoin, onLeave);\n    }\n    /**\n     * Used to sync a diff of presence join and leave events from the\n     * server, as they happen.\n     *\n     * Like `syncState`, `syncDiff` accepts optional `onJoin` and\n     * `onLeave` callbacks to react to a user joining or leaving from a\n     * device.\n     *\n     * @internal\n     */\n    static syncDiff(state, diff, onJoin, onLeave) {\n        const { joins, leaves } = {\n            joins: this.transformState(diff.joins),\n            leaves: this.transformState(diff.leaves),\n        };\n        if (!onJoin) {\n            onJoin = () => { };\n        }\n        if (!onLeave) {\n            onLeave = () => { };\n        }\n        this.map(joins, (key, newPresences) => {\n            var _a;\n            const currentPresences = (_a = state[key]) !== null && _a !== void 0 ? _a : [];\n            state[key] = this.cloneDeep(newPresences);\n            if (currentPresences.length > 0) {\n                const joinedPresenceRefs = state[key].map((m) => m.presence_ref);\n                const curPresences = currentPresences.filter((m) => joinedPresenceRefs.indexOf(m.presence_ref) < 0);\n                state[key].unshift(...curPresences);\n            }\n            onJoin(key, currentPresences, newPresences);\n        });\n        this.map(leaves, (key, leftPresences) => {\n            let currentPresences = state[key];\n            if (!currentPresences)\n                return;\n            const presenceRefsToRemove = leftPresences.map((m) => m.presence_ref);\n            currentPresences = currentPresences.filter((m) => presenceRefsToRemove.indexOf(m.presence_ref) < 0);\n            state[key] = currentPresences;\n            onLeave(key, currentPresences, leftPresences);\n            if (currentPresences.length === 0)\n                delete state[key];\n        });\n        return state;\n    }\n    /** @internal */\n    static map(obj, func) {\n        return Object.getOwnPropertyNames(obj).map((key) => func(key, obj[key]));\n    }\n    /**\n     * Remove 'metas' key\n     * Change 'phx_ref' to 'presence_ref'\n     * Remove 'phx_ref' and 'phx_ref_prev'\n     *\n     * @example\n     * // returns {\n     *  abc123: [\n     *    { presence_ref: '2', user_id: 1 },\n     *    { presence_ref: '3', user_id: 2 }\n     *  ]\n     * }\n     * RealtimePresence.transformState({\n     *  abc123: {\n     *    metas: [\n     *      { phx_ref: '2', phx_ref_prev: '1' user_id: 1 },\n     *      { phx_ref: '3', user_id: 2 }\n     *    ]\n     *  }\n     * })\n     *\n     * @internal\n     */\n    static transformState(state) {\n        state = this.cloneDeep(state);\n        return Object.getOwnPropertyNames(state).reduce((newState, key) => {\n            const presences = state[key];\n            if ('metas' in presences) {\n                newState[key] = presences.metas.map((presence) => {\n                    presence['presence_ref'] = presence['phx_ref'];\n                    delete presence['phx_ref'];\n                    delete presence['phx_ref_prev'];\n                    return presence;\n                });\n            }\n            else {\n                newState[key] = presences;\n            }\n            return newState;\n        }, {});\n    }\n    /** @internal */\n    static cloneDeep(obj) {\n        return JSON.parse(JSON.stringify(obj));\n    }\n    /** @internal */\n    onJoin(callback) {\n        this.caller.onJoin = callback;\n    }\n    /** @internal */\n    onLeave(callback) {\n        this.caller.onLeave = callback;\n    }\n    /** @internal */\n    onSync(callback) {\n        this.caller.onSync = callback;\n    }\n    /** @internal */\n    inPendingSyncState() {\n        return !this.joinRef || this.joinRef !== this.channel._joinRef();\n    }\n}\n//# sourceMappingURL=RealtimePresence.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcmVhbHRpbWUtanMvZGlzdC9tb2R1bGUvUmVhbHRpbWVQcmVzZW5jZS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMEVBQTBFO0FBQzVEO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixTQUFTLDhCQUE4QjtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLDhCQUE4QjtBQUM5Qiw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QyxvQkFBb0IsMEJBQTBCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Qsd0NBQXdDO0FBQ3hDLG9CQUFvQiwwQkFBMEI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0EsZ0RBQWdELGVBQWU7QUFDL0QsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxzQ0FBc0MsZUFBZTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZ0JBQWdCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLCtCQUErQjtBQUMzQyxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsNENBQTRDO0FBQzFELGNBQWM7QUFDZDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLElBQUk7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJEOlxcbmV4dFxcb3JnXFxub2RlX21vZHVsZXNcXEBzdXBhYmFzZVxccmVhbHRpbWUtanNcXGRpc3RcXG1vZHVsZVxcUmVhbHRpbWVQcmVzZW5jZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICBUaGlzIGZpbGUgZHJhd3MgaGVhdmlseSBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9waG9lbml4ZnJhbWV3b3JrL3Bob2VuaXgvYmxvYi9kMzQ0ZWMwYTczMmFiNGVlMjA0MjE1YjMxZGU2OWNmNGJlNzJlM2JmL2Fzc2V0cy9qcy9waG9lbml4L3ByZXNlbmNlLmpzXG4gIExpY2Vuc2U6IGh0dHBzOi8vZ2l0aHViLmNvbS9waG9lbml4ZnJhbWV3b3JrL3Bob2VuaXgvYmxvYi9kMzQ0ZWMwYTczMmFiNGVlMjA0MjE1YjMxZGU2OWNmNGJlNzJlM2JmL0xJQ0VOU0UubWRcbiovXG5leHBvcnQgdmFyIFJFQUxUSU1FX1BSRVNFTkNFX0xJU1RFTl9FVkVOVFM7XG4oZnVuY3Rpb24gKFJFQUxUSU1FX1BSRVNFTkNFX0xJU1RFTl9FVkVOVFMpIHtcbiAgICBSRUFMVElNRV9QUkVTRU5DRV9MSVNURU5fRVZFTlRTW1wiU1lOQ1wiXSA9IFwic3luY1wiO1xuICAgIFJFQUxUSU1FX1BSRVNFTkNFX0xJU1RFTl9FVkVOVFNbXCJKT0lOXCJdID0gXCJqb2luXCI7XG4gICAgUkVBTFRJTUVfUFJFU0VOQ0VfTElTVEVOX0VWRU5UU1tcIkxFQVZFXCJdID0gXCJsZWF2ZVwiO1xufSkoUkVBTFRJTUVfUFJFU0VOQ0VfTElTVEVOX0VWRU5UUyB8fCAoUkVBTFRJTUVfUFJFU0VOQ0VfTElTVEVOX0VWRU5UUyA9IHt9KSk7XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZWFsdGltZVByZXNlbmNlIHtcbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyB0aGUgUHJlc2VuY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2hhbm5lbCAtIFRoZSBSZWFsdGltZUNoYW5uZWxcbiAgICAgKiBAcGFyYW0gb3B0cyAtIFRoZSBvcHRpb25zLFxuICAgICAqICAgICAgICBmb3IgZXhhbXBsZSBge2V2ZW50czoge3N0YXRlOiAnc3RhdGUnLCBkaWZmOiAnZGlmZid9fWBcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihjaGFubmVsLCBvcHRzKSB7XG4gICAgICAgIHRoaXMuY2hhbm5lbCA9IGNoYW5uZWw7XG4gICAgICAgIHRoaXMuc3RhdGUgPSB7fTtcbiAgICAgICAgdGhpcy5wZW5kaW5nRGlmZnMgPSBbXTtcbiAgICAgICAgdGhpcy5qb2luUmVmID0gbnVsbDtcbiAgICAgICAgdGhpcy5lbmFibGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY2FsbGVyID0ge1xuICAgICAgICAgICAgb25Kb2luOiAoKSA9PiB7IH0sXG4gICAgICAgICAgICBvbkxlYXZlOiAoKSA9PiB7IH0sXG4gICAgICAgICAgICBvblN5bmM6ICgpID0+IHsgfSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZXZlbnRzID0gKG9wdHMgPT09IG51bGwgfHwgb3B0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0cy5ldmVudHMpIHx8IHtcbiAgICAgICAgICAgIHN0YXRlOiAncHJlc2VuY2Vfc3RhdGUnLFxuICAgICAgICAgICAgZGlmZjogJ3ByZXNlbmNlX2RpZmYnLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNoYW5uZWwuX29uKGV2ZW50cy5zdGF0ZSwge30sIChuZXdTdGF0ZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBvbkpvaW4sIG9uTGVhdmUsIG9uU3luYyB9ID0gdGhpcy5jYWxsZXI7XG4gICAgICAgICAgICB0aGlzLmpvaW5SZWYgPSB0aGlzLmNoYW5uZWwuX2pvaW5SZWYoKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBSZWFsdGltZVByZXNlbmNlLnN5bmNTdGF0ZSh0aGlzLnN0YXRlLCBuZXdTdGF0ZSwgb25Kb2luLCBvbkxlYXZlKTtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ0RpZmZzLmZvckVhY2goKGRpZmYpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gUmVhbHRpbWVQcmVzZW5jZS5zeW5jRGlmZih0aGlzLnN0YXRlLCBkaWZmLCBvbkpvaW4sIG9uTGVhdmUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdEaWZmcyA9IFtdO1xuICAgICAgICAgICAgb25TeW5jKCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNoYW5uZWwuX29uKGV2ZW50cy5kaWZmLCB7fSwgKGRpZmYpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgb25Kb2luLCBvbkxlYXZlLCBvblN5bmMgfSA9IHRoaXMuY2FsbGVyO1xuICAgICAgICAgICAgaWYgKHRoaXMuaW5QZW5kaW5nU3luY1N0YXRlKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdEaWZmcy5wdXNoKGRpZmYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFJlYWx0aW1lUHJlc2VuY2Uuc3luY0RpZmYodGhpcy5zdGF0ZSwgZGlmZiwgb25Kb2luLCBvbkxlYXZlKTtcbiAgICAgICAgICAgICAgICBvblN5bmMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMub25Kb2luKChrZXksIGN1cnJlbnRQcmVzZW5jZXMsIG5ld1ByZXNlbmNlcykgPT4ge1xuICAgICAgICAgICAgdGhpcy5jaGFubmVsLl90cmlnZ2VyKCdwcmVzZW5jZScsIHtcbiAgICAgICAgICAgICAgICBldmVudDogJ2pvaW4nLFxuICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICBjdXJyZW50UHJlc2VuY2VzLFxuICAgICAgICAgICAgICAgIG5ld1ByZXNlbmNlcyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5vbkxlYXZlKChrZXksIGN1cnJlbnRQcmVzZW5jZXMsIGxlZnRQcmVzZW5jZXMpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbC5fdHJpZ2dlcigncHJlc2VuY2UnLCB7XG4gICAgICAgICAgICAgICAgZXZlbnQ6ICdsZWF2ZScsXG4gICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgIGN1cnJlbnRQcmVzZW5jZXMsXG4gICAgICAgICAgICAgICAgbGVmdFByZXNlbmNlcyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5vblN5bmMoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5jaGFubmVsLl90cmlnZ2VyKCdwcmVzZW5jZScsIHsgZXZlbnQ6ICdzeW5jJyB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVzZWQgdG8gc3luYyB0aGUgbGlzdCBvZiBwcmVzZW5jZXMgb24gdGhlIHNlcnZlciB3aXRoIHRoZVxuICAgICAqIGNsaWVudCdzIHN0YXRlLlxuICAgICAqXG4gICAgICogQW4gb3B0aW9uYWwgYG9uSm9pbmAgYW5kIGBvbkxlYXZlYCBjYWxsYmFjayBjYW4gYmUgcHJvdmlkZWQgdG9cbiAgICAgKiByZWFjdCB0byBjaGFuZ2VzIGluIHRoZSBjbGllbnQncyBsb2NhbCBwcmVzZW5jZXMgYWNyb3NzXG4gICAgICogZGlzY29ubmVjdHMgYW5kIHJlY29ubmVjdHMgd2l0aCB0aGUgc2VydmVyLlxuICAgICAqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgc3RhdGljIHN5bmNTdGF0ZShjdXJyZW50U3RhdGUsIG5ld1N0YXRlLCBvbkpvaW4sIG9uTGVhdmUpIHtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLmNsb25lRGVlcChjdXJyZW50U3RhdGUpO1xuICAgICAgICBjb25zdCB0cmFuc2Zvcm1lZFN0YXRlID0gdGhpcy50cmFuc2Zvcm1TdGF0ZShuZXdTdGF0ZSk7XG4gICAgICAgIGNvbnN0IGpvaW5zID0ge307XG4gICAgICAgIGNvbnN0IGxlYXZlcyA9IHt9O1xuICAgICAgICB0aGlzLm1hcChzdGF0ZSwgKGtleSwgcHJlc2VuY2VzKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRyYW5zZm9ybWVkU3RhdGVba2V5XSkge1xuICAgICAgICAgICAgICAgIGxlYXZlc1trZXldID0gcHJlc2VuY2VzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5tYXAodHJhbnNmb3JtZWRTdGF0ZSwgKGtleSwgbmV3UHJlc2VuY2VzKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50UHJlc2VuY2VzID0gc3RhdGVba2V5XTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UHJlc2VuY2VzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3UHJlc2VuY2VSZWZzID0gbmV3UHJlc2VuY2VzLm1hcCgobSkgPT4gbS5wcmVzZW5jZV9yZWYpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGN1clByZXNlbmNlUmVmcyA9IGN1cnJlbnRQcmVzZW5jZXMubWFwKChtKSA9PiBtLnByZXNlbmNlX3JlZik7XG4gICAgICAgICAgICAgICAgY29uc3Qgam9pbmVkUHJlc2VuY2VzID0gbmV3UHJlc2VuY2VzLmZpbHRlcigobSkgPT4gY3VyUHJlc2VuY2VSZWZzLmluZGV4T2YobS5wcmVzZW5jZV9yZWYpIDwgMCk7XG4gICAgICAgICAgICAgICAgY29uc3QgbGVmdFByZXNlbmNlcyA9IGN1cnJlbnRQcmVzZW5jZXMuZmlsdGVyKChtKSA9PiBuZXdQcmVzZW5jZVJlZnMuaW5kZXhPZihtLnByZXNlbmNlX3JlZikgPCAwKTtcbiAgICAgICAgICAgICAgICBpZiAoam9pbmVkUHJlc2VuY2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgam9pbnNba2V5XSA9IGpvaW5lZFByZXNlbmNlcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGxlZnRQcmVzZW5jZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBsZWF2ZXNba2V5XSA9IGxlZnRQcmVzZW5jZXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgam9pbnNba2V5XSA9IG5ld1ByZXNlbmNlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLnN5bmNEaWZmKHN0YXRlLCB7IGpvaW5zLCBsZWF2ZXMgfSwgb25Kb2luLCBvbkxlYXZlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXNlZCB0byBzeW5jIGEgZGlmZiBvZiBwcmVzZW5jZSBqb2luIGFuZCBsZWF2ZSBldmVudHMgZnJvbSB0aGVcbiAgICAgKiBzZXJ2ZXIsIGFzIHRoZXkgaGFwcGVuLlxuICAgICAqXG4gICAgICogTGlrZSBgc3luY1N0YXRlYCwgYHN5bmNEaWZmYCBhY2NlcHRzIG9wdGlvbmFsIGBvbkpvaW5gIGFuZFxuICAgICAqIGBvbkxlYXZlYCBjYWxsYmFja3MgdG8gcmVhY3QgdG8gYSB1c2VyIGpvaW5pbmcgb3IgbGVhdmluZyBmcm9tIGFcbiAgICAgKiBkZXZpY2UuXG4gICAgICpcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBzdGF0aWMgc3luY0RpZmYoc3RhdGUsIGRpZmYsIG9uSm9pbiwgb25MZWF2ZSkge1xuICAgICAgICBjb25zdCB7IGpvaW5zLCBsZWF2ZXMgfSA9IHtcbiAgICAgICAgICAgIGpvaW5zOiB0aGlzLnRyYW5zZm9ybVN0YXRlKGRpZmYuam9pbnMpLFxuICAgICAgICAgICAgbGVhdmVzOiB0aGlzLnRyYW5zZm9ybVN0YXRlKGRpZmYubGVhdmVzKSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCFvbkpvaW4pIHtcbiAgICAgICAgICAgIG9uSm9pbiA9ICgpID0+IHsgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW9uTGVhdmUpIHtcbiAgICAgICAgICAgIG9uTGVhdmUgPSAoKSA9PiB7IH07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tYXAoam9pbnMsIChrZXksIG5ld1ByZXNlbmNlcykgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgY29uc3QgY3VycmVudFByZXNlbmNlcyA9IChfYSA9IHN0YXRlW2tleV0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtdO1xuICAgICAgICAgICAgc3RhdGVba2V5XSA9IHRoaXMuY2xvbmVEZWVwKG5ld1ByZXNlbmNlcyk7XG4gICAgICAgICAgICBpZiAoY3VycmVudFByZXNlbmNlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgam9pbmVkUHJlc2VuY2VSZWZzID0gc3RhdGVba2V5XS5tYXAoKG0pID0+IG0ucHJlc2VuY2VfcmVmKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJQcmVzZW5jZXMgPSBjdXJyZW50UHJlc2VuY2VzLmZpbHRlcigobSkgPT4gam9pbmVkUHJlc2VuY2VSZWZzLmluZGV4T2YobS5wcmVzZW5jZV9yZWYpIDwgMCk7XG4gICAgICAgICAgICAgICAgc3RhdGVba2V5XS51bnNoaWZ0KC4uLmN1clByZXNlbmNlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvbkpvaW4oa2V5LCBjdXJyZW50UHJlc2VuY2VzLCBuZXdQcmVzZW5jZXMpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5tYXAobGVhdmVzLCAoa2V5LCBsZWZ0UHJlc2VuY2VzKSA9PiB7XG4gICAgICAgICAgICBsZXQgY3VycmVudFByZXNlbmNlcyA9IHN0YXRlW2tleV07XG4gICAgICAgICAgICBpZiAoIWN1cnJlbnRQcmVzZW5jZXMpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY29uc3QgcHJlc2VuY2VSZWZzVG9SZW1vdmUgPSBsZWZ0UHJlc2VuY2VzLm1hcCgobSkgPT4gbS5wcmVzZW5jZV9yZWYpO1xuICAgICAgICAgICAgY3VycmVudFByZXNlbmNlcyA9IGN1cnJlbnRQcmVzZW5jZXMuZmlsdGVyKChtKSA9PiBwcmVzZW5jZVJlZnNUb1JlbW92ZS5pbmRleE9mKG0ucHJlc2VuY2VfcmVmKSA8IDApO1xuICAgICAgICAgICAgc3RhdGVba2V5XSA9IGN1cnJlbnRQcmVzZW5jZXM7XG4gICAgICAgICAgICBvbkxlYXZlKGtleSwgY3VycmVudFByZXNlbmNlcywgbGVmdFByZXNlbmNlcyk7XG4gICAgICAgICAgICBpZiAoY3VycmVudFByZXNlbmNlcy5sZW5ndGggPT09IDApXG4gICAgICAgICAgICAgICAgZGVsZXRlIHN0YXRlW2tleV07XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBzdGF0aWMgbWFwKG9iaiwgZnVuYykge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob2JqKS5tYXAoKGtleSkgPT4gZnVuYyhrZXksIG9ialtrZXldKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZSAnbWV0YXMnIGtleVxuICAgICAqIENoYW5nZSAncGh4X3JlZicgdG8gJ3ByZXNlbmNlX3JlZidcbiAgICAgKiBSZW1vdmUgJ3BoeF9yZWYnIGFuZCAncGh4X3JlZl9wcmV2J1xuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyByZXR1cm5zIHtcbiAgICAgKiAgYWJjMTIzOiBbXG4gICAgICogICAgeyBwcmVzZW5jZV9yZWY6ICcyJywgdXNlcl9pZDogMSB9LFxuICAgICAqICAgIHsgcHJlc2VuY2VfcmVmOiAnMycsIHVzZXJfaWQ6IDIgfVxuICAgICAqICBdXG4gICAgICogfVxuICAgICAqIFJlYWx0aW1lUHJlc2VuY2UudHJhbnNmb3JtU3RhdGUoe1xuICAgICAqICBhYmMxMjM6IHtcbiAgICAgKiAgICBtZXRhczogW1xuICAgICAqICAgICAgeyBwaHhfcmVmOiAnMicsIHBoeF9yZWZfcHJldjogJzEnIHVzZXJfaWQ6IDEgfSxcbiAgICAgKiAgICAgIHsgcGh4X3JlZjogJzMnLCB1c2VyX2lkOiAyIH1cbiAgICAgKiAgICBdXG4gICAgICogIH1cbiAgICAgKiB9KVxuICAgICAqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgc3RhdGljIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XG4gICAgICAgIHN0YXRlID0gdGhpcy5jbG9uZURlZXAoc3RhdGUpO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoc3RhdGUpLnJlZHVjZSgobmV3U3RhdGUsIGtleSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcHJlc2VuY2VzID0gc3RhdGVba2V5XTtcbiAgICAgICAgICAgIGlmICgnbWV0YXMnIGluIHByZXNlbmNlcykge1xuICAgICAgICAgICAgICAgIG5ld1N0YXRlW2tleV0gPSBwcmVzZW5jZXMubWV0YXMubWFwKChwcmVzZW5jZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBwcmVzZW5jZVsncHJlc2VuY2VfcmVmJ10gPSBwcmVzZW5jZVsncGh4X3JlZiddO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgcHJlc2VuY2VbJ3BoeF9yZWYnXTtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHByZXNlbmNlWydwaHhfcmVmX3ByZXYnXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByZXNlbmNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV3U3RhdGVba2V5XSA9IHByZXNlbmNlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXdTdGF0ZTtcbiAgICAgICAgfSwge30pO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgc3RhdGljIGNsb25lRGVlcChvYmopIHtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkob2JqKSk7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBvbkpvaW4oY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5jYWxsZXIub25Kb2luID0gY2FsbGJhY2s7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBvbkxlYXZlKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuY2FsbGVyLm9uTGVhdmUgPSBjYWxsYmFjaztcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIG9uU3luYyhjYWxsYmFjaykge1xuICAgICAgICB0aGlzLmNhbGxlci5vblN5bmMgPSBjYWxsYmFjaztcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIGluUGVuZGluZ1N5bmNTdGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmpvaW5SZWYgfHwgdGhpcy5qb2luUmVmICE9PSB0aGlzLmNoYW5uZWwuX2pvaW5SZWYoKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1SZWFsdGltZVByZXNlbmNlLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/realtime-js/dist/module/RealtimePresence.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/realtime-js/dist/module/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@supabase/realtime-js/dist/module/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   REALTIME_CHANNEL_STATES: () => (/* reexport safe */ _RealtimeChannel__WEBPACK_IMPORTED_MODULE_1__.REALTIME_CHANNEL_STATES),\n/* harmony export */   REALTIME_LISTEN_TYPES: () => (/* reexport safe */ _RealtimeChannel__WEBPACK_IMPORTED_MODULE_1__.REALTIME_LISTEN_TYPES),\n/* harmony export */   REALTIME_POSTGRES_CHANGES_LISTEN_EVENT: () => (/* reexport safe */ _RealtimeChannel__WEBPACK_IMPORTED_MODULE_1__.REALTIME_POSTGRES_CHANGES_LISTEN_EVENT),\n/* harmony export */   REALTIME_PRESENCE_LISTEN_EVENTS: () => (/* reexport safe */ _RealtimePresence__WEBPACK_IMPORTED_MODULE_2__.REALTIME_PRESENCE_LISTEN_EVENTS),\n/* harmony export */   REALTIME_SUBSCRIBE_STATES: () => (/* reexport safe */ _RealtimeChannel__WEBPACK_IMPORTED_MODULE_1__.REALTIME_SUBSCRIBE_STATES),\n/* harmony export */   RealtimeChannel: () => (/* reexport safe */ _RealtimeChannel__WEBPACK_IMPORTED_MODULE_1__[\"default\"]),\n/* harmony export */   RealtimeClient: () => (/* reexport safe */ _RealtimeClient__WEBPACK_IMPORTED_MODULE_0__[\"default\"]),\n/* harmony export */   RealtimePresence: () => (/* reexport safe */ _RealtimePresence__WEBPACK_IMPORTED_MODULE_2__[\"default\"]),\n/* harmony export */   WebSocketFactory: () => (/* reexport safe */ _lib_websocket_factory__WEBPACK_IMPORTED_MODULE_3__[\"default\"])\n/* harmony export */ });\n/* harmony import */ var _RealtimeClient__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./RealtimeClient */ \"(app-pages-browser)/./node_modules/@supabase/realtime-js/dist/module/RealtimeClient.js\");\n/* harmony import */ var _RealtimeChannel__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./RealtimeChannel */ \"(app-pages-browser)/./node_modules/@supabase/realtime-js/dist/module/RealtimeChannel.js\");\n/* harmony import */ var _RealtimePresence__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./RealtimePresence */ \"(app-pages-browser)/./node_modules/@supabase/realtime-js/dist/module/RealtimePresence.js\");\n/* harmony import */ var _lib_websocket_factory__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lib/websocket-factory */ \"(app-pages-browser)/./node_modules/@supabase/realtime-js/dist/module/lib/websocket-factory.js\");\n\n\n\n\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcmVhbHRpbWUtanMvZGlzdC9tb2R1bGUvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUE4QztBQUMwSDtBQUNoRjtBQUNqQztBQUM2SztBQUNwTyIsInNvdXJjZXMiOlsiRDpcXG5leHRcXG9yZ1xcbm9kZV9tb2R1bGVzXFxAc3VwYWJhc2VcXHJlYWx0aW1lLWpzXFxkaXN0XFxtb2R1bGVcXGluZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFsdGltZUNsaWVudCBmcm9tICcuL1JlYWx0aW1lQ2xpZW50JztcbmltcG9ydCBSZWFsdGltZUNoYW5uZWwsIHsgUkVBTFRJTUVfTElTVEVOX1RZUEVTLCBSRUFMVElNRV9QT1NUR1JFU19DSEFOR0VTX0xJU1RFTl9FVkVOVCwgUkVBTFRJTUVfU1VCU0NSSUJFX1NUQVRFUywgUkVBTFRJTUVfQ0hBTk5FTF9TVEFURVMsIH0gZnJvbSAnLi9SZWFsdGltZUNoYW5uZWwnO1xuaW1wb3J0IFJlYWx0aW1lUHJlc2VuY2UsIHsgUkVBTFRJTUVfUFJFU0VOQ0VfTElTVEVOX0VWRU5UUywgfSBmcm9tICcuL1JlYWx0aW1lUHJlc2VuY2UnO1xuaW1wb3J0IFdlYlNvY2tldEZhY3RvcnkgZnJvbSAnLi9saWIvd2Vic29ja2V0LWZhY3RvcnknO1xuZXhwb3J0IHsgUmVhbHRpbWVQcmVzZW5jZSwgUmVhbHRpbWVDaGFubmVsLCBSZWFsdGltZUNsaWVudCwgUkVBTFRJTUVfTElTVEVOX1RZUEVTLCBSRUFMVElNRV9QT1NUR1JFU19DSEFOR0VTX0xJU1RFTl9FVkVOVCwgUkVBTFRJTUVfUFJFU0VOQ0VfTElTVEVOX0VWRU5UUywgUkVBTFRJTUVfU1VCU0NSSUJFX1NUQVRFUywgUkVBTFRJTUVfQ0hBTk5FTF9TVEFURVMsIFdlYlNvY2tldEZhY3RvcnksIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/realtime-js/dist/module/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/realtime-js/dist/module/lib/constants.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@supabase/realtime-js/dist/module/lib/constants.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CHANNEL_EVENTS: () => (/* binding */ CHANNEL_EVENTS),\n/* harmony export */   CHANNEL_STATES: () => (/* binding */ CHANNEL_STATES),\n/* harmony export */   CONNECTION_STATE: () => (/* binding */ CONNECTION_STATE),\n/* harmony export */   DEFAULT_TIMEOUT: () => (/* binding */ DEFAULT_TIMEOUT),\n/* harmony export */   DEFAULT_VERSION: () => (/* binding */ DEFAULT_VERSION),\n/* harmony export */   MAX_PUSH_BUFFER_SIZE: () => (/* binding */ MAX_PUSH_BUFFER_SIZE),\n/* harmony export */   SOCKET_STATES: () => (/* binding */ SOCKET_STATES),\n/* harmony export */   TRANSPORTS: () => (/* binding */ TRANSPORTS),\n/* harmony export */   VERSION: () => (/* binding */ VERSION),\n/* harmony export */   VSN: () => (/* binding */ VSN),\n/* harmony export */   WS_CLOSE_NORMAL: () => (/* binding */ WS_CLOSE_NORMAL)\n/* harmony export */ });\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./version */ \"(app-pages-browser)/./node_modules/@supabase/realtime-js/dist/module/lib/version.js\");\n\nconst DEFAULT_VERSION = `realtime-js/${_version__WEBPACK_IMPORTED_MODULE_0__.version}`;\nconst VSN = '1.0.0';\nconst VERSION = _version__WEBPACK_IMPORTED_MODULE_0__.version;\nconst DEFAULT_TIMEOUT = 10000;\nconst WS_CLOSE_NORMAL = 1000;\nconst MAX_PUSH_BUFFER_SIZE = 100;\nvar SOCKET_STATES;\n(function (SOCKET_STATES) {\n    SOCKET_STATES[SOCKET_STATES[\"connecting\"] = 0] = \"connecting\";\n    SOCKET_STATES[SOCKET_STATES[\"open\"] = 1] = \"open\";\n    SOCKET_STATES[SOCKET_STATES[\"closing\"] = 2] = \"closing\";\n    SOCKET_STATES[SOCKET_STATES[\"closed\"] = 3] = \"closed\";\n})(SOCKET_STATES || (SOCKET_STATES = {}));\nvar CHANNEL_STATES;\n(function (CHANNEL_STATES) {\n    CHANNEL_STATES[\"closed\"] = \"closed\";\n    CHANNEL_STATES[\"errored\"] = \"errored\";\n    CHANNEL_STATES[\"joined\"] = \"joined\";\n    CHANNEL_STATES[\"joining\"] = \"joining\";\n    CHANNEL_STATES[\"leaving\"] = \"leaving\";\n})(CHANNEL_STATES || (CHANNEL_STATES = {}));\nvar CHANNEL_EVENTS;\n(function (CHANNEL_EVENTS) {\n    CHANNEL_EVENTS[\"close\"] = \"phx_close\";\n    CHANNEL_EVENTS[\"error\"] = \"phx_error\";\n    CHANNEL_EVENTS[\"join\"] = \"phx_join\";\n    CHANNEL_EVENTS[\"reply\"] = \"phx_reply\";\n    CHANNEL_EVENTS[\"leave\"] = \"phx_leave\";\n    CHANNEL_EVENTS[\"access_token\"] = \"access_token\";\n})(CHANNEL_EVENTS || (CHANNEL_EVENTS = {}));\nvar TRANSPORTS;\n(function (TRANSPORTS) {\n    TRANSPORTS[\"websocket\"] = \"websocket\";\n})(TRANSPORTS || (TRANSPORTS = {}));\nvar CONNECTION_STATE;\n(function (CONNECTION_STATE) {\n    CONNECTION_STATE[\"Connecting\"] = \"connecting\";\n    CONNECTION_STATE[\"Open\"] = \"open\";\n    CONNECTION_STATE[\"Closing\"] = \"closing\";\n    CONNECTION_STATE[\"Closed\"] = \"closed\";\n})(CONNECTION_STATE || (CONNECTION_STATE = {}));\n//# sourceMappingURL=constants.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcmVhbHRpbWUtanMvZGlzdC9tb2R1bGUvbGliL2NvbnN0YW50cy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBb0M7QUFDN0IsdUNBQXVDLDZDQUFPLENBQUM7QUFDL0M7QUFDQSxnQkFBZ0IsNkNBQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxzQ0FBc0M7QUFDaEM7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHdDQUF3QztBQUNsQztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx3Q0FBd0M7QUFDbEM7QUFDUDtBQUNBO0FBQ0EsQ0FBQyxnQ0FBZ0M7QUFDMUI7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw0Q0FBNEM7QUFDN0MiLCJzb3VyY2VzIjpbIkQ6XFxuZXh0XFxvcmdcXG5vZGVfbW9kdWxlc1xcQHN1cGFiYXNlXFxyZWFsdGltZS1qc1xcZGlzdFxcbW9kdWxlXFxsaWJcXGNvbnN0YW50cy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSAnLi92ZXJzaW9uJztcbmV4cG9ydCBjb25zdCBERUZBVUxUX1ZFUlNJT04gPSBgcmVhbHRpbWUtanMvJHt2ZXJzaW9ufWA7XG5leHBvcnQgY29uc3QgVlNOID0gJzEuMC4wJztcbmV4cG9ydCBjb25zdCBWRVJTSU9OID0gdmVyc2lvbjtcbmV4cG9ydCBjb25zdCBERUZBVUxUX1RJTUVPVVQgPSAxMDAwMDtcbmV4cG9ydCBjb25zdCBXU19DTE9TRV9OT1JNQUwgPSAxMDAwO1xuZXhwb3J0IGNvbnN0IE1BWF9QVVNIX0JVRkZFUl9TSVpFID0gMTAwO1xuZXhwb3J0IHZhciBTT0NLRVRfU1RBVEVTO1xuKGZ1bmN0aW9uIChTT0NLRVRfU1RBVEVTKSB7XG4gICAgU09DS0VUX1NUQVRFU1tTT0NLRVRfU1RBVEVTW1wiY29ubmVjdGluZ1wiXSA9IDBdID0gXCJjb25uZWN0aW5nXCI7XG4gICAgU09DS0VUX1NUQVRFU1tTT0NLRVRfU1RBVEVTW1wib3BlblwiXSA9IDFdID0gXCJvcGVuXCI7XG4gICAgU09DS0VUX1NUQVRFU1tTT0NLRVRfU1RBVEVTW1wiY2xvc2luZ1wiXSA9IDJdID0gXCJjbG9zaW5nXCI7XG4gICAgU09DS0VUX1NUQVRFU1tTT0NLRVRfU1RBVEVTW1wiY2xvc2VkXCJdID0gM10gPSBcImNsb3NlZFwiO1xufSkoU09DS0VUX1NUQVRFUyB8fCAoU09DS0VUX1NUQVRFUyA9IHt9KSk7XG5leHBvcnQgdmFyIENIQU5ORUxfU1RBVEVTO1xuKGZ1bmN0aW9uIChDSEFOTkVMX1NUQVRFUykge1xuICAgIENIQU5ORUxfU1RBVEVTW1wiY2xvc2VkXCJdID0gXCJjbG9zZWRcIjtcbiAgICBDSEFOTkVMX1NUQVRFU1tcImVycm9yZWRcIl0gPSBcImVycm9yZWRcIjtcbiAgICBDSEFOTkVMX1NUQVRFU1tcImpvaW5lZFwiXSA9IFwiam9pbmVkXCI7XG4gICAgQ0hBTk5FTF9TVEFURVNbXCJqb2luaW5nXCJdID0gXCJqb2luaW5nXCI7XG4gICAgQ0hBTk5FTF9TVEFURVNbXCJsZWF2aW5nXCJdID0gXCJsZWF2aW5nXCI7XG59KShDSEFOTkVMX1NUQVRFUyB8fCAoQ0hBTk5FTF9TVEFURVMgPSB7fSkpO1xuZXhwb3J0IHZhciBDSEFOTkVMX0VWRU5UUztcbihmdW5jdGlvbiAoQ0hBTk5FTF9FVkVOVFMpIHtcbiAgICBDSEFOTkVMX0VWRU5UU1tcImNsb3NlXCJdID0gXCJwaHhfY2xvc2VcIjtcbiAgICBDSEFOTkVMX0VWRU5UU1tcImVycm9yXCJdID0gXCJwaHhfZXJyb3JcIjtcbiAgICBDSEFOTkVMX0VWRU5UU1tcImpvaW5cIl0gPSBcInBoeF9qb2luXCI7XG4gICAgQ0hBTk5FTF9FVkVOVFNbXCJyZXBseVwiXSA9IFwicGh4X3JlcGx5XCI7XG4gICAgQ0hBTk5FTF9FVkVOVFNbXCJsZWF2ZVwiXSA9IFwicGh4X2xlYXZlXCI7XG4gICAgQ0hBTk5FTF9FVkVOVFNbXCJhY2Nlc3NfdG9rZW5cIl0gPSBcImFjY2Vzc190b2tlblwiO1xufSkoQ0hBTk5FTF9FVkVOVFMgfHwgKENIQU5ORUxfRVZFTlRTID0ge30pKTtcbmV4cG9ydCB2YXIgVFJBTlNQT1JUUztcbihmdW5jdGlvbiAoVFJBTlNQT1JUUykge1xuICAgIFRSQU5TUE9SVFNbXCJ3ZWJzb2NrZXRcIl0gPSBcIndlYnNvY2tldFwiO1xufSkoVFJBTlNQT1JUUyB8fCAoVFJBTlNQT1JUUyA9IHt9KSk7XG5leHBvcnQgdmFyIENPTk5FQ1RJT05fU1RBVEU7XG4oZnVuY3Rpb24gKENPTk5FQ1RJT05fU1RBVEUpIHtcbiAgICBDT05ORUNUSU9OX1NUQVRFW1wiQ29ubmVjdGluZ1wiXSA9IFwiY29ubmVjdGluZ1wiO1xuICAgIENPTk5FQ1RJT05fU1RBVEVbXCJPcGVuXCJdID0gXCJvcGVuXCI7XG4gICAgQ09OTkVDVElPTl9TVEFURVtcIkNsb3NpbmdcIl0gPSBcImNsb3NpbmdcIjtcbiAgICBDT05ORUNUSU9OX1NUQVRFW1wiQ2xvc2VkXCJdID0gXCJjbG9zZWRcIjtcbn0pKENPTk5FQ1RJT05fU1RBVEUgfHwgKENPTk5FQ1RJT05fU1RBVEUgPSB7fSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uc3RhbnRzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/realtime-js/dist/module/lib/constants.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/realtime-js/dist/module/lib/push.js":
/*!********************************************************************!*\
  !*** ./node_modules/@supabase/realtime-js/dist/module/lib/push.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Push)\n/* harmony export */ });\n/* harmony import */ var _lib_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/constants */ \"(app-pages-browser)/./node_modules/@supabase/realtime-js/dist/module/lib/constants.js\");\n\nclass Push {\n    /**\n     * Initializes the Push\n     *\n     * @param channel The Channel\n     * @param event The event, for example `\"phx_join\"`\n     * @param payload The payload, for example `{user_id: 123}`\n     * @param timeout The push timeout in milliseconds\n     */\n    constructor(channel, event, payload = {}, timeout = _lib_constants__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_TIMEOUT) {\n        this.channel = channel;\n        this.event = event;\n        this.payload = payload;\n        this.timeout = timeout;\n        this.sent = false;\n        this.timeoutTimer = undefined;\n        this.ref = '';\n        this.receivedResp = null;\n        this.recHooks = [];\n        this.refEvent = null;\n    }\n    resend(timeout) {\n        this.timeout = timeout;\n        this._cancelRefEvent();\n        this.ref = '';\n        this.refEvent = null;\n        this.receivedResp = null;\n        this.sent = false;\n        this.send();\n    }\n    send() {\n        if (this._hasReceived('timeout')) {\n            return;\n        }\n        this.startTimeout();\n        this.sent = true;\n        this.channel.socket.push({\n            topic: this.channel.topic,\n            event: this.event,\n            payload: this.payload,\n            ref: this.ref,\n            join_ref: this.channel._joinRef(),\n        });\n    }\n    updatePayload(payload) {\n        this.payload = Object.assign(Object.assign({}, this.payload), payload);\n    }\n    receive(status, callback) {\n        var _a;\n        if (this._hasReceived(status)) {\n            callback((_a = this.receivedResp) === null || _a === void 0 ? void 0 : _a.response);\n        }\n        this.recHooks.push({ status, callback });\n        return this;\n    }\n    startTimeout() {\n        if (this.timeoutTimer) {\n            return;\n        }\n        this.ref = this.channel.socket._makeRef();\n        this.refEvent = this.channel._replyEventName(this.ref);\n        const callback = (payload) => {\n            this._cancelRefEvent();\n            this._cancelTimeout();\n            this.receivedResp = payload;\n            this._matchReceive(payload);\n        };\n        this.channel._on(this.refEvent, {}, callback);\n        this.timeoutTimer = setTimeout(() => {\n            this.trigger('timeout', {});\n        }, this.timeout);\n    }\n    trigger(status, response) {\n        if (this.refEvent)\n            this.channel._trigger(this.refEvent, { status, response });\n    }\n    destroy() {\n        this._cancelRefEvent();\n        this._cancelTimeout();\n    }\n    _cancelRefEvent() {\n        if (!this.refEvent) {\n            return;\n        }\n        this.channel._off(this.refEvent, {});\n    }\n    _cancelTimeout() {\n        clearTimeout(this.timeoutTimer);\n        this.timeoutTimer = undefined;\n    }\n    _matchReceive({ status, response }) {\n        this.recHooks.filter((h) => h.status === status).forEach((h) => h.callback(response));\n    }\n    _hasReceived(status) {\n        return this.receivedResp && this.receivedResp.status === status;\n    }\n}\n//# sourceMappingURL=push.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcmVhbHRpbWUtanMvZGlzdC9tb2R1bGUvbGliL3B1c2guanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBbUQ7QUFDcEM7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELGFBQWE7QUFDOUQ7QUFDQTtBQUNBLDRDQUE0QyxZQUFZLDJEQUFlO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsa0JBQWtCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQSxzQ0FBc0M7QUFDdEMsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxrQkFBa0I7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJEOlxcbmV4dFxcb3JnXFxub2RlX21vZHVsZXNcXEBzdXBhYmFzZVxccmVhbHRpbWUtanNcXGRpc3RcXG1vZHVsZVxcbGliXFxwdXNoLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IERFRkFVTFRfVElNRU9VVCB9IGZyb20gJy4uL2xpYi9jb25zdGFudHMnO1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUHVzaCB7XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgdGhlIFB1c2hcbiAgICAgKlxuICAgICAqIEBwYXJhbSBjaGFubmVsIFRoZSBDaGFubmVsXG4gICAgICogQHBhcmFtIGV2ZW50IFRoZSBldmVudCwgZm9yIGV4YW1wbGUgYFwicGh4X2pvaW5cImBcbiAgICAgKiBAcGFyYW0gcGF5bG9hZCBUaGUgcGF5bG9hZCwgZm9yIGV4YW1wbGUgYHt1c2VyX2lkOiAxMjN9YFxuICAgICAqIEBwYXJhbSB0aW1lb3V0IFRoZSBwdXNoIHRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY2hhbm5lbCwgZXZlbnQsIHBheWxvYWQgPSB7fSwgdGltZW91dCA9IERFRkFVTFRfVElNRU9VVCkge1xuICAgICAgICB0aGlzLmNoYW5uZWwgPSBjaGFubmVsO1xuICAgICAgICB0aGlzLmV2ZW50ID0gZXZlbnQ7XG4gICAgICAgIHRoaXMucGF5bG9hZCA9IHBheWxvYWQ7XG4gICAgICAgIHRoaXMudGltZW91dCA9IHRpbWVvdXQ7XG4gICAgICAgIHRoaXMuc2VudCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnRpbWVvdXRUaW1lciA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5yZWYgPSAnJztcbiAgICAgICAgdGhpcy5yZWNlaXZlZFJlc3AgPSBudWxsO1xuICAgICAgICB0aGlzLnJlY0hvb2tzID0gW107XG4gICAgICAgIHRoaXMucmVmRXZlbnQgPSBudWxsO1xuICAgIH1cbiAgICByZXNlbmQodGltZW91dCkge1xuICAgICAgICB0aGlzLnRpbWVvdXQgPSB0aW1lb3V0O1xuICAgICAgICB0aGlzLl9jYW5jZWxSZWZFdmVudCgpO1xuICAgICAgICB0aGlzLnJlZiA9ICcnO1xuICAgICAgICB0aGlzLnJlZkV2ZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZWNlaXZlZFJlc3AgPSBudWxsO1xuICAgICAgICB0aGlzLnNlbnQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zZW5kKCk7XG4gICAgfVxuICAgIHNlbmQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9oYXNSZWNlaXZlZCgndGltZW91dCcpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGFydFRpbWVvdXQoKTtcbiAgICAgICAgdGhpcy5zZW50ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5jaGFubmVsLnNvY2tldC5wdXNoKHtcbiAgICAgICAgICAgIHRvcGljOiB0aGlzLmNoYW5uZWwudG9waWMsXG4gICAgICAgICAgICBldmVudDogdGhpcy5ldmVudCxcbiAgICAgICAgICAgIHBheWxvYWQ6IHRoaXMucGF5bG9hZCxcbiAgICAgICAgICAgIHJlZjogdGhpcy5yZWYsXG4gICAgICAgICAgICBqb2luX3JlZjogdGhpcy5jaGFubmVsLl9qb2luUmVmKCksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB1cGRhdGVQYXlsb2FkKHBheWxvYWQpIHtcbiAgICAgICAgdGhpcy5wYXlsb2FkID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLnBheWxvYWQpLCBwYXlsb2FkKTtcbiAgICB9XG4gICAgcmVjZWl2ZShzdGF0dXMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKHRoaXMuX2hhc1JlY2VpdmVkKHN0YXR1cykpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKChfYSA9IHRoaXMucmVjZWl2ZWRSZXNwKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVzcG9uc2UpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVjSG9va3MucHVzaCh7IHN0YXR1cywgY2FsbGJhY2sgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBzdGFydFRpbWVvdXQoKSB7XG4gICAgICAgIGlmICh0aGlzLnRpbWVvdXRUaW1lcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVmID0gdGhpcy5jaGFubmVsLnNvY2tldC5fbWFrZVJlZigpO1xuICAgICAgICB0aGlzLnJlZkV2ZW50ID0gdGhpcy5jaGFubmVsLl9yZXBseUV2ZW50TmFtZSh0aGlzLnJlZik7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrID0gKHBheWxvYWQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX2NhbmNlbFJlZkV2ZW50KCk7XG4gICAgICAgICAgICB0aGlzLl9jYW5jZWxUaW1lb3V0KCk7XG4gICAgICAgICAgICB0aGlzLnJlY2VpdmVkUmVzcCA9IHBheWxvYWQ7XG4gICAgICAgICAgICB0aGlzLl9tYXRjaFJlY2VpdmUocGF5bG9hZCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY2hhbm5lbC5fb24odGhpcy5yZWZFdmVudCwge30sIGNhbGxiYWNrKTtcbiAgICAgICAgdGhpcy50aW1lb3V0VGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcigndGltZW91dCcsIHt9KTtcbiAgICAgICAgfSwgdGhpcy50aW1lb3V0KTtcbiAgICB9XG4gICAgdHJpZ2dlcihzdGF0dXMsIHJlc3BvbnNlKSB7XG4gICAgICAgIGlmICh0aGlzLnJlZkV2ZW50KVxuICAgICAgICAgICAgdGhpcy5jaGFubmVsLl90cmlnZ2VyKHRoaXMucmVmRXZlbnQsIHsgc3RhdHVzLCByZXNwb25zZSB9KTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5fY2FuY2VsUmVmRXZlbnQoKTtcbiAgICAgICAgdGhpcy5fY2FuY2VsVGltZW91dCgpO1xuICAgIH1cbiAgICBfY2FuY2VsUmVmRXZlbnQoKSB7XG4gICAgICAgIGlmICghdGhpcy5yZWZFdmVudCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2hhbm5lbC5fb2ZmKHRoaXMucmVmRXZlbnQsIHt9KTtcbiAgICB9XG4gICAgX2NhbmNlbFRpbWVvdXQoKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXRUaW1lcik7XG4gICAgICAgIHRoaXMudGltZW91dFRpbWVyID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBfbWF0Y2hSZWNlaXZlKHsgc3RhdHVzLCByZXNwb25zZSB9KSB7XG4gICAgICAgIHRoaXMucmVjSG9va3MuZmlsdGVyKChoKSA9PiBoLnN0YXR1cyA9PT0gc3RhdHVzKS5mb3JFYWNoKChoKSA9PiBoLmNhbGxiYWNrKHJlc3BvbnNlKSk7XG4gICAgfVxuICAgIF9oYXNSZWNlaXZlZChzdGF0dXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVjZWl2ZWRSZXNwICYmIHRoaXMucmVjZWl2ZWRSZXNwLnN0YXR1cyA9PT0gc3RhdHVzO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXB1c2guanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/realtime-js/dist/module/lib/push.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/realtime-js/dist/module/lib/serializer.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@supabase/realtime-js/dist/module/lib/serializer.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Serializer)\n/* harmony export */ });\n// This file draws heavily from https://github.com/phoenixframework/phoenix/commit/cf098e9cf7a44ee6479d31d911a97d3c7430c6fe\n// License: https://github.com/phoenixframework/phoenix/blob/master/LICENSE.md\nclass Serializer {\n    constructor() {\n        this.HEADER_LENGTH = 1;\n    }\n    decode(rawPayload, callback) {\n        if (rawPayload.constructor === ArrayBuffer) {\n            return callback(this._binaryDecode(rawPayload));\n        }\n        if (typeof rawPayload === 'string') {\n            return callback(JSON.parse(rawPayload));\n        }\n        return callback({});\n    }\n    _binaryDecode(buffer) {\n        const view = new DataView(buffer);\n        const decoder = new TextDecoder();\n        return this._decodeBroadcast(buffer, view, decoder);\n    }\n    _decodeBroadcast(buffer, view, decoder) {\n        const topicSize = view.getUint8(1);\n        const eventSize = view.getUint8(2);\n        let offset = this.HEADER_LENGTH + 2;\n        const topic = decoder.decode(buffer.slice(offset, offset + topicSize));\n        offset = offset + topicSize;\n        const event = decoder.decode(buffer.slice(offset, offset + eventSize));\n        offset = offset + eventSize;\n        const data = JSON.parse(decoder.decode(buffer.slice(offset, buffer.byteLength)));\n        return { ref: null, topic: topic, event: event, payload: data };\n    }\n}\n//# sourceMappingURL=serializer.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcmVhbHRpbWUtanMvZGlzdC9tb2R1bGUvbGliL3NlcmlhbGl6ZXIuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFxuZXh0XFxvcmdcXG5vZGVfbW9kdWxlc1xcQHN1cGFiYXNlXFxyZWFsdGltZS1qc1xcZGlzdFxcbW9kdWxlXFxsaWJcXHNlcmlhbGl6ZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gVGhpcyBmaWxlIGRyYXdzIGhlYXZpbHkgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vcGhvZW5peGZyYW1ld29yay9waG9lbml4L2NvbW1pdC9jZjA5OGU5Y2Y3YTQ0ZWU2NDc5ZDMxZDkxMWE5N2QzYzc0MzBjNmZlXG4vLyBMaWNlbnNlOiBodHRwczovL2dpdGh1Yi5jb20vcGhvZW5peGZyYW1ld29yay9waG9lbml4L2Jsb2IvbWFzdGVyL0xJQ0VOU0UubWRcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNlcmlhbGl6ZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLkhFQURFUl9MRU5HVEggPSAxO1xuICAgIH1cbiAgICBkZWNvZGUocmF3UGF5bG9hZCwgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKHJhd1BheWxvYWQuY29uc3RydWN0b3IgPT09IEFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sodGhpcy5fYmluYXJ5RGVjb2RlKHJhd1BheWxvYWQpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHJhd1BheWxvYWQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soSlNPTi5wYXJzZShyYXdQYXlsb2FkKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKHt9KTtcbiAgICB9XG4gICAgX2JpbmFyeURlY29kZShidWZmZXIpIHtcbiAgICAgICAgY29uc3QgdmlldyA9IG5ldyBEYXRhVmlldyhidWZmZXIpO1xuICAgICAgICBjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWNvZGVCcm9hZGNhc3QoYnVmZmVyLCB2aWV3LCBkZWNvZGVyKTtcbiAgICB9XG4gICAgX2RlY29kZUJyb2FkY2FzdChidWZmZXIsIHZpZXcsIGRlY29kZXIpIHtcbiAgICAgICAgY29uc3QgdG9waWNTaXplID0gdmlldy5nZXRVaW50OCgxKTtcbiAgICAgICAgY29uc3QgZXZlbnRTaXplID0gdmlldy5nZXRVaW50OCgyKTtcbiAgICAgICAgbGV0IG9mZnNldCA9IHRoaXMuSEVBREVSX0xFTkdUSCArIDI7XG4gICAgICAgIGNvbnN0IHRvcGljID0gZGVjb2Rlci5kZWNvZGUoYnVmZmVyLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgdG9waWNTaXplKSk7XG4gICAgICAgIG9mZnNldCA9IG9mZnNldCArIHRvcGljU2l6ZTtcbiAgICAgICAgY29uc3QgZXZlbnQgPSBkZWNvZGVyLmRlY29kZShidWZmZXIuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBldmVudFNpemUpKTtcbiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ICsgZXZlbnRTaXplO1xuICAgICAgICBjb25zdCBkYXRhID0gSlNPTi5wYXJzZShkZWNvZGVyLmRlY29kZShidWZmZXIuc2xpY2Uob2Zmc2V0LCBidWZmZXIuYnl0ZUxlbmd0aCkpKTtcbiAgICAgICAgcmV0dXJuIHsgcmVmOiBudWxsLCB0b3BpYzogdG9waWMsIGV2ZW50OiBldmVudCwgcGF5bG9hZDogZGF0YSB9O1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNlcmlhbGl6ZXIuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/realtime-js/dist/module/lib/serializer.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/realtime-js/dist/module/lib/timer.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@supabase/realtime-js/dist/module/lib/timer.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Timer)\n/* harmony export */ });\n/**\n * Creates a timer that accepts a `timerCalc` function to perform calculated timeout retries, such as exponential backoff.\n *\n * @example\n *    let reconnectTimer = new Timer(() => this.connect(), function(tries){\n *      return [1000, 5000, 10000][tries - 1] || 10000\n *    })\n *    reconnectTimer.scheduleTimeout() // fires after 1000\n *    reconnectTimer.scheduleTimeout() // fires after 5000\n *    reconnectTimer.reset()\n *    reconnectTimer.scheduleTimeout() // fires after 1000\n */\nclass Timer {\n    constructor(callback, timerCalc) {\n        this.callback = callback;\n        this.timerCalc = timerCalc;\n        this.timer = undefined;\n        this.tries = 0;\n        this.callback = callback;\n        this.timerCalc = timerCalc;\n    }\n    reset() {\n        this.tries = 0;\n        clearTimeout(this.timer);\n        this.timer = undefined;\n    }\n    // Cancels any previous scheduleTimeout and schedules callback\n    scheduleTimeout() {\n        clearTimeout(this.timer);\n        this.timer = setTimeout(() => {\n            this.tries = this.tries + 1;\n            this.callback();\n        }, this.timerCalc(this.tries + 1));\n    }\n}\n//# sourceMappingURL=timer.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcmVhbHRpbWUtanMvZGlzdC9tb2R1bGUvbGliL3RpbWVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBIiwic291cmNlcyI6WyJEOlxcbmV4dFxcb3JnXFxub2RlX21vZHVsZXNcXEBzdXBhYmFzZVxccmVhbHRpbWUtanNcXGRpc3RcXG1vZHVsZVxcbGliXFx0aW1lci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENyZWF0ZXMgYSB0aW1lciB0aGF0IGFjY2VwdHMgYSBgdGltZXJDYWxjYCBmdW5jdGlvbiB0byBwZXJmb3JtIGNhbGN1bGF0ZWQgdGltZW91dCByZXRyaWVzLCBzdWNoIGFzIGV4cG9uZW50aWFsIGJhY2tvZmYuXG4gKlxuICogQGV4YW1wbGVcbiAqICAgIGxldCByZWNvbm5lY3RUaW1lciA9IG5ldyBUaW1lcigoKSA9PiB0aGlzLmNvbm5lY3QoKSwgZnVuY3Rpb24odHJpZXMpe1xuICogICAgICByZXR1cm4gWzEwMDAsIDUwMDAsIDEwMDAwXVt0cmllcyAtIDFdIHx8IDEwMDAwXG4gKiAgICB9KVxuICogICAgcmVjb25uZWN0VGltZXIuc2NoZWR1bGVUaW1lb3V0KCkgLy8gZmlyZXMgYWZ0ZXIgMTAwMFxuICogICAgcmVjb25uZWN0VGltZXIuc2NoZWR1bGVUaW1lb3V0KCkgLy8gZmlyZXMgYWZ0ZXIgNTAwMFxuICogICAgcmVjb25uZWN0VGltZXIucmVzZXQoKVxuICogICAgcmVjb25uZWN0VGltZXIuc2NoZWR1bGVUaW1lb3V0KCkgLy8gZmlyZXMgYWZ0ZXIgMTAwMFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUaW1lciB7XG4gICAgY29uc3RydWN0b3IoY2FsbGJhY2ssIHRpbWVyQ2FsYykge1xuICAgICAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICAgIHRoaXMudGltZXJDYWxjID0gdGltZXJDYWxjO1xuICAgICAgICB0aGlzLnRpbWVyID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnRyaWVzID0gMDtcbiAgICAgICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgICB0aGlzLnRpbWVyQ2FsYyA9IHRpbWVyQ2FsYztcbiAgICB9XG4gICAgcmVzZXQoKSB7XG4gICAgICAgIHRoaXMudHJpZXMgPSAwO1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lcik7XG4gICAgICAgIHRoaXMudGltZXIgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8vIENhbmNlbHMgYW55IHByZXZpb3VzIHNjaGVkdWxlVGltZW91dCBhbmQgc2NoZWR1bGVzIGNhbGxiYWNrXG4gICAgc2NoZWR1bGVUaW1lb3V0KCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lcik7XG4gICAgICAgIHRoaXMudGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMudHJpZXMgPSB0aGlzLnRyaWVzICsgMTtcbiAgICAgICAgICAgIHRoaXMuY2FsbGJhY2soKTtcbiAgICAgICAgfSwgdGhpcy50aW1lckNhbGModGhpcy50cmllcyArIDEpKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD10aW1lci5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/realtime-js/dist/module/lib/timer.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/realtime-js/dist/module/lib/transformers.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@supabase/realtime-js/dist/module/lib/transformers.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PostgresTypes: () => (/* binding */ PostgresTypes),\n/* harmony export */   convertCell: () => (/* binding */ convertCell),\n/* harmony export */   convertChangeData: () => (/* binding */ convertChangeData),\n/* harmony export */   convertColumn: () => (/* binding */ convertColumn),\n/* harmony export */   httpEndpointURL: () => (/* binding */ httpEndpointURL),\n/* harmony export */   toArray: () => (/* binding */ toArray),\n/* harmony export */   toBoolean: () => (/* binding */ toBoolean),\n/* harmony export */   toJson: () => (/* binding */ toJson),\n/* harmony export */   toNumber: () => (/* binding */ toNumber),\n/* harmony export */   toTimestampString: () => (/* binding */ toTimestampString)\n/* harmony export */ });\n/**\n * Helpers to convert the change Payload into native JS types.\n */\n// Adapted from epgsql (src/epgsql_binary.erl), this module licensed under\n// 3-clause BSD found here: https://raw.githubusercontent.com/epgsql/epgsql/devel/LICENSE\nvar PostgresTypes;\n(function (PostgresTypes) {\n    PostgresTypes[\"abstime\"] = \"abstime\";\n    PostgresTypes[\"bool\"] = \"bool\";\n    PostgresTypes[\"date\"] = \"date\";\n    PostgresTypes[\"daterange\"] = \"daterange\";\n    PostgresTypes[\"float4\"] = \"float4\";\n    PostgresTypes[\"float8\"] = \"float8\";\n    PostgresTypes[\"int2\"] = \"int2\";\n    PostgresTypes[\"int4\"] = \"int4\";\n    PostgresTypes[\"int4range\"] = \"int4range\";\n    PostgresTypes[\"int8\"] = \"int8\";\n    PostgresTypes[\"int8range\"] = \"int8range\";\n    PostgresTypes[\"json\"] = \"json\";\n    PostgresTypes[\"jsonb\"] = \"jsonb\";\n    PostgresTypes[\"money\"] = \"money\";\n    PostgresTypes[\"numeric\"] = \"numeric\";\n    PostgresTypes[\"oid\"] = \"oid\";\n    PostgresTypes[\"reltime\"] = \"reltime\";\n    PostgresTypes[\"text\"] = \"text\";\n    PostgresTypes[\"time\"] = \"time\";\n    PostgresTypes[\"timestamp\"] = \"timestamp\";\n    PostgresTypes[\"timestamptz\"] = \"timestamptz\";\n    PostgresTypes[\"timetz\"] = \"timetz\";\n    PostgresTypes[\"tsrange\"] = \"tsrange\";\n    PostgresTypes[\"tstzrange\"] = \"tstzrange\";\n})(PostgresTypes || (PostgresTypes = {}));\n/**\n * Takes an array of columns and an object of string values then converts each string value\n * to its mapped type.\n *\n * @param {{name: String, type: String}[]} columns\n * @param {Object} record\n * @param {Object} options The map of various options that can be applied to the mapper\n * @param {Array} options.skipTypes The array of types that should not be converted\n *\n * @example convertChangeData([{name: 'first_name', type: 'text'}, {name: 'age', type: 'int4'}], {first_name: 'Paul', age:'33'}, {})\n * //=>{ first_name: 'Paul', age: 33 }\n */\nconst convertChangeData = (columns, record, options = {}) => {\n    var _a;\n    const skipTypes = (_a = options.skipTypes) !== null && _a !== void 0 ? _a : [];\n    if (!record) {\n        return {};\n    }\n    return Object.keys(record).reduce((acc, rec_key) => {\n        acc[rec_key] = convertColumn(rec_key, columns, record, skipTypes);\n        return acc;\n    }, {});\n};\n/**\n * Converts the value of an individual column.\n *\n * @param {String} columnName The column that you want to convert\n * @param {{name: String, type: String}[]} columns All of the columns\n * @param {Object} record The map of string values\n * @param {Array} skipTypes An array of types that should not be converted\n * @return {object} Useless information\n *\n * @example convertColumn('age', [{name: 'first_name', type: 'text'}, {name: 'age', type: 'int4'}], {first_name: 'Paul', age: '33'}, [])\n * //=> 33\n * @example convertColumn('age', [{name: 'first_name', type: 'text'}, {name: 'age', type: 'int4'}], {first_name: 'Paul', age: '33'}, ['int4'])\n * //=> \"33\"\n */\nconst convertColumn = (columnName, columns, record, skipTypes) => {\n    const column = columns.find((x) => x.name === columnName);\n    const colType = column === null || column === void 0 ? void 0 : column.type;\n    const value = record[columnName];\n    if (colType && !skipTypes.includes(colType)) {\n        return convertCell(colType, value);\n    }\n    return noop(value);\n};\n/**\n * If the value of the cell is `null`, returns null.\n * Otherwise converts the string value to the correct type.\n * @param {String} type A postgres column type\n * @param {String} value The cell value\n *\n * @example convertCell('bool', 't')\n * //=> true\n * @example convertCell('int8', '10')\n * //=> 10\n * @example convertCell('_int4', '{1,2,3,4}')\n * //=> [1,2,3,4]\n */\nconst convertCell = (type, value) => {\n    // if data type is an array\n    if (type.charAt(0) === '_') {\n        const dataType = type.slice(1, type.length);\n        return toArray(value, dataType);\n    }\n    // If not null, convert to correct type.\n    switch (type) {\n        case PostgresTypes.bool:\n            return toBoolean(value);\n        case PostgresTypes.float4:\n        case PostgresTypes.float8:\n        case PostgresTypes.int2:\n        case PostgresTypes.int4:\n        case PostgresTypes.int8:\n        case PostgresTypes.numeric:\n        case PostgresTypes.oid:\n            return toNumber(value);\n        case PostgresTypes.json:\n        case PostgresTypes.jsonb:\n            return toJson(value);\n        case PostgresTypes.timestamp:\n            return toTimestampString(value); // Format to be consistent with PostgREST\n        case PostgresTypes.abstime: // To allow users to cast it based on Timezone\n        case PostgresTypes.date: // To allow users to cast it based on Timezone\n        case PostgresTypes.daterange:\n        case PostgresTypes.int4range:\n        case PostgresTypes.int8range:\n        case PostgresTypes.money:\n        case PostgresTypes.reltime: // To allow users to cast it based on Timezone\n        case PostgresTypes.text:\n        case PostgresTypes.time: // To allow users to cast it based on Timezone\n        case PostgresTypes.timestamptz: // To allow users to cast it based on Timezone\n        case PostgresTypes.timetz: // To allow users to cast it based on Timezone\n        case PostgresTypes.tsrange:\n        case PostgresTypes.tstzrange:\n            return noop(value);\n        default:\n            // Return the value for remaining types\n            return noop(value);\n    }\n};\nconst noop = (value) => {\n    return value;\n};\nconst toBoolean = (value) => {\n    switch (value) {\n        case 't':\n            return true;\n        case 'f':\n            return false;\n        default:\n            return value;\n    }\n};\nconst toNumber = (value) => {\n    if (typeof value === 'string') {\n        const parsedValue = parseFloat(value);\n        if (!Number.isNaN(parsedValue)) {\n            return parsedValue;\n        }\n    }\n    return value;\n};\nconst toJson = (value) => {\n    if (typeof value === 'string') {\n        try {\n            return JSON.parse(value);\n        }\n        catch (error) {\n            console.log(`JSON parse error: ${error}`);\n            return value;\n        }\n    }\n    return value;\n};\n/**\n * Converts a Postgres Array into a native JS array\n *\n * @example toArray('{}', 'int4')\n * //=> []\n * @example toArray('{\"[2021-01-01,2021-12-31)\",\"(2021-01-01,2021-12-32]\"}', 'daterange')\n * //=> ['[2021-01-01,2021-12-31)', '(2021-01-01,2021-12-32]']\n * @example toArray([1,2,3,4], 'int4')\n * //=> [1,2,3,4]\n */\nconst toArray = (value, type) => {\n    if (typeof value !== 'string') {\n        return value;\n    }\n    const lastIdx = value.length - 1;\n    const closeBrace = value[lastIdx];\n    const openBrace = value[0];\n    // Confirm value is a Postgres array by checking curly brackets\n    if (openBrace === '{' && closeBrace === '}') {\n        let arr;\n        const valTrim = value.slice(1, lastIdx);\n        // TODO: find a better solution to separate Postgres array data\n        try {\n            arr = JSON.parse('[' + valTrim + ']');\n        }\n        catch (_) {\n            // WARNING: splitting on comma does not cover all edge cases\n            arr = valTrim ? valTrim.split(',') : [];\n        }\n        return arr.map((val) => convertCell(type, val));\n    }\n    return value;\n};\n/**\n * Fixes timestamp to be ISO-8601. Swaps the space between the date and time for a 'T'\n * See https://github.com/supabase/supabase/issues/18\n *\n * @example toTimestampString('2019-09-10 00:00:00')\n * //=> '2019-09-10T00:00:00'\n */\nconst toTimestampString = (value) => {\n    if (typeof value === 'string') {\n        return value.replace(' ', 'T');\n    }\n    return value;\n};\nconst httpEndpointURL = (socketUrl) => {\n    let url = socketUrl;\n    url = url.replace(/^ws/i, 'http');\n    url = url.replace(/(\\/socket\\/websocket|\\/socket|\\/websocket)\\/?$/i, '');\n    return url.replace(/\\/+$/, '') + '/api/broadcast';\n};\n//# sourceMappingURL=transformers.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcmVhbHRpbWUtanMvZGlzdC9tb2R1bGUvbGliL3RyYW5zZm9ybWVycy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHNDQUFzQztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksMkJBQTJCLElBQUk7QUFDM0MsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLE9BQU87QUFDbEI7QUFDQSxnQ0FBZ0MsaUNBQWlDLEdBQUcsMEJBQTBCLElBQUksNkJBQTZCLElBQUk7QUFDbkksU0FBUztBQUNUO0FBQ08sd0RBQXdEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLElBQUk7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLDJCQUEyQixJQUFJO0FBQzNDLFdBQVcsUUFBUTtBQUNuQixXQUFXLE9BQU87QUFDbEIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0EsbUNBQW1DLGlDQUFpQyxHQUFHLDBCQUEwQixJQUFJLDhCQUE4QjtBQUNuSTtBQUNBLG1DQUFtQyxpQ0FBaUMsR0FBRywwQkFBMEIsSUFBSSw4QkFBOEI7QUFDbkk7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxRQUFRO0FBQzNDO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLE1BQU07QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBLHNCQUFzQixvREFBb0Q7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHNCQUFzQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiRDpcXG5leHRcXG9yZ1xcbm9kZV9tb2R1bGVzXFxAc3VwYWJhc2VcXHJlYWx0aW1lLWpzXFxkaXN0XFxtb2R1bGVcXGxpYlxcdHJhbnNmb3JtZXJzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogSGVscGVycyB0byBjb252ZXJ0IHRoZSBjaGFuZ2UgUGF5bG9hZCBpbnRvIG5hdGl2ZSBKUyB0eXBlcy5cbiAqL1xuLy8gQWRhcHRlZCBmcm9tIGVwZ3NxbCAoc3JjL2VwZ3NxbF9iaW5hcnkuZXJsKSwgdGhpcyBtb2R1bGUgbGljZW5zZWQgdW5kZXJcbi8vIDMtY2xhdXNlIEJTRCBmb3VuZCBoZXJlOiBodHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vZXBnc3FsL2VwZ3NxbC9kZXZlbC9MSUNFTlNFXG5leHBvcnQgdmFyIFBvc3RncmVzVHlwZXM7XG4oZnVuY3Rpb24gKFBvc3RncmVzVHlwZXMpIHtcbiAgICBQb3N0Z3Jlc1R5cGVzW1wiYWJzdGltZVwiXSA9IFwiYWJzdGltZVwiO1xuICAgIFBvc3RncmVzVHlwZXNbXCJib29sXCJdID0gXCJib29sXCI7XG4gICAgUG9zdGdyZXNUeXBlc1tcImRhdGVcIl0gPSBcImRhdGVcIjtcbiAgICBQb3N0Z3Jlc1R5cGVzW1wiZGF0ZXJhbmdlXCJdID0gXCJkYXRlcmFuZ2VcIjtcbiAgICBQb3N0Z3Jlc1R5cGVzW1wiZmxvYXQ0XCJdID0gXCJmbG9hdDRcIjtcbiAgICBQb3N0Z3Jlc1R5cGVzW1wiZmxvYXQ4XCJdID0gXCJmbG9hdDhcIjtcbiAgICBQb3N0Z3Jlc1R5cGVzW1wiaW50MlwiXSA9IFwiaW50MlwiO1xuICAgIFBvc3RncmVzVHlwZXNbXCJpbnQ0XCJdID0gXCJpbnQ0XCI7XG4gICAgUG9zdGdyZXNUeXBlc1tcImludDRyYW5nZVwiXSA9IFwiaW50NHJhbmdlXCI7XG4gICAgUG9zdGdyZXNUeXBlc1tcImludDhcIl0gPSBcImludDhcIjtcbiAgICBQb3N0Z3Jlc1R5cGVzW1wiaW50OHJhbmdlXCJdID0gXCJpbnQ4cmFuZ2VcIjtcbiAgICBQb3N0Z3Jlc1R5cGVzW1wianNvblwiXSA9IFwianNvblwiO1xuICAgIFBvc3RncmVzVHlwZXNbXCJqc29uYlwiXSA9IFwianNvbmJcIjtcbiAgICBQb3N0Z3Jlc1R5cGVzW1wibW9uZXlcIl0gPSBcIm1vbmV5XCI7XG4gICAgUG9zdGdyZXNUeXBlc1tcIm51bWVyaWNcIl0gPSBcIm51bWVyaWNcIjtcbiAgICBQb3N0Z3Jlc1R5cGVzW1wib2lkXCJdID0gXCJvaWRcIjtcbiAgICBQb3N0Z3Jlc1R5cGVzW1wicmVsdGltZVwiXSA9IFwicmVsdGltZVwiO1xuICAgIFBvc3RncmVzVHlwZXNbXCJ0ZXh0XCJdID0gXCJ0ZXh0XCI7XG4gICAgUG9zdGdyZXNUeXBlc1tcInRpbWVcIl0gPSBcInRpbWVcIjtcbiAgICBQb3N0Z3Jlc1R5cGVzW1widGltZXN0YW1wXCJdID0gXCJ0aW1lc3RhbXBcIjtcbiAgICBQb3N0Z3Jlc1R5cGVzW1widGltZXN0YW1wdHpcIl0gPSBcInRpbWVzdGFtcHR6XCI7XG4gICAgUG9zdGdyZXNUeXBlc1tcInRpbWV0elwiXSA9IFwidGltZXR6XCI7XG4gICAgUG9zdGdyZXNUeXBlc1tcInRzcmFuZ2VcIl0gPSBcInRzcmFuZ2VcIjtcbiAgICBQb3N0Z3Jlc1R5cGVzW1widHN0enJhbmdlXCJdID0gXCJ0c3R6cmFuZ2VcIjtcbn0pKFBvc3RncmVzVHlwZXMgfHwgKFBvc3RncmVzVHlwZXMgPSB7fSkpO1xuLyoqXG4gKiBUYWtlcyBhbiBhcnJheSBvZiBjb2x1bW5zIGFuZCBhbiBvYmplY3Qgb2Ygc3RyaW5nIHZhbHVlcyB0aGVuIGNvbnZlcnRzIGVhY2ggc3RyaW5nIHZhbHVlXG4gKiB0byBpdHMgbWFwcGVkIHR5cGUuXG4gKlxuICogQHBhcmFtIHt7bmFtZTogU3RyaW5nLCB0eXBlOiBTdHJpbmd9W119IGNvbHVtbnNcbiAqIEBwYXJhbSB7T2JqZWN0fSByZWNvcmRcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIFRoZSBtYXAgb2YgdmFyaW91cyBvcHRpb25zIHRoYXQgY2FuIGJlIGFwcGxpZWQgdG8gdGhlIG1hcHBlclxuICogQHBhcmFtIHtBcnJheX0gb3B0aW9ucy5za2lwVHlwZXMgVGhlIGFycmF5IG9mIHR5cGVzIHRoYXQgc2hvdWxkIG5vdCBiZSBjb252ZXJ0ZWRcbiAqXG4gKiBAZXhhbXBsZSBjb252ZXJ0Q2hhbmdlRGF0YShbe25hbWU6ICdmaXJzdF9uYW1lJywgdHlwZTogJ3RleHQnfSwge25hbWU6ICdhZ2UnLCB0eXBlOiAnaW50NCd9XSwge2ZpcnN0X25hbWU6ICdQYXVsJywgYWdlOiczMyd9LCB7fSlcbiAqIC8vPT57IGZpcnN0X25hbWU6ICdQYXVsJywgYWdlOiAzMyB9XG4gKi9cbmV4cG9ydCBjb25zdCBjb252ZXJ0Q2hhbmdlRGF0YSA9IChjb2x1bW5zLCByZWNvcmQsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBza2lwVHlwZXMgPSAoX2EgPSBvcHRpb25zLnNraXBUeXBlcykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW107XG4gICAgaWYgKCFyZWNvcmQpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmtleXMocmVjb3JkKS5yZWR1Y2UoKGFjYywgcmVjX2tleSkgPT4ge1xuICAgICAgICBhY2NbcmVjX2tleV0gPSBjb252ZXJ0Q29sdW1uKHJlY19rZXksIGNvbHVtbnMsIHJlY29yZCwgc2tpcFR5cGVzKTtcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCB7fSk7XG59O1xuLyoqXG4gKiBDb252ZXJ0cyB0aGUgdmFsdWUgb2YgYW4gaW5kaXZpZHVhbCBjb2x1bW4uXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGNvbHVtbk5hbWUgVGhlIGNvbHVtbiB0aGF0IHlvdSB3YW50IHRvIGNvbnZlcnRcbiAqIEBwYXJhbSB7e25hbWU6IFN0cmluZywgdHlwZTogU3RyaW5nfVtdfSBjb2x1bW5zIEFsbCBvZiB0aGUgY29sdW1uc1xuICogQHBhcmFtIHtPYmplY3R9IHJlY29yZCBUaGUgbWFwIG9mIHN0cmluZyB2YWx1ZXNcbiAqIEBwYXJhbSB7QXJyYXl9IHNraXBUeXBlcyBBbiBhcnJheSBvZiB0eXBlcyB0aGF0IHNob3VsZCBub3QgYmUgY29udmVydGVkXG4gKiBAcmV0dXJuIHtvYmplY3R9IFVzZWxlc3MgaW5mb3JtYXRpb25cbiAqXG4gKiBAZXhhbXBsZSBjb252ZXJ0Q29sdW1uKCdhZ2UnLCBbe25hbWU6ICdmaXJzdF9uYW1lJywgdHlwZTogJ3RleHQnfSwge25hbWU6ICdhZ2UnLCB0eXBlOiAnaW50NCd9XSwge2ZpcnN0X25hbWU6ICdQYXVsJywgYWdlOiAnMzMnfSwgW10pXG4gKiAvLz0+IDMzXG4gKiBAZXhhbXBsZSBjb252ZXJ0Q29sdW1uKCdhZ2UnLCBbe25hbWU6ICdmaXJzdF9uYW1lJywgdHlwZTogJ3RleHQnfSwge25hbWU6ICdhZ2UnLCB0eXBlOiAnaW50NCd9XSwge2ZpcnN0X25hbWU6ICdQYXVsJywgYWdlOiAnMzMnfSwgWydpbnQ0J10pXG4gKiAvLz0+IFwiMzNcIlxuICovXG5leHBvcnQgY29uc3QgY29udmVydENvbHVtbiA9IChjb2x1bW5OYW1lLCBjb2x1bW5zLCByZWNvcmQsIHNraXBUeXBlcykgPT4ge1xuICAgIGNvbnN0IGNvbHVtbiA9IGNvbHVtbnMuZmluZCgoeCkgPT4geC5uYW1lID09PSBjb2x1bW5OYW1lKTtcbiAgICBjb25zdCBjb2xUeXBlID0gY29sdW1uID09PSBudWxsIHx8IGNvbHVtbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29sdW1uLnR5cGU7XG4gICAgY29uc3QgdmFsdWUgPSByZWNvcmRbY29sdW1uTmFtZV07XG4gICAgaWYgKGNvbFR5cGUgJiYgIXNraXBUeXBlcy5pbmNsdWRlcyhjb2xUeXBlKSkge1xuICAgICAgICByZXR1cm4gY29udmVydENlbGwoY29sVHlwZSwgdmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gbm9vcCh2YWx1ZSk7XG59O1xuLyoqXG4gKiBJZiB0aGUgdmFsdWUgb2YgdGhlIGNlbGwgaXMgYG51bGxgLCByZXR1cm5zIG51bGwuXG4gKiBPdGhlcndpc2UgY29udmVydHMgdGhlIHN0cmluZyB2YWx1ZSB0byB0aGUgY29ycmVjdCB0eXBlLlxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgQSBwb3N0Z3JlcyBjb2x1bW4gdHlwZVxuICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlIFRoZSBjZWxsIHZhbHVlXG4gKlxuICogQGV4YW1wbGUgY29udmVydENlbGwoJ2Jvb2wnLCAndCcpXG4gKiAvLz0+IHRydWVcbiAqIEBleGFtcGxlIGNvbnZlcnRDZWxsKCdpbnQ4JywgJzEwJylcbiAqIC8vPT4gMTBcbiAqIEBleGFtcGxlIGNvbnZlcnRDZWxsKCdfaW50NCcsICd7MSwyLDMsNH0nKVxuICogLy89PiBbMSwyLDMsNF1cbiAqL1xuZXhwb3J0IGNvbnN0IGNvbnZlcnRDZWxsID0gKHR5cGUsIHZhbHVlKSA9PiB7XG4gICAgLy8gaWYgZGF0YSB0eXBlIGlzIGFuIGFycmF5XG4gICAgaWYgKHR5cGUuY2hhckF0KDApID09PSAnXycpIHtcbiAgICAgICAgY29uc3QgZGF0YVR5cGUgPSB0eXBlLnNsaWNlKDEsIHR5cGUubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIHRvQXJyYXkodmFsdWUsIGRhdGFUeXBlKTtcbiAgICB9XG4gICAgLy8gSWYgbm90IG51bGwsIGNvbnZlcnQgdG8gY29ycmVjdCB0eXBlLlxuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFBvc3RncmVzVHlwZXMuYm9vbDpcbiAgICAgICAgICAgIHJldHVybiB0b0Jvb2xlYW4odmFsdWUpO1xuICAgICAgICBjYXNlIFBvc3RncmVzVHlwZXMuZmxvYXQ0OlxuICAgICAgICBjYXNlIFBvc3RncmVzVHlwZXMuZmxvYXQ4OlxuICAgICAgICBjYXNlIFBvc3RncmVzVHlwZXMuaW50MjpcbiAgICAgICAgY2FzZSBQb3N0Z3Jlc1R5cGVzLmludDQ6XG4gICAgICAgIGNhc2UgUG9zdGdyZXNUeXBlcy5pbnQ4OlxuICAgICAgICBjYXNlIFBvc3RncmVzVHlwZXMubnVtZXJpYzpcbiAgICAgICAgY2FzZSBQb3N0Z3Jlc1R5cGVzLm9pZDpcbiAgICAgICAgICAgIHJldHVybiB0b051bWJlcih2YWx1ZSk7XG4gICAgICAgIGNhc2UgUG9zdGdyZXNUeXBlcy5qc29uOlxuICAgICAgICBjYXNlIFBvc3RncmVzVHlwZXMuanNvbmI6XG4gICAgICAgICAgICByZXR1cm4gdG9Kc29uKHZhbHVlKTtcbiAgICAgICAgY2FzZSBQb3N0Z3Jlc1R5cGVzLnRpbWVzdGFtcDpcbiAgICAgICAgICAgIHJldHVybiB0b1RpbWVzdGFtcFN0cmluZyh2YWx1ZSk7IC8vIEZvcm1hdCB0byBiZSBjb25zaXN0ZW50IHdpdGggUG9zdGdSRVNUXG4gICAgICAgIGNhc2UgUG9zdGdyZXNUeXBlcy5hYnN0aW1lOiAvLyBUbyBhbGxvdyB1c2VycyB0byBjYXN0IGl0IGJhc2VkIG9uIFRpbWV6b25lXG4gICAgICAgIGNhc2UgUG9zdGdyZXNUeXBlcy5kYXRlOiAvLyBUbyBhbGxvdyB1c2VycyB0byBjYXN0IGl0IGJhc2VkIG9uIFRpbWV6b25lXG4gICAgICAgIGNhc2UgUG9zdGdyZXNUeXBlcy5kYXRlcmFuZ2U6XG4gICAgICAgIGNhc2UgUG9zdGdyZXNUeXBlcy5pbnQ0cmFuZ2U6XG4gICAgICAgIGNhc2UgUG9zdGdyZXNUeXBlcy5pbnQ4cmFuZ2U6XG4gICAgICAgIGNhc2UgUG9zdGdyZXNUeXBlcy5tb25leTpcbiAgICAgICAgY2FzZSBQb3N0Z3Jlc1R5cGVzLnJlbHRpbWU6IC8vIFRvIGFsbG93IHVzZXJzIHRvIGNhc3QgaXQgYmFzZWQgb24gVGltZXpvbmVcbiAgICAgICAgY2FzZSBQb3N0Z3Jlc1R5cGVzLnRleHQ6XG4gICAgICAgIGNhc2UgUG9zdGdyZXNUeXBlcy50aW1lOiAvLyBUbyBhbGxvdyB1c2VycyB0byBjYXN0IGl0IGJhc2VkIG9uIFRpbWV6b25lXG4gICAgICAgIGNhc2UgUG9zdGdyZXNUeXBlcy50aW1lc3RhbXB0ejogLy8gVG8gYWxsb3cgdXNlcnMgdG8gY2FzdCBpdCBiYXNlZCBvbiBUaW1lem9uZVxuICAgICAgICBjYXNlIFBvc3RncmVzVHlwZXMudGltZXR6OiAvLyBUbyBhbGxvdyB1c2VycyB0byBjYXN0IGl0IGJhc2VkIG9uIFRpbWV6b25lXG4gICAgICAgIGNhc2UgUG9zdGdyZXNUeXBlcy50c3JhbmdlOlxuICAgICAgICBjYXNlIFBvc3RncmVzVHlwZXMudHN0enJhbmdlOlxuICAgICAgICAgICAgcmV0dXJuIG5vb3AodmFsdWUpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgLy8gUmV0dXJuIHRoZSB2YWx1ZSBmb3IgcmVtYWluaW5nIHR5cGVzXG4gICAgICAgICAgICByZXR1cm4gbm9vcCh2YWx1ZSk7XG4gICAgfVxufTtcbmNvbnN0IG5vb3AgPSAodmFsdWUpID0+IHtcbiAgICByZXR1cm4gdmFsdWU7XG59O1xuZXhwb3J0IGNvbnN0IHRvQm9vbGVhbiA9ICh2YWx1ZSkgPT4ge1xuICAgIHN3aXRjaCAodmFsdWUpIHtcbiAgICAgICAgY2FzZSAndCc6XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgY2FzZSAnZic6XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxufTtcbmV4cG9ydCBjb25zdCB0b051bWJlciA9ICh2YWx1ZSkgPT4ge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZFZhbHVlID0gcGFyc2VGbG9hdCh2YWx1ZSk7XG4gICAgICAgIGlmICghTnVtYmVyLmlzTmFOKHBhcnNlZFZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlZFZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn07XG5leHBvcnQgY29uc3QgdG9Kc29uID0gKHZhbHVlKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBKU09OLnBhcnNlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBKU09OIHBhcnNlIGVycm9yOiAke2Vycm9yfWApO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn07XG4vKipcbiAqIENvbnZlcnRzIGEgUG9zdGdyZXMgQXJyYXkgaW50byBhIG5hdGl2ZSBKUyBhcnJheVxuICpcbiAqIEBleGFtcGxlIHRvQXJyYXkoJ3t9JywgJ2ludDQnKVxuICogLy89PiBbXVxuICogQGV4YW1wbGUgdG9BcnJheSgne1wiWzIwMjEtMDEtMDEsMjAyMS0xMi0zMSlcIixcIigyMDIxLTAxLTAxLDIwMjEtMTItMzJdXCJ9JywgJ2RhdGVyYW5nZScpXG4gKiAvLz0+IFsnWzIwMjEtMDEtMDEsMjAyMS0xMi0zMSknLCAnKDIwMjEtMDEtMDEsMjAyMS0xMi0zMl0nXVxuICogQGV4YW1wbGUgdG9BcnJheShbMSwyLDMsNF0sICdpbnQ0JylcbiAqIC8vPT4gWzEsMiwzLDRdXG4gKi9cbmV4cG9ydCBjb25zdCB0b0FycmF5ID0gKHZhbHVlLCB0eXBlKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBjb25zdCBsYXN0SWR4ID0gdmFsdWUubGVuZ3RoIC0gMTtcbiAgICBjb25zdCBjbG9zZUJyYWNlID0gdmFsdWVbbGFzdElkeF07XG4gICAgY29uc3Qgb3BlbkJyYWNlID0gdmFsdWVbMF07XG4gICAgLy8gQ29uZmlybSB2YWx1ZSBpcyBhIFBvc3RncmVzIGFycmF5IGJ5IGNoZWNraW5nIGN1cmx5IGJyYWNrZXRzXG4gICAgaWYgKG9wZW5CcmFjZSA9PT0gJ3snICYmIGNsb3NlQnJhY2UgPT09ICd9Jykge1xuICAgICAgICBsZXQgYXJyO1xuICAgICAgICBjb25zdCB2YWxUcmltID0gdmFsdWUuc2xpY2UoMSwgbGFzdElkeCk7XG4gICAgICAgIC8vIFRPRE86IGZpbmQgYSBiZXR0ZXIgc29sdXRpb24gdG8gc2VwYXJhdGUgUG9zdGdyZXMgYXJyYXkgZGF0YVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXJyID0gSlNPTi5wYXJzZSgnWycgKyB2YWxUcmltICsgJ10nKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoXykge1xuICAgICAgICAgICAgLy8gV0FSTklORzogc3BsaXR0aW5nIG9uIGNvbW1hIGRvZXMgbm90IGNvdmVyIGFsbCBlZGdlIGNhc2VzXG4gICAgICAgICAgICBhcnIgPSB2YWxUcmltID8gdmFsVHJpbS5zcGxpdCgnLCcpIDogW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFyci5tYXAoKHZhbCkgPT4gY29udmVydENlbGwodHlwZSwgdmFsKSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn07XG4vKipcbiAqIEZpeGVzIHRpbWVzdGFtcCB0byBiZSBJU08tODYwMS4gU3dhcHMgdGhlIHNwYWNlIGJldHdlZW4gdGhlIGRhdGUgYW5kIHRpbWUgZm9yIGEgJ1QnXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3N1cGFiYXNlL3N1cGFiYXNlL2lzc3Vlcy8xOFxuICpcbiAqIEBleGFtcGxlIHRvVGltZXN0YW1wU3RyaW5nKCcyMDE5LTA5LTEwIDAwOjAwOjAwJylcbiAqIC8vPT4gJzIwMTktMDktMTBUMDA6MDA6MDAnXG4gKi9cbmV4cG9ydCBjb25zdCB0b1RpbWVzdGFtcFN0cmluZyA9ICh2YWx1ZSkgPT4ge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS5yZXBsYWNlKCcgJywgJ1QnKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufTtcbmV4cG9ydCBjb25zdCBodHRwRW5kcG9pbnRVUkwgPSAoc29ja2V0VXJsKSA9PiB7XG4gICAgbGV0IHVybCA9IHNvY2tldFVybDtcbiAgICB1cmwgPSB1cmwucmVwbGFjZSgvXndzL2ksICdodHRwJyk7XG4gICAgdXJsID0gdXJsLnJlcGxhY2UoLyhcXC9zb2NrZXRcXC93ZWJzb2NrZXR8XFwvc29ja2V0fFxcL3dlYnNvY2tldClcXC8/JC9pLCAnJyk7XG4gICAgcmV0dXJuIHVybC5yZXBsYWNlKC9cXC8rJC8sICcnKSArICcvYXBpL2Jyb2FkY2FzdCc7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHJhbnNmb3JtZXJzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/realtime-js/dist/module/lib/transformers.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/realtime-js/dist/module/lib/version.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@supabase/realtime-js/dist/module/lib/version.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\n// Generated automatically during releases by scripts/update-version-files.ts\n// This file provides runtime access to the package version for:\n// - HTTP request headers (e.g., X-Client-Info header for API requests)\n// - Debugging and support (identifying which version is running)\n// - Telemetry and logging (version reporting in errors/analytics)\n// - Ensuring build artifacts match the published package version\nconst version = '2.74.0';\n//# sourceMappingURL=version.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcmVhbHRpbWUtanMvZGlzdC9tb2R1bGUvbGliL3ZlcnNpb24uanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AiLCJzb3VyY2VzIjpbIkQ6XFxuZXh0XFxvcmdcXG5vZGVfbW9kdWxlc1xcQHN1cGFiYXNlXFxyZWFsdGltZS1qc1xcZGlzdFxcbW9kdWxlXFxsaWJcXHZlcnNpb24uanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gR2VuZXJhdGVkIGF1dG9tYXRpY2FsbHkgZHVyaW5nIHJlbGVhc2VzIGJ5IHNjcmlwdHMvdXBkYXRlLXZlcnNpb24tZmlsZXMudHNcbi8vIFRoaXMgZmlsZSBwcm92aWRlcyBydW50aW1lIGFjY2VzcyB0byB0aGUgcGFja2FnZSB2ZXJzaW9uIGZvcjpcbi8vIC0gSFRUUCByZXF1ZXN0IGhlYWRlcnMgKGUuZy4sIFgtQ2xpZW50LUluZm8gaGVhZGVyIGZvciBBUEkgcmVxdWVzdHMpXG4vLyAtIERlYnVnZ2luZyBhbmQgc3VwcG9ydCAoaWRlbnRpZnlpbmcgd2hpY2ggdmVyc2lvbiBpcyBydW5uaW5nKVxuLy8gLSBUZWxlbWV0cnkgYW5kIGxvZ2dpbmcgKHZlcnNpb24gcmVwb3J0aW5nIGluIGVycm9ycy9hbmFseXRpY3MpXG4vLyAtIEVuc3VyaW5nIGJ1aWxkIGFydGlmYWN0cyBtYXRjaCB0aGUgcHVibGlzaGVkIHBhY2thZ2UgdmVyc2lvblxuZXhwb3J0IGNvbnN0IHZlcnNpb24gPSAnMi43NC4wJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZlcnNpb24uanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/realtime-js/dist/module/lib/version.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/realtime-js/dist/module/lib/websocket-factory.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@supabase/realtime-js/dist/module/lib/websocket-factory.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WebSocketFactory: () => (/* binding */ WebSocketFactory),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\nclass WebSocketFactory {\n    static detectEnvironment() {\n        var _a;\n        if (typeof WebSocket !== 'undefined') {\n            return { type: 'native', constructor: WebSocket };\n        }\n        if (typeof globalThis !== 'undefined' && typeof globalThis.WebSocket !== 'undefined') {\n            return { type: 'native', constructor: globalThis.WebSocket };\n        }\n        if (typeof __webpack_require__.g !== 'undefined' && typeof __webpack_require__.g.WebSocket !== 'undefined') {\n            return { type: 'native', constructor: __webpack_require__.g.WebSocket };\n        }\n        if (typeof globalThis !== 'undefined' &&\n            typeof globalThis.WebSocketPair !== 'undefined' &&\n            typeof globalThis.WebSocket === 'undefined') {\n            return {\n                type: 'cloudflare',\n                error: 'Cloudflare Workers detected. WebSocket clients are not supported in Cloudflare Workers.',\n                workaround: 'Use Cloudflare Workers WebSocket API for server-side WebSocket handling, or deploy to a different runtime.',\n            };\n        }\n        if ((typeof globalThis !== 'undefined' && globalThis.EdgeRuntime) ||\n            (typeof navigator !== 'undefined' && ((_a = navigator.userAgent) === null || _a === void 0 ? void 0 : _a.includes('Vercel-Edge')))) {\n            return {\n                type: 'unsupported',\n                error: 'Edge runtime detected (Vercel Edge/Netlify Edge). WebSockets are not supported in edge functions.',\n                workaround: 'Use serverless functions or a different deployment target for WebSocket functionality.',\n            };\n        }\n        if (typeof process !== 'undefined') {\n            // Use dynamic property access to avoid Next.js Edge Runtime static analysis warnings\n            const processVersions = process['versions'];\n            if (processVersions && processVersions['node']) {\n                // Remove 'v' prefix if present and parse the major version\n                const versionString = processVersions['node'];\n                const nodeVersion = parseInt(versionString.replace(/^v/, '').split('.')[0]);\n                // Node.js 22+ should have native WebSocket\n                if (nodeVersion >= 22) {\n                    // Check if native WebSocket is available (should be in Node.js 22+)\n                    if (typeof globalThis.WebSocket !== 'undefined') {\n                        return { type: 'native', constructor: globalThis.WebSocket };\n                    }\n                    // If not available, user needs to provide it\n                    return {\n                        type: 'unsupported',\n                        error: `Node.js ${nodeVersion} detected but native WebSocket not found.`,\n                        workaround: 'Provide a WebSocket implementation via the transport option.',\n                    };\n                }\n                // Node.js < 22 doesn't have native WebSocket\n                return {\n                    type: 'unsupported',\n                    error: `Node.js ${nodeVersion} detected without native WebSocket support.`,\n                    workaround: 'For Node.js < 22, install \"ws\" package and provide it via the transport option:\\n' +\n                        'import ws from \"ws\"\\n' +\n                        'new RealtimeClient(url, { transport: ws })',\n                };\n            }\n        }\n        return {\n            type: 'unsupported',\n            error: 'Unknown JavaScript runtime without WebSocket support.',\n            workaround: \"Ensure you're running in a supported environment (browser, Node.js, Deno) or provide a custom WebSocket implementation.\",\n        };\n    }\n    static getWebSocketConstructor() {\n        const env = this.detectEnvironment();\n        if (env.constructor) {\n            return env.constructor;\n        }\n        let errorMessage = env.error || 'WebSocket not supported in this environment.';\n        if (env.workaround) {\n            errorMessage += `\\n\\nSuggested solution: ${env.workaround}`;\n        }\n        throw new Error(errorMessage);\n    }\n    static createWebSocket(url, protocols) {\n        const WS = this.getWebSocketConstructor();\n        return new WS(url, protocols);\n    }\n    static isWebSocketSupported() {\n        try {\n            const env = this.detectEnvironment();\n            return env.type === 'native' || env.type === 'ws';\n        }\n        catch (_a) {\n            return false;\n        }\n    }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (WebSocketFactory);\n//# sourceMappingURL=websocket-factory.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcmVhbHRpbWUtanMvZGlzdC9tb2R1bGUvbGliL3dlYnNvY2tldC1mYWN0b3J5LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxtQkFBbUIscUJBQU0sMkJBQTJCLHFCQUFNO0FBQzFELHFCQUFxQiw2QkFBNkIscUJBQU07QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUI7QUFDQSxvQ0FBb0MsT0FBTztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLGFBQWE7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGFBQWE7QUFDbkQ7QUFDQTtBQUNBLG1EQUFtRCxlQUFlO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELGVBQWU7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFlLGdCQUFnQixFQUFDO0FBQ2hDIiwic291cmNlcyI6WyJEOlxcbmV4dFxcb3JnXFxub2RlX21vZHVsZXNcXEBzdXBhYmFzZVxccmVhbHRpbWUtanNcXGRpc3RcXG1vZHVsZVxcbGliXFx3ZWJzb2NrZXQtZmFjdG9yeS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY2xhc3MgV2ViU29ja2V0RmFjdG9yeSB7XG4gICAgc3RhdGljIGRldGVjdEVudmlyb25tZW50KCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICh0eXBlb2YgV2ViU29ja2V0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogJ25hdGl2ZScsIGNvbnN0cnVjdG9yOiBXZWJTb2NrZXQgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBnbG9iYWxUaGlzLldlYlNvY2tldCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHR5cGU6ICduYXRpdmUnLCBjb25zdHJ1Y3RvcjogZ2xvYmFsVGhpcy5XZWJTb2NrZXQgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGdsb2JhbC5XZWJTb2NrZXQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4geyB0eXBlOiAnbmF0aXZlJywgY29uc3RydWN0b3I6IGdsb2JhbC5XZWJTb2NrZXQgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICB0eXBlb2YgZ2xvYmFsVGhpcy5XZWJTb2NrZXRQYWlyICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgdHlwZW9mIGdsb2JhbFRoaXMuV2ViU29ja2V0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnY2xvdWRmbGFyZScsXG4gICAgICAgICAgICAgICAgZXJyb3I6ICdDbG91ZGZsYXJlIFdvcmtlcnMgZGV0ZWN0ZWQuIFdlYlNvY2tldCBjbGllbnRzIGFyZSBub3Qgc3VwcG9ydGVkIGluIENsb3VkZmxhcmUgV29ya2Vycy4nLFxuICAgICAgICAgICAgICAgIHdvcmthcm91bmQ6ICdVc2UgQ2xvdWRmbGFyZSBXb3JrZXJzIFdlYlNvY2tldCBBUEkgZm9yIHNlcnZlci1zaWRlIFdlYlNvY2tldCBoYW5kbGluZywgb3IgZGVwbG95IHRvIGEgZGlmZmVyZW50IHJ1bnRpbWUuJyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCh0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgJiYgZ2xvYmFsVGhpcy5FZGdlUnVudGltZSkgfHxcbiAgICAgICAgICAgICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiAoKF9hID0gbmF2aWdhdG9yLnVzZXJBZ2VudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmluY2x1ZGVzKCdWZXJjZWwtRWRnZScpKSkpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3Vuc3VwcG9ydGVkJyxcbiAgICAgICAgICAgICAgICBlcnJvcjogJ0VkZ2UgcnVudGltZSBkZXRlY3RlZCAoVmVyY2VsIEVkZ2UvTmV0bGlmeSBFZGdlKS4gV2ViU29ja2V0cyBhcmUgbm90IHN1cHBvcnRlZCBpbiBlZGdlIGZ1bmN0aW9ucy4nLFxuICAgICAgICAgICAgICAgIHdvcmthcm91bmQ6ICdVc2Ugc2VydmVybGVzcyBmdW5jdGlvbnMgb3IgYSBkaWZmZXJlbnQgZGVwbG95bWVudCB0YXJnZXQgZm9yIFdlYlNvY2tldCBmdW5jdGlvbmFsaXR5LicsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIC8vIFVzZSBkeW5hbWljIHByb3BlcnR5IGFjY2VzcyB0byBhdm9pZCBOZXh0LmpzIEVkZ2UgUnVudGltZSBzdGF0aWMgYW5hbHlzaXMgd2FybmluZ3NcbiAgICAgICAgICAgIGNvbnN0IHByb2Nlc3NWZXJzaW9ucyA9IHByb2Nlc3NbJ3ZlcnNpb25zJ107XG4gICAgICAgICAgICBpZiAocHJvY2Vzc1ZlcnNpb25zICYmIHByb2Nlc3NWZXJzaW9uc1snbm9kZSddKSB7XG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlICd2JyBwcmVmaXggaWYgcHJlc2VudCBhbmQgcGFyc2UgdGhlIG1ham9yIHZlcnNpb25cbiAgICAgICAgICAgICAgICBjb25zdCB2ZXJzaW9uU3RyaW5nID0gcHJvY2Vzc1ZlcnNpb25zWydub2RlJ107XG4gICAgICAgICAgICAgICAgY29uc3Qgbm9kZVZlcnNpb24gPSBwYXJzZUludCh2ZXJzaW9uU3RyaW5nLnJlcGxhY2UoL152LywgJycpLnNwbGl0KCcuJylbMF0pO1xuICAgICAgICAgICAgICAgIC8vIE5vZGUuanMgMjIrIHNob3VsZCBoYXZlIG5hdGl2ZSBXZWJTb2NrZXRcbiAgICAgICAgICAgICAgICBpZiAobm9kZVZlcnNpb24gPj0gMjIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgbmF0aXZlIFdlYlNvY2tldCBpcyBhdmFpbGFibGUgKHNob3VsZCBiZSBpbiBOb2RlLmpzIDIyKylcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzLldlYlNvY2tldCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHR5cGU6ICduYXRpdmUnLCBjb25zdHJ1Y3RvcjogZ2xvYmFsVGhpcy5XZWJTb2NrZXQgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBJZiBub3QgYXZhaWxhYmxlLCB1c2VyIG5lZWRzIHRvIHByb3ZpZGUgaXRcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICd1bnN1cHBvcnRlZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogYE5vZGUuanMgJHtub2RlVmVyc2lvbn0gZGV0ZWN0ZWQgYnV0IG5hdGl2ZSBXZWJTb2NrZXQgbm90IGZvdW5kLmAsXG4gICAgICAgICAgICAgICAgICAgICAgICB3b3JrYXJvdW5kOiAnUHJvdmlkZSBhIFdlYlNvY2tldCBpbXBsZW1lbnRhdGlvbiB2aWEgdGhlIHRyYW5zcG9ydCBvcHRpb24uJyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gTm9kZS5qcyA8IDIyIGRvZXNuJ3QgaGF2ZSBuYXRpdmUgV2ViU29ja2V0XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3Vuc3VwcG9ydGVkJyxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGBOb2RlLmpzICR7bm9kZVZlcnNpb259IGRldGVjdGVkIHdpdGhvdXQgbmF0aXZlIFdlYlNvY2tldCBzdXBwb3J0LmAsXG4gICAgICAgICAgICAgICAgICAgIHdvcmthcm91bmQ6ICdGb3IgTm9kZS5qcyA8IDIyLCBpbnN0YWxsIFwid3NcIiBwYWNrYWdlIGFuZCBwcm92aWRlIGl0IHZpYSB0aGUgdHJhbnNwb3J0IG9wdGlvbjpcXG4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdpbXBvcnQgd3MgZnJvbSBcIndzXCJcXG4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICduZXcgUmVhbHRpbWVDbGllbnQodXJsLCB7IHRyYW5zcG9ydDogd3MgfSknLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICd1bnN1cHBvcnRlZCcsXG4gICAgICAgICAgICBlcnJvcjogJ1Vua25vd24gSmF2YVNjcmlwdCBydW50aW1lIHdpdGhvdXQgV2ViU29ja2V0IHN1cHBvcnQuJyxcbiAgICAgICAgICAgIHdvcmthcm91bmQ6IFwiRW5zdXJlIHlvdSdyZSBydW5uaW5nIGluIGEgc3VwcG9ydGVkIGVudmlyb25tZW50IChicm93c2VyLCBOb2RlLmpzLCBEZW5vKSBvciBwcm92aWRlIGEgY3VzdG9tIFdlYlNvY2tldCBpbXBsZW1lbnRhdGlvbi5cIixcbiAgICAgICAgfTtcbiAgICB9XG4gICAgc3RhdGljIGdldFdlYlNvY2tldENvbnN0cnVjdG9yKCkge1xuICAgICAgICBjb25zdCBlbnYgPSB0aGlzLmRldGVjdEVudmlyb25tZW50KCk7XG4gICAgICAgIGlmIChlbnYuY29uc3RydWN0b3IpIHtcbiAgICAgICAgICAgIHJldHVybiBlbnYuY29uc3RydWN0b3I7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGVycm9yTWVzc2FnZSA9IGVudi5lcnJvciB8fCAnV2ViU29ja2V0IG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBlbnZpcm9ubWVudC4nO1xuICAgICAgICBpZiAoZW52Lndvcmthcm91bmQpIHtcbiAgICAgICAgICAgIGVycm9yTWVzc2FnZSArPSBgXFxuXFxuU3VnZ2VzdGVkIHNvbHV0aW9uOiAke2Vudi53b3JrYXJvdW5kfWA7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yTWVzc2FnZSk7XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGVXZWJTb2NrZXQodXJsLCBwcm90b2NvbHMpIHtcbiAgICAgICAgY29uc3QgV1MgPSB0aGlzLmdldFdlYlNvY2tldENvbnN0cnVjdG9yKCk7XG4gICAgICAgIHJldHVybiBuZXcgV1ModXJsLCBwcm90b2NvbHMpO1xuICAgIH1cbiAgICBzdGF0aWMgaXNXZWJTb2NrZXRTdXBwb3J0ZWQoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBlbnYgPSB0aGlzLmRldGVjdEVudmlyb25tZW50KCk7XG4gICAgICAgICAgICByZXR1cm4gZW52LnR5cGUgPT09ICduYXRpdmUnIHx8IGVudi50eXBlID09PSAnd3MnO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChfYSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0IGRlZmF1bHQgV2ViU29ja2V0RmFjdG9yeTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdlYnNvY2tldC1mYWN0b3J5LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/realtime-js/dist/module/lib/websocket-factory.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/storage-js/dist/module/StorageClient.js":
/*!************************************************************************!*\
  !*** ./node_modules/@supabase/storage-js/dist/module/StorageClient.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   StorageClient: () => (/* binding */ StorageClient)\n/* harmony export */ });\n/* harmony import */ var _packages_StorageFileApi__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./packages/StorageFileApi */ \"(app-pages-browser)/./node_modules/@supabase/storage-js/dist/module/packages/StorageFileApi.js\");\n/* harmony import */ var _packages_StorageBucketApi__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./packages/StorageBucketApi */ \"(app-pages-browser)/./node_modules/@supabase/storage-js/dist/module/packages/StorageBucketApi.js\");\n\n\nclass StorageClient extends _packages_StorageBucketApi__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n    constructor(url, headers = {}, fetch, opts) {\n        super(url, headers, fetch, opts);\n    }\n    /**\n     * Perform file operation in a bucket.\n     *\n     * @param id The bucket id to operate on.\n     */\n    from(id) {\n        return new _packages_StorageFileApi__WEBPACK_IMPORTED_MODULE_1__[\"default\"](this.url, this.headers, id, this.fetch);\n    }\n}\n//# sourceMappingURL=StorageClient.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2Uvc3RvcmFnZS1qcy9kaXN0L21vZHVsZS9TdG9yYWdlQ2xpZW50LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUF1RDtBQUNJO0FBQ3BELDRCQUE0QixrRUFBZ0I7QUFDbkQsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsZ0VBQWM7QUFDakM7QUFDQTtBQUNBIiwic291cmNlcyI6WyJEOlxcbmV4dFxcb3JnXFxub2RlX21vZHVsZXNcXEBzdXBhYmFzZVxcc3RvcmFnZS1qc1xcZGlzdFxcbW9kdWxlXFxTdG9yYWdlQ2xpZW50LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBTdG9yYWdlRmlsZUFwaSBmcm9tICcuL3BhY2thZ2VzL1N0b3JhZ2VGaWxlQXBpJztcbmltcG9ydCBTdG9yYWdlQnVja2V0QXBpIGZyb20gJy4vcGFja2FnZXMvU3RvcmFnZUJ1Y2tldEFwaSc7XG5leHBvcnQgY2xhc3MgU3RvcmFnZUNsaWVudCBleHRlbmRzIFN0b3JhZ2VCdWNrZXRBcGkge1xuICAgIGNvbnN0cnVjdG9yKHVybCwgaGVhZGVycyA9IHt9LCBmZXRjaCwgb3B0cykge1xuICAgICAgICBzdXBlcih1cmwsIGhlYWRlcnMsIGZldGNoLCBvcHRzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGVyZm9ybSBmaWxlIG9wZXJhdGlvbiBpbiBhIGJ1Y2tldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpZCBUaGUgYnVja2V0IGlkIHRvIG9wZXJhdGUgb24uXG4gICAgICovXG4gICAgZnJvbShpZCkge1xuICAgICAgICByZXR1cm4gbmV3IFN0b3JhZ2VGaWxlQXBpKHRoaXMudXJsLCB0aGlzLmhlYWRlcnMsIGlkLCB0aGlzLmZldGNoKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TdG9yYWdlQ2xpZW50LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/storage-js/dist/module/StorageClient.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/storage-js/dist/module/lib/constants.js":
/*!************************************************************************!*\
  !*** ./node_modules/@supabase/storage-js/dist/module/lib/constants.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEFAULT_HEADERS: () => (/* binding */ DEFAULT_HEADERS)\n/* harmony export */ });\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./version */ \"(app-pages-browser)/./node_modules/@supabase/storage-js/dist/module/lib/version.js\");\n\nconst DEFAULT_HEADERS = { 'X-Client-Info': `storage-js/${_version__WEBPACK_IMPORTED_MODULE_0__.version}` };\n//# sourceMappingURL=constants.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2Uvc3RvcmFnZS1qcy9kaXN0L21vZHVsZS9saWIvY29uc3RhbnRzLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQW9DO0FBQzdCLDBCQUEwQiwrQkFBK0IsNkNBQU8sQ0FBQztBQUN4RSIsInNvdXJjZXMiOlsiRDpcXG5leHRcXG9yZ1xcbm9kZV9tb2R1bGVzXFxAc3VwYWJhc2VcXHN0b3JhZ2UtanNcXGRpc3RcXG1vZHVsZVxcbGliXFxjb25zdGFudHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gJy4vdmVyc2lvbic7XG5leHBvcnQgY29uc3QgREVGQVVMVF9IRUFERVJTID0geyAnWC1DbGllbnQtSW5mbyc6IGBzdG9yYWdlLWpzLyR7dmVyc2lvbn1gIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25zdGFudHMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/storage-js/dist/module/lib/constants.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/storage-js/dist/module/lib/errors.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@supabase/storage-js/dist/module/lib/errors.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   StorageApiError: () => (/* binding */ StorageApiError),\n/* harmony export */   StorageError: () => (/* binding */ StorageError),\n/* harmony export */   StorageUnknownError: () => (/* binding */ StorageUnknownError),\n/* harmony export */   isStorageError: () => (/* binding */ isStorageError)\n/* harmony export */ });\nclass StorageError extends Error {\n    constructor(message) {\n        super(message);\n        this.__isStorageError = true;\n        this.name = 'StorageError';\n    }\n}\nfunction isStorageError(error) {\n    return typeof error === 'object' && error !== null && '__isStorageError' in error;\n}\nclass StorageApiError extends StorageError {\n    constructor(message, status, statusCode) {\n        super(message);\n        this.name = 'StorageApiError';\n        this.status = status;\n        this.statusCode = statusCode;\n    }\n    toJSON() {\n        return {\n            name: this.name,\n            message: this.message,\n            status: this.status,\n            statusCode: this.statusCode,\n        };\n    }\n}\nclass StorageUnknownError extends StorageError {\n    constructor(message, originalError) {\n        super(message);\n        this.name = 'StorageUnknownError';\n        this.originalError = originalError;\n    }\n}\n//# sourceMappingURL=errors.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2Uvc3RvcmFnZS1qcy9kaXN0L21vZHVsZS9saWIvZXJyb3JzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiRDpcXG5leHRcXG9yZ1xcbm9kZV9tb2R1bGVzXFxAc3VwYWJhc2VcXHN0b3JhZ2UtanNcXGRpc3RcXG1vZHVsZVxcbGliXFxlcnJvcnMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNsYXNzIFN0b3JhZ2VFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLl9faXNTdG9yYWdlRXJyb3IgPSB0cnVlO1xuICAgICAgICB0aGlzLm5hbWUgPSAnU3RvcmFnZUVycm9yJztcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gaXNTdG9yYWdlRXJyb3IoZXJyb3IpIHtcbiAgICByZXR1cm4gdHlwZW9mIGVycm9yID09PSAnb2JqZWN0JyAmJiBlcnJvciAhPT0gbnVsbCAmJiAnX19pc1N0b3JhZ2VFcnJvcicgaW4gZXJyb3I7XG59XG5leHBvcnQgY2xhc3MgU3RvcmFnZUFwaUVycm9yIGV4dGVuZHMgU3RvcmFnZUVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBzdGF0dXMsIHN0YXR1c0NvZGUpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIHRoaXMubmFtZSA9ICdTdG9yYWdlQXBpRXJyb3InO1xuICAgICAgICB0aGlzLnN0YXR1cyA9IHN0YXR1cztcbiAgICAgICAgdGhpcy5zdGF0dXNDb2RlID0gc3RhdHVzQ29kZTtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgICAgICAgc3RhdHVzOiB0aGlzLnN0YXR1cyxcbiAgICAgICAgICAgIHN0YXR1c0NvZGU6IHRoaXMuc3RhdHVzQ29kZSxcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgU3RvcmFnZVVua25vd25FcnJvciBleHRlbmRzIFN0b3JhZ2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgb3JpZ2luYWxFcnJvcikge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ1N0b3JhZ2VVbmtub3duRXJyb3InO1xuICAgICAgICB0aGlzLm9yaWdpbmFsRXJyb3IgPSBvcmlnaW5hbEVycm9yO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVycm9ycy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/storage-js/dist/module/lib/errors.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/storage-js/dist/module/lib/fetch.js":
/*!********************************************************************!*\
  !*** ./node_modules/@supabase/storage-js/dist/module/lib/fetch.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   get: () => (/* binding */ get),\n/* harmony export */   head: () => (/* binding */ head),\n/* harmony export */   post: () => (/* binding */ post),\n/* harmony export */   put: () => (/* binding */ put),\n/* harmony export */   remove: () => (/* binding */ remove)\n/* harmony export */ });\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./errors */ \"(app-pages-browser)/./node_modules/@supabase/storage-js/dist/module/lib/errors.js\");\n/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helpers */ \"(app-pages-browser)/./node_modules/@supabase/storage-js/dist/module/lib/helpers.js\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\nconst _getErrorMessage = (err) => err.msg || err.message || err.error_description || err.error || JSON.stringify(err);\nconst handleError = (error, reject, options) => __awaiter(void 0, void 0, void 0, function* () {\n    const Res = yield (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.resolveResponse)();\n    if (error instanceof Res && !(options === null || options === void 0 ? void 0 : options.noResolveJson)) {\n        error\n            .json()\n            .then((err) => {\n            const status = error.status || 500;\n            const statusCode = (err === null || err === void 0 ? void 0 : err.statusCode) || status + '';\n            reject(new _errors__WEBPACK_IMPORTED_MODULE_1__.StorageApiError(_getErrorMessage(err), status, statusCode));\n        })\n            .catch((err) => {\n            reject(new _errors__WEBPACK_IMPORTED_MODULE_1__.StorageUnknownError(_getErrorMessage(err), err));\n        });\n    }\n    else {\n        reject(new _errors__WEBPACK_IMPORTED_MODULE_1__.StorageUnknownError(_getErrorMessage(error), error));\n    }\n});\nconst _getRequestParams = (method, options, parameters, body) => {\n    const params = { method, headers: (options === null || options === void 0 ? void 0 : options.headers) || {} };\n    if (method === 'GET' || !body) {\n        return params;\n    }\n    if ((0,_helpers__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(body)) {\n        params.headers = Object.assign({ 'Content-Type': 'application/json' }, options === null || options === void 0 ? void 0 : options.headers);\n        params.body = JSON.stringify(body);\n    }\n    else {\n        params.body = body;\n    }\n    if (options === null || options === void 0 ? void 0 : options.duplex) {\n        params.duplex = options.duplex;\n    }\n    return Object.assign(Object.assign({}, params), parameters);\n};\nfunction _handleRequest(fetcher, method, url, options, parameters, body) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return new Promise((resolve, reject) => {\n            fetcher(url, _getRequestParams(method, options, parameters, body))\n                .then((result) => {\n                if (!result.ok)\n                    throw result;\n                if (options === null || options === void 0 ? void 0 : options.noResolveJson)\n                    return result;\n                return result.json();\n            })\n                .then((data) => resolve(data))\n                .catch((error) => handleError(error, reject, options));\n        });\n    });\n}\nfunction get(fetcher, url, options, parameters) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return _handleRequest(fetcher, 'GET', url, options, parameters);\n    });\n}\nfunction post(fetcher, url, body, options, parameters) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return _handleRequest(fetcher, 'POST', url, options, parameters, body);\n    });\n}\nfunction put(fetcher, url, body, options, parameters) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return _handleRequest(fetcher, 'PUT', url, options, parameters, body);\n    });\n}\nfunction head(fetcher, url, options, parameters) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return _handleRequest(fetcher, 'HEAD', url, Object.assign(Object.assign({}, options), { noResolveJson: true }), parameters);\n    });\n}\nfunction remove(fetcher, url, body, options, parameters) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return _handleRequest(fetcher, 'DELETE', url, options, parameters, body);\n    });\n}\n//# sourceMappingURL=fetch.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2Uvc3RvcmFnZS1qcy9kaXN0L21vZHVsZS9saWIvZmV0Y2guanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBLGlCQUFpQixTQUFJLElBQUksU0FBSTtBQUM3Qiw0QkFBNEIsK0RBQStELGlCQUFpQjtBQUM1RztBQUNBLG9DQUFvQyxNQUFNLCtCQUErQixZQUFZO0FBQ3JGLG1DQUFtQyxNQUFNLG1DQUFtQyxZQUFZO0FBQ3hGLGdDQUFnQztBQUNoQztBQUNBLEtBQUs7QUFDTDtBQUNnRTtBQUNMO0FBQzNEO0FBQ0E7QUFDQSxzQkFBc0IseURBQWU7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG9EQUFlO0FBQ3RDLFNBQVM7QUFDVDtBQUNBLHVCQUF1Qix3REFBbUI7QUFDMUMsU0FBUztBQUNUO0FBQ0E7QUFDQSxtQkFBbUIsd0RBQW1CO0FBQ3RDO0FBQ0EsQ0FBQztBQUNEO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLFFBQVEsdURBQWE7QUFDckIseUNBQXlDLG9DQUFvQztBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDTztBQUNQO0FBQ0Esa0ZBQWtGLGNBQWMscUJBQXFCO0FBQ3JILEtBQUs7QUFDTDtBQUNPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBIiwic291cmNlcyI6WyJEOlxcbmV4dFxcb3JnXFxub2RlX21vZHVsZXNcXEBzdXBhYmFzZVxcc3RvcmFnZS1qc1xcZGlzdFxcbW9kdWxlXFxsaWJcXGZldGNoLmpzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuaW1wb3J0IHsgU3RvcmFnZUFwaUVycm9yLCBTdG9yYWdlVW5rbm93bkVycm9yIH0gZnJvbSAnLi9lcnJvcnMnO1xuaW1wb3J0IHsgaXNQbGFpbk9iamVjdCwgcmVzb2x2ZVJlc3BvbnNlIH0gZnJvbSAnLi9oZWxwZXJzJztcbmNvbnN0IF9nZXRFcnJvck1lc3NhZ2UgPSAoZXJyKSA9PiBlcnIubXNnIHx8IGVyci5tZXNzYWdlIHx8IGVyci5lcnJvcl9kZXNjcmlwdGlvbiB8fCBlcnIuZXJyb3IgfHwgSlNPTi5zdHJpbmdpZnkoZXJyKTtcbmNvbnN0IGhhbmRsZUVycm9yID0gKGVycm9yLCByZWplY3QsIG9wdGlvbnMpID0+IF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgIGNvbnN0IFJlcyA9IHlpZWxkIHJlc29sdmVSZXNwb25zZSgpO1xuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIFJlcyAmJiAhKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5ub1Jlc29sdmVKc29uKSkge1xuICAgICAgICBlcnJvclxuICAgICAgICAgICAgLmpzb24oKVxuICAgICAgICAgICAgLnRoZW4oKGVycikgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc3RhdHVzID0gZXJyb3Iuc3RhdHVzIHx8IDUwMDtcbiAgICAgICAgICAgIGNvbnN0IHN0YXR1c0NvZGUgPSAoZXJyID09PSBudWxsIHx8IGVyciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXJyLnN0YXR1c0NvZGUpIHx8IHN0YXR1cyArICcnO1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBTdG9yYWdlQXBpRXJyb3IoX2dldEVycm9yTWVzc2FnZShlcnIpLCBzdGF0dXMsIHN0YXR1c0NvZGUpKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICByZWplY3QobmV3IFN0b3JhZ2VVbmtub3duRXJyb3IoX2dldEVycm9yTWVzc2FnZShlcnIpLCBlcnIpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZWplY3QobmV3IFN0b3JhZ2VVbmtub3duRXJyb3IoX2dldEVycm9yTWVzc2FnZShlcnJvciksIGVycm9yKSk7XG4gICAgfVxufSk7XG5jb25zdCBfZ2V0UmVxdWVzdFBhcmFtcyA9IChtZXRob2QsIG9wdGlvbnMsIHBhcmFtZXRlcnMsIGJvZHkpID0+IHtcbiAgICBjb25zdCBwYXJhbXMgPSB7IG1ldGhvZCwgaGVhZGVyczogKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5oZWFkZXJzKSB8fCB7fSB9O1xuICAgIGlmIChtZXRob2QgPT09ICdHRVQnIHx8ICFib2R5KSB7XG4gICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfVxuICAgIGlmIChpc1BsYWluT2JqZWN0KGJvZHkpKSB7XG4gICAgICAgIHBhcmFtcy5oZWFkZXJzID0gT2JqZWN0LmFzc2lnbih7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSwgb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmhlYWRlcnMpO1xuICAgICAgICBwYXJhbXMuYm9keSA9IEpTT04uc3RyaW5naWZ5KGJvZHkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcGFyYW1zLmJvZHkgPSBib2R5O1xuICAgIH1cbiAgICBpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmR1cGxleCkge1xuICAgICAgICBwYXJhbXMuZHVwbGV4ID0gb3B0aW9ucy5kdXBsZXg7XG4gICAgfVxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHBhcmFtcyksIHBhcmFtZXRlcnMpO1xufTtcbmZ1bmN0aW9uIF9oYW5kbGVSZXF1ZXN0KGZldGNoZXIsIG1ldGhvZCwgdXJsLCBvcHRpb25zLCBwYXJhbWV0ZXJzLCBib2R5KSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGZldGNoZXIodXJsLCBfZ2V0UmVxdWVzdFBhcmFtcyhtZXRob2QsIG9wdGlvbnMsIHBhcmFtZXRlcnMsIGJvZHkpKVxuICAgICAgICAgICAgICAgIC50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXJlc3VsdC5vaylcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgcmVzdWx0O1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubm9SZXNvbHZlSnNvbilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0Lmpzb24oKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGRhdGEpID0+IHJlc29sdmUoZGF0YSkpXG4gICAgICAgICAgICAgICAgLmNhdGNoKChlcnJvcikgPT4gaGFuZGxlRXJyb3IoZXJyb3IsIHJlamVjdCwgb3B0aW9ucykpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXQoZmV0Y2hlciwgdXJsLCBvcHRpb25zLCBwYXJhbWV0ZXJzKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgcmV0dXJuIF9oYW5kbGVSZXF1ZXN0KGZldGNoZXIsICdHRVQnLCB1cmwsIG9wdGlvbnMsIHBhcmFtZXRlcnMpO1xuICAgIH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHBvc3QoZmV0Y2hlciwgdXJsLCBib2R5LCBvcHRpb25zLCBwYXJhbWV0ZXJzKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgcmV0dXJuIF9oYW5kbGVSZXF1ZXN0KGZldGNoZXIsICdQT1NUJywgdXJsLCBvcHRpb25zLCBwYXJhbWV0ZXJzLCBib2R5KTtcbiAgICB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBwdXQoZmV0Y2hlciwgdXJsLCBib2R5LCBvcHRpb25zLCBwYXJhbWV0ZXJzKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgcmV0dXJuIF9oYW5kbGVSZXF1ZXN0KGZldGNoZXIsICdQVVQnLCB1cmwsIG9wdGlvbnMsIHBhcmFtZXRlcnMsIGJvZHkpO1xuICAgIH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGhlYWQoZmV0Y2hlciwgdXJsLCBvcHRpb25zLCBwYXJhbWV0ZXJzKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgcmV0dXJuIF9oYW5kbGVSZXF1ZXN0KGZldGNoZXIsICdIRUFEJywgdXJsLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpLCB7IG5vUmVzb2x2ZUpzb246IHRydWUgfSksIHBhcmFtZXRlcnMpO1xuICAgIH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZShmZXRjaGVyLCB1cmwsIGJvZHksIG9wdGlvbnMsIHBhcmFtZXRlcnMpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICByZXR1cm4gX2hhbmRsZVJlcXVlc3QoZmV0Y2hlciwgJ0RFTEVURScsIHVybCwgb3B0aW9ucywgcGFyYW1ldGVycywgYm9keSk7XG4gICAgfSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mZXRjaC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/storage-js/dist/module/lib/fetch.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/storage-js/dist/module/lib/helpers.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@supabase/storage-js/dist/module/lib/helpers.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isPlainObject: () => (/* binding */ isPlainObject),\n/* harmony export */   recursiveToCamel: () => (/* binding */ recursiveToCamel),\n/* harmony export */   resolveFetch: () => (/* binding */ resolveFetch),\n/* harmony export */   resolveResponse: () => (/* binding */ resolveResponse)\n/* harmony export */ });\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nconst resolveFetch = (customFetch) => {\n    let _fetch;\n    if (customFetch) {\n        _fetch = customFetch;\n    }\n    else if (typeof fetch === 'undefined') {\n        _fetch = (...args) => Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! @supabase/node-fetch */ \"(app-pages-browser)/./node_modules/@supabase/node-fetch/browser.js\")).then(({ default: fetch }) => fetch(...args));\n    }\n    else {\n        _fetch = fetch;\n    }\n    return (...args) => _fetch(...args);\n};\nconst resolveResponse = () => __awaiter(void 0, void 0, void 0, function* () {\n    if (typeof Response === 'undefined') {\n        // @ts-ignore\n        return (yield Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! @supabase/node-fetch */ \"(app-pages-browser)/./node_modules/@supabase/node-fetch/browser.js\"))).Response;\n    }\n    return Response;\n});\nconst recursiveToCamel = (item) => {\n    if (Array.isArray(item)) {\n        return item.map((el) => recursiveToCamel(el));\n    }\n    else if (typeof item === 'function' || item !== Object(item)) {\n        return item;\n    }\n    const result = {};\n    Object.entries(item).forEach(([key, value]) => {\n        const newKey = key.replace(/([-_][a-z])/gi, (c) => c.toUpperCase().replace(/[-_]/g, ''));\n        result[newKey] = recursiveToCamel(value);\n    });\n    return result;\n};\n/**\n * Determine if input is a plain object\n * An object is plain if it's created by either {}, new Object(), or Object.create(null)\n * source: https://github.com/sindresorhus/is-plain-obj\n */\nconst isPlainObject = (value) => {\n    if (typeof value !== 'object' || value === null) {\n        return false;\n    }\n    const prototype = Object.getPrototypeOf(value);\n    return ((prototype === null ||\n        prototype === Object.prototype ||\n        Object.getPrototypeOf(prototype) === null) &&\n        !(Symbol.toStringTag in value) &&\n        !(Symbol.iterator in value));\n};\n//# sourceMappingURL=helpers.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2Uvc3RvcmFnZS1qcy9kaXN0L21vZHVsZS9saWIvaGVscGVycy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUEsaUJBQWlCLFNBQUksSUFBSSxTQUFJO0FBQzdCLDRCQUE0QiwrREFBK0QsaUJBQWlCO0FBQzVHO0FBQ0Esb0NBQW9DLE1BQU0sK0JBQStCLFlBQVk7QUFDckYsbUNBQW1DLE1BQU0sbUNBQW1DLFlBQVk7QUFDeEYsZ0NBQWdDO0FBQ2hDO0FBQ0EsS0FBSztBQUNMO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHNMQUE4QixTQUFTLGdCQUFnQjtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSxzQkFBc0Isc0xBQThCO0FBQ3BEO0FBQ0E7QUFDQSxDQUFDO0FBQ007QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJEOlxcbmV4dFxcb3JnXFxub2RlX21vZHVsZXNcXEBzdXBhYmFzZVxcc3RvcmFnZS1qc1xcZGlzdFxcbW9kdWxlXFxsaWJcXGhlbHBlcnMuanMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5leHBvcnQgY29uc3QgcmVzb2x2ZUZldGNoID0gKGN1c3RvbUZldGNoKSA9PiB7XG4gICAgbGV0IF9mZXRjaDtcbiAgICBpZiAoY3VzdG9tRmV0Y2gpIHtcbiAgICAgICAgX2ZldGNoID0gY3VzdG9tRmV0Y2g7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBmZXRjaCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgX2ZldGNoID0gKC4uLmFyZ3MpID0+IGltcG9ydCgnQHN1cGFiYXNlL25vZGUtZmV0Y2gnKS50aGVuKCh7IGRlZmF1bHQ6IGZldGNoIH0pID0+IGZldGNoKC4uLmFyZ3MpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIF9mZXRjaCA9IGZldGNoO1xuICAgIH1cbiAgICByZXR1cm4gKC4uLmFyZ3MpID0+IF9mZXRjaCguLi5hcmdzKTtcbn07XG5leHBvcnQgY29uc3QgcmVzb2x2ZVJlc3BvbnNlID0gKCkgPT4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgaWYgKHR5cGVvZiBSZXNwb25zZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICByZXR1cm4gKHlpZWxkIGltcG9ydCgnQHN1cGFiYXNlL25vZGUtZmV0Y2gnKSkuUmVzcG9uc2U7XG4gICAgfVxuICAgIHJldHVybiBSZXNwb25zZTtcbn0pO1xuZXhwb3J0IGNvbnN0IHJlY3Vyc2l2ZVRvQ2FtZWwgPSAoaXRlbSkgPT4ge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGl0ZW0pKSB7XG4gICAgICAgIHJldHVybiBpdGVtLm1hcCgoZWwpID0+IHJlY3Vyc2l2ZVRvQ2FtZWwoZWwpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGl0ZW0gPT09ICdmdW5jdGlvbicgfHwgaXRlbSAhPT0gT2JqZWN0KGl0ZW0pKSB7XG4gICAgICAgIHJldHVybiBpdGVtO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBPYmplY3QuZW50cmllcyhpdGVtKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgY29uc3QgbmV3S2V5ID0ga2V5LnJlcGxhY2UoLyhbLV9dW2Etel0pL2dpLCAoYykgPT4gYy50b1VwcGVyQ2FzZSgpLnJlcGxhY2UoL1stX10vZywgJycpKTtcbiAgICAgICAgcmVzdWx0W25ld0tleV0gPSByZWN1cnNpdmVUb0NhbWVsKHZhbHVlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbi8qKlxuICogRGV0ZXJtaW5lIGlmIGlucHV0IGlzIGEgcGxhaW4gb2JqZWN0XG4gKiBBbiBvYmplY3QgaXMgcGxhaW4gaWYgaXQncyBjcmVhdGVkIGJ5IGVpdGhlciB7fSwgbmV3IE9iamVjdCgpLCBvciBPYmplY3QuY3JlYXRlKG51bGwpXG4gKiBzb3VyY2U6IGh0dHBzOi8vZ2l0aHViLmNvbS9zaW5kcmVzb3JodXMvaXMtcGxhaW4tb2JqXG4gKi9cbmV4cG9ydCBjb25zdCBpc1BsYWluT2JqZWN0ID0gKHZhbHVlKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcgfHwgdmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBwcm90b3R5cGUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsdWUpO1xuICAgIHJldHVybiAoKHByb3RvdHlwZSA9PT0gbnVsbCB8fFxuICAgICAgICBwcm90b3R5cGUgPT09IE9iamVjdC5wcm90b3R5cGUgfHxcbiAgICAgICAgT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvdHlwZSkgPT09IG51bGwpICYmXG4gICAgICAgICEoU3ltYm9sLnRvU3RyaW5nVGFnIGluIHZhbHVlKSAmJlxuICAgICAgICAhKFN5bWJvbC5pdGVyYXRvciBpbiB2YWx1ZSkpO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhlbHBlcnMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/storage-js/dist/module/lib/helpers.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/storage-js/dist/module/lib/version.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@supabase/storage-js/dist/module/lib/version.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\n// Generated automatically during releases by scripts/update-version-files.ts\n// This file provides runtime access to the package version for:\n// - HTTP request headers (e.g., X-Client-Info header for API requests)\n// - Debugging and support (identifying which version is running)\n// - Telemetry and logging (version reporting in errors/analytics)\n// - Ensuring build artifacts match the published package version\nconst version = '2.74.0';\n//# sourceMappingURL=version.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2Uvc3RvcmFnZS1qcy9kaXN0L21vZHVsZS9saWIvdmVyc2lvbi5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCIsInNvdXJjZXMiOlsiRDpcXG5leHRcXG9yZ1xcbm9kZV9tb2R1bGVzXFxAc3VwYWJhc2VcXHN0b3JhZ2UtanNcXGRpc3RcXG1vZHVsZVxcbGliXFx2ZXJzaW9uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEdlbmVyYXRlZCBhdXRvbWF0aWNhbGx5IGR1cmluZyByZWxlYXNlcyBieSBzY3JpcHRzL3VwZGF0ZS12ZXJzaW9uLWZpbGVzLnRzXG4vLyBUaGlzIGZpbGUgcHJvdmlkZXMgcnVudGltZSBhY2Nlc3MgdG8gdGhlIHBhY2thZ2UgdmVyc2lvbiBmb3I6XG4vLyAtIEhUVFAgcmVxdWVzdCBoZWFkZXJzIChlLmcuLCBYLUNsaWVudC1JbmZvIGhlYWRlciBmb3IgQVBJIHJlcXVlc3RzKVxuLy8gLSBEZWJ1Z2dpbmcgYW5kIHN1cHBvcnQgKGlkZW50aWZ5aW5nIHdoaWNoIHZlcnNpb24gaXMgcnVubmluZylcbi8vIC0gVGVsZW1ldHJ5IGFuZCBsb2dnaW5nICh2ZXJzaW9uIHJlcG9ydGluZyBpbiBlcnJvcnMvYW5hbHl0aWNzKVxuLy8gLSBFbnN1cmluZyBidWlsZCBhcnRpZmFjdHMgbWF0Y2ggdGhlIHB1Ymxpc2hlZCBwYWNrYWdlIHZlcnNpb25cbmV4cG9ydCBjb25zdCB2ZXJzaW9uID0gJzIuNzQuMCc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD12ZXJzaW9uLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/storage-js/dist/module/lib/version.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/storage-js/dist/module/packages/BlobDownloadBuilder.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@supabase/storage-js/dist/module/packages/BlobDownloadBuilder.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ BlobDownloadBuilder)\n/* harmony export */ });\n/* harmony import */ var _lib_errors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/errors */ \"(app-pages-browser)/./node_modules/@supabase/storage-js/dist/module/lib/errors.js\");\n/* harmony import */ var _StreamDownloadBuilder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./StreamDownloadBuilder */ \"(app-pages-browser)/./node_modules/@supabase/storage-js/dist/module/packages/StreamDownloadBuilder.js\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\nclass BlobDownloadBuilder {\n    constructor(downloadFn, shouldThrowOnError) {\n        this.downloadFn = downloadFn;\n        this.shouldThrowOnError = shouldThrowOnError;\n    }\n    asStream() {\n        return new _StreamDownloadBuilder__WEBPACK_IMPORTED_MODULE_0__[\"default\"](this.downloadFn, this.shouldThrowOnError);\n    }\n    then(onfulfilled, onrejected) {\n        return this.execute().then(onfulfilled, onrejected);\n    }\n    execute() {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const result = yield this.downloadFn();\n                return {\n                    data: yield result.blob(),\n                    error: null,\n                };\n            }\n            catch (error) {\n                if (this.shouldThrowOnError) {\n                    throw error;\n                }\n                if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_1__.isStorageError)(error)) {\n                    return { data: null, error };\n                }\n                throw error;\n            }\n        });\n    }\n}\n//# sourceMappingURL=BlobDownloadBuilder.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2Uvc3RvcmFnZS1qcy9kaXN0L21vZHVsZS9wYWNrYWdlcy9CbG9iRG93bmxvYWRCdWlsZGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLGlCQUFpQixTQUFJLElBQUksU0FBSTtBQUM3Qiw0QkFBNEIsK0RBQStELGlCQUFpQjtBQUM1RztBQUNBLG9DQUFvQyxNQUFNLCtCQUErQixZQUFZO0FBQ3JGLG1DQUFtQyxNQUFNLG1DQUFtQyxZQUFZO0FBQ3hGLGdDQUFnQztBQUNoQztBQUNBLEtBQUs7QUFDTDtBQUMrQztBQUNhO0FBQzdDO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw4REFBcUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwyREFBYztBQUNsQyw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiRDpcXG5leHRcXG9yZ1xcbm9kZV9tb2R1bGVzXFxAc3VwYWJhc2VcXHN0b3JhZ2UtanNcXGRpc3RcXG1vZHVsZVxccGFja2FnZXNcXEJsb2JEb3dubG9hZEJ1aWxkZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5pbXBvcnQgeyBpc1N0b3JhZ2VFcnJvciB9IGZyb20gJy4uL2xpYi9lcnJvcnMnO1xuaW1wb3J0IFN0cmVhbURvd25sb2FkQnVpbGRlciBmcm9tICcuL1N0cmVhbURvd25sb2FkQnVpbGRlcic7XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCbG9iRG93bmxvYWRCdWlsZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihkb3dubG9hZEZuLCBzaG91bGRUaHJvd09uRXJyb3IpIHtcbiAgICAgICAgdGhpcy5kb3dubG9hZEZuID0gZG93bmxvYWRGbjtcbiAgICAgICAgdGhpcy5zaG91bGRUaHJvd09uRXJyb3IgPSBzaG91bGRUaHJvd09uRXJyb3I7XG4gICAgfVxuICAgIGFzU3RyZWFtKCkge1xuICAgICAgICByZXR1cm4gbmV3IFN0cmVhbURvd25sb2FkQnVpbGRlcih0aGlzLmRvd25sb2FkRm4sIHRoaXMuc2hvdWxkVGhyb3dPbkVycm9yKTtcbiAgICB9XG4gICAgdGhlbihvbmZ1bGZpbGxlZCwgb25yZWplY3RlZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5leGVjdXRlKCkudGhlbihvbmZ1bGZpbGxlZCwgb25yZWplY3RlZCk7XG4gICAgfVxuICAgIGV4ZWN1dGUoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHlpZWxkIHRoaXMuZG93bmxvYWRGbigpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHlpZWxkIHJlc3VsdC5ibG9iKCksXG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zaG91bGRUaHJvd09uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpc1N0b3JhZ2VFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJsb2JEb3dubG9hZEJ1aWxkZXIuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/storage-js/dist/module/packages/BlobDownloadBuilder.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/storage-js/dist/module/packages/StorageBucketApi.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@supabase/storage-js/dist/module/packages/StorageBucketApi.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ StorageBucketApi)\n/* harmony export */ });\n/* harmony import */ var _lib_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/constants */ \"(app-pages-browser)/./node_modules/@supabase/storage-js/dist/module/lib/constants.js\");\n/* harmony import */ var _lib_errors__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../lib/errors */ \"(app-pages-browser)/./node_modules/@supabase/storage-js/dist/module/lib/errors.js\");\n/* harmony import */ var _lib_fetch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/fetch */ \"(app-pages-browser)/./node_modules/@supabase/storage-js/dist/module/lib/fetch.js\");\n/* harmony import */ var _lib_helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/helpers */ \"(app-pages-browser)/./node_modules/@supabase/storage-js/dist/module/lib/helpers.js\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\n\nclass StorageBucketApi {\n    constructor(url, headers = {}, fetch, opts) {\n        this.shouldThrowOnError = false;\n        const baseUrl = new URL(url);\n        // if legacy uri is used, replace with new storage host (disables request buffering to allow > 50GB uploads)\n        // \"project-ref.supabase.co\" becomes \"project-ref.storage.supabase.co\"\n        if (opts === null || opts === void 0 ? void 0 : opts.useNewHostname) {\n            const isSupabaseHost = /supabase\\.(co|in|red)$/.test(baseUrl.hostname);\n            if (isSupabaseHost && !baseUrl.hostname.includes('storage.supabase.')) {\n                baseUrl.hostname = baseUrl.hostname.replace('supabase.', 'storage.supabase.');\n            }\n        }\n        this.url = baseUrl.href.replace(/\\/$/, '');\n        this.headers = Object.assign(Object.assign({}, _lib_constants__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_HEADERS), headers);\n        this.fetch = (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_1__.resolveFetch)(fetch);\n    }\n    /**\n     * Enable throwing errors instead of returning them.\n     */\n    throwOnError() {\n        this.shouldThrowOnError = true;\n        return this;\n    }\n    /**\n     * Retrieves the details of all Storage buckets within an existing project.\n     */\n    listBuckets() {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const data = yield (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_2__.get)(this.fetch, `${this.url}/bucket`, { headers: this.headers });\n                return { data, error: null };\n            }\n            catch (error) {\n                if (this.shouldThrowOnError) {\n                    throw error;\n                }\n                if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_3__.isStorageError)(error)) {\n                    return { data: null, error };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Retrieves the details of an existing Storage bucket.\n     *\n     * @param id The unique identifier of the bucket you would like to retrieve.\n     */\n    getBucket(id) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const data = yield (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_2__.get)(this.fetch, `${this.url}/bucket/${id}`, { headers: this.headers });\n                return { data, error: null };\n            }\n            catch (error) {\n                if (this.shouldThrowOnError) {\n                    throw error;\n                }\n                if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_3__.isStorageError)(error)) {\n                    return { data: null, error };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Creates a new Storage bucket\n     *\n     * @param id A unique identifier for the bucket you are creating.\n     * @param options.public The visibility of the bucket. Public buckets don't require an authorization token to download objects, but still require a valid token for all other operations. By default, buckets are private.\n     * @param options.fileSizeLimit specifies the max file size in bytes that can be uploaded to this bucket.\n     * The global file size limit takes precedence over this value.\n     * The default value is null, which doesn't set a per bucket file size limit.\n     * @param options.allowedMimeTypes specifies the allowed mime types that this bucket can accept during upload.\n     * The default value is null, which allows files with all mime types to be uploaded.\n     * Each mime type specified can be a wildcard, e.g. image/*, or a specific mime type, e.g. image/png.\n     * @returns newly created bucket id\n     * @param options.type (private-beta) specifies the bucket type. see `BucketType` for more details.\n     *   - default bucket type is `STANDARD`\n     */\n    createBucket(id_1) {\n        return __awaiter(this, arguments, void 0, function* (id, options = {\n            public: false,\n        }) {\n            try {\n                const data = yield (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_2__.post)(this.fetch, `${this.url}/bucket`, {\n                    id,\n                    name: id,\n                    type: options.type,\n                    public: options.public,\n                    file_size_limit: options.fileSizeLimit,\n                    allowed_mime_types: options.allowedMimeTypes,\n                }, { headers: this.headers });\n                return { data, error: null };\n            }\n            catch (error) {\n                if (this.shouldThrowOnError) {\n                    throw error;\n                }\n                if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_3__.isStorageError)(error)) {\n                    return { data: null, error };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Updates a Storage bucket\n     *\n     * @param id A unique identifier for the bucket you are updating.\n     * @param options.public The visibility of the bucket. Public buckets don't require an authorization token to download objects, but still require a valid token for all other operations.\n     * @param options.fileSizeLimit specifies the max file size in bytes that can be uploaded to this bucket.\n     * The global file size limit takes precedence over this value.\n     * The default value is null, which doesn't set a per bucket file size limit.\n     * @param options.allowedMimeTypes specifies the allowed mime types that this bucket can accept during upload.\n     * The default value is null, which allows files with all mime types to be uploaded.\n     * Each mime type specified can be a wildcard, e.g. image/*, or a specific mime type, e.g. image/png.\n     */\n    updateBucket(id, options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const data = yield (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_2__.put)(this.fetch, `${this.url}/bucket/${id}`, {\n                    id,\n                    name: id,\n                    public: options.public,\n                    file_size_limit: options.fileSizeLimit,\n                    allowed_mime_types: options.allowedMimeTypes,\n                }, { headers: this.headers });\n                return { data, error: null };\n            }\n            catch (error) {\n                if (this.shouldThrowOnError) {\n                    throw error;\n                }\n                if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_3__.isStorageError)(error)) {\n                    return { data: null, error };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Removes all objects inside a single bucket.\n     *\n     * @param id The unique identifier of the bucket you would like to empty.\n     */\n    emptyBucket(id) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const data = yield (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_2__.post)(this.fetch, `${this.url}/bucket/${id}/empty`, {}, { headers: this.headers });\n                return { data, error: null };\n            }\n            catch (error) {\n                if (this.shouldThrowOnError) {\n                    throw error;\n                }\n                if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_3__.isStorageError)(error)) {\n                    return { data: null, error };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Deletes an existing bucket. A bucket can't be deleted with existing objects inside it.\n     * You must first `empty()` the bucket.\n     *\n     * @param id The unique identifier of the bucket you would like to delete.\n     */\n    deleteBucket(id) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const data = yield (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_2__.remove)(this.fetch, `${this.url}/bucket/${id}`, {}, { headers: this.headers });\n                return { data, error: null };\n            }\n            catch (error) {\n                if (this.shouldThrowOnError) {\n                    throw error;\n                }\n                if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_3__.isStorageError)(error)) {\n                    return { data: null, error };\n                }\n                throw error;\n            }\n        });\n    }\n}\n//# sourceMappingURL=StorageBucketApi.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2Uvc3RvcmFnZS1qcy9kaXN0L21vZHVsZS9wYWNrYWdlcy9TdG9yYWdlQnVja2V0QXBpLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUEsaUJBQWlCLFNBQUksSUFBSSxTQUFJO0FBQzdCLDRCQUE0QiwrREFBK0QsaUJBQWlCO0FBQzVHO0FBQ0Esb0NBQW9DLE1BQU0sK0JBQStCLFlBQVk7QUFDckYsbUNBQW1DLE1BQU0sbUNBQW1DLFlBQVk7QUFDeEYsZ0NBQWdDO0FBQ2hDO0FBQ0EsS0FBSztBQUNMO0FBQ21EO0FBQ0o7QUFDTztBQUNSO0FBQy9CO0FBQ2YsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsRUFBRSwyREFBZTtBQUN0RSxxQkFBcUIsMERBQVk7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQywrQ0FBRyxnQkFBZ0IsU0FBUyxZQUFZLHVCQUF1QjtBQUNsRyx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwyREFBYztBQUNsQyw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQywrQ0FBRyxnQkFBZ0IsU0FBUyxVQUFVLEdBQUcsS0FBSyx1QkFBdUI7QUFDeEcseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMkRBQWM7QUFDbEMsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLG1DQUFtQyxnREFBSSxnQkFBZ0IsU0FBUztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsSUFBSSx1QkFBdUI7QUFDNUMseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMkRBQWM7QUFDbEMsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQywrQ0FBRyxnQkFBZ0IsU0FBUyxVQUFVLEdBQUc7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixJQUFJLHVCQUF1QjtBQUM1Qyx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwyREFBYztBQUNsQyw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxnREFBSSxnQkFBZ0IsU0FBUyxVQUFVLEdBQUcsV0FBVyxJQUFJLHVCQUF1QjtBQUNuSCx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwyREFBYztBQUNsQyw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGtEQUFNLGdCQUFnQixTQUFTLFVBQVUsR0FBRyxLQUFLLElBQUksdUJBQXVCO0FBQy9HLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDJEQUFjO0FBQ2xDLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBIiwic291cmNlcyI6WyJEOlxcbmV4dFxcb3JnXFxub2RlX21vZHVsZXNcXEBzdXBhYmFzZVxcc3RvcmFnZS1qc1xcZGlzdFxcbW9kdWxlXFxwYWNrYWdlc1xcU3RvcmFnZUJ1Y2tldEFwaS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbmltcG9ydCB7IERFRkFVTFRfSEVBREVSUyB9IGZyb20gJy4uL2xpYi9jb25zdGFudHMnO1xuaW1wb3J0IHsgaXNTdG9yYWdlRXJyb3IgfSBmcm9tICcuLi9saWIvZXJyb3JzJztcbmltcG9ydCB7IGdldCwgcG9zdCwgcHV0LCByZW1vdmUgfSBmcm9tICcuLi9saWIvZmV0Y2gnO1xuaW1wb3J0IHsgcmVzb2x2ZUZldGNoIH0gZnJvbSAnLi4vbGliL2hlbHBlcnMnO1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3RvcmFnZUJ1Y2tldEFwaSB7XG4gICAgY29uc3RydWN0b3IodXJsLCBoZWFkZXJzID0ge30sIGZldGNoLCBvcHRzKSB7XG4gICAgICAgIHRoaXMuc2hvdWxkVGhyb3dPbkVycm9yID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IGJhc2VVcmwgPSBuZXcgVVJMKHVybCk7XG4gICAgICAgIC8vIGlmIGxlZ2FjeSB1cmkgaXMgdXNlZCwgcmVwbGFjZSB3aXRoIG5ldyBzdG9yYWdlIGhvc3QgKGRpc2FibGVzIHJlcXVlc3QgYnVmZmVyaW5nIHRvIGFsbG93ID4gNTBHQiB1cGxvYWRzKVxuICAgICAgICAvLyBcInByb2plY3QtcmVmLnN1cGFiYXNlLmNvXCIgYmVjb21lcyBcInByb2plY3QtcmVmLnN0b3JhZ2Uuc3VwYWJhc2UuY29cIlxuICAgICAgICBpZiAob3B0cyA9PT0gbnVsbCB8fCBvcHRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRzLnVzZU5ld0hvc3RuYW1lKSB7XG4gICAgICAgICAgICBjb25zdCBpc1N1cGFiYXNlSG9zdCA9IC9zdXBhYmFzZVxcLihjb3xpbnxyZWQpJC8udGVzdChiYXNlVXJsLmhvc3RuYW1lKTtcbiAgICAgICAgICAgIGlmIChpc1N1cGFiYXNlSG9zdCAmJiAhYmFzZVVybC5ob3N0bmFtZS5pbmNsdWRlcygnc3RvcmFnZS5zdXBhYmFzZS4nKSkge1xuICAgICAgICAgICAgICAgIGJhc2VVcmwuaG9zdG5hbWUgPSBiYXNlVXJsLmhvc3RuYW1lLnJlcGxhY2UoJ3N1cGFiYXNlLicsICdzdG9yYWdlLnN1cGFiYXNlLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMudXJsID0gYmFzZVVybC5ocmVmLnJlcGxhY2UoL1xcLyQvLCAnJyk7XG4gICAgICAgIHRoaXMuaGVhZGVycyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVF9IRUFERVJTKSwgaGVhZGVycyk7XG4gICAgICAgIHRoaXMuZmV0Y2ggPSByZXNvbHZlRmV0Y2goZmV0Y2gpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbmFibGUgdGhyb3dpbmcgZXJyb3JzIGluc3RlYWQgb2YgcmV0dXJuaW5nIHRoZW0uXG4gICAgICovXG4gICAgdGhyb3dPbkVycm9yKCkge1xuICAgICAgICB0aGlzLnNob3VsZFRocm93T25FcnJvciA9IHRydWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIGRldGFpbHMgb2YgYWxsIFN0b3JhZ2UgYnVja2V0cyB3aXRoaW4gYW4gZXhpc3RpbmcgcHJvamVjdC5cbiAgICAgKi9cbiAgICBsaXN0QnVja2V0cygpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IHlpZWxkIGdldCh0aGlzLmZldGNoLCBgJHt0aGlzLnVybH0vYnVja2V0YCwgeyBoZWFkZXJzOiB0aGlzLmhlYWRlcnMgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YSwgZXJyb3I6IG51bGwgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNob3VsZFRocm93T25FcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlzU3RvcmFnZUVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgZGV0YWlscyBvZiBhbiBleGlzdGluZyBTdG9yYWdlIGJ1Y2tldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpZCBUaGUgdW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIGJ1Y2tldCB5b3Ugd291bGQgbGlrZSB0byByZXRyaWV2ZS5cbiAgICAgKi9cbiAgICBnZXRCdWNrZXQoaWQpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IHlpZWxkIGdldCh0aGlzLmZldGNoLCBgJHt0aGlzLnVybH0vYnVja2V0LyR7aWR9YCwgeyBoZWFkZXJzOiB0aGlzLmhlYWRlcnMgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YSwgZXJyb3I6IG51bGwgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNob3VsZFRocm93T25FcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlzU3RvcmFnZUVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgU3RvcmFnZSBidWNrZXRcbiAgICAgKlxuICAgICAqIEBwYXJhbSBpZCBBIHVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgYnVja2V0IHlvdSBhcmUgY3JlYXRpbmcuXG4gICAgICogQHBhcmFtIG9wdGlvbnMucHVibGljIFRoZSB2aXNpYmlsaXR5IG9mIHRoZSBidWNrZXQuIFB1YmxpYyBidWNrZXRzIGRvbid0IHJlcXVpcmUgYW4gYXV0aG9yaXphdGlvbiB0b2tlbiB0byBkb3dubG9hZCBvYmplY3RzLCBidXQgc3RpbGwgcmVxdWlyZSBhIHZhbGlkIHRva2VuIGZvciBhbGwgb3RoZXIgb3BlcmF0aW9ucy4gQnkgZGVmYXVsdCwgYnVja2V0cyBhcmUgcHJpdmF0ZS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5maWxlU2l6ZUxpbWl0IHNwZWNpZmllcyB0aGUgbWF4IGZpbGUgc2l6ZSBpbiBieXRlcyB0aGF0IGNhbiBiZSB1cGxvYWRlZCB0byB0aGlzIGJ1Y2tldC5cbiAgICAgKiBUaGUgZ2xvYmFsIGZpbGUgc2l6ZSBsaW1pdCB0YWtlcyBwcmVjZWRlbmNlIG92ZXIgdGhpcyB2YWx1ZS5cbiAgICAgKiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBudWxsLCB3aGljaCBkb2Vzbid0IHNldCBhIHBlciBidWNrZXQgZmlsZSBzaXplIGxpbWl0LlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmFsbG93ZWRNaW1lVHlwZXMgc3BlY2lmaWVzIHRoZSBhbGxvd2VkIG1pbWUgdHlwZXMgdGhhdCB0aGlzIGJ1Y2tldCBjYW4gYWNjZXB0IGR1cmluZyB1cGxvYWQuXG4gICAgICogVGhlIGRlZmF1bHQgdmFsdWUgaXMgbnVsbCwgd2hpY2ggYWxsb3dzIGZpbGVzIHdpdGggYWxsIG1pbWUgdHlwZXMgdG8gYmUgdXBsb2FkZWQuXG4gICAgICogRWFjaCBtaW1lIHR5cGUgc3BlY2lmaWVkIGNhbiBiZSBhIHdpbGRjYXJkLCBlLmcuIGltYWdlLyosIG9yIGEgc3BlY2lmaWMgbWltZSB0eXBlLCBlLmcuIGltYWdlL3BuZy5cbiAgICAgKiBAcmV0dXJucyBuZXdseSBjcmVhdGVkIGJ1Y2tldCBpZFxuICAgICAqIEBwYXJhbSBvcHRpb25zLnR5cGUgKHByaXZhdGUtYmV0YSkgc3BlY2lmaWVzIHRoZSBidWNrZXQgdHlwZS4gc2VlIGBCdWNrZXRUeXBlYCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqICAgLSBkZWZhdWx0IGJ1Y2tldCB0eXBlIGlzIGBTVEFOREFSRGBcbiAgICAgKi9cbiAgICBjcmVhdGVCdWNrZXQoaWRfMSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIGFyZ3VtZW50cywgdm9pZCAwLCBmdW5jdGlvbiogKGlkLCBvcHRpb25zID0ge1xuICAgICAgICAgICAgcHVibGljOiBmYWxzZSxcbiAgICAgICAgfSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0geWllbGQgcG9zdCh0aGlzLmZldGNoLCBgJHt0aGlzLnVybH0vYnVja2V0YCwge1xuICAgICAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogaWQsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IG9wdGlvbnMudHlwZSxcbiAgICAgICAgICAgICAgICAgICAgcHVibGljOiBvcHRpb25zLnB1YmxpYyxcbiAgICAgICAgICAgICAgICAgICAgZmlsZV9zaXplX2xpbWl0OiBvcHRpb25zLmZpbGVTaXplTGltaXQsXG4gICAgICAgICAgICAgICAgICAgIGFsbG93ZWRfbWltZV90eXBlczogb3B0aW9ucy5hbGxvd2VkTWltZVR5cGVzLFxuICAgICAgICAgICAgICAgIH0sIHsgaGVhZGVyczogdGhpcy5oZWFkZXJzIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGEsIGVycm9yOiBudWxsIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zaG91bGRUaHJvd09uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpc1N0b3JhZ2VFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIGEgU3RvcmFnZSBidWNrZXRcbiAgICAgKlxuICAgICAqIEBwYXJhbSBpZCBBIHVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgYnVja2V0IHlvdSBhcmUgdXBkYXRpbmcuXG4gICAgICogQHBhcmFtIG9wdGlvbnMucHVibGljIFRoZSB2aXNpYmlsaXR5IG9mIHRoZSBidWNrZXQuIFB1YmxpYyBidWNrZXRzIGRvbid0IHJlcXVpcmUgYW4gYXV0aG9yaXphdGlvbiB0b2tlbiB0byBkb3dubG9hZCBvYmplY3RzLCBidXQgc3RpbGwgcmVxdWlyZSBhIHZhbGlkIHRva2VuIGZvciBhbGwgb3RoZXIgb3BlcmF0aW9ucy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5maWxlU2l6ZUxpbWl0IHNwZWNpZmllcyB0aGUgbWF4IGZpbGUgc2l6ZSBpbiBieXRlcyB0aGF0IGNhbiBiZSB1cGxvYWRlZCB0byB0aGlzIGJ1Y2tldC5cbiAgICAgKiBUaGUgZ2xvYmFsIGZpbGUgc2l6ZSBsaW1pdCB0YWtlcyBwcmVjZWRlbmNlIG92ZXIgdGhpcyB2YWx1ZS5cbiAgICAgKiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBudWxsLCB3aGljaCBkb2Vzbid0IHNldCBhIHBlciBidWNrZXQgZmlsZSBzaXplIGxpbWl0LlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmFsbG93ZWRNaW1lVHlwZXMgc3BlY2lmaWVzIHRoZSBhbGxvd2VkIG1pbWUgdHlwZXMgdGhhdCB0aGlzIGJ1Y2tldCBjYW4gYWNjZXB0IGR1cmluZyB1cGxvYWQuXG4gICAgICogVGhlIGRlZmF1bHQgdmFsdWUgaXMgbnVsbCwgd2hpY2ggYWxsb3dzIGZpbGVzIHdpdGggYWxsIG1pbWUgdHlwZXMgdG8gYmUgdXBsb2FkZWQuXG4gICAgICogRWFjaCBtaW1lIHR5cGUgc3BlY2lmaWVkIGNhbiBiZSBhIHdpbGRjYXJkLCBlLmcuIGltYWdlLyosIG9yIGEgc3BlY2lmaWMgbWltZSB0eXBlLCBlLmcuIGltYWdlL3BuZy5cbiAgICAgKi9cbiAgICB1cGRhdGVCdWNrZXQoaWQsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IHlpZWxkIHB1dCh0aGlzLmZldGNoLCBgJHt0aGlzLnVybH0vYnVja2V0LyR7aWR9YCwge1xuICAgICAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogaWQsXG4gICAgICAgICAgICAgICAgICAgIHB1YmxpYzogb3B0aW9ucy5wdWJsaWMsXG4gICAgICAgICAgICAgICAgICAgIGZpbGVfc2l6ZV9saW1pdDogb3B0aW9ucy5maWxlU2l6ZUxpbWl0LFxuICAgICAgICAgICAgICAgICAgICBhbGxvd2VkX21pbWVfdHlwZXM6IG9wdGlvbnMuYWxsb3dlZE1pbWVUeXBlcyxcbiAgICAgICAgICAgICAgICB9LCB7IGhlYWRlcnM6IHRoaXMuaGVhZGVycyB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhLCBlcnJvcjogbnVsbCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2hvdWxkVGhyb3dPbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXNTdG9yYWdlRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwgb2JqZWN0cyBpbnNpZGUgYSBzaW5nbGUgYnVja2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGlkIFRoZSB1bmlxdWUgaWRlbnRpZmllciBvZiB0aGUgYnVja2V0IHlvdSB3b3VsZCBsaWtlIHRvIGVtcHR5LlxuICAgICAqL1xuICAgIGVtcHR5QnVja2V0KGlkKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSB5aWVsZCBwb3N0KHRoaXMuZmV0Y2gsIGAke3RoaXMudXJsfS9idWNrZXQvJHtpZH0vZW1wdHlgLCB7fSwgeyBoZWFkZXJzOiB0aGlzLmhlYWRlcnMgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YSwgZXJyb3I6IG51bGwgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNob3VsZFRocm93T25FcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlzU3RvcmFnZUVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZXMgYW4gZXhpc3RpbmcgYnVja2V0LiBBIGJ1Y2tldCBjYW4ndCBiZSBkZWxldGVkIHdpdGggZXhpc3Rpbmcgb2JqZWN0cyBpbnNpZGUgaXQuXG4gICAgICogWW91IG11c3QgZmlyc3QgYGVtcHR5KClgIHRoZSBidWNrZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaWQgVGhlIHVuaXF1ZSBpZGVudGlmaWVyIG9mIHRoZSBidWNrZXQgeW91IHdvdWxkIGxpa2UgdG8gZGVsZXRlLlxuICAgICAqL1xuICAgIGRlbGV0ZUJ1Y2tldChpZCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0geWllbGQgcmVtb3ZlKHRoaXMuZmV0Y2gsIGAke3RoaXMudXJsfS9idWNrZXQvJHtpZH1gLCB7fSwgeyBoZWFkZXJzOiB0aGlzLmhlYWRlcnMgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YSwgZXJyb3I6IG51bGwgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNob3VsZFRocm93T25FcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlzU3RvcmFnZUVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U3RvcmFnZUJ1Y2tldEFwaS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/storage-js/dist/module/packages/StorageBucketApi.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/storage-js/dist/module/packages/StorageFileApi.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@supabase/storage-js/dist/module/packages/StorageFileApi.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ StorageFileApi)\n/* harmony export */ });\n/* harmony import */ var _lib_errors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/errors */ \"(app-pages-browser)/./node_modules/@supabase/storage-js/dist/module/lib/errors.js\");\n/* harmony import */ var _lib_fetch__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/fetch */ \"(app-pages-browser)/./node_modules/@supabase/storage-js/dist/module/lib/fetch.js\");\n/* harmony import */ var _lib_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/helpers */ \"(app-pages-browser)/./node_modules/@supabase/storage-js/dist/module/lib/helpers.js\");\n/* harmony import */ var _BlobDownloadBuilder__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./BlobDownloadBuilder */ \"(app-pages-browser)/./node_modules/@supabase/storage-js/dist/module/packages/BlobDownloadBuilder.js\");\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"(app-pages-browser)/./node_modules/next/dist/compiled/buffer/index.js\")[\"Buffer\"];\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\n\nconst DEFAULT_SEARCH_OPTIONS = {\n    limit: 100,\n    offset: 0,\n    sortBy: {\n        column: 'name',\n        order: 'asc',\n    },\n};\nconst DEFAULT_FILE_OPTIONS = {\n    cacheControl: '3600',\n    contentType: 'text/plain;charset=UTF-8',\n    upsert: false,\n};\nclass StorageFileApi {\n    constructor(url, headers = {}, bucketId, fetch) {\n        this.shouldThrowOnError = false;\n        this.url = url;\n        this.headers = headers;\n        this.bucketId = bucketId;\n        this.fetch = (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_0__.resolveFetch)(fetch);\n    }\n    /**\n     * Enable throwing errors instead of returning them.\n     */\n    throwOnError() {\n        this.shouldThrowOnError = true;\n        return this;\n    }\n    /**\n     * Uploads a file to an existing bucket or replaces an existing file at the specified path with a new one.\n     *\n     * @param method HTTP method.\n     * @param path The relative file path. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.\n     * @param fileBody The body of the file to be stored in the bucket.\n     */\n    uploadOrUpdate(method, path, fileBody, fileOptions) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                let body;\n                const options = Object.assign(Object.assign({}, DEFAULT_FILE_OPTIONS), fileOptions);\n                let headers = Object.assign(Object.assign({}, this.headers), (method === 'POST' && { 'x-upsert': String(options.upsert) }));\n                const metadata = options.metadata;\n                if (typeof Blob !== 'undefined' && fileBody instanceof Blob) {\n                    body = new FormData();\n                    body.append('cacheControl', options.cacheControl);\n                    if (metadata) {\n                        body.append('metadata', this.encodeMetadata(metadata));\n                    }\n                    body.append('', fileBody);\n                }\n                else if (typeof FormData !== 'undefined' && fileBody instanceof FormData) {\n                    body = fileBody;\n                    body.append('cacheControl', options.cacheControl);\n                    if (metadata) {\n                        body.append('metadata', this.encodeMetadata(metadata));\n                    }\n                }\n                else {\n                    body = fileBody;\n                    headers['cache-control'] = `max-age=${options.cacheControl}`;\n                    headers['content-type'] = options.contentType;\n                    if (metadata) {\n                        headers['x-metadata'] = this.toBase64(this.encodeMetadata(metadata));\n                    }\n                }\n                if (fileOptions === null || fileOptions === void 0 ? void 0 : fileOptions.headers) {\n                    headers = Object.assign(Object.assign({}, headers), fileOptions.headers);\n                }\n                const cleanPath = this._removeEmptyFolders(path);\n                const _path = this._getFinalPath(cleanPath);\n                const data = yield (method == 'PUT' ? _lib_fetch__WEBPACK_IMPORTED_MODULE_1__.put : _lib_fetch__WEBPACK_IMPORTED_MODULE_1__.post)(this.fetch, `${this.url}/object/${_path}`, body, Object.assign({ headers }, ((options === null || options === void 0 ? void 0 : options.duplex) ? { duplex: options.duplex } : {})));\n                return {\n                    data: { path: cleanPath, id: data.Id, fullPath: data.Key },\n                    error: null,\n                };\n            }\n            catch (error) {\n                if (this.shouldThrowOnError) {\n                    throw error;\n                }\n                if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isStorageError)(error)) {\n                    return { data: null, error };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Uploads a file to an existing bucket.\n     *\n     * @param path The file path, including the file name. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.\n     * @param fileBody The body of the file to be stored in the bucket.\n     */\n    upload(path, fileBody, fileOptions) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.uploadOrUpdate('POST', path, fileBody, fileOptions);\n        });\n    }\n    /**\n     * Upload a file with a token generated from `createSignedUploadUrl`.\n     * @param path The file path, including the file name. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.\n     * @param token The token generated from `createSignedUploadUrl`\n     * @param fileBody The body of the file to be stored in the bucket.\n     */\n    uploadToSignedUrl(path, token, fileBody, fileOptions) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const cleanPath = this._removeEmptyFolders(path);\n            const _path = this._getFinalPath(cleanPath);\n            const url = new URL(this.url + `/object/upload/sign/${_path}`);\n            url.searchParams.set('token', token);\n            try {\n                let body;\n                const options = Object.assign({ upsert: DEFAULT_FILE_OPTIONS.upsert }, fileOptions);\n                const headers = Object.assign(Object.assign({}, this.headers), { 'x-upsert': String(options.upsert) });\n                if (typeof Blob !== 'undefined' && fileBody instanceof Blob) {\n                    body = new FormData();\n                    body.append('cacheControl', options.cacheControl);\n                    body.append('', fileBody);\n                }\n                else if (typeof FormData !== 'undefined' && fileBody instanceof FormData) {\n                    body = fileBody;\n                    body.append('cacheControl', options.cacheControl);\n                }\n                else {\n                    body = fileBody;\n                    headers['cache-control'] = `max-age=${options.cacheControl}`;\n                    headers['content-type'] = options.contentType;\n                }\n                const data = yield (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_1__.put)(this.fetch, url.toString(), body, { headers });\n                return {\n                    data: { path: cleanPath, fullPath: data.Key },\n                    error: null,\n                };\n            }\n            catch (error) {\n                if (this.shouldThrowOnError) {\n                    throw error;\n                }\n                if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isStorageError)(error)) {\n                    return { data: null, error };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Creates a signed upload URL.\n     * Signed upload URLs can be used to upload files to the bucket without further authentication.\n     * They are valid for 2 hours.\n     * @param path The file path, including the current file name. For example `folder/image.png`.\n     * @param options.upsert If set to true, allows the file to be overwritten if it already exists.\n     */\n    createSignedUploadUrl(path, options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                let _path = this._getFinalPath(path);\n                const headers = Object.assign({}, this.headers);\n                if (options === null || options === void 0 ? void 0 : options.upsert) {\n                    headers['x-upsert'] = 'true';\n                }\n                const data = yield (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_1__.post)(this.fetch, `${this.url}/object/upload/sign/${_path}`, {}, { headers });\n                const url = new URL(this.url + data.url);\n                const token = url.searchParams.get('token');\n                if (!token) {\n                    throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.StorageError('No token returned by API');\n                }\n                return { data: { signedUrl: url.toString(), path, token }, error: null };\n            }\n            catch (error) {\n                if (this.shouldThrowOnError) {\n                    throw error;\n                }\n                if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isStorageError)(error)) {\n                    return { data: null, error };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Replaces an existing file at the specified path with a new one.\n     *\n     * @param path The relative file path. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to update.\n     * @param fileBody The body of the file to be stored in the bucket.\n     */\n    update(path, fileBody, fileOptions) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.uploadOrUpdate('PUT', path, fileBody, fileOptions);\n        });\n    }\n    /**\n     * Moves an existing file to a new path in the same bucket.\n     *\n     * @param fromPath The original file path, including the current file name. For example `folder/image.png`.\n     * @param toPath The new file path, including the new file name. For example `folder/image-new.png`.\n     * @param options The destination options.\n     */\n    move(fromPath, toPath, options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const data = yield (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_1__.post)(this.fetch, `${this.url}/object/move`, {\n                    bucketId: this.bucketId,\n                    sourceKey: fromPath,\n                    destinationKey: toPath,\n                    destinationBucket: options === null || options === void 0 ? void 0 : options.destinationBucket,\n                }, { headers: this.headers });\n                return { data, error: null };\n            }\n            catch (error) {\n                if (this.shouldThrowOnError) {\n                    throw error;\n                }\n                if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isStorageError)(error)) {\n                    return { data: null, error };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Copies an existing file to a new path in the same bucket.\n     *\n     * @param fromPath The original file path, including the current file name. For example `folder/image.png`.\n     * @param toPath The new file path, including the new file name. For example `folder/image-copy.png`.\n     * @param options The destination options.\n     */\n    copy(fromPath, toPath, options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const data = yield (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_1__.post)(this.fetch, `${this.url}/object/copy`, {\n                    bucketId: this.bucketId,\n                    sourceKey: fromPath,\n                    destinationKey: toPath,\n                    destinationBucket: options === null || options === void 0 ? void 0 : options.destinationBucket,\n                }, { headers: this.headers });\n                return { data: { path: data.Key }, error: null };\n            }\n            catch (error) {\n                if (this.shouldThrowOnError) {\n                    throw error;\n                }\n                if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isStorageError)(error)) {\n                    return { data: null, error };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Creates a signed URL. Use a signed URL to share a file for a fixed amount of time.\n     *\n     * @param path The file path, including the current file name. For example `folder/image.png`.\n     * @param expiresIn The number of seconds until the signed URL expires. For example, `60` for a URL which is valid for one minute.\n     * @param options.download triggers the file as a download if set to true. Set this parameter as the name of the file if you want to trigger the download with a different filename.\n     * @param options.transform Transform the asset before serving it to the client.\n     */\n    createSignedUrl(path, expiresIn, options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                let _path = this._getFinalPath(path);\n                let data = yield (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_1__.post)(this.fetch, `${this.url}/object/sign/${_path}`, Object.assign({ expiresIn }, ((options === null || options === void 0 ? void 0 : options.transform) ? { transform: options.transform } : {})), { headers: this.headers });\n                const downloadQueryParam = (options === null || options === void 0 ? void 0 : options.download)\n                    ? `&download=${options.download === true ? '' : options.download}`\n                    : '';\n                const signedUrl = encodeURI(`${this.url}${data.signedURL}${downloadQueryParam}`);\n                data = { signedUrl };\n                return { data, error: null };\n            }\n            catch (error) {\n                if (this.shouldThrowOnError) {\n                    throw error;\n                }\n                if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isStorageError)(error)) {\n                    return { data: null, error };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Creates multiple signed URLs. Use a signed URL to share a file for a fixed amount of time.\n     *\n     * @param paths The file paths to be downloaded, including the current file names. For example `['folder/image.png', 'folder2/image2.png']`.\n     * @param expiresIn The number of seconds until the signed URLs expire. For example, `60` for URLs which are valid for one minute.\n     * @param options.download triggers the file as a download if set to true. Set this parameter as the name of the file if you want to trigger the download with a different filename.\n     */\n    createSignedUrls(paths, expiresIn, options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const data = yield (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_1__.post)(this.fetch, `${this.url}/object/sign/${this.bucketId}`, { expiresIn, paths }, { headers: this.headers });\n                const downloadQueryParam = (options === null || options === void 0 ? void 0 : options.download)\n                    ? `&download=${options.download === true ? '' : options.download}`\n                    : '';\n                return {\n                    data: data.map((datum) => (Object.assign(Object.assign({}, datum), { signedUrl: datum.signedURL\n                            ? encodeURI(`${this.url}${datum.signedURL}${downloadQueryParam}`)\n                            : null }))),\n                    error: null,\n                };\n            }\n            catch (error) {\n                if (this.shouldThrowOnError) {\n                    throw error;\n                }\n                if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isStorageError)(error)) {\n                    return { data: null, error };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Downloads a file from a private bucket. For public buckets, make a request to the URL returned from `getPublicUrl` instead.\n     *\n     * @param path The full path and file name of the file to be downloaded. For example `folder/image.png`.\n     * @param options.transform Transform the asset before serving it to the client.\n     */\n    download(path, options) {\n        const wantsTransformation = typeof (options === null || options === void 0 ? void 0 : options.transform) !== 'undefined';\n        const renderPath = wantsTransformation ? 'render/image/authenticated' : 'object';\n        const transformationQuery = this.transformOptsToQueryString((options === null || options === void 0 ? void 0 : options.transform) || {});\n        const queryString = transformationQuery ? `?${transformationQuery}` : '';\n        const _path = this._getFinalPath(path);\n        const downloadFn = () => (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_1__.get)(this.fetch, `${this.url}/${renderPath}/${_path}${queryString}`, {\n            headers: this.headers,\n            noResolveJson: true,\n        });\n        return new _BlobDownloadBuilder__WEBPACK_IMPORTED_MODULE_3__[\"default\"](downloadFn, this.shouldThrowOnError);\n    }\n    /**\n     * Retrieves the details of an existing file.\n     * @param path\n     */\n    info(path) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const _path = this._getFinalPath(path);\n            try {\n                const data = yield (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_1__.get)(this.fetch, `${this.url}/object/info/${_path}`, {\n                    headers: this.headers,\n                });\n                return { data: (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_0__.recursiveToCamel)(data), error: null };\n            }\n            catch (error) {\n                if (this.shouldThrowOnError) {\n                    throw error;\n                }\n                if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isStorageError)(error)) {\n                    return { data: null, error };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Checks the existence of a file.\n     * @param path\n     */\n    exists(path) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const _path = this._getFinalPath(path);\n            try {\n                yield (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_1__.head)(this.fetch, `${this.url}/object/${_path}`, {\n                    headers: this.headers,\n                });\n                return { data: true, error: null };\n            }\n            catch (error) {\n                if (this.shouldThrowOnError) {\n                    throw error;\n                }\n                if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isStorageError)(error) && error instanceof _lib_errors__WEBPACK_IMPORTED_MODULE_2__.StorageUnknownError) {\n                    const originalError = error.originalError;\n                    if ([400, 404].includes(originalError === null || originalError === void 0 ? void 0 : originalError.status)) {\n                        return { data: false, error };\n                    }\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * A simple convenience function to get the URL for an asset in a public bucket. If you do not want to use this function, you can construct the public URL by concatenating the bucket URL with the path to the asset.\n     * This function does not verify if the bucket is public. If a public URL is created for a bucket which is not public, you will not be able to download the asset.\n     *\n     * @param path The path and name of the file to generate the public URL for. For example `folder/image.png`.\n     * @param options.download Triggers the file as a download if set to true. Set this parameter as the name of the file if you want to trigger the download with a different filename.\n     * @param options.transform Transform the asset before serving it to the client.\n     */\n    getPublicUrl(path, options) {\n        const _path = this._getFinalPath(path);\n        const _queryString = [];\n        const downloadQueryParam = (options === null || options === void 0 ? void 0 : options.download)\n            ? `download=${options.download === true ? '' : options.download}`\n            : '';\n        if (downloadQueryParam !== '') {\n            _queryString.push(downloadQueryParam);\n        }\n        const wantsTransformation = typeof (options === null || options === void 0 ? void 0 : options.transform) !== 'undefined';\n        const renderPath = wantsTransformation ? 'render/image' : 'object';\n        const transformationQuery = this.transformOptsToQueryString((options === null || options === void 0 ? void 0 : options.transform) || {});\n        if (transformationQuery !== '') {\n            _queryString.push(transformationQuery);\n        }\n        let queryString = _queryString.join('&');\n        if (queryString !== '') {\n            queryString = `?${queryString}`;\n        }\n        return {\n            data: { publicUrl: encodeURI(`${this.url}/${renderPath}/public/${_path}${queryString}`) },\n        };\n    }\n    /**\n     * Deletes files within the same bucket\n     *\n     * @param paths An array of files to delete, including the path and file name. For example [`'folder/image.png'`].\n     */\n    remove(paths) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const data = yield (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_1__.remove)(this.fetch, `${this.url}/object/${this.bucketId}`, { prefixes: paths }, { headers: this.headers });\n                return { data, error: null };\n            }\n            catch (error) {\n                if (this.shouldThrowOnError) {\n                    throw error;\n                }\n                if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isStorageError)(error)) {\n                    return { data: null, error };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Get file metadata\n     * @param id the file id to retrieve metadata\n     */\n    // async getMetadata(\n    //   id: string\n    // ): Promise<\n    //   | {\n    //       data: Metadata\n    //       error: null\n    //     }\n    //   | {\n    //       data: null\n    //       error: StorageError\n    //     }\n    // > {\n    //   try {\n    //     const data = await get(this.fetch, `${this.url}/metadata/${id}`, { headers: this.headers })\n    //     return { data, error: null }\n    //   } catch (error) {\n    //     if (isStorageError(error)) {\n    //       return { data: null, error }\n    //     }\n    //     throw error\n    //   }\n    // }\n    /**\n     * Update file metadata\n     * @param id the file id to update metadata\n     * @param meta the new file metadata\n     */\n    // async updateMetadata(\n    //   id: string,\n    //   meta: Metadata\n    // ): Promise<\n    //   | {\n    //       data: Metadata\n    //       error: null\n    //     }\n    //   | {\n    //       data: null\n    //       error: StorageError\n    //     }\n    // > {\n    //   try {\n    //     const data = await post(\n    //       this.fetch,\n    //       `${this.url}/metadata/${id}`,\n    //       { ...meta },\n    //       { headers: this.headers }\n    //     )\n    //     return { data, error: null }\n    //   } catch (error) {\n    //     if (isStorageError(error)) {\n    //       return { data: null, error }\n    //     }\n    //     throw error\n    //   }\n    // }\n    /**\n     * Lists all the files and folders within a path of the bucket.\n     * @param path The folder path.\n     * @param options Search options including limit (defaults to 100), offset, sortBy, and search\n     */\n    list(path, options, parameters) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const body = Object.assign(Object.assign(Object.assign({}, DEFAULT_SEARCH_OPTIONS), options), { prefix: path || '' });\n                const data = yield (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_1__.post)(this.fetch, `${this.url}/object/list/${this.bucketId}`, body, { headers: this.headers }, parameters);\n                return { data, error: null };\n            }\n            catch (error) {\n                if (this.shouldThrowOnError) {\n                    throw error;\n                }\n                if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isStorageError)(error)) {\n                    return { data: null, error };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * @experimental this method signature might change in the future\n     * @param options search options\n     * @param parameters\n     */\n    listV2(options, parameters) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const body = Object.assign({}, options);\n                const data = yield (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_1__.post)(this.fetch, `${this.url}/object/list-v2/${this.bucketId}`, body, { headers: this.headers }, parameters);\n                return { data, error: null };\n            }\n            catch (error) {\n                if (this.shouldThrowOnError) {\n                    throw error;\n                }\n                if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isStorageError)(error)) {\n                    return { data: null, error };\n                }\n                throw error;\n            }\n        });\n    }\n    encodeMetadata(metadata) {\n        return JSON.stringify(metadata);\n    }\n    toBase64(data) {\n        if (typeof Buffer !== 'undefined') {\n            return Buffer.from(data).toString('base64');\n        }\n        return btoa(data);\n    }\n    _getFinalPath(path) {\n        return `${this.bucketId}/${path.replace(/^\\/+/, '')}`;\n    }\n    _removeEmptyFolders(path) {\n        return path.replace(/^\\/|\\/$/g, '').replace(/\\/+/g, '/');\n    }\n    transformOptsToQueryString(transform) {\n        const params = [];\n        if (transform.width) {\n            params.push(`width=${transform.width}`);\n        }\n        if (transform.height) {\n            params.push(`height=${transform.height}`);\n        }\n        if (transform.resize) {\n            params.push(`resize=${transform.resize}`);\n        }\n        if (transform.format) {\n            params.push(`format=${transform.format}`);\n        }\n        if (transform.quality) {\n            params.push(`quality=${transform.quality}`);\n        }\n        return params.join('&');\n    }\n}\n//# sourceMappingURL=StorageFileApi.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2Uvc3RvcmFnZS1qcy9kaXN0L21vZHVsZS9wYWNrYWdlcy9TdG9yYWdlRmlsZUFwaS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQSxpQkFBaUIsU0FBSSxJQUFJLFNBQUk7QUFDN0IsNEJBQTRCLCtEQUErRCxpQkFBaUI7QUFDNUc7QUFDQSxvQ0FBb0MsTUFBTSwrQkFBK0IsWUFBWTtBQUNyRixtQ0FBbUMsTUFBTSxtQ0FBbUMsWUFBWTtBQUN4RixnQ0FBZ0M7QUFDaEM7QUFDQSxLQUFLO0FBQ0w7QUFDa0Y7QUFDdEI7QUFDSTtBQUNSO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNlO0FBQ2YsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDBEQUFZO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlELDREQUE0RCx5Q0FBeUMsb0NBQW9DO0FBQ3pJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxxQkFBcUI7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCwyQ0FBRyxHQUFHLDRDQUFJLGlCQUFpQixTQUFTLFVBQVUsTUFBTSx5QkFBeUIsU0FBUywwRUFBMEUseUJBQXlCLElBQUk7QUFDblA7QUFDQSw0QkFBNEIsa0RBQWtEO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Es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LG9CQUFvQiwyREFBYztBQUNsQyw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QyxtQ0FBbUMsZ0RBQUksZ0JBQWdCLFNBQVMsa0JBQWtCLGNBQWMsV0FBVyx1QkFBdUI7QUFDbEkseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMkRBQWM7QUFDbEMsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE1BQU07QUFDekIsbUJBQW1CLE1BQU07QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsY0FBYyxHQUFHLHlCQUF5QjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxnQkFBZ0I7QUFDakQ7QUFDQTtBQUNBLGtDQUFrQyxpQkFBaUI7QUFDbkQ7QUFDQTtBQUNBLGtDQUFrQyxpQkFBaUI7QUFDbkQ7QUFDQTtBQUNBLGtDQUFrQyxpQkFBaUI7QUFDbkQ7QUFDQTtBQUNBLG1DQUFtQyxrQkFBa0I7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiRDpcXG5leHRcXG9yZ1xcbm9kZV9tb2R1bGVzXFxAc3VwYWJhc2VcXHN0b3JhZ2UtanNcXGRpc3RcXG1vZHVsZVxccGFja2FnZXNcXFN0b3JhZ2VGaWxlQXBpLmpzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuaW1wb3J0IHsgaXNTdG9yYWdlRXJyb3IsIFN0b3JhZ2VFcnJvciwgU3RvcmFnZVVua25vd25FcnJvciB9IGZyb20gJy4uL2xpYi9lcnJvcnMnO1xuaW1wb3J0IHsgZ2V0LCBoZWFkLCBwb3N0LCBwdXQsIHJlbW92ZSB9IGZyb20gJy4uL2xpYi9mZXRjaCc7XG5pbXBvcnQgeyByZWN1cnNpdmVUb0NhbWVsLCByZXNvbHZlRmV0Y2ggfSBmcm9tICcuLi9saWIvaGVscGVycyc7XG5pbXBvcnQgQmxvYkRvd25sb2FkQnVpbGRlciBmcm9tICcuL0Jsb2JEb3dubG9hZEJ1aWxkZXInO1xuY29uc3QgREVGQVVMVF9TRUFSQ0hfT1BUSU9OUyA9IHtcbiAgICBsaW1pdDogMTAwLFxuICAgIG9mZnNldDogMCxcbiAgICBzb3J0Qnk6IHtcbiAgICAgICAgY29sdW1uOiAnbmFtZScsXG4gICAgICAgIG9yZGVyOiAnYXNjJyxcbiAgICB9LFxufTtcbmNvbnN0IERFRkFVTFRfRklMRV9PUFRJT05TID0ge1xuICAgIGNhY2hlQ29udHJvbDogJzM2MDAnLFxuICAgIGNvbnRlbnRUeXBlOiAndGV4dC9wbGFpbjtjaGFyc2V0PVVURi04JyxcbiAgICB1cHNlcnQ6IGZhbHNlLFxufTtcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN0b3JhZ2VGaWxlQXBpIHtcbiAgICBjb25zdHJ1Y3Rvcih1cmwsIGhlYWRlcnMgPSB7fSwgYnVja2V0SWQsIGZldGNoKSB7XG4gICAgICAgIHRoaXMuc2hvdWxkVGhyb3dPbkVycm9yID0gZmFsc2U7XG4gICAgICAgIHRoaXMudXJsID0gdXJsO1xuICAgICAgICB0aGlzLmhlYWRlcnMgPSBoZWFkZXJzO1xuICAgICAgICB0aGlzLmJ1Y2tldElkID0gYnVja2V0SWQ7XG4gICAgICAgIHRoaXMuZmV0Y2ggPSByZXNvbHZlRmV0Y2goZmV0Y2gpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbmFibGUgdGhyb3dpbmcgZXJyb3JzIGluc3RlYWQgb2YgcmV0dXJuaW5nIHRoZW0uXG4gICAgICovXG4gICAgdGhyb3dPbkVycm9yKCkge1xuICAgICAgICB0aGlzLnNob3VsZFRocm93T25FcnJvciA9IHRydWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGxvYWRzIGEgZmlsZSB0byBhbiBleGlzdGluZyBidWNrZXQgb3IgcmVwbGFjZXMgYW4gZXhpc3RpbmcgZmlsZSBhdCB0aGUgc3BlY2lmaWVkIHBhdGggd2l0aCBhIG5ldyBvbmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbWV0aG9kIEhUVFAgbWV0aG9kLlxuICAgICAqIEBwYXJhbSBwYXRoIFRoZSByZWxhdGl2ZSBmaWxlIHBhdGguIFNob3VsZCBiZSBvZiB0aGUgZm9ybWF0IGBmb2xkZXIvc3ViZm9sZGVyL2ZpbGVuYW1lLnBuZ2AuIFRoZSBidWNrZXQgbXVzdCBhbHJlYWR5IGV4aXN0IGJlZm9yZSBhdHRlbXB0aW5nIHRvIHVwbG9hZC5cbiAgICAgKiBAcGFyYW0gZmlsZUJvZHkgVGhlIGJvZHkgb2YgdGhlIGZpbGUgdG8gYmUgc3RvcmVkIGluIHRoZSBidWNrZXQuXG4gICAgICovXG4gICAgdXBsb2FkT3JVcGRhdGUobWV0aG9kLCBwYXRoLCBmaWxlQm9keSwgZmlsZU9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbGV0IGJvZHk7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVF9GSUxFX09QVElPTlMpLCBmaWxlT3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgbGV0IGhlYWRlcnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMuaGVhZGVycyksIChtZXRob2QgPT09ICdQT1NUJyAmJiB7ICd4LXVwc2VydCc6IFN0cmluZyhvcHRpb25zLnVwc2VydCkgfSkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1ldGFkYXRhID0gb3B0aW9ucy5tZXRhZGF0YTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIEJsb2IgIT09ICd1bmRlZmluZWQnICYmIGZpbGVCb2R5IGluc3RhbmNlb2YgQmxvYikge1xuICAgICAgICAgICAgICAgICAgICBib2R5ID0gbmV3IEZvcm1EYXRhKCk7XG4gICAgICAgICAgICAgICAgICAgIGJvZHkuYXBwZW5kKCdjYWNoZUNvbnRyb2wnLCBvcHRpb25zLmNhY2hlQ29udHJvbCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtZXRhZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYm9keS5hcHBlbmQoJ21ldGFkYXRhJywgdGhpcy5lbmNvZGVNZXRhZGF0YShtZXRhZGF0YSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJvZHkuYXBwZW5kKCcnLCBmaWxlQm9keSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBGb3JtRGF0YSAhPT0gJ3VuZGVmaW5lZCcgJiYgZmlsZUJvZHkgaW5zdGFuY2VvZiBGb3JtRGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBib2R5ID0gZmlsZUJvZHk7XG4gICAgICAgICAgICAgICAgICAgIGJvZHkuYXBwZW5kKCdjYWNoZUNvbnRyb2wnLCBvcHRpb25zLmNhY2hlQ29udHJvbCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtZXRhZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYm9keS5hcHBlbmQoJ21ldGFkYXRhJywgdGhpcy5lbmNvZGVNZXRhZGF0YShtZXRhZGF0YSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBib2R5ID0gZmlsZUJvZHk7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnNbJ2NhY2hlLWNvbnRyb2wnXSA9IGBtYXgtYWdlPSR7b3B0aW9ucy5jYWNoZUNvbnRyb2x9YDtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyc1snY29udGVudC10eXBlJ10gPSBvcHRpb25zLmNvbnRlbnRUeXBlO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnNbJ3gtbWV0YWRhdGEnXSA9IHRoaXMudG9CYXNlNjQodGhpcy5lbmNvZGVNZXRhZGF0YShtZXRhZGF0YSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChmaWxlT3B0aW9ucyA9PT0gbnVsbCB8fCBmaWxlT3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZmlsZU9wdGlvbnMuaGVhZGVycykge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBoZWFkZXJzKSwgZmlsZU9wdGlvbnMuaGVhZGVycyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGNsZWFuUGF0aCA9IHRoaXMuX3JlbW92ZUVtcHR5Rm9sZGVycyhwYXRoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBfcGF0aCA9IHRoaXMuX2dldEZpbmFsUGF0aChjbGVhblBhdGgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSB5aWVsZCAobWV0aG9kID09ICdQVVQnID8gcHV0IDogcG9zdCkodGhpcy5mZXRjaCwgYCR7dGhpcy51cmx9L29iamVjdC8ke19wYXRofWAsIGJvZHksIE9iamVjdC5hc3NpZ24oeyBoZWFkZXJzIH0sICgob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmR1cGxleCkgPyB7IGR1cGxleDogb3B0aW9ucy5kdXBsZXggfSA6IHt9KSkpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHsgcGF0aDogY2xlYW5QYXRoLCBpZDogZGF0YS5JZCwgZnVsbFBhdGg6IGRhdGEuS2V5IH0sXG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zaG91bGRUaHJvd09uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpc1N0b3JhZ2VFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGxvYWRzIGEgZmlsZSB0byBhbiBleGlzdGluZyBidWNrZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGF0aCBUaGUgZmlsZSBwYXRoLCBpbmNsdWRpbmcgdGhlIGZpbGUgbmFtZS4gU2hvdWxkIGJlIG9mIHRoZSBmb3JtYXQgYGZvbGRlci9zdWJmb2xkZXIvZmlsZW5hbWUucG5nYC4gVGhlIGJ1Y2tldCBtdXN0IGFscmVhZHkgZXhpc3QgYmVmb3JlIGF0dGVtcHRpbmcgdG8gdXBsb2FkLlxuICAgICAqIEBwYXJhbSBmaWxlQm9keSBUaGUgYm9keSBvZiB0aGUgZmlsZSB0byBiZSBzdG9yZWQgaW4gdGhlIGJ1Y2tldC5cbiAgICAgKi9cbiAgICB1cGxvYWQocGF0aCwgZmlsZUJvZHksIGZpbGVPcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy51cGxvYWRPclVwZGF0ZSgnUE9TVCcsIHBhdGgsIGZpbGVCb2R5LCBmaWxlT3B0aW9ucyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGxvYWQgYSBmaWxlIHdpdGggYSB0b2tlbiBnZW5lcmF0ZWQgZnJvbSBgY3JlYXRlU2lnbmVkVXBsb2FkVXJsYC5cbiAgICAgKiBAcGFyYW0gcGF0aCBUaGUgZmlsZSBwYXRoLCBpbmNsdWRpbmcgdGhlIGZpbGUgbmFtZS4gU2hvdWxkIGJlIG9mIHRoZSBmb3JtYXQgYGZvbGRlci9zdWJmb2xkZXIvZmlsZW5hbWUucG5nYC4gVGhlIGJ1Y2tldCBtdXN0IGFscmVhZHkgZXhpc3QgYmVmb3JlIGF0dGVtcHRpbmcgdG8gdXBsb2FkLlxuICAgICAqIEBwYXJhbSB0b2tlbiBUaGUgdG9rZW4gZ2VuZXJhdGVkIGZyb20gYGNyZWF0ZVNpZ25lZFVwbG9hZFVybGBcbiAgICAgKiBAcGFyYW0gZmlsZUJvZHkgVGhlIGJvZHkgb2YgdGhlIGZpbGUgdG8gYmUgc3RvcmVkIGluIHRoZSBidWNrZXQuXG4gICAgICovXG4gICAgdXBsb2FkVG9TaWduZWRVcmwocGF0aCwgdG9rZW4sIGZpbGVCb2R5LCBmaWxlT3B0aW9ucykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgY2xlYW5QYXRoID0gdGhpcy5fcmVtb3ZlRW1wdHlGb2xkZXJzKHBhdGgpO1xuICAgICAgICAgICAgY29uc3QgX3BhdGggPSB0aGlzLl9nZXRGaW5hbFBhdGgoY2xlYW5QYXRoKTtcbiAgICAgICAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwodGhpcy51cmwgKyBgL29iamVjdC91cGxvYWQvc2lnbi8ke19wYXRofWApO1xuICAgICAgICAgICAgdXJsLnNlYXJjaFBhcmFtcy5zZXQoJ3Rva2VuJywgdG9rZW4pO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBsZXQgYm9keTtcbiAgICAgICAgICAgICAgICBjb25zdCBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7IHVwc2VydDogREVGQVVMVF9GSUxFX09QVElPTlMudXBzZXJ0IH0sIGZpbGVPcHRpb25zKTtcbiAgICAgICAgICAgICAgICBjb25zdCBoZWFkZXJzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmhlYWRlcnMpLCB7ICd4LXVwc2VydCc6IFN0cmluZyhvcHRpb25zLnVwc2VydCkgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBCbG9iICE9PSAndW5kZWZpbmVkJyAmJiBmaWxlQm9keSBpbnN0YW5jZW9mIEJsb2IpIHtcbiAgICAgICAgICAgICAgICAgICAgYm9keSA9IG5ldyBGb3JtRGF0YSgpO1xuICAgICAgICAgICAgICAgICAgICBib2R5LmFwcGVuZCgnY2FjaGVDb250cm9sJywgb3B0aW9ucy5jYWNoZUNvbnRyb2wpO1xuICAgICAgICAgICAgICAgICAgICBib2R5LmFwcGVuZCgnJywgZmlsZUJvZHkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgRm9ybURhdGEgIT09ICd1bmRlZmluZWQnICYmIGZpbGVCb2R5IGluc3RhbmNlb2YgRm9ybURhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgYm9keSA9IGZpbGVCb2R5O1xuICAgICAgICAgICAgICAgICAgICBib2R5LmFwcGVuZCgnY2FjaGVDb250cm9sJywgb3B0aW9ucy5jYWNoZUNvbnRyb2wpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYm9keSA9IGZpbGVCb2R5O1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzWydjYWNoZS1jb250cm9sJ10gPSBgbWF4LWFnZT0ke29wdGlvbnMuY2FjaGVDb250cm9sfWA7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddID0gb3B0aW9ucy5jb250ZW50VHlwZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IHlpZWxkIHB1dCh0aGlzLmZldGNoLCB1cmwudG9TdHJpbmcoKSwgYm9keSwgeyBoZWFkZXJzIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHsgcGF0aDogY2xlYW5QYXRoLCBmdWxsUGF0aDogZGF0YS5LZXkgfSxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNob3VsZFRocm93T25FcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlzU3RvcmFnZUVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzaWduZWQgdXBsb2FkIFVSTC5cbiAgICAgKiBTaWduZWQgdXBsb2FkIFVSTHMgY2FuIGJlIHVzZWQgdG8gdXBsb2FkIGZpbGVzIHRvIHRoZSBidWNrZXQgd2l0aG91dCBmdXJ0aGVyIGF1dGhlbnRpY2F0aW9uLlxuICAgICAqIFRoZXkgYXJlIHZhbGlkIGZvciAyIGhvdXJzLlxuICAgICAqIEBwYXJhbSBwYXRoIFRoZSBmaWxlIHBhdGgsIGluY2x1ZGluZyB0aGUgY3VycmVudCBmaWxlIG5hbWUuIEZvciBleGFtcGxlIGBmb2xkZXIvaW1hZ2UucG5nYC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy51cHNlcnQgSWYgc2V0IHRvIHRydWUsIGFsbG93cyB0aGUgZmlsZSB0byBiZSBvdmVyd3JpdHRlbiBpZiBpdCBhbHJlYWR5IGV4aXN0cy5cbiAgICAgKi9cbiAgICBjcmVhdGVTaWduZWRVcGxvYWRVcmwocGF0aCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBsZXQgX3BhdGggPSB0aGlzLl9nZXRGaW5hbFBhdGgocGF0aCk7XG4gICAgICAgICAgICAgICAgY29uc3QgaGVhZGVycyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuaGVhZGVycyk7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy51cHNlcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyc1sneC11cHNlcnQnXSA9ICd0cnVlJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IHlpZWxkIHBvc3QodGhpcy5mZXRjaCwgYCR7dGhpcy51cmx9L29iamVjdC91cGxvYWQvc2lnbi8ke19wYXRofWAsIHt9LCB7IGhlYWRlcnMgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdXJsID0gbmV3IFVSTCh0aGlzLnVybCArIGRhdGEudXJsKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0b2tlbiA9IHVybC5zZWFyY2hQYXJhbXMuZ2V0KCd0b2tlbicpO1xuICAgICAgICAgICAgICAgIGlmICghdG9rZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFN0b3JhZ2VFcnJvcignTm8gdG9rZW4gcmV0dXJuZWQgYnkgQVBJJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgc2lnbmVkVXJsOiB1cmwudG9TdHJpbmcoKSwgcGF0aCwgdG9rZW4gfSwgZXJyb3I6IG51bGwgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNob3VsZFRocm93T25FcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlzU3RvcmFnZUVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlcGxhY2VzIGFuIGV4aXN0aW5nIGZpbGUgYXQgdGhlIHNwZWNpZmllZCBwYXRoIHdpdGggYSBuZXcgb25lLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhdGggVGhlIHJlbGF0aXZlIGZpbGUgcGF0aC4gU2hvdWxkIGJlIG9mIHRoZSBmb3JtYXQgYGZvbGRlci9zdWJmb2xkZXIvZmlsZW5hbWUucG5nYC4gVGhlIGJ1Y2tldCBtdXN0IGFscmVhZHkgZXhpc3QgYmVmb3JlIGF0dGVtcHRpbmcgdG8gdXBkYXRlLlxuICAgICAqIEBwYXJhbSBmaWxlQm9keSBUaGUgYm9keSBvZiB0aGUgZmlsZSB0byBiZSBzdG9yZWQgaW4gdGhlIGJ1Y2tldC5cbiAgICAgKi9cbiAgICB1cGRhdGUocGF0aCwgZmlsZUJvZHksIGZpbGVPcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy51cGxvYWRPclVwZGF0ZSgnUFVUJywgcGF0aCwgZmlsZUJvZHksIGZpbGVPcHRpb25zKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1vdmVzIGFuIGV4aXN0aW5nIGZpbGUgdG8gYSBuZXcgcGF0aCBpbiB0aGUgc2FtZSBidWNrZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZnJvbVBhdGggVGhlIG9yaWdpbmFsIGZpbGUgcGF0aCwgaW5jbHVkaW5nIHRoZSBjdXJyZW50IGZpbGUgbmFtZS4gRm9yIGV4YW1wbGUgYGZvbGRlci9pbWFnZS5wbmdgLlxuICAgICAqIEBwYXJhbSB0b1BhdGggVGhlIG5ldyBmaWxlIHBhdGgsIGluY2x1ZGluZyB0aGUgbmV3IGZpbGUgbmFtZS4gRm9yIGV4YW1wbGUgYGZvbGRlci9pbWFnZS1uZXcucG5nYC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBUaGUgZGVzdGluYXRpb24gb3B0aW9ucy5cbiAgICAgKi9cbiAgICBtb3ZlKGZyb21QYXRoLCB0b1BhdGgsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IHlpZWxkIHBvc3QodGhpcy5mZXRjaCwgYCR7dGhpcy51cmx9L29iamVjdC9tb3ZlYCwge1xuICAgICAgICAgICAgICAgICAgICBidWNrZXRJZDogdGhpcy5idWNrZXRJZCxcbiAgICAgICAgICAgICAgICAgICAgc291cmNlS2V5OiBmcm9tUGF0aCxcbiAgICAgICAgICAgICAgICAgICAgZGVzdGluYXRpb25LZXk6IHRvUGF0aCxcbiAgICAgICAgICAgICAgICAgICAgZGVzdGluYXRpb25CdWNrZXQ6IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5kZXN0aW5hdGlvbkJ1Y2tldCxcbiAgICAgICAgICAgICAgICB9LCB7IGhlYWRlcnM6IHRoaXMuaGVhZGVycyB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhLCBlcnJvcjogbnVsbCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2hvdWxkVGhyb3dPbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXNTdG9yYWdlRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29waWVzIGFuIGV4aXN0aW5nIGZpbGUgdG8gYSBuZXcgcGF0aCBpbiB0aGUgc2FtZSBidWNrZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZnJvbVBhdGggVGhlIG9yaWdpbmFsIGZpbGUgcGF0aCwgaW5jbHVkaW5nIHRoZSBjdXJyZW50IGZpbGUgbmFtZS4gRm9yIGV4YW1wbGUgYGZvbGRlci9pbWFnZS5wbmdgLlxuICAgICAqIEBwYXJhbSB0b1BhdGggVGhlIG5ldyBmaWxlIHBhdGgsIGluY2x1ZGluZyB0aGUgbmV3IGZpbGUgbmFtZS4gRm9yIGV4YW1wbGUgYGZvbGRlci9pbWFnZS1jb3B5LnBuZ2AuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgVGhlIGRlc3RpbmF0aW9uIG9wdGlvbnMuXG4gICAgICovXG4gICAgY29weShmcm9tUGF0aCwgdG9QYXRoLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSB5aWVsZCBwb3N0KHRoaXMuZmV0Y2gsIGAke3RoaXMudXJsfS9vYmplY3QvY29weWAsIHtcbiAgICAgICAgICAgICAgICAgICAgYnVja2V0SWQ6IHRoaXMuYnVja2V0SWQsXG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZUtleTogZnJvbVBhdGgsXG4gICAgICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uS2V5OiB0b1BhdGgsXG4gICAgICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uQnVja2V0OiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZGVzdGluYXRpb25CdWNrZXQsXG4gICAgICAgICAgICAgICAgfSwgeyBoZWFkZXJzOiB0aGlzLmhlYWRlcnMgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyBwYXRoOiBkYXRhLktleSB9LCBlcnJvcjogbnVsbCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2hvdWxkVGhyb3dPbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXNTdG9yYWdlRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNpZ25lZCBVUkwuIFVzZSBhIHNpZ25lZCBVUkwgdG8gc2hhcmUgYSBmaWxlIGZvciBhIGZpeGVkIGFtb3VudCBvZiB0aW1lLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhdGggVGhlIGZpbGUgcGF0aCwgaW5jbHVkaW5nIHRoZSBjdXJyZW50IGZpbGUgbmFtZS4gRm9yIGV4YW1wbGUgYGZvbGRlci9pbWFnZS5wbmdgLlxuICAgICAqIEBwYXJhbSBleHBpcmVzSW4gVGhlIG51bWJlciBvZiBzZWNvbmRzIHVudGlsIHRoZSBzaWduZWQgVVJMIGV4cGlyZXMuIEZvciBleGFtcGxlLCBgNjBgIGZvciBhIFVSTCB3aGljaCBpcyB2YWxpZCBmb3Igb25lIG1pbnV0ZS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5kb3dubG9hZCB0cmlnZ2VycyB0aGUgZmlsZSBhcyBhIGRvd25sb2FkIGlmIHNldCB0byB0cnVlLiBTZXQgdGhpcyBwYXJhbWV0ZXIgYXMgdGhlIG5hbWUgb2YgdGhlIGZpbGUgaWYgeW91IHdhbnQgdG8gdHJpZ2dlciB0aGUgZG93bmxvYWQgd2l0aCBhIGRpZmZlcmVudCBmaWxlbmFtZS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy50cmFuc2Zvcm0gVHJhbnNmb3JtIHRoZSBhc3NldCBiZWZvcmUgc2VydmluZyBpdCB0byB0aGUgY2xpZW50LlxuICAgICAqL1xuICAgIGNyZWF0ZVNpZ25lZFVybChwYXRoLCBleHBpcmVzSW4sIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbGV0IF9wYXRoID0gdGhpcy5fZ2V0RmluYWxQYXRoKHBhdGgpO1xuICAgICAgICAgICAgICAgIGxldCBkYXRhID0geWllbGQgcG9zdCh0aGlzLmZldGNoLCBgJHt0aGlzLnVybH0vb2JqZWN0L3NpZ24vJHtfcGF0aH1gLCBPYmplY3QuYXNzaWduKHsgZXhwaXJlc0luIH0sICgob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnRyYW5zZm9ybSkgPyB7IHRyYW5zZm9ybTogb3B0aW9ucy50cmFuc2Zvcm0gfSA6IHt9KSksIHsgaGVhZGVyczogdGhpcy5oZWFkZXJzIH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRvd25sb2FkUXVlcnlQYXJhbSA9IChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZG93bmxvYWQpXG4gICAgICAgICAgICAgICAgICAgID8gYCZkb3dubG9hZD0ke29wdGlvbnMuZG93bmxvYWQgPT09IHRydWUgPyAnJyA6IG9wdGlvbnMuZG93bmxvYWR9YFxuICAgICAgICAgICAgICAgICAgICA6ICcnO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNpZ25lZFVybCA9IGVuY29kZVVSSShgJHt0aGlzLnVybH0ke2RhdGEuc2lnbmVkVVJMfSR7ZG93bmxvYWRRdWVyeVBhcmFtfWApO1xuICAgICAgICAgICAgICAgIGRhdGEgPSB7IHNpZ25lZFVybCB9O1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGEsIGVycm9yOiBudWxsIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zaG91bGRUaHJvd09uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpc1N0b3JhZ2VFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIG11bHRpcGxlIHNpZ25lZCBVUkxzLiBVc2UgYSBzaWduZWQgVVJMIHRvIHNoYXJlIGEgZmlsZSBmb3IgYSBmaXhlZCBhbW91bnQgb2YgdGltZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXRocyBUaGUgZmlsZSBwYXRocyB0byBiZSBkb3dubG9hZGVkLCBpbmNsdWRpbmcgdGhlIGN1cnJlbnQgZmlsZSBuYW1lcy4gRm9yIGV4YW1wbGUgYFsnZm9sZGVyL2ltYWdlLnBuZycsICdmb2xkZXIyL2ltYWdlMi5wbmcnXWAuXG4gICAgICogQHBhcmFtIGV4cGlyZXNJbiBUaGUgbnVtYmVyIG9mIHNlY29uZHMgdW50aWwgdGhlIHNpZ25lZCBVUkxzIGV4cGlyZS4gRm9yIGV4YW1wbGUsIGA2MGAgZm9yIFVSTHMgd2hpY2ggYXJlIHZhbGlkIGZvciBvbmUgbWludXRlLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmRvd25sb2FkIHRyaWdnZXJzIHRoZSBmaWxlIGFzIGEgZG93bmxvYWQgaWYgc2V0IHRvIHRydWUuIFNldCB0aGlzIHBhcmFtZXRlciBhcyB0aGUgbmFtZSBvZiB0aGUgZmlsZSBpZiB5b3Ugd2FudCB0byB0cmlnZ2VyIHRoZSBkb3dubG9hZCB3aXRoIGEgZGlmZmVyZW50IGZpbGVuYW1lLlxuICAgICAqL1xuICAgIGNyZWF0ZVNpZ25lZFVybHMocGF0aHMsIGV4cGlyZXNJbiwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0geWllbGQgcG9zdCh0aGlzLmZldGNoLCBgJHt0aGlzLnVybH0vb2JqZWN0L3NpZ24vJHt0aGlzLmJ1Y2tldElkfWAsIHsgZXhwaXJlc0luLCBwYXRocyB9LCB7IGhlYWRlcnM6IHRoaXMuaGVhZGVycyB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCBkb3dubG9hZFF1ZXJ5UGFyYW0gPSAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmRvd25sb2FkKVxuICAgICAgICAgICAgICAgICAgICA/IGAmZG93bmxvYWQ9JHtvcHRpb25zLmRvd25sb2FkID09PSB0cnVlID8gJycgOiBvcHRpb25zLmRvd25sb2FkfWBcbiAgICAgICAgICAgICAgICAgICAgOiAnJztcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiBkYXRhLm1hcCgoZGF0dW0pID0+IChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRhdHVtKSwgeyBzaWduZWRVcmw6IGRhdHVtLnNpZ25lZFVSTFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gZW5jb2RlVVJJKGAke3RoaXMudXJsfSR7ZGF0dW0uc2lnbmVkVVJMfSR7ZG93bmxvYWRRdWVyeVBhcmFtfWApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBudWxsIH0pKSksXG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zaG91bGRUaHJvd09uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpc1N0b3JhZ2VFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEb3dubG9hZHMgYSBmaWxlIGZyb20gYSBwcml2YXRlIGJ1Y2tldC4gRm9yIHB1YmxpYyBidWNrZXRzLCBtYWtlIGEgcmVxdWVzdCB0byB0aGUgVVJMIHJldHVybmVkIGZyb20gYGdldFB1YmxpY1VybGAgaW5zdGVhZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXRoIFRoZSBmdWxsIHBhdGggYW5kIGZpbGUgbmFtZSBvZiB0aGUgZmlsZSB0byBiZSBkb3dubG9hZGVkLiBGb3IgZXhhbXBsZSBgZm9sZGVyL2ltYWdlLnBuZ2AuXG4gICAgICogQHBhcmFtIG9wdGlvbnMudHJhbnNmb3JtIFRyYW5zZm9ybSB0aGUgYXNzZXQgYmVmb3JlIHNlcnZpbmcgaXQgdG8gdGhlIGNsaWVudC5cbiAgICAgKi9cbiAgICBkb3dubG9hZChwYXRoLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHdhbnRzVHJhbnNmb3JtYXRpb24gPSB0eXBlb2YgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy50cmFuc2Zvcm0pICE9PSAndW5kZWZpbmVkJztcbiAgICAgICAgY29uc3QgcmVuZGVyUGF0aCA9IHdhbnRzVHJhbnNmb3JtYXRpb24gPyAncmVuZGVyL2ltYWdlL2F1dGhlbnRpY2F0ZWQnIDogJ29iamVjdCc7XG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybWF0aW9uUXVlcnkgPSB0aGlzLnRyYW5zZm9ybU9wdHNUb1F1ZXJ5U3RyaW5nKChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudHJhbnNmb3JtKSB8fCB7fSk7XG4gICAgICAgIGNvbnN0IHF1ZXJ5U3RyaW5nID0gdHJhbnNmb3JtYXRpb25RdWVyeSA/IGA/JHt0cmFuc2Zvcm1hdGlvblF1ZXJ5fWAgOiAnJztcbiAgICAgICAgY29uc3QgX3BhdGggPSB0aGlzLl9nZXRGaW5hbFBhdGgocGF0aCk7XG4gICAgICAgIGNvbnN0IGRvd25sb2FkRm4gPSAoKSA9PiBnZXQodGhpcy5mZXRjaCwgYCR7dGhpcy51cmx9LyR7cmVuZGVyUGF0aH0vJHtfcGF0aH0ke3F1ZXJ5U3RyaW5nfWAsIHtcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgIG5vUmVzb2x2ZUpzb246IHRydWUsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV3IEJsb2JEb3dubG9hZEJ1aWxkZXIoZG93bmxvYWRGbiwgdGhpcy5zaG91bGRUaHJvd09uRXJyb3IpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIGRldGFpbHMgb2YgYW4gZXhpc3RpbmcgZmlsZS5cbiAgICAgKiBAcGFyYW0gcGF0aFxuICAgICAqL1xuICAgIGluZm8ocGF0aCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgX3BhdGggPSB0aGlzLl9nZXRGaW5hbFBhdGgocGF0aCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSB5aWVsZCBnZXQodGhpcy5mZXRjaCwgYCR7dGhpcy51cmx9L29iamVjdC9pbmZvLyR7X3BhdGh9YCwge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogcmVjdXJzaXZlVG9DYW1lbChkYXRhKSwgZXJyb3I6IG51bGwgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNob3VsZFRocm93T25FcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlzU3RvcmFnZUVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrcyB0aGUgZXhpc3RlbmNlIG9mIGEgZmlsZS5cbiAgICAgKiBAcGFyYW0gcGF0aFxuICAgICAqL1xuICAgIGV4aXN0cyhwYXRoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBfcGF0aCA9IHRoaXMuX2dldEZpbmFsUGF0aChwYXRoKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgeWllbGQgaGVhZCh0aGlzLmZldGNoLCBgJHt0aGlzLnVybH0vb2JqZWN0LyR7X3BhdGh9YCwge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogdHJ1ZSwgZXJyb3I6IG51bGwgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNob3VsZFRocm93T25FcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlzU3RvcmFnZUVycm9yKGVycm9yKSAmJiBlcnJvciBpbnN0YW5jZW9mIFN0b3JhZ2VVbmtub3duRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxFcnJvciA9IGVycm9yLm9yaWdpbmFsRXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIGlmIChbNDAwLCA0MDRdLmluY2x1ZGVzKG9yaWdpbmFsRXJyb3IgPT09IG51bGwgfHwgb3JpZ2luYWxFcnJvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3JpZ2luYWxFcnJvci5zdGF0dXMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBmYWxzZSwgZXJyb3IgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgc2ltcGxlIGNvbnZlbmllbmNlIGZ1bmN0aW9uIHRvIGdldCB0aGUgVVJMIGZvciBhbiBhc3NldCBpbiBhIHB1YmxpYyBidWNrZXQuIElmIHlvdSBkbyBub3Qgd2FudCB0byB1c2UgdGhpcyBmdW5jdGlvbiwgeW91IGNhbiBjb25zdHJ1Y3QgdGhlIHB1YmxpYyBVUkwgYnkgY29uY2F0ZW5hdGluZyB0aGUgYnVja2V0IFVSTCB3aXRoIHRoZSBwYXRoIHRvIHRoZSBhc3NldC5cbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGRvZXMgbm90IHZlcmlmeSBpZiB0aGUgYnVja2V0IGlzIHB1YmxpYy4gSWYgYSBwdWJsaWMgVVJMIGlzIGNyZWF0ZWQgZm9yIGEgYnVja2V0IHdoaWNoIGlzIG5vdCBwdWJsaWMsIHlvdSB3aWxsIG5vdCBiZSBhYmxlIHRvIGRvd25sb2FkIHRoZSBhc3NldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXRoIFRoZSBwYXRoIGFuZCBuYW1lIG9mIHRoZSBmaWxlIHRvIGdlbmVyYXRlIHRoZSBwdWJsaWMgVVJMIGZvci4gRm9yIGV4YW1wbGUgYGZvbGRlci9pbWFnZS5wbmdgLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmRvd25sb2FkIFRyaWdnZXJzIHRoZSBmaWxlIGFzIGEgZG93bmxvYWQgaWYgc2V0IHRvIHRydWUuIFNldCB0aGlzIHBhcmFtZXRlciBhcyB0aGUgbmFtZSBvZiB0aGUgZmlsZSBpZiB5b3Ugd2FudCB0byB0cmlnZ2VyIHRoZSBkb3dubG9hZCB3aXRoIGEgZGlmZmVyZW50IGZpbGVuYW1lLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLnRyYW5zZm9ybSBUcmFuc2Zvcm0gdGhlIGFzc2V0IGJlZm9yZSBzZXJ2aW5nIGl0IHRvIHRoZSBjbGllbnQuXG4gICAgICovXG4gICAgZ2V0UHVibGljVXJsKHBhdGgsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgX3BhdGggPSB0aGlzLl9nZXRGaW5hbFBhdGgocGF0aCk7XG4gICAgICAgIGNvbnN0IF9xdWVyeVN0cmluZyA9IFtdO1xuICAgICAgICBjb25zdCBkb3dubG9hZFF1ZXJ5UGFyYW0gPSAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmRvd25sb2FkKVxuICAgICAgICAgICAgPyBgZG93bmxvYWQ9JHtvcHRpb25zLmRvd25sb2FkID09PSB0cnVlID8gJycgOiBvcHRpb25zLmRvd25sb2FkfWBcbiAgICAgICAgICAgIDogJyc7XG4gICAgICAgIGlmIChkb3dubG9hZFF1ZXJ5UGFyYW0gIT09ICcnKSB7XG4gICAgICAgICAgICBfcXVlcnlTdHJpbmcucHVzaChkb3dubG9hZFF1ZXJ5UGFyYW0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHdhbnRzVHJhbnNmb3JtYXRpb24gPSB0eXBlb2YgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy50cmFuc2Zvcm0pICE9PSAndW5kZWZpbmVkJztcbiAgICAgICAgY29uc3QgcmVuZGVyUGF0aCA9IHdhbnRzVHJhbnNmb3JtYXRpb24gPyAncmVuZGVyL2ltYWdlJyA6ICdvYmplY3QnO1xuICAgICAgICBjb25zdCB0cmFuc2Zvcm1hdGlvblF1ZXJ5ID0gdGhpcy50cmFuc2Zvcm1PcHRzVG9RdWVyeVN0cmluZygob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnRyYW5zZm9ybSkgfHwge30pO1xuICAgICAgICBpZiAodHJhbnNmb3JtYXRpb25RdWVyeSAhPT0gJycpIHtcbiAgICAgICAgICAgIF9xdWVyeVN0cmluZy5wdXNoKHRyYW5zZm9ybWF0aW9uUXVlcnkpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBxdWVyeVN0cmluZyA9IF9xdWVyeVN0cmluZy5qb2luKCcmJyk7XG4gICAgICAgIGlmIChxdWVyeVN0cmluZyAhPT0gJycpIHtcbiAgICAgICAgICAgIHF1ZXJ5U3RyaW5nID0gYD8ke3F1ZXJ5U3RyaW5nfWA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRhdGE6IHsgcHVibGljVXJsOiBlbmNvZGVVUkkoYCR7dGhpcy51cmx9LyR7cmVuZGVyUGF0aH0vcHVibGljLyR7X3BhdGh9JHtxdWVyeVN0cmluZ31gKSB9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGVzIGZpbGVzIHdpdGhpbiB0aGUgc2FtZSBidWNrZXRcbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXRocyBBbiBhcnJheSBvZiBmaWxlcyB0byBkZWxldGUsIGluY2x1ZGluZyB0aGUgcGF0aCBhbmQgZmlsZSBuYW1lLiBGb3IgZXhhbXBsZSBbYCdmb2xkZXIvaW1hZ2UucG5nJ2BdLlxuICAgICAqL1xuICAgIHJlbW92ZShwYXRocykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0geWllbGQgcmVtb3ZlKHRoaXMuZmV0Y2gsIGAke3RoaXMudXJsfS9vYmplY3QvJHt0aGlzLmJ1Y2tldElkfWAsIHsgcHJlZml4ZXM6IHBhdGhzIH0sIHsgaGVhZGVyczogdGhpcy5oZWFkZXJzIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGEsIGVycm9yOiBudWxsIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zaG91bGRUaHJvd09uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpc1N0b3JhZ2VFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgZmlsZSBtZXRhZGF0YVxuICAgICAqIEBwYXJhbSBpZCB0aGUgZmlsZSBpZCB0byByZXRyaWV2ZSBtZXRhZGF0YVxuICAgICAqL1xuICAgIC8vIGFzeW5jIGdldE1ldGFkYXRhKFxuICAgIC8vICAgaWQ6IHN0cmluZ1xuICAgIC8vICk6IFByb21pc2U8XG4gICAgLy8gICB8IHtcbiAgICAvLyAgICAgICBkYXRhOiBNZXRhZGF0YVxuICAgIC8vICAgICAgIGVycm9yOiBudWxsXG4gICAgLy8gICAgIH1cbiAgICAvLyAgIHwge1xuICAgIC8vICAgICAgIGRhdGE6IG51bGxcbiAgICAvLyAgICAgICBlcnJvcjogU3RvcmFnZUVycm9yXG4gICAgLy8gICAgIH1cbiAgICAvLyA+IHtcbiAgICAvLyAgIHRyeSB7XG4gICAgLy8gICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBnZXQodGhpcy5mZXRjaCwgYCR7dGhpcy51cmx9L21ldGFkYXRhLyR7aWR9YCwgeyBoZWFkZXJzOiB0aGlzLmhlYWRlcnMgfSlcbiAgICAvLyAgICAgcmV0dXJuIHsgZGF0YSwgZXJyb3I6IG51bGwgfVxuICAgIC8vICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAvLyAgICAgaWYgKGlzU3RvcmFnZUVycm9yKGVycm9yKSkge1xuICAgIC8vICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH1cbiAgICAvLyAgICAgfVxuICAgIC8vICAgICB0aHJvdyBlcnJvclxuICAgIC8vICAgfVxuICAgIC8vIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgZmlsZSBtZXRhZGF0YVxuICAgICAqIEBwYXJhbSBpZCB0aGUgZmlsZSBpZCB0byB1cGRhdGUgbWV0YWRhdGFcbiAgICAgKiBAcGFyYW0gbWV0YSB0aGUgbmV3IGZpbGUgbWV0YWRhdGFcbiAgICAgKi9cbiAgICAvLyBhc3luYyB1cGRhdGVNZXRhZGF0YShcbiAgICAvLyAgIGlkOiBzdHJpbmcsXG4gICAgLy8gICBtZXRhOiBNZXRhZGF0YVxuICAgIC8vICk6IFByb21pc2U8XG4gICAgLy8gICB8IHtcbiAgICAvLyAgICAgICBkYXRhOiBNZXRhZGF0YVxuICAgIC8vICAgICAgIGVycm9yOiBudWxsXG4gICAgLy8gICAgIH1cbiAgICAvLyAgIHwge1xuICAgIC8vICAgICAgIGRhdGE6IG51bGxcbiAgICAvLyAgICAgICBlcnJvcjogU3RvcmFnZUVycm9yXG4gICAgLy8gICAgIH1cbiAgICAvLyA+IHtcbiAgICAvLyAgIHRyeSB7XG4gICAgLy8gICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBwb3N0KFxuICAgIC8vICAgICAgIHRoaXMuZmV0Y2gsXG4gICAgLy8gICAgICAgYCR7dGhpcy51cmx9L21ldGFkYXRhLyR7aWR9YCxcbiAgICAvLyAgICAgICB7IC4uLm1ldGEgfSxcbiAgICAvLyAgICAgICB7IGhlYWRlcnM6IHRoaXMuaGVhZGVycyB9XG4gICAgLy8gICAgIClcbiAgICAvLyAgICAgcmV0dXJuIHsgZGF0YSwgZXJyb3I6IG51bGwgfVxuICAgIC8vICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAvLyAgICAgaWYgKGlzU3RvcmFnZUVycm9yKGVycm9yKSkge1xuICAgIC8vICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH1cbiAgICAvLyAgICAgfVxuICAgIC8vICAgICB0aHJvdyBlcnJvclxuICAgIC8vICAgfVxuICAgIC8vIH1cbiAgICAvKipcbiAgICAgKiBMaXN0cyBhbGwgdGhlIGZpbGVzIGFuZCBmb2xkZXJzIHdpdGhpbiBhIHBhdGggb2YgdGhlIGJ1Y2tldC5cbiAgICAgKiBAcGFyYW0gcGF0aCBUaGUgZm9sZGVyIHBhdGguXG4gICAgICogQHBhcmFtIG9wdGlvbnMgU2VhcmNoIG9wdGlvbnMgaW5jbHVkaW5nIGxpbWl0IChkZWZhdWx0cyB0byAxMDApLCBvZmZzZXQsIHNvcnRCeSwgYW5kIHNlYXJjaFxuICAgICAqL1xuICAgIGxpc3QocGF0aCwgb3B0aW9ucywgcGFyYW1ldGVycykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBib2R5ID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIERFRkFVTFRfU0VBUkNIX09QVElPTlMpLCBvcHRpb25zKSwgeyBwcmVmaXg6IHBhdGggfHwgJycgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IHlpZWxkIHBvc3QodGhpcy5mZXRjaCwgYCR7dGhpcy51cmx9L29iamVjdC9saXN0LyR7dGhpcy5idWNrZXRJZH1gLCBib2R5LCB7IGhlYWRlcnM6IHRoaXMuaGVhZGVycyB9LCBwYXJhbWV0ZXJzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhLCBlcnJvcjogbnVsbCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2hvdWxkVGhyb3dPbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXNTdG9yYWdlRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGV4cGVyaW1lbnRhbCB0aGlzIG1ldGhvZCBzaWduYXR1cmUgbWlnaHQgY2hhbmdlIGluIHRoZSBmdXR1cmVcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBzZWFyY2ggb3B0aW9uc1xuICAgICAqIEBwYXJhbSBwYXJhbWV0ZXJzXG4gICAgICovXG4gICAgbGlzdFYyKG9wdGlvbnMsIHBhcmFtZXRlcnMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYm9keSA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSB5aWVsZCBwb3N0KHRoaXMuZmV0Y2gsIGAke3RoaXMudXJsfS9vYmplY3QvbGlzdC12Mi8ke3RoaXMuYnVja2V0SWR9YCwgYm9keSwgeyBoZWFkZXJzOiB0aGlzLmhlYWRlcnMgfSwgcGFyYW1ldGVycyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YSwgZXJyb3I6IG51bGwgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNob3VsZFRocm93T25FcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlzU3RvcmFnZUVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVuY29kZU1ldGFkYXRhKG1ldGFkYXRhKSB7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShtZXRhZGF0YSk7XG4gICAgfVxuICAgIHRvQmFzZTY0KGRhdGEpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBCdWZmZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20oZGF0YSkudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBidG9hKGRhdGEpO1xuICAgIH1cbiAgICBfZ2V0RmluYWxQYXRoKHBhdGgpIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuYnVja2V0SWR9LyR7cGF0aC5yZXBsYWNlKC9eXFwvKy8sICcnKX1gO1xuICAgIH1cbiAgICBfcmVtb3ZlRW1wdHlGb2xkZXJzKHBhdGgpIHtcbiAgICAgICAgcmV0dXJuIHBhdGgucmVwbGFjZSgvXlxcL3xcXC8kL2csICcnKS5yZXBsYWNlKC9cXC8rL2csICcvJyk7XG4gICAgfVxuICAgIHRyYW5zZm9ybU9wdHNUb1F1ZXJ5U3RyaW5nKHRyYW5zZm9ybSkge1xuICAgICAgICBjb25zdCBwYXJhbXMgPSBbXTtcbiAgICAgICAgaWYgKHRyYW5zZm9ybS53aWR0aCkge1xuICAgICAgICAgICAgcGFyYW1zLnB1c2goYHdpZHRoPSR7dHJhbnNmb3JtLndpZHRofWApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0cmFuc2Zvcm0uaGVpZ2h0KSB7XG4gICAgICAgICAgICBwYXJhbXMucHVzaChgaGVpZ2h0PSR7dHJhbnNmb3JtLmhlaWdodH1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHJhbnNmb3JtLnJlc2l6ZSkge1xuICAgICAgICAgICAgcGFyYW1zLnB1c2goYHJlc2l6ZT0ke3RyYW5zZm9ybS5yZXNpemV9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRyYW5zZm9ybS5mb3JtYXQpIHtcbiAgICAgICAgICAgIHBhcmFtcy5wdXNoKGBmb3JtYXQ9JHt0cmFuc2Zvcm0uZm9ybWF0fWApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0cmFuc2Zvcm0ucXVhbGl0eSkge1xuICAgICAgICAgICAgcGFyYW1zLnB1c2goYHF1YWxpdHk9JHt0cmFuc2Zvcm0ucXVhbGl0eX1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyYW1zLmpvaW4oJyYnKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TdG9yYWdlRmlsZUFwaS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/storage-js/dist/module/packages/StorageFileApi.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/storage-js/dist/module/packages/StreamDownloadBuilder.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@supabase/storage-js/dist/module/packages/StreamDownloadBuilder.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ StreamDownloadBuilder)\n/* harmony export */ });\n/* harmony import */ var _lib_errors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/errors */ \"(app-pages-browser)/./node_modules/@supabase/storage-js/dist/module/lib/errors.js\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\nclass StreamDownloadBuilder {\n    constructor(downloadFn, shouldThrowOnError) {\n        this.downloadFn = downloadFn;\n        this.shouldThrowOnError = shouldThrowOnError;\n    }\n    then(onfulfilled, onrejected) {\n        return this.execute().then(onfulfilled, onrejected);\n    }\n    execute() {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const result = yield this.downloadFn();\n                return {\n                    data: result.body,\n                    error: null,\n                };\n            }\n            catch (error) {\n                if (this.shouldThrowOnError) {\n                    throw error;\n                }\n                if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_0__.isStorageError)(error)) {\n                    return { data: null, error };\n                }\n                throw error;\n            }\n        });\n    }\n}\n//# sourceMappingURL=StreamDownloadBuilder.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2Uvc3RvcmFnZS1qcy9kaXN0L21vZHVsZS9wYWNrYWdlcy9TdHJlYW1Eb3dubG9hZEJ1aWxkZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxpQkFBaUIsU0FBSSxJQUFJLFNBQUk7QUFDN0IsNEJBQTRCLCtEQUErRCxpQkFBaUI7QUFDNUc7QUFDQSxvQ0FBb0MsTUFBTSwrQkFBK0IsWUFBWTtBQUNyRixtQ0FBbUMsTUFBTSxtQ0FBbUMsWUFBWTtBQUN4RixnQ0FBZ0M7QUFDaEM7QUFDQSxLQUFLO0FBQ0w7QUFDK0M7QUFDaEM7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDJEQUFjO0FBQ2xDLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBIiwic291cmNlcyI6WyJEOlxcbmV4dFxcb3JnXFxub2RlX21vZHVsZXNcXEBzdXBhYmFzZVxcc3RvcmFnZS1qc1xcZGlzdFxcbW9kdWxlXFxwYWNrYWdlc1xcU3RyZWFtRG93bmxvYWRCdWlsZGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuaW1wb3J0IHsgaXNTdG9yYWdlRXJyb3IgfSBmcm9tICcuLi9saWIvZXJyb3JzJztcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN0cmVhbURvd25sb2FkQnVpbGRlciB7XG4gICAgY29uc3RydWN0b3IoZG93bmxvYWRGbiwgc2hvdWxkVGhyb3dPbkVycm9yKSB7XG4gICAgICAgIHRoaXMuZG93bmxvYWRGbiA9IGRvd25sb2FkRm47XG4gICAgICAgIHRoaXMuc2hvdWxkVGhyb3dPbkVycm9yID0gc2hvdWxkVGhyb3dPbkVycm9yO1xuICAgIH1cbiAgICB0aGVuKG9uZnVsZmlsbGVkLCBvbnJlamVjdGVkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmV4ZWN1dGUoKS50aGVuKG9uZnVsZmlsbGVkLCBvbnJlamVjdGVkKTtcbiAgICB9XG4gICAgZXhlY3V0ZSgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0geWllbGQgdGhpcy5kb3dubG9hZEZuKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogcmVzdWx0LmJvZHksXG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zaG91bGRUaHJvd09uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpc1N0b3JhZ2VFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVN0cmVhbURvd25sb2FkQnVpbGRlci5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/storage-js/dist/module/packages/StreamDownloadBuilder.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/supabase-js/dist/module/SupabaseClient.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@supabase/supabase-js/dist/module/SupabaseClient.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ SupabaseClient)\n/* harmony export */ });\n/* harmony import */ var _supabase_functions_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @supabase/functions-js */ \"(app-pages-browser)/./node_modules/@supabase/functions-js/dist/module/FunctionsClient.js\");\n/* harmony import */ var _supabase_postgrest_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @supabase/postgrest-js */ \"(app-pages-browser)/./node_modules/@supabase/postgrest-js/dist/esm/wrapper.mjs\");\n/* harmony import */ var _supabase_realtime_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @supabase/realtime-js */ \"(app-pages-browser)/./node_modules/@supabase/realtime-js/dist/module/index.js\");\n/* harmony import */ var _supabase_storage_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @supabase/storage-js */ \"(app-pages-browser)/./node_modules/@supabase/storage-js/dist/module/StorageClient.js\");\n/* harmony import */ var _lib_constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lib/constants */ \"(app-pages-browser)/./node_modules/@supabase/supabase-js/dist/module/lib/constants.js\");\n/* harmony import */ var _lib_fetch__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./lib/fetch */ \"(app-pages-browser)/./node_modules/@supabase/supabase-js/dist/module/lib/fetch.js\");\n/* harmony import */ var _lib_helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/helpers */ \"(app-pages-browser)/./node_modules/@supabase/supabase-js/dist/module/lib/helpers.js\");\n/* harmony import */ var _lib_SupabaseAuthClient__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./lib/SupabaseAuthClient */ \"(app-pages-browser)/./node_modules/@supabase/supabase-js/dist/module/lib/SupabaseAuthClient.js\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\n\n\n\n\n\n/**\n * Supabase Client.\n *\n * An isomorphic Javascript client for interacting with Postgres.\n */\nclass SupabaseClient {\n    /**\n     * Create a new client for use in the browser.\n     * @param supabaseUrl The unique Supabase URL which is supplied when you create a new project in your project dashboard.\n     * @param supabaseKey The unique Supabase Key which is supplied when you create a new project in your project dashboard.\n     * @param options.db.schema You can switch in between schemas. The schema needs to be on the list of exposed schemas inside Supabase.\n     * @param options.auth.autoRefreshToken Set to \"true\" if you want to automatically refresh the token before expiring.\n     * @param options.auth.persistSession Set to \"true\" if you want to automatically save the user session into local storage.\n     * @param options.auth.detectSessionInUrl Set to \"true\" if you want to automatically detects OAuth grants in the URL and signs in the user.\n     * @param options.realtime Options passed along to realtime-js constructor.\n     * @param options.storage Options passed along to the storage-js constructor.\n     * @param options.global.fetch A custom fetch implementation.\n     * @param options.global.headers Any additional headers to send with each network request.\n     */\n    constructor(supabaseUrl, supabaseKey, options) {\n        var _a, _b, _c;\n        this.supabaseUrl = supabaseUrl;\n        this.supabaseKey = supabaseKey;\n        const baseUrl = (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_2__.validateSupabaseUrl)(supabaseUrl);\n        if (!supabaseKey)\n            throw new Error('supabaseKey is required.');\n        this.realtimeUrl = new URL('realtime/v1', baseUrl);\n        this.realtimeUrl.protocol = this.realtimeUrl.protocol.replace('http', 'ws');\n        this.authUrl = new URL('auth/v1', baseUrl);\n        this.storageUrl = new URL('storage/v1', baseUrl);\n        this.functionsUrl = new URL('functions/v1', baseUrl);\n        // default storage key uses the supabase project ref as a namespace\n        const defaultStorageKey = `sb-${baseUrl.hostname.split('.')[0]}-auth-token`;\n        const DEFAULTS = {\n            db: _lib_constants__WEBPACK_IMPORTED_MODULE_3__.DEFAULT_DB_OPTIONS,\n            realtime: _lib_constants__WEBPACK_IMPORTED_MODULE_3__.DEFAULT_REALTIME_OPTIONS,\n            auth: Object.assign(Object.assign({}, _lib_constants__WEBPACK_IMPORTED_MODULE_3__.DEFAULT_AUTH_OPTIONS), { storageKey: defaultStorageKey }),\n            global: _lib_constants__WEBPACK_IMPORTED_MODULE_3__.DEFAULT_GLOBAL_OPTIONS,\n        };\n        const settings = (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_2__.applySettingDefaults)(options !== null && options !== void 0 ? options : {}, DEFAULTS);\n        this.storageKey = (_a = settings.auth.storageKey) !== null && _a !== void 0 ? _a : '';\n        this.headers = (_b = settings.global.headers) !== null && _b !== void 0 ? _b : {};\n        if (!settings.accessToken) {\n            this.auth = this._initSupabaseAuthClient((_c = settings.auth) !== null && _c !== void 0 ? _c : {}, this.headers, settings.global.fetch);\n        }\n        else {\n            this.accessToken = settings.accessToken;\n            this.auth = new Proxy({}, {\n                get: (_, prop) => {\n                    throw new Error(`@supabase/supabase-js: Supabase Client is configured with the accessToken option, accessing supabase.auth.${String(prop)} is not possible`);\n                },\n            });\n        }\n        this.fetch = (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_4__.fetchWithAuth)(supabaseKey, this._getAccessToken.bind(this), settings.global.fetch);\n        this.realtime = this._initRealtimeClient(Object.assign({ headers: this.headers, accessToken: this._getAccessToken.bind(this) }, settings.realtime));\n        this.rest = new _supabase_postgrest_js__WEBPACK_IMPORTED_MODULE_0__.PostgrestClient(new URL('rest/v1', baseUrl).href, {\n            headers: this.headers,\n            schema: settings.db.schema,\n            fetch: this.fetch,\n        });\n        this.storage = new _supabase_storage_js__WEBPACK_IMPORTED_MODULE_5__.StorageClient(this.storageUrl.href, this.headers, this.fetch, options === null || options === void 0 ? void 0 : options.storage);\n        if (!settings.accessToken) {\n            this._listenForAuthEvents();\n        }\n    }\n    /**\n     * Supabase Functions allows you to deploy and invoke edge functions.\n     */\n    get functions() {\n        return new _supabase_functions_js__WEBPACK_IMPORTED_MODULE_6__.FunctionsClient(this.functionsUrl.href, {\n            headers: this.headers,\n            customFetch: this.fetch,\n        });\n    }\n    /**\n     * Perform a query on a table or a view.\n     *\n     * @param relation - The table or view name to query\n     */\n    from(relation) {\n        return this.rest.from(relation);\n    }\n    // NOTE: signatures must be kept in sync with PostgrestClient.schema\n    /**\n     * Select a schema to query or perform an function (rpc) call.\n     *\n     * The schema needs to be on the list of exposed schemas inside Supabase.\n     *\n     * @param schema - The schema to query\n     */\n    schema(schema) {\n        return this.rest.schema(schema);\n    }\n    // NOTE: signatures must be kept in sync with PostgrestClient.rpc\n    /**\n     * Perform a function call.\n     *\n     * @param fn - The function name to call\n     * @param args - The arguments to pass to the function call\n     * @param options - Named parameters\n     * @param options.head - When set to `true`, `data` will not be returned.\n     * Useful if you only need the count.\n     * @param options.get - When set to `true`, the function will be called with\n     * read-only access mode.\n     * @param options.count - Count algorithm to use to count rows returned by the\n     * function. Only applicable for [set-returning\n     * functions](https://www.postgresql.org/docs/current/functions-srf.html).\n     *\n     * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n     * hood.\n     *\n     * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n     * statistics under the hood.\n     *\n     * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n     * numbers.\n     */\n    rpc(fn, args = {}, options = {}) {\n        return this.rest.rpc(fn, args, options);\n    }\n    /**\n     * Creates a Realtime channel with Broadcast, Presence, and Postgres Changes.\n     *\n     * @param {string} name - The name of the Realtime channel.\n     * @param {Object} opts - The options to pass to the Realtime channel.\n     *\n     */\n    channel(name, opts = { config: {} }) {\n        return this.realtime.channel(name, opts);\n    }\n    /**\n     * Returns all Realtime channels.\n     */\n    getChannels() {\n        return this.realtime.getChannels();\n    }\n    /**\n     * Unsubscribes and removes Realtime channel from Realtime client.\n     *\n     * @param {RealtimeChannel} channel - The name of the Realtime channel.\n     *\n     */\n    removeChannel(channel) {\n        return this.realtime.removeChannel(channel);\n    }\n    /**\n     * Unsubscribes and removes all Realtime channels from Realtime client.\n     */\n    removeAllChannels() {\n        return this.realtime.removeAllChannels();\n    }\n    _getAccessToken() {\n        return __awaiter(this, void 0, void 0, function* () {\n            var _a, _b;\n            if (this.accessToken) {\n                return yield this.accessToken();\n            }\n            const { data } = yield this.auth.getSession();\n            return (_b = (_a = data.session) === null || _a === void 0 ? void 0 : _a.access_token) !== null && _b !== void 0 ? _b : this.supabaseKey;\n        });\n    }\n    _initSupabaseAuthClient({ autoRefreshToken, persistSession, detectSessionInUrl, storage, userStorage, storageKey, flowType, lock, debug, }, headers, fetch) {\n        const authHeaders = {\n            Authorization: `Bearer ${this.supabaseKey}`,\n            apikey: `${this.supabaseKey}`,\n        };\n        return new _lib_SupabaseAuthClient__WEBPACK_IMPORTED_MODULE_7__.SupabaseAuthClient({\n            url: this.authUrl.href,\n            headers: Object.assign(Object.assign({}, authHeaders), headers),\n            storageKey: storageKey,\n            autoRefreshToken,\n            persistSession,\n            detectSessionInUrl,\n            storage,\n            userStorage,\n            flowType,\n            lock,\n            debug,\n            fetch,\n            // auth checks if there is a custom authorizaiton header using this flag\n            // so it knows whether to return an error when getUser is called with no session\n            hasCustomAuthorizationHeader: Object.keys(this.headers).some((key) => key.toLowerCase() === 'authorization'),\n        });\n    }\n    _initRealtimeClient(options) {\n        return new _supabase_realtime_js__WEBPACK_IMPORTED_MODULE_1__.RealtimeClient(this.realtimeUrl.href, Object.assign(Object.assign({}, options), { params: Object.assign({ apikey: this.supabaseKey }, options === null || options === void 0 ? void 0 : options.params) }));\n    }\n    _listenForAuthEvents() {\n        let data = this.auth.onAuthStateChange((event, session) => {\n            this._handleTokenChanged(event, 'CLIENT', session === null || session === void 0 ? void 0 : session.access_token);\n        });\n        return data;\n    }\n    _handleTokenChanged(event, source, token) {\n        if ((event === 'TOKEN_REFRESHED' || event === 'SIGNED_IN') &&\n            this.changedAccessToken !== token) {\n            this.changedAccessToken = token;\n            this.realtime.setAuth(token);\n        }\n        else if (event === 'SIGNED_OUT') {\n            this.realtime.setAuth();\n            if (source == 'STORAGE')\n                this.auth.signOut();\n            this.changedAccessToken = undefined;\n        }\n    }\n}\n//# sourceMappingURL=SupabaseClient.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2Uvc3VwYWJhc2UtanMvZGlzdC9tb2R1bGUvU3VwYWJhc2VDbGllbnQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUEsaUJBQWlCLFNBQUksSUFBSSxTQUFJO0FBQzdCLDRCQUE0QiwrREFBK0QsaUJBQWlCO0FBQzVHO0FBQ0Esb0NBQW9DLE1BQU0sK0JBQStCLFlBQVk7QUFDckYsbUNBQW1DLE1BQU0sbUNBQW1DLFlBQVk7QUFDeEYsZ0NBQWdDO0FBQ2hDO0FBQ0EsS0FBSztBQUNMO0FBQ3lEO0FBQ0M7QUFDRjtBQUNzQjtBQUNnRDtBQUNsRjtBQUM4QjtBQUNaO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsaUVBQW1CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsK0JBQStCO0FBQ3ZFO0FBQ0EsZ0JBQWdCLDhEQUFrQjtBQUNsQyxzQkFBc0Isb0VBQXdCO0FBQzlDLGdEQUFnRCxFQUFFLGdFQUFvQixLQUFLLCtCQUErQjtBQUMxRyxvQkFBb0Isa0VBQXNCO0FBQzFDO0FBQ0EseUJBQXlCLGtFQUFvQixzREFBc0Q7QUFDbkc7QUFDQTtBQUNBO0FBQ0EsNkdBQTZHO0FBQzdHO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBLGlKQUFpSixjQUFjO0FBQy9KLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQSxxQkFBcUIseURBQWE7QUFDbEMsaUVBQWlFLHFFQUFxRTtBQUN0SSx3QkFBd0IsbUVBQWU7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULDJCQUEyQiwrREFBcUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixtRUFBZTtBQUNsQztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsY0FBYztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0EsMkJBQTJCLFlBQVk7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaUJBQWlCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBLFNBQVM7QUFDVDtBQUNBLDhCQUE4QixnSEFBZ0g7QUFDOUk7QUFDQSxxQ0FBcUMsaUJBQWlCO0FBQ3RELHVCQUF1QixpQkFBaUI7QUFDeEM7QUFDQSxtQkFBbUIsdUVBQWtCO0FBQ3JDO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxtQkFBbUIsaUVBQWMsc0RBQXNELGNBQWMsd0JBQXdCLDBCQUEwQixxRUFBcUU7QUFDNU47QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiRDpcXG5leHRcXG9yZ1xcbm9kZV9tb2R1bGVzXFxAc3VwYWJhc2VcXHN1cGFiYXNlLWpzXFxkaXN0XFxtb2R1bGVcXFN1cGFiYXNlQ2xpZW50LmpzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuaW1wb3J0IHsgRnVuY3Rpb25zQ2xpZW50IH0gZnJvbSAnQHN1cGFiYXNlL2Z1bmN0aW9ucy1qcyc7XG5pbXBvcnQgeyBQb3N0Z3Jlc3RDbGllbnQsIH0gZnJvbSAnQHN1cGFiYXNlL3Bvc3RncmVzdC1qcyc7XG5pbXBvcnQgeyBSZWFsdGltZUNsaWVudCwgfSBmcm9tICdAc3VwYWJhc2UvcmVhbHRpbWUtanMnO1xuaW1wb3J0IHsgU3RvcmFnZUNsaWVudCBhcyBTdXBhYmFzZVN0b3JhZ2VDbGllbnQgfSBmcm9tICdAc3VwYWJhc2Uvc3RvcmFnZS1qcyc7XG5pbXBvcnQgeyBERUZBVUxUX0dMT0JBTF9PUFRJT05TLCBERUZBVUxUX0RCX09QVElPTlMsIERFRkFVTFRfQVVUSF9PUFRJT05TLCBERUZBVUxUX1JFQUxUSU1FX09QVElPTlMsIH0gZnJvbSAnLi9saWIvY29uc3RhbnRzJztcbmltcG9ydCB7IGZldGNoV2l0aEF1dGggfSBmcm9tICcuL2xpYi9mZXRjaCc7XG5pbXBvcnQgeyBhcHBseVNldHRpbmdEZWZhdWx0cywgdmFsaWRhdGVTdXBhYmFzZVVybCB9IGZyb20gJy4vbGliL2hlbHBlcnMnO1xuaW1wb3J0IHsgU3VwYWJhc2VBdXRoQ2xpZW50IH0gZnJvbSAnLi9saWIvU3VwYWJhc2VBdXRoQ2xpZW50Jztcbi8qKlxuICogU3VwYWJhc2UgQ2xpZW50LlxuICpcbiAqIEFuIGlzb21vcnBoaWMgSmF2YXNjcmlwdCBjbGllbnQgZm9yIGludGVyYWN0aW5nIHdpdGggUG9zdGdyZXMuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN1cGFiYXNlQ2xpZW50IHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgY2xpZW50IGZvciB1c2UgaW4gdGhlIGJyb3dzZXIuXG4gICAgICogQHBhcmFtIHN1cGFiYXNlVXJsIFRoZSB1bmlxdWUgU3VwYWJhc2UgVVJMIHdoaWNoIGlzIHN1cHBsaWVkIHdoZW4geW91IGNyZWF0ZSBhIG5ldyBwcm9qZWN0IGluIHlvdXIgcHJvamVjdCBkYXNoYm9hcmQuXG4gICAgICogQHBhcmFtIHN1cGFiYXNlS2V5IFRoZSB1bmlxdWUgU3VwYWJhc2UgS2V5IHdoaWNoIGlzIHN1cHBsaWVkIHdoZW4geW91IGNyZWF0ZSBhIG5ldyBwcm9qZWN0IGluIHlvdXIgcHJvamVjdCBkYXNoYm9hcmQuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuZGIuc2NoZW1hIFlvdSBjYW4gc3dpdGNoIGluIGJldHdlZW4gc2NoZW1hcy4gVGhlIHNjaGVtYSBuZWVkcyB0byBiZSBvbiB0aGUgbGlzdCBvZiBleHBvc2VkIHNjaGVtYXMgaW5zaWRlIFN1cGFiYXNlLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmF1dGguYXV0b1JlZnJlc2hUb2tlbiBTZXQgdG8gXCJ0cnVlXCIgaWYgeW91IHdhbnQgdG8gYXV0b21hdGljYWxseSByZWZyZXNoIHRoZSB0b2tlbiBiZWZvcmUgZXhwaXJpbmcuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuYXV0aC5wZXJzaXN0U2Vzc2lvbiBTZXQgdG8gXCJ0cnVlXCIgaWYgeW91IHdhbnQgdG8gYXV0b21hdGljYWxseSBzYXZlIHRoZSB1c2VyIHNlc3Npb24gaW50byBsb2NhbCBzdG9yYWdlLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmF1dGguZGV0ZWN0U2Vzc2lvbkluVXJsIFNldCB0byBcInRydWVcIiBpZiB5b3Ugd2FudCB0byBhdXRvbWF0aWNhbGx5IGRldGVjdHMgT0F1dGggZ3JhbnRzIGluIHRoZSBVUkwgYW5kIHNpZ25zIGluIHRoZSB1c2VyLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLnJlYWx0aW1lIE9wdGlvbnMgcGFzc2VkIGFsb25nIHRvIHJlYWx0aW1lLWpzIGNvbnN0cnVjdG9yLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLnN0b3JhZ2UgT3B0aW9ucyBwYXNzZWQgYWxvbmcgdG8gdGhlIHN0b3JhZ2UtanMgY29uc3RydWN0b3IuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuZ2xvYmFsLmZldGNoIEEgY3VzdG9tIGZldGNoIGltcGxlbWVudGF0aW9uLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmdsb2JhbC5oZWFkZXJzIEFueSBhZGRpdGlvbmFsIGhlYWRlcnMgdG8gc2VuZCB3aXRoIGVhY2ggbmV0d29yayByZXF1ZXN0LlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHN1cGFiYXNlVXJsLCBzdXBhYmFzZUtleSwgb3B0aW9ucykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgdGhpcy5zdXBhYmFzZVVybCA9IHN1cGFiYXNlVXJsO1xuICAgICAgICB0aGlzLnN1cGFiYXNlS2V5ID0gc3VwYWJhc2VLZXk7XG4gICAgICAgIGNvbnN0IGJhc2VVcmwgPSB2YWxpZGF0ZVN1cGFiYXNlVXJsKHN1cGFiYXNlVXJsKTtcbiAgICAgICAgaWYgKCFzdXBhYmFzZUtleSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc3VwYWJhc2VLZXkgaXMgcmVxdWlyZWQuJyk7XG4gICAgICAgIHRoaXMucmVhbHRpbWVVcmwgPSBuZXcgVVJMKCdyZWFsdGltZS92MScsIGJhc2VVcmwpO1xuICAgICAgICB0aGlzLnJlYWx0aW1lVXJsLnByb3RvY29sID0gdGhpcy5yZWFsdGltZVVybC5wcm90b2NvbC5yZXBsYWNlKCdodHRwJywgJ3dzJyk7XG4gICAgICAgIHRoaXMuYXV0aFVybCA9IG5ldyBVUkwoJ2F1dGgvdjEnLCBiYXNlVXJsKTtcbiAgICAgICAgdGhpcy5zdG9yYWdlVXJsID0gbmV3IFVSTCgnc3RvcmFnZS92MScsIGJhc2VVcmwpO1xuICAgICAgICB0aGlzLmZ1bmN0aW9uc1VybCA9IG5ldyBVUkwoJ2Z1bmN0aW9ucy92MScsIGJhc2VVcmwpO1xuICAgICAgICAvLyBkZWZhdWx0IHN0b3JhZ2Uga2V5IHVzZXMgdGhlIHN1cGFiYXNlIHByb2plY3QgcmVmIGFzIGEgbmFtZXNwYWNlXG4gICAgICAgIGNvbnN0IGRlZmF1bHRTdG9yYWdlS2V5ID0gYHNiLSR7YmFzZVVybC5ob3N0bmFtZS5zcGxpdCgnLicpWzBdfS1hdXRoLXRva2VuYDtcbiAgICAgICAgY29uc3QgREVGQVVMVFMgPSB7XG4gICAgICAgICAgICBkYjogREVGQVVMVF9EQl9PUFRJT05TLFxuICAgICAgICAgICAgcmVhbHRpbWU6IERFRkFVTFRfUkVBTFRJTUVfT1BUSU9OUyxcbiAgICAgICAgICAgIGF1dGg6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVF9BVVRIX09QVElPTlMpLCB7IHN0b3JhZ2VLZXk6IGRlZmF1bHRTdG9yYWdlS2V5IH0pLFxuICAgICAgICAgICAgZ2xvYmFsOiBERUZBVUxUX0dMT0JBTF9PUFRJT05TLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBzZXR0aW5ncyA9IGFwcGx5U2V0dGluZ0RlZmF1bHRzKG9wdGlvbnMgIT09IG51bGwgJiYgb3B0aW9ucyAhPT0gdm9pZCAwID8gb3B0aW9ucyA6IHt9LCBERUZBVUxUUyk7XG4gICAgICAgIHRoaXMuc3RvcmFnZUtleSA9IChfYSA9IHNldHRpbmdzLmF1dGguc3RvcmFnZUtleSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJyc7XG4gICAgICAgIHRoaXMuaGVhZGVycyA9IChfYiA9IHNldHRpbmdzLmdsb2JhbC5oZWFkZXJzKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB7fTtcbiAgICAgICAgaWYgKCFzZXR0aW5ncy5hY2Nlc3NUb2tlbikge1xuICAgICAgICAgICAgdGhpcy5hdXRoID0gdGhpcy5faW5pdFN1cGFiYXNlQXV0aENsaWVudCgoX2MgPSBzZXR0aW5ncy5hdXRoKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiB7fSwgdGhpcy5oZWFkZXJzLCBzZXR0aW5ncy5nbG9iYWwuZmV0Y2gpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5hY2Nlc3NUb2tlbiA9IHNldHRpbmdzLmFjY2Vzc1Rva2VuO1xuICAgICAgICAgICAgdGhpcy5hdXRoID0gbmV3IFByb3h5KHt9LCB7XG4gICAgICAgICAgICAgICAgZ2V0OiAoXywgcHJvcCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEBzdXBhYmFzZS9zdXBhYmFzZS1qczogU3VwYWJhc2UgQ2xpZW50IGlzIGNvbmZpZ3VyZWQgd2l0aCB0aGUgYWNjZXNzVG9rZW4gb3B0aW9uLCBhY2Nlc3Npbmcgc3VwYWJhc2UuYXV0aC4ke1N0cmluZyhwcm9wKX0gaXMgbm90IHBvc3NpYmxlYCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZmV0Y2ggPSBmZXRjaFdpdGhBdXRoKHN1cGFiYXNlS2V5LCB0aGlzLl9nZXRBY2Nlc3NUb2tlbi5iaW5kKHRoaXMpLCBzZXR0aW5ncy5nbG9iYWwuZmV0Y2gpO1xuICAgICAgICB0aGlzLnJlYWx0aW1lID0gdGhpcy5faW5pdFJlYWx0aW1lQ2xpZW50KE9iamVjdC5hc3NpZ24oeyBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsIGFjY2Vzc1Rva2VuOiB0aGlzLl9nZXRBY2Nlc3NUb2tlbi5iaW5kKHRoaXMpIH0sIHNldHRpbmdzLnJlYWx0aW1lKSk7XG4gICAgICAgIHRoaXMucmVzdCA9IG5ldyBQb3N0Z3Jlc3RDbGllbnQobmV3IFVSTCgncmVzdC92MScsIGJhc2VVcmwpLmhyZWYsIHtcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgIHNjaGVtYTogc2V0dGluZ3MuZGIuc2NoZW1hLFxuICAgICAgICAgICAgZmV0Y2g6IHRoaXMuZmV0Y2gsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnN0b3JhZ2UgPSBuZXcgU3VwYWJhc2VTdG9yYWdlQ2xpZW50KHRoaXMuc3RvcmFnZVVybC5ocmVmLCB0aGlzLmhlYWRlcnMsIHRoaXMuZmV0Y2gsIG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5zdG9yYWdlKTtcbiAgICAgICAgaWYgKCFzZXR0aW5ncy5hY2Nlc3NUb2tlbikge1xuICAgICAgICAgICAgdGhpcy5fbGlzdGVuRm9yQXV0aEV2ZW50cygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN1cGFiYXNlIEZ1bmN0aW9ucyBhbGxvd3MgeW91IHRvIGRlcGxveSBhbmQgaW52b2tlIGVkZ2UgZnVuY3Rpb25zLlxuICAgICAqL1xuICAgIGdldCBmdW5jdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiBuZXcgRnVuY3Rpb25zQ2xpZW50KHRoaXMuZnVuY3Rpb25zVXJsLmhyZWYsIHtcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgIGN1c3RvbUZldGNoOiB0aGlzLmZldGNoLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGVyZm9ybSBhIHF1ZXJ5IG9uIGEgdGFibGUgb3IgYSB2aWV3LlxuICAgICAqXG4gICAgICogQHBhcmFtIHJlbGF0aW9uIC0gVGhlIHRhYmxlIG9yIHZpZXcgbmFtZSB0byBxdWVyeVxuICAgICAqL1xuICAgIGZyb20ocmVsYXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzdC5mcm9tKHJlbGF0aW9uKTtcbiAgICB9XG4gICAgLy8gTk9URTogc2lnbmF0dXJlcyBtdXN0IGJlIGtlcHQgaW4gc3luYyB3aXRoIFBvc3RncmVzdENsaWVudC5zY2hlbWFcbiAgICAvKipcbiAgICAgKiBTZWxlY3QgYSBzY2hlbWEgdG8gcXVlcnkgb3IgcGVyZm9ybSBhbiBmdW5jdGlvbiAocnBjKSBjYWxsLlxuICAgICAqXG4gICAgICogVGhlIHNjaGVtYSBuZWVkcyB0byBiZSBvbiB0aGUgbGlzdCBvZiBleHBvc2VkIHNjaGVtYXMgaW5zaWRlIFN1cGFiYXNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHNjaGVtYSAtIFRoZSBzY2hlbWEgdG8gcXVlcnlcbiAgICAgKi9cbiAgICBzY2hlbWEoc2NoZW1hKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc3Quc2NoZW1hKHNjaGVtYSk7XG4gICAgfVxuICAgIC8vIE5PVEU6IHNpZ25hdHVyZXMgbXVzdCBiZSBrZXB0IGluIHN5bmMgd2l0aCBQb3N0Z3Jlc3RDbGllbnQucnBjXG4gICAgLyoqXG4gICAgICogUGVyZm9ybSBhIGZ1bmN0aW9uIGNhbGwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZm4gLSBUaGUgZnVuY3Rpb24gbmFtZSB0byBjYWxsXG4gICAgICogQHBhcmFtIGFyZ3MgLSBUaGUgYXJndW1lbnRzIHRvIHBhc3MgdG8gdGhlIGZ1bmN0aW9uIGNhbGxcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIE5hbWVkIHBhcmFtZXRlcnNcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5oZWFkIC0gV2hlbiBzZXQgdG8gYHRydWVgLCBgZGF0YWAgd2lsbCBub3QgYmUgcmV0dXJuZWQuXG4gICAgICogVXNlZnVsIGlmIHlvdSBvbmx5IG5lZWQgdGhlIGNvdW50LlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmdldCAtIFdoZW4gc2V0IHRvIGB0cnVlYCwgdGhlIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIHdpdGhcbiAgICAgKiByZWFkLW9ubHkgYWNjZXNzIG1vZGUuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuY291bnQgLSBDb3VudCBhbGdvcml0aG0gdG8gdXNlIHRvIGNvdW50IHJvd3MgcmV0dXJuZWQgYnkgdGhlXG4gICAgICogZnVuY3Rpb24uIE9ubHkgYXBwbGljYWJsZSBmb3IgW3NldC1yZXR1cm5pbmdcbiAgICAgKiBmdW5jdGlvbnNdKGh0dHBzOi8vd3d3LnBvc3RncmVzcWwub3JnL2RvY3MvY3VycmVudC9mdW5jdGlvbnMtc3JmLmh0bWwpLlxuICAgICAqXG4gICAgICogYFwiZXhhY3RcImA6IEV4YWN0IGJ1dCBzbG93IGNvdW50IGFsZ29yaXRobS4gUGVyZm9ybXMgYSBgQ09VTlQoKilgIHVuZGVyIHRoZVxuICAgICAqIGhvb2QuXG4gICAgICpcbiAgICAgKiBgXCJwbGFubmVkXCJgOiBBcHByb3hpbWF0ZWQgYnV0IGZhc3QgY291bnQgYWxnb3JpdGhtLiBVc2VzIHRoZSBQb3N0Z3Jlc1xuICAgICAqIHN0YXRpc3RpY3MgdW5kZXIgdGhlIGhvb2QuXG4gICAgICpcbiAgICAgKiBgXCJlc3RpbWF0ZWRcImA6IFVzZXMgZXhhY3QgY291bnQgZm9yIGxvdyBudW1iZXJzIGFuZCBwbGFubmVkIGNvdW50IGZvciBoaWdoXG4gICAgICogbnVtYmVycy5cbiAgICAgKi9cbiAgICBycGMoZm4sIGFyZ3MgPSB7fSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc3QucnBjKGZuLCBhcmdzLCBvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIFJlYWx0aW1lIGNoYW5uZWwgd2l0aCBCcm9hZGNhc3QsIFByZXNlbmNlLCBhbmQgUG9zdGdyZXMgQ2hhbmdlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIFJlYWx0aW1lIGNoYW5uZWwuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBUaGUgb3B0aW9ucyB0byBwYXNzIHRvIHRoZSBSZWFsdGltZSBjaGFubmVsLlxuICAgICAqXG4gICAgICovXG4gICAgY2hhbm5lbChuYW1lLCBvcHRzID0geyBjb25maWc6IHt9IH0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVhbHRpbWUuY2hhbm5lbChuYW1lLCBvcHRzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbGwgUmVhbHRpbWUgY2hhbm5lbHMuXG4gICAgICovXG4gICAgZ2V0Q2hhbm5lbHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlYWx0aW1lLmdldENoYW5uZWxzKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVuc3Vic2NyaWJlcyBhbmQgcmVtb3ZlcyBSZWFsdGltZSBjaGFubmVsIGZyb20gUmVhbHRpbWUgY2xpZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtSZWFsdGltZUNoYW5uZWx9IGNoYW5uZWwgLSBUaGUgbmFtZSBvZiB0aGUgUmVhbHRpbWUgY2hhbm5lbC5cbiAgICAgKlxuICAgICAqL1xuICAgIHJlbW92ZUNoYW5uZWwoY2hhbm5lbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWFsdGltZS5yZW1vdmVDaGFubmVsKGNoYW5uZWwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVbnN1YnNjcmliZXMgYW5kIHJlbW92ZXMgYWxsIFJlYWx0aW1lIGNoYW5uZWxzIGZyb20gUmVhbHRpbWUgY2xpZW50LlxuICAgICAqL1xuICAgIHJlbW92ZUFsbENoYW5uZWxzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWFsdGltZS5yZW1vdmVBbGxDaGFubmVscygpO1xuICAgIH1cbiAgICBfZ2V0QWNjZXNzVG9rZW4oKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgaWYgKHRoaXMuYWNjZXNzVG9rZW4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5hY2Nlc3NUb2tlbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyBkYXRhIH0gPSB5aWVsZCB0aGlzLmF1dGguZ2V0U2Vzc2lvbigpO1xuICAgICAgICAgICAgcmV0dXJuIChfYiA9IChfYSA9IGRhdGEuc2Vzc2lvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFjY2Vzc190b2tlbikgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogdGhpcy5zdXBhYmFzZUtleTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9pbml0U3VwYWJhc2VBdXRoQ2xpZW50KHsgYXV0b1JlZnJlc2hUb2tlbiwgcGVyc2lzdFNlc3Npb24sIGRldGVjdFNlc3Npb25JblVybCwgc3RvcmFnZSwgdXNlclN0b3JhZ2UsIHN0b3JhZ2VLZXksIGZsb3dUeXBlLCBsb2NrLCBkZWJ1ZywgfSwgaGVhZGVycywgZmV0Y2gpIHtcbiAgICAgICAgY29uc3QgYXV0aEhlYWRlcnMgPSB7XG4gICAgICAgICAgICBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7dGhpcy5zdXBhYmFzZUtleX1gLFxuICAgICAgICAgICAgYXBpa2V5OiBgJHt0aGlzLnN1cGFiYXNlS2V5fWAsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBuZXcgU3VwYWJhc2VBdXRoQ2xpZW50KHtcbiAgICAgICAgICAgIHVybDogdGhpcy5hdXRoVXJsLmhyZWYsXG4gICAgICAgICAgICBoZWFkZXJzOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGF1dGhIZWFkZXJzKSwgaGVhZGVycyksXG4gICAgICAgICAgICBzdG9yYWdlS2V5OiBzdG9yYWdlS2V5LFxuICAgICAgICAgICAgYXV0b1JlZnJlc2hUb2tlbixcbiAgICAgICAgICAgIHBlcnNpc3RTZXNzaW9uLFxuICAgICAgICAgICAgZGV0ZWN0U2Vzc2lvbkluVXJsLFxuICAgICAgICAgICAgc3RvcmFnZSxcbiAgICAgICAgICAgIHVzZXJTdG9yYWdlLFxuICAgICAgICAgICAgZmxvd1R5cGUsXG4gICAgICAgICAgICBsb2NrLFxuICAgICAgICAgICAgZGVidWcsXG4gICAgICAgICAgICBmZXRjaCxcbiAgICAgICAgICAgIC8vIGF1dGggY2hlY2tzIGlmIHRoZXJlIGlzIGEgY3VzdG9tIGF1dGhvcml6YWl0b24gaGVhZGVyIHVzaW5nIHRoaXMgZmxhZ1xuICAgICAgICAgICAgLy8gc28gaXQga25vd3Mgd2hldGhlciB0byByZXR1cm4gYW4gZXJyb3Igd2hlbiBnZXRVc2VyIGlzIGNhbGxlZCB3aXRoIG5vIHNlc3Npb25cbiAgICAgICAgICAgIGhhc0N1c3RvbUF1dGhvcml6YXRpb25IZWFkZXI6IE9iamVjdC5rZXlzKHRoaXMuaGVhZGVycykuc29tZSgoa2V5KSA9PiBrZXkudG9Mb3dlckNhc2UoKSA9PT0gJ2F1dGhvcml6YXRpb24nKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9pbml0UmVhbHRpbWVDbGllbnQob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IFJlYWx0aW1lQ2xpZW50KHRoaXMucmVhbHRpbWVVcmwuaHJlZiwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKSwgeyBwYXJhbXM6IE9iamVjdC5hc3NpZ24oeyBhcGlrZXk6IHRoaXMuc3VwYWJhc2VLZXkgfSwgb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnBhcmFtcykgfSkpO1xuICAgIH1cbiAgICBfbGlzdGVuRm9yQXV0aEV2ZW50cygpIHtcbiAgICAgICAgbGV0IGRhdGEgPSB0aGlzLmF1dGgub25BdXRoU3RhdGVDaGFuZ2UoKGV2ZW50LCBzZXNzaW9uKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVUb2tlbkNoYW5nZWQoZXZlbnQsICdDTElFTlQnLCBzZXNzaW9uID09PSBudWxsIHx8IHNlc3Npb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNlc3Npb24uYWNjZXNzX3Rva2VuKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICBfaGFuZGxlVG9rZW5DaGFuZ2VkKGV2ZW50LCBzb3VyY2UsIHRva2VuKSB7XG4gICAgICAgIGlmICgoZXZlbnQgPT09ICdUT0tFTl9SRUZSRVNIRUQnIHx8IGV2ZW50ID09PSAnU0lHTkVEX0lOJykgJiZcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlZEFjY2Vzc1Rva2VuICE9PSB0b2tlbikge1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VkQWNjZXNzVG9rZW4gPSB0b2tlbjtcbiAgICAgICAgICAgIHRoaXMucmVhbHRpbWUuc2V0QXV0aCh0b2tlbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXZlbnQgPT09ICdTSUdORURfT1VUJykge1xuICAgICAgICAgICAgdGhpcy5yZWFsdGltZS5zZXRBdXRoKCk7XG4gICAgICAgICAgICBpZiAoc291cmNlID09ICdTVE9SQUdFJylcbiAgICAgICAgICAgICAgICB0aGlzLmF1dGguc2lnbk91dCgpO1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VkQWNjZXNzVG9rZW4gPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TdXBhYmFzZUNsaWVudC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/supabase-js/dist/module/SupabaseClient.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/supabase-js/dist/module/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@supabase/supabase-js/dist/module/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AuthAdminApi: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.AuthAdminApi),\n/* harmony export */   AuthApiError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.AuthApiError),\n/* harmony export */   AuthClient: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.AuthClient),\n/* harmony export */   AuthError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.AuthError),\n/* harmony export */   AuthImplicitGrantRedirectError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.AuthImplicitGrantRedirectError),\n/* harmony export */   AuthInvalidCredentialsError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.AuthInvalidCredentialsError),\n/* harmony export */   AuthInvalidJwtError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.AuthInvalidJwtError),\n/* harmony export */   AuthInvalidTokenResponseError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.AuthInvalidTokenResponseError),\n/* harmony export */   AuthPKCEGrantCodeExchangeError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.AuthPKCEGrantCodeExchangeError),\n/* harmony export */   AuthRetryableFetchError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.AuthRetryableFetchError),\n/* harmony export */   AuthSessionMissingError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.AuthSessionMissingError),\n/* harmony export */   AuthUnknownError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.AuthUnknownError),\n/* harmony export */   AuthWeakPasswordError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.AuthWeakPasswordError),\n/* harmony export */   CustomAuthError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.CustomAuthError),\n/* harmony export */   FunctionRegion: () => (/* reexport safe */ _supabase_functions_js__WEBPACK_IMPORTED_MODULE_2__.FunctionRegion),\n/* harmony export */   FunctionsError: () => (/* reexport safe */ _supabase_functions_js__WEBPACK_IMPORTED_MODULE_2__.FunctionsError),\n/* harmony export */   FunctionsFetchError: () => (/* reexport safe */ _supabase_functions_js__WEBPACK_IMPORTED_MODULE_2__.FunctionsFetchError),\n/* harmony export */   FunctionsHttpError: () => (/* reexport safe */ _supabase_functions_js__WEBPACK_IMPORTED_MODULE_2__.FunctionsHttpError),\n/* harmony export */   FunctionsRelayError: () => (/* reexport safe */ _supabase_functions_js__WEBPACK_IMPORTED_MODULE_2__.FunctionsRelayError),\n/* harmony export */   GoTrueAdminApi: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.GoTrueAdminApi),\n/* harmony export */   GoTrueClient: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.GoTrueClient),\n/* harmony export */   NavigatorLockAcquireTimeoutError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.NavigatorLockAcquireTimeoutError),\n/* harmony export */   PostgrestError: () => (/* reexport safe */ _supabase_postgrest_js__WEBPACK_IMPORTED_MODULE_1__.PostgrestError),\n/* harmony export */   REALTIME_CHANNEL_STATES: () => (/* reexport safe */ _supabase_realtime_js__WEBPACK_IMPORTED_MODULE_3__.REALTIME_CHANNEL_STATES),\n/* harmony export */   REALTIME_LISTEN_TYPES: () => (/* reexport safe */ _supabase_realtime_js__WEBPACK_IMPORTED_MODULE_3__.REALTIME_LISTEN_TYPES),\n/* harmony export */   REALTIME_POSTGRES_CHANGES_LISTEN_EVENT: () => (/* reexport safe */ _supabase_realtime_js__WEBPACK_IMPORTED_MODULE_3__.REALTIME_POSTGRES_CHANGES_LISTEN_EVENT),\n/* harmony export */   REALTIME_PRESENCE_LISTEN_EVENTS: () => (/* reexport safe */ _supabase_realtime_js__WEBPACK_IMPORTED_MODULE_3__.REALTIME_PRESENCE_LISTEN_EVENTS),\n/* harmony export */   REALTIME_SUBSCRIBE_STATES: () => (/* reexport safe */ _supabase_realtime_js__WEBPACK_IMPORTED_MODULE_3__.REALTIME_SUBSCRIBE_STATES),\n/* harmony export */   RealtimeChannel: () => (/* reexport safe */ _supabase_realtime_js__WEBPACK_IMPORTED_MODULE_3__.RealtimeChannel),\n/* harmony export */   RealtimeClient: () => (/* reexport safe */ _supabase_realtime_js__WEBPACK_IMPORTED_MODULE_3__.RealtimeClient),\n/* harmony export */   RealtimePresence: () => (/* reexport safe */ _supabase_realtime_js__WEBPACK_IMPORTED_MODULE_3__.RealtimePresence),\n/* harmony export */   SIGN_OUT_SCOPES: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.SIGN_OUT_SCOPES),\n/* harmony export */   SupabaseClient: () => (/* reexport safe */ _SupabaseClient__WEBPACK_IMPORTED_MODULE_4__[\"default\"]),\n/* harmony export */   WebSocketFactory: () => (/* reexport safe */ _supabase_realtime_js__WEBPACK_IMPORTED_MODULE_3__.WebSocketFactory),\n/* harmony export */   createClient: () => (/* binding */ createClient),\n/* harmony export */   isAuthApiError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.isAuthApiError),\n/* harmony export */   isAuthError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.isAuthError),\n/* harmony export */   isAuthImplicitGrantRedirectError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.isAuthImplicitGrantRedirectError),\n/* harmony export */   isAuthRetryableFetchError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.isAuthRetryableFetchError),\n/* harmony export */   isAuthSessionMissingError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.isAuthSessionMissingError),\n/* harmony export */   isAuthWeakPasswordError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.isAuthWeakPasswordError),\n/* harmony export */   lockInternals: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.lockInternals),\n/* harmony export */   navigatorLock: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.navigatorLock),\n/* harmony export */   processLock: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.processLock)\n/* harmony export */ });\n/* harmony import */ var _SupabaseClient__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./SupabaseClient */ \"(app-pages-browser)/./node_modules/@supabase/supabase-js/dist/module/SupabaseClient.js\");\n/* harmony import */ var _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @supabase/auth-js */ \"(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/index.js\");\n/* harmony import */ var _supabase_postgrest_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @supabase/postgrest-js */ \"(app-pages-browser)/./node_modules/@supabase/postgrest-js/dist/esm/wrapper.mjs\");\n/* harmony import */ var _supabase_functions_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @supabase/functions-js */ \"(app-pages-browser)/./node_modules/@supabase/functions-js/dist/module/types.js\");\n/* harmony import */ var _supabase_realtime_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @supabase/realtime-js */ \"(app-pages-browser)/./node_modules/@supabase/realtime-js/dist/module/index.js\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n\n\n\n\n\n\n/**\n * Creates a new Supabase Client.\n */\nconst createClient = (supabaseUrl, supabaseKey, options) => {\n    return new _SupabaseClient__WEBPACK_IMPORTED_MODULE_4__[\"default\"](supabaseUrl, supabaseKey, options);\n};\n// Check for Node.js <= 18 deprecation\nfunction shouldShowDeprecationWarning() {\n    // Skip in browser environments\n    if (typeof window !== 'undefined') {\n        return false;\n    }\n    // Skip if process is not available (e.g., Edge Runtime)\n    if (typeof process === 'undefined') {\n        return false;\n    }\n    // Use dynamic property access to avoid Next.js Edge Runtime static analysis warnings\n    const processVersion = process['version'];\n    if (processVersion === undefined || processVersion === null) {\n        return false;\n    }\n    const versionMatch = processVersion.match(/^v(\\d+)\\./);\n    if (!versionMatch) {\n        return false;\n    }\n    const majorVersion = parseInt(versionMatch[1], 10);\n    return majorVersion <= 18;\n}\nif (shouldShowDeprecationWarning()) {\n    console.warn(`  Node.js 18 and below are deprecated and will no longer be supported in future versions of @supabase/supabase-js. ` +\n        `Please upgrade to Node.js 20 or later. ` +\n        `For more information, visit: https://github.com/orgs/supabase/discussions/37217`);\n}\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2Uvc3VwYWJhc2UtanMvZGlzdC9tb2R1bGUvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBOEM7QUFDWjtBQUN1QjtBQUM4RTtBQUNqRztBQUN1QjtBQUM3RDtBQUNBO0FBQ0E7QUFDTztBQUNQLGVBQWUsdURBQWM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsT0FBTztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiRDpcXG5leHRcXG9yZ1xcbm9kZV9tb2R1bGVzXFxAc3VwYWJhc2VcXHN1cGFiYXNlLWpzXFxkaXN0XFxtb2R1bGVcXGluZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBTdXBhYmFzZUNsaWVudCBmcm9tICcuL1N1cGFiYXNlQ2xpZW50JztcbmV4cG9ydCAqIGZyb20gJ0BzdXBhYmFzZS9hdXRoLWpzJztcbmV4cG9ydCB7IFBvc3RncmVzdEVycm9yLCB9IGZyb20gJ0BzdXBhYmFzZS9wb3N0Z3Jlc3QtanMnO1xuZXhwb3J0IHsgRnVuY3Rpb25zSHR0cEVycm9yLCBGdW5jdGlvbnNGZXRjaEVycm9yLCBGdW5jdGlvbnNSZWxheUVycm9yLCBGdW5jdGlvbnNFcnJvciwgRnVuY3Rpb25SZWdpb24sIH0gZnJvbSAnQHN1cGFiYXNlL2Z1bmN0aW9ucy1qcyc7XG5leHBvcnQgKiBmcm9tICdAc3VwYWJhc2UvcmVhbHRpbWUtanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBTdXBhYmFzZUNsaWVudCB9IGZyb20gJy4vU3VwYWJhc2VDbGllbnQnO1xuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IFN1cGFiYXNlIENsaWVudC5cbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZUNsaWVudCA9IChzdXBhYmFzZVVybCwgc3VwYWJhc2VLZXksIG9wdGlvbnMpID0+IHtcbiAgICByZXR1cm4gbmV3IFN1cGFiYXNlQ2xpZW50KHN1cGFiYXNlVXJsLCBzdXBhYmFzZUtleSwgb3B0aW9ucyk7XG59O1xuLy8gQ2hlY2sgZm9yIE5vZGUuanMgPD0gMTggZGVwcmVjYXRpb25cbmZ1bmN0aW9uIHNob3VsZFNob3dEZXByZWNhdGlvbldhcm5pbmcoKSB7XG4gICAgLy8gU2tpcCBpbiBicm93c2VyIGVudmlyb25tZW50c1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIFNraXAgaWYgcHJvY2VzcyBpcyBub3QgYXZhaWxhYmxlIChlLmcuLCBFZGdlIFJ1bnRpbWUpXG4gICAgaWYgKHR5cGVvZiBwcm9jZXNzID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIFVzZSBkeW5hbWljIHByb3BlcnR5IGFjY2VzcyB0byBhdm9pZCBOZXh0LmpzIEVkZ2UgUnVudGltZSBzdGF0aWMgYW5hbHlzaXMgd2FybmluZ3NcbiAgICBjb25zdCBwcm9jZXNzVmVyc2lvbiA9IHByb2Nlc3NbJ3ZlcnNpb24nXTtcbiAgICBpZiAocHJvY2Vzc1ZlcnNpb24gPT09IHVuZGVmaW5lZCB8fCBwcm9jZXNzVmVyc2lvbiA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHZlcnNpb25NYXRjaCA9IHByb2Nlc3NWZXJzaW9uLm1hdGNoKC9edihcXGQrKVxcLi8pO1xuICAgIGlmICghdmVyc2lvbk1hdGNoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgbWFqb3JWZXJzaW9uID0gcGFyc2VJbnQodmVyc2lvbk1hdGNoWzFdLCAxMCk7XG4gICAgcmV0dXJuIG1ham9yVmVyc2lvbiA8PSAxODtcbn1cbmlmIChzaG91bGRTaG93RGVwcmVjYXRpb25XYXJuaW5nKCkpIHtcbiAgICBjb25zb2xlLndhcm4oYOKaoO+4jyAgTm9kZS5qcyAxOCBhbmQgYmVsb3cgYXJlIGRlcHJlY2F0ZWQgYW5kIHdpbGwgbm8gbG9uZ2VyIGJlIHN1cHBvcnRlZCBpbiBmdXR1cmUgdmVyc2lvbnMgb2YgQHN1cGFiYXNlL3N1cGFiYXNlLWpzLiBgICtcbiAgICAgICAgYFBsZWFzZSB1cGdyYWRlIHRvIE5vZGUuanMgMjAgb3IgbGF0ZXIuIGAgK1xuICAgICAgICBgRm9yIG1vcmUgaW5mb3JtYXRpb24sIHZpc2l0OiBodHRwczovL2dpdGh1Yi5jb20vb3Jncy9zdXBhYmFzZS9kaXNjdXNzaW9ucy8zNzIxN2ApO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/supabase-js/dist/module/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/supabase-js/dist/module/lib/SupabaseAuthClient.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@supabase/supabase-js/dist/module/lib/SupabaseAuthClient.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SupabaseAuthClient: () => (/* binding */ SupabaseAuthClient)\n/* harmony export */ });\n/* harmony import */ var _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @supabase/auth-js */ \"(app-pages-browser)/./node_modules/@supabase/auth-js/dist/module/index.js\");\n\nclass SupabaseAuthClient extends _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.AuthClient {\n    constructor(options) {\n        super(options);\n    }\n}\n//# sourceMappingURL=SupabaseAuthClient.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2Uvc3VwYWJhc2UtanMvZGlzdC9tb2R1bGUvbGliL1N1cGFiYXNlQXV0aENsaWVudC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUErQztBQUN4QyxpQ0FBaUMseURBQVU7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiRDpcXG5leHRcXG9yZ1xcbm9kZV9tb2R1bGVzXFxAc3VwYWJhc2VcXHN1cGFiYXNlLWpzXFxkaXN0XFxtb2R1bGVcXGxpYlxcU3VwYWJhc2VBdXRoQ2xpZW50LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEF1dGhDbGllbnQgfSBmcm9tICdAc3VwYWJhc2UvYXV0aC1qcyc7XG5leHBvcnQgY2xhc3MgU3VwYWJhc2VBdXRoQ2xpZW50IGV4dGVuZHMgQXV0aENsaWVudCB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICBzdXBlcihvcHRpb25zKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TdXBhYmFzZUF1dGhDbGllbnQuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/supabase-js/dist/module/lib/SupabaseAuthClient.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/supabase-js/dist/module/lib/constants.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@supabase/supabase-js/dist/module/lib/constants.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEFAULT_AUTH_OPTIONS: () => (/* binding */ DEFAULT_AUTH_OPTIONS),\n/* harmony export */   DEFAULT_DB_OPTIONS: () => (/* binding */ DEFAULT_DB_OPTIONS),\n/* harmony export */   DEFAULT_GLOBAL_OPTIONS: () => (/* binding */ DEFAULT_GLOBAL_OPTIONS),\n/* harmony export */   DEFAULT_HEADERS: () => (/* binding */ DEFAULT_HEADERS),\n/* harmony export */   DEFAULT_REALTIME_OPTIONS: () => (/* binding */ DEFAULT_REALTIME_OPTIONS)\n/* harmony export */ });\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./version */ \"(app-pages-browser)/./node_modules/@supabase/supabase-js/dist/module/lib/version.js\");\n\nlet JS_ENV = '';\n// @ts-ignore\nif (typeof Deno !== 'undefined') {\n    JS_ENV = 'deno';\n}\nelse if (typeof document !== 'undefined') {\n    JS_ENV = 'web';\n}\nelse if (typeof navigator !== 'undefined' && navigator.product === 'ReactNative') {\n    JS_ENV = 'react-native';\n}\nelse {\n    JS_ENV = 'node';\n}\nconst DEFAULT_HEADERS = { 'X-Client-Info': `supabase-js-${JS_ENV}/${_version__WEBPACK_IMPORTED_MODULE_0__.version}` };\nconst DEFAULT_GLOBAL_OPTIONS = {\n    headers: DEFAULT_HEADERS,\n};\nconst DEFAULT_DB_OPTIONS = {\n    schema: 'public',\n};\nconst DEFAULT_AUTH_OPTIONS = {\n    autoRefreshToken: true,\n    persistSession: true,\n    detectSessionInUrl: true,\n    flowType: 'implicit',\n};\nconst DEFAULT_REALTIME_OPTIONS = {};\n//# sourceMappingURL=constants.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2Uvc3VwYWJhc2UtanMvZGlzdC9tb2R1bGUvbGliL2NvbnN0YW50cy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLDBCQUEwQixnQ0FBZ0MsT0FBTyxHQUFHLDZDQUFPLENBQUM7QUFDNUU7QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCIsInNvdXJjZXMiOlsiRDpcXG5leHRcXG9yZ1xcbm9kZV9tb2R1bGVzXFxAc3VwYWJhc2VcXHN1cGFiYXNlLWpzXFxkaXN0XFxtb2R1bGVcXGxpYlxcY29uc3RhbnRzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHZlcnNpb24gfSBmcm9tICcuL3ZlcnNpb24nO1xubGV0IEpTX0VOViA9ICcnO1xuLy8gQHRzLWlnbm9yZVxuaWYgKHR5cGVvZiBEZW5vICE9PSAndW5kZWZpbmVkJykge1xuICAgIEpTX0VOViA9ICdkZW5vJztcbn1cbmVsc2UgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBKU19FTlYgPSAnd2ViJztcbn1cbmVsc2UgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci5wcm9kdWN0ID09PSAnUmVhY3ROYXRpdmUnKSB7XG4gICAgSlNfRU5WID0gJ3JlYWN0LW5hdGl2ZSc7XG59XG5lbHNlIHtcbiAgICBKU19FTlYgPSAnbm9kZSc7XG59XG5leHBvcnQgY29uc3QgREVGQVVMVF9IRUFERVJTID0geyAnWC1DbGllbnQtSW5mbyc6IGBzdXBhYmFzZS1qcy0ke0pTX0VOVn0vJHt2ZXJzaW9ufWAgfTtcbmV4cG9ydCBjb25zdCBERUZBVUxUX0dMT0JBTF9PUFRJT05TID0ge1xuICAgIGhlYWRlcnM6IERFRkFVTFRfSEVBREVSUyxcbn07XG5leHBvcnQgY29uc3QgREVGQVVMVF9EQl9PUFRJT05TID0ge1xuICAgIHNjaGVtYTogJ3B1YmxpYycsXG59O1xuZXhwb3J0IGNvbnN0IERFRkFVTFRfQVVUSF9PUFRJT05TID0ge1xuICAgIGF1dG9SZWZyZXNoVG9rZW46IHRydWUsXG4gICAgcGVyc2lzdFNlc3Npb246IHRydWUsXG4gICAgZGV0ZWN0U2Vzc2lvbkluVXJsOiB0cnVlLFxuICAgIGZsb3dUeXBlOiAnaW1wbGljaXQnLFxufTtcbmV4cG9ydCBjb25zdCBERUZBVUxUX1JFQUxUSU1FX09QVElPTlMgPSB7fTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnN0YW50cy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/supabase-js/dist/module/lib/constants.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/supabase-js/dist/module/lib/fetch.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@supabase/supabase-js/dist/module/lib/fetch.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fetchWithAuth: () => (/* binding */ fetchWithAuth),\n/* harmony export */   resolveFetch: () => (/* binding */ resolveFetch),\n/* harmony export */   resolveHeadersConstructor: () => (/* binding */ resolveHeadersConstructor)\n/* harmony export */ });\n/* harmony import */ var _supabase_node_fetch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @supabase/node-fetch */ \"(app-pages-browser)/./node_modules/@supabase/node-fetch/browser.js\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n// @ts-ignore\n\nconst resolveFetch = (customFetch) => {\n    let _fetch;\n    if (customFetch) {\n        _fetch = customFetch;\n    }\n    else if (typeof fetch === 'undefined') {\n        _fetch = _supabase_node_fetch__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\n    }\n    else {\n        _fetch = fetch;\n    }\n    return (...args) => _fetch(...args);\n};\nconst resolveHeadersConstructor = () => {\n    if (typeof Headers === 'undefined') {\n        return _supabase_node_fetch__WEBPACK_IMPORTED_MODULE_0__.Headers;\n    }\n    return Headers;\n};\nconst fetchWithAuth = (supabaseKey, getAccessToken, customFetch) => {\n    const fetch = resolveFetch(customFetch);\n    const HeadersConstructor = resolveHeadersConstructor();\n    return (input, init) => __awaiter(void 0, void 0, void 0, function* () {\n        var _a;\n        const accessToken = (_a = (yield getAccessToken())) !== null && _a !== void 0 ? _a : supabaseKey;\n        let headers = new HeadersConstructor(init === null || init === void 0 ? void 0 : init.headers);\n        if (!headers.has('apikey')) {\n            headers.set('apikey', supabaseKey);\n        }\n        if (!headers.has('Authorization')) {\n            headers.set('Authorization', `Bearer ${accessToken}`);\n        }\n        return fetch(input, Object.assign(Object.assign({}, init), { headers }));\n    });\n};\n//# sourceMappingURL=fetch.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2Uvc3VwYWJhc2UtanMvZGlzdC9tb2R1bGUvbGliL2ZldGNoLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQSxpQkFBaUIsU0FBSSxJQUFJLFNBQUk7QUFDN0IsNEJBQTRCLCtEQUErRCxpQkFBaUI7QUFDNUc7QUFDQSxvQ0FBb0MsTUFBTSwrQkFBK0IsWUFBWTtBQUNyRixtQ0FBbUMsTUFBTSxtQ0FBbUMsWUFBWTtBQUN4RixnQ0FBZ0M7QUFDaEM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUM4RTtBQUN2RTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsNERBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLGVBQWUseURBQWdCO0FBQy9CO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsWUFBWTtBQUMvRDtBQUNBLDBEQUEwRCxXQUFXLFNBQVM7QUFDOUUsS0FBSztBQUNMO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFxuZXh0XFxvcmdcXG5vZGVfbW9kdWxlc1xcQHN1cGFiYXNlXFxzdXBhYmFzZS1qc1xcZGlzdFxcbW9kdWxlXFxsaWJcXGZldGNoLmpzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuLy8gQHRzLWlnbm9yZVxuaW1wb3J0IG5vZGVGZXRjaCwgeyBIZWFkZXJzIGFzIE5vZGVGZXRjaEhlYWRlcnMgfSBmcm9tICdAc3VwYWJhc2Uvbm9kZS1mZXRjaCc7XG5leHBvcnQgY29uc3QgcmVzb2x2ZUZldGNoID0gKGN1c3RvbUZldGNoKSA9PiB7XG4gICAgbGV0IF9mZXRjaDtcbiAgICBpZiAoY3VzdG9tRmV0Y2gpIHtcbiAgICAgICAgX2ZldGNoID0gY3VzdG9tRmV0Y2g7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBmZXRjaCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgX2ZldGNoID0gbm9kZUZldGNoO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgX2ZldGNoID0gZmV0Y2g7XG4gICAgfVxuICAgIHJldHVybiAoLi4uYXJncykgPT4gX2ZldGNoKC4uLmFyZ3MpO1xufTtcbmV4cG9ydCBjb25zdCByZXNvbHZlSGVhZGVyc0NvbnN0cnVjdG9yID0gKCkgPT4ge1xuICAgIGlmICh0eXBlb2YgSGVhZGVycyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIE5vZGVGZXRjaEhlYWRlcnM7XG4gICAgfVxuICAgIHJldHVybiBIZWFkZXJzO1xufTtcbmV4cG9ydCBjb25zdCBmZXRjaFdpdGhBdXRoID0gKHN1cGFiYXNlS2V5LCBnZXRBY2Nlc3NUb2tlbiwgY3VzdG9tRmV0Y2gpID0+IHtcbiAgICBjb25zdCBmZXRjaCA9IHJlc29sdmVGZXRjaChjdXN0b21GZXRjaCk7XG4gICAgY29uc3QgSGVhZGVyc0NvbnN0cnVjdG9yID0gcmVzb2x2ZUhlYWRlcnNDb25zdHJ1Y3RvcigpO1xuICAgIHJldHVybiAoaW5wdXQsIGluaXQpID0+IF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IGFjY2Vzc1Rva2VuID0gKF9hID0gKHlpZWxkIGdldEFjY2Vzc1Rva2VuKCkpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBzdXBhYmFzZUtleTtcbiAgICAgICAgbGV0IGhlYWRlcnMgPSBuZXcgSGVhZGVyc0NvbnN0cnVjdG9yKGluaXQgPT09IG51bGwgfHwgaW5pdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW5pdC5oZWFkZXJzKTtcbiAgICAgICAgaWYgKCFoZWFkZXJzLmhhcygnYXBpa2V5JykpIHtcbiAgICAgICAgICAgIGhlYWRlcnMuc2V0KCdhcGlrZXknLCBzdXBhYmFzZUtleSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFoZWFkZXJzLmhhcygnQXV0aG9yaXphdGlvbicpKSB7XG4gICAgICAgICAgICBoZWFkZXJzLnNldCgnQXV0aG9yaXphdGlvbicsIGBCZWFyZXIgJHthY2Nlc3NUb2tlbn1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmV0Y2goaW5wdXQsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgaW5pdCksIHsgaGVhZGVycyB9KSk7XG4gICAgfSk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmV0Y2guanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/supabase-js/dist/module/lib/fetch.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/supabase-js/dist/module/lib/helpers.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@supabase/supabase-js/dist/module/lib/helpers.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   applySettingDefaults: () => (/* binding */ applySettingDefaults),\n/* harmony export */   ensureTrailingSlash: () => (/* binding */ ensureTrailingSlash),\n/* harmony export */   isBrowser: () => (/* binding */ isBrowser),\n/* harmony export */   uuid: () => (/* binding */ uuid),\n/* harmony export */   validateSupabaseUrl: () => (/* binding */ validateSupabaseUrl)\n/* harmony export */ });\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nfunction uuid() {\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n        var r = (Math.random() * 16) | 0, v = c == 'x' ? r : (r & 0x3) | 0x8;\n        return v.toString(16);\n    });\n}\nfunction ensureTrailingSlash(url) {\n    return url.endsWith('/') ? url : url + '/';\n}\nconst isBrowser = () => typeof window !== 'undefined';\nfunction applySettingDefaults(options, defaults) {\n    var _a, _b;\n    const { db: dbOptions, auth: authOptions, realtime: realtimeOptions, global: globalOptions, } = options;\n    const { db: DEFAULT_DB_OPTIONS, auth: DEFAULT_AUTH_OPTIONS, realtime: DEFAULT_REALTIME_OPTIONS, global: DEFAULT_GLOBAL_OPTIONS, } = defaults;\n    const result = {\n        db: Object.assign(Object.assign({}, DEFAULT_DB_OPTIONS), dbOptions),\n        auth: Object.assign(Object.assign({}, DEFAULT_AUTH_OPTIONS), authOptions),\n        realtime: Object.assign(Object.assign({}, DEFAULT_REALTIME_OPTIONS), realtimeOptions),\n        storage: {},\n        global: Object.assign(Object.assign(Object.assign({}, DEFAULT_GLOBAL_OPTIONS), globalOptions), { headers: Object.assign(Object.assign({}, ((_a = DEFAULT_GLOBAL_OPTIONS === null || DEFAULT_GLOBAL_OPTIONS === void 0 ? void 0 : DEFAULT_GLOBAL_OPTIONS.headers) !== null && _a !== void 0 ? _a : {})), ((_b = globalOptions === null || globalOptions === void 0 ? void 0 : globalOptions.headers) !== null && _b !== void 0 ? _b : {})) }),\n        accessToken: () => __awaiter(this, void 0, void 0, function* () { return ''; }),\n    };\n    if (options.accessToken) {\n        result.accessToken = options.accessToken;\n    }\n    else {\n        // hack around Required<>\n        delete result.accessToken;\n    }\n    return result;\n}\n/**\n * Validates a Supabase client URL\n *\n * @param {string} supabaseUrl - The Supabase client URL string.\n * @returns {URL} - The validated base URL.\n * @throws {Error}\n */\nfunction validateSupabaseUrl(supabaseUrl) {\n    const trimmedUrl = supabaseUrl === null || supabaseUrl === void 0 ? void 0 : supabaseUrl.trim();\n    if (!trimmedUrl) {\n        throw new Error('supabaseUrl is required.');\n    }\n    if (!trimmedUrl.match(/^https?:\\/\\//i)) {\n        throw new Error('Invalid supabaseUrl: Must be a valid HTTP or HTTPS URL.');\n    }\n    try {\n        return new URL(ensureTrailingSlash(trimmedUrl));\n    }\n    catch (_a) {\n        throw Error('Invalid supabaseUrl: Provided URL is malformed.');\n    }\n}\n//# sourceMappingURL=helpers.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2Uvc3VwYWJhc2UtanMvZGlzdC9tb2R1bGUvbGliL2hlbHBlcnMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQSxpQkFBaUIsU0FBSSxJQUFJLFNBQUk7QUFDN0IsNEJBQTRCLCtEQUErRCxpQkFBaUI7QUFDNUc7QUFDQSxvQ0FBb0MsTUFBTSwrQkFBK0IsWUFBWTtBQUNyRixtQ0FBbUMsTUFBTSxtQ0FBbUMsWUFBWTtBQUN4RixnQ0FBZ0M7QUFDaEM7QUFDQSxLQUFLO0FBQ0w7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ0E7QUFDUDtBQUNBLFlBQVksc0ZBQXNGO0FBQ2xHLFlBQVksMEhBQTBIO0FBQ3RJO0FBQ0EsMENBQTBDO0FBQzFDLDRDQUE0QztBQUM1QyxnREFBZ0Q7QUFDaEQsbUJBQW1CO0FBQ25CLDREQUE0RCw2Q0FBNkMsdUNBQXVDLDRKQUE0SixtSUFBbUksSUFBSTtBQUNuYiwwRUFBMEUsWUFBWTtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLEtBQUs7QUFDbEIsWUFBWTtBQUNaO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFxuZXh0XFxvcmdcXG5vZGVfbW9kdWxlc1xcQHN1cGFiYXNlXFxzdXBhYmFzZS1qc1xcZGlzdFxcbW9kdWxlXFxsaWJcXGhlbHBlcnMuanMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5leHBvcnQgZnVuY3Rpb24gdXVpZCgpIHtcbiAgICByZXR1cm4gJ3h4eHh4eHh4LXh4eHgtNHh4eC15eHh4LXh4eHh4eHh4eHh4eCcucmVwbGFjZSgvW3h5XS9nLCBmdW5jdGlvbiAoYykge1xuICAgICAgICB2YXIgciA9IChNYXRoLnJhbmRvbSgpICogMTYpIHwgMCwgdiA9IGMgPT0gJ3gnID8gciA6IChyICYgMHgzKSB8IDB4ODtcbiAgICAgICAgcmV0dXJuIHYudG9TdHJpbmcoMTYpO1xuICAgIH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGVuc3VyZVRyYWlsaW5nU2xhc2godXJsKSB7XG4gICAgcmV0dXJuIHVybC5lbmRzV2l0aCgnLycpID8gdXJsIDogdXJsICsgJy8nO1xufVxuZXhwb3J0IGNvbnN0IGlzQnJvd3NlciA9ICgpID0+IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnO1xuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5U2V0dGluZ0RlZmF1bHRzKG9wdGlvbnMsIGRlZmF1bHRzKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBjb25zdCB7IGRiOiBkYk9wdGlvbnMsIGF1dGg6IGF1dGhPcHRpb25zLCByZWFsdGltZTogcmVhbHRpbWVPcHRpb25zLCBnbG9iYWw6IGdsb2JhbE9wdGlvbnMsIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IHsgZGI6IERFRkFVTFRfREJfT1BUSU9OUywgYXV0aDogREVGQVVMVF9BVVRIX09QVElPTlMsIHJlYWx0aW1lOiBERUZBVUxUX1JFQUxUSU1FX09QVElPTlMsIGdsb2JhbDogREVGQVVMVF9HTE9CQUxfT1BUSU9OUywgfSA9IGRlZmF1bHRzO1xuICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgICAgZGI6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVF9EQl9PUFRJT05TKSwgZGJPcHRpb25zKSxcbiAgICAgICAgYXV0aDogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX0FVVEhfT1BUSU9OUyksIGF1dGhPcHRpb25zKSxcbiAgICAgICAgcmVhbHRpbWU6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVF9SRUFMVElNRV9PUFRJT05TKSwgcmVhbHRpbWVPcHRpb25zKSxcbiAgICAgICAgc3RvcmFnZToge30sXG4gICAgICAgIGdsb2JhbDogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIERFRkFVTFRfR0xPQkFMX09QVElPTlMpLCBnbG9iYWxPcHRpb25zKSwgeyBoZWFkZXJzOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sICgoX2EgPSBERUZBVUxUX0dMT0JBTF9PUFRJT05TID09PSBudWxsIHx8IERFRkFVTFRfR0xPQkFMX09QVElPTlMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IERFRkFVTFRfR0xPQkFMX09QVElPTlMuaGVhZGVycykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDoge30pKSwgKChfYiA9IGdsb2JhbE9wdGlvbnMgPT09IG51bGwgfHwgZ2xvYmFsT3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZ2xvYmFsT3B0aW9ucy5oZWFkZXJzKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB7fSkpIH0pLFxuICAgICAgICBhY2Nlc3NUb2tlbjogKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkgeyByZXR1cm4gJyc7IH0pLFxuICAgIH07XG4gICAgaWYgKG9wdGlvbnMuYWNjZXNzVG9rZW4pIHtcbiAgICAgICAgcmVzdWx0LmFjY2Vzc1Rva2VuID0gb3B0aW9ucy5hY2Nlc3NUb2tlbjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIGhhY2sgYXJvdW5kIFJlcXVpcmVkPD5cbiAgICAgICAgZGVsZXRlIHJlc3VsdC5hY2Nlc3NUb2tlbjtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogVmFsaWRhdGVzIGEgU3VwYWJhc2UgY2xpZW50IFVSTFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdXBhYmFzZVVybCAtIFRoZSBTdXBhYmFzZSBjbGllbnQgVVJMIHN0cmluZy5cbiAqIEByZXR1cm5zIHtVUkx9IC0gVGhlIHZhbGlkYXRlZCBiYXNlIFVSTC5cbiAqIEB0aHJvd3Mge0Vycm9yfVxuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVTdXBhYmFzZVVybChzdXBhYmFzZVVybCkge1xuICAgIGNvbnN0IHRyaW1tZWRVcmwgPSBzdXBhYmFzZVVybCA9PT0gbnVsbCB8fCBzdXBhYmFzZVVybCA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3VwYWJhc2VVcmwudHJpbSgpO1xuICAgIGlmICghdHJpbW1lZFVybCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3N1cGFiYXNlVXJsIGlzIHJlcXVpcmVkLicpO1xuICAgIH1cbiAgICBpZiAoIXRyaW1tZWRVcmwubWF0Y2goL15odHRwcz86XFwvXFwvL2kpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdXBhYmFzZVVybDogTXVzdCBiZSBhIHZhbGlkIEhUVFAgb3IgSFRUUFMgVVJMLicpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gbmV3IFVSTChlbnN1cmVUcmFpbGluZ1NsYXNoKHRyaW1tZWRVcmwpKTtcbiAgICB9XG4gICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgIHRocm93IEVycm9yKCdJbnZhbGlkIHN1cGFiYXNlVXJsOiBQcm92aWRlZCBVUkwgaXMgbWFsZm9ybWVkLicpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhlbHBlcnMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/supabase-js/dist/module/lib/helpers.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@supabase/supabase-js/dist/module/lib/version.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@supabase/supabase-js/dist/module/lib/version.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\n// Generated automatically during releases by scripts/update-version-files.ts\n// This file provides runtime access to the package version for:\n// - HTTP request headers (e.g., X-Client-Info header for API requests)\n// - Debugging and support (identifying which version is running)\n// - Telemetry and logging (version reporting in errors/analytics)\n// - Ensuring build artifacts match the published package version\nconst version = '2.74.0';\n//# sourceMappingURL=version.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2Uvc3VwYWJhc2UtanMvZGlzdC9tb2R1bGUvbGliL3ZlcnNpb24uanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AiLCJzb3VyY2VzIjpbIkQ6XFxuZXh0XFxvcmdcXG5vZGVfbW9kdWxlc1xcQHN1cGFiYXNlXFxzdXBhYmFzZS1qc1xcZGlzdFxcbW9kdWxlXFxsaWJcXHZlcnNpb24uanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gR2VuZXJhdGVkIGF1dG9tYXRpY2FsbHkgZHVyaW5nIHJlbGVhc2VzIGJ5IHNjcmlwdHMvdXBkYXRlLXZlcnNpb24tZmlsZXMudHNcbi8vIFRoaXMgZmlsZSBwcm92aWRlcyBydW50aW1lIGFjY2VzcyB0byB0aGUgcGFja2FnZSB2ZXJzaW9uIGZvcjpcbi8vIC0gSFRUUCByZXF1ZXN0IGhlYWRlcnMgKGUuZy4sIFgtQ2xpZW50LUluZm8gaGVhZGVyIGZvciBBUEkgcmVxdWVzdHMpXG4vLyAtIERlYnVnZ2luZyBhbmQgc3VwcG9ydCAoaWRlbnRpZnlpbmcgd2hpY2ggdmVyc2lvbiBpcyBydW5uaW5nKVxuLy8gLSBUZWxlbWV0cnkgYW5kIGxvZ2dpbmcgKHZlcnNpb24gcmVwb3J0aW5nIGluIGVycm9ycy9hbmFseXRpY3MpXG4vLyAtIEVuc3VyaW5nIGJ1aWxkIGFydGlmYWN0cyBtYXRjaCB0aGUgcHVibGlzaGVkIHBhY2thZ2UgdmVyc2lvblxuZXhwb3J0IGNvbnN0IHZlcnNpb24gPSAnMi43NC4wJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZlcnNpb24uanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@supabase/supabase-js/dist/module/lib/version.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/bootstrap/dist/css/bootstrap.min.css":
/*!***********************************************************!*\
  !*** ./node_modules/bootstrap/dist/css/bootstrap.min.css ***!
  \***********************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"41c9cf9654c8\");\nif (true) { module.hot.accept() }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ib290c3RyYXAvZGlzdC9jc3MvYm9vdHN0cmFwLm1pbi5jc3MiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLGlFQUFlLGNBQWM7QUFDN0IsSUFBSSxJQUFVLElBQUksaUJBQWlCIiwic291cmNlcyI6WyJEOlxcbmV4dFxcb3JnXFxub2RlX21vZHVsZXNcXGJvb3RzdHJhcFxcZGlzdFxcY3NzXFxib290c3RyYXAubWluLmNzcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBcIjQxYzljZjk2NTRjOFwiXG5pZiAobW9kdWxlLmhvdCkgeyBtb2R1bGUuaG90LmFjY2VwdCgpIH1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/bootstrap/dist/css/bootstrap.min.css\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/filepond-plugin-image-preview/dist/filepond-plugin-image-preview.css":
/*!*******************************************************************************************!*\
  !*** ./node_modules/filepond-plugin-image-preview/dist/filepond-plugin-image-preview.css ***!
  \*******************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"52a3e07787a9\");\nif (true) { module.hot.accept() }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9maWxlcG9uZC1wbHVnaW4taW1hZ2UtcHJldmlldy9kaXN0L2ZpbGVwb25kLXBsdWdpbi1pbWFnZS1wcmV2aWV3LmNzcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsaUVBQWUsY0FBYztBQUM3QixJQUFJLElBQVUsSUFBSSxpQkFBaUIiLCJzb3VyY2VzIjpbIkQ6XFxuZXh0XFxvcmdcXG5vZGVfbW9kdWxlc1xcZmlsZXBvbmQtcGx1Z2luLWltYWdlLXByZXZpZXdcXGRpc3RcXGZpbGVwb25kLXBsdWdpbi1pbWFnZS1wcmV2aWV3LmNzcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBcIjUyYTNlMDc3ODdhOVwiXG5pZiAobW9kdWxlLmhvdCkgeyBtb2R1bGUuaG90LmFjY2VwdCgpIH1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/filepond-plugin-image-preview/dist/filepond-plugin-image-preview.css\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/filepond/dist/filepond.min.css":
/*!*****************************************************!*\
  !*** ./node_modules/filepond/dist/filepond.min.css ***!
  \*****************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"f1005388ccee\");\nif (true) { module.hot.accept() }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9maWxlcG9uZC9kaXN0L2ZpbGVwb25kLm1pbi5jc3MiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLGlFQUFlLGNBQWM7QUFDN0IsSUFBSSxJQUFVLElBQUksaUJBQWlCIiwic291cmNlcyI6WyJEOlxcbmV4dFxcb3JnXFxub2RlX21vZHVsZXNcXGZpbGVwb25kXFxkaXN0XFxmaWxlcG9uZC5taW4uY3NzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IFwiZjEwMDUzODhjY2VlXCJcbmlmIChtb2R1bGUuaG90KSB7IG1vZHVsZS5ob3QuYWNjZXB0KCkgfVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/filepond/dist/filepond.min.css\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22D%3A%5C%5Cnext%5C%5Corg%5C%5Csrc%5C%5Capp%5C%5Clayout.js%22%2C%22ids%22%3A%5B%5D%7D&server=false!":
/*!*************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22D%3A%5C%5Cnext%5C%5Corg%5C%5Csrc%5C%5Capp%5C%5Clayout.js%22%2C%22ids%22%3A%5B%5D%7D&server=false! ***!
  \*************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("Promise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./src/app/layout.js */ \"(app-pages-browser)/./src/app/layout.js\"));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtZmxpZ2h0LWNsaWVudC1lbnRyeS1sb2FkZXIuanM/bW9kdWxlcz0lN0IlMjJyZXF1ZXN0JTIyJTNBJTIyRCUzQSU1QyU1Q25leHQlNUMlNUNvcmclNUMlNUNzcmMlNUMlNUNhcHAlNUMlNUNsYXlvdXQuanMlMjIlMkMlMjJpZHMlMjIlM0ElNUIlNUQlN0Qmc2VydmVyPWZhbHNlISIsIm1hcHBpbmdzIjoiQUFBQSxnS0FBdUUiLCJzb3VyY2VzIjpbIiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQoLyogd2VicGFja01vZGU6IFwiZWFnZXJcIiAqLyBcIkQ6XFxcXG5leHRcXFxcb3JnXFxcXHNyY1xcXFxhcHBcXFxcbGF5b3V0LmpzXCIpO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22D%3A%5C%5Cnext%5C%5Corg%5C%5Csrc%5C%5Capp%5C%5Clayout.js%22%2C%22ids%22%3A%5B%5D%7D&server=false!\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/noop-head.js":
/*!***************************************************************!*\
  !*** ./node_modules/next/dist/client/components/noop-head.js ***!
  \***************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: function() {\n        return NoopHead;\n    }\n}));\nfunction NoopHead() {\n    return null;\n}\n_c = NoopHead;\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=noop-head.js.map\nvar _c;\n$RefreshReg$(_c, \"NoopHead\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvbm9vcC1oZWFkLmpzIiwibWFwcGluZ3MiOiI7Ozs7MkNBQUE7OztlQUF3QkE7OztBQUFUO0lBQ2IsT0FBTztBQUNUO0tBRndCQSIsInNvdXJjZXMiOlsiRDpcXHNyY1xcY2xpZW50XFxjb21wb25lbnRzXFxub29wLWhlYWQudHN4Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIE5vb3BIZWFkKCkge1xuICByZXR1cm4gbnVsbFxufVxuIl0sIm5hbWVzIjpbIk5vb3BIZWFkIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/noop-head.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/buffer/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/next/dist/compiled/buffer/index.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("var __dirname = \"/\";\n(function(){var e={675:function(e,r){\"use strict\";r.byteLength=byteLength;r.toByteArray=toByteArray;r.fromByteArray=fromByteArray;var t=[];var f=[];var n=typeof Uint8Array!==\"undefined\"?Uint8Array:Array;var i=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";for(var o=0,u=i.length;o<u;++o){t[o]=i[o];f[i.charCodeAt(o)]=o}f[\"-\".charCodeAt(0)]=62;f[\"_\".charCodeAt(0)]=63;function getLens(e){var r=e.length;if(r%4>0){throw new Error(\"Invalid string. Length must be a multiple of 4\")}var t=e.indexOf(\"=\");if(t===-1)t=r;var f=t===r?0:4-t%4;return[t,f]}function byteLength(e){var r=getLens(e);var t=r[0];var f=r[1];return(t+f)*3/4-f}function _byteLength(e,r,t){return(r+t)*3/4-t}function toByteArray(e){var r;var t=getLens(e);var i=t[0];var o=t[1];var u=new n(_byteLength(e,i,o));var a=0;var s=o>0?i-4:i;var h;for(h=0;h<s;h+=4){r=f[e.charCodeAt(h)]<<18|f[e.charCodeAt(h+1)]<<12|f[e.charCodeAt(h+2)]<<6|f[e.charCodeAt(h+3)];u[a++]=r>>16&255;u[a++]=r>>8&255;u[a++]=r&255}if(o===2){r=f[e.charCodeAt(h)]<<2|f[e.charCodeAt(h+1)]>>4;u[a++]=r&255}if(o===1){r=f[e.charCodeAt(h)]<<10|f[e.charCodeAt(h+1)]<<4|f[e.charCodeAt(h+2)]>>2;u[a++]=r>>8&255;u[a++]=r&255}return u}function tripletToBase64(e){return t[e>>18&63]+t[e>>12&63]+t[e>>6&63]+t[e&63]}function encodeChunk(e,r,t){var f;var n=[];for(var i=r;i<t;i+=3){f=(e[i]<<16&16711680)+(e[i+1]<<8&65280)+(e[i+2]&255);n.push(tripletToBase64(f))}return n.join(\"\")}function fromByteArray(e){var r;var f=e.length;var n=f%3;var i=[];var o=16383;for(var u=0,a=f-n;u<a;u+=o){i.push(encodeChunk(e,u,u+o>a?a:u+o))}if(n===1){r=e[f-1];i.push(t[r>>2]+t[r<<4&63]+\"==\")}else if(n===2){r=(e[f-2]<<8)+e[f-1];i.push(t[r>>10]+t[r>>4&63]+t[r<<2&63]+\"=\")}return i.join(\"\")}},72:function(e,r,t){\"use strict\";\n/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */var f=t(675);var n=t(783);var i=typeof Symbol===\"function\"&&typeof Symbol.for===\"function\"?Symbol.for(\"nodejs.util.inspect.custom\"):null;r.Buffer=Buffer;r.SlowBuffer=SlowBuffer;r.INSPECT_MAX_BYTES=50;var o=2147483647;r.kMaxLength=o;Buffer.TYPED_ARRAY_SUPPORT=typedArraySupport();if(!Buffer.TYPED_ARRAY_SUPPORT&&typeof console!==\"undefined\"&&typeof console.error===\"function\"){console.error(\"This browser lacks typed array (Uint8Array) support which is required by \"+\"`buffer` v5.x. Use `buffer` v4.x if you require old browser support.\")}function typedArraySupport(){try{var e=new Uint8Array(1);var r={foo:function(){return 42}};Object.setPrototypeOf(r,Uint8Array.prototype);Object.setPrototypeOf(e,r);return e.foo()===42}catch(e){return false}}Object.defineProperty(Buffer.prototype,\"parent\",{enumerable:true,get:function(){if(!Buffer.isBuffer(this))return undefined;return this.buffer}});Object.defineProperty(Buffer.prototype,\"offset\",{enumerable:true,get:function(){if(!Buffer.isBuffer(this))return undefined;return this.byteOffset}});function createBuffer(e){if(e>o){throw new RangeError('The value \"'+e+'\" is invalid for option \"size\"')}var r=new Uint8Array(e);Object.setPrototypeOf(r,Buffer.prototype);return r}function Buffer(e,r,t){if(typeof e===\"number\"){if(typeof r===\"string\"){throw new TypeError('The \"string\" argument must be of type string. Received type number')}return allocUnsafe(e)}return from(e,r,t)}Buffer.poolSize=8192;function from(e,r,t){if(typeof e===\"string\"){return fromString(e,r)}if(ArrayBuffer.isView(e)){return fromArrayLike(e)}if(e==null){throw new TypeError(\"The first argument must be one of type string, Buffer, ArrayBuffer, Array, \"+\"or Array-like Object. Received type \"+typeof e)}if(isInstance(e,ArrayBuffer)||e&&isInstance(e.buffer,ArrayBuffer)){return fromArrayBuffer(e,r,t)}if(typeof SharedArrayBuffer!==\"undefined\"&&(isInstance(e,SharedArrayBuffer)||e&&isInstance(e.buffer,SharedArrayBuffer))){return fromArrayBuffer(e,r,t)}if(typeof e===\"number\"){throw new TypeError('The \"value\" argument must not be of type number. Received type number')}var f=e.valueOf&&e.valueOf();if(f!=null&&f!==e){return Buffer.from(f,r,t)}var n=fromObject(e);if(n)return n;if(typeof Symbol!==\"undefined\"&&Symbol.toPrimitive!=null&&typeof e[Symbol.toPrimitive]===\"function\"){return Buffer.from(e[Symbol.toPrimitive](\"string\"),r,t)}throw new TypeError(\"The first argument must be one of type string, Buffer, ArrayBuffer, Array, \"+\"or Array-like Object. Received type \"+typeof e)}Buffer.from=function(e,r,t){return from(e,r,t)};Object.setPrototypeOf(Buffer.prototype,Uint8Array.prototype);Object.setPrototypeOf(Buffer,Uint8Array);function assertSize(e){if(typeof e!==\"number\"){throw new TypeError('\"size\" argument must be of type number')}else if(e<0){throw new RangeError('The value \"'+e+'\" is invalid for option \"size\"')}}function alloc(e,r,t){assertSize(e);if(e<=0){return createBuffer(e)}if(r!==undefined){return typeof t===\"string\"?createBuffer(e).fill(r,t):createBuffer(e).fill(r)}return createBuffer(e)}Buffer.alloc=function(e,r,t){return alloc(e,r,t)};function allocUnsafe(e){assertSize(e);return createBuffer(e<0?0:checked(e)|0)}Buffer.allocUnsafe=function(e){return allocUnsafe(e)};Buffer.allocUnsafeSlow=function(e){return allocUnsafe(e)};function fromString(e,r){if(typeof r!==\"string\"||r===\"\"){r=\"utf8\"}if(!Buffer.isEncoding(r)){throw new TypeError(\"Unknown encoding: \"+r)}var t=byteLength(e,r)|0;var f=createBuffer(t);var n=f.write(e,r);if(n!==t){f=f.slice(0,n)}return f}function fromArrayLike(e){var r=e.length<0?0:checked(e.length)|0;var t=createBuffer(r);for(var f=0;f<r;f+=1){t[f]=e[f]&255}return t}function fromArrayBuffer(e,r,t){if(r<0||e.byteLength<r){throw new RangeError('\"offset\" is outside of buffer bounds')}if(e.byteLength<r+(t||0)){throw new RangeError('\"length\" is outside of buffer bounds')}var f;if(r===undefined&&t===undefined){f=new Uint8Array(e)}else if(t===undefined){f=new Uint8Array(e,r)}else{f=new Uint8Array(e,r,t)}Object.setPrototypeOf(f,Buffer.prototype);return f}function fromObject(e){if(Buffer.isBuffer(e)){var r=checked(e.length)|0;var t=createBuffer(r);if(t.length===0){return t}e.copy(t,0,0,r);return t}if(e.length!==undefined){if(typeof e.length!==\"number\"||numberIsNaN(e.length)){return createBuffer(0)}return fromArrayLike(e)}if(e.type===\"Buffer\"&&Array.isArray(e.data)){return fromArrayLike(e.data)}}function checked(e){if(e>=o){throw new RangeError(\"Attempt to allocate Buffer larger than maximum \"+\"size: 0x\"+o.toString(16)+\" bytes\")}return e|0}function SlowBuffer(e){if(+e!=e){e=0}return Buffer.alloc(+e)}Buffer.isBuffer=function isBuffer(e){return e!=null&&e._isBuffer===true&&e!==Buffer.prototype};Buffer.compare=function compare(e,r){if(isInstance(e,Uint8Array))e=Buffer.from(e,e.offset,e.byteLength);if(isInstance(r,Uint8Array))r=Buffer.from(r,r.offset,r.byteLength);if(!Buffer.isBuffer(e)||!Buffer.isBuffer(r)){throw new TypeError('The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array')}if(e===r)return 0;var t=e.length;var f=r.length;for(var n=0,i=Math.min(t,f);n<i;++n){if(e[n]!==r[n]){t=e[n];f=r[n];break}}if(t<f)return-1;if(f<t)return 1;return 0};Buffer.isEncoding=function isEncoding(e){switch(String(e).toLowerCase()){case\"hex\":case\"utf8\":case\"utf-8\":case\"ascii\":case\"latin1\":case\"binary\":case\"base64\":case\"ucs2\":case\"ucs-2\":case\"utf16le\":case\"utf-16le\":return true;default:return false}};Buffer.concat=function concat(e,r){if(!Array.isArray(e)){throw new TypeError('\"list\" argument must be an Array of Buffers')}if(e.length===0){return Buffer.alloc(0)}var t;if(r===undefined){r=0;for(t=0;t<e.length;++t){r+=e[t].length}}var f=Buffer.allocUnsafe(r);var n=0;for(t=0;t<e.length;++t){var i=e[t];if(isInstance(i,Uint8Array)){i=Buffer.from(i)}if(!Buffer.isBuffer(i)){throw new TypeError('\"list\" argument must be an Array of Buffers')}i.copy(f,n);n+=i.length}return f};function byteLength(e,r){if(Buffer.isBuffer(e)){return e.length}if(ArrayBuffer.isView(e)||isInstance(e,ArrayBuffer)){return e.byteLength}if(typeof e!==\"string\"){throw new TypeError('The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. '+\"Received type \"+typeof e)}var t=e.length;var f=arguments.length>2&&arguments[2]===true;if(!f&&t===0)return 0;var n=false;for(;;){switch(r){case\"ascii\":case\"latin1\":case\"binary\":return t;case\"utf8\":case\"utf-8\":return utf8ToBytes(e).length;case\"ucs2\":case\"ucs-2\":case\"utf16le\":case\"utf-16le\":return t*2;case\"hex\":return t>>>1;case\"base64\":return base64ToBytes(e).length;default:if(n){return f?-1:utf8ToBytes(e).length}r=(\"\"+r).toLowerCase();n=true}}}Buffer.byteLength=byteLength;function slowToString(e,r,t){var f=false;if(r===undefined||r<0){r=0}if(r>this.length){return\"\"}if(t===undefined||t>this.length){t=this.length}if(t<=0){return\"\"}t>>>=0;r>>>=0;if(t<=r){return\"\"}if(!e)e=\"utf8\";while(true){switch(e){case\"hex\":return hexSlice(this,r,t);case\"utf8\":case\"utf-8\":return utf8Slice(this,r,t);case\"ascii\":return asciiSlice(this,r,t);case\"latin1\":case\"binary\":return latin1Slice(this,r,t);case\"base64\":return base64Slice(this,r,t);case\"ucs2\":case\"ucs-2\":case\"utf16le\":case\"utf-16le\":return utf16leSlice(this,r,t);default:if(f)throw new TypeError(\"Unknown encoding: \"+e);e=(e+\"\").toLowerCase();f=true}}}Buffer.prototype._isBuffer=true;function swap(e,r,t){var f=e[r];e[r]=e[t];e[t]=f}Buffer.prototype.swap16=function swap16(){var e=this.length;if(e%2!==0){throw new RangeError(\"Buffer size must be a multiple of 16-bits\")}for(var r=0;r<e;r+=2){swap(this,r,r+1)}return this};Buffer.prototype.swap32=function swap32(){var e=this.length;if(e%4!==0){throw new RangeError(\"Buffer size must be a multiple of 32-bits\")}for(var r=0;r<e;r+=4){swap(this,r,r+3);swap(this,r+1,r+2)}return this};Buffer.prototype.swap64=function swap64(){var e=this.length;if(e%8!==0){throw new RangeError(\"Buffer size must be a multiple of 64-bits\")}for(var r=0;r<e;r+=8){swap(this,r,r+7);swap(this,r+1,r+6);swap(this,r+2,r+5);swap(this,r+3,r+4)}return this};Buffer.prototype.toString=function toString(){var e=this.length;if(e===0)return\"\";if(arguments.length===0)return utf8Slice(this,0,e);return slowToString.apply(this,arguments)};Buffer.prototype.toLocaleString=Buffer.prototype.toString;Buffer.prototype.equals=function equals(e){if(!Buffer.isBuffer(e))throw new TypeError(\"Argument must be a Buffer\");if(this===e)return true;return Buffer.compare(this,e)===0};Buffer.prototype.inspect=function inspect(){var e=\"\";var t=r.INSPECT_MAX_BYTES;e=this.toString(\"hex\",0,t).replace(/(.{2})/g,\"$1 \").trim();if(this.length>t)e+=\" ... \";return\"<Buffer \"+e+\">\"};if(i){Buffer.prototype[i]=Buffer.prototype.inspect}Buffer.prototype.compare=function compare(e,r,t,f,n){if(isInstance(e,Uint8Array)){e=Buffer.from(e,e.offset,e.byteLength)}if(!Buffer.isBuffer(e)){throw new TypeError('The \"target\" argument must be one of type Buffer or Uint8Array. '+\"Received type \"+typeof e)}if(r===undefined){r=0}if(t===undefined){t=e?e.length:0}if(f===undefined){f=0}if(n===undefined){n=this.length}if(r<0||t>e.length||f<0||n>this.length){throw new RangeError(\"out of range index\")}if(f>=n&&r>=t){return 0}if(f>=n){return-1}if(r>=t){return 1}r>>>=0;t>>>=0;f>>>=0;n>>>=0;if(this===e)return 0;var i=n-f;var o=t-r;var u=Math.min(i,o);var a=this.slice(f,n);var s=e.slice(r,t);for(var h=0;h<u;++h){if(a[h]!==s[h]){i=a[h];o=s[h];break}}if(i<o)return-1;if(o<i)return 1;return 0};function bidirectionalIndexOf(e,r,t,f,n){if(e.length===0)return-1;if(typeof t===\"string\"){f=t;t=0}else if(t>2147483647){t=2147483647}else if(t<-2147483648){t=-2147483648}t=+t;if(numberIsNaN(t)){t=n?0:e.length-1}if(t<0)t=e.length+t;if(t>=e.length){if(n)return-1;else t=e.length-1}else if(t<0){if(n)t=0;else return-1}if(typeof r===\"string\"){r=Buffer.from(r,f)}if(Buffer.isBuffer(r)){if(r.length===0){return-1}return arrayIndexOf(e,r,t,f,n)}else if(typeof r===\"number\"){r=r&255;if(typeof Uint8Array.prototype.indexOf===\"function\"){if(n){return Uint8Array.prototype.indexOf.call(e,r,t)}else{return Uint8Array.prototype.lastIndexOf.call(e,r,t)}}return arrayIndexOf(e,[r],t,f,n)}throw new TypeError(\"val must be string, number or Buffer\")}function arrayIndexOf(e,r,t,f,n){var i=1;var o=e.length;var u=r.length;if(f!==undefined){f=String(f).toLowerCase();if(f===\"ucs2\"||f===\"ucs-2\"||f===\"utf16le\"||f===\"utf-16le\"){if(e.length<2||r.length<2){return-1}i=2;o/=2;u/=2;t/=2}}function read(e,r){if(i===1){return e[r]}else{return e.readUInt16BE(r*i)}}var a;if(n){var s=-1;for(a=t;a<o;a++){if(read(e,a)===read(r,s===-1?0:a-s)){if(s===-1)s=a;if(a-s+1===u)return s*i}else{if(s!==-1)a-=a-s;s=-1}}}else{if(t+u>o)t=o-u;for(a=t;a>=0;a--){var h=true;for(var c=0;c<u;c++){if(read(e,a+c)!==read(r,c)){h=false;break}}if(h)return a}}return-1}Buffer.prototype.includes=function includes(e,r,t){return this.indexOf(e,r,t)!==-1};Buffer.prototype.indexOf=function indexOf(e,r,t){return bidirectionalIndexOf(this,e,r,t,true)};Buffer.prototype.lastIndexOf=function lastIndexOf(e,r,t){return bidirectionalIndexOf(this,e,r,t,false)};function hexWrite(e,r,t,f){t=Number(t)||0;var n=e.length-t;if(!f){f=n}else{f=Number(f);if(f>n){f=n}}var i=r.length;if(f>i/2){f=i/2}for(var o=0;o<f;++o){var u=parseInt(r.substr(o*2,2),16);if(numberIsNaN(u))return o;e[t+o]=u}return o}function utf8Write(e,r,t,f){return blitBuffer(utf8ToBytes(r,e.length-t),e,t,f)}function asciiWrite(e,r,t,f){return blitBuffer(asciiToBytes(r),e,t,f)}function latin1Write(e,r,t,f){return asciiWrite(e,r,t,f)}function base64Write(e,r,t,f){return blitBuffer(base64ToBytes(r),e,t,f)}function ucs2Write(e,r,t,f){return blitBuffer(utf16leToBytes(r,e.length-t),e,t,f)}Buffer.prototype.write=function write(e,r,t,f){if(r===undefined){f=\"utf8\";t=this.length;r=0}else if(t===undefined&&typeof r===\"string\"){f=r;t=this.length;r=0}else if(isFinite(r)){r=r>>>0;if(isFinite(t)){t=t>>>0;if(f===undefined)f=\"utf8\"}else{f=t;t=undefined}}else{throw new Error(\"Buffer.write(string, encoding, offset[, length]) is no longer supported\")}var n=this.length-r;if(t===undefined||t>n)t=n;if(e.length>0&&(t<0||r<0)||r>this.length){throw new RangeError(\"Attempt to write outside buffer bounds\")}if(!f)f=\"utf8\";var i=false;for(;;){switch(f){case\"hex\":return hexWrite(this,e,r,t);case\"utf8\":case\"utf-8\":return utf8Write(this,e,r,t);case\"ascii\":return asciiWrite(this,e,r,t);case\"latin1\":case\"binary\":return latin1Write(this,e,r,t);case\"base64\":return base64Write(this,e,r,t);case\"ucs2\":case\"ucs-2\":case\"utf16le\":case\"utf-16le\":return ucs2Write(this,e,r,t);default:if(i)throw new TypeError(\"Unknown encoding: \"+f);f=(\"\"+f).toLowerCase();i=true}}};Buffer.prototype.toJSON=function toJSON(){return{type:\"Buffer\",data:Array.prototype.slice.call(this._arr||this,0)}};function base64Slice(e,r,t){if(r===0&&t===e.length){return f.fromByteArray(e)}else{return f.fromByteArray(e.slice(r,t))}}function utf8Slice(e,r,t){t=Math.min(e.length,t);var f=[];var n=r;while(n<t){var i=e[n];var o=null;var u=i>239?4:i>223?3:i>191?2:1;if(n+u<=t){var a,s,h,c;switch(u){case 1:if(i<128){o=i}break;case 2:a=e[n+1];if((a&192)===128){c=(i&31)<<6|a&63;if(c>127){o=c}}break;case 3:a=e[n+1];s=e[n+2];if((a&192)===128&&(s&192)===128){c=(i&15)<<12|(a&63)<<6|s&63;if(c>2047&&(c<55296||c>57343)){o=c}}break;case 4:a=e[n+1];s=e[n+2];h=e[n+3];if((a&192)===128&&(s&192)===128&&(h&192)===128){c=(i&15)<<18|(a&63)<<12|(s&63)<<6|h&63;if(c>65535&&c<1114112){o=c}}}}if(o===null){o=65533;u=1}else if(o>65535){o-=65536;f.push(o>>>10&1023|55296);o=56320|o&1023}f.push(o);n+=u}return decodeCodePointsArray(f)}var u=4096;function decodeCodePointsArray(e){var r=e.length;if(r<=u){return String.fromCharCode.apply(String,e)}var t=\"\";var f=0;while(f<r){t+=String.fromCharCode.apply(String,e.slice(f,f+=u))}return t}function asciiSlice(e,r,t){var f=\"\";t=Math.min(e.length,t);for(var n=r;n<t;++n){f+=String.fromCharCode(e[n]&127)}return f}function latin1Slice(e,r,t){var f=\"\";t=Math.min(e.length,t);for(var n=r;n<t;++n){f+=String.fromCharCode(e[n])}return f}function hexSlice(e,r,t){var f=e.length;if(!r||r<0)r=0;if(!t||t<0||t>f)t=f;var n=\"\";for(var i=r;i<t;++i){n+=s[e[i]]}return n}function utf16leSlice(e,r,t){var f=e.slice(r,t);var n=\"\";for(var i=0;i<f.length;i+=2){n+=String.fromCharCode(f[i]+f[i+1]*256)}return n}Buffer.prototype.slice=function slice(e,r){var t=this.length;e=~~e;r=r===undefined?t:~~r;if(e<0){e+=t;if(e<0)e=0}else if(e>t){e=t}if(r<0){r+=t;if(r<0)r=0}else if(r>t){r=t}if(r<e)r=e;var f=this.subarray(e,r);Object.setPrototypeOf(f,Buffer.prototype);return f};function checkOffset(e,r,t){if(e%1!==0||e<0)throw new RangeError(\"offset is not uint\");if(e+r>t)throw new RangeError(\"Trying to access beyond buffer length\")}Buffer.prototype.readUIntLE=function readUIntLE(e,r,t){e=e>>>0;r=r>>>0;if(!t)checkOffset(e,r,this.length);var f=this[e];var n=1;var i=0;while(++i<r&&(n*=256)){f+=this[e+i]*n}return f};Buffer.prototype.readUIntBE=function readUIntBE(e,r,t){e=e>>>0;r=r>>>0;if(!t){checkOffset(e,r,this.length)}var f=this[e+--r];var n=1;while(r>0&&(n*=256)){f+=this[e+--r]*n}return f};Buffer.prototype.readUInt8=function readUInt8(e,r){e=e>>>0;if(!r)checkOffset(e,1,this.length);return this[e]};Buffer.prototype.readUInt16LE=function readUInt16LE(e,r){e=e>>>0;if(!r)checkOffset(e,2,this.length);return this[e]|this[e+1]<<8};Buffer.prototype.readUInt16BE=function readUInt16BE(e,r){e=e>>>0;if(!r)checkOffset(e,2,this.length);return this[e]<<8|this[e+1]};Buffer.prototype.readUInt32LE=function readUInt32LE(e,r){e=e>>>0;if(!r)checkOffset(e,4,this.length);return(this[e]|this[e+1]<<8|this[e+2]<<16)+this[e+3]*16777216};Buffer.prototype.readUInt32BE=function readUInt32BE(e,r){e=e>>>0;if(!r)checkOffset(e,4,this.length);return this[e]*16777216+(this[e+1]<<16|this[e+2]<<8|this[e+3])};Buffer.prototype.readIntLE=function readIntLE(e,r,t){e=e>>>0;r=r>>>0;if(!t)checkOffset(e,r,this.length);var f=this[e];var n=1;var i=0;while(++i<r&&(n*=256)){f+=this[e+i]*n}n*=128;if(f>=n)f-=Math.pow(2,8*r);return f};Buffer.prototype.readIntBE=function readIntBE(e,r,t){e=e>>>0;r=r>>>0;if(!t)checkOffset(e,r,this.length);var f=r;var n=1;var i=this[e+--f];while(f>0&&(n*=256)){i+=this[e+--f]*n}n*=128;if(i>=n)i-=Math.pow(2,8*r);return i};Buffer.prototype.readInt8=function readInt8(e,r){e=e>>>0;if(!r)checkOffset(e,1,this.length);if(!(this[e]&128))return this[e];return(255-this[e]+1)*-1};Buffer.prototype.readInt16LE=function readInt16LE(e,r){e=e>>>0;if(!r)checkOffset(e,2,this.length);var t=this[e]|this[e+1]<<8;return t&32768?t|4294901760:t};Buffer.prototype.readInt16BE=function readInt16BE(e,r){e=e>>>0;if(!r)checkOffset(e,2,this.length);var t=this[e+1]|this[e]<<8;return t&32768?t|4294901760:t};Buffer.prototype.readInt32LE=function readInt32LE(e,r){e=e>>>0;if(!r)checkOffset(e,4,this.length);return this[e]|this[e+1]<<8|this[e+2]<<16|this[e+3]<<24};Buffer.prototype.readInt32BE=function readInt32BE(e,r){e=e>>>0;if(!r)checkOffset(e,4,this.length);return this[e]<<24|this[e+1]<<16|this[e+2]<<8|this[e+3]};Buffer.prototype.readFloatLE=function readFloatLE(e,r){e=e>>>0;if(!r)checkOffset(e,4,this.length);return n.read(this,e,true,23,4)};Buffer.prototype.readFloatBE=function readFloatBE(e,r){e=e>>>0;if(!r)checkOffset(e,4,this.length);return n.read(this,e,false,23,4)};Buffer.prototype.readDoubleLE=function readDoubleLE(e,r){e=e>>>0;if(!r)checkOffset(e,8,this.length);return n.read(this,e,true,52,8)};Buffer.prototype.readDoubleBE=function readDoubleBE(e,r){e=e>>>0;if(!r)checkOffset(e,8,this.length);return n.read(this,e,false,52,8)};function checkInt(e,r,t,f,n,i){if(!Buffer.isBuffer(e))throw new TypeError('\"buffer\" argument must be a Buffer instance');if(r>n||r<i)throw new RangeError('\"value\" argument is out of bounds');if(t+f>e.length)throw new RangeError(\"Index out of range\")}Buffer.prototype.writeUIntLE=function writeUIntLE(e,r,t,f){e=+e;r=r>>>0;t=t>>>0;if(!f){var n=Math.pow(2,8*t)-1;checkInt(this,e,r,t,n,0)}var i=1;var o=0;this[r]=e&255;while(++o<t&&(i*=256)){this[r+o]=e/i&255}return r+t};Buffer.prototype.writeUIntBE=function writeUIntBE(e,r,t,f){e=+e;r=r>>>0;t=t>>>0;if(!f){var n=Math.pow(2,8*t)-1;checkInt(this,e,r,t,n,0)}var i=t-1;var o=1;this[r+i]=e&255;while(--i>=0&&(o*=256)){this[r+i]=e/o&255}return r+t};Buffer.prototype.writeUInt8=function writeUInt8(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,1,255,0);this[r]=e&255;return r+1};Buffer.prototype.writeUInt16LE=function writeUInt16LE(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,2,65535,0);this[r]=e&255;this[r+1]=e>>>8;return r+2};Buffer.prototype.writeUInt16BE=function writeUInt16BE(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,2,65535,0);this[r]=e>>>8;this[r+1]=e&255;return r+2};Buffer.prototype.writeUInt32LE=function writeUInt32LE(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,4,4294967295,0);this[r+3]=e>>>24;this[r+2]=e>>>16;this[r+1]=e>>>8;this[r]=e&255;return r+4};Buffer.prototype.writeUInt32BE=function writeUInt32BE(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,4,4294967295,0);this[r]=e>>>24;this[r+1]=e>>>16;this[r+2]=e>>>8;this[r+3]=e&255;return r+4};Buffer.prototype.writeIntLE=function writeIntLE(e,r,t,f){e=+e;r=r>>>0;if(!f){var n=Math.pow(2,8*t-1);checkInt(this,e,r,t,n-1,-n)}var i=0;var o=1;var u=0;this[r]=e&255;while(++i<t&&(o*=256)){if(e<0&&u===0&&this[r+i-1]!==0){u=1}this[r+i]=(e/o>>0)-u&255}return r+t};Buffer.prototype.writeIntBE=function writeIntBE(e,r,t,f){e=+e;r=r>>>0;if(!f){var n=Math.pow(2,8*t-1);checkInt(this,e,r,t,n-1,-n)}var i=t-1;var o=1;var u=0;this[r+i]=e&255;while(--i>=0&&(o*=256)){if(e<0&&u===0&&this[r+i+1]!==0){u=1}this[r+i]=(e/o>>0)-u&255}return r+t};Buffer.prototype.writeInt8=function writeInt8(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,1,127,-128);if(e<0)e=255+e+1;this[r]=e&255;return r+1};Buffer.prototype.writeInt16LE=function writeInt16LE(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,2,32767,-32768);this[r]=e&255;this[r+1]=e>>>8;return r+2};Buffer.prototype.writeInt16BE=function writeInt16BE(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,2,32767,-32768);this[r]=e>>>8;this[r+1]=e&255;return r+2};Buffer.prototype.writeInt32LE=function writeInt32LE(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,4,2147483647,-2147483648);this[r]=e&255;this[r+1]=e>>>8;this[r+2]=e>>>16;this[r+3]=e>>>24;return r+4};Buffer.prototype.writeInt32BE=function writeInt32BE(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,4,2147483647,-2147483648);if(e<0)e=4294967295+e+1;this[r]=e>>>24;this[r+1]=e>>>16;this[r+2]=e>>>8;this[r+3]=e&255;return r+4};function checkIEEE754(e,r,t,f,n,i){if(t+f>e.length)throw new RangeError(\"Index out of range\");if(t<0)throw new RangeError(\"Index out of range\")}function writeFloat(e,r,t,f,i){r=+r;t=t>>>0;if(!i){checkIEEE754(e,r,t,4,34028234663852886e22,-34028234663852886e22)}n.write(e,r,t,f,23,4);return t+4}Buffer.prototype.writeFloatLE=function writeFloatLE(e,r,t){return writeFloat(this,e,r,true,t)};Buffer.prototype.writeFloatBE=function writeFloatBE(e,r,t){return writeFloat(this,e,r,false,t)};function writeDouble(e,r,t,f,i){r=+r;t=t>>>0;if(!i){checkIEEE754(e,r,t,8,17976931348623157e292,-17976931348623157e292)}n.write(e,r,t,f,52,8);return t+8}Buffer.prototype.writeDoubleLE=function writeDoubleLE(e,r,t){return writeDouble(this,e,r,true,t)};Buffer.prototype.writeDoubleBE=function writeDoubleBE(e,r,t){return writeDouble(this,e,r,false,t)};Buffer.prototype.copy=function copy(e,r,t,f){if(!Buffer.isBuffer(e))throw new TypeError(\"argument should be a Buffer\");if(!t)t=0;if(!f&&f!==0)f=this.length;if(r>=e.length)r=e.length;if(!r)r=0;if(f>0&&f<t)f=t;if(f===t)return 0;if(e.length===0||this.length===0)return 0;if(r<0){throw new RangeError(\"targetStart out of bounds\")}if(t<0||t>=this.length)throw new RangeError(\"Index out of range\");if(f<0)throw new RangeError(\"sourceEnd out of bounds\");if(f>this.length)f=this.length;if(e.length-r<f-t){f=e.length-r+t}var n=f-t;if(this===e&&typeof Uint8Array.prototype.copyWithin===\"function\"){this.copyWithin(r,t,f)}else if(this===e&&t<r&&r<f){for(var i=n-1;i>=0;--i){e[i+r]=this[i+t]}}else{Uint8Array.prototype.set.call(e,this.subarray(t,f),r)}return n};Buffer.prototype.fill=function fill(e,r,t,f){if(typeof e===\"string\"){if(typeof r===\"string\"){f=r;r=0;t=this.length}else if(typeof t===\"string\"){f=t;t=this.length}if(f!==undefined&&typeof f!==\"string\"){throw new TypeError(\"encoding must be a string\")}if(typeof f===\"string\"&&!Buffer.isEncoding(f)){throw new TypeError(\"Unknown encoding: \"+f)}if(e.length===1){var n=e.charCodeAt(0);if(f===\"utf8\"&&n<128||f===\"latin1\"){e=n}}}else if(typeof e===\"number\"){e=e&255}else if(typeof e===\"boolean\"){e=Number(e)}if(r<0||this.length<r||this.length<t){throw new RangeError(\"Out of range index\")}if(t<=r){return this}r=r>>>0;t=t===undefined?this.length:t>>>0;if(!e)e=0;var i;if(typeof e===\"number\"){for(i=r;i<t;++i){this[i]=e}}else{var o=Buffer.isBuffer(e)?e:Buffer.from(e,f);var u=o.length;if(u===0){throw new TypeError('The value \"'+e+'\" is invalid for argument \"value\"')}for(i=0;i<t-r;++i){this[i+r]=o[i%u]}}return this};var a=/[^+/0-9A-Za-z-_]/g;function base64clean(e){e=e.split(\"=\")[0];e=e.trim().replace(a,\"\");if(e.length<2)return\"\";while(e.length%4!==0){e=e+\"=\"}return e}function utf8ToBytes(e,r){r=r||Infinity;var t;var f=e.length;var n=null;var i=[];for(var o=0;o<f;++o){t=e.charCodeAt(o);if(t>55295&&t<57344){if(!n){if(t>56319){if((r-=3)>-1)i.push(239,191,189);continue}else if(o+1===f){if((r-=3)>-1)i.push(239,191,189);continue}n=t;continue}if(t<56320){if((r-=3)>-1)i.push(239,191,189);n=t;continue}t=(n-55296<<10|t-56320)+65536}else if(n){if((r-=3)>-1)i.push(239,191,189)}n=null;if(t<128){if((r-=1)<0)break;i.push(t)}else if(t<2048){if((r-=2)<0)break;i.push(t>>6|192,t&63|128)}else if(t<65536){if((r-=3)<0)break;i.push(t>>12|224,t>>6&63|128,t&63|128)}else if(t<1114112){if((r-=4)<0)break;i.push(t>>18|240,t>>12&63|128,t>>6&63|128,t&63|128)}else{throw new Error(\"Invalid code point\")}}return i}function asciiToBytes(e){var r=[];for(var t=0;t<e.length;++t){r.push(e.charCodeAt(t)&255)}return r}function utf16leToBytes(e,r){var t,f,n;var i=[];for(var o=0;o<e.length;++o){if((r-=2)<0)break;t=e.charCodeAt(o);f=t>>8;n=t%256;i.push(n);i.push(f)}return i}function base64ToBytes(e){return f.toByteArray(base64clean(e))}function blitBuffer(e,r,t,f){for(var n=0;n<f;++n){if(n+t>=r.length||n>=e.length)break;r[n+t]=e[n]}return n}function isInstance(e,r){return e instanceof r||e!=null&&e.constructor!=null&&e.constructor.name!=null&&e.constructor.name===r.name}function numberIsNaN(e){return e!==e}var s=function(){var e=\"0123456789abcdef\";var r=new Array(256);for(var t=0;t<16;++t){var f=t*16;for(var n=0;n<16;++n){r[f+n]=e[t]+e[n]}}return r}()},783:function(e,r){\n/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\nr.read=function(e,r,t,f,n){var i,o;var u=n*8-f-1;var a=(1<<u)-1;var s=a>>1;var h=-7;var c=t?n-1:0;var l=t?-1:1;var p=e[r+c];c+=l;i=p&(1<<-h)-1;p>>=-h;h+=u;for(;h>0;i=i*256+e[r+c],c+=l,h-=8){}o=i&(1<<-h)-1;i>>=-h;h+=f;for(;h>0;o=o*256+e[r+c],c+=l,h-=8){}if(i===0){i=1-s}else if(i===a){return o?NaN:(p?-1:1)*Infinity}else{o=o+Math.pow(2,f);i=i-s}return(p?-1:1)*o*Math.pow(2,i-f)};r.write=function(e,r,t,f,n,i){var o,u,a;var s=i*8-n-1;var h=(1<<s)-1;var c=h>>1;var l=n===23?Math.pow(2,-24)-Math.pow(2,-77):0;var p=f?0:i-1;var y=f?1:-1;var g=r<0||r===0&&1/r<0?1:0;r=Math.abs(r);if(isNaN(r)||r===Infinity){u=isNaN(r)?1:0;o=h}else{o=Math.floor(Math.log(r)/Math.LN2);if(r*(a=Math.pow(2,-o))<1){o--;a*=2}if(o+c>=1){r+=l/a}else{r+=l*Math.pow(2,1-c)}if(r*a>=2){o++;a/=2}if(o+c>=h){u=0;o=h}else if(o+c>=1){u=(r*a-1)*Math.pow(2,n);o=o+c}else{u=r*Math.pow(2,c-1)*Math.pow(2,n);o=0}}for(;n>=8;e[t+p]=u&255,p+=y,u/=256,n-=8){}o=o<<n|u;s+=n;for(;s>0;e[t+p]=o&255,p+=y,o/=256,s-=8){}e[t+p-y]|=g*128}}};var r={};function __nccwpck_require__(t){var f=r[t];if(f!==undefined){return f.exports}var n=r[t]={exports:{}};var i=true;try{e[t](n,n.exports,__nccwpck_require__);i=false}finally{if(i)delete r[t]}return n.exports}if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var t=__nccwpck_require__(72);module.exports=t})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvYnVmZmVyL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7QUFBQSxZQUFZLE9BQU8sa0JBQWtCLGFBQWEsd0JBQXdCLDBCQUEwQiw4QkFBOEIsU0FBUyxTQUFTLHVEQUF1RCx5RUFBeUUsdUJBQXVCLElBQUksS0FBSyxVQUFVLHFCQUFxQix3QkFBd0Isd0JBQXdCLG9CQUFvQixlQUFlLFVBQVUsa0VBQWtFLHFCQUFxQixjQUFjLG9CQUFvQixZQUFZLHVCQUF1QixpQkFBaUIsV0FBVyxXQUFXLGtCQUFrQiw0QkFBNEIsa0JBQWtCLHdCQUF3QixNQUFNLGlCQUFpQixXQUFXLFdBQVcsZ0NBQWdDLFFBQVEsZ0JBQWdCLE1BQU0sUUFBUSxJQUFJLE1BQU0sK0ZBQStGLGlCQUFpQixnQkFBZ0IsYUFBYSxVQUFVLGdEQUFnRCxhQUFhLFVBQVUseUVBQXlFLGdCQUFnQixhQUFhLFNBQVMsNEJBQTRCLGtEQUFrRCw0QkFBNEIsTUFBTSxTQUFTLFlBQVksSUFBSSxNQUFNLHFEQUFxRCwyQkFBMkIsa0JBQWtCLDBCQUEwQixNQUFNLGVBQWUsVUFBVSxTQUFTLFlBQVksa0JBQWtCLElBQUksTUFBTSxxQ0FBcUMsVUFBVSxTQUFTLGdDQUFnQyxlQUFlLHFCQUFxQiwyQ0FBMkMsbUJBQW1CLG9CQUFvQjtBQUM5ckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixhQUFhLCtHQUErRyxnQkFBZ0Isd0JBQXdCLHVCQUF1QixpQkFBaUIsZUFBZSwrQ0FBK0MsaUdBQWlHLGtLQUFrSyw2QkFBNkIsSUFBSSx3QkFBd0IsT0FBTyxlQUFlLFlBQVksOENBQThDLDJCQUEyQixvQkFBb0IsU0FBUyxjQUFjLGlEQUFpRCwrQkFBK0IsMkNBQTJDLG9CQUFvQixFQUFFLGlEQUFpRCwrQkFBK0IsMkNBQTJDLHdCQUF3QixFQUFFLHlCQUF5QixRQUFRLHVFQUF1RSx3QkFBd0IsMENBQTBDLFNBQVMs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Q0FBK0MsY0FBYyxhQUFhLDRCQUE0QixjQUFjLDJCQUEyQixlQUFlLElBQUksS0FBSyxtQ0FBbUMsMkJBQTJCLElBQUksS0FBSyxXQUFXLE9BQU8sS0FBSyxxQkFBcUIsV0FBVyxJQUFJLEtBQUssV0FBVyxJQUFJLElBQUksZ0JBQWdCLHdCQUF3QixNQUFNLEtBQUssa0NBQWtDLEtBQUssS0FBSyxLQUFLLGdDQUFnQyxTQUFTLEtBQUssS0FBSyxJQUFJLGdDQUFnQyxtQkFBbUIsU0FBUyxnQ0FBZ0MsV0FBVyxrQkFBa0IsaUJBQWlCLFlBQVksWUFBWSxXQUFXLElBQUksc0NBQXNDLFFBQVEsUUFBUSxpQkFBaUIsaUJBQWlCLG1FQUFtRSxTQUFTLEtBQUssOEJBQThCLGlCQUFpQiIsInNvdXJjZXMiOlsiRDpcXG5leHRcXG9yZ1xcbm9kZV9tb2R1bGVzXFxuZXh0XFxkaXN0XFxjb21waWxlZFxcYnVmZmVyXFxpbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXt2YXIgZT17Njc1OmZ1bmN0aW9uKGUscil7XCJ1c2Ugc3RyaWN0XCI7ci5ieXRlTGVuZ3RoPWJ5dGVMZW5ndGg7ci50b0J5dGVBcnJheT10b0J5dGVBcnJheTtyLmZyb21CeXRlQXJyYXk9ZnJvbUJ5dGVBcnJheTt2YXIgdD1bXTt2YXIgZj1bXTt2YXIgbj10eXBlb2YgVWludDhBcnJheSE9PVwidW5kZWZpbmVkXCI/VWludDhBcnJheTpBcnJheTt2YXIgaT1cIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky9cIjtmb3IodmFyIG89MCx1PWkubGVuZ3RoO288dTsrK28pe3Rbb109aVtvXTtmW2kuY2hhckNvZGVBdChvKV09b31mW1wiLVwiLmNoYXJDb2RlQXQoMCldPTYyO2ZbXCJfXCIuY2hhckNvZGVBdCgwKV09NjM7ZnVuY3Rpb24gZ2V0TGVucyhlKXt2YXIgcj1lLmxlbmd0aDtpZihyJTQ+MCl7dGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNFwiKX12YXIgdD1lLmluZGV4T2YoXCI9XCIpO2lmKHQ9PT0tMSl0PXI7dmFyIGY9dD09PXI/MDo0LXQlNDtyZXR1cm5bdCxmXX1mdW5jdGlvbiBieXRlTGVuZ3RoKGUpe3ZhciByPWdldExlbnMoZSk7dmFyIHQ9clswXTt2YXIgZj1yWzFdO3JldHVybih0K2YpKjMvNC1mfWZ1bmN0aW9uIF9ieXRlTGVuZ3RoKGUscix0KXtyZXR1cm4ocit0KSozLzQtdH1mdW5jdGlvbiB0b0J5dGVBcnJheShlKXt2YXIgcjt2YXIgdD1nZXRMZW5zKGUpO3ZhciBpPXRbMF07dmFyIG89dFsxXTt2YXIgdT1uZXcgbihfYnl0ZUxlbmd0aChlLGksbykpO3ZhciBhPTA7dmFyIHM9bz4wP2ktNDppO3ZhciBoO2ZvcihoPTA7aDxzO2grPTQpe3I9ZltlLmNoYXJDb2RlQXQoaCldPDwxOHxmW2UuY2hhckNvZGVBdChoKzEpXTw8MTJ8ZltlLmNoYXJDb2RlQXQoaCsyKV08PDZ8ZltlLmNoYXJDb2RlQXQoaCszKV07dVthKytdPXI+PjE2JjI1NTt1W2ErK109cj4+OCYyNTU7dVthKytdPXImMjU1fWlmKG89PT0yKXtyPWZbZS5jaGFyQ29kZUF0KGgpXTw8MnxmW2UuY2hhckNvZGVBdChoKzEpXT4+NDt1W2ErK109ciYyNTV9aWYobz09PTEpe3I9ZltlLmNoYXJDb2RlQXQoaCldPDwxMHxmW2UuY2hhckNvZGVBdChoKzEpXTw8NHxmW2UuY2hhckNvZGVBdChoKzIpXT4+Mjt1W2ErK109cj4+OCYyNTU7dVthKytdPXImMjU1fXJldHVybiB1fWZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NChlKXtyZXR1cm4gdFtlPj4xOCY2M10rdFtlPj4xMiY2M10rdFtlPj42JjYzXSt0W2UmNjNdfWZ1bmN0aW9uIGVuY29kZUNodW5rKGUscix0KXt2YXIgZjt2YXIgbj1bXTtmb3IodmFyIGk9cjtpPHQ7aSs9Myl7Zj0oZVtpXTw8MTYmMTY3MTE2ODApKyhlW2krMV08PDgmNjUyODApKyhlW2krMl0mMjU1KTtuLnB1c2godHJpcGxldFRvQmFzZTY0KGYpKX1yZXR1cm4gbi5qb2luKFwiXCIpfWZ1bmN0aW9uIGZyb21CeXRlQXJyYXkoZSl7dmFyIHI7dmFyIGY9ZS5sZW5ndGg7dmFyIG49ZiUzO3ZhciBpPVtdO3ZhciBvPTE2MzgzO2Zvcih2YXIgdT0wLGE9Zi1uO3U8YTt1Kz1vKXtpLnB1c2goZW5jb2RlQ2h1bmsoZSx1LHUrbz5hP2E6dStvKSl9aWYobj09PTEpe3I9ZVtmLTFdO2kucHVzaCh0W3I+PjJdK3Rbcjw8NCY2M10rXCI9PVwiKX1lbHNlIGlmKG49PT0yKXtyPShlW2YtMl08PDgpK2VbZi0xXTtpLnB1c2godFtyPj4xMF0rdFtyPj40JjYzXSt0W3I8PDImNjNdK1wiPVwiKX1yZXR1cm4gaS5qb2luKFwiXCIpfX0sNzI6ZnVuY3Rpb24oZSxyLHQpe1widXNlIHN0cmljdFwiO1xuLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovdmFyIGY9dCg2NzUpO3ZhciBuPXQoNzgzKTt2YXIgaT10eXBlb2YgU3ltYm9sPT09XCJmdW5jdGlvblwiJiZ0eXBlb2YgU3ltYm9sLmZvcj09PVwiZnVuY3Rpb25cIj9TeW1ib2wuZm9yKFwibm9kZWpzLnV0aWwuaW5zcGVjdC5jdXN0b21cIik6bnVsbDtyLkJ1ZmZlcj1CdWZmZXI7ci5TbG93QnVmZmVyPVNsb3dCdWZmZXI7ci5JTlNQRUNUX01BWF9CWVRFUz01MDt2YXIgbz0yMTQ3NDgzNjQ3O3Iua01heExlbmd0aD1vO0J1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUPXR5cGVkQXJyYXlTdXBwb3J0KCk7aWYoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUJiZ0eXBlb2YgY29uc29sZSE9PVwidW5kZWZpbmVkXCImJnR5cGVvZiBjb25zb2xlLmVycm9yPT09XCJmdW5jdGlvblwiKXtjb25zb2xlLmVycm9yKFwiVGhpcyBicm93c2VyIGxhY2tzIHR5cGVkIGFycmF5IChVaW50OEFycmF5KSBzdXBwb3J0IHdoaWNoIGlzIHJlcXVpcmVkIGJ5IFwiK1wiYGJ1ZmZlcmAgdjUueC4gVXNlIGBidWZmZXJgIHY0LnggaWYgeW91IHJlcXVpcmUgb2xkIGJyb3dzZXIgc3VwcG9ydC5cIil9ZnVuY3Rpb24gdHlwZWRBcnJheVN1cHBvcnQoKXt0cnl7dmFyIGU9bmV3IFVpbnQ4QXJyYXkoMSk7dmFyIHI9e2ZvbzpmdW5jdGlvbigpe3JldHVybiA0Mn19O09iamVjdC5zZXRQcm90b3R5cGVPZihyLFVpbnQ4QXJyYXkucHJvdG90eXBlKTtPYmplY3Quc2V0UHJvdG90eXBlT2YoZSxyKTtyZXR1cm4gZS5mb28oKT09PTQyfWNhdGNoKGUpe3JldHVybiBmYWxzZX19T2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlci5wcm90b3R5cGUsXCJwYXJlbnRcIix7ZW51bWVyYWJsZTp0cnVlLGdldDpmdW5jdGlvbigpe2lmKCFCdWZmZXIuaXNCdWZmZXIodGhpcykpcmV0dXJuIHVuZGVmaW5lZDtyZXR1cm4gdGhpcy5idWZmZXJ9fSk7T2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlci5wcm90b3R5cGUsXCJvZmZzZXRcIix7ZW51bWVyYWJsZTp0cnVlLGdldDpmdW5jdGlvbigpe2lmKCFCdWZmZXIuaXNCdWZmZXIodGhpcykpcmV0dXJuIHVuZGVmaW5lZDtyZXR1cm4gdGhpcy5ieXRlT2Zmc2V0fX0pO2Z1bmN0aW9uIGNyZWF0ZUJ1ZmZlcihlKXtpZihlPm8pe3Rocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgXCInK2UrJ1wiIGlzIGludmFsaWQgZm9yIG9wdGlvbiBcInNpemVcIicpfXZhciByPW5ldyBVaW50OEFycmF5KGUpO09iamVjdC5zZXRQcm90b3R5cGVPZihyLEJ1ZmZlci5wcm90b3R5cGUpO3JldHVybiByfWZ1bmN0aW9uIEJ1ZmZlcihlLHIsdCl7aWYodHlwZW9mIGU9PT1cIm51bWJlclwiKXtpZih0eXBlb2Ygcj09PVwic3RyaW5nXCIpe3Rocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcInN0cmluZ1wiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBzdHJpbmcuIFJlY2VpdmVkIHR5cGUgbnVtYmVyJyl9cmV0dXJuIGFsbG9jVW5zYWZlKGUpfXJldHVybiBmcm9tKGUscix0KX1CdWZmZXIucG9vbFNpemU9ODE5MjtmdW5jdGlvbiBmcm9tKGUscix0KXtpZih0eXBlb2YgZT09PVwic3RyaW5nXCIpe3JldHVybiBmcm9tU3RyaW5nKGUscil9aWYoQXJyYXlCdWZmZXIuaXNWaWV3KGUpKXtyZXR1cm4gZnJvbUFycmF5TGlrZShlKX1pZihlPT1udWxsKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwiVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgXCIrXCJvciBBcnJheS1saWtlIE9iamVjdC4gUmVjZWl2ZWQgdHlwZSBcIit0eXBlb2YgZSl9aWYoaXNJbnN0YW5jZShlLEFycmF5QnVmZmVyKXx8ZSYmaXNJbnN0YW5jZShlLmJ1ZmZlcixBcnJheUJ1ZmZlcikpe3JldHVybiBmcm9tQXJyYXlCdWZmZXIoZSxyLHQpfWlmKHR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlciE9PVwidW5kZWZpbmVkXCImJihpc0luc3RhbmNlKGUsU2hhcmVkQXJyYXlCdWZmZXIpfHxlJiZpc0luc3RhbmNlKGUuYnVmZmVyLFNoYXJlZEFycmF5QnVmZmVyKSkpe3JldHVybiBmcm9tQXJyYXlCdWZmZXIoZSxyLHQpfWlmKHR5cGVvZiBlPT09XCJudW1iZXJcIil7dGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwidmFsdWVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBvZiB0eXBlIG51bWJlci4gUmVjZWl2ZWQgdHlwZSBudW1iZXInKX12YXIgZj1lLnZhbHVlT2YmJmUudmFsdWVPZigpO2lmKGYhPW51bGwmJmYhPT1lKXtyZXR1cm4gQnVmZmVyLmZyb20oZixyLHQpfXZhciBuPWZyb21PYmplY3QoZSk7aWYobilyZXR1cm4gbjtpZih0eXBlb2YgU3ltYm9sIT09XCJ1bmRlZmluZWRcIiYmU3ltYm9sLnRvUHJpbWl0aXZlIT1udWxsJiZ0eXBlb2YgZVtTeW1ib2wudG9QcmltaXRpdmVdPT09XCJmdW5jdGlvblwiKXtyZXR1cm4gQnVmZmVyLmZyb20oZVtTeW1ib2wudG9QcmltaXRpdmVdKFwic3RyaW5nXCIpLHIsdCl9dGhyb3cgbmV3IFR5cGVFcnJvcihcIlRoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksIFwiK1wib3IgQXJyYXktbGlrZSBPYmplY3QuIFJlY2VpdmVkIHR5cGUgXCIrdHlwZW9mIGUpfUJ1ZmZlci5mcm9tPWZ1bmN0aW9uKGUscix0KXtyZXR1cm4gZnJvbShlLHIsdCl9O09iamVjdC5zZXRQcm90b3R5cGVPZihCdWZmZXIucHJvdG90eXBlLFVpbnQ4QXJyYXkucHJvdG90eXBlKTtPYmplY3Quc2V0UHJvdG90eXBlT2YoQnVmZmVyLFVpbnQ4QXJyYXkpO2Z1bmN0aW9uIGFzc2VydFNpemUoZSl7aWYodHlwZW9mIGUhPT1cIm51bWJlclwiKXt0aHJvdyBuZXcgVHlwZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgbnVtYmVyJyl9ZWxzZSBpZihlPDApe3Rocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgXCInK2UrJ1wiIGlzIGludmFsaWQgZm9yIG9wdGlvbiBcInNpemVcIicpfX1mdW5jdGlvbiBhbGxvYyhlLHIsdCl7YXNzZXJ0U2l6ZShlKTtpZihlPD0wKXtyZXR1cm4gY3JlYXRlQnVmZmVyKGUpfWlmKHIhPT11bmRlZmluZWQpe3JldHVybiB0eXBlb2YgdD09PVwic3RyaW5nXCI/Y3JlYXRlQnVmZmVyKGUpLmZpbGwocix0KTpjcmVhdGVCdWZmZXIoZSkuZmlsbChyKX1yZXR1cm4gY3JlYXRlQnVmZmVyKGUpfUJ1ZmZlci5hbGxvYz1mdW5jdGlvbihlLHIsdCl7cmV0dXJuIGFsbG9jKGUscix0KX07ZnVuY3Rpb24gYWxsb2NVbnNhZmUoZSl7YXNzZXJ0U2l6ZShlKTtyZXR1cm4gY3JlYXRlQnVmZmVyKGU8MD8wOmNoZWNrZWQoZSl8MCl9QnVmZmVyLmFsbG9jVW5zYWZlPWZ1bmN0aW9uKGUpe3JldHVybiBhbGxvY1Vuc2FmZShlKX07QnVmZmVyLmFsbG9jVW5zYWZlU2xvdz1mdW5jdGlvbihlKXtyZXR1cm4gYWxsb2NVbnNhZmUoZSl9O2Z1bmN0aW9uIGZyb21TdHJpbmcoZSxyKXtpZih0eXBlb2YgciE9PVwic3RyaW5nXCJ8fHI9PT1cIlwiKXtyPVwidXRmOFwifWlmKCFCdWZmZXIuaXNFbmNvZGluZyhyKSl7dGhyb3cgbmV3IFR5cGVFcnJvcihcIlVua25vd24gZW5jb2Rpbmc6IFwiK3IpfXZhciB0PWJ5dGVMZW5ndGgoZSxyKXwwO3ZhciBmPWNyZWF0ZUJ1ZmZlcih0KTt2YXIgbj1mLndyaXRlKGUscik7aWYobiE9PXQpe2Y9Zi5zbGljZSgwLG4pfXJldHVybiBmfWZ1bmN0aW9uIGZyb21BcnJheUxpa2UoZSl7dmFyIHI9ZS5sZW5ndGg8MD8wOmNoZWNrZWQoZS5sZW5ndGgpfDA7dmFyIHQ9Y3JlYXRlQnVmZmVyKHIpO2Zvcih2YXIgZj0wO2Y8cjtmKz0xKXt0W2ZdPWVbZl0mMjU1fXJldHVybiB0fWZ1bmN0aW9uIGZyb21BcnJheUJ1ZmZlcihlLHIsdCl7aWYocjwwfHxlLmJ5dGVMZW5ndGg8cil7dGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wib2Zmc2V0XCIgaXMgb3V0c2lkZSBvZiBidWZmZXIgYm91bmRzJyl9aWYoZS5ieXRlTGVuZ3RoPHIrKHR8fDApKXt0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJsZW5ndGhcIiBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHMnKX12YXIgZjtpZihyPT09dW5kZWZpbmVkJiZ0PT09dW5kZWZpbmVkKXtmPW5ldyBVaW50OEFycmF5KGUpfWVsc2UgaWYodD09PXVuZGVmaW5lZCl7Zj1uZXcgVWludDhBcnJheShlLHIpfWVsc2V7Zj1uZXcgVWludDhBcnJheShlLHIsdCl9T2JqZWN0LnNldFByb3RvdHlwZU9mKGYsQnVmZmVyLnByb3RvdHlwZSk7cmV0dXJuIGZ9ZnVuY3Rpb24gZnJvbU9iamVjdChlKXtpZihCdWZmZXIuaXNCdWZmZXIoZSkpe3ZhciByPWNoZWNrZWQoZS5sZW5ndGgpfDA7dmFyIHQ9Y3JlYXRlQnVmZmVyKHIpO2lmKHQubGVuZ3RoPT09MCl7cmV0dXJuIHR9ZS5jb3B5KHQsMCwwLHIpO3JldHVybiB0fWlmKGUubGVuZ3RoIT09dW5kZWZpbmVkKXtpZih0eXBlb2YgZS5sZW5ndGghPT1cIm51bWJlclwifHxudW1iZXJJc05hTihlLmxlbmd0aCkpe3JldHVybiBjcmVhdGVCdWZmZXIoMCl9cmV0dXJuIGZyb21BcnJheUxpa2UoZSl9aWYoZS50eXBlPT09XCJCdWZmZXJcIiYmQXJyYXkuaXNBcnJheShlLmRhdGEpKXtyZXR1cm4gZnJvbUFycmF5TGlrZShlLmRhdGEpfX1mdW5jdGlvbiBjaGVja2VkKGUpe2lmKGU+PW8pe3Rocm93IG5ldyBSYW5nZUVycm9yKFwiQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSBcIitcInNpemU6IDB4XCIrby50b1N0cmluZygxNikrXCIgYnl0ZXNcIil9cmV0dXJuIGV8MH1mdW5jdGlvbiBTbG93QnVmZmVyKGUpe2lmKCtlIT1lKXtlPTB9cmV0dXJuIEJ1ZmZlci5hbGxvYygrZSl9QnVmZmVyLmlzQnVmZmVyPWZ1bmN0aW9uIGlzQnVmZmVyKGUpe3JldHVybiBlIT1udWxsJiZlLl9pc0J1ZmZlcj09PXRydWUmJmUhPT1CdWZmZXIucHJvdG90eXBlfTtCdWZmZXIuY29tcGFyZT1mdW5jdGlvbiBjb21wYXJlKGUscil7aWYoaXNJbnN0YW5jZShlLFVpbnQ4QXJyYXkpKWU9QnVmZmVyLmZyb20oZSxlLm9mZnNldCxlLmJ5dGVMZW5ndGgpO2lmKGlzSW5zdGFuY2UocixVaW50OEFycmF5KSlyPUJ1ZmZlci5mcm9tKHIsci5vZmZzZXQsci5ieXRlTGVuZ3RoKTtpZighQnVmZmVyLmlzQnVmZmVyKGUpfHwhQnVmZmVyLmlzQnVmZmVyKHIpKXt0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJidWYxXCIsIFwiYnVmMlwiIGFyZ3VtZW50cyBtdXN0IGJlIG9uZSBvZiB0eXBlIEJ1ZmZlciBvciBVaW50OEFycmF5Jyl9aWYoZT09PXIpcmV0dXJuIDA7dmFyIHQ9ZS5sZW5ndGg7dmFyIGY9ci5sZW5ndGg7Zm9yKHZhciBuPTAsaT1NYXRoLm1pbih0LGYpO248aTsrK24pe2lmKGVbbl0hPT1yW25dKXt0PWVbbl07Zj1yW25dO2JyZWFrfX1pZih0PGYpcmV0dXJuLTE7aWYoZjx0KXJldHVybiAxO3JldHVybiAwfTtCdWZmZXIuaXNFbmNvZGluZz1mdW5jdGlvbiBpc0VuY29kaW5nKGUpe3N3aXRjaChTdHJpbmcoZSkudG9Mb3dlckNhc2UoKSl7Y2FzZVwiaGV4XCI6Y2FzZVwidXRmOFwiOmNhc2VcInV0Zi04XCI6Y2FzZVwiYXNjaWlcIjpjYXNlXCJsYXRpbjFcIjpjYXNlXCJiaW5hcnlcIjpjYXNlXCJiYXNlNjRcIjpjYXNlXCJ1Y3MyXCI6Y2FzZVwidWNzLTJcIjpjYXNlXCJ1dGYxNmxlXCI6Y2FzZVwidXRmLTE2bGVcIjpyZXR1cm4gdHJ1ZTtkZWZhdWx0OnJldHVybiBmYWxzZX19O0J1ZmZlci5jb25jYXQ9ZnVuY3Rpb24gY29uY2F0KGUscil7aWYoIUFycmF5LmlzQXJyYXkoZSkpe3Rocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpfWlmKGUubGVuZ3RoPT09MCl7cmV0dXJuIEJ1ZmZlci5hbGxvYygwKX12YXIgdDtpZihyPT09dW5kZWZpbmVkKXtyPTA7Zm9yKHQ9MDt0PGUubGVuZ3RoOysrdCl7cis9ZVt0XS5sZW5ndGh9fXZhciBmPUJ1ZmZlci5hbGxvY1Vuc2FmZShyKTt2YXIgbj0wO2Zvcih0PTA7dDxlLmxlbmd0aDsrK3Qpe3ZhciBpPWVbdF07aWYoaXNJbnN0YW5jZShpLFVpbnQ4QXJyYXkpKXtpPUJ1ZmZlci5mcm9tKGkpfWlmKCFCdWZmZXIuaXNCdWZmZXIoaSkpe3Rocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpfWkuY29weShmLG4pO24rPWkubGVuZ3RofXJldHVybiBmfTtmdW5jdGlvbiBieXRlTGVuZ3RoKGUscil7aWYoQnVmZmVyLmlzQnVmZmVyKGUpKXtyZXR1cm4gZS5sZW5ndGh9aWYoQXJyYXlCdWZmZXIuaXNWaWV3KGUpfHxpc0luc3RhbmNlKGUsQXJyYXlCdWZmZXIpKXtyZXR1cm4gZS5ieXRlTGVuZ3RofWlmKHR5cGVvZiBlIT09XCJzdHJpbmdcIil7dGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwic3RyaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgb3IgQXJyYXlCdWZmZXIuICcrXCJSZWNlaXZlZCB0eXBlIFwiK3R5cGVvZiBlKX12YXIgdD1lLmxlbmd0aDt2YXIgZj1hcmd1bWVudHMubGVuZ3RoPjImJmFyZ3VtZW50c1syXT09PXRydWU7aWYoIWYmJnQ9PT0wKXJldHVybiAwO3ZhciBuPWZhbHNlO2Zvcig7Oyl7c3dpdGNoKHIpe2Nhc2VcImFzY2lpXCI6Y2FzZVwibGF0aW4xXCI6Y2FzZVwiYmluYXJ5XCI6cmV0dXJuIHQ7Y2FzZVwidXRmOFwiOmNhc2VcInV0Zi04XCI6cmV0dXJuIHV0ZjhUb0J5dGVzKGUpLmxlbmd0aDtjYXNlXCJ1Y3MyXCI6Y2FzZVwidWNzLTJcIjpjYXNlXCJ1dGYxNmxlXCI6Y2FzZVwidXRmLTE2bGVcIjpyZXR1cm4gdCoyO2Nhc2VcImhleFwiOnJldHVybiB0Pj4+MTtjYXNlXCJiYXNlNjRcIjpyZXR1cm4gYmFzZTY0VG9CeXRlcyhlKS5sZW5ndGg7ZGVmYXVsdDppZihuKXtyZXR1cm4gZj8tMTp1dGY4VG9CeXRlcyhlKS5sZW5ndGh9cj0oXCJcIityKS50b0xvd2VyQ2FzZSgpO249dHJ1ZX19fUJ1ZmZlci5ieXRlTGVuZ3RoPWJ5dGVMZW5ndGg7ZnVuY3Rpb24gc2xvd1RvU3RyaW5nKGUscix0KXt2YXIgZj1mYWxzZTtpZihyPT09dW5kZWZpbmVkfHxyPDApe3I9MH1pZihyPnRoaXMubGVuZ3RoKXtyZXR1cm5cIlwifWlmKHQ9PT11bmRlZmluZWR8fHQ+dGhpcy5sZW5ndGgpe3Q9dGhpcy5sZW5ndGh9aWYodDw9MCl7cmV0dXJuXCJcIn10Pj4+PTA7cj4+Pj0wO2lmKHQ8PXIpe3JldHVyblwiXCJ9aWYoIWUpZT1cInV0ZjhcIjt3aGlsZSh0cnVlKXtzd2l0Y2goZSl7Y2FzZVwiaGV4XCI6cmV0dXJuIGhleFNsaWNlKHRoaXMscix0KTtjYXNlXCJ1dGY4XCI6Y2FzZVwidXRmLThcIjpyZXR1cm4gdXRmOFNsaWNlKHRoaXMscix0KTtjYXNlXCJhc2NpaVwiOnJldHVybiBhc2NpaVNsaWNlKHRoaXMscix0KTtjYXNlXCJsYXRpbjFcIjpjYXNlXCJiaW5hcnlcIjpyZXR1cm4gbGF0aW4xU2xpY2UodGhpcyxyLHQpO2Nhc2VcImJhc2U2NFwiOnJldHVybiBiYXNlNjRTbGljZSh0aGlzLHIsdCk7Y2FzZVwidWNzMlwiOmNhc2VcInVjcy0yXCI6Y2FzZVwidXRmMTZsZVwiOmNhc2VcInV0Zi0xNmxlXCI6cmV0dXJuIHV0ZjE2bGVTbGljZSh0aGlzLHIsdCk7ZGVmYXVsdDppZihmKXRocm93IG5ldyBUeXBlRXJyb3IoXCJVbmtub3duIGVuY29kaW5nOiBcIitlKTtlPShlK1wiXCIpLnRvTG93ZXJDYXNlKCk7Zj10cnVlfX19QnVmZmVyLnByb3RvdHlwZS5faXNCdWZmZXI9dHJ1ZTtmdW5jdGlvbiBzd2FwKGUscix0KXt2YXIgZj1lW3JdO2Vbcl09ZVt0XTtlW3RdPWZ9QnVmZmVyLnByb3RvdHlwZS5zd2FwMTY9ZnVuY3Rpb24gc3dhcDE2KCl7dmFyIGU9dGhpcy5sZW5ndGg7aWYoZSUyIT09MCl7dGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMTYtYml0c1wiKX1mb3IodmFyIHI9MDtyPGU7cis9Mil7c3dhcCh0aGlzLHIscisxKX1yZXR1cm4gdGhpc307QnVmZmVyLnByb3RvdHlwZS5zd2FwMzI9ZnVuY3Rpb24gc3dhcDMyKCl7dmFyIGU9dGhpcy5sZW5ndGg7aWYoZSU0IT09MCl7dGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMzItYml0c1wiKX1mb3IodmFyIHI9MDtyPGU7cis9NCl7c3dhcCh0aGlzLHIsciszKTtzd2FwKHRoaXMscisxLHIrMil9cmV0dXJuIHRoaXN9O0J1ZmZlci5wcm90b3R5cGUuc3dhcDY0PWZ1bmN0aW9uIHN3YXA2NCgpe3ZhciBlPXRoaXMubGVuZ3RoO2lmKGUlOCE9PTApe3Rocm93IG5ldyBSYW5nZUVycm9yKFwiQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDY0LWJpdHNcIil9Zm9yKHZhciByPTA7cjxlO3IrPTgpe3N3YXAodGhpcyxyLHIrNyk7c3dhcCh0aGlzLHIrMSxyKzYpO3N3YXAodGhpcyxyKzIscis1KTtzd2FwKHRoaXMsciszLHIrNCl9cmV0dXJuIHRoaXN9O0J1ZmZlci5wcm90b3R5cGUudG9TdHJpbmc9ZnVuY3Rpb24gdG9TdHJpbmcoKXt2YXIgZT10aGlzLmxlbmd0aDtpZihlPT09MClyZXR1cm5cIlwiO2lmKGFyZ3VtZW50cy5sZW5ndGg9PT0wKXJldHVybiB1dGY4U2xpY2UodGhpcywwLGUpO3JldHVybiBzbG93VG9TdHJpbmcuYXBwbHkodGhpcyxhcmd1bWVudHMpfTtCdWZmZXIucHJvdG90eXBlLnRvTG9jYWxlU3RyaW5nPUJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmc7QnVmZmVyLnByb3RvdHlwZS5lcXVhbHM9ZnVuY3Rpb24gZXF1YWxzKGUpe2lmKCFCdWZmZXIuaXNCdWZmZXIoZSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXJcIik7aWYodGhpcz09PWUpcmV0dXJuIHRydWU7cmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsZSk9PT0wfTtCdWZmZXIucHJvdG90eXBlLmluc3BlY3Q9ZnVuY3Rpb24gaW5zcGVjdCgpe3ZhciBlPVwiXCI7dmFyIHQ9ci5JTlNQRUNUX01BWF9CWVRFUztlPXRoaXMudG9TdHJpbmcoXCJoZXhcIiwwLHQpLnJlcGxhY2UoLyguezJ9KS9nLFwiJDEgXCIpLnRyaW0oKTtpZih0aGlzLmxlbmd0aD50KWUrPVwiIC4uLiBcIjtyZXR1cm5cIjxCdWZmZXIgXCIrZStcIj5cIn07aWYoaSl7QnVmZmVyLnByb3RvdHlwZVtpXT1CdWZmZXIucHJvdG90eXBlLmluc3BlY3R9QnVmZmVyLnByb3RvdHlwZS5jb21wYXJlPWZ1bmN0aW9uIGNvbXBhcmUoZSxyLHQsZixuKXtpZihpc0luc3RhbmNlKGUsVWludDhBcnJheSkpe2U9QnVmZmVyLmZyb20oZSxlLm9mZnNldCxlLmJ5dGVMZW5ndGgpfWlmKCFCdWZmZXIuaXNCdWZmZXIoZSkpe3Rocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcInRhcmdldFwiIGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgQnVmZmVyIG9yIFVpbnQ4QXJyYXkuICcrXCJSZWNlaXZlZCB0eXBlIFwiK3R5cGVvZiBlKX1pZihyPT09dW5kZWZpbmVkKXtyPTB9aWYodD09PXVuZGVmaW5lZCl7dD1lP2UubGVuZ3RoOjB9aWYoZj09PXVuZGVmaW5lZCl7Zj0wfWlmKG49PT11bmRlZmluZWQpe249dGhpcy5sZW5ndGh9aWYocjwwfHx0PmUubGVuZ3RofHxmPDB8fG4+dGhpcy5sZW5ndGgpe3Rocm93IG5ldyBSYW5nZUVycm9yKFwib3V0IG9mIHJhbmdlIGluZGV4XCIpfWlmKGY+PW4mJnI+PXQpe3JldHVybiAwfWlmKGY+PW4pe3JldHVybi0xfWlmKHI+PXQpe3JldHVybiAxfXI+Pj49MDt0Pj4+PTA7Zj4+Pj0wO24+Pj49MDtpZih0aGlzPT09ZSlyZXR1cm4gMDt2YXIgaT1uLWY7dmFyIG89dC1yO3ZhciB1PU1hdGgubWluKGksbyk7dmFyIGE9dGhpcy5zbGljZShmLG4pO3ZhciBzPWUuc2xpY2Uocix0KTtmb3IodmFyIGg9MDtoPHU7KytoKXtpZihhW2hdIT09c1toXSl7aT1hW2hdO289c1toXTticmVha319aWYoaTxvKXJldHVybi0xO2lmKG88aSlyZXR1cm4gMTtyZXR1cm4gMH07ZnVuY3Rpb24gYmlkaXJlY3Rpb25hbEluZGV4T2YoZSxyLHQsZixuKXtpZihlLmxlbmd0aD09PTApcmV0dXJuLTE7aWYodHlwZW9mIHQ9PT1cInN0cmluZ1wiKXtmPXQ7dD0wfWVsc2UgaWYodD4yMTQ3NDgzNjQ3KXt0PTIxNDc0ODM2NDd9ZWxzZSBpZih0PC0yMTQ3NDgzNjQ4KXt0PS0yMTQ3NDgzNjQ4fXQ9K3Q7aWYobnVtYmVySXNOYU4odCkpe3Q9bj8wOmUubGVuZ3RoLTF9aWYodDwwKXQ9ZS5sZW5ndGgrdDtpZih0Pj1lLmxlbmd0aCl7aWYobilyZXR1cm4tMTtlbHNlIHQ9ZS5sZW5ndGgtMX1lbHNlIGlmKHQ8MCl7aWYobil0PTA7ZWxzZSByZXR1cm4tMX1pZih0eXBlb2Ygcj09PVwic3RyaW5nXCIpe3I9QnVmZmVyLmZyb20ocixmKX1pZihCdWZmZXIuaXNCdWZmZXIocikpe2lmKHIubGVuZ3RoPT09MCl7cmV0dXJuLTF9cmV0dXJuIGFycmF5SW5kZXhPZihlLHIsdCxmLG4pfWVsc2UgaWYodHlwZW9mIHI9PT1cIm51bWJlclwiKXtyPXImMjU1O2lmKHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mPT09XCJmdW5jdGlvblwiKXtpZihuKXtyZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGUscix0KX1lbHNle3JldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZi5jYWxsKGUscix0KX19cmV0dXJuIGFycmF5SW5kZXhPZihlLFtyXSx0LGYsbil9dGhyb3cgbmV3IFR5cGVFcnJvcihcInZhbCBtdXN0IGJlIHN0cmluZywgbnVtYmVyIG9yIEJ1ZmZlclwiKX1mdW5jdGlvbiBhcnJheUluZGV4T2YoZSxyLHQsZixuKXt2YXIgaT0xO3ZhciBvPWUubGVuZ3RoO3ZhciB1PXIubGVuZ3RoO2lmKGYhPT11bmRlZmluZWQpe2Y9U3RyaW5nKGYpLnRvTG93ZXJDYXNlKCk7aWYoZj09PVwidWNzMlwifHxmPT09XCJ1Y3MtMlwifHxmPT09XCJ1dGYxNmxlXCJ8fGY9PT1cInV0Zi0xNmxlXCIpe2lmKGUubGVuZ3RoPDJ8fHIubGVuZ3RoPDIpe3JldHVybi0xfWk9MjtvLz0yO3UvPTI7dC89Mn19ZnVuY3Rpb24gcmVhZChlLHIpe2lmKGk9PT0xKXtyZXR1cm4gZVtyXX1lbHNle3JldHVybiBlLnJlYWRVSW50MTZCRShyKmkpfX12YXIgYTtpZihuKXt2YXIgcz0tMTtmb3IoYT10O2E8bzthKyspe2lmKHJlYWQoZSxhKT09PXJlYWQocixzPT09LTE/MDphLXMpKXtpZihzPT09LTEpcz1hO2lmKGEtcysxPT09dSlyZXR1cm4gcyppfWVsc2V7aWYocyE9PS0xKWEtPWEtcztzPS0xfX19ZWxzZXtpZih0K3U+byl0PW8tdTtmb3IoYT10O2E+PTA7YS0tKXt2YXIgaD10cnVlO2Zvcih2YXIgYz0wO2M8dTtjKyspe2lmKHJlYWQoZSxhK2MpIT09cmVhZChyLGMpKXtoPWZhbHNlO2JyZWFrfX1pZihoKXJldHVybiBhfX1yZXR1cm4tMX1CdWZmZXIucHJvdG90eXBlLmluY2x1ZGVzPWZ1bmN0aW9uIGluY2x1ZGVzKGUscix0KXtyZXR1cm4gdGhpcy5pbmRleE9mKGUscix0KSE9PS0xfTtCdWZmZXIucHJvdG90eXBlLmluZGV4T2Y9ZnVuY3Rpb24gaW5kZXhPZihlLHIsdCl7cmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsZSxyLHQsdHJ1ZSl9O0J1ZmZlci5wcm90b3R5cGUubGFzdEluZGV4T2Y9ZnVuY3Rpb24gbGFzdEluZGV4T2YoZSxyLHQpe3JldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLGUscix0LGZhbHNlKX07ZnVuY3Rpb24gaGV4V3JpdGUoZSxyLHQsZil7dD1OdW1iZXIodCl8fDA7dmFyIG49ZS5sZW5ndGgtdDtpZighZil7Zj1ufWVsc2V7Zj1OdW1iZXIoZik7aWYoZj5uKXtmPW59fXZhciBpPXIubGVuZ3RoO2lmKGY+aS8yKXtmPWkvMn1mb3IodmFyIG89MDtvPGY7KytvKXt2YXIgdT1wYXJzZUludChyLnN1YnN0cihvKjIsMiksMTYpO2lmKG51bWJlcklzTmFOKHUpKXJldHVybiBvO2VbdCtvXT11fXJldHVybiBvfWZ1bmN0aW9uIHV0ZjhXcml0ZShlLHIsdCxmKXtyZXR1cm4gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhyLGUubGVuZ3RoLXQpLGUsdCxmKX1mdW5jdGlvbiBhc2NpaVdyaXRlKGUscix0LGYpe3JldHVybiBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhyKSxlLHQsZil9ZnVuY3Rpb24gbGF0aW4xV3JpdGUoZSxyLHQsZil7cmV0dXJuIGFzY2lpV3JpdGUoZSxyLHQsZil9ZnVuY3Rpb24gYmFzZTY0V3JpdGUoZSxyLHQsZil7cmV0dXJuIGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhyKSxlLHQsZil9ZnVuY3Rpb24gdWNzMldyaXRlKGUscix0LGYpe3JldHVybiBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHIsZS5sZW5ndGgtdCksZSx0LGYpfUJ1ZmZlci5wcm90b3R5cGUud3JpdGU9ZnVuY3Rpb24gd3JpdGUoZSxyLHQsZil7aWYocj09PXVuZGVmaW5lZCl7Zj1cInV0ZjhcIjt0PXRoaXMubGVuZ3RoO3I9MH1lbHNlIGlmKHQ9PT11bmRlZmluZWQmJnR5cGVvZiByPT09XCJzdHJpbmdcIil7Zj1yO3Q9dGhpcy5sZW5ndGg7cj0wfWVsc2UgaWYoaXNGaW5pdGUocikpe3I9cj4+PjA7aWYoaXNGaW5pdGUodCkpe3Q9dD4+PjA7aWYoZj09PXVuZGVmaW5lZClmPVwidXRmOFwifWVsc2V7Zj10O3Q9dW5kZWZpbmVkfX1lbHNle3Rocm93IG5ldyBFcnJvcihcIkJ1ZmZlci53cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXRbLCBsZW5ndGhdKSBpcyBubyBsb25nZXIgc3VwcG9ydGVkXCIpfXZhciBuPXRoaXMubGVuZ3RoLXI7aWYodD09PXVuZGVmaW5lZHx8dD5uKXQ9bjtpZihlLmxlbmd0aD4wJiYodDwwfHxyPDApfHxyPnRoaXMubGVuZ3RoKXt0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkF0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzXCIpfWlmKCFmKWY9XCJ1dGY4XCI7dmFyIGk9ZmFsc2U7Zm9yKDs7KXtzd2l0Y2goZil7Y2FzZVwiaGV4XCI6cmV0dXJuIGhleFdyaXRlKHRoaXMsZSxyLHQpO2Nhc2VcInV0ZjhcIjpjYXNlXCJ1dGYtOFwiOnJldHVybiB1dGY4V3JpdGUodGhpcyxlLHIsdCk7Y2FzZVwiYXNjaWlcIjpyZXR1cm4gYXNjaWlXcml0ZSh0aGlzLGUscix0KTtjYXNlXCJsYXRpbjFcIjpjYXNlXCJiaW5hcnlcIjpyZXR1cm4gbGF0aW4xV3JpdGUodGhpcyxlLHIsdCk7Y2FzZVwiYmFzZTY0XCI6cmV0dXJuIGJhc2U2NFdyaXRlKHRoaXMsZSxyLHQpO2Nhc2VcInVjczJcIjpjYXNlXCJ1Y3MtMlwiOmNhc2VcInV0ZjE2bGVcIjpjYXNlXCJ1dGYtMTZsZVwiOnJldHVybiB1Y3MyV3JpdGUodGhpcyxlLHIsdCk7ZGVmYXVsdDppZihpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJVbmtub3duIGVuY29kaW5nOiBcIitmKTtmPShcIlwiK2YpLnRvTG93ZXJDYXNlKCk7aT10cnVlfX19O0J1ZmZlci5wcm90b3R5cGUudG9KU09OPWZ1bmN0aW9uIHRvSlNPTigpe3JldHVybnt0eXBlOlwiQnVmZmVyXCIsZGF0YTpBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnJ8fHRoaXMsMCl9fTtmdW5jdGlvbiBiYXNlNjRTbGljZShlLHIsdCl7aWYocj09PTAmJnQ9PT1lLmxlbmd0aCl7cmV0dXJuIGYuZnJvbUJ5dGVBcnJheShlKX1lbHNle3JldHVybiBmLmZyb21CeXRlQXJyYXkoZS5zbGljZShyLHQpKX19ZnVuY3Rpb24gdXRmOFNsaWNlKGUscix0KXt0PU1hdGgubWluKGUubGVuZ3RoLHQpO3ZhciBmPVtdO3ZhciBuPXI7d2hpbGUobjx0KXt2YXIgaT1lW25dO3ZhciBvPW51bGw7dmFyIHU9aT4yMzk/NDppPjIyMz8zOmk+MTkxPzI6MTtpZihuK3U8PXQpe3ZhciBhLHMsaCxjO3N3aXRjaCh1KXtjYXNlIDE6aWYoaTwxMjgpe289aX1icmVhaztjYXNlIDI6YT1lW24rMV07aWYoKGEmMTkyKT09PTEyOCl7Yz0oaSYzMSk8PDZ8YSY2MztpZihjPjEyNyl7bz1jfX1icmVhaztjYXNlIDM6YT1lW24rMV07cz1lW24rMl07aWYoKGEmMTkyKT09PTEyOCYmKHMmMTkyKT09PTEyOCl7Yz0oaSYxNSk8PDEyfChhJjYzKTw8NnxzJjYzO2lmKGM+MjA0NyYmKGM8NTUyOTZ8fGM+NTczNDMpKXtvPWN9fWJyZWFrO2Nhc2UgNDphPWVbbisxXTtzPWVbbisyXTtoPWVbbiszXTtpZigoYSYxOTIpPT09MTI4JiYocyYxOTIpPT09MTI4JiYoaCYxOTIpPT09MTI4KXtjPShpJjE1KTw8MTh8KGEmNjMpPDwxMnwocyY2Myk8PDZ8aCY2MztpZihjPjY1NTM1JiZjPDExMTQxMTIpe289Y319fX1pZihvPT09bnVsbCl7bz02NTUzMzt1PTF9ZWxzZSBpZihvPjY1NTM1KXtvLT02NTUzNjtmLnB1c2gobz4+PjEwJjEwMjN8NTUyOTYpO289NTYzMjB8byYxMDIzfWYucHVzaChvKTtuKz11fXJldHVybiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkoZil9dmFyIHU9NDA5NjtmdW5jdGlvbiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkoZSl7dmFyIHI9ZS5sZW5ndGg7aWYocjw9dSl7cmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLGUpfXZhciB0PVwiXCI7dmFyIGY9MDt3aGlsZShmPHIpe3QrPVN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLGUuc2xpY2UoZixmKz11KSl9cmV0dXJuIHR9ZnVuY3Rpb24gYXNjaWlTbGljZShlLHIsdCl7dmFyIGY9XCJcIjt0PU1hdGgubWluKGUubGVuZ3RoLHQpO2Zvcih2YXIgbj1yO248dDsrK24pe2YrPVN0cmluZy5mcm9tQ2hhckNvZGUoZVtuXSYxMjcpfXJldHVybiBmfWZ1bmN0aW9uIGxhdGluMVNsaWNlKGUscix0KXt2YXIgZj1cIlwiO3Q9TWF0aC5taW4oZS5sZW5ndGgsdCk7Zm9yKHZhciBuPXI7bjx0Oysrbil7Zis9U3RyaW5nLmZyb21DaGFyQ29kZShlW25dKX1yZXR1cm4gZn1mdW5jdGlvbiBoZXhTbGljZShlLHIsdCl7dmFyIGY9ZS5sZW5ndGg7aWYoIXJ8fHI8MClyPTA7aWYoIXR8fHQ8MHx8dD5mKXQ9Zjt2YXIgbj1cIlwiO2Zvcih2YXIgaT1yO2k8dDsrK2kpe24rPXNbZVtpXV19cmV0dXJuIG59ZnVuY3Rpb24gdXRmMTZsZVNsaWNlKGUscix0KXt2YXIgZj1lLnNsaWNlKHIsdCk7dmFyIG49XCJcIjtmb3IodmFyIGk9MDtpPGYubGVuZ3RoO2krPTIpe24rPVN0cmluZy5mcm9tQ2hhckNvZGUoZltpXStmW2krMV0qMjU2KX1yZXR1cm4gbn1CdWZmZXIucHJvdG90eXBlLnNsaWNlPWZ1bmN0aW9uIHNsaWNlKGUscil7dmFyIHQ9dGhpcy5sZW5ndGg7ZT1+fmU7cj1yPT09dW5kZWZpbmVkP3Q6fn5yO2lmKGU8MCl7ZSs9dDtpZihlPDApZT0wfWVsc2UgaWYoZT50KXtlPXR9aWYocjwwKXtyKz10O2lmKHI8MClyPTB9ZWxzZSBpZihyPnQpe3I9dH1pZihyPGUpcj1lO3ZhciBmPXRoaXMuc3ViYXJyYXkoZSxyKTtPYmplY3Quc2V0UHJvdG90eXBlT2YoZixCdWZmZXIucHJvdG90eXBlKTtyZXR1cm4gZn07ZnVuY3Rpb24gY2hlY2tPZmZzZXQoZSxyLHQpe2lmKGUlMSE9PTB8fGU8MCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIm9mZnNldCBpcyBub3QgdWludFwiKTtpZihlK3I+dCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlRyeWluZyB0byBhY2Nlc3MgYmV5b25kIGJ1ZmZlciBsZW5ndGhcIil9QnVmZmVyLnByb3RvdHlwZS5yZWFkVUludExFPWZ1bmN0aW9uIHJlYWRVSW50TEUoZSxyLHQpe2U9ZT4+PjA7cj1yPj4+MDtpZighdCljaGVja09mZnNldChlLHIsdGhpcy5sZW5ndGgpO3ZhciBmPXRoaXNbZV07dmFyIG49MTt2YXIgaT0wO3doaWxlKCsraTxyJiYobio9MjU2KSl7Zis9dGhpc1tlK2ldKm59cmV0dXJuIGZ9O0J1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRCRT1mdW5jdGlvbiByZWFkVUludEJFKGUscix0KXtlPWU+Pj4wO3I9cj4+PjA7aWYoIXQpe2NoZWNrT2Zmc2V0KGUscix0aGlzLmxlbmd0aCl9dmFyIGY9dGhpc1tlKy0tcl07dmFyIG49MTt3aGlsZShyPjAmJihuKj0yNTYpKXtmKz10aGlzW2UrLS1yXSpufXJldHVybiBmfTtCdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OD1mdW5jdGlvbiByZWFkVUludDgoZSxyKXtlPWU+Pj4wO2lmKCFyKWNoZWNrT2Zmc2V0KGUsMSx0aGlzLmxlbmd0aCk7cmV0dXJuIHRoaXNbZV19O0J1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFPWZ1bmN0aW9uIHJlYWRVSW50MTZMRShlLHIpe2U9ZT4+PjA7aWYoIXIpY2hlY2tPZmZzZXQoZSwyLHRoaXMubGVuZ3RoKTtyZXR1cm4gdGhpc1tlXXx0aGlzW2UrMV08PDh9O0J1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFPWZ1bmN0aW9uIHJlYWRVSW50MTZCRShlLHIpe2U9ZT4+PjA7aWYoIXIpY2hlY2tPZmZzZXQoZSwyLHRoaXMubGVuZ3RoKTtyZXR1cm4gdGhpc1tlXTw8OHx0aGlzW2UrMV19O0J1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFPWZ1bmN0aW9uIHJlYWRVSW50MzJMRShlLHIpe2U9ZT4+PjA7aWYoIXIpY2hlY2tPZmZzZXQoZSw0LHRoaXMubGVuZ3RoKTtyZXR1cm4odGhpc1tlXXx0aGlzW2UrMV08PDh8dGhpc1tlKzJdPDwxNikrdGhpc1tlKzNdKjE2Nzc3MjE2fTtCdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRT1mdW5jdGlvbiByZWFkVUludDMyQkUoZSxyKXtlPWU+Pj4wO2lmKCFyKWNoZWNrT2Zmc2V0KGUsNCx0aGlzLmxlbmd0aCk7cmV0dXJuIHRoaXNbZV0qMTY3NzcyMTYrKHRoaXNbZSsxXTw8MTZ8dGhpc1tlKzJdPDw4fHRoaXNbZSszXSl9O0J1ZmZlci5wcm90b3R5cGUucmVhZEludExFPWZ1bmN0aW9uIHJlYWRJbnRMRShlLHIsdCl7ZT1lPj4+MDtyPXI+Pj4wO2lmKCF0KWNoZWNrT2Zmc2V0KGUscix0aGlzLmxlbmd0aCk7dmFyIGY9dGhpc1tlXTt2YXIgbj0xO3ZhciBpPTA7d2hpbGUoKytpPHImJihuKj0yNTYpKXtmKz10aGlzW2UraV0qbn1uKj0xMjg7aWYoZj49bilmLT1NYXRoLnBvdygyLDgqcik7cmV0dXJuIGZ9O0J1ZmZlci5wcm90b3R5cGUucmVhZEludEJFPWZ1bmN0aW9uIHJlYWRJbnRCRShlLHIsdCl7ZT1lPj4+MDtyPXI+Pj4wO2lmKCF0KWNoZWNrT2Zmc2V0KGUscix0aGlzLmxlbmd0aCk7dmFyIGY9cjt2YXIgbj0xO3ZhciBpPXRoaXNbZSstLWZdO3doaWxlKGY+MCYmKG4qPTI1Nikpe2krPXRoaXNbZSstLWZdKm59bio9MTI4O2lmKGk+PW4paS09TWF0aC5wb3coMiw4KnIpO3JldHVybiBpfTtCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4PWZ1bmN0aW9uIHJlYWRJbnQ4KGUscil7ZT1lPj4+MDtpZighciljaGVja09mZnNldChlLDEsdGhpcy5sZW5ndGgpO2lmKCEodGhpc1tlXSYxMjgpKXJldHVybiB0aGlzW2VdO3JldHVybigyNTUtdGhpc1tlXSsxKSotMX07QnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRT1mdW5jdGlvbiByZWFkSW50MTZMRShlLHIpe2U9ZT4+PjA7aWYoIXIpY2hlY2tPZmZzZXQoZSwyLHRoaXMubGVuZ3RoKTt2YXIgdD10aGlzW2VdfHRoaXNbZSsxXTw8ODtyZXR1cm4gdCYzMjc2OD90fDQyOTQ5MDE3NjA6dH07QnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRT1mdW5jdGlvbiByZWFkSW50MTZCRShlLHIpe2U9ZT4+PjA7aWYoIXIpY2hlY2tPZmZzZXQoZSwyLHRoaXMubGVuZ3RoKTt2YXIgdD10aGlzW2UrMV18dGhpc1tlXTw8ODtyZXR1cm4gdCYzMjc2OD90fDQyOTQ5MDE3NjA6dH07QnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRT1mdW5jdGlvbiByZWFkSW50MzJMRShlLHIpe2U9ZT4+PjA7aWYoIXIpY2hlY2tPZmZzZXQoZSw0LHRoaXMubGVuZ3RoKTtyZXR1cm4gdGhpc1tlXXx0aGlzW2UrMV08PDh8dGhpc1tlKzJdPDwxNnx0aGlzW2UrM108PDI0fTtCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFPWZ1bmN0aW9uIHJlYWRJbnQzMkJFKGUscil7ZT1lPj4+MDtpZighciljaGVja09mZnNldChlLDQsdGhpcy5sZW5ndGgpO3JldHVybiB0aGlzW2VdPDwyNHx0aGlzW2UrMV08PDE2fHRoaXNbZSsyXTw8OHx0aGlzW2UrM119O0J1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEU9ZnVuY3Rpb24gcmVhZEZsb2F0TEUoZSxyKXtlPWU+Pj4wO2lmKCFyKWNoZWNrT2Zmc2V0KGUsNCx0aGlzLmxlbmd0aCk7cmV0dXJuIG4ucmVhZCh0aGlzLGUsdHJ1ZSwyMyw0KX07QnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRT1mdW5jdGlvbiByZWFkRmxvYXRCRShlLHIpe2U9ZT4+PjA7aWYoIXIpY2hlY2tPZmZzZXQoZSw0LHRoaXMubGVuZ3RoKTtyZXR1cm4gbi5yZWFkKHRoaXMsZSxmYWxzZSwyMyw0KX07QnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEU9ZnVuY3Rpb24gcmVhZERvdWJsZUxFKGUscil7ZT1lPj4+MDtpZighciljaGVja09mZnNldChlLDgsdGhpcy5sZW5ndGgpO3JldHVybiBuLnJlYWQodGhpcyxlLHRydWUsNTIsOCl9O0J1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFPWZ1bmN0aW9uIHJlYWREb3VibGVCRShlLHIpe2U9ZT4+PjA7aWYoIXIpY2hlY2tPZmZzZXQoZSw4LHRoaXMubGVuZ3RoKTtyZXR1cm4gbi5yZWFkKHRoaXMsZSxmYWxzZSw1Miw4KX07ZnVuY3Rpb24gY2hlY2tJbnQoZSxyLHQsZixuLGkpe2lmKCFCdWZmZXIuaXNCdWZmZXIoZSkpdGhyb3cgbmV3IFR5cGVFcnJvcignXCJidWZmZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJyk7aWYocj5ufHxyPGkpdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBpcyBvdXQgb2YgYm91bmRzJyk7aWYodCtmPmUubGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKFwiSW5kZXggb3V0IG9mIHJhbmdlXCIpfUJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50TEU9ZnVuY3Rpb24gd3JpdGVVSW50TEUoZSxyLHQsZil7ZT0rZTtyPXI+Pj4wO3Q9dD4+PjA7aWYoIWYpe3ZhciBuPU1hdGgucG93KDIsOCp0KS0xO2NoZWNrSW50KHRoaXMsZSxyLHQsbiwwKX12YXIgaT0xO3ZhciBvPTA7dGhpc1tyXT1lJjI1NTt3aGlsZSgrK288dCYmKGkqPTI1Nikpe3RoaXNbcitvXT1lL2kmMjU1fXJldHVybiByK3R9O0J1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50QkU9ZnVuY3Rpb24gd3JpdGVVSW50QkUoZSxyLHQsZil7ZT0rZTtyPXI+Pj4wO3Q9dD4+PjA7aWYoIWYpe3ZhciBuPU1hdGgucG93KDIsOCp0KS0xO2NoZWNrSW50KHRoaXMsZSxyLHQsbiwwKX12YXIgaT10LTE7dmFyIG89MTt0aGlzW3IraV09ZSYyNTU7d2hpbGUoLS1pPj0wJiYobyo9MjU2KSl7dGhpc1tyK2ldPWUvbyYyNTV9cmV0dXJuIHIrdH07QnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4PWZ1bmN0aW9uIHdyaXRlVUludDgoZSxyLHQpe2U9K2U7cj1yPj4+MDtpZighdCljaGVja0ludCh0aGlzLGUsciwxLDI1NSwwKTt0aGlzW3JdPWUmMjU1O3JldHVybiByKzF9O0J1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRT1mdW5jdGlvbiB3cml0ZVVJbnQxNkxFKGUscix0KXtlPStlO3I9cj4+PjA7aWYoIXQpY2hlY2tJbnQodGhpcyxlLHIsMiw2NTUzNSwwKTt0aGlzW3JdPWUmMjU1O3RoaXNbcisxXT1lPj4+ODtyZXR1cm4gcisyfTtCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkU9ZnVuY3Rpb24gd3JpdGVVSW50MTZCRShlLHIsdCl7ZT0rZTtyPXI+Pj4wO2lmKCF0KWNoZWNrSW50KHRoaXMsZSxyLDIsNjU1MzUsMCk7dGhpc1tyXT1lPj4+ODt0aGlzW3IrMV09ZSYyNTU7cmV0dXJuIHIrMn07QnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFPWZ1bmN0aW9uIHdyaXRlVUludDMyTEUoZSxyLHQpe2U9K2U7cj1yPj4+MDtpZighdCljaGVja0ludCh0aGlzLGUsciw0LDQyOTQ5NjcyOTUsMCk7dGhpc1tyKzNdPWU+Pj4yNDt0aGlzW3IrMl09ZT4+PjE2O3RoaXNbcisxXT1lPj4+ODt0aGlzW3JdPWUmMjU1O3JldHVybiByKzR9O0J1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRT1mdW5jdGlvbiB3cml0ZVVJbnQzMkJFKGUscix0KXtlPStlO3I9cj4+PjA7aWYoIXQpY2hlY2tJbnQodGhpcyxlLHIsNCw0Mjk0OTY3Mjk1LDApO3RoaXNbcl09ZT4+PjI0O3RoaXNbcisxXT1lPj4+MTY7dGhpc1tyKzJdPWU+Pj44O3RoaXNbciszXT1lJjI1NTtyZXR1cm4gcis0fTtCdWZmZXIucHJvdG90eXBlLndyaXRlSW50TEU9ZnVuY3Rpb24gd3JpdGVJbnRMRShlLHIsdCxmKXtlPStlO3I9cj4+PjA7aWYoIWYpe3ZhciBuPU1hdGgucG93KDIsOCp0LTEpO2NoZWNrSW50KHRoaXMsZSxyLHQsbi0xLC1uKX12YXIgaT0wO3ZhciBvPTE7dmFyIHU9MDt0aGlzW3JdPWUmMjU1O3doaWxlKCsraTx0JiYobyo9MjU2KSl7aWYoZTwwJiZ1PT09MCYmdGhpc1tyK2ktMV0hPT0wKXt1PTF9dGhpc1tyK2ldPShlL28+PjApLXUmMjU1fXJldHVybiByK3R9O0J1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRCRT1mdW5jdGlvbiB3cml0ZUludEJFKGUscix0LGYpe2U9K2U7cj1yPj4+MDtpZighZil7dmFyIG49TWF0aC5wb3coMiw4KnQtMSk7Y2hlY2tJbnQodGhpcyxlLHIsdCxuLTEsLW4pfXZhciBpPXQtMTt2YXIgbz0xO3ZhciB1PTA7dGhpc1tyK2ldPWUmMjU1O3doaWxlKC0taT49MCYmKG8qPTI1Nikpe2lmKGU8MCYmdT09PTAmJnRoaXNbcitpKzFdIT09MCl7dT0xfXRoaXNbcitpXT0oZS9vPj4wKS11JjI1NX1yZXR1cm4gcit0fTtCdWZmZXIucHJvdG90eXBlLndyaXRlSW50OD1mdW5jdGlvbiB3cml0ZUludDgoZSxyLHQpe2U9K2U7cj1yPj4+MDtpZighdCljaGVja0ludCh0aGlzLGUsciwxLDEyNywtMTI4KTtpZihlPDApZT0yNTUrZSsxO3RoaXNbcl09ZSYyNTU7cmV0dXJuIHIrMX07QnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEU9ZnVuY3Rpb24gd3JpdGVJbnQxNkxFKGUscix0KXtlPStlO3I9cj4+PjA7aWYoIXQpY2hlY2tJbnQodGhpcyxlLHIsMiwzMjc2NywtMzI3NjgpO3RoaXNbcl09ZSYyNTU7dGhpc1tyKzFdPWU+Pj44O3JldHVybiByKzJ9O0J1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFPWZ1bmN0aW9uIHdyaXRlSW50MTZCRShlLHIsdCl7ZT0rZTtyPXI+Pj4wO2lmKCF0KWNoZWNrSW50KHRoaXMsZSxyLDIsMzI3NjcsLTMyNzY4KTt0aGlzW3JdPWU+Pj44O3RoaXNbcisxXT1lJjI1NTtyZXR1cm4gcisyfTtCdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRT1mdW5jdGlvbiB3cml0ZUludDMyTEUoZSxyLHQpe2U9K2U7cj1yPj4+MDtpZighdCljaGVja0ludCh0aGlzLGUsciw0LDIxNDc0ODM2NDcsLTIxNDc0ODM2NDgpO3RoaXNbcl09ZSYyNTU7dGhpc1tyKzFdPWU+Pj44O3RoaXNbcisyXT1lPj4+MTY7dGhpc1tyKzNdPWU+Pj4yNDtyZXR1cm4gcis0fTtCdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRT1mdW5jdGlvbiB3cml0ZUludDMyQkUoZSxyLHQpe2U9K2U7cj1yPj4+MDtpZighdCljaGVja0ludCh0aGlzLGUsciw0LDIxNDc0ODM2NDcsLTIxNDc0ODM2NDgpO2lmKGU8MCllPTQyOTQ5NjcyOTUrZSsxO3RoaXNbcl09ZT4+PjI0O3RoaXNbcisxXT1lPj4+MTY7dGhpc1tyKzJdPWU+Pj44O3RoaXNbciszXT1lJjI1NTtyZXR1cm4gcis0fTtmdW5jdGlvbiBjaGVja0lFRUU3NTQoZSxyLHQsZixuLGkpe2lmKHQrZj5lLmxlbmd0aCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkluZGV4IG91dCBvZiByYW5nZVwiKTtpZih0PDApdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbmRleCBvdXQgb2YgcmFuZ2VcIil9ZnVuY3Rpb24gd3JpdGVGbG9hdChlLHIsdCxmLGkpe3I9K3I7dD10Pj4+MDtpZighaSl7Y2hlY2tJRUVFNzU0KGUscix0LDQsMzQwMjgyMzQ2NjM4NTI4ODZlMjIsLTM0MDI4MjM0NjYzODUyODg2ZTIyKX1uLndyaXRlKGUscix0LGYsMjMsNCk7cmV0dXJuIHQrNH1CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRT1mdW5jdGlvbiB3cml0ZUZsb2F0TEUoZSxyLHQpe3JldHVybiB3cml0ZUZsb2F0KHRoaXMsZSxyLHRydWUsdCl9O0J1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFPWZ1bmN0aW9uIHdyaXRlRmxvYXRCRShlLHIsdCl7cmV0dXJuIHdyaXRlRmxvYXQodGhpcyxlLHIsZmFsc2UsdCl9O2Z1bmN0aW9uIHdyaXRlRG91YmxlKGUscix0LGYsaSl7cj0rcjt0PXQ+Pj4wO2lmKCFpKXtjaGVja0lFRUU3NTQoZSxyLHQsOCwxNzk3NjkzMTM0ODYyMzE1N2UyOTIsLTE3OTc2OTMxMzQ4NjIzMTU3ZTI5Mil9bi53cml0ZShlLHIsdCxmLDUyLDgpO3JldHVybiB0Kzh9QnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFPWZ1bmN0aW9uIHdyaXRlRG91YmxlTEUoZSxyLHQpe3JldHVybiB3cml0ZURvdWJsZSh0aGlzLGUscix0cnVlLHQpfTtCdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkU9ZnVuY3Rpb24gd3JpdGVEb3VibGVCRShlLHIsdCl7cmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsZSxyLGZhbHNlLHQpfTtCdWZmZXIucHJvdG90eXBlLmNvcHk9ZnVuY3Rpb24gY29weShlLHIsdCxmKXtpZighQnVmZmVyLmlzQnVmZmVyKGUpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJhcmd1bWVudCBzaG91bGQgYmUgYSBCdWZmZXJcIik7aWYoIXQpdD0wO2lmKCFmJiZmIT09MClmPXRoaXMubGVuZ3RoO2lmKHI+PWUubGVuZ3RoKXI9ZS5sZW5ndGg7aWYoIXIpcj0wO2lmKGY+MCYmZjx0KWY9dDtpZihmPT09dClyZXR1cm4gMDtpZihlLmxlbmd0aD09PTB8fHRoaXMubGVuZ3RoPT09MClyZXR1cm4gMDtpZihyPDApe3Rocm93IG5ldyBSYW5nZUVycm9yKFwidGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kc1wiKX1pZih0PDB8fHQ+PXRoaXMubGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKFwiSW5kZXggb3V0IG9mIHJhbmdlXCIpO2lmKGY8MCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcInNvdXJjZUVuZCBvdXQgb2YgYm91bmRzXCIpO2lmKGY+dGhpcy5sZW5ndGgpZj10aGlzLmxlbmd0aDtpZihlLmxlbmd0aC1yPGYtdCl7Zj1lLmxlbmd0aC1yK3R9dmFyIG49Zi10O2lmKHRoaXM9PT1lJiZ0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuY29weVdpdGhpbj09PVwiZnVuY3Rpb25cIil7dGhpcy5jb3B5V2l0aGluKHIsdCxmKX1lbHNlIGlmKHRoaXM9PT1lJiZ0PHImJnI8Zil7Zm9yKHZhciBpPW4tMTtpPj0wOy0taSl7ZVtpK3JdPXRoaXNbaSt0XX19ZWxzZXtVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbChlLHRoaXMuc3ViYXJyYXkodCxmKSxyKX1yZXR1cm4gbn07QnVmZmVyLnByb3RvdHlwZS5maWxsPWZ1bmN0aW9uIGZpbGwoZSxyLHQsZil7aWYodHlwZW9mIGU9PT1cInN0cmluZ1wiKXtpZih0eXBlb2Ygcj09PVwic3RyaW5nXCIpe2Y9cjtyPTA7dD10aGlzLmxlbmd0aH1lbHNlIGlmKHR5cGVvZiB0PT09XCJzdHJpbmdcIil7Zj10O3Q9dGhpcy5sZW5ndGh9aWYoZiE9PXVuZGVmaW5lZCYmdHlwZW9mIGYhPT1cInN0cmluZ1wiKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwiZW5jb2RpbmcgbXVzdCBiZSBhIHN0cmluZ1wiKX1pZih0eXBlb2YgZj09PVwic3RyaW5nXCImJiFCdWZmZXIuaXNFbmNvZGluZyhmKSl7dGhyb3cgbmV3IFR5cGVFcnJvcihcIlVua25vd24gZW5jb2Rpbmc6IFwiK2YpfWlmKGUubGVuZ3RoPT09MSl7dmFyIG49ZS5jaGFyQ29kZUF0KDApO2lmKGY9PT1cInV0ZjhcIiYmbjwxMjh8fGY9PT1cImxhdGluMVwiKXtlPW59fX1lbHNlIGlmKHR5cGVvZiBlPT09XCJudW1iZXJcIil7ZT1lJjI1NX1lbHNlIGlmKHR5cGVvZiBlPT09XCJib29sZWFuXCIpe2U9TnVtYmVyKGUpfWlmKHI8MHx8dGhpcy5sZW5ndGg8cnx8dGhpcy5sZW5ndGg8dCl7dGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJPdXQgb2YgcmFuZ2UgaW5kZXhcIil9aWYodDw9cil7cmV0dXJuIHRoaXN9cj1yPj4+MDt0PXQ9PT11bmRlZmluZWQ/dGhpcy5sZW5ndGg6dD4+PjA7aWYoIWUpZT0wO3ZhciBpO2lmKHR5cGVvZiBlPT09XCJudW1iZXJcIil7Zm9yKGk9cjtpPHQ7KytpKXt0aGlzW2ldPWV9fWVsc2V7dmFyIG89QnVmZmVyLmlzQnVmZmVyKGUpP2U6QnVmZmVyLmZyb20oZSxmKTt2YXIgdT1vLmxlbmd0aDtpZih1PT09MCl7dGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIHZhbHVlIFwiJytlKydcIiBpcyBpbnZhbGlkIGZvciBhcmd1bWVudCBcInZhbHVlXCInKX1mb3IoaT0wO2k8dC1yOysraSl7dGhpc1tpK3JdPW9baSV1XX19cmV0dXJuIHRoaXN9O3ZhciBhPS9bXisvMC05QS1aYS16LV9dL2c7ZnVuY3Rpb24gYmFzZTY0Y2xlYW4oZSl7ZT1lLnNwbGl0KFwiPVwiKVswXTtlPWUudHJpbSgpLnJlcGxhY2UoYSxcIlwiKTtpZihlLmxlbmd0aDwyKXJldHVyblwiXCI7d2hpbGUoZS5sZW5ndGglNCE9PTApe2U9ZStcIj1cIn1yZXR1cm4gZX1mdW5jdGlvbiB1dGY4VG9CeXRlcyhlLHIpe3I9cnx8SW5maW5pdHk7dmFyIHQ7dmFyIGY9ZS5sZW5ndGg7dmFyIG49bnVsbDt2YXIgaT1bXTtmb3IodmFyIG89MDtvPGY7KytvKXt0PWUuY2hhckNvZGVBdChvKTtpZih0PjU1Mjk1JiZ0PDU3MzQ0KXtpZighbil7aWYodD41NjMxOSl7aWYoKHItPTMpPi0xKWkucHVzaCgyMzksMTkxLDE4OSk7Y29udGludWV9ZWxzZSBpZihvKzE9PT1mKXtpZigoci09Myk+LTEpaS5wdXNoKDIzOSwxOTEsMTg5KTtjb250aW51ZX1uPXQ7Y29udGludWV9aWYodDw1NjMyMCl7aWYoKHItPTMpPi0xKWkucHVzaCgyMzksMTkxLDE4OSk7bj10O2NvbnRpbnVlfXQ9KG4tNTUyOTY8PDEwfHQtNTYzMjApKzY1NTM2fWVsc2UgaWYobil7aWYoKHItPTMpPi0xKWkucHVzaCgyMzksMTkxLDE4OSl9bj1udWxsO2lmKHQ8MTI4KXtpZigoci09MSk8MClicmVhaztpLnB1c2godCl9ZWxzZSBpZih0PDIwNDgpe2lmKChyLT0yKTwwKWJyZWFrO2kucHVzaCh0Pj42fDE5Mix0JjYzfDEyOCl9ZWxzZSBpZih0PDY1NTM2KXtpZigoci09Myk8MClicmVhaztpLnB1c2godD4+MTJ8MjI0LHQ+PjYmNjN8MTI4LHQmNjN8MTI4KX1lbHNlIGlmKHQ8MTExNDExMil7aWYoKHItPTQpPDApYnJlYWs7aS5wdXNoKHQ+PjE4fDI0MCx0Pj4xMiY2M3wxMjgsdD4+NiY2M3wxMjgsdCY2M3wxMjgpfWVsc2V7dGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBjb2RlIHBvaW50XCIpfX1yZXR1cm4gaX1mdW5jdGlvbiBhc2NpaVRvQnl0ZXMoZSl7dmFyIHI9W107Zm9yKHZhciB0PTA7dDxlLmxlbmd0aDsrK3Qpe3IucHVzaChlLmNoYXJDb2RlQXQodCkmMjU1KX1yZXR1cm4gcn1mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyhlLHIpe3ZhciB0LGYsbjt2YXIgaT1bXTtmb3IodmFyIG89MDtvPGUubGVuZ3RoOysrbyl7aWYoKHItPTIpPDApYnJlYWs7dD1lLmNoYXJDb2RlQXQobyk7Zj10Pj44O249dCUyNTY7aS5wdXNoKG4pO2kucHVzaChmKX1yZXR1cm4gaX1mdW5jdGlvbiBiYXNlNjRUb0J5dGVzKGUpe3JldHVybiBmLnRvQnl0ZUFycmF5KGJhc2U2NGNsZWFuKGUpKX1mdW5jdGlvbiBibGl0QnVmZmVyKGUscix0LGYpe2Zvcih2YXIgbj0wO248ZjsrK24pe2lmKG4rdD49ci5sZW5ndGh8fG4+PWUubGVuZ3RoKWJyZWFrO3Jbbit0XT1lW25dfXJldHVybiBufWZ1bmN0aW9uIGlzSW5zdGFuY2UoZSxyKXtyZXR1cm4gZSBpbnN0YW5jZW9mIHJ8fGUhPW51bGwmJmUuY29uc3RydWN0b3IhPW51bGwmJmUuY29uc3RydWN0b3IubmFtZSE9bnVsbCYmZS5jb25zdHJ1Y3Rvci5uYW1lPT09ci5uYW1lfWZ1bmN0aW9uIG51bWJlcklzTmFOKGUpe3JldHVybiBlIT09ZX12YXIgcz1mdW5jdGlvbigpe3ZhciBlPVwiMDEyMzQ1Njc4OWFiY2RlZlwiO3ZhciByPW5ldyBBcnJheSgyNTYpO2Zvcih2YXIgdD0wO3Q8MTY7Kyt0KXt2YXIgZj10KjE2O2Zvcih2YXIgbj0wO248MTY7KytuKXtyW2Yrbl09ZVt0XStlW25dfX1yZXR1cm4gcn0oKX0sNzgzOmZ1bmN0aW9uKGUscil7XG4vKiEgaWVlZTc1NC4gQlNELTMtQ2xhdXNlIExpY2Vuc2UuIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZy9vcGVuc291cmNlPiAqL1xuci5yZWFkPWZ1bmN0aW9uKGUscix0LGYsbil7dmFyIGksbzt2YXIgdT1uKjgtZi0xO3ZhciBhPSgxPDx1KS0xO3ZhciBzPWE+PjE7dmFyIGg9LTc7dmFyIGM9dD9uLTE6MDt2YXIgbD10Py0xOjE7dmFyIHA9ZVtyK2NdO2MrPWw7aT1wJigxPDwtaCktMTtwPj49LWg7aCs9dTtmb3IoO2g+MDtpPWkqMjU2K2VbcitjXSxjKz1sLGgtPTgpe31vPWkmKDE8PC1oKS0xO2k+Pj0taDtoKz1mO2Zvcig7aD4wO289byoyNTYrZVtyK2NdLGMrPWwsaC09OCl7fWlmKGk9PT0wKXtpPTEtc31lbHNlIGlmKGk9PT1hKXtyZXR1cm4gbz9OYU46KHA/LTE6MSkqSW5maW5pdHl9ZWxzZXtvPW8rTWF0aC5wb3coMixmKTtpPWktc31yZXR1cm4ocD8tMToxKSpvKk1hdGgucG93KDIsaS1mKX07ci53cml0ZT1mdW5jdGlvbihlLHIsdCxmLG4saSl7dmFyIG8sdSxhO3ZhciBzPWkqOC1uLTE7dmFyIGg9KDE8PHMpLTE7dmFyIGM9aD4+MTt2YXIgbD1uPT09MjM/TWF0aC5wb3coMiwtMjQpLU1hdGgucG93KDIsLTc3KTowO3ZhciBwPWY/MDppLTE7dmFyIHk9Zj8xOi0xO3ZhciBnPXI8MHx8cj09PTAmJjEvcjwwPzE6MDtyPU1hdGguYWJzKHIpO2lmKGlzTmFOKHIpfHxyPT09SW5maW5pdHkpe3U9aXNOYU4ocik/MTowO289aH1lbHNle289TWF0aC5mbG9vcihNYXRoLmxvZyhyKS9NYXRoLkxOMik7aWYociooYT1NYXRoLnBvdygyLC1vKSk8MSl7by0tO2EqPTJ9aWYobytjPj0xKXtyKz1sL2F9ZWxzZXtyKz1sKk1hdGgucG93KDIsMS1jKX1pZihyKmE+PTIpe28rKzthLz0yfWlmKG8rYz49aCl7dT0wO289aH1lbHNlIGlmKG8rYz49MSl7dT0ociphLTEpKk1hdGgucG93KDIsbik7bz1vK2N9ZWxzZXt1PXIqTWF0aC5wb3coMixjLTEpKk1hdGgucG93KDIsbik7bz0wfX1mb3IoO24+PTg7ZVt0K3BdPXUmMjU1LHArPXksdS89MjU2LG4tPTgpe31vPW88PG58dTtzKz1uO2Zvcig7cz4wO2VbdCtwXT1vJjI1NSxwKz15LG8vPTI1NixzLT04KXt9ZVt0K3AteV18PWcqMTI4fX19O3ZhciByPXt9O2Z1bmN0aW9uIF9fbmNjd3Bja19yZXF1aXJlX18odCl7dmFyIGY9clt0XTtpZihmIT09dW5kZWZpbmVkKXtyZXR1cm4gZi5leHBvcnRzfXZhciBuPXJbdF09e2V4cG9ydHM6e319O3ZhciBpPXRydWU7dHJ5e2VbdF0obixuLmV4cG9ydHMsX19uY2N3cGNrX3JlcXVpcmVfXyk7aT1mYWxzZX1maW5hbGx5e2lmKGkpZGVsZXRlIHJbdF19cmV0dXJuIG4uZXhwb3J0c31pZih0eXBlb2YgX19uY2N3cGNrX3JlcXVpcmVfXyE9PVwidW5kZWZpbmVkXCIpX19uY2N3cGNrX3JlcXVpcmVfXy5hYj1fX2Rpcm5hbWUrXCIvXCI7dmFyIHQ9X19uY2N3cGNrX3JlcXVpcmVfXyg3Mik7bW9kdWxlLmV4cG9ydHM9dH0pKCk7Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/buffer/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * react-jsx-dev-runtime.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n true &&\n  (function () {\n    function getComponentNameFromType(type) {\n      if (null == type) return null;\n      if (\"function\" === typeof type)\n        return type.$$typeof === REACT_CLIENT_REFERENCE\n          ? null\n          : type.displayName || type.name || null;\n      if (\"string\" === typeof type) return type;\n      switch (type) {\n        case REACT_FRAGMENT_TYPE:\n          return \"Fragment\";\n        case REACT_PROFILER_TYPE:\n          return \"Profiler\";\n        case REACT_STRICT_MODE_TYPE:\n          return \"StrictMode\";\n        case REACT_SUSPENSE_TYPE:\n          return \"Suspense\";\n        case REACT_SUSPENSE_LIST_TYPE:\n          return \"SuspenseList\";\n        case REACT_ACTIVITY_TYPE:\n          return \"Activity\";\n      }\n      if (\"object\" === typeof type)\n        switch (\n          (\"number\" === typeof type.tag &&\n            console.error(\n              \"Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.\"\n            ),\n          type.$$typeof)\n        ) {\n          case REACT_PORTAL_TYPE:\n            return \"Portal\";\n          case REACT_CONTEXT_TYPE:\n            return type.displayName || \"Context\";\n          case REACT_CONSUMER_TYPE:\n            return (type._context.displayName || \"Context\") + \".Consumer\";\n          case REACT_FORWARD_REF_TYPE:\n            var innerType = type.render;\n            type = type.displayName;\n            type ||\n              ((type = innerType.displayName || innerType.name || \"\"),\n              (type = \"\" !== type ? \"ForwardRef(\" + type + \")\" : \"ForwardRef\"));\n            return type;\n          case REACT_MEMO_TYPE:\n            return (\n              (innerType = type.displayName || null),\n              null !== innerType\n                ? innerType\n                : getComponentNameFromType(type.type) || \"Memo\"\n            );\n          case REACT_LAZY_TYPE:\n            innerType = type._payload;\n            type = type._init;\n            try {\n              return getComponentNameFromType(type(innerType));\n            } catch (x) {}\n        }\n      return null;\n    }\n    function testStringCoercion(value) {\n      return \"\" + value;\n    }\n    function checkKeyStringCoercion(value) {\n      try {\n        testStringCoercion(value);\n        var JSCompiler_inline_result = !1;\n      } catch (e) {\n        JSCompiler_inline_result = !0;\n      }\n      if (JSCompiler_inline_result) {\n        JSCompiler_inline_result = console;\n        var JSCompiler_temp_const = JSCompiler_inline_result.error;\n        var JSCompiler_inline_result$jscomp$0 =\n          (\"function\" === typeof Symbol &&\n            Symbol.toStringTag &&\n            value[Symbol.toStringTag]) ||\n          value.constructor.name ||\n          \"Object\";\n        JSCompiler_temp_const.call(\n          JSCompiler_inline_result,\n          \"The provided key is an unsupported type %s. This value must be coerced to a string before using it here.\",\n          JSCompiler_inline_result$jscomp$0\n        );\n        return testStringCoercion(value);\n      }\n    }\n    function getTaskName(type) {\n      if (type === REACT_FRAGMENT_TYPE) return \"<>\";\n      if (\n        \"object\" === typeof type &&\n        null !== type &&\n        type.$$typeof === REACT_LAZY_TYPE\n      )\n        return \"<...>\";\n      try {\n        var name = getComponentNameFromType(type);\n        return name ? \"<\" + name + \">\" : \"<...>\";\n      } catch (x) {\n        return \"<...>\";\n      }\n    }\n    function getOwner() {\n      var dispatcher = ReactSharedInternals.A;\n      return null === dispatcher ? null : dispatcher.getOwner();\n    }\n    function UnknownOwner() {\n      return Error(\"react-stack-top-frame\");\n    }\n    function hasValidKey(config) {\n      if (hasOwnProperty.call(config, \"key\")) {\n        var getter = Object.getOwnPropertyDescriptor(config, \"key\").get;\n        if (getter && getter.isReactWarning) return !1;\n      }\n      return void 0 !== config.key;\n    }\n    function defineKeyPropWarningGetter(props, displayName) {\n      function warnAboutAccessingKey() {\n        specialPropKeyWarningShown ||\n          ((specialPropKeyWarningShown = !0),\n          console.error(\n            \"%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)\",\n            displayName\n          ));\n      }\n      warnAboutAccessingKey.isReactWarning = !0;\n      Object.defineProperty(props, \"key\", {\n        get: warnAboutAccessingKey,\n        configurable: !0\n      });\n    }\n    function elementRefGetterWithDeprecationWarning() {\n      var componentName = getComponentNameFromType(this.type);\n      didWarnAboutElementRef[componentName] ||\n        ((didWarnAboutElementRef[componentName] = !0),\n        console.error(\n          \"Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release.\"\n        ));\n      componentName = this.props.ref;\n      return void 0 !== componentName ? componentName : null;\n    }\n    function ReactElement(type, key, props, owner, debugStack, debugTask) {\n      var refProp = props.ref;\n      type = {\n        $$typeof: REACT_ELEMENT_TYPE,\n        type: type,\n        key: key,\n        props: props,\n        _owner: owner\n      };\n      null !== (void 0 !== refProp ? refProp : null)\n        ? Object.defineProperty(type, \"ref\", {\n            enumerable: !1,\n            get: elementRefGetterWithDeprecationWarning\n          })\n        : Object.defineProperty(type, \"ref\", { enumerable: !1, value: null });\n      type._store = {};\n      Object.defineProperty(type._store, \"validated\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: 0\n      });\n      Object.defineProperty(type, \"_debugInfo\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: null\n      });\n      Object.defineProperty(type, \"_debugStack\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: debugStack\n      });\n      Object.defineProperty(type, \"_debugTask\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: debugTask\n      });\n      Object.freeze && (Object.freeze(type.props), Object.freeze(type));\n      return type;\n    }\n    function jsxDEVImpl(\n      type,\n      config,\n      maybeKey,\n      isStaticChildren,\n      debugStack,\n      debugTask\n    ) {\n      var children = config.children;\n      if (void 0 !== children)\n        if (isStaticChildren)\n          if (isArrayImpl(children)) {\n            for (\n              isStaticChildren = 0;\n              isStaticChildren < children.length;\n              isStaticChildren++\n            )\n              validateChildKeys(children[isStaticChildren]);\n            Object.freeze && Object.freeze(children);\n          } else\n            console.error(\n              \"React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.\"\n            );\n        else validateChildKeys(children);\n      if (hasOwnProperty.call(config, \"key\")) {\n        children = getComponentNameFromType(type);\n        var keys = Object.keys(config).filter(function (k) {\n          return \"key\" !== k;\n        });\n        isStaticChildren =\n          0 < keys.length\n            ? \"{key: someKey, \" + keys.join(\": ..., \") + \": ...}\"\n            : \"{key: someKey}\";\n        didWarnAboutKeySpread[children + isStaticChildren] ||\n          ((keys =\n            0 < keys.length ? \"{\" + keys.join(\": ..., \") + \": ...}\" : \"{}\"),\n          console.error(\n            'A props object containing a \"key\" prop is being spread into JSX:\\n  let props = %s;\\n  <%s {...props} />\\nReact keys must be passed directly to JSX without using spread:\\n  let props = %s;\\n  <%s key={someKey} {...props} />',\n            isStaticChildren,\n            children,\n            keys,\n            children\n          ),\n          (didWarnAboutKeySpread[children + isStaticChildren] = !0));\n      }\n      children = null;\n      void 0 !== maybeKey &&\n        (checkKeyStringCoercion(maybeKey), (children = \"\" + maybeKey));\n      hasValidKey(config) &&\n        (checkKeyStringCoercion(config.key), (children = \"\" + config.key));\n      if (\"key\" in config) {\n        maybeKey = {};\n        for (var propName in config)\n          \"key\" !== propName && (maybeKey[propName] = config[propName]);\n      } else maybeKey = config;\n      children &&\n        defineKeyPropWarningGetter(\n          maybeKey,\n          \"function\" === typeof type\n            ? type.displayName || type.name || \"Unknown\"\n            : type\n        );\n      return ReactElement(\n        type,\n        children,\n        maybeKey,\n        getOwner(),\n        debugStack,\n        debugTask\n      );\n    }\n    function validateChildKeys(node) {\n      \"object\" === typeof node &&\n        null !== node &&\n        node.$$typeof === REACT_ELEMENT_TYPE &&\n        node._store &&\n        (node._store.validated = 1);\n    }\n    var React = __webpack_require__(/*! next/dist/compiled/react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"),\n      REACT_ELEMENT_TYPE = Symbol.for(\"react.transitional.element\"),\n      REACT_PORTAL_TYPE = Symbol.for(\"react.portal\"),\n      REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\"),\n      REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\"),\n      REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\"),\n      REACT_CONSUMER_TYPE = Symbol.for(\"react.consumer\"),\n      REACT_CONTEXT_TYPE = Symbol.for(\"react.context\"),\n      REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\"),\n      REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\"),\n      REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\"),\n      REACT_MEMO_TYPE = Symbol.for(\"react.memo\"),\n      REACT_LAZY_TYPE = Symbol.for(\"react.lazy\"),\n      REACT_ACTIVITY_TYPE = Symbol.for(\"react.activity\"),\n      REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\"),\n      ReactSharedInternals =\n        React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,\n      hasOwnProperty = Object.prototype.hasOwnProperty,\n      isArrayImpl = Array.isArray,\n      createTask = console.createTask\n        ? console.createTask\n        : function () {\n            return null;\n          };\n    React = {\n      react_stack_bottom_frame: function (callStackForError) {\n        return callStackForError();\n      }\n    };\n    var specialPropKeyWarningShown;\n    var didWarnAboutElementRef = {};\n    var unknownOwnerDebugStack = React.react_stack_bottom_frame.bind(\n      React,\n      UnknownOwner\n    )();\n    var unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));\n    var didWarnAboutKeySpread = {};\n    exports.Fragment = REACT_FRAGMENT_TYPE;\n    exports.jsxDEV = function (type, config, maybeKey, isStaticChildren) {\n      var trackActualOwner =\n        1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;\n      return jsxDEVImpl(\n        type,\n        config,\n        maybeKey,\n        isStaticChildren,\n        trackActualOwner\n          ? Error(\"react-stack-top-frame\")\n          : unknownOwnerDebugStack,\n        trackActualOwner ? createTask(getTaskName(type)) : unknownOwnerDebugTask\n      );\n    };\n  })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7QUFDYixLQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCwrQ0FBK0MsNkJBQTZCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxnQkFBZ0IsZ0RBQWdEO0FBQ2hFLGdCQUFnQixhQUFhO0FBQzdCO0FBQ0E7QUFDQSxnQ0FBZ0Msa0NBQWtDLE9BQU87QUFDekU7QUFDQSxnR0FBZ0csU0FBUyxVQUFVLHNGQUFzRixhQUFhLFVBQVUsVUFBVTtBQUMxTztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG1CQUFPLENBQUMsc0dBQTBCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksZ0JBQWdCO0FBQ3BCLElBQUksY0FBYztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUciLCJzb3VyY2VzIjpbIkQ6XFxuZXh0XFxvcmdcXG5vZGVfbW9kdWxlc1xcbmV4dFxcZGlzdFxcY29tcGlsZWRcXHJlYWN0XFxjanNcXHJlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WICYmXG4gIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHtcbiAgICAgIGlmIChudWxsID09IHR5cGUpIHJldHVybiBudWxsO1xuICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHR5cGUpXG4gICAgICAgIHJldHVybiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFXG4gICAgICAgICAgPyBudWxsXG4gICAgICAgICAgOiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBudWxsO1xuICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiB0eXBlKSByZXR1cm4gdHlwZTtcbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFJFQUNUX0ZSQUdNRU5UX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFwiRnJhZ21lbnRcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlByb2ZpbGVyXCI7XG4gICAgICAgIGNhc2UgUkVBQ1RfU1RSSUNUX01PREVfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJTdHJpY3RNb2RlXCI7XG4gICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJTdXNwZW5zZVwiO1xuICAgICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJTdXNwZW5zZUxpc3RcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9BQ1RJVklUWV9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIkFjdGl2aXR5XCI7XG4gICAgICB9XG4gICAgICBpZiAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIHR5cGUpXG4gICAgICAgIHN3aXRjaCAoXG4gICAgICAgICAgKFwibnVtYmVyXCIgPT09IHR5cGVvZiB0eXBlLnRhZyAmJlxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJSZWNlaXZlZCBhbiB1bmV4cGVjdGVkIG9iamVjdCBpbiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoKS4gVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICAgICApLFxuICAgICAgICAgIHR5cGUuJCR0eXBlb2YpXG4gICAgICAgICkge1xuICAgICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gXCJQb3J0YWxcIjtcbiAgICAgICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IFwiQ29udGV4dFwiO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OU1VNRVJfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiAodHlwZS5fY29udGV4dC5kaXNwbGF5TmFtZSB8fCBcIkNvbnRleHRcIikgKyBcIi5Db25zdW1lclwiO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgICAgIHZhciBpbm5lclR5cGUgPSB0eXBlLnJlbmRlcjtcbiAgICAgICAgICAgIHR5cGUgPSB0eXBlLmRpc3BsYXlOYW1lO1xuICAgICAgICAgICAgdHlwZSB8fFxuICAgICAgICAgICAgICAoKHR5cGUgPSBpbm5lclR5cGUuZGlzcGxheU5hbWUgfHwgaW5uZXJUeXBlLm5hbWUgfHwgXCJcIiksXG4gICAgICAgICAgICAgICh0eXBlID0gXCJcIiAhPT0gdHlwZSA/IFwiRm9yd2FyZFJlZihcIiArIHR5cGUgKyBcIilcIiA6IFwiRm9yd2FyZFJlZlwiKSk7XG4gICAgICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIChpbm5lclR5cGUgPSB0eXBlLmRpc3BsYXlOYW1lIHx8IG51bGwpLFxuICAgICAgICAgICAgICBudWxsICE9PSBpbm5lclR5cGVcbiAgICAgICAgICAgICAgICA/IGlubmVyVHlwZVxuICAgICAgICAgICAgICAgIDogZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUudHlwZSkgfHwgXCJNZW1vXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICBpbm5lclR5cGUgPSB0eXBlLl9wYXlsb2FkO1xuICAgICAgICAgICAgdHlwZSA9IHR5cGUuX2luaXQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUoaW5uZXJUeXBlKSk7XG4gICAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gXCJcIiArIHZhbHVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjaGVja0tleVN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gICAgICB0cnkge1xuICAgICAgICB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpO1xuICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gITE7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9ICEwO1xuICAgICAgfVxuICAgICAgaWYgKEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCkge1xuICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSBjb25zb2xlO1xuICAgICAgICB2YXIgSlNDb21waWxlcl90ZW1wX2NvbnN0ID0gSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0LmVycm9yO1xuICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQwID1cbiAgICAgICAgICAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgU3ltYm9sICYmXG4gICAgICAgICAgICBTeW1ib2wudG9TdHJpbmdUYWcgJiZcbiAgICAgICAgICAgIHZhbHVlW1N5bWJvbC50b1N0cmluZ1RhZ10pIHx8XG4gICAgICAgICAgdmFsdWUuY29uc3RydWN0b3IubmFtZSB8fFxuICAgICAgICAgIFwiT2JqZWN0XCI7XG4gICAgICAgIEpTQ29tcGlsZXJfdGVtcF9jb25zdC5jYWxsKFxuICAgICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCxcbiAgICAgICAgICBcIlRoZSBwcm92aWRlZCBrZXkgaXMgYW4gdW5zdXBwb3J0ZWQgdHlwZSAlcy4gVGhpcyB2YWx1ZSBtdXN0IGJlIGNvZXJjZWQgdG8gYSBzdHJpbmcgYmVmb3JlIHVzaW5nIGl0IGhlcmUuXCIsXG4gICAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQwXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRUYXNrTmFtZSh0eXBlKSB7XG4gICAgICBpZiAodHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSkgcmV0dXJuIFwiPD5cIjtcbiAgICAgIGlmIChcbiAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIHR5cGUgJiZcbiAgICAgICAgbnVsbCAhPT0gdHlwZSAmJlxuICAgICAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9MQVpZX1RZUEVcbiAgICAgIClcbiAgICAgICAgcmV0dXJuIFwiPC4uLj5cIjtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgICByZXR1cm4gbmFtZSA/IFwiPFwiICsgbmFtZSArIFwiPlwiIDogXCI8Li4uPlwiO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICByZXR1cm4gXCI8Li4uPlwiO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRPd25lcigpIHtcbiAgICAgIHZhciBkaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuQTtcbiAgICAgIHJldHVybiBudWxsID09PSBkaXNwYXRjaGVyID8gbnVsbCA6IGRpc3BhdGNoZXIuZ2V0T3duZXIoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gVW5rbm93bk93bmVyKCkge1xuICAgICAgcmV0dXJuIEVycm9yKFwicmVhY3Qtc3RhY2stdG9wLWZyYW1lXCIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBoYXNWYWxpZEtleShjb25maWcpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgXCJrZXlcIikpIHtcbiAgICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCBcImtleVwiKS5nZXQ7XG4gICAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSByZXR1cm4gITE7XG4gICAgICB9XG4gICAgICByZXR1cm4gdm9pZCAwICE9PSBjb25maWcua2V5O1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcbiAgICAgIGZ1bmN0aW9uIHdhcm5BYm91dEFjY2Vzc2luZ0tleSgpIHtcbiAgICAgICAgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24gfHxcbiAgICAgICAgICAoKHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duID0gITApLFxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIiVzOiBga2V5YCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0IGluIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgdmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCBwcm9wLiAoaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9zcGVjaWFsLXByb3BzKVwiLFxuICAgICAgICAgICAgZGlzcGxheU5hbWVcbiAgICAgICAgICApKTtcbiAgICAgIH1cbiAgICAgIHdhcm5BYm91dEFjY2Vzc2luZ0tleS5pc1JlYWN0V2FybmluZyA9ICEwO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCBcImtleVwiLCB7XG4gICAgICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nS2V5LFxuICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZWxlbWVudFJlZkdldHRlcldpdGhEZXByZWNhdGlvbldhcm5pbmcoKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0aGlzLnR5cGUpO1xuICAgICAgZGlkV2FybkFib3V0RWxlbWVudFJlZltjb21wb25lbnROYW1lXSB8fFxuICAgICAgICAoKGRpZFdhcm5BYm91dEVsZW1lbnRSZWZbY29tcG9uZW50TmFtZV0gPSAhMCksXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJBY2Nlc3NpbmcgZWxlbWVudC5yZWYgd2FzIHJlbW92ZWQgaW4gUmVhY3QgMTkuIHJlZiBpcyBub3cgYSByZWd1bGFyIHByb3AuIEl0IHdpbGwgYmUgcmVtb3ZlZCBmcm9tIHRoZSBKU1ggRWxlbWVudCB0eXBlIGluIGEgZnV0dXJlIHJlbGVhc2UuXCJcbiAgICAgICAgKSk7XG4gICAgICBjb21wb25lbnROYW1lID0gdGhpcy5wcm9wcy5yZWY7XG4gICAgICByZXR1cm4gdm9pZCAwICE9PSBjb21wb25lbnROYW1lID8gY29tcG9uZW50TmFtZSA6IG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFJlYWN0RWxlbWVudCh0eXBlLCBrZXksIHByb3BzLCBvd25lciwgZGVidWdTdGFjaywgZGVidWdUYXNrKSB7XG4gICAgICB2YXIgcmVmUHJvcCA9IHByb3BzLnJlZjtcbiAgICAgIHR5cGUgPSB7XG4gICAgICAgICQkdHlwZW9mOiBSRUFDVF9FTEVNRU5UX1RZUEUsXG4gICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgIGtleToga2V5LFxuICAgICAgICBwcm9wczogcHJvcHMsXG4gICAgICAgIF9vd25lcjogb3duZXJcbiAgICAgIH07XG4gICAgICBudWxsICE9PSAodm9pZCAwICE9PSByZWZQcm9wID8gcmVmUHJvcCA6IG51bGwpXG4gICAgICAgID8gT2JqZWN0LmRlZmluZVByb3BlcnR5KHR5cGUsIFwicmVmXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICAgICAgZ2V0OiBlbGVtZW50UmVmR2V0dGVyV2l0aERlcHJlY2F0aW9uV2FybmluZ1xuICAgICAgICAgIH0pXG4gICAgICAgIDogT2JqZWN0LmRlZmluZVByb3BlcnR5KHR5cGUsIFwicmVmXCIsIHsgZW51bWVyYWJsZTogITEsIHZhbHVlOiBudWxsIH0pO1xuICAgICAgdHlwZS5fc3RvcmUgPSB7fTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0eXBlLl9zdG9yZSwgXCJ2YWxpZGF0ZWRcIiwge1xuICAgICAgICBjb25maWd1cmFibGU6ICExLFxuICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgd3JpdGFibGU6ICEwLFxuICAgICAgICB2YWx1ZTogMFxuICAgICAgfSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodHlwZSwgXCJfZGVidWdJbmZvXCIsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMSxcbiAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgIHdyaXRhYmxlOiAhMCxcbiAgICAgICAgdmFsdWU6IG51bGxcbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHR5cGUsIFwiX2RlYnVnU3RhY2tcIiwge1xuICAgICAgICBjb25maWd1cmFibGU6ICExLFxuICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgd3JpdGFibGU6ICEwLFxuICAgICAgICB2YWx1ZTogZGVidWdTdGFja1xuICAgICAgfSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodHlwZSwgXCJfZGVidWdUYXNrXCIsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMSxcbiAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgIHdyaXRhYmxlOiAhMCxcbiAgICAgICAgdmFsdWU6IGRlYnVnVGFza1xuICAgICAgfSk7XG4gICAgICBPYmplY3QuZnJlZXplICYmIChPYmplY3QuZnJlZXplKHR5cGUucHJvcHMpLCBPYmplY3QuZnJlZXplKHR5cGUpKTtcbiAgICAgIHJldHVybiB0eXBlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBqc3hERVZJbXBsKFxuICAgICAgdHlwZSxcbiAgICAgIGNvbmZpZyxcbiAgICAgIG1heWJlS2V5LFxuICAgICAgaXNTdGF0aWNDaGlsZHJlbixcbiAgICAgIGRlYnVnU3RhY2ssXG4gICAgICBkZWJ1Z1Rhc2tcbiAgICApIHtcbiAgICAgIHZhciBjaGlsZHJlbiA9IGNvbmZpZy5jaGlsZHJlbjtcbiAgICAgIGlmICh2b2lkIDAgIT09IGNoaWxkcmVuKVxuICAgICAgICBpZiAoaXNTdGF0aWNDaGlsZHJlbilcbiAgICAgICAgICBpZiAoaXNBcnJheUltcGwoY2hpbGRyZW4pKSB7XG4gICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICBpc1N0YXRpY0NoaWxkcmVuID0gMDtcbiAgICAgICAgICAgICAgaXNTdGF0aWNDaGlsZHJlbiA8IGNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgICAgICAgaXNTdGF0aWNDaGlsZHJlbisrXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuW2lzU3RhdGljQ2hpbGRyZW5dKTtcbiAgICAgICAgICAgIE9iamVjdC5mcmVlemUgJiYgT2JqZWN0LmZyZWV6ZShjaGlsZHJlbik7XG4gICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIlJlYWN0LmpzeDogU3RhdGljIGNoaWxkcmVuIHNob3VsZCBhbHdheXMgYmUgYW4gYXJyYXkuIFlvdSBhcmUgbGlrZWx5IGV4cGxpY2l0bHkgY2FsbGluZyBSZWFjdC5qc3hzIG9yIFJlYWN0LmpzeERFVi4gVXNlIHRoZSBCYWJlbCB0cmFuc2Zvcm0gaW5zdGVhZC5cIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgZWxzZSB2YWxpZGF0ZUNoaWxkS2V5cyhjaGlsZHJlbik7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIFwia2V5XCIpKSB7XG4gICAgICAgIGNoaWxkcmVuID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGNvbmZpZykuZmlsdGVyKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgcmV0dXJuIFwia2V5XCIgIT09IGs7XG4gICAgICAgIH0pO1xuICAgICAgICBpc1N0YXRpY0NoaWxkcmVuID1cbiAgICAgICAgICAwIDwga2V5cy5sZW5ndGhcbiAgICAgICAgICAgID8gXCJ7a2V5OiBzb21lS2V5LCBcIiArIGtleXMuam9pbihcIjogLi4uLCBcIikgKyBcIjogLi4ufVwiXG4gICAgICAgICAgICA6IFwie2tleTogc29tZUtleX1cIjtcbiAgICAgICAgZGlkV2FybkFib3V0S2V5U3ByZWFkW2NoaWxkcmVuICsgaXNTdGF0aWNDaGlsZHJlbl0gfHxcbiAgICAgICAgICAoKGtleXMgPVxuICAgICAgICAgICAgMCA8IGtleXMubGVuZ3RoID8gXCJ7XCIgKyBrZXlzLmpvaW4oXCI6IC4uLiwgXCIpICsgXCI6IC4uLn1cIiA6IFwie31cIiksXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICdBIHByb3BzIG9iamVjdCBjb250YWluaW5nIGEgXCJrZXlcIiBwcm9wIGlzIGJlaW5nIHNwcmVhZCBpbnRvIEpTWDpcXG4gIGxldCBwcm9wcyA9ICVzO1xcbiAgPCVzIHsuLi5wcm9wc30gLz5cXG5SZWFjdCBrZXlzIG11c3QgYmUgcGFzc2VkIGRpcmVjdGx5IHRvIEpTWCB3aXRob3V0IHVzaW5nIHNwcmVhZDpcXG4gIGxldCBwcm9wcyA9ICVzO1xcbiAgPCVzIGtleT17c29tZUtleX0gey4uLnByb3BzfSAvPicsXG4gICAgICAgICAgICBpc1N0YXRpY0NoaWxkcmVuLFxuICAgICAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgICAgICBrZXlzLFxuICAgICAgICAgICAgY2hpbGRyZW5cbiAgICAgICAgICApLFxuICAgICAgICAgIChkaWRXYXJuQWJvdXRLZXlTcHJlYWRbY2hpbGRyZW4gKyBpc1N0YXRpY0NoaWxkcmVuXSA9ICEwKSk7XG4gICAgICB9XG4gICAgICBjaGlsZHJlbiA9IG51bGw7XG4gICAgICB2b2lkIDAgIT09IG1heWJlS2V5ICYmXG4gICAgICAgIChjaGVja0tleVN0cmluZ0NvZXJjaW9uKG1heWJlS2V5KSwgKGNoaWxkcmVuID0gXCJcIiArIG1heWJlS2V5KSk7XG4gICAgICBoYXNWYWxpZEtleShjb25maWcpICYmXG4gICAgICAgIChjaGVja0tleVN0cmluZ0NvZXJjaW9uKGNvbmZpZy5rZXkpLCAoY2hpbGRyZW4gPSBcIlwiICsgY29uZmlnLmtleSkpO1xuICAgICAgaWYgKFwia2V5XCIgaW4gY29uZmlnKSB7XG4gICAgICAgIG1heWJlS2V5ID0ge307XG4gICAgICAgIGZvciAodmFyIHByb3BOYW1lIGluIGNvbmZpZylcbiAgICAgICAgICBcImtleVwiICE9PSBwcm9wTmFtZSAmJiAobWF5YmVLZXlbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXSk7XG4gICAgICB9IGVsc2UgbWF5YmVLZXkgPSBjb25maWc7XG4gICAgICBjaGlsZHJlbiAmJlxuICAgICAgICBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihcbiAgICAgICAgICBtYXliZUtleSxcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB0eXBlXG4gICAgICAgICAgICA/IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8IFwiVW5rbm93blwiXG4gICAgICAgICAgICA6IHR5cGVcbiAgICAgICAgKTtcbiAgICAgIHJldHVybiBSZWFjdEVsZW1lbnQoXG4gICAgICAgIHR5cGUsXG4gICAgICAgIGNoaWxkcmVuLFxuICAgICAgICBtYXliZUtleSxcbiAgICAgICAgZ2V0T3duZXIoKSxcbiAgICAgICAgZGVidWdTdGFjayxcbiAgICAgICAgZGVidWdUYXNrXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZUNoaWxkS2V5cyhub2RlKSB7XG4gICAgICBcIm9iamVjdFwiID09PSB0eXBlb2Ygbm9kZSAmJlxuICAgICAgICBudWxsICE9PSBub2RlICYmXG4gICAgICAgIG5vZGUuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRSAmJlxuICAgICAgICBub2RlLl9zdG9yZSAmJlxuICAgICAgICAobm9kZS5fc3RvcmUudmFsaWRhdGVkID0gMSk7XG4gICAgfVxuICAgIHZhciBSZWFjdCA9IHJlcXVpcmUoXCJuZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3RcIiksXG4gICAgICBSRUFDVF9FTEVNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QudHJhbnNpdGlvbmFsLmVsZW1lbnRcIiksXG4gICAgICBSRUFDVF9QT1JUQUxfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5wb3J0YWxcIiksXG4gICAgICBSRUFDVF9GUkFHTUVOVF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmZyYWdtZW50XCIpLFxuICAgICAgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5zdHJpY3RfbW9kZVwiKSxcbiAgICAgIFJFQUNUX1BST0ZJTEVSX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QucHJvZmlsZXJcIiksXG4gICAgICBSRUFDVF9DT05TVU1FUl9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmNvbnN1bWVyXCIpLFxuICAgICAgUkVBQ1RfQ09OVEVYVF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmNvbnRleHRcIiksXG4gICAgICBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmZvcndhcmRfcmVmXCIpLFxuICAgICAgUkVBQ1RfU1VTUEVOU0VfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5zdXNwZW5zZVwiKSxcbiAgICAgIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5zdXNwZW5zZV9saXN0XCIpLFxuICAgICAgUkVBQ1RfTUVNT19UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0Lm1lbW9cIiksXG4gICAgICBSRUFDVF9MQVpZX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QubGF6eVwiKSxcbiAgICAgIFJFQUNUX0FDVElWSVRZX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuYWN0aXZpdHlcIiksXG4gICAgICBSRUFDVF9DTElFTlRfUkVGRVJFTkNFID0gU3ltYm9sLmZvcihcInJlYWN0LmNsaWVudC5yZWZlcmVuY2VcIiksXG4gICAgICBSZWFjdFNoYXJlZEludGVybmFscyA9XG4gICAgICAgIFJlYWN0Ll9fQ0xJRU5UX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1dBUk5fVVNFUlNfVEhFWV9DQU5OT1RfVVBHUkFERSxcbiAgICAgIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSxcbiAgICAgIGlzQXJyYXlJbXBsID0gQXJyYXkuaXNBcnJheSxcbiAgICAgIGNyZWF0ZVRhc2sgPSBjb25zb2xlLmNyZWF0ZVRhc2tcbiAgICAgICAgPyBjb25zb2xlLmNyZWF0ZVRhc2tcbiAgICAgICAgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9O1xuICAgIFJlYWN0ID0ge1xuICAgICAgcmVhY3Rfc3RhY2tfYm90dG9tX2ZyYW1lOiBmdW5jdGlvbiAoY2FsbFN0YWNrRm9yRXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxTdGFja0ZvckVycm9yKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd247XG4gICAgdmFyIGRpZFdhcm5BYm91dEVsZW1lbnRSZWYgPSB7fTtcbiAgICB2YXIgdW5rbm93bk93bmVyRGVidWdTdGFjayA9IFJlYWN0LnJlYWN0X3N0YWNrX2JvdHRvbV9mcmFtZS5iaW5kKFxuICAgICAgUmVhY3QsXG4gICAgICBVbmtub3duT3duZXJcbiAgICApKCk7XG4gICAgdmFyIHVua25vd25Pd25lckRlYnVnVGFzayA9IGNyZWF0ZVRhc2soZ2V0VGFza05hbWUoVW5rbm93bk93bmVyKSk7XG4gICAgdmFyIGRpZFdhcm5BYm91dEtleVNwcmVhZCA9IHt9O1xuICAgIGV4cG9ydHMuRnJhZ21lbnQgPSBSRUFDVF9GUkFHTUVOVF9UWVBFO1xuICAgIGV4cG9ydHMuanN4REVWID0gZnVuY3Rpb24gKHR5cGUsIGNvbmZpZywgbWF5YmVLZXksIGlzU3RhdGljQ2hpbGRyZW4pIHtcbiAgICAgIHZhciB0cmFja0FjdHVhbE93bmVyID1cbiAgICAgICAgMWU0ID4gUmVhY3RTaGFyZWRJbnRlcm5hbHMucmVjZW50bHlDcmVhdGVkT3duZXJTdGFja3MrKztcbiAgICAgIHJldHVybiBqc3hERVZJbXBsKFxuICAgICAgICB0eXBlLFxuICAgICAgICBjb25maWcsXG4gICAgICAgIG1heWJlS2V5LFxuICAgICAgICBpc1N0YXRpY0NoaWxkcmVuLFxuICAgICAgICB0cmFja0FjdHVhbE93bmVyXG4gICAgICAgICAgPyBFcnJvcihcInJlYWN0LXN0YWNrLXRvcC1mcmFtZVwiKVxuICAgICAgICAgIDogdW5rbm93bk93bmVyRGVidWdTdGFjayxcbiAgICAgICAgdHJhY2tBY3R1YWxPd25lciA/IGNyZWF0ZVRhc2soZ2V0VGFza05hbWUodHlwZSkpIDogdW5rbm93bk93bmVyRGVidWdUYXNrXG4gICAgICApO1xuICAgIH07XG4gIH0pKCk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/jsx-dev-runtime.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvanN4LWRldi1ydW50aW1lLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0YsRUFBRSw4TEFBc0U7QUFDeEUiLCJzb3VyY2VzIjpbIkQ6XFxuZXh0XFxvcmdcXG5vZGVfbW9kdWxlc1xcbmV4dFxcZGlzdFxcY29tcGlsZWRcXHJlYWN0XFxqc3gtZGV2LXJ1bnRpbWUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5wcm9kdWN0aW9uLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcycpO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/simplebar-react/dist/simplebar.min.css":
/*!*************************************************************!*\
  !*** ./node_modules/simplebar-react/dist/simplebar.min.css ***!
  \*************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"0fb3b0449e3f\");\nif (true) { module.hot.accept() }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zaW1wbGViYXItcmVhY3QvZGlzdC9zaW1wbGViYXIubWluLmNzcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsaUVBQWUsY0FBYztBQUM3QixJQUFJLElBQVUsSUFBSSxpQkFBaUIiLCJzb3VyY2VzIjpbIkQ6XFxuZXh0XFxvcmdcXG5vZGVfbW9kdWxlc1xcc2ltcGxlYmFyLXJlYWN0XFxkaXN0XFxzaW1wbGViYXIubWluLmNzcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBcIjBmYjNiMDQ0OWUzZlwiXG5pZiAobW9kdWxlLmhvdCkgeyBtb2R1bGUuaG90LmFjY2VwdCgpIH1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/simplebar-react/dist/simplebar.min.css\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/slick-carousel/slick/slick-theme.css":
/*!***********************************************************!*\
  !*** ./node_modules/slick-carousel/slick/slick-theme.css ***!
  \***********************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"47bbcad01bb7\");\nif (true) { module.hot.accept() }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zbGljay1jYXJvdXNlbC9zbGljay9zbGljay10aGVtZS5jc3MiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLGlFQUFlLGNBQWM7QUFDN0IsSUFBSSxJQUFVLElBQUksaUJBQWlCIiwic291cmNlcyI6WyJEOlxcbmV4dFxcb3JnXFxub2RlX21vZHVsZXNcXHNsaWNrLWNhcm91c2VsXFxzbGlja1xcc2xpY2stdGhlbWUuY3NzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IFwiNDdiYmNhZDAxYmI3XCJcbmlmIChtb2R1bGUuaG90KSB7IG1vZHVsZS5ob3QuYWNjZXB0KCkgfVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/slick-carousel/slick/slick-theme.css\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/slick-carousel/slick/slick.css":
/*!*****************************************************!*\
  !*** ./node_modules/slick-carousel/slick/slick.css ***!
  \*****************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"409910187ca4\");\nif (true) { module.hot.accept() }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zbGljay1jYXJvdXNlbC9zbGljay9zbGljay5jc3MiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLGlFQUFlLGNBQWM7QUFDN0IsSUFBSSxJQUFVLElBQUksaUJBQWlCIiwic291cmNlcyI6WyJEOlxcbmV4dFxcb3JnXFxub2RlX21vZHVsZXNcXHNsaWNrLWNhcm91c2VsXFxzbGlja1xcc2xpY2suY3NzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IFwiNDA5OTEwMTg3Y2E0XCJcbmlmIChtb2R1bGUuaG90KSB7IG1vZHVsZS5ob3QuYWNjZXB0KCkgfVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/slick-carousel/slick/slick.css\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/app/globle.css":
/*!****************************!*\
  !*** ./src/app/globle.css ***!
  \****************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"bc9caa71568d\");\nif (true) { module.hot.accept() }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvZ2xvYmxlLmNzcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsaUVBQWUsY0FBYztBQUM3QixJQUFJLElBQVUsSUFBSSxpQkFBaUIiLCJzb3VyY2VzIjpbIkQ6XFxuZXh0XFxvcmdcXHNyY1xcYXBwXFxnbG9ibGUuY3NzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IFwiYmM5Y2FhNzE1NjhkXCJcbmlmIChtb2R1bGUuaG90KSB7IG1vZHVsZS5ob3QuYWNjZXB0KCkgfVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/globle.css\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/app/layout.js":
/*!***************************!*\
  !*** ./src/app/layout.js ***!
  \***************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ RootLayout)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var _utils_Bootstrap_BootstrapClient__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/utils/Bootstrap/BootstrapClient */ \"(app-pages-browser)/./src/utils/Bootstrap/BootstrapClient.js\");\n/* harmony import */ var next_head__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/head */ \"(app-pages-browser)/./node_modules/next/dist/client/components/noop-head.js\");\n/* harmony import */ var next_head__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_head__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _context_AuthContext__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/context/AuthContext */ \"(app-pages-browser)/./src/context/AuthContext.js\");\n/* harmony import */ var _vendor_trumbowyg_trumbowyg_min_css__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../vendor/trumbowyg/trumbowyg.min.css */ \"(app-pages-browser)/./src/vendor/trumbowyg/trumbowyg.min.css\");\n/* harmony import */ var filepond_dist_filepond_min_css__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! filepond/dist/filepond.min.css */ \"(app-pages-browser)/./node_modules/filepond/dist/filepond.min.css\");\n/* harmony import */ var _vendor_fontawesome_css_all_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../vendor/fontawesome/css/all.css */ \"(app-pages-browser)/./src/vendor/fontawesome/css/all.css\");\n/* harmony import */ var _vendor_datatable_datatable2_buttons_dataTables_min_css__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../vendor/datatable/datatable2/buttons.dataTables.min.css */ \"(app-pages-browser)/./src/vendor/datatable/datatable2/buttons.dataTables.min.css\");\n/* harmony import */ var _vendor_prism_prism_min_css__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../vendor/prism/prism.min.css */ \"(app-pages-browser)/./src/vendor/prism/prism.min.css\");\n/* harmony import */ var slick_carousel_slick_slick_css__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! slick-carousel/slick/slick.css */ \"(app-pages-browser)/./node_modules/slick-carousel/slick/slick.css\");\n/* harmony import */ var slick_carousel_slick_slick_theme_css__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! slick-carousel/slick/slick-theme.css */ \"(app-pages-browser)/./node_modules/slick-carousel/slick/slick-theme.css\");\n/* harmony import */ var _vendor_animation_animate_min_css__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../vendor/animation/animate.min.css */ \"(app-pages-browser)/./src/vendor/animation/animate.min.css\");\n/* harmony import */ var _vendor_datatable_jquery_dataTables_min_css__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../vendor/datatable/jquery.dataTables.min.css */ \"(app-pages-browser)/./src/vendor/datatable/jquery.dataTables.min.css\");\n/* harmony import */ var _vendor_weather_weather_icons_css__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../vendor/weather/weather-icons.css */ \"(app-pages-browser)/./src/vendor/weather/weather-icons.css\");\n/* harmony import */ var _vendor_animated_icon_mdi_light_css__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../vendor/animated_icon/mdi-light.css */ \"(app-pages-browser)/./src/vendor/animated_icon/mdi-light.css\");\n/* harmony import */ var _vendor_ionio_icon_css_iconoir_css__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../vendor/ionio-icon/css/iconoir.css */ \"(app-pages-browser)/./src/vendor/ionio-icon/css/iconoir.css\");\n/* harmony import */ var _vendor_leafletmaps_leaflet_css__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../vendor/leafletmaps/leaflet.css */ \"(app-pages-browser)/./src/vendor/leafletmaps/leaflet.css\");\n/* harmony import */ var _vendor_vector_map_jquery_jvectormap_css__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../vendor/vector-map/jquery-jvectormap.css */ \"(app-pages-browser)/./src/vendor/vector-map/jquery-jvectormap.css\");\n/* harmony import */ var _vendor_shepherdjs_shepherd_css__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../vendor/shepherdjs/shepherd.css */ \"(app-pages-browser)/./src/vendor/shepherdjs/shepherd.css\");\n/* harmony import */ var _vendor_jstree_style_min_css__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ../vendor/jstree/style.min.css */ \"(app-pages-browser)/./src/vendor/jstree/style.min.css\");\n/* harmony import */ var _vendor_dual_listboxes_dual_listbox_css__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ../vendor/dual_listboxes/dual-listbox.css */ \"(app-pages-browser)/./src/vendor/dual_listboxes/dual-listbox.css\");\n/* harmony import */ var _vendor_fullcalendar_global_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ../vendor/fullcalendar/global.js */ \"(app-pages-browser)/./src/vendor/fullcalendar/global.js\");\n/* harmony import */ var _vendor_fullcalendar_global_js__WEBPACK_IMPORTED_MODULE_21___default = /*#__PURE__*/__webpack_require__.n(_vendor_fullcalendar_global_js__WEBPACK_IMPORTED_MODULE_21__);\n/* harmony import */ var _vendor_slick_slick_css__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ../vendor/slick/slick.css */ \"(app-pages-browser)/./src/vendor/slick/slick.css\");\n/* harmony import */ var _vendor_datepikar_flatpickr_min_css__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ../vendor/datepikar/flatpickr.min.css */ \"(app-pages-browser)/./src/vendor/datepikar/flatpickr.min.css\");\n/* harmony import */ var filepond_plugin_image_preview_dist_filepond_plugin_image_preview_css__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! filepond-plugin-image-preview/dist/filepond-plugin-image-preview.css */ \"(app-pages-browser)/./node_modules/filepond-plugin-image-preview/dist/filepond-plugin-image-preview.css\");\n/* harmony import */ var _vendor_tabler_icons_tabler_icons_css__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ../vendor/tabler-icons/tabler-icons.css */ \"(app-pages-browser)/./src/vendor/tabler-icons/tabler-icons.css\");\n/* harmony import */ var _vendor_phosphor_phosphor_light_css__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ../vendor/phosphor/phosphor-light.css */ \"(app-pages-browser)/./src/vendor/phosphor/phosphor-light.css\");\n/* harmony import */ var _vendor_flag_icons_master_flag_icon_css__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ../vendor/flag-icons-master/flag-icon.css */ \"(app-pages-browser)/./src/vendor/flag-icons-master/flag-icon.css\");\n/* harmony import */ var _vendor_nouislider_nouislider_min_css__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ../vendor/nouislider/nouislider.min.css */ \"(app-pages-browser)/./src/vendor/nouislider/nouislider.min.css\");\n/* harmony import */ var simplebar_react_dist_simplebar_min_css__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! simplebar-react/dist/simplebar.min.css */ \"(app-pages-browser)/./node_modules/simplebar-react/dist/simplebar.min.css\");\n/* harmony import */ var bootstrap_dist_css_bootstrap_min_css__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! bootstrap/dist/css/bootstrap.min.css */ \"(app-pages-browser)/./node_modules/bootstrap/dist/css/bootstrap.min.css\");\n/* harmony import */ var _vendor_select_select2_min_css__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ../vendor/select/select2.min.css */ \"(app-pages-browser)/./src/vendor/select/select2.min.css\");\n/* harmony import */ var _scss_style_scss__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ../scss/style.scss */ \"(app-pages-browser)/./src/scss/style.scss\");\n/* harmony import */ var _scss_responsive_scss__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ../scss/responsive.scss */ \"(app-pages-browser)/./src/scss/responsive.scss\");\n/* harmony import */ var _globle_css__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ./globle.css */ \"(app-pages-browser)/./src/app/globle.css\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \n\n\n //  import context\n// CSS imports\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction RootLayout(param) {\n    let { children } = param;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"html\", {\n        lang: \"en\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((next_head__WEBPACK_IMPORTED_MODULE_2___default()), {\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"link\", {\n                        rel: \"preconnect\",\n                        href: \"https://fonts.googleapis.com\"\n                    }, void 0, false, {\n                        fileName: \"D:\\\\next\\\\org\\\\src\\\\app\\\\layout.js\",\n                        lineNumber: 44,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"link\", {\n                        rel: \"preconnect\",\n                        href: \"https://fonts.gstatic.com\",\n                        crossOrigin: \"true\"\n                    }, void 0, false, {\n                        fileName: \"D:\\\\next\\\\org\\\\src\\\\app\\\\layout.js\",\n                        lineNumber: 45,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"link\", {\n                        href: \"https://fonts.googleapis.com/css2?family=Golos+Text:wght@400..900&display=swap\",\n                        rel: \"stylesheet\"\n                    }, void 0, false, {\n                        fileName: \"D:\\\\next\\\\org\\\\src\\\\app\\\\layout.js\",\n                        lineNumber: 46,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"link\", {\n                        rel: \"icon\",\n                        href: \"/images/logo/favicon.png\",\n                        type: \"image/x-icon\"\n                    }, void 0, false, {\n                        fileName: \"D:\\\\next\\\\org\\\\src\\\\app\\\\layout.js\",\n                        lineNumber: 50,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"link\", {\n                        rel: \"shortcut icon\",\n                        href: \"/images/logo/favicon.png\",\n                        type: \"image/x-icon\"\n                    }, void 0, false, {\n                        fileName: \"D:\\\\next\\\\org\\\\src\\\\app\\\\layout.js\",\n                        lineNumber: 51,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"meta\", {\n                        name: \"msapplication-TileImage\",\n                        content: \"/images/logo/favicon.png\"\n                    }, void 0, false, {\n                        fileName: \"D:\\\\next\\\\org\\\\src\\\\app\\\\layout.js\",\n                        lineNumber: 52,\n                        columnNumber: 9\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"D:\\\\next\\\\org\\\\src\\\\app\\\\layout.js\",\n                lineNumber: 43,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"body\", {\n                className: \"ltr light\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_context_AuthContext__WEBPACK_IMPORTED_MODULE_3__.AuthProvider, {\n                    children: children\n                }, void 0, false, {\n                    fileName: \"D:\\\\next\\\\org\\\\src\\\\app\\\\layout.js\",\n                    lineNumber: 56,\n                    columnNumber: 9\n                }, this)\n            }, void 0, false, {\n                fileName: \"D:\\\\next\\\\org\\\\src\\\\app\\\\layout.js\",\n                lineNumber: 54,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_utils_Bootstrap_BootstrapClient__WEBPACK_IMPORTED_MODULE_1__[\"default\"], {}, void 0, false, {\n                fileName: \"D:\\\\next\\\\org\\\\src\\\\app\\\\layout.js\",\n                lineNumber: 60,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"D:\\\\next\\\\org\\\\src\\\\app\\\\layout.js\",\n        lineNumber: 42,\n        columnNumber: 5\n    }, this);\n}\n_c = RootLayout;\nvar _c;\n$RefreshReg$(_c, \"RootLayout\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvbGF5b3V0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUNnRTtBQUNuQztBQUN3QixDQUFDLG1CQUFtQjtBQUV6RSxjQUFjO0FBQ2lDO0FBQ1A7QUFDRztBQUN3QjtBQUM1QjtBQUNDO0FBQ007QUFDRDtBQUNVO0FBQ1Y7QUFDRTtBQUNEO0FBQ0g7QUFDUztBQUNUO0FBQ0g7QUFDVztBQUNUO0FBQ1A7QUFDWTtBQUMrQjtBQUM3QjtBQUNGO0FBQ0k7QUFDQztBQUNIO0FBQ0Q7QUFDRjtBQUNKO0FBQ2Q7QUFDSztBQUNYO0FBRVAsU0FBU0csV0FBVyxLQUFZO1FBQVosRUFBRUMsUUFBUSxFQUFFLEdBQVo7SUFDakMscUJBQ0UsOERBQUNDO1FBQUtDLE1BQUs7OzBCQUNULDhEQUFDTCxrREFBSUE7O2tDQUNILDhEQUFDTTt3QkFBS0MsS0FBSTt3QkFBYUMsTUFBSzs7Ozs7O2tDQUM1Qiw4REFBQ0Y7d0JBQUtDLEtBQUk7d0JBQWFDLE1BQUs7d0JBQTRCQyxhQUFZOzs7Ozs7a0NBQ3BFLDhEQUFDSDt3QkFDQ0UsTUFBSzt3QkFDTEQsS0FBSTs7Ozs7O2tDQUVOLDhEQUFDRDt3QkFBS0MsS0FBSTt3QkFBT0MsTUFBSzt3QkFBMkJFLE1BQUs7Ozs7OztrQ0FDdEQsOERBQUNKO3dCQUFLQyxLQUFJO3dCQUFnQkMsTUFBSzt3QkFBMkJFLE1BQUs7Ozs7OztrQ0FDL0QsOERBQUNDO3dCQUFLQyxNQUFLO3dCQUEwQkMsU0FBUTs7Ozs7Ozs7Ozs7OzBCQUUvQyw4REFBQ0M7Z0JBQUtDLFdBQVU7MEJBRWQsNEVBQUNkLDhEQUFZQTs4QkFDVkU7Ozs7Ozs7Ozs7OzBCQUdMLDhEQUFDSix3RUFBZUE7Ozs7Ozs7Ozs7O0FBR3RCO0tBdkJ3QkciLCJzb3VyY2VzIjpbIkQ6XFxuZXh0XFxvcmdcXHNyY1xcYXBwXFxsYXlvdXQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCI7XHJcbmltcG9ydCBCb290c3RyYXBDbGllbnQgZnJvbSBcIkAvdXRpbHMvQm9vdHN0cmFwL0Jvb3RzdHJhcENsaWVudFwiO1xyXG5pbXBvcnQgSGVhZCBmcm9tIFwibmV4dC9oZWFkXCI7XHJcbmltcG9ydCB7IEF1dGhQcm92aWRlciB9IGZyb20gXCJAL2NvbnRleHQvQXV0aENvbnRleHRcIjsgLy8g4pyFIGltcG9ydCBjb250ZXh0XHJcblxyXG4vLyBDU1MgaW1wb3J0c1xyXG5pbXBvcnQgJy4uL3ZlbmRvci90cnVtYm93eWcvdHJ1bWJvd3lnLm1pbi5jc3MnO1xyXG5pbXBvcnQgJ2ZpbGVwb25kL2Rpc3QvZmlsZXBvbmQubWluLmNzcyc7XHJcbmltcG9ydCAnLi4vdmVuZG9yL2ZvbnRhd2Vzb21lL2Nzcy9hbGwuY3NzJztcclxuaW1wb3J0ICcuLi92ZW5kb3IvZGF0YXRhYmxlL2RhdGF0YWJsZTIvYnV0dG9ucy5kYXRhVGFibGVzLm1pbi5jc3MnO1xyXG5pbXBvcnQgJy4uL3ZlbmRvci9wcmlzbS9wcmlzbS5taW4uY3NzJztcclxuaW1wb3J0IFwic2xpY2stY2Fyb3VzZWwvc2xpY2svc2xpY2suY3NzXCI7XHJcbmltcG9ydCBcInNsaWNrLWNhcm91c2VsL3NsaWNrL3NsaWNrLXRoZW1lLmNzc1wiO1xyXG5pbXBvcnQgJy4uL3ZlbmRvci9hbmltYXRpb24vYW5pbWF0ZS5taW4uY3NzJztcclxuaW1wb3J0ICcuLi92ZW5kb3IvZGF0YXRhYmxlL2pxdWVyeS5kYXRhVGFibGVzLm1pbi5jc3MnO1xyXG5pbXBvcnQgJy4uL3ZlbmRvci93ZWF0aGVyL3dlYXRoZXItaWNvbnMuY3NzJztcclxuaW1wb3J0ICcuLi92ZW5kb3IvYW5pbWF0ZWRfaWNvbi9tZGktbGlnaHQuY3NzJztcclxuaW1wb3J0ICcuLi92ZW5kb3IvaW9uaW8taWNvbi9jc3MvaWNvbm9pci5jc3MnO1xyXG5pbXBvcnQgJy4uL3ZlbmRvci9sZWFmbGV0bWFwcy9sZWFmbGV0LmNzcyc7XHJcbmltcG9ydCAnLi4vdmVuZG9yL3ZlY3Rvci1tYXAvanF1ZXJ5LWp2ZWN0b3JtYXAuY3NzJztcclxuaW1wb3J0ICcuLi92ZW5kb3Ivc2hlcGhlcmRqcy9zaGVwaGVyZC5jc3MnO1xyXG5pbXBvcnQgJy4uL3ZlbmRvci9qc3RyZWUvc3R5bGUubWluLmNzcyc7XHJcbmltcG9ydCAnLi4vdmVuZG9yL2R1YWxfbGlzdGJveGVzL2R1YWwtbGlzdGJveC5jc3MnO1xyXG5pbXBvcnQgJy4uL3ZlbmRvci9mdWxsY2FsZW5kYXIvZ2xvYmFsLmpzJztcclxuaW1wb3J0ICcuLi92ZW5kb3Ivc2xpY2svc2xpY2suY3NzJztcclxuaW1wb3J0ICcuLi92ZW5kb3IvZGF0ZXBpa2FyL2ZsYXRwaWNrci5taW4uY3NzJztcclxuaW1wb3J0ICdmaWxlcG9uZC1wbHVnaW4taW1hZ2UtcHJldmlldy9kaXN0L2ZpbGVwb25kLXBsdWdpbi1pbWFnZS1wcmV2aWV3LmNzcyc7XHJcbmltcG9ydCBcIi4uL3ZlbmRvci90YWJsZXItaWNvbnMvdGFibGVyLWljb25zLmNzc1wiO1xyXG5pbXBvcnQgXCIuLi92ZW5kb3IvcGhvc3Bob3IvcGhvc3Bob3ItbGlnaHQuY3NzXCI7XHJcbmltcG9ydCBcIi4uL3ZlbmRvci9mbGFnLWljb25zLW1hc3Rlci9mbGFnLWljb24uY3NzXCI7XHJcbmltcG9ydCBcIi4uL3ZlbmRvci92ZWN0b3ItbWFwL2pxdWVyeS1qdmVjdG9ybWFwLmNzc1wiO1xyXG5pbXBvcnQgXCIuLi92ZW5kb3Ivbm91aXNsaWRlci9ub3Vpc2xpZGVyLm1pbi5jc3NcIjtcclxuaW1wb3J0ICdzaW1wbGViYXItcmVhY3QvZGlzdC9zaW1wbGViYXIubWluLmNzcyc7XHJcbmltcG9ydCBcImJvb3RzdHJhcC9kaXN0L2Nzcy9ib290c3RyYXAubWluLmNzc1wiO1xyXG5pbXBvcnQgJy4uL3ZlbmRvci9zZWxlY3Qvc2VsZWN0Mi5taW4uY3NzJztcclxuaW1wb3J0IFwiLi4vc2Nzcy9zdHlsZS5zY3NzXCI7XHJcbmltcG9ydCBcIi4uL3Njc3MvcmVzcG9uc2l2ZS5zY3NzXCI7XHJcbmltcG9ydCAnLi9nbG9ibGUuY3NzJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFJvb3RMYXlvdXQoeyBjaGlsZHJlbiB9KSB7XHJcbiAgcmV0dXJuIChcclxuICAgIDxodG1sIGxhbmc9XCJlblwiPlxyXG4gICAgICA8SGVhZD5cclxuICAgICAgICA8bGluayByZWw9XCJwcmVjb25uZWN0XCIgaHJlZj1cImh0dHBzOi8vZm9udHMuZ29vZ2xlYXBpcy5jb21cIi8+XHJcbiAgICAgICAgPGxpbmsgcmVsPVwicHJlY29ubmVjdFwiIGhyZWY9XCJodHRwczovL2ZvbnRzLmdzdGF0aWMuY29tXCIgY3Jvc3NPcmlnaW49XCJ0cnVlXCIvPlxyXG4gICAgICAgIDxsaW5rXHJcbiAgICAgICAgICBocmVmPVwiaHR0cHM6Ly9mb250cy5nb29nbGVhcGlzLmNvbS9jc3MyP2ZhbWlseT1Hb2xvcytUZXh0OndnaHRANDAwLi45MDAmZGlzcGxheT1zd2FwXCJcclxuICAgICAgICAgIHJlbD1cInN0eWxlc2hlZXRcIlxyXG4gICAgICAgIC8+XHJcbiAgICAgICAgPGxpbmsgcmVsPVwiaWNvblwiIGhyZWY9XCIvaW1hZ2VzL2xvZ28vZmF2aWNvbi5wbmdcIiB0eXBlPVwiaW1hZ2UveC1pY29uXCIvPlxyXG4gICAgICAgIDxsaW5rIHJlbD1cInNob3J0Y3V0IGljb25cIiBocmVmPVwiL2ltYWdlcy9sb2dvL2Zhdmljb24ucG5nXCIgdHlwZT1cImltYWdlL3gtaWNvblwiLz5cclxuICAgICAgICA8bWV0YSBuYW1lPVwibXNhcHBsaWNhdGlvbi1UaWxlSW1hZ2VcIiBjb250ZW50PVwiL2ltYWdlcy9sb2dvL2Zhdmljb24ucG5nXCIvPlxyXG4gICAgICA8L0hlYWQ+XHJcbiAgICAgIDxib2R5IGNsYXNzTmFtZT1cImx0ciBsaWdodFwiPlxyXG4gICAgICAgIHsvKiDinIUgV3JhcCBhcHAgd2l0aCBBdXRoUHJvdmlkZXIgKi99XHJcbiAgICAgICAgPEF1dGhQcm92aWRlcj5cclxuICAgICAgICAgIHtjaGlsZHJlbn1cclxuICAgICAgICA8L0F1dGhQcm92aWRlcj5cclxuICAgICAgPC9ib2R5PlxyXG4gICAgICA8Qm9vdHN0cmFwQ2xpZW50IC8+XHJcbiAgICA8L2h0bWw+XHJcbiAgKTtcclxufVxyXG4iXSwibmFtZXMiOlsiQm9vdHN0cmFwQ2xpZW50IiwiSGVhZCIsIkF1dGhQcm92aWRlciIsIlJvb3RMYXlvdXQiLCJjaGlsZHJlbiIsImh0bWwiLCJsYW5nIiwibGluayIsInJlbCIsImhyZWYiLCJjcm9zc09yaWdpbiIsInR5cGUiLCJtZXRhIiwibmFtZSIsImNvbnRlbnQiLCJib2R5IiwiY2xhc3NOYW1lIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/layout.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/context/AuthContext.js":
/*!************************************!*\
  !*** ./src/context/AuthContext.js ***!
  \************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AuthProvider: () => (/* binding */ AuthProvider),\n/* harmony export */   useAuth: () => (/* binding */ useAuth)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _utils_supabaseClient__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/utils/supabaseClient */ \"(app-pages-browser)/./src/utils/supabaseClient.js\");\n/* __next_internal_client_entry_do_not_use__ AuthProvider,useAuth auto */ \nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\n\nconst AuthContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)();\nconst AuthProvider = (param)=>{\n    let { children } = param;\n    _s();\n    const [user, setUser] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null); // full profile from backend\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);\n    // Load profile on mount\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"AuthProvider.useEffect\": ()=>{\n            fetchProfile();\n        }\n    }[\"AuthProvider.useEffect\"], []);\n    // ...\n    const fetchProfile = async ()=>{\n        try {\n            const res = await fetch(\"/api/auth/me\", {\n                method: \"GET\",\n                credentials: \"include\"\n            });\n            if (res.ok) setUser(await res.json());\n            else setUser(null);\n        } catch (e) {\n            console.error(\"Profile fetch failed:\", e);\n            setUser(null);\n        } finally{\n            setLoading(false);\n        }\n    };\n    const login = async (email, password)=>{\n        setLoading(true);\n        try {\n            const res = await fetch(\"/api/auth/login\", {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify({\n                    email,\n                    password\n                }),\n                credentials: \"include\"\n            });\n            const data = await res.json();\n            if (!res.ok) throw new Error(data.detail || \"Login failed\");\n            await fetchProfile();\n            return true;\n        } catch (err) {\n            console.error(\"Login error:\", err);\n            throw err;\n        } finally{\n            setLoading(false);\n        }\n    };\n    const logout = async ()=>{\n        try {\n            await fetch(\"/api/auth/logout\", {\n                method: \"POST\",\n                credentials: \"include\"\n            });\n        } catch (e) {\n            console.error(\"Logout failed:\", e);\n        }\n        setUser(null);\n        window.location.href = \"/auth/login\";\n    };\n    const authedFetch = async function(url) {\n        let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n        let res = await fetch(url.startsWith(\"/\") ? url : \"/api\".concat(url), {\n            ...options,\n            credentials: \"include\"\n        });\n        if (res.status === 401) {\n            const refreshRes = await fetch(\"/api/auth/refresh\", {\n                method: \"POST\",\n                credentials: \"include\"\n            });\n            if (refreshRes.ok) {\n                res = await fetch(url.startsWith(\"/\") ? url : \"/api\".concat(url), {\n                    ...options,\n                    credentials: \"include\"\n                });\n            }\n        }\n        return res;\n    };\n    // Social login unchanged, but keep redirectTo same origin:\n    const socialLogin = async (provider)=>{\n        const { error } = await _utils_supabaseClient__WEBPACK_IMPORTED_MODULE_2__.supabase.auth.signInWithOAuth({\n            provider,\n            options: {\n                redirectTo: \"\".concat(window.location.origin, \"/auth/callback\")\n            }\n        });\n        if (error) throw error;\n    };\n    // ...\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(AuthContext.Provider, {\n        value: {\n            user,\n            loading,\n            login,\n            logout,\n            authedFetch,\n            fetchProfile,\n            socialLogin\n        },\n        children: children\n    }, void 0, false, {\n        fileName: \"D:\\\\next\\\\org\\\\src\\\\context\\\\AuthContext.js\",\n        lineNumber: 91,\n        columnNumber: 5\n    }, undefined);\n};\n_s(AuthProvider, \"NiO5z6JIqzX62LS5UWDgIqbZYyY=\");\n_c = AuthProvider;\nconst useAuth = ()=>{\n    _s1();\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(AuthContext);\n};\n_s1(useAuth, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\nvar _c;\n$RefreshReg$(_c, \"AuthProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb250ZXh0L0F1dGhDb250ZXh0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQzhFO0FBQzVCO0FBRWxELE1BQU1NLDRCQUFjTCxvREFBYUE7QUFFMUIsTUFBTU0sZUFBZTtRQUFDLEVBQUVDLFFBQVEsRUFBRTs7SUFDdkMsTUFBTSxDQUFDQyxNQUFNQyxRQUFRLEdBQUdOLCtDQUFRQSxDQUFDLE9BQVMsNEJBQTRCO0lBQ3RFLE1BQU0sQ0FBQ08sU0FBU0MsV0FBVyxHQUFHUiwrQ0FBUUEsQ0FBQztJQUV2Qyx3QkFBd0I7SUFDeEJELGdEQUFTQTtrQ0FBQztZQUNSVTtRQUNGO2lDQUFHLEVBQUU7SUFHTCxNQUFNO0lBQ1IsTUFBTUEsZUFBZTtRQUNuQixJQUFJO1lBQ0YsTUFBTUMsTUFBTSxNQUFNQyxNQUFPLGdCQUFlO2dCQUFFQyxRQUFRO2dCQUFPQyxhQUFhO1lBQVU7WUFDaEYsSUFBSUgsSUFBSUksRUFBRSxFQUFFUixRQUFRLE1BQU1JLElBQUlLLElBQUk7aUJBQzdCVCxRQUFRO1FBQ2YsRUFBRSxPQUFPVSxHQUFHO1lBQ1ZDLFFBQVFDLEtBQUssQ0FBQyx5QkFBeUJGO1lBQ3ZDVixRQUFRO1FBQ1YsU0FBVTtZQUNSRSxXQUFXO1FBQ2I7SUFDRjtJQUVBLE1BQU1XLFFBQVEsT0FBT0MsT0FBT0M7UUFDMUJiLFdBQVc7UUFDWCxJQUFJO1lBQ0YsTUFBTUUsTUFBTSxNQUFNQyxNQUFPLG1CQUFrQjtnQkFDekNDLFFBQVE7Z0JBQ1JVLFNBQVM7b0JBQUUsZ0JBQWdCO2dCQUFtQjtnQkFDOUNDLE1BQU1DLEtBQUtDLFNBQVMsQ0FBQztvQkFBRUw7b0JBQU9DO2dCQUFTO2dCQUN2Q1IsYUFBYTtZQUNmO1lBQ0EsTUFBTWEsT0FBTyxNQUFNaEIsSUFBSUssSUFBSTtZQUMzQixJQUFJLENBQUNMLElBQUlJLEVBQUUsRUFBRSxNQUFNLElBQUlhLE1BQU1ELEtBQUtFLE1BQU0sSUFBSTtZQUM1QyxNQUFNbkI7WUFDTixPQUFPO1FBQ1QsRUFBRSxPQUFPb0IsS0FBSztZQUNaWixRQUFRQyxLQUFLLENBQUMsZ0JBQWdCVztZQUM5QixNQUFNQTtRQUNSLFNBQVU7WUFDUnJCLFdBQVc7UUFDYjtJQUNGO0lBRUEsTUFBTXNCLFNBQVM7UUFDYixJQUFJO1lBQ0YsTUFBTW5CLE1BQU8sb0JBQW1CO2dCQUFFQyxRQUFRO2dCQUFRQyxhQUFhO1lBQVU7UUFDM0UsRUFBRSxPQUFPRyxHQUFHO1lBQ1ZDLFFBQVFDLEtBQUssQ0FBQyxrQkFBa0JGO1FBQ2xDO1FBQ0FWLFFBQVE7UUFDUnlCLE9BQU9DLFFBQVEsQ0FBQ0MsSUFBSSxHQUFHO0lBQ3pCO0lBRUEsTUFBTUMsY0FBYyxlQUFPQztZQUFLQywyRUFBVSxDQUFDO1FBQ3pDLElBQUkxQixNQUFNLE1BQU1DLE1BQU13QixJQUFJRSxVQUFVLENBQUMsT0FBT0YsTUFBTSxPQUFXLE9BQUpBLE1BQU87WUFDOUQsR0FBR0MsT0FBTztZQUNWdkIsYUFBYTtRQUNmO1FBQ0EsSUFBSUgsSUFBSTRCLE1BQU0sS0FBSyxLQUFLO1lBQ3RCLE1BQU1DLGFBQWEsTUFBTTVCLE1BQU8scUJBQW9CO2dCQUFFQyxRQUFRO2dCQUFRQyxhQUFhO1lBQVU7WUFDN0YsSUFBSTBCLFdBQVd6QixFQUFFLEVBQUU7Z0JBQ2pCSixNQUFNLE1BQU1DLE1BQU13QixJQUFJRSxVQUFVLENBQUMsT0FBT0YsTUFBTSxPQUFXLE9BQUpBLE1BQU87b0JBQzFELEdBQUdDLE9BQU87b0JBQ1Z2QixhQUFhO2dCQUNmO1lBQ0Y7UUFDRjtRQUNBLE9BQU9IO0lBQ1Q7SUFFQSwyREFBMkQ7SUFDM0QsTUFBTThCLGNBQWMsT0FBT0M7UUFDekIsTUFBTSxFQUFFdkIsS0FBSyxFQUFFLEdBQUcsTUFBTWpCLDJEQUFRQSxDQUFDeUMsSUFBSSxDQUFDQyxlQUFlLENBQUM7WUFDcERGO1lBQ0FMLFNBQVM7Z0JBQUVRLFlBQVksR0FBMEIsT0FBdkJiLE9BQU9DLFFBQVEsQ0FBQ2EsTUFBTSxFQUFDO1lBQWdCO1FBQ25FO1FBQ0EsSUFBSTNCLE9BQU8sTUFBTUE7SUFDbkI7SUFDQSxNQUFNO0lBR0oscUJBQ0UsOERBQUNoQixZQUFZNEMsUUFBUTtRQUNuQkMsT0FBTztZQUNMMUM7WUFDQUU7WUFDQVk7WUFDQVc7WUFDQUk7WUFDQXpCO1lBQ0ErQjtRQUNGO2tCQUVDcEM7Ozs7OztBQUdQLEVBQUU7R0FsR1dEO0tBQUFBO0FBb0dOLE1BQU02QyxVQUFVOztJQUFNbEQsT0FBQUEsaURBQVVBLENBQUNJO0FBQVcsRUFBRTtJQUF4QzhDIiwic291cmNlcyI6WyJEOlxcbmV4dFxcb3JnXFxzcmNcXGNvbnRleHRcXEF1dGhDb250ZXh0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiO1xyXG5pbXBvcnQgUmVhY3QsIHsgY3JlYXRlQ29udGV4dCwgdXNlQ29udGV4dCwgdXNlRWZmZWN0LCB1c2VTdGF0ZSB9IGZyb20gXCJyZWFjdFwiO1xyXG5pbXBvcnQgeyBzdXBhYmFzZSB9IGZyb20gXCJAL3V0aWxzL3N1cGFiYXNlQ2xpZW50XCI7XHJcblxyXG5jb25zdCBBdXRoQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQoKTtcclxuXHJcbmV4cG9ydCBjb25zdCBBdXRoUHJvdmlkZXIgPSAoeyBjaGlsZHJlbiB9KSA9PiB7XHJcbiAgY29uc3QgW3VzZXIsIHNldFVzZXJdID0gdXNlU3RhdGUobnVsbCk7ICAgLy8gZnVsbCBwcm9maWxlIGZyb20gYmFja2VuZFxyXG4gIGNvbnN0IFtsb2FkaW5nLCBzZXRMb2FkaW5nXSA9IHVzZVN0YXRlKHRydWUpO1xyXG5cclxuICAvLyBMb2FkIHByb2ZpbGUgb24gbW91bnRcclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgZmV0Y2hQcm9maWxlKCk7XHJcbiAgfSwgW10pO1xyXG5cclxuXHJcbiAgLy8gLi4uXHJcbmNvbnN0IGZldGNoUHJvZmlsZSA9IGFzeW5jICgpID0+IHtcclxuICB0cnkge1xyXG4gICAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2goYC9hcGkvYXV0aC9tZWAsIHsgbWV0aG9kOiBcIkdFVFwiLCBjcmVkZW50aWFsczogXCJpbmNsdWRlXCIgfSk7XHJcbiAgICBpZiAocmVzLm9rKSBzZXRVc2VyKGF3YWl0IHJlcy5qc29uKCkpO1xyXG4gICAgZWxzZSBzZXRVc2VyKG51bGwpO1xyXG4gIH0gY2F0Y2ggKGUpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoXCJQcm9maWxlIGZldGNoIGZhaWxlZDpcIiwgZSk7XHJcbiAgICBzZXRVc2VyKG51bGwpO1xyXG4gIH0gZmluYWxseSB7XHJcbiAgICBzZXRMb2FkaW5nKGZhbHNlKTtcclxuICB9XHJcbn07XHJcblxyXG5jb25zdCBsb2dpbiA9IGFzeW5jIChlbWFpbCwgcGFzc3dvcmQpID0+IHtcclxuICBzZXRMb2FkaW5nKHRydWUpO1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaChgL2FwaS9hdXRoL2xvZ2luYCwge1xyXG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxyXG4gICAgICBoZWFkZXJzOiB7IFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0sXHJcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgZW1haWwsIHBhc3N3b3JkIH0pLFxyXG4gICAgICBjcmVkZW50aWFsczogXCJpbmNsdWRlXCIsXHJcbiAgICB9KTtcclxuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXMuanNvbigpO1xyXG4gICAgaWYgKCFyZXMub2spIHRocm93IG5ldyBFcnJvcihkYXRhLmRldGFpbCB8fCBcIkxvZ2luIGZhaWxlZFwiKTtcclxuICAgIGF3YWl0IGZldGNoUHJvZmlsZSgpO1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKFwiTG9naW4gZXJyb3I6XCIsIGVycik7XHJcbiAgICB0aHJvdyBlcnI7XHJcbiAgfSBmaW5hbGx5IHtcclxuICAgIHNldExvYWRpbmcoZmFsc2UpO1xyXG4gIH1cclxufTtcclxuXHJcbmNvbnN0IGxvZ291dCA9IGFzeW5jICgpID0+IHtcclxuICB0cnkge1xyXG4gICAgYXdhaXQgZmV0Y2goYC9hcGkvYXV0aC9sb2dvdXRgLCB7IG1ldGhvZDogXCJQT1NUXCIsIGNyZWRlbnRpYWxzOiBcImluY2x1ZGVcIiB9KTtcclxuICB9IGNhdGNoIChlKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKFwiTG9nb3V0IGZhaWxlZDpcIiwgZSk7XHJcbiAgfVxyXG4gIHNldFVzZXIobnVsbCk7XHJcbiAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSBcIi9hdXRoL2xvZ2luXCI7XHJcbn07XHJcblxyXG5jb25zdCBhdXRoZWRGZXRjaCA9IGFzeW5jICh1cmwsIG9wdGlvbnMgPSB7fSkgPT4ge1xyXG4gIGxldCByZXMgPSBhd2FpdCBmZXRjaCh1cmwuc3RhcnRzV2l0aChcIi9cIikgPyB1cmwgOiBgL2FwaSR7dXJsfWAsIHtcclxuICAgIC4uLm9wdGlvbnMsXHJcbiAgICBjcmVkZW50aWFsczogXCJpbmNsdWRlXCIsXHJcbiAgfSk7XHJcbiAgaWYgKHJlcy5zdGF0dXMgPT09IDQwMSkge1xyXG4gICAgY29uc3QgcmVmcmVzaFJlcyA9IGF3YWl0IGZldGNoKGAvYXBpL2F1dGgvcmVmcmVzaGAsIHsgbWV0aG9kOiBcIlBPU1RcIiwgY3JlZGVudGlhbHM6IFwiaW5jbHVkZVwiIH0pO1xyXG4gICAgaWYgKHJlZnJlc2hSZXMub2spIHtcclxuICAgICAgcmVzID0gYXdhaXQgZmV0Y2godXJsLnN0YXJ0c1dpdGgoXCIvXCIpID8gdXJsIDogYC9hcGkke3VybH1gLCB7XHJcbiAgICAgICAgLi4ub3B0aW9ucyxcclxuICAgICAgICBjcmVkZW50aWFsczogXCJpbmNsdWRlXCIsXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gcmVzO1xyXG59O1xyXG5cclxuLy8gU29jaWFsIGxvZ2luIHVuY2hhbmdlZCwgYnV0IGtlZXAgcmVkaXJlY3RUbyBzYW1lIG9yaWdpbjpcclxuY29uc3Qgc29jaWFsTG9naW4gPSBhc3luYyAocHJvdmlkZXIpID0+IHtcclxuICBjb25zdCB7IGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZS5hdXRoLnNpZ25JbldpdGhPQXV0aCh7XHJcbiAgICBwcm92aWRlcixcclxuICAgIG9wdGlvbnM6IHsgcmVkaXJlY3RUbzogYCR7d2luZG93LmxvY2F0aW9uLm9yaWdpbn0vYXV0aC9jYWxsYmFja2AgfSxcclxuICB9KTtcclxuICBpZiAoZXJyb3IpIHRocm93IGVycm9yO1xyXG59O1xyXG4vLyAuLi5cclxuXHJcblxyXG4gIHJldHVybiAoXHJcbiAgICA8QXV0aENvbnRleHQuUHJvdmlkZXJcclxuICAgICAgdmFsdWU9e3tcclxuICAgICAgICB1c2VyLCAgICAgICAgLy8gZnVsbCBwcm9maWxlIGZyb20gL2F1dGgvbWVcclxuICAgICAgICBsb2FkaW5nLFxyXG4gICAgICAgIGxvZ2luLFxyXG4gICAgICAgIGxvZ291dCxcclxuICAgICAgICBhdXRoZWRGZXRjaCxcclxuICAgICAgICBmZXRjaFByb2ZpbGUsXHJcbiAgICAgICAgc29jaWFsTG9naW4sIC8vIDwtIG5ld1xyXG4gICAgICB9fVxyXG4gICAgPlxyXG4gICAgICB7Y2hpbGRyZW59XHJcbiAgICA8L0F1dGhDb250ZXh0LlByb3ZpZGVyPlxyXG4gICk7XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgdXNlQXV0aCA9ICgpID0+IHVzZUNvbnRleHQoQXV0aENvbnRleHQpO1xyXG4iXSwibmFtZXMiOlsiUmVhY3QiLCJjcmVhdGVDb250ZXh0IiwidXNlQ29udGV4dCIsInVzZUVmZmVjdCIsInVzZVN0YXRlIiwic3VwYWJhc2UiLCJBdXRoQ29udGV4dCIsIkF1dGhQcm92aWRlciIsImNoaWxkcmVuIiwidXNlciIsInNldFVzZXIiLCJsb2FkaW5nIiwic2V0TG9hZGluZyIsImZldGNoUHJvZmlsZSIsInJlcyIsImZldGNoIiwibWV0aG9kIiwiY3JlZGVudGlhbHMiLCJvayIsImpzb24iLCJlIiwiY29uc29sZSIsImVycm9yIiwibG9naW4iLCJlbWFpbCIsInBhc3N3b3JkIiwiaGVhZGVycyIsImJvZHkiLCJKU09OIiwic3RyaW5naWZ5IiwiZGF0YSIsIkVycm9yIiwiZGV0YWlsIiwiZXJyIiwibG9nb3V0Iiwid2luZG93IiwibG9jYXRpb24iLCJocmVmIiwiYXV0aGVkRmV0Y2giLCJ1cmwiLCJvcHRpb25zIiwic3RhcnRzV2l0aCIsInN0YXR1cyIsInJlZnJlc2hSZXMiLCJzb2NpYWxMb2dpbiIsInByb3ZpZGVyIiwiYXV0aCIsInNpZ25JbldpdGhPQXV0aCIsInJlZGlyZWN0VG8iLCJvcmlnaW4iLCJQcm92aWRlciIsInZhbHVlIiwidXNlQXV0aCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/context/AuthContext.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/scss/responsive.scss":
/*!**********************************!*\
  !*** ./src/scss/responsive.scss ***!
  \**********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"a0c806817445\");\nif (true) { module.hot.accept() }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zY3NzL3Jlc3BvbnNpdmUuc2NzcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsaUVBQWUsY0FBYztBQUM3QixJQUFJLElBQVUsSUFBSSxpQkFBaUIiLCJzb3VyY2VzIjpbIkQ6XFxuZXh0XFxvcmdcXHNyY1xcc2Nzc1xccmVzcG9uc2l2ZS5zY3NzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IFwiYTBjODA2ODE3NDQ1XCJcbmlmIChtb2R1bGUuaG90KSB7IG1vZHVsZS5ob3QuYWNjZXB0KCkgfVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/scss/responsive.scss\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/scss/style.scss":
/*!*****************************!*\
  !*** ./src/scss/style.scss ***!
  \*****************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"0f2c47bdef0e\");\nif (true) { module.hot.accept() }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zY3NzL3N0eWxlLnNjc3MiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLGlFQUFlLGNBQWM7QUFDN0IsSUFBSSxJQUFVLElBQUksaUJBQWlCIiwic291cmNlcyI6WyJEOlxcbmV4dFxcb3JnXFxzcmNcXHNjc3NcXHN0eWxlLnNjc3MiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgXCIwZjJjNDdiZGVmMGVcIlxuaWYgKG1vZHVsZS5ob3QpIHsgbW9kdWxlLmhvdC5hY2NlcHQoKSB9XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/scss/style.scss\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/utils/Bootstrap/BootstrapClient.js":
/*!************************************************!*\
  !*** ./src/utils/Bootstrap/BootstrapClient.js ***!
  \************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* __next_internal_client_entry_do_not_use__ default auto */ var _s = $RefreshSig$();\n\nconst BootstrapClient = ()=>{\n    _s();\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"BootstrapClient.useEffect\": ()=>{\n            __webpack_require__.e(/*! import() */ \"_app-pages-browser_src_vendor_bootstrap_bootstrap_bundle_min_js\").then(__webpack_require__.t.bind(__webpack_require__, /*! ../../vendor/bootstrap/bootstrap.bundle.min.js */ \"(app-pages-browser)/./src/vendor/bootstrap/bootstrap.bundle.min.js\", 23));\n            __webpack_require__.e(/*! import() */ \"_app-pages-browser_src_vendor_vector-map_jquery-jvectormap-2_0_5_min_js\").then(__webpack_require__.t.bind(__webpack_require__, /*! ../../vendor/vector-map/jquery-jvectormap-2.0.5.min */ \"(app-pages-browser)/./src/vendor/vector-map/jquery-jvectormap-2.0.5.min.js\", 23));\n            __webpack_require__.e(/*! import() */ \"_app-pages-browser_src_vendor_datatable_jquery_dataTables_min_js\").then(__webpack_require__.t.bind(__webpack_require__, /*! ../../vendor/datatable/jquery.dataTables.min.js */ \"(app-pages-browser)/./src/vendor/datatable/jquery.dataTables.min.js\", 23));\n            __webpack_require__.e(/*! import() */ \"_app-pages-browser_src_vendor_trumbowyg_trumbowyg_min_js\").then(__webpack_require__.t.bind(__webpack_require__, /*! ../../vendor/trumbowyg/trumbowyg.min */ \"(app-pages-browser)/./src/vendor/trumbowyg/trumbowyg.min.js\", 23));\n            __webpack_require__.e(/*! import() */ \"_app-pages-browser_src_vendor_listJs_list-jquery_min_js\").then(__webpack_require__.t.bind(__webpack_require__, /*! ../../vendor/listJs/list-jquery.min */ \"(app-pages-browser)/./src/vendor/listJs/list-jquery.min.js\", 23));\n            __webpack_require__.e(/*! import() */ \"_app-pages-browser_src_vendor_listJs_list_min_js\").then(__webpack_require__.t.bind(__webpack_require__, /*! ../../vendor/listJs/list.min */ \"(app-pages-browser)/./src/vendor/listJs/list.min.js\", 23));\n            setTimeout({\n                \"BootstrapClient.useEffect\": ()=>{\n                    __webpack_require__.e(/*! import() */ \"_app-pages-browser_src_vendor_vector-map_jquery-jvectormap-world-mill_js\").then(__webpack_require__.t.bind(__webpack_require__, /*! ../../vendor/vector-map/jquery-jvectormap-world-mill */ \"(app-pages-browser)/./src/vendor/vector-map/jquery-jvectormap-world-mill.js\", 23));\n                    __webpack_require__.e(/*! import() */ \"_app-pages-browser_src_vendor_vector-map_africa-mill_js\").then(__webpack_require__.t.bind(__webpack_require__, /*! ../../vendor/vector-map/africa-mill */ \"(app-pages-browser)/./src/vendor/vector-map/africa-mill.js\", 23));\n                    __webpack_require__.e(/*! import() */ \"_app-pages-browser_src_vendor_vector-map_asia-mill_js\").then(__webpack_require__.t.bind(__webpack_require__, /*! ../../vendor/vector-map/asia-mill */ \"(app-pages-browser)/./src/vendor/vector-map/asia-mill.js\", 23));\n                    __webpack_require__.e(/*! import() */ \"_app-pages-browser_src_vendor_vector-map_ru-mill_js\").then(__webpack_require__.t.bind(__webpack_require__, /*! ../../vendor/vector-map/ru-mill */ \"(app-pages-browser)/./src/vendor/vector-map/ru-mill.js\", 23));\n                    __webpack_require__.e(/*! import() */ \"_app-pages-browser_src_vendor_vector-map_europe-mill_js\").then(__webpack_require__.t.bind(__webpack_require__, /*! ../../vendor/vector-map/europe-mill */ \"(app-pages-browser)/./src/vendor/vector-map/europe-mill.js\", 23));\n                    __webpack_require__.e(/*! import() */ \"_app-pages-browser_src_vendor_vector-map_jquery-jvectormap-us-lcc_js\").then(__webpack_require__.t.bind(__webpack_require__, /*! ../../vendor/vector-map/jquery-jvectormap-us-lcc */ \"(app-pages-browser)/./src/vendor/vector-map/jquery-jvectormap-us-lcc.js\", 23));\n                    __webpack_require__.e(/*! import() */ \"_app-pages-browser_src_vendor_vector-map_uk_countries-mill_js\").then(__webpack_require__.t.bind(__webpack_require__, /*! ../../vendor/vector-map/uk_countries-mill */ \"(app-pages-browser)/./src/vendor/vector-map/uk_countries-mill.js\", 23));\n                    __webpack_require__.e(/*! import() */ \"_app-pages-browser_src_vendor_vector-map_jvectormap-es-mill_js\").then(__webpack_require__.t.bind(__webpack_require__, /*! ../../vendor/vector-map/jvectormap-es-mill */ \"(app-pages-browser)/./src/vendor/vector-map/jvectormap-es-mill.js\", 23));\n                }\n            }[\"BootstrapClient.useEffect\"], 500);\n            __webpack_require__.e(/*! import() */ \"_app-pages-browser_src_vendor_select_select2_min_js\").then(__webpack_require__.t.bind(__webpack_require__, /*! ../../vendor/select/select2.min.js */ \"(app-pages-browser)/./src/vendor/select/select2.min.js\", 23));\n            __webpack_require__.e(/*! import() */ \"_app-pages-browser_src_vendor_phosphor_phosphor_js\").then(__webpack_require__.t.bind(__webpack_require__, /*! ../../vendor/phosphor/phosphor.js */ \"(app-pages-browser)/./src/vendor/phosphor/phosphor.js\", 23));\n            __webpack_require__.e(/*! import() */ \"_app-pages-browser_src_vendor_animated_icon_iconify-icon_min_js\").then(__webpack_require__.t.bind(__webpack_require__, /*! ../../vendor/animated_icon/iconify-icon.min */ \"(app-pages-browser)/./src/vendor/animated_icon/iconify-icon.min.js\", 23));\n            __webpack_require__.e(/*! import() */ \"_app-pages-browser_src_vendor_block-ui_jquery_blockUI_js\").then(__webpack_require__.t.bind(__webpack_require__, /*! ../../vendor/block-ui/jquery.blockUI */ \"(app-pages-browser)/./src/vendor/block-ui/jquery.blockUI.js\", 23));\n            __webpack_require__.e(/*! import() */ \"_app-pages-browser_src_vendor_dual_listboxes_dual-listbox_js\").then(__webpack_require__.t.bind(__webpack_require__, /*! ../../vendor/dual_listboxes/dual-listbox */ \"(app-pages-browser)/./src/vendor/dual_listboxes/dual-listbox.js\", 23));\n            __webpack_require__.e(/*! import() */ \"_app-pages-browser_src_vendor_googlemap_gmaps_js\").then(__webpack_require__.t.bind(__webpack_require__, /*! ../../vendor/googlemap/gmaps */ \"(app-pages-browser)/./src/vendor/googlemap/gmaps.js\", 23));\n            __webpack_require__.e(/*! import() */ \"_app-pages-browser_src_vendor_googlemap_google_js\").then(__webpack_require__.bind(__webpack_require__, /*! ../../vendor/googlemap/google */ \"(app-pages-browser)/./src/vendor/googlemap/google.js\"));\n            __webpack_require__.e(/*! import() */ \"_app-pages-browser_src_components_Forms_Elements_Dual_List_Boxes_initDataListBox_js\").then(__webpack_require__.bind(__webpack_require__, /*! ../../components/Forms_Elements/Dual_List_Boxes/initDataListBox */ \"(app-pages-browser)/./src/components/Forms_Elements/Dual_List_Boxes/initDataListBox.js\"));\n            __webpack_require__.e(/*! import() */ \"_app-pages-browser_src_utils_CommonJs_index_js\").then(__webpack_require__.t.bind(__webpack_require__, /*! ../CommonJs/index */ \"(app-pages-browser)/./src/utils/CommonJs/index.js\", 23));\n        }\n    }[\"BootstrapClient.useEffect\"], []);\n    return null;\n};\n_s(BootstrapClient, \"OD7bBpZva5O2jO+Puf00hKivP7c=\");\n_c = BootstrapClient;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (BootstrapClient);\nvar _c;\n$RefreshReg$(_c, \"BootstrapClient\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy91dGlscy9Cb290c3RyYXAvQm9vdHN0cmFwQ2xpZW50LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFFa0M7QUFFbEMsTUFBTUMsa0JBQWtCOztJQUNwQkQsZ0RBQVNBO3FDQUFDO1lBQ04sOFJBQXdEO1lBQ3hELG1UQUE2RDtZQUM3RCxpU0FBeUQ7WUFDekQsc1FBQThDO1lBQzlDLG1RQUE2QztZQUM3Qyw4T0FBc0M7WUFDdENFOzZDQUFXO29CQUNQLHNUQUE4RDtvQkFDOUQsbVFBQTZDO29CQUM3Qyw2UEFBMkM7b0JBQzNDLHVQQUF5QztvQkFDekMsbVFBQTZDO29CQUM3QywwU0FBMEQ7b0JBQzFELHFSQUFtRDtvQkFDbkQsd1JBQW9EO2dCQUN4RDs0Q0FBRztZQUNILDBQQUE0QztZQUM1Qyx1UEFBMkM7WUFDM0MsMlJBQXFEO1lBQ3JELHNRQUE4QztZQUM5QyxrUkFBa0Q7WUFDbEQsOE9BQXNDO1lBQ3RDLDJPQUF1QztZQUN2QyxpVkFBeUU7WUFDekUsK05BQTJCO1FBQy9CO29DQUFHLEVBQUU7SUFFTCxPQUFPO0FBQ1g7R0E5Qk1EO0tBQUFBO0FBZ0NOLGlFQUFlQSxlQUFlQSxFQUFDIiwic291cmNlcyI6WyJEOlxcbmV4dFxcb3JnXFxzcmNcXHV0aWxzXFxCb290c3RyYXBcXEJvb3RzdHJhcENsaWVudC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIjtcclxuXHJcbmltcG9ydCB7IHVzZUVmZmVjdCB9IGZyb20gXCJyZWFjdFwiO1xyXG5cclxuY29uc3QgQm9vdHN0cmFwQ2xpZW50ID0gKCkgPT4ge1xyXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICBpbXBvcnQoXCIuLi8uLi92ZW5kb3IvYm9vdHN0cmFwL2Jvb3RzdHJhcC5idW5kbGUubWluLmpzXCIpO1xyXG4gICAgICAgIGltcG9ydCgnLi4vLi4vdmVuZG9yL3ZlY3Rvci1tYXAvanF1ZXJ5LWp2ZWN0b3JtYXAtMi4wLjUubWluJyk7XHJcbiAgICAgICAgaW1wb3J0KFwiLi4vLi4vdmVuZG9yL2RhdGF0YWJsZS9qcXVlcnkuZGF0YVRhYmxlcy5taW4uanNcIik7XHJcbiAgICAgICAgaW1wb3J0KFwiLi4vLi4vdmVuZG9yL3RydW1ib3d5Zy90cnVtYm93eWcubWluXCIpO1xyXG4gICAgICAgIGltcG9ydChcIi4uLy4uL3ZlbmRvci9saXN0SnMvbGlzdC1qcXVlcnkubWluXCIpO1xyXG4gICAgICAgIGltcG9ydChcIi4uLy4uL3ZlbmRvci9saXN0SnMvbGlzdC5taW5cIik7XHJcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgIGltcG9ydCgnLi4vLi4vdmVuZG9yL3ZlY3Rvci1tYXAvanF1ZXJ5LWp2ZWN0b3JtYXAtd29ybGQtbWlsbCcpO1xyXG4gICAgICAgICAgICBpbXBvcnQoJy4uLy4uL3ZlbmRvci92ZWN0b3ItbWFwL2FmcmljYS1taWxsJyk7XHJcbiAgICAgICAgICAgIGltcG9ydCgnLi4vLi4vdmVuZG9yL3ZlY3Rvci1tYXAvYXNpYS1taWxsJyk7XHJcbiAgICAgICAgICAgIGltcG9ydCgnLi4vLi4vdmVuZG9yL3ZlY3Rvci1tYXAvcnUtbWlsbCcpO1xyXG4gICAgICAgICAgICBpbXBvcnQoJy4uLy4uL3ZlbmRvci92ZWN0b3ItbWFwL2V1cm9wZS1taWxsJyk7XHJcbiAgICAgICAgICAgIGltcG9ydCgnLi4vLi4vdmVuZG9yL3ZlY3Rvci1tYXAvanF1ZXJ5LWp2ZWN0b3JtYXAtdXMtbGNjJyk7XHJcbiAgICAgICAgICAgIGltcG9ydCgnLi4vLi4vdmVuZG9yL3ZlY3Rvci1tYXAvdWtfY291bnRyaWVzLW1pbGwnKTtcclxuICAgICAgICAgICAgaW1wb3J0KCcuLi8uLi92ZW5kb3IvdmVjdG9yLW1hcC9qdmVjdG9ybWFwLWVzLW1pbGwnKTtcclxuICAgICAgICB9LCA1MDApXHJcbiAgICAgICAgaW1wb3J0KFwiLi4vLi4vdmVuZG9yL3NlbGVjdC9zZWxlY3QyLm1pbi5qc1wiKTtcclxuICAgICAgICBpbXBvcnQoXCIuLi8uLi92ZW5kb3IvcGhvc3Bob3IvcGhvc3Bob3IuanNcIik7XHJcbiAgICAgICAgaW1wb3J0KFwiLi4vLi4vdmVuZG9yL2FuaW1hdGVkX2ljb24vaWNvbmlmeS1pY29uLm1pblwiKTtcclxuICAgICAgICBpbXBvcnQoJy4uLy4uL3ZlbmRvci9ibG9jay11aS9qcXVlcnkuYmxvY2tVSScpO1xyXG4gICAgICAgIGltcG9ydCgnLi4vLi4vdmVuZG9yL2R1YWxfbGlzdGJveGVzL2R1YWwtbGlzdGJveCcpO1xyXG4gICAgICAgIGltcG9ydCgnLi4vLi4vdmVuZG9yL2dvb2dsZW1hcC9nbWFwcycpO1xyXG4gICAgICAgIGltcG9ydCgnLi4vLi4vdmVuZG9yL2dvb2dsZW1hcC9nb29nbGUnKTtcclxuICAgICAgICBpbXBvcnQoXCIuLi8uLi9jb21wb25lbnRzL0Zvcm1zX0VsZW1lbnRzL0R1YWxfTGlzdF9Cb3hlcy9pbml0RGF0YUxpc3RCb3hcIik7XHJcbiAgICAgICAgaW1wb3J0KFwiLi4vQ29tbW9uSnMvaW5kZXhcIilcclxuICAgIH0sIFtdKTtcclxuXHJcbiAgICByZXR1cm4gbnVsbDtcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IEJvb3RzdHJhcENsaWVudDsiXSwibmFtZXMiOlsidXNlRWZmZWN0IiwiQm9vdHN0cmFwQ2xpZW50Iiwic2V0VGltZW91dCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/utils/Bootstrap/BootstrapClient.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/utils/supabaseClient.js":
/*!*************************************!*\
  !*** ./src/utils/supabaseClient.js ***!
  \*************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   supabase: () => (/* binding */ supabase)\n/* harmony export */ });\n/* harmony import */ var _supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @supabase/supabase-js */ \"(app-pages-browser)/./node_modules/@supabase/supabase-js/dist/module/index.js\");\n\nconst supabase = (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__.createClient)(\"https://fazmwdhhessljlyxndee.supabase.co\", \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImZhem13ZGhoZXNzbGpseXhuZGVlIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTgyNjUyNzcsImV4cCI6MjA3Mzg0MTI3N30.eqb4M8SnT6HA0wL2Kr3DPCLOAeERkDo86xwX1XMtxSs\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy91dGlscy9zdXBhYmFzZUNsaWVudC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFxRDtBQUU5QyxNQUFNQyxXQUFXRCxtRUFBWUEsQ0FDbENFLDBDQUFvQyxFQUNwQ0Esa05BQXlDLEVBQ3pDIiwic291cmNlcyI6WyJEOlxcbmV4dFxcb3JnXFxzcmNcXHV0aWxzXFxzdXBhYmFzZUNsaWVudC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjcmVhdGVDbGllbnQgfSBmcm9tIFwiQHN1cGFiYXNlL3N1cGFiYXNlLWpzXCI7XHJcblxyXG5leHBvcnQgY29uc3Qgc3VwYWJhc2UgPSBjcmVhdGVDbGllbnQoXHJcbiAgcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfU1VQQUJBU0VfVVJMLFxyXG4gIHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1NVUEFCQVNFX0FOT05fS0VZXHJcbik7XHJcbiJdLCJuYW1lcyI6WyJjcmVhdGVDbGllbnQiLCJzdXBhYmFzZSIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19TVVBBQkFTRV9VUkwiLCJORVhUX1BVQkxJQ19TVVBBQkFTRV9BTk9OX0tFWSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/utils/supabaseClient.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/vendor/animated_icon/mdi-light.css":
/*!************************************************!*\
  !*** ./src/vendor/animated_icon/mdi-light.css ***!
  \************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"c0e63ae90b1a\");\nif (true) { module.hot.accept() }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy92ZW5kb3IvYW5pbWF0ZWRfaWNvbi9tZGktbGlnaHQuY3NzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxpRUFBZSxjQUFjO0FBQzdCLElBQUksSUFBVSxJQUFJLGlCQUFpQiIsInNvdXJjZXMiOlsiRDpcXG5leHRcXG9yZ1xcc3JjXFx2ZW5kb3JcXGFuaW1hdGVkX2ljb25cXG1kaS1saWdodC5jc3MiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgXCJjMGU2M2FlOTBiMWFcIlxuaWYgKG1vZHVsZS5ob3QpIHsgbW9kdWxlLmhvdC5hY2NlcHQoKSB9XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/vendor/animated_icon/mdi-light.css\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/vendor/animation/animate.min.css":
/*!**********************************************!*\
  !*** ./src/vendor/animation/animate.min.css ***!
  \**********************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"d2e2266997eb\");\nif (true) { module.hot.accept() }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy92ZW5kb3IvYW5pbWF0aW9uL2FuaW1hdGUubWluLmNzcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsaUVBQWUsY0FBYztBQUM3QixJQUFJLElBQVUsSUFBSSxpQkFBaUIiLCJzb3VyY2VzIjpbIkQ6XFxuZXh0XFxvcmdcXHNyY1xcdmVuZG9yXFxhbmltYXRpb25cXGFuaW1hdGUubWluLmNzcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBcImQyZTIyNjY5OTdlYlwiXG5pZiAobW9kdWxlLmhvdCkgeyBtb2R1bGUuaG90LmFjY2VwdCgpIH1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/vendor/animation/animate.min.css\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/vendor/datatable/datatable2/buttons.dataTables.min.css":
/*!********************************************************************!*\
  !*** ./src/vendor/datatable/datatable2/buttons.dataTables.min.css ***!
  \********************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"cf9a8e781a10\");\nif (true) { module.hot.accept() }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy92ZW5kb3IvZGF0YXRhYmxlL2RhdGF0YWJsZTIvYnV0dG9ucy5kYXRhVGFibGVzLm1pbi5jc3MiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLGlFQUFlLGNBQWM7QUFDN0IsSUFBSSxJQUFVLElBQUksaUJBQWlCIiwic291cmNlcyI6WyJEOlxcbmV4dFxcb3JnXFxzcmNcXHZlbmRvclxcZGF0YXRhYmxlXFxkYXRhdGFibGUyXFxidXR0b25zLmRhdGFUYWJsZXMubWluLmNzcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBcImNmOWE4ZTc4MWExMFwiXG5pZiAobW9kdWxlLmhvdCkgeyBtb2R1bGUuaG90LmFjY2VwdCgpIH1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/vendor/datatable/datatable2/buttons.dataTables.min.css\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/vendor/datatable/jquery.dataTables.min.css":
/*!********************************************************!*\
  !*** ./src/vendor/datatable/jquery.dataTables.min.css ***!
  \********************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"87552ac84e82\");\nif (true) { module.hot.accept() }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy92ZW5kb3IvZGF0YXRhYmxlL2pxdWVyeS5kYXRhVGFibGVzLm1pbi5jc3MiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLGlFQUFlLGNBQWM7QUFDN0IsSUFBSSxJQUFVLElBQUksaUJBQWlCIiwic291cmNlcyI6WyJEOlxcbmV4dFxcb3JnXFxzcmNcXHZlbmRvclxcZGF0YXRhYmxlXFxqcXVlcnkuZGF0YVRhYmxlcy5taW4uY3NzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IFwiODc1NTJhYzg0ZTgyXCJcbmlmIChtb2R1bGUuaG90KSB7IG1vZHVsZS5ob3QuYWNjZXB0KCkgfVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/vendor/datatable/jquery.dataTables.min.css\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/vendor/datepikar/flatpickr.min.css":
/*!************************************************!*\
  !*** ./src/vendor/datepikar/flatpickr.min.css ***!
  \************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"01d2d2b2de62\");\nif (true) { module.hot.accept() }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy92ZW5kb3IvZGF0ZXBpa2FyL2ZsYXRwaWNrci5taW4uY3NzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxpRUFBZSxjQUFjO0FBQzdCLElBQUksSUFBVSxJQUFJLGlCQUFpQiIsInNvdXJjZXMiOlsiRDpcXG5leHRcXG9yZ1xcc3JjXFx2ZW5kb3JcXGRhdGVwaWthclxcZmxhdHBpY2tyLm1pbi5jc3MiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgXCIwMWQyZDJiMmRlNjJcIlxuaWYgKG1vZHVsZS5ob3QpIHsgbW9kdWxlLmhvdC5hY2NlcHQoKSB9XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/vendor/datepikar/flatpickr.min.css\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/vendor/dual_listboxes/dual-listbox.css":
/*!****************************************************!*\
  !*** ./src/vendor/dual_listboxes/dual-listbox.css ***!
  \****************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"103f340b1465\");\nif (true) { module.hot.accept() }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy92ZW5kb3IvZHVhbF9saXN0Ym94ZXMvZHVhbC1saXN0Ym94LmNzcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsaUVBQWUsY0FBYztBQUM3QixJQUFJLElBQVUsSUFBSSxpQkFBaUIiLCJzb3VyY2VzIjpbIkQ6XFxuZXh0XFxvcmdcXHNyY1xcdmVuZG9yXFxkdWFsX2xpc3Rib3hlc1xcZHVhbC1saXN0Ym94LmNzcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBcIjEwM2YzNDBiMTQ2NVwiXG5pZiAobW9kdWxlLmhvdCkgeyBtb2R1bGUuaG90LmFjY2VwdCgpIH1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/vendor/dual_listboxes/dual-listbox.css\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/vendor/flag-icons-master/flag-icon.css":
/*!****************************************************!*\
  !*** ./src/vendor/flag-icons-master/flag-icon.css ***!
  \****************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"18577fd2f964\");\nif (true) { module.hot.accept() }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy92ZW5kb3IvZmxhZy1pY29ucy1tYXN0ZXIvZmxhZy1pY29uLmNzcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsaUVBQWUsY0FBYztBQUM3QixJQUFJLElBQVUsSUFBSSxpQkFBaUIiLCJzb3VyY2VzIjpbIkQ6XFxuZXh0XFxvcmdcXHNyY1xcdmVuZG9yXFxmbGFnLWljb25zLW1hc3RlclxcZmxhZy1pY29uLmNzcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBcIjE4NTc3ZmQyZjk2NFwiXG5pZiAobW9kdWxlLmhvdCkgeyBtb2R1bGUuaG90LmFjY2VwdCgpIH1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/vendor/flag-icons-master/flag-icon.css\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/vendor/fontawesome/css/all.css":
/*!********************************************!*\
  !*** ./src/vendor/fontawesome/css/all.css ***!
  \********************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"e52162736ee8\");\nif (true) { module.hot.accept() }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy92ZW5kb3IvZm9udGF3ZXNvbWUvY3NzL2FsbC5jc3MiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLGlFQUFlLGNBQWM7QUFDN0IsSUFBSSxJQUFVLElBQUksaUJBQWlCIiwic291cmNlcyI6WyJEOlxcbmV4dFxcb3JnXFxzcmNcXHZlbmRvclxcZm9udGF3ZXNvbWVcXGNzc1xcYWxsLmNzcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBcImU1MjE2MjczNmVlOFwiXG5pZiAobW9kdWxlLmhvdCkgeyBtb2R1bGUuaG90LmFjY2VwdCgpIH1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/vendor/fontawesome/css/all.css\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/vendor/fullcalendar/global.js":
/*!*******************************************!*\
  !*** ./src/vendor/fullcalendar/global.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("/*!\r\nFullCalendar Standard Bundle v6.1.8\r\nDocs & License: https://fullcalendar.io/docs/initialize-globals\r\n(c) 2023 Adam Shaw\r\n*/ var FullCalendar = function(exports) {\n    'use strict';\n    var n, l$1, u$1, i$1, t, r$1, o, f$1, e$1, c$1 = {}, s = [], a$1 = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;\n    function h(n, l) {\n        for(var u in l)n[u] = l[u];\n        return n;\n    }\n    function v$1(n) {\n        var l = n.parentNode;\n        l && l.removeChild(n);\n    }\n    function y(l, u, i) {\n        var t, r, o, f = {};\n        for(o in u)\"key\" == o ? t = u[o] : \"ref\" == o ? r = u[o] : f[o] = u[o];\n        if (arguments.length > 2 && (f.children = arguments.length > 3 ? n.call(arguments, 2) : i), \"function\" == typeof l && null != l.defaultProps) for(o in l.defaultProps)void 0 === f[o] && (f[o] = l.defaultProps[o]);\n        return p(l, f, t, r, null);\n    }\n    function p(n, i, t, r, o) {\n        var f = {\n            type: n,\n            props: i,\n            key: t,\n            ref: r,\n            __k: null,\n            __: null,\n            __b: 0,\n            __e: null,\n            __d: void 0,\n            __c: null,\n            __h: null,\n            constructor: void 0,\n            __v: null == o ? ++u$1 : o\n        };\n        return null == o && null != l$1.vnode && l$1.vnode(f), f;\n    }\n    function d() {\n        return {\n            current: null\n        };\n    }\n    function _(n) {\n        return n.children;\n    }\n    function k$1(n, l, u, i, t) {\n        var r;\n        for(r in u)\"children\" === r || \"key\" === r || r in l || g$2(n, r, null, u[r], i);\n        for(r in l)t && \"function\" != typeof l[r] || \"children\" === r || \"key\" === r || \"value\" === r || \"checked\" === r || u[r] === l[r] || g$2(n, r, l[r], u[r], i);\n    }\n    function b$1(n, l, u) {\n        \"-\" === l[0] ? n.setProperty(l, null == u ? \"\" : u) : n[l] = null == u ? \"\" : \"number\" != typeof u || a$1.test(l) ? u : u + \"px\";\n    }\n    function g$2(n, l, u, i, t) {\n        var r;\n        n: if (\"style\" === l) if (\"string\" == typeof u) n.style.cssText = u;\n        else {\n            if (\"string\" == typeof i && (n.style.cssText = i = \"\"), i) for(l in i)u && l in u || b$1(n.style, l, \"\");\n            if (u) for(l in u)i && u[l] === i[l] || b$1(n.style, l, u[l]);\n        }\n        else if (\"o\" === l[0] && \"n\" === l[1]) r = l !== (l = l.replace(/Capture$/, \"\")), l = l.toLowerCase() in n ? l.toLowerCase().slice(2) : l.slice(2), n.l || (n.l = {}), n.l[l + r] = u, u ? i || n.addEventListener(l, r ? w$2 : m$1, r) : n.removeEventListener(l, r ? w$2 : m$1, r);\n        else if (\"dangerouslySetInnerHTML\" !== l) {\n            if (t) l = l.replace(/xlink(H|:h)/, \"h\").replace(/sName$/, \"s\");\n            else if (\"width\" !== l && \"height\" !== l && \"href\" !== l && \"list\" !== l && \"form\" !== l && \"tabIndex\" !== l && \"download\" !== l && l in n) try {\n                n[l] = null == u ? \"\" : u;\n                break n;\n            } catch (n) {}\n            \"function\" == typeof u || (null == u || !1 === u && -1 == l.indexOf(\"-\") ? n.removeAttribute(l) : n.setAttribute(l, u));\n        }\n    }\n    function m$1(n) {\n        t = !0;\n        try {\n            return this.l[n.type + !1](l$1.event ? l$1.event(n) : n);\n        } finally{\n            t = !1;\n        }\n    }\n    function w$2(n) {\n        t = !0;\n        try {\n            return this.l[n.type + !0](l$1.event ? l$1.event(n) : n);\n        } finally{\n            t = !1;\n        }\n    }\n    function x$1(n, l) {\n        this.props = n, this.context = l;\n    }\n    function A(n, l) {\n        if (null == l) return n.__ ? A(n.__, n.__.__k.indexOf(n) + 1) : null;\n        for(var u; l < n.__k.length; l++)if (null != (u = n.__k[l]) && null != u.__e) return u.__e;\n        return \"function\" == typeof n.type ? A(n) : null;\n    }\n    function P$1(n) {\n        var l, u;\n        if (null != (n = n.__) && null != n.__c) {\n            for(n.__e = n.__c.base = null, l = 0; l < n.__k.length; l++)if (null != (u = n.__k[l]) && null != u.__e) {\n                n.__e = n.__c.base = u.__e;\n                break;\n            }\n            return P$1(n);\n        }\n    }\n    function C$1(n) {\n        t ? setTimeout(n) : f$1(n);\n    }\n    function T$1(n) {\n        (!n.__d && (n.__d = !0) && r$1.push(n) && !$$1.__r++ || o !== l$1.debounceRendering) && ((o = l$1.debounceRendering) || C$1)($$1);\n    }\n    function $$1() {\n        var n, l, u, i, t, o, f, e;\n        for(r$1.sort(function(n, l) {\n            return n.__v.__b - l.__v.__b;\n        }); n = r$1.shift();)n.__d && (l = r$1.length, i = void 0, t = void 0, f = (o = (u = n).__v).__e, (e = u.__P) && (i = [], (t = h({}, o)).__v = o.__v + 1, M(e, o, t, u.__n, void 0 !== e.ownerSVGElement, null != o.__h ? [\n            f\n        ] : null, i, null == f ? A(o) : f, o.__h), N(i, o), o.__e != f && P$1(o)), r$1.length > l && r$1.sort(function(n, l) {\n            return n.__v.__b - l.__v.__b;\n        }));\n        $$1.__r = 0;\n    }\n    function H$1(n, l, u, i, t, r, o, f, e, a) {\n        var h, v, y, d, k, b, g, m = i && i.__k || s, w = m.length;\n        for(u.__k = [], h = 0; h < l.length; h++)if (null != (d = u.__k[h] = null == (d = l[h]) || \"boolean\" == typeof d ? null : \"string\" == typeof d || \"number\" == typeof d || \"bigint\" == typeof d ? p(null, d, null, null, d) : Array.isArray(d) ? p(_, {\n            children: d\n        }, null, null, null) : d.__b > 0 ? p(d.type, d.props, d.key, d.ref ? d.ref : null, d.__v) : d)) {\n            if (d.__ = u, d.__b = u.__b + 1, null === (y = m[h]) || y && d.key == y.key && d.type === y.type) m[h] = void 0;\n            else for(v = 0; v < w; v++){\n                if ((y = m[v]) && d.key == y.key && d.type === y.type) {\n                    m[v] = void 0;\n                    break;\n                }\n                y = null;\n            }\n            M(n, d, y = y || c$1, t, r, o, f, e, a), k = d.__e, (v = d.ref) && y.ref != v && (g || (g = []), y.ref && g.push(y.ref, null, d), g.push(v, d.__c || k, d)), null != k ? (null == b && (b = k), \"function\" == typeof d.type && d.__k === y.__k ? d.__d = e = I$1(d, e, n) : e = z$1(n, d, y, m, k, e), \"function\" == typeof u.type && (u.__d = e)) : e && y.__e == e && e.parentNode != n && (e = A(y));\n        }\n        for(u.__e = b, h = w; h--;)null != m[h] && (\"function\" == typeof u.type && null != m[h].__e && m[h].__e == u.__d && (u.__d = L$1(i).nextSibling), q(m[h], m[h]));\n        if (g) for(h = 0; h < g.length; h++)S(g[h], g[++h], g[++h]);\n    }\n    function I$1(n, l, u) {\n        for(var i, t = n.__k, r = 0; t && r < t.length; r++)(i = t[r]) && (i.__ = n, l = \"function\" == typeof i.type ? I$1(i, l, u) : z$1(u, i, i, t, i.__e, l));\n        return l;\n    }\n    function j$2(n, l) {\n        return l = l || [], null == n || \"boolean\" == typeof n || (Array.isArray(n) ? n.some(function(n) {\n            j$2(n, l);\n        }) : l.push(n)), l;\n    }\n    function z$1(n, l, u, i, t, r) {\n        var o, f, e;\n        if (void 0 !== l.__d) o = l.__d, l.__d = void 0;\n        else if (null == u || t != r || null == t.parentNode) n: if (null == r || r.parentNode !== n) n.appendChild(t), o = null;\n        else {\n            for(f = r, e = 0; (f = f.nextSibling) && e < i.length; e += 1)if (f == t) break n;\n            n.insertBefore(t, r), o = r;\n        }\n        return void 0 !== o ? o : t.nextSibling;\n    }\n    function L$1(n) {\n        var l, u, i;\n        if (null == n.type || \"string\" == typeof n.type) return n.__e;\n        if (n.__k) {\n            for(l = n.__k.length - 1; l >= 0; l--)if ((u = n.__k[l]) && (i = L$1(u))) return i;\n        }\n        return null;\n    }\n    function M(n, u, i, t, r, o, f, e, c) {\n        var s, a, v, y, p, d, k, b, g, m, w, A, P, C, T, $ = u.type;\n        if (void 0 !== u.constructor) return null;\n        null != i.__h && (c = i.__h, e = u.__e = i.__e, u.__h = null, o = [\n            e\n        ]), (s = l$1.__b) && s(u);\n        try {\n            n: if (\"function\" == typeof $) {\n                if (b = u.props, g = (s = $.contextType) && t[s.__c], m = s ? g ? g.props.value : s.__ : t, i.__c ? k = (a = u.__c = i.__c).__ = a.__E : (\"prototype\" in $ && $.prototype.render ? u.__c = a = new $(b, m) : (u.__c = a = new x$1(b, m), a.constructor = $, a.render = B$1), g && g.sub(a), a.props = b, a.state || (a.state = {}), a.context = m, a.__n = t, v = a.__d = !0, a.__h = [], a._sb = []), null == a.__s && (a.__s = a.state), null != $.getDerivedStateFromProps && (a.__s == a.state && (a.__s = h({}, a.__s)), h(a.__s, $.getDerivedStateFromProps(b, a.__s))), y = a.props, p = a.state, a.__v = u, v) null == $.getDerivedStateFromProps && null != a.componentWillMount && a.componentWillMount(), null != a.componentDidMount && a.__h.push(a.componentDidMount);\n                else {\n                    if (null == $.getDerivedStateFromProps && b !== y && null != a.componentWillReceiveProps && a.componentWillReceiveProps(b, m), !a.__e && null != a.shouldComponentUpdate && !1 === a.shouldComponentUpdate(b, a.__s, m) || u.__v === i.__v) {\n                        for(u.__v !== i.__v && (a.props = b, a.state = a.__s, a.__d = !1), u.__e = i.__e, u.__k = i.__k, u.__k.forEach(function(n) {\n                            n && (n.__ = u);\n                        }), w = 0; w < a._sb.length; w++)a.__h.push(a._sb[w]);\n                        a._sb = [], a.__h.length && f.push(a);\n                        break n;\n                    }\n                    null != a.componentWillUpdate && a.componentWillUpdate(b, a.__s, m), null != a.componentDidUpdate && a.__h.push(function() {\n                        a.componentDidUpdate(y, p, d);\n                    });\n                }\n                if (a.context = m, a.props = b, a.__P = n, A = l$1.__r, P = 0, \"prototype\" in $ && $.prototype.render) {\n                    for(a.state = a.__s, a.__d = !1, A && A(u), s = a.render(a.props, a.state, a.context), C = 0; C < a._sb.length; C++)a.__h.push(a._sb[C]);\n                    a._sb = [];\n                } else do {\n                    a.__d = !1, A && A(u), s = a.render(a.props, a.state, a.context), a.state = a.__s;\n                }while (a.__d && ++P < 25);\n                a.state = a.__s, null != a.getChildContext && (t = h(h({}, t), a.getChildContext())), v || null == a.getSnapshotBeforeUpdate || (d = a.getSnapshotBeforeUpdate(y, p)), T = null != s && s.type === _ && null == s.key ? s.props.children : s, H$1(n, Array.isArray(T) ? T : [\n                    T\n                ], u, i, t, r, o, f, e, c), a.base = u.__e, u.__h = null, a.__h.length && f.push(a), k && (a.__E = a.__ = null), a.__e = !1;\n            } else null == o && u.__v === i.__v ? (u.__k = i.__k, u.__e = i.__e) : u.__e = O(i.__e, u, i, t, r, o, f, c);\n            (s = l$1.diffed) && s(u);\n        } catch (n) {\n            u.__v = null, (c || null != o) && (u.__e = e, u.__h = !!c, o[o.indexOf(e)] = null), l$1.__e(n, u, i);\n        }\n    }\n    function N(n, u) {\n        l$1.__c && l$1.__c(u, n), n.some(function(u) {\n            try {\n                n = u.__h, u.__h = [], n.some(function(n) {\n                    n.call(u);\n                });\n            } catch (n) {\n                l$1.__e(n, u.__v);\n            }\n        });\n    }\n    function O(l, u, i, t, r, o, f, e) {\n        var s, a, h, y = i.props, p = u.props, d = u.type, _ = 0;\n        if (\"svg\" === d && (r = !0), null != o) {\n            for(; _ < o.length; _++)if ((s = o[_]) && \"setAttribute\" in s == !!d && (d ? s.localName === d : 3 === s.nodeType)) {\n                l = s, o[_] = null;\n                break;\n            }\n        }\n        if (null == l) {\n            if (null === d) return document.createTextNode(p);\n            l = r ? document.createElementNS(\"http://www.w3.org/2000/svg\", d) : document.createElement(d, p.is && p), o = null, e = !1;\n        }\n        if (null === d) y === p || e && l.data === p || (l.data = p);\n        else {\n            if (o = o && n.call(l.childNodes), a = (y = i.props || c$1).dangerouslySetInnerHTML, h = p.dangerouslySetInnerHTML, !e) {\n                if (null != o) for(y = {}, _ = 0; _ < l.attributes.length; _++)y[l.attributes[_].name] = l.attributes[_].value;\n                (h || a) && (h && (a && h.__html == a.__html || h.__html === l.innerHTML) || (l.innerHTML = h && h.__html || \"\"));\n            }\n            if (k$1(l, p, y, r, e), h) u.__k = [];\n            else if (_ = u.props.children, H$1(l, Array.isArray(_) ? _ : [\n                _\n            ], u, i, t, r && \"foreignObject\" !== d, o, f, o ? o[0] : i.__k && A(i, 0), e), null != o) for(_ = o.length; _--;)null != o[_] && v$1(o[_]);\n            e || (\"value\" in p && void 0 !== (_ = p.value) && (_ !== l.value || \"progress\" === d && !_ || \"option\" === d && _ !== y.value) && g$2(l, \"value\", _, y.value, !1), \"checked\" in p && void 0 !== (_ = p.checked) && _ !== l.checked && g$2(l, \"checked\", _, y.checked, !1));\n        }\n        return l;\n    }\n    function S(n, u, i) {\n        try {\n            \"function\" == typeof n ? n(u) : n.current = u;\n        } catch (n) {\n            l$1.__e(n, i);\n        }\n    }\n    function q(n, u, i) {\n        var t, r;\n        if (l$1.unmount && l$1.unmount(n), (t = n.ref) && (t.current && t.current !== n.__e || S(t, null, u)), null != (t = n.__c)) {\n            if (t.componentWillUnmount) try {\n                t.componentWillUnmount();\n            } catch (n) {\n                l$1.__e(n, u);\n            }\n            t.base = t.__P = null, n.__c = void 0;\n        }\n        if (t = n.__k) for(r = 0; r < t.length; r++)t[r] && q(t[r], u, i || \"function\" != typeof n.type);\n        i || null == n.__e || v$1(n.__e), n.__ = n.__e = n.__d = void 0;\n    }\n    function B$1(n, l, u) {\n        return this.constructor(n, u);\n    }\n    function D$1(u, i, t) {\n        var r, o, f;\n        l$1.__ && l$1.__(u, i), o = (r = \"function\" == typeof t) ? null : t && t.__k || i.__k, f = [], M(i, u = (!r && t || i).__k = y(_, null, [\n            u\n        ]), o || c$1, c$1, void 0 !== i.ownerSVGElement, !r && t ? [\n            t\n        ] : o ? null : i.firstChild ? n.call(i.childNodes) : null, f, !r && t ? t : o ? o.__e : i.firstChild, r), N(f, u);\n    }\n    function E(n, l) {\n        D$1(n, l, E);\n    }\n    function F$1(l, u, i) {\n        var t, r, o, f = h({}, l.props);\n        for(o in u)\"key\" == o ? t = u[o] : \"ref\" == o ? r = u[o] : f[o] = u[o];\n        return arguments.length > 2 && (f.children = arguments.length > 3 ? n.call(arguments, 2) : i), p(l.type, f, t || l.key, r || l.ref, null);\n    }\n    function G$1(n, l) {\n        var u = {\n            __c: l = \"__cC\" + e$1++,\n            __: n,\n            Consumer: function(n, l) {\n                return n.children(l);\n            },\n            Provider: function(n) {\n                var u, i;\n                return this.getChildContext || (u = [], (i = {})[l] = this, this.getChildContext = function() {\n                    return i;\n                }, this.shouldComponentUpdate = function(n) {\n                    this.props.value !== n.value && u.some(function(n) {\n                        n.__e = !0, T$1(n);\n                    });\n                }, this.sub = function(n) {\n                    u.push(n);\n                    var l = n.componentWillUnmount;\n                    n.componentWillUnmount = function() {\n                        u.splice(u.indexOf(n), 1), l && l.call(n);\n                    };\n                }), n.children;\n            }\n        };\n        return u.Provider.__ = u.Consumer.contextType = u;\n    }\n    n = s.slice, l$1 = {\n        __e: function(n, l, u, i) {\n            for(var t, r, o; l = l.__;)if ((t = l.__c) && !t.__) try {\n                if ((r = t.constructor) && null != r.getDerivedStateFromError && (t.setState(r.getDerivedStateFromError(n)), o = t.__d), null != t.componentDidCatch && (t.componentDidCatch(n, i || {}), o = t.__d), o) return t.__E = t;\n            } catch (l) {\n                n = l;\n            }\n            throw n;\n        }\n    }, u$1 = 0, i$1 = function(n) {\n        return null != n && void 0 === n.constructor;\n    }, t = !1, x$1.prototype.setState = function(n, l) {\n        var u;\n        u = null != this.__s && this.__s !== this.state ? this.__s : this.__s = h({}, this.state), \"function\" == typeof n && (n = n(h({}, u), this.props)), n && h(u, n), null != n && this.__v && (l && this._sb.push(l), T$1(this));\n    }, x$1.prototype.forceUpdate = function(n) {\n        this.__v && (this.__e = !0, n && this.__h.push(n), T$1(this));\n    }, x$1.prototype.render = _, r$1 = [], f$1 = \"function\" == typeof Promise ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, $$1.__r = 0, e$1 = 0;\n    var r, u, i, f = [], c = [], e = l$1.__b, a = l$1.__r, v = l$1.diffed, l = l$1.__c, m = l$1.unmount;\n    function b() {\n        for(var t; t = f.shift();)if (t.__P && t.__H) try {\n            t.__H.__h.forEach(k), t.__H.__h.forEach(w$1), t.__H.__h = [];\n        } catch (r) {\n            t.__H.__h = [], l$1.__e(r, t.__v);\n        }\n    }\n    l$1.__b = function(n) {\n        r = null, e && e(n);\n    }, l$1.__r = function(n) {\n        a && a(n);\n        var i = (r = n.__c).__H;\n        i && (u === r ? (i.__h = [], r.__h = [], i.__.forEach(function(n) {\n            n.__N && (n.__ = n.__N), n.__V = c, n.__N = n.i = void 0;\n        })) : (i.__h.forEach(k), i.__h.forEach(w$1), i.__h = [])), u = r;\n    }, l$1.diffed = function(t) {\n        v && v(t);\n        var o = t.__c;\n        o && o.__H && (o.__H.__h.length && (1 !== f.push(o) && i === l$1.requestAnimationFrame || ((i = l$1.requestAnimationFrame) || j$1)(b)), o.__H.__.forEach(function(n) {\n            n.i && (n.__H = n.i), n.__V !== c && (n.__ = n.__V), n.i = void 0, n.__V = c;\n        })), u = r = null;\n    }, l$1.__c = function(t, r) {\n        r.some(function(t) {\n            try {\n                t.__h.forEach(k), t.__h = t.__h.filter(function(n) {\n                    return !n.__ || w$1(n);\n                });\n            } catch (u) {\n                r.some(function(n) {\n                    n.__h && (n.__h = []);\n                }), r = [], l$1.__e(u, t.__v);\n            }\n        }), l && l(t, r);\n    }, l$1.unmount = function(t) {\n        m && m(t);\n        var r, u = t.__c;\n        u && u.__H && (u.__H.__.forEach(function(n) {\n            try {\n                k(n);\n            } catch (n) {\n                r = n;\n            }\n        }), u.__H = void 0, r && l$1.__e(r, u.__v));\n    };\n    var g$1 = \"function\" == typeof requestAnimationFrame;\n    function j$1(n) {\n        var t, r = function() {\n            clearTimeout(u), g$1 && cancelAnimationFrame(t), setTimeout(n);\n        }, u = setTimeout(r, 100);\n        g$1 && (t = requestAnimationFrame(r));\n    }\n    function k(n) {\n        var t = r, u = n.__c;\n        \"function\" == typeof u && (n.__c = void 0, u()), r = t;\n    }\n    function w$1(n) {\n        var t = r;\n        n.__c = n.__(), r = t;\n    }\n    function g(n, t) {\n        for(var e in t)n[e] = t[e];\n        return n;\n    }\n    function C(n, t) {\n        for(var e in n)if (\"__source\" !== e && !(e in t)) return !0;\n        for(var r in t)if (\"__source\" !== r && n[r] !== t[r]) return !0;\n        return !1;\n    }\n    function w(n) {\n        this.props = n;\n    }\n    (w.prototype = new x$1).isPureReactComponent = !0, w.prototype.shouldComponentUpdate = function(n, t) {\n        return C(this.props, n) || C(this.state, t);\n    };\n    var x = l$1.__b;\n    l$1.__b = function(n) {\n        n.type && n.type.__f && n.ref && (n.props.ref = n.ref, n.ref = null), x && x(n);\n    };\n    var T = l$1.__e;\n    l$1.__e = function(n, t, e, r) {\n        if (n.then) {\n            for(var u, o = t; o = o.__;)if ((u = o.__c) && u.__c) return null == t.__e && (t.__e = e.__e, t.__k = e.__k), u.__c(n, t);\n        }\n        T(n, t, e, r);\n    };\n    var I = l$1.unmount;\n    function L(n, t, e) {\n        return n && (n.__c && n.__c.__H && (n.__c.__H.__.forEach(function(n) {\n            \"function\" == typeof n.__c && n.__c();\n        }), n.__c.__H = null), null != (n = g({}, n)).__c && (n.__c.__P === e && (n.__c.__P = t), n.__c = null), n.__k = n.__k && n.__k.map(function(n) {\n            return L(n, t, e);\n        })), n;\n    }\n    function U(n, t, e) {\n        return n && (n.__v = null, n.__k = n.__k && n.__k.map(function(n) {\n            return U(n, t, e);\n        }), n.__c && n.__c.__P === t && (n.__e && e.insertBefore(n.__e, n.__d), n.__c.__e = !0, n.__c.__P = e)), n;\n    }\n    function D() {\n        this.__u = 0, this.t = null, this.__b = null;\n    }\n    function F(n) {\n        var t = n.__.__c;\n        return t && t.__a && t.__a(n);\n    }\n    function V() {\n        this.u = null, this.o = null;\n    }\n    l$1.unmount = function(n) {\n        var t = n.__c;\n        t && t.__R && t.__R(), t && !0 === n.__h && (n.type = null), I && I(n);\n    }, (D.prototype = new x$1).__c = function(n, t) {\n        var e = t.__c, r = this;\n        null == r.t && (r.t = []), r.t.push(e);\n        var u = F(r.__v), o = !1, i = function() {\n            o || (o = !0, e.__R = null, u ? u(l) : l());\n        };\n        e.__R = i;\n        var l = function() {\n            if (!--r.__u) {\n                if (r.state.__a) {\n                    var n = r.state.__a;\n                    r.__v.__k[0] = U(n, n.__c.__P, n.__c.__O);\n                }\n                var t;\n                for(r.setState({\n                    __a: r.__b = null\n                }); t = r.t.pop();)t.forceUpdate();\n            }\n        }, c = !0 === t.__h;\n        r.__u++ || c || r.setState({\n            __a: r.__b = r.__v.__k[0]\n        }), n.then(i, i);\n    }, D.prototype.componentWillUnmount = function() {\n        this.t = [];\n    }, D.prototype.render = function(n, e) {\n        if (this.__b) {\n            if (this.__v.__k) {\n                var r = document.createElement(\"div\"), o = this.__v.__k[0].__c;\n                this.__v.__k[0] = L(this.__b, r, o.__O = o.__P);\n            }\n            this.__b = null;\n        }\n        var i = e.__a && y(_, null, n.fallback);\n        return i && (i.__h = null), [\n            y(_, null, e.__a ? null : n.children),\n            i\n        ];\n    };\n    var W = function(n, t, e) {\n        if (++e[1] === e[0] && n.o.delete(t), n.props.revealOrder && (\"t\" !== n.props.revealOrder[0] || !n.o.size)) for(e = n.u; e;){\n            for(; e.length > 3;)e.pop()();\n            if (e[1] < e[0]) break;\n            n.u = e = e[2];\n        }\n    };\n    function P(n) {\n        return this.getChildContext = function() {\n            return n.context;\n        }, n.children;\n    }\n    function $(n) {\n        var e = this, r = n.i;\n        e.componentWillUnmount = function() {\n            D$1(null, e.l), e.l = null, e.i = null;\n        }, e.i && e.i !== r && e.componentWillUnmount(), n.__v ? (e.l || (e.i = r, e.l = {\n            nodeType: 1,\n            parentNode: r,\n            childNodes: [],\n            appendChild: function(n) {\n                this.childNodes.push(n), e.i.appendChild(n);\n            },\n            insertBefore: function(n, t) {\n                this.childNodes.push(n), e.i.appendChild(n);\n            },\n            removeChild: function(n) {\n                this.childNodes.splice(this.childNodes.indexOf(n) >>> 1, 1), e.i.removeChild(n);\n            }\n        }), D$1(y(P, {\n            context: e.context\n        }, n.__v), e.l)) : e.l && e.componentWillUnmount();\n    }\n    function j(n, e) {\n        var r = y($, {\n            __v: n,\n            i: e\n        });\n        return r.containerInfo = e, r;\n    }\n    (V.prototype = new x$1).__a = function(n) {\n        var t = this, e = F(t.__v), r = t.o.get(n);\n        return r[0]++, function(u) {\n            var o = function() {\n                t.props.revealOrder ? (r.push(u), W(t, n, r)) : u();\n            };\n            e ? e(o) : o();\n        };\n    }, V.prototype.render = function(n) {\n        this.u = null, this.o = new Map;\n        var t = j$2(n.children);\n        n.revealOrder && \"b\" === n.revealOrder[0] && t.reverse();\n        for(var e = t.length; e--;)this.o.set(t[e], this.u = [\n            1,\n            0,\n            this.u\n        ]);\n        return n.children;\n    }, V.prototype.componentDidUpdate = V.prototype.componentDidMount = function() {\n        var n = this;\n        this.o.forEach(function(t, e) {\n            W(n, e, t);\n        });\n    };\n    var z = \"undefined\" != typeof Symbol && Symbol.for && Symbol.for(\"react.element\") || 60103, B = /^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|dominant|fill|flood|font|glyph(?!R)|horiz|image|letter|lighting|marker(?!H|W|U)|overline|paint|pointer|shape|stop|strikethrough|stroke|text(?!L)|transform|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/, H = \"undefined\" != typeof document, Z = function(n) {\n        return (\"undefined\" != typeof Symbol && \"symbol\" == typeof Symbol() ? /fil|che|rad/i : /fil|che|ra/i).test(n);\n    };\n    x$1.prototype.isReactComponent = {}, [\n        \"componentWillMount\",\n        \"componentWillReceiveProps\",\n        \"componentWillUpdate\"\n    ].forEach(function(t) {\n        Object.defineProperty(x$1.prototype, t, {\n            configurable: !0,\n            get: function() {\n                return this[\"UNSAFE_\" + t];\n            },\n            set: function(n) {\n                Object.defineProperty(this, t, {\n                    configurable: !0,\n                    writable: !0,\n                    value: n\n                });\n            }\n        });\n    });\n    var G = l$1.event;\n    function J() {}\n    function K() {\n        return this.cancelBubble;\n    }\n    function Q() {\n        return this.defaultPrevented;\n    }\n    l$1.event = function(n) {\n        return G && (n = G(n)), n.persist = J, n.isPropagationStopped = K, n.isDefaultPrevented = Q, n.nativeEvent = n;\n    };\n    var nn = {\n        configurable: !0,\n        get: function() {\n            return this.class;\n        }\n    }, tn = l$1.vnode;\n    l$1.vnode = function(n) {\n        var t = n.type, e = n.props, u = e;\n        if (\"string\" == typeof t) {\n            var o = -1 === t.indexOf(\"-\");\n            for(var i in u = {}, e){\n                var l = e[i];\n                H && \"children\" === i && \"noscript\" === t || \"value\" === i && \"defaultValue\" in e && null == l || (\"defaultValue\" === i && \"value\" in e && null == e.value ? i = \"value\" : \"download\" === i && !0 === l ? l = \"\" : /ondoubleclick/i.test(i) ? i = \"ondblclick\" : /^onchange(textarea|input)/i.test(i + t) && !Z(e.type) ? i = \"oninput\" : /^onfocus$/i.test(i) ? i = \"onfocusin\" : /^onblur$/i.test(i) ? i = \"onfocusout\" : /^on(Ani|Tra|Tou|BeforeInp|Compo)/.test(i) ? i = i.toLowerCase() : o && B.test(i) ? i = i.replace(/[A-Z0-9]/g, \"-$&\").toLowerCase() : null === l && (l = void 0), /^oninput$/i.test(i) && (i = i.toLowerCase(), u[i] && (i = \"oninputCapture\")), u[i] = l);\n            }\n            \"select\" == t && u.multiple && Array.isArray(u.value) && (u.value = j$2(e.children).forEach(function(n) {\n                n.props.selected = -1 != u.value.indexOf(n.props.value);\n            })), \"select\" == t && null != u.defaultValue && (u.value = j$2(e.children).forEach(function(n) {\n                n.props.selected = u.multiple ? -1 != u.defaultValue.indexOf(n.props.value) : u.defaultValue == n.props.value;\n            })), n.props = u, e.class != e.className && (nn.enumerable = \"className\" in e, null != e.className && (u.class = e.className), Object.defineProperty(u, \"className\", nn));\n        }\n        n.$$typeof = z, tn && tn(n);\n    };\n    var en = l$1.__r;\n    l$1.__r = function(n) {\n        en && en(n), n.__c;\n    };\n    const styleTexts = [];\n    const styleEls = new Map();\n    function injectStyles(styleText) {\n        styleTexts.push(styleText);\n        styleEls.forEach((styleEl)=>{\n            appendStylesTo(styleEl, styleText);\n        });\n    }\n    function ensureElHasStyles(el) {\n        if (el.isConnected) {\n            registerStylesRoot(el.getRootNode());\n        }\n    }\n    function registerStylesRoot(rootNode) {\n        let styleEl = styleEls.get(rootNode);\n        if (!styleEl || !styleEl.isConnected) {\n            styleEl = rootNode.querySelector('style[data-fullcalendar]');\n            if (!styleEl) {\n                styleEl = document.createElement('style');\n                styleEl.setAttribute('data-fullcalendar', '');\n                const nonce = getNonceValue();\n                if (nonce) {\n                    styleEl.nonce = nonce;\n                }\n                const parentEl = rootNode === document ? document.head : rootNode;\n                const insertBefore = rootNode === document ? parentEl.querySelector('script,link[rel=stylesheet],link[as=style],style') : parentEl.firstChild;\n                parentEl.insertBefore(styleEl, insertBefore);\n            }\n            styleEls.set(rootNode, styleEl);\n            hydrateStylesRoot(styleEl);\n        }\n    }\n    function hydrateStylesRoot(styleEl) {\n        for (const styleText of styleTexts){\n            appendStylesTo(styleEl, styleText);\n        }\n    }\n    function appendStylesTo(styleEl, styleText) {\n        const { sheet } = styleEl;\n        const ruleCnt = sheet.cssRules.length;\n        styleText.split('}').forEach((styleStr, i)=>{\n            styleStr = styleStr.trim();\n            if (styleStr) {\n                sheet.insertRule(styleStr + '}', ruleCnt + i);\n            }\n        });\n    }\n    // nonce\n    // -------------------------------------------------------------------------------------------------\n    let queriedNonceValue;\n    function getNonceValue() {\n        if (queriedNonceValue === undefined) {\n            queriedNonceValue = queryNonceValue();\n        }\n        return queriedNonceValue;\n    }\n    /*\r\n    TODO: discourage meta tag and instead put nonce attribute on placeholder <style> tag\r\n    */ function queryNonceValue() {\n        const metaWithNonce = document.querySelector('meta[name=\"csp-nonce\"]');\n        if (metaWithNonce && metaWithNonce.hasAttribute('content')) {\n            return metaWithNonce.getAttribute('content');\n        }\n        const elWithNonce = document.querySelector('script[nonce]');\n        if (elWithNonce) {\n            return elWithNonce.nonce || '';\n        }\n        return '';\n    }\n    // main\n    // -------------------------------------------------------------------------------------------------\n    if (typeof document !== 'undefined') {\n        registerStylesRoot(document);\n    }\n    var css_248z$4 = \":root{--fc-small-font-size:.85em;--fc-page-bg-color:#fff;--fc-neutral-bg-color:hsla(0,0%,82%,.3);--fc-neutral-text-color:grey;--fc-border-color:#ddd;--fc-button-text-color:#fff;--fc-button-bg-color:#2c3e50;--fc-button-border-color:#2c3e50;--fc-button-hover-bg-color:#1e2b37;--fc-button-hover-border-color:#1a252f;--fc-button-active-bg-color:#1a252f;--fc-button-active-border-color:#151e27;--fc-event-bg-color:#3788d8;--fc-event-border-color:#3788d8;--fc-event-text-color:#fff;--fc-event-selected-overlay-color:rgba(0,0,0,.25);--fc-more-link-bg-color:#d0d0d0;--fc-more-link-text-color:inherit;--fc-event-resizer-thickness:8px;--fc-event-resizer-dot-total-width:8px;--fc-event-resizer-dot-border-width:1px;--fc-non-business-color:hsla(0,0%,84%,.3);--fc-bg-event-color:#8fdf82;--fc-bg-event-opacity:0.3;--fc-highlight-color:rgba(188,232,241,.3);--fc-today-bg-color:rgba(255,220,40,.15);--fc-now-indicator-color:red}.fc-not-allowed,.fc-not-allowed .fc-event{cursor:not-allowed}.fc{display:flex;flex-direction:column;font-size:1em}.fc,.fc *,.fc :after,.fc :before{box-sizing:border-box}.fc table{border-collapse:collapse;border-spacing:0;font-size:1em}.fc th{text-align:center}.fc td,.fc th{padding:0;vertical-align:top}.fc a[data-navlink]{cursor:pointer}.fc a[data-navlink]:hover{text-decoration:underline}.fc-direction-ltr{direction:ltr;text-align:left}.fc-direction-rtl{direction:rtl;text-align:right}.fc-theme-standard td,.fc-theme-standard th{border:1px solid var(--fc-border-color)}.fc-liquid-hack td,.fc-liquid-hack th{position:relative}@font-face{font-family:fcicons;font-style:normal;font-weight:400;src:url(\\\"data:application/x-font-ttf;charset=utf-8;base64,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\\\") format(\\\"truetype\\\")}.fc-icon{speak:none;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;display:inline-block;font-family:fcicons!important;font-style:normal;font-variant:normal;font-weight:400;height:1em;line-height:1;text-align:center;text-transform:none;-webkit-user-select:none;-moz-user-select:none;user-select:none;width:1em}.fc-icon-chevron-left:before{content:\\\"\\\\e900\\\"}.fc-icon-chevron-right:before{content:\\\"\\\\e901\\\"}.fc-icon-chevrons-left:before{content:\\\"\\\\e902\\\"}.fc-icon-chevrons-right:before{content:\\\"\\\\e903\\\"}.fc-icon-minus-square:before{content:\\\"\\\\e904\\\"}.fc-icon-plus-square:before{content:\\\"\\\\e905\\\"}.fc-icon-x:before{content:\\\"\\\\e906\\\"}.fc .fc-button{border-radius:0;font-family:inherit;font-size:inherit;line-height:inherit;margin:0;overflow:visible;text-transform:none}.fc .fc-button:focus{outline:1px dotted;outline:5px auto -webkit-focus-ring-color}.fc .fc-button{-webkit-appearance:button}.fc .fc-button:not(:disabled){cursor:pointer}.fc .fc-button{background-color:transparent;border:1px solid transparent;border-radius:.25em;display:inline-block;font-size:1em;font-weight:400;line-height:1.5;padding:.4em .65em;text-align:center;-webkit-user-select:none;-moz-user-select:none;user-select:none;vertical-align:middle}.fc .fc-button:hover{text-decoration:none}.fc .fc-button:focus{box-shadow:0 0 0 .2rem rgba(44,62,80,.25);outline:0}.fc .fc-button:disabled{opacity:.65}.fc .fc-button-primary{background-color:var(--fc-button-bg-color);border-color:var(--fc-button-border-color);color:var(--fc-button-text-color)}.fc .fc-button-primary:hover{background-color:var(--fc-button-hover-bg-color);border-color:var(--fc-button-hover-border-color);color:var(--fc-button-text-color)}.fc .fc-button-primary:disabled{background-color:var(--fc-button-bg-color);border-color:var(--fc-button-border-color);color:var(--fc-button-text-color)}.fc .fc-button-primary:focus{box-shadow:0 0 0 .2rem rgba(76,91,106,.5)}.fc .fc-button-primary:not(:disabled).fc-button-active,.fc .fc-button-primary:not(:disabled):active{background-color:var(--fc-button-active-bg-color);border-color:var(--fc-button-active-border-color);color:var(--fc-button-text-color)}.fc .fc-button-primary:not(:disabled).fc-button-active:focus,.fc .fc-button-primary:not(:disabled):active:focus{box-shadow:0 0 0 .2rem rgba(76,91,106,.5)}.fc .fc-button .fc-icon{font-size:1.5em;vertical-align:middle}.fc .fc-button-group{display:inline-flex;position:relative;vertical-align:middle}.fc .fc-button-group>.fc-button{flex:1 1 auto;position:relative}.fc .fc-button-group>.fc-button.fc-button-active,.fc .fc-button-group>.fc-button:active,.fc .fc-button-group>.fc-button:focus,.fc .fc-button-group>.fc-button:hover{z-index:1}.fc-direction-ltr .fc-button-group>.fc-button:not(:first-child){border-bottom-left-radius:0;border-top-left-radius:0;margin-left:-1px}.fc-direction-ltr .fc-button-group>.fc-button:not(:last-child){border-bottom-right-radius:0;border-top-right-radius:0}.fc-direction-rtl .fc-button-group>.fc-button:not(:first-child){border-bottom-right-radius:0;border-top-right-radius:0;margin-right:-1px}.fc-direction-rtl .fc-button-group>.fc-button:not(:last-child){border-bottom-left-radius:0;border-top-left-radius:0}.fc .fc-toolbar{align-items:center;display:flex;justify-content:space-between}.fc .fc-toolbar.fc-header-toolbar{margin-bottom:1.5em}.fc .fc-toolbar.fc-footer-toolbar{margin-top:1.5em}.fc .fc-toolbar-title{font-size:1.75em;margin:0}.fc-direction-ltr .fc-toolbar>*>:not(:first-child){margin-left:.75em}.fc-direction-rtl .fc-toolbar>*>:not(:first-child){margin-right:.75em}.fc-direction-rtl .fc-toolbar-ltr{flex-direction:row-reverse}.fc .fc-scroller{-webkit-overflow-scrolling:touch;position:relative}.fc .fc-scroller-liquid{height:100%}.fc .fc-scroller-liquid-absolute{bottom:0;left:0;position:absolute;right:0;top:0}.fc .fc-scroller-harness{direction:ltr;overflow:hidden;position:relative}.fc .fc-scroller-harness-liquid{height:100%}.fc-direction-rtl .fc-scroller-harness>.fc-scroller{direction:rtl}.fc-theme-standard .fc-scrollgrid{border:1px solid var(--fc-border-color)}.fc .fc-scrollgrid,.fc .fc-scrollgrid table{table-layout:fixed;width:100%}.fc .fc-scrollgrid table{border-left-style:hidden;border-right-style:hidden;border-top-style:hidden}.fc .fc-scrollgrid{border-bottom-width:0;border-collapse:separate;border-right-width:0}.fc .fc-scrollgrid-liquid{height:100%}.fc .fc-scrollgrid-section,.fc .fc-scrollgrid-section table,.fc .fc-scrollgrid-section>td{height:1px}.fc .fc-scrollgrid-section-liquid>td{height:100%}.fc .fc-scrollgrid-section>*{border-left-width:0;border-top-width:0}.fc .fc-scrollgrid-section-footer>*,.fc .fc-scrollgrid-section-header>*{border-bottom-width:0}.fc .fc-scrollgrid-section-body table,.fc .fc-scrollgrid-section-footer table{border-bottom-style:hidden}.fc .fc-scrollgrid-section-sticky>*{background:var(--fc-page-bg-color);position:sticky;z-index:3}.fc .fc-scrollgrid-section-header.fc-scrollgrid-section-sticky>*{top:0}.fc .fc-scrollgrid-section-footer.fc-scrollgrid-section-sticky>*{bottom:0}.fc .fc-scrollgrid-sticky-shim{height:1px;margin-bottom:-1px}.fc-sticky{position:sticky}.fc .fc-view-harness{flex-grow:1;position:relative}.fc .fc-view-harness-active>.fc-view{bottom:0;left:0;position:absolute;right:0;top:0}.fc .fc-col-header-cell-cushion{display:inline-block;padding:2px 4px}.fc .fc-bg-event,.fc .fc-highlight,.fc .fc-non-business{bottom:0;left:0;position:absolute;right:0;top:0}.fc .fc-non-business{background:var(--fc-non-business-color)}.fc .fc-bg-event{background:var(--fc-bg-event-color);opacity:var(--fc-bg-event-opacity)}.fc .fc-bg-event .fc-event-title{font-size:var(--fc-small-font-size);font-style:italic;margin:.5em}.fc .fc-highlight{background:var(--fc-highlight-color)}.fc .fc-cell-shaded,.fc .fc-day-disabled{background:var(--fc-neutral-bg-color)}a.fc-event,a.fc-event:hover{text-decoration:none}.fc-event.fc-event-draggable,.fc-event[href]{cursor:pointer}.fc-event .fc-event-main{position:relative;z-index:2}.fc-event-dragging:not(.fc-event-selected){opacity:.75}.fc-event-dragging.fc-event-selected{box-shadow:0 2px 7px rgba(0,0,0,.3)}.fc-event .fc-event-resizer{display:none;position:absolute;z-index:4}.fc-event-selected .fc-event-resizer,.fc-event:hover .fc-event-resizer{display:block}.fc-event-selected .fc-event-resizer{background:var(--fc-page-bg-color);border-color:inherit;border-radius:calc(var(--fc-event-resizer-dot-total-width)/2);border-style:solid;border-width:var(--fc-event-resizer-dot-border-width);height:var(--fc-event-resizer-dot-total-width);width:var(--fc-event-resizer-dot-total-width)}.fc-event-selected .fc-event-resizer:before{bottom:-20px;content:\\\"\\\";left:-20px;position:absolute;right:-20px;top:-20px}.fc-event-selected,.fc-event:focus{box-shadow:0 2px 5px rgba(0,0,0,.2)}.fc-event-selected:before,.fc-event:focus:before{bottom:0;content:\\\"\\\";left:0;position:absolute;right:0;top:0;z-index:3}.fc-event-selected:after,.fc-event:focus:after{background:var(--fc-event-selected-overlay-color);bottom:-1px;content:\\\"\\\";left:-1px;position:absolute;right:-1px;top:-1px;z-index:1}.fc-h-event{background-color:var(--fc-event-bg-color);border:1px solid var(--fc-event-border-color);display:block}.fc-h-event .fc-event-main{color:var(--fc-event-text-color)}.fc-h-event .fc-event-main-frame{display:flex}.fc-h-event .fc-event-time{max-width:100%;overflow:hidden}.fc-h-event .fc-event-title-container{flex-grow:1;flex-shrink:1;min-width:0}.fc-h-event .fc-event-title{display:inline-block;left:0;max-width:100%;overflow:hidden;right:0;vertical-align:top}.fc-h-event.fc-event-selected:before{bottom:-10px;top:-10px}.fc-direction-ltr .fc-daygrid-block-event:not(.fc-event-start),.fc-direction-rtl .fc-daygrid-block-event:not(.fc-event-end){border-bottom-left-radius:0;border-left-width:0;border-top-left-radius:0}.fc-direction-ltr .fc-daygrid-block-event:not(.fc-event-end),.fc-direction-rtl .fc-daygrid-block-event:not(.fc-event-start){border-bottom-right-radius:0;border-right-width:0;border-top-right-radius:0}.fc-h-event:not(.fc-event-selected) .fc-event-resizer{bottom:0;top:0;width:var(--fc-event-resizer-thickness)}.fc-direction-ltr .fc-h-event:not(.fc-event-selected) .fc-event-resizer-start,.fc-direction-rtl .fc-h-event:not(.fc-event-selected) .fc-event-resizer-end{cursor:w-resize;left:calc(var(--fc-event-resizer-thickness)*-.5)}.fc-direction-ltr .fc-h-event:not(.fc-event-selected) .fc-event-resizer-end,.fc-direction-rtl .fc-h-event:not(.fc-event-selected) .fc-event-resizer-start{cursor:e-resize;right:calc(var(--fc-event-resizer-thickness)*-.5)}.fc-h-event.fc-event-selected .fc-event-resizer{margin-top:calc(var(--fc-event-resizer-dot-total-width)*-.5);top:50%}.fc-direction-ltr .fc-h-event.fc-event-selected .fc-event-resizer-start,.fc-direction-rtl .fc-h-event.fc-event-selected .fc-event-resizer-end{left:calc(var(--fc-event-resizer-dot-total-width)*-.5)}.fc-direction-ltr .fc-h-event.fc-event-selected .fc-event-resizer-end,.fc-direction-rtl .fc-h-event.fc-event-selected .fc-event-resizer-start{right:calc(var(--fc-event-resizer-dot-total-width)*-.5)}.fc .fc-popover{box-shadow:0 2px 6px rgba(0,0,0,.15);position:absolute;z-index:9999}.fc .fc-popover-header{align-items:center;display:flex;flex-direction:row;justify-content:space-between;padding:3px 4px}.fc .fc-popover-title{margin:0 2px}.fc .fc-popover-close{cursor:pointer;font-size:1.1em;opacity:.65}.fc-theme-standard .fc-popover{background:var(--fc-page-bg-color);border:1px solid var(--fc-border-color)}.fc-theme-standard .fc-popover-header{background:var(--fc-neutral-bg-color)}\";\n    injectStyles(css_248z$4);\n    function removeElement(el) {\n        if (el.parentNode) {\n            el.parentNode.removeChild(el);\n        }\n    }\n    // Querying\n    // ----------------------------------------------------------------------------------------------------------------\n    function elementClosest(el, selector) {\n        if (el.closest) {\n            return el.closest(selector);\n        // really bad fallback for IE\n        // from https://developer.mozilla.org/en-US/docs/Web/API/Element/closest\n        }\n        if (!document.documentElement.contains(el)) {\n            return null;\n        }\n        do {\n            if (elementMatches(el, selector)) {\n                return el;\n            }\n            el = el.parentElement || el.parentNode;\n        }while (el !== null && el.nodeType === 1);\n        return null;\n    }\n    function elementMatches(el, selector) {\n        let method = el.matches || el.matchesSelector || el.msMatchesSelector;\n        return method.call(el, selector);\n    }\n    // accepts multiple subject els\n    // returns a real array. good for methods like forEach\n    // TODO: accept the document\n    function findElements(container, selector) {\n        let containers = container instanceof HTMLElement ? [\n            container\n        ] : container;\n        let allMatches = [];\n        for(let i = 0; i < containers.length; i += 1){\n            let matches = containers[i].querySelectorAll(selector);\n            for(let j = 0; j < matches.length; j += 1){\n                allMatches.push(matches[j]);\n            }\n        }\n        return allMatches;\n    }\n    // accepts multiple subject els\n    // only queries direct child elements // TODO: rename to findDirectChildren!\n    function findDirectChildren(parent, selector) {\n        let parents = parent instanceof HTMLElement ? [\n            parent\n        ] : parent;\n        let allMatches = [];\n        for(let i = 0; i < parents.length; i += 1){\n            let childNodes = parents[i].children; // only ever elements\n            for(let j = 0; j < childNodes.length; j += 1){\n                let childNode = childNodes[j];\n                if (!selector || elementMatches(childNode, selector)) {\n                    allMatches.push(childNode);\n                }\n            }\n        }\n        return allMatches;\n    }\n    // Style\n    // ----------------------------------------------------------------------------------------------------------------\n    const PIXEL_PROP_RE = /(top|left|right|bottom|width|height)$/i;\n    function applyStyle(el, props) {\n        for(let propName in props){\n            applyStyleProp(el, propName, props[propName]);\n        }\n    }\n    function applyStyleProp(el, name, val) {\n        if (val == null) {\n            el.style[name] = '';\n        } else if (typeof val === 'number' && PIXEL_PROP_RE.test(name)) {\n            el.style[name] = \"\".concat(val, \"px\");\n        } else {\n            el.style[name] = val;\n        }\n    }\n    // Event Handling\n    // ----------------------------------------------------------------------------------------------------------------\n    // if intercepting bubbled events at the document/window/body level,\n    // and want to see originating element (the 'target'), use this util instead\n    // of `ev.target` because it goes within web-component boundaries.\n    function getEventTargetViaRoot(ev) {\n        var _a, _b;\n        return (_b = (_a = ev.composedPath) === null || _a === void 0 ? void 0 : _a.call(ev)[0]) !== null && _b !== void 0 ? _b : ev.target;\n    }\n    // Unique ID for DOM attribute\n    let guid$1 = 0;\n    function getUniqueDomId() {\n        guid$1 += 1;\n        return 'fc-dom-' + guid$1;\n    }\n    // Stops a mouse/touch event from doing it's native browser action\n    function preventDefault(ev) {\n        ev.preventDefault();\n    }\n    // Event Delegation\n    // ----------------------------------------------------------------------------------------------------------------\n    function buildDelegationHandler(selector, handler) {\n        return (ev)=>{\n            let matchedChild = elementClosest(ev.target, selector);\n            if (matchedChild) {\n                handler.call(matchedChild, ev, matchedChild);\n            }\n        };\n    }\n    function listenBySelector(container, eventType, selector, handler) {\n        let attachedHandler = buildDelegationHandler(selector, handler);\n        container.addEventListener(eventType, attachedHandler);\n        return ()=>{\n            container.removeEventListener(eventType, attachedHandler);\n        };\n    }\n    function listenToHoverBySelector(container, selector, onMouseEnter, onMouseLeave) {\n        let currentMatchedChild;\n        return listenBySelector(container, 'mouseover', selector, (mouseOverEv, matchedChild)=>{\n            if (matchedChild !== currentMatchedChild) {\n                currentMatchedChild = matchedChild;\n                onMouseEnter(mouseOverEv, matchedChild);\n                let realOnMouseLeave = (mouseLeaveEv)=>{\n                    currentMatchedChild = null;\n                    onMouseLeave(mouseLeaveEv, matchedChild);\n                    matchedChild.removeEventListener('mouseleave', realOnMouseLeave);\n                };\n                // listen to the next mouseleave, and then unattach\n                matchedChild.addEventListener('mouseleave', realOnMouseLeave);\n            }\n        });\n    }\n    // Animation\n    // ----------------------------------------------------------------------------------------------------------------\n    const transitionEventNames = [\n        'webkitTransitionEnd',\n        'otransitionend',\n        'oTransitionEnd',\n        'msTransitionEnd',\n        'transitionend'\n    ];\n    // triggered only when the next single subsequent transition finishes\n    function whenTransitionDone(el, callback) {\n        let realCallback = (ev)=>{\n            callback(ev);\n            transitionEventNames.forEach((eventName)=>{\n                el.removeEventListener(eventName, realCallback);\n            });\n        };\n        transitionEventNames.forEach((eventName)=>{\n            el.addEventListener(eventName, realCallback); // cross-browser way to determine when the transition finishes\n        });\n    }\n    // ARIA workarounds\n    // ----------------------------------------------------------------------------------------------------------------\n    function createAriaClickAttrs(handler) {\n        return Object.assign({\n            onClick: handler\n        }, createAriaKeyboardAttrs(handler));\n    }\n    function createAriaKeyboardAttrs(handler) {\n        return {\n            tabIndex: 0,\n            onKeyDown (ev) {\n                if (ev.key === 'Enter' || ev.key === ' ') {\n                    handler(ev);\n                    ev.preventDefault(); // if space, don't scroll down page\n                }\n            }\n        };\n    }\n    let guidNumber = 0;\n    function guid() {\n        guidNumber += 1;\n        return String(guidNumber);\n    }\n    /* FullCalendar-specific DOM Utilities\r\n    ----------------------------------------------------------------------------------------------------------------------*/ // Make the mouse cursor express that an event is not allowed in the current area\n    function disableCursor() {\n        document.body.classList.add('fc-not-allowed');\n    }\n    // Returns the mouse cursor to its original look\n    function enableCursor() {\n        document.body.classList.remove('fc-not-allowed');\n    }\n    /* Selection\r\n    ----------------------------------------------------------------------------------------------------------------------*/ function preventSelection(el) {\n        el.style.userSelect = 'none';\n        el.addEventListener('selectstart', preventDefault);\n    }\n    function allowSelection(el) {\n        el.style.userSelect = '';\n        el.removeEventListener('selectstart', preventDefault);\n    }\n    /* Context Menu\r\n    ----------------------------------------------------------------------------------------------------------------------*/ function preventContextMenu(el) {\n        el.addEventListener('contextmenu', preventDefault);\n    }\n    function allowContextMenu(el) {\n        el.removeEventListener('contextmenu', preventDefault);\n    }\n    function parseFieldSpecs(input) {\n        let specs = [];\n        let tokens = [];\n        let i;\n        let token;\n        if (typeof input === 'string') {\n            tokens = input.split(/\\s*,\\s*/);\n        } else if (typeof input === 'function') {\n            tokens = [\n                input\n            ];\n        } else if (Array.isArray(input)) {\n            tokens = input;\n        }\n        for(i = 0; i < tokens.length; i += 1){\n            token = tokens[i];\n            if (typeof token === 'string') {\n                specs.push(token.charAt(0) === '-' ? {\n                    field: token.substring(1),\n                    order: -1\n                } : {\n                    field: token,\n                    order: 1\n                });\n            } else if (typeof token === 'function') {\n                specs.push({\n                    func: token\n                });\n            }\n        }\n        return specs;\n    }\n    function compareByFieldSpecs(obj0, obj1, fieldSpecs) {\n        let i;\n        let cmp;\n        for(i = 0; i < fieldSpecs.length; i += 1){\n            cmp = compareByFieldSpec(obj0, obj1, fieldSpecs[i]);\n            if (cmp) {\n                return cmp;\n            }\n        }\n        return 0;\n    }\n    function compareByFieldSpec(obj0, obj1, fieldSpec) {\n        if (fieldSpec.func) {\n            return fieldSpec.func(obj0, obj1);\n        }\n        return flexibleCompare(obj0[fieldSpec.field], obj1[fieldSpec.field]) * (fieldSpec.order || 1);\n    }\n    function flexibleCompare(a, b) {\n        if (!a && !b) {\n            return 0;\n        }\n        if (b == null) {\n            return -1;\n        }\n        if (a == null) {\n            return 1;\n        }\n        if (typeof a === 'string' || typeof b === 'string') {\n            return String(a).localeCompare(String(b));\n        }\n        return a - b;\n    }\n    /* String Utilities\r\n    ----------------------------------------------------------------------------------------------------------------------*/ function padStart(val, len) {\n        let s = String(val);\n        return '000'.substr(0, len - s.length) + s;\n    }\n    function formatWithOrdinals(formatter, args, fallbackText) {\n        if (typeof formatter === 'function') {\n            return formatter(...args);\n        }\n        if (typeof formatter === 'string') {\n            return args.reduce((str, arg, index)=>str.replace('$' + index, arg || ''), formatter);\n        }\n        return fallbackText;\n    }\n    /* Number Utilities\r\n    ----------------------------------------------------------------------------------------------------------------------*/ function compareNumbers(a, b) {\n        return a - b;\n    }\n    function isInt(n) {\n        return n % 1 === 0;\n    }\n    /* FC-specific DOM dimension stuff\r\n    ----------------------------------------------------------------------------------------------------------------------*/ function computeSmallestCellWidth(cellEl) {\n        let allWidthEl = cellEl.querySelector('.fc-scrollgrid-shrink-frame');\n        let contentWidthEl = cellEl.querySelector('.fc-scrollgrid-shrink-cushion');\n        if (!allWidthEl) {\n            throw new Error('needs fc-scrollgrid-shrink-frame className'); // TODO: use const\n        }\n        if (!contentWidthEl) {\n            throw new Error('needs fc-scrollgrid-shrink-cushion className');\n        }\n        return cellEl.getBoundingClientRect().width - allWidthEl.getBoundingClientRect().width + // the cell padding+border\n        contentWidthEl.getBoundingClientRect().width;\n    }\n    const INTERNAL_UNITS = [\n        'years',\n        'months',\n        'days',\n        'milliseconds'\n    ];\n    const PARSE_RE = /^(-?)(?:(\\d+)\\.)?(\\d+):(\\d\\d)(?::(\\d\\d)(?:\\.(\\d\\d\\d))?)?/;\n    // Parsing and Creation\n    function createDuration(input, unit) {\n        if (typeof input === 'string') {\n            return parseString(input);\n        }\n        if (typeof input === 'object' && input) {\n            return parseObject(input);\n        }\n        if (typeof input === 'number') {\n            return parseObject({\n                [unit || 'milliseconds']: input\n            });\n        }\n        return null;\n    }\n    function parseString(s) {\n        let m = PARSE_RE.exec(s);\n        if (m) {\n            let sign = m[1] ? -1 : 1;\n            return {\n                years: 0,\n                months: 0,\n                days: sign * (m[2] ? parseInt(m[2], 10) : 0),\n                milliseconds: sign * ((m[3] ? parseInt(m[3], 10) : 0) * 60 * 60 * 1000 + // hours\n                (m[4] ? parseInt(m[4], 10) : 0) * 60 * 1000 + // minutes\n                (m[5] ? parseInt(m[5], 10) : 0) * 1000 + // seconds\n                (m[6] ? parseInt(m[6], 10) : 0 // ms\n                ))\n            };\n        }\n        return null;\n    }\n    function parseObject(obj) {\n        let duration = {\n            years: obj.years || obj.year || 0,\n            months: obj.months || obj.month || 0,\n            days: obj.days || obj.day || 0,\n            milliseconds: (obj.hours || obj.hour || 0) * 60 * 60 * 1000 + // hours\n            (obj.minutes || obj.minute || 0) * 60 * 1000 + // minutes\n            (obj.seconds || obj.second || 0) * 1000 + // seconds\n            (obj.milliseconds || obj.millisecond || obj.ms || 0)\n        };\n        let weeks = obj.weeks || obj.week;\n        if (weeks) {\n            duration.days += weeks * 7;\n            duration.specifiedWeeks = true;\n        }\n        return duration;\n    }\n    // Equality\n    function durationsEqual(d0, d1) {\n        return d0.years === d1.years && d0.months === d1.months && d0.days === d1.days && d0.milliseconds === d1.milliseconds;\n    }\n    function asCleanDays(dur) {\n        if (!dur.years && !dur.months && !dur.milliseconds) {\n            return dur.days;\n        }\n        return 0;\n    }\n    // Simple Math\n    function addDurations(d0, d1) {\n        return {\n            years: d0.years + d1.years,\n            months: d0.months + d1.months,\n            days: d0.days + d1.days,\n            milliseconds: d0.milliseconds + d1.milliseconds\n        };\n    }\n    function subtractDurations(d1, d0) {\n        return {\n            years: d1.years - d0.years,\n            months: d1.months - d0.months,\n            days: d1.days - d0.days,\n            milliseconds: d1.milliseconds - d0.milliseconds\n        };\n    }\n    function multiplyDuration(d, n) {\n        return {\n            years: d.years * n,\n            months: d.months * n,\n            days: d.days * n,\n            milliseconds: d.milliseconds * n\n        };\n    }\n    // Conversions\n    // \"Rough\" because they are based on average-case Gregorian months/years\n    function asRoughYears(dur) {\n        return asRoughDays(dur) / 365;\n    }\n    function asRoughMonths(dur) {\n        return asRoughDays(dur) / 30;\n    }\n    function asRoughDays(dur) {\n        return asRoughMs(dur) / 864e5;\n    }\n    function asRoughMinutes(dur) {\n        return asRoughMs(dur) / (1000 * 60);\n    }\n    function asRoughSeconds(dur) {\n        return asRoughMs(dur) / 1000;\n    }\n    function asRoughMs(dur) {\n        return dur.years * (365 * 864e5) + dur.months * (30 * 864e5) + dur.days * 864e5 + dur.milliseconds;\n    }\n    // Advanced Math\n    function wholeDivideDurations(numerator, denominator) {\n        let res = null;\n        for(let i = 0; i < INTERNAL_UNITS.length; i += 1){\n            let unit = INTERNAL_UNITS[i];\n            if (denominator[unit]) {\n                let localRes = numerator[unit] / denominator[unit];\n                if (!isInt(localRes) || res !== null && res !== localRes) {\n                    return null;\n                }\n                res = localRes;\n            } else if (numerator[unit]) {\n                // needs to divide by something but can't!\n                return null;\n            }\n        }\n        return res;\n    }\n    function greatestDurationDenominator(dur) {\n        let ms = dur.milliseconds;\n        if (ms) {\n            if (ms % 1000 !== 0) {\n                return {\n                    unit: 'millisecond',\n                    value: ms\n                };\n            }\n            if (ms % (1000 * 60) !== 0) {\n                return {\n                    unit: 'second',\n                    value: ms / 1000\n                };\n            }\n            if (ms % (1000 * 60 * 60) !== 0) {\n                return {\n                    unit: 'minute',\n                    value: ms / (1000 * 60)\n                };\n            }\n            if (ms) {\n                return {\n                    unit: 'hour',\n                    value: ms / (1000 * 60 * 60)\n                };\n            }\n        }\n        if (dur.days) {\n            if (dur.specifiedWeeks && dur.days % 7 === 0) {\n                return {\n                    unit: 'week',\n                    value: dur.days / 7\n                };\n            }\n            return {\n                unit: 'day',\n                value: dur.days\n            };\n        }\n        if (dur.months) {\n            return {\n                unit: 'month',\n                value: dur.months\n            };\n        }\n        if (dur.years) {\n            return {\n                unit: 'year',\n                value: dur.years\n            };\n        }\n        return {\n            unit: 'millisecond',\n            value: 0\n        };\n    }\n    const { hasOwnProperty } = Object.prototype;\n    // Merges an array of objects into a single object.\n    // The second argument allows for an array of property names who's object values will be merged together.\n    function mergeProps(propObjs, complexPropsMap) {\n        let dest = {};\n        if (complexPropsMap) {\n            for(let name in complexPropsMap){\n                if (complexPropsMap[name] === isMaybeObjectsEqual) {\n                    let complexObjs = [];\n                    // collect the trailing object values, stopping when a non-object is discovered\n                    for(let i = propObjs.length - 1; i >= 0; i -= 1){\n                        let val = propObjs[i][name];\n                        if (typeof val === 'object' && val) {\n                            complexObjs.unshift(val);\n                        } else if (val !== undefined) {\n                            dest[name] = val; // if there were no objects, this value will be used\n                            break;\n                        }\n                    }\n                    // if the trailing values were objects, use the merged value\n                    if (complexObjs.length) {\n                        dest[name] = mergeProps(complexObjs);\n                    }\n                }\n            }\n        }\n        // copy values into the destination, going from last to first\n        for(let i = propObjs.length - 1; i >= 0; i -= 1){\n            let props = propObjs[i];\n            for(let name in props){\n                if (!(name in dest)) {\n                    dest[name] = props[name];\n                }\n            }\n        }\n        return dest;\n    }\n    function filterHash(hash, func) {\n        let filtered = {};\n        for(let key in hash){\n            if (func(hash[key], key)) {\n                filtered[key] = hash[key];\n            }\n        }\n        return filtered;\n    }\n    function mapHash(hash, func) {\n        let newHash = {};\n        for(let key in hash){\n            newHash[key] = func(hash[key], key);\n        }\n        return newHash;\n    }\n    function arrayToHash(a) {\n        let hash = {};\n        for (let item of a){\n            hash[item] = true;\n        }\n        return hash;\n    }\n    // TODO: reassess browser support\n    // https://caniuse.com/?search=object.values\n    function hashValuesToArray(obj) {\n        let a = [];\n        for(let key in obj){\n            a.push(obj[key]);\n        }\n        return a;\n    }\n    function isPropsEqual(obj0, obj1) {\n        if (obj0 === obj1) {\n            return true;\n        }\n        for(let key in obj0){\n            if (hasOwnProperty.call(obj0, key)) {\n                if (!(key in obj1)) {\n                    return false;\n                }\n            }\n        }\n        for(let key in obj1){\n            if (hasOwnProperty.call(obj1, key)) {\n                if (obj0[key] !== obj1[key]) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    const HANDLER_RE = /^on[A-Z]/;\n    function isNonHandlerPropsEqual(obj0, obj1) {\n        const keys = getUnequalProps(obj0, obj1);\n        for (let key of keys){\n            if (!HANDLER_RE.test(key)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    function getUnequalProps(obj0, obj1) {\n        let keys = [];\n        for(let key in obj0){\n            if (hasOwnProperty.call(obj0, key)) {\n                if (!(key in obj1)) {\n                    keys.push(key);\n                }\n            }\n        }\n        for(let key in obj1){\n            if (hasOwnProperty.call(obj1, key)) {\n                if (obj0[key] !== obj1[key]) {\n                    keys.push(key);\n                }\n            }\n        }\n        return keys;\n    }\n    function compareObjs(oldProps, newProps) {\n        let equalityFuncs = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n        if (oldProps === newProps) {\n            return true;\n        }\n        for(let key in newProps){\n            if (key in oldProps && isObjValsEqual(oldProps[key], newProps[key], equalityFuncs[key])) ;\n            else {\n                return false;\n            }\n        }\n        // check for props that were omitted in the new\n        for(let key in oldProps){\n            if (!(key in newProps)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /*\r\n    assumed \"true\" equality for handler names like \"onReceiveSomething\"\r\n    */ function isObjValsEqual(val0, val1, comparator) {\n        if (val0 === val1 || comparator === true) {\n            return true;\n        }\n        if (comparator) {\n            return comparator(val0, val1);\n        }\n        return false;\n    }\n    function collectFromHash(hash) {\n        let startIndex = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, endIndex = arguments.length > 2 ? arguments[2] : void 0, step = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1;\n        let res = [];\n        if (endIndex == null) {\n            endIndex = Object.keys(hash).length;\n        }\n        for(let i = startIndex; i < endIndex; i += step){\n            let val = hash[i];\n            if (val !== undefined) {\n                res.push(val);\n            }\n        }\n        return res;\n    }\n    // TODO: new util arrayify?\n    function removeExact(array, exactVal) {\n        let removeCnt = 0;\n        let i = 0;\n        while(i < array.length){\n            if (array[i] === exactVal) {\n                array.splice(i, 1);\n                removeCnt += 1;\n            } else {\n                i += 1;\n            }\n        }\n        return removeCnt;\n    }\n    function isArraysEqual(a0, a1, equalityFunc) {\n        if (a0 === a1) {\n            return true;\n        }\n        let len = a0.length;\n        let i;\n        if (len !== a1.length) {\n            return false;\n        }\n        for(i = 0; i < len; i += 1){\n            if (!(equalityFunc ? equalityFunc(a0[i], a1[i]) : a0[i] === a1[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    const DAY_IDS = [\n        'sun',\n        'mon',\n        'tue',\n        'wed',\n        'thu',\n        'fri',\n        'sat'\n    ];\n    // Adding\n    function addWeeks(m, n) {\n        let a = dateToUtcArray(m);\n        a[2] += n * 7;\n        return arrayToUtcDate(a);\n    }\n    function addDays(m, n) {\n        let a = dateToUtcArray(m);\n        a[2] += n;\n        return arrayToUtcDate(a);\n    }\n    function addMs(m, n) {\n        let a = dateToUtcArray(m);\n        a[6] += n;\n        return arrayToUtcDate(a);\n    }\n    // Diffing (all return floats)\n    // TODO: why not use ranges?\n    function diffWeeks(m0, m1) {\n        return diffDays(m0, m1) / 7;\n    }\n    function diffDays(m0, m1) {\n        return (m1.valueOf() - m0.valueOf()) / (1000 * 60 * 60 * 24);\n    }\n    function diffHours(m0, m1) {\n        return (m1.valueOf() - m0.valueOf()) / (1000 * 60 * 60);\n    }\n    function diffMinutes(m0, m1) {\n        return (m1.valueOf() - m0.valueOf()) / (1000 * 60);\n    }\n    function diffSeconds(m0, m1) {\n        return (m1.valueOf() - m0.valueOf()) / 1000;\n    }\n    function diffDayAndTime(m0, m1) {\n        let m0day = startOfDay(m0);\n        let m1day = startOfDay(m1);\n        return {\n            years: 0,\n            months: 0,\n            days: Math.round(diffDays(m0day, m1day)),\n            milliseconds: m1.valueOf() - m1day.valueOf() - (m0.valueOf() - m0day.valueOf())\n        };\n    }\n    // Diffing Whole Units\n    function diffWholeWeeks(m0, m1) {\n        let d = diffWholeDays(m0, m1);\n        if (d !== null && d % 7 === 0) {\n            return d / 7;\n        }\n        return null;\n    }\n    function diffWholeDays(m0, m1) {\n        if (timeAsMs(m0) === timeAsMs(m1)) {\n            return Math.round(diffDays(m0, m1));\n        }\n        return null;\n    }\n    // Start-Of\n    function startOfDay(m) {\n        return arrayToUtcDate([\n            m.getUTCFullYear(),\n            m.getUTCMonth(),\n            m.getUTCDate()\n        ]);\n    }\n    function startOfHour(m) {\n        return arrayToUtcDate([\n            m.getUTCFullYear(),\n            m.getUTCMonth(),\n            m.getUTCDate(),\n            m.getUTCHours()\n        ]);\n    }\n    function startOfMinute(m) {\n        return arrayToUtcDate([\n            m.getUTCFullYear(),\n            m.getUTCMonth(),\n            m.getUTCDate(),\n            m.getUTCHours(),\n            m.getUTCMinutes()\n        ]);\n    }\n    function startOfSecond(m) {\n        return arrayToUtcDate([\n            m.getUTCFullYear(),\n            m.getUTCMonth(),\n            m.getUTCDate(),\n            m.getUTCHours(),\n            m.getUTCMinutes(),\n            m.getUTCSeconds()\n        ]);\n    }\n    // Week Computation\n    function weekOfYear(marker, dow, doy) {\n        let y = marker.getUTCFullYear();\n        let w = weekOfGivenYear(marker, y, dow, doy);\n        if (w < 1) {\n            return weekOfGivenYear(marker, y - 1, dow, doy);\n        }\n        let nextW = weekOfGivenYear(marker, y + 1, dow, doy);\n        if (nextW >= 1) {\n            return Math.min(w, nextW);\n        }\n        return w;\n    }\n    function weekOfGivenYear(marker, year, dow, doy) {\n        let firstWeekStart = arrayToUtcDate([\n            year,\n            0,\n            1 + firstWeekOffset(year, dow, doy)\n        ]);\n        let dayStart = startOfDay(marker);\n        let days = Math.round(diffDays(firstWeekStart, dayStart));\n        return Math.floor(days / 7) + 1; // zero-indexed\n    }\n    // start-of-first-week - start-of-year\n    function firstWeekOffset(year, dow, doy) {\n        // first-week day -- which january is always in the first week (4 for iso, 1 for other)\n        let fwd = 7 + dow - doy;\n        // first-week day local weekday -- which local weekday is fwd\n        let fwdlw = (7 + arrayToUtcDate([\n            year,\n            0,\n            fwd\n        ]).getUTCDay() - dow) % 7;\n        return -fwdlw + fwd - 1;\n    }\n    // Array Conversion\n    function dateToLocalArray(date) {\n        return [\n            date.getFullYear(),\n            date.getMonth(),\n            date.getDate(),\n            date.getHours(),\n            date.getMinutes(),\n            date.getSeconds(),\n            date.getMilliseconds()\n        ];\n    }\n    function arrayToLocalDate(a) {\n        return new Date(a[0], a[1] || 0, a[2] == null ? 1 : a[2], a[3] || 0, a[4] || 0, a[5] || 0);\n    }\n    function dateToUtcArray(date) {\n        return [\n            date.getUTCFullYear(),\n            date.getUTCMonth(),\n            date.getUTCDate(),\n            date.getUTCHours(),\n            date.getUTCMinutes(),\n            date.getUTCSeconds(),\n            date.getUTCMilliseconds()\n        ];\n    }\n    function arrayToUtcDate(a) {\n        // according to web standards (and Safari), a month index is required.\n        // massage if only given a year.\n        if (a.length === 1) {\n            a = a.concat([\n                0\n            ]);\n        }\n        return new Date(Date.UTC(...a));\n    }\n    // Other Utils\n    function isValidDate(m) {\n        return !isNaN(m.valueOf());\n    }\n    function timeAsMs(m) {\n        return m.getUTCHours() * 1000 * 60 * 60 + m.getUTCMinutes() * 1000 * 60 + m.getUTCSeconds() * 1000 + m.getUTCMilliseconds();\n    }\n    // timeZoneOffset is in minutes\n    function buildIsoString(marker, timeZoneOffset) {\n        let stripZeroTime = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;\n        let s = marker.toISOString();\n        s = s.replace('.000', '');\n        if (stripZeroTime) {\n            s = s.replace('T00:00:00Z', '');\n        }\n        if (s.length > 10) {\n            if (timeZoneOffset == null) {\n                s = s.replace('Z', '');\n            } else if (timeZoneOffset !== 0) {\n                s = s.replace('Z', formatTimeZoneOffset(timeZoneOffset, true));\n            }\n        // otherwise, its UTC-0 and we want to keep the Z\n        }\n        return s;\n    }\n    // formats the date, but with no time part\n    // TODO: somehow merge with buildIsoString and stripZeroTime\n    // TODO: rename. omit \"string\"\n    function formatDayString(marker) {\n        return marker.toISOString().replace(/T.*$/, '');\n    }\n    function formatIsoMonthStr(marker) {\n        return marker.toISOString().match(/^\\d{4}-\\d{2}/)[0];\n    }\n    // TODO: use Date::toISOString and use everything after the T?\n    function formatIsoTimeString(marker) {\n        return padStart(marker.getUTCHours(), 2) + ':' + padStart(marker.getUTCMinutes(), 2) + ':' + padStart(marker.getUTCSeconds(), 2);\n    }\n    function formatTimeZoneOffset(minutes) {\n        let doIso = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n        let sign = minutes < 0 ? '-' : '+';\n        let abs = Math.abs(minutes);\n        let hours = Math.floor(abs / 60);\n        let mins = Math.round(abs % 60);\n        if (doIso) {\n            return \"\".concat(sign + padStart(hours, 2), \":\").concat(padStart(mins, 2));\n        }\n        return \"GMT\".concat(sign).concat(hours).concat(mins ? \":\".concat(padStart(mins, 2)) : '');\n    }\n    function memoize(workerFunc, resEquality, teardownFunc) {\n        let currentArgs;\n        let currentRes;\n        return function() {\n            for(var _len = arguments.length, newArgs = new Array(_len), _key = 0; _key < _len; _key++){\n                newArgs[_key] = arguments[_key];\n            }\n            if (!currentArgs) {\n                currentRes = workerFunc.apply(this, newArgs);\n            } else if (!isArraysEqual(currentArgs, newArgs)) {\n                if (teardownFunc) {\n                    teardownFunc(currentRes);\n                }\n                let res = workerFunc.apply(this, newArgs);\n                if (!resEquality || !resEquality(res, currentRes)) {\n                    currentRes = res;\n                }\n            }\n            currentArgs = newArgs;\n            return currentRes;\n        };\n    }\n    function memoizeObjArg(workerFunc, resEquality, teardownFunc) {\n        let currentArg;\n        let currentRes;\n        return (newArg)=>{\n            if (!currentArg) {\n                currentRes = workerFunc.call(this, newArg);\n            } else if (!isPropsEqual(currentArg, newArg)) {\n                if (teardownFunc) {\n                    teardownFunc(currentRes);\n                }\n                let res = workerFunc.call(this, newArg);\n                if (!resEquality || !resEquality(res, currentRes)) {\n                    currentRes = res;\n                }\n            }\n            currentArg = newArg;\n            return currentRes;\n        };\n    }\n    function memoizeArraylike(workerFunc, resEquality, teardownFunc) {\n        let currentArgSets = [];\n        let currentResults = [];\n        return (newArgSets)=>{\n            let currentLen = currentArgSets.length;\n            let newLen = newArgSets.length;\n            let i = 0;\n            for(; i < currentLen; i += 1){\n                if (!newArgSets[i]) {\n                    if (teardownFunc) {\n                        teardownFunc(currentResults[i]);\n                    }\n                } else if (!isArraysEqual(currentArgSets[i], newArgSets[i])) {\n                    if (teardownFunc) {\n                        teardownFunc(currentResults[i]);\n                    }\n                    let res = workerFunc.apply(this, newArgSets[i]);\n                    if (!resEquality || !resEquality(res, currentResults[i])) {\n                        currentResults[i] = res;\n                    }\n                }\n            }\n            for(; i < newLen; i += 1){\n                currentResults[i] = workerFunc.apply(this, newArgSets[i]);\n            }\n            currentArgSets = newArgSets;\n            currentResults.splice(newLen); // remove excess\n            return currentResults;\n        };\n    }\n    function memoizeHashlike(workerFunc, resEquality, teardownFunc) {\n        let currentArgHash = {};\n        let currentResHash = {};\n        return (newArgHash)=>{\n            let newResHash = {};\n            for(let key in newArgHash){\n                if (!currentResHash[key]) {\n                    newResHash[key] = workerFunc.apply(this, newArgHash[key]);\n                } else if (!isArraysEqual(currentArgHash[key], newArgHash[key])) {\n                    if (teardownFunc) {\n                        teardownFunc(currentResHash[key]);\n                    }\n                    let res = workerFunc.apply(this, newArgHash[key]);\n                    newResHash[key] = resEquality && resEquality(res, currentResHash[key]) ? currentResHash[key] : res;\n                } else {\n                    newResHash[key] = currentResHash[key];\n                }\n            }\n            currentArgHash = newArgHash;\n            currentResHash = newResHash;\n            return newResHash;\n        };\n    }\n    const EXTENDED_SETTINGS_AND_SEVERITIES = {\n        week: 3,\n        separator: 0,\n        omitZeroMinute: 0,\n        meridiem: 0,\n        omitCommas: 0\n    };\n    const STANDARD_DATE_PROP_SEVERITIES = {\n        timeZoneName: 7,\n        era: 6,\n        year: 5,\n        month: 4,\n        day: 2,\n        weekday: 2,\n        hour: 1,\n        minute: 1,\n        second: 1\n    };\n    const MERIDIEM_RE = /\\s*([ap])\\.?m\\.?/i; // eats up leading spaces too\n    const COMMA_RE = /,/g; // we need re for globalness\n    const MULTI_SPACE_RE = /\\s+/g;\n    const LTR_RE = /\\u200e/g; // control character\n    const UTC_RE = /UTC|GMT/;\n    class NativeFormatter {\n        format(date, context) {\n            return this.buildFormattingFunc(this.standardDateProps, this.extendedSettings, context)(date);\n        }\n        formatRange(start, end, context, betterDefaultSeparator) {\n            let { standardDateProps, extendedSettings } = this;\n            let diffSeverity = computeMarkerDiffSeverity(start.marker, end.marker, context.calendarSystem);\n            if (!diffSeverity) {\n                return this.format(start, context);\n            }\n            let biggestUnitForPartial = diffSeverity;\n            if (biggestUnitForPartial > 1 && // the two dates are different in a way that's larger scale than time\n            (standardDateProps.year === 'numeric' || standardDateProps.year === '2-digit') && (standardDateProps.month === 'numeric' || standardDateProps.month === '2-digit') && (standardDateProps.day === 'numeric' || standardDateProps.day === '2-digit')) {\n                biggestUnitForPartial = 1; // make it look like the dates are only different in terms of time\n            }\n            let full0 = this.format(start, context);\n            let full1 = this.format(end, context);\n            if (full0 === full1) {\n                return full0;\n            }\n            let partialDateProps = computePartialFormattingOptions(standardDateProps, biggestUnitForPartial);\n            let partialFormattingFunc = buildFormattingFunc(partialDateProps, extendedSettings, context);\n            let partial0 = partialFormattingFunc(start);\n            let partial1 = partialFormattingFunc(end);\n            let insertion = findCommonInsertion(full0, partial0, full1, partial1);\n            let separator = extendedSettings.separator || betterDefaultSeparator || context.defaultSeparator || '';\n            if (insertion) {\n                return insertion.before + partial0 + separator + partial1 + insertion.after;\n            }\n            return full0 + separator + full1;\n        }\n        getLargestUnit() {\n            switch(this.severity){\n                case 7:\n                case 6:\n                case 5:\n                    return 'year';\n                case 4:\n                    return 'month';\n                case 3:\n                    return 'week';\n                case 2:\n                    return 'day';\n                default:\n                    return 'time'; // really?\n            }\n        }\n        constructor(formatSettings){\n            let standardDateProps = {};\n            let extendedSettings = {};\n            let severity = 0;\n            for(let name in formatSettings){\n                if (name in EXTENDED_SETTINGS_AND_SEVERITIES) {\n                    extendedSettings[name] = formatSettings[name];\n                    severity = Math.max(EXTENDED_SETTINGS_AND_SEVERITIES[name], severity);\n                } else {\n                    standardDateProps[name] = formatSettings[name];\n                    if (name in STANDARD_DATE_PROP_SEVERITIES) {\n                        severity = Math.max(STANDARD_DATE_PROP_SEVERITIES[name], severity);\n                    }\n                }\n            }\n            this.standardDateProps = standardDateProps;\n            this.extendedSettings = extendedSettings;\n            this.severity = severity;\n            this.buildFormattingFunc = memoize(buildFormattingFunc);\n        }\n    }\n    function buildFormattingFunc(standardDateProps, extendedSettings, context) {\n        let standardDatePropCnt = Object.keys(standardDateProps).length;\n        if (standardDatePropCnt === 1 && standardDateProps.timeZoneName === 'short') {\n            return (date)=>formatTimeZoneOffset(date.timeZoneOffset);\n        }\n        if (standardDatePropCnt === 0 && extendedSettings.week) {\n            return (date)=>formatWeekNumber(context.computeWeekNumber(date.marker), context.weekText, context.weekTextLong, context.locale, extendedSettings.week);\n        }\n        return buildNativeFormattingFunc(standardDateProps, extendedSettings, context);\n    }\n    function buildNativeFormattingFunc(standardDateProps, extendedSettings, context) {\n        standardDateProps = Object.assign({}, standardDateProps); // copy\n        extendedSettings = Object.assign({}, extendedSettings); // copy\n        sanitizeSettings(standardDateProps, extendedSettings);\n        standardDateProps.timeZone = 'UTC'; // we leverage the only guaranteed timeZone for our UTC markers\n        let normalFormat = new Intl.DateTimeFormat(context.locale.codes, standardDateProps);\n        let zeroFormat; // needed?\n        if (extendedSettings.omitZeroMinute) {\n            let zeroProps = Object.assign({}, standardDateProps);\n            delete zeroProps.minute; // seconds and ms were already considered in sanitizeSettings\n            zeroFormat = new Intl.DateTimeFormat(context.locale.codes, zeroProps);\n        }\n        return (date)=>{\n            let { marker } = date;\n            let format;\n            if (zeroFormat && !marker.getUTCMinutes()) {\n                format = zeroFormat;\n            } else {\n                format = normalFormat;\n            }\n            let s = format.format(marker);\n            return postProcess(s, date, standardDateProps, extendedSettings, context);\n        };\n    }\n    function sanitizeSettings(standardDateProps, extendedSettings) {\n        // deal with a browser inconsistency where formatting the timezone\n        // requires that the hour/minute be present.\n        if (standardDateProps.timeZoneName) {\n            if (!standardDateProps.hour) {\n                standardDateProps.hour = '2-digit';\n            }\n            if (!standardDateProps.minute) {\n                standardDateProps.minute = '2-digit';\n            }\n        }\n        // only support short timezone names\n        if (standardDateProps.timeZoneName === 'long') {\n            standardDateProps.timeZoneName = 'short';\n        }\n        // if requesting to display seconds, MUST display minutes\n        if (extendedSettings.omitZeroMinute && (standardDateProps.second || standardDateProps.millisecond)) {\n            delete extendedSettings.omitZeroMinute;\n        }\n    }\n    function postProcess(s, date, standardDateProps, extendedSettings, context) {\n        s = s.replace(LTR_RE, ''); // remove left-to-right control chars. do first. good for other regexes\n        if (standardDateProps.timeZoneName === 'short') {\n            s = injectTzoStr(s, context.timeZone === 'UTC' || date.timeZoneOffset == null ? 'UTC' : formatTimeZoneOffset(date.timeZoneOffset));\n        }\n        if (extendedSettings.omitCommas) {\n            s = s.replace(COMMA_RE, '').trim();\n        }\n        if (extendedSettings.omitZeroMinute) {\n            s = s.replace(':00', ''); // zeroFormat doesn't always achieve this\n        }\n        // ^ do anything that might create adjacent spaces before this point,\n        // because MERIDIEM_RE likes to eat up loading spaces\n        if (extendedSettings.meridiem === false) {\n            s = s.replace(MERIDIEM_RE, '').trim();\n        } else if (extendedSettings.meridiem === 'narrow') {\n            s = s.replace(MERIDIEM_RE, (m0, m1)=>m1.toLocaleLowerCase());\n        } else if (extendedSettings.meridiem === 'short') {\n            s = s.replace(MERIDIEM_RE, (m0, m1)=>\"\".concat(m1.toLocaleLowerCase(), \"m\"));\n        } else if (extendedSettings.meridiem === 'lowercase') {\n            s = s.replace(MERIDIEM_RE, (m0)=>m0.toLocaleLowerCase());\n        }\n        s = s.replace(MULTI_SPACE_RE, ' ');\n        s = s.trim();\n        return s;\n    }\n    function injectTzoStr(s, tzoStr) {\n        let replaced = false;\n        s = s.replace(UTC_RE, ()=>{\n            replaced = true;\n            return tzoStr;\n        });\n        // IE11 doesn't include UTC/GMT in the original string, so append to end\n        if (!replaced) {\n            s += \" \".concat(tzoStr);\n        }\n        return s;\n    }\n    function formatWeekNumber(num, weekText, weekTextLong, locale, display) {\n        let parts = [];\n        if (display === 'long') {\n            parts.push(weekTextLong);\n        } else if (display === 'short' || display === 'narrow') {\n            parts.push(weekText);\n        }\n        if (display === 'long' || display === 'short') {\n            parts.push(' ');\n        }\n        parts.push(locale.simpleNumberFormat.format(num));\n        if (locale.options.direction === 'rtl') {\n            parts.reverse();\n        }\n        return parts.join('');\n    }\n    // Range Formatting Utils\n    // 0 = exactly the same\n    // 1 = different by time\n    // and bigger\n    function computeMarkerDiffSeverity(d0, d1, ca) {\n        if (ca.getMarkerYear(d0) !== ca.getMarkerYear(d1)) {\n            return 5;\n        }\n        if (ca.getMarkerMonth(d0) !== ca.getMarkerMonth(d1)) {\n            return 4;\n        }\n        if (ca.getMarkerDay(d0) !== ca.getMarkerDay(d1)) {\n            return 2;\n        }\n        if (timeAsMs(d0) !== timeAsMs(d1)) {\n            return 1;\n        }\n        return 0;\n    }\n    function computePartialFormattingOptions(options, biggestUnit) {\n        let partialOptions = {};\n        for(let name in options){\n            if (!(name in STANDARD_DATE_PROP_SEVERITIES) || // not a date part prop (like timeZone)\n            STANDARD_DATE_PROP_SEVERITIES[name] <= biggestUnit) {\n                partialOptions[name] = options[name];\n            }\n        }\n        return partialOptions;\n    }\n    function findCommonInsertion(full0, partial0, full1, partial1) {\n        let i0 = 0;\n        while(i0 < full0.length){\n            let found0 = full0.indexOf(partial0, i0);\n            if (found0 === -1) {\n                break;\n            }\n            let before0 = full0.substr(0, found0);\n            i0 = found0 + partial0.length;\n            let after0 = full0.substr(i0);\n            let i1 = 0;\n            while(i1 < full1.length){\n                let found1 = full1.indexOf(partial1, i1);\n                if (found1 === -1) {\n                    break;\n                }\n                let before1 = full1.substr(0, found1);\n                i1 = found1 + partial1.length;\n                let after1 = full1.substr(i1);\n                if (before0 === before1 && after0 === after1) {\n                    return {\n                        before: before0,\n                        after: after0\n                    };\n                }\n            }\n        }\n        return null;\n    }\n    function expandZonedMarker(dateInfo, calendarSystem) {\n        let a = calendarSystem.markerToArray(dateInfo.marker);\n        return {\n            marker: dateInfo.marker,\n            timeZoneOffset: dateInfo.timeZoneOffset,\n            array: a,\n            year: a[0],\n            month: a[1],\n            day: a[2],\n            hour: a[3],\n            minute: a[4],\n            second: a[5],\n            millisecond: a[6]\n        };\n    }\n    function createVerboseFormattingArg(start, end, context, betterDefaultSeparator) {\n        let startInfo = expandZonedMarker(start, context.calendarSystem);\n        let endInfo = end ? expandZonedMarker(end, context.calendarSystem) : null;\n        return {\n            date: startInfo,\n            start: startInfo,\n            end: endInfo,\n            timeZone: context.timeZone,\n            localeCodes: context.locale.codes,\n            defaultSeparator: betterDefaultSeparator || context.defaultSeparator\n        };\n    }\n    /*\r\n    TODO: fix the terminology of \"formatter\" vs \"formatting func\"\r\n    */ /*\r\n    At the time of instantiation, this object does not know which cmd-formatting system it will use.\r\n    It receives this at the time of formatting, as a setting.\r\n    */ class CmdFormatter {\n        format(date, context, betterDefaultSeparator) {\n            return context.cmdFormatter(this.cmdStr, createVerboseFormattingArg(date, null, context, betterDefaultSeparator));\n        }\n        formatRange(start, end, context, betterDefaultSeparator) {\n            return context.cmdFormatter(this.cmdStr, createVerboseFormattingArg(start, end, context, betterDefaultSeparator));\n        }\n        constructor(cmdStr){\n            this.cmdStr = cmdStr;\n        }\n    }\n    class FuncFormatter {\n        format(date, context, betterDefaultSeparator) {\n            return this.func(createVerboseFormattingArg(date, null, context, betterDefaultSeparator));\n        }\n        formatRange(start, end, context, betterDefaultSeparator) {\n            return this.func(createVerboseFormattingArg(start, end, context, betterDefaultSeparator));\n        }\n        constructor(func){\n            this.func = func;\n        }\n    }\n    function createFormatter(input) {\n        if (typeof input === 'object' && input) {\n            return new NativeFormatter(input);\n        }\n        if (typeof input === 'string') {\n            return new CmdFormatter(input);\n        }\n        if (typeof input === 'function') {\n            return new FuncFormatter(input);\n        }\n        return null;\n    }\n    // base options\n    // ------------\n    const BASE_OPTION_REFINERS = {\n        navLinkDayClick: identity,\n        navLinkWeekClick: identity,\n        duration: createDuration,\n        bootstrapFontAwesome: identity,\n        buttonIcons: identity,\n        customButtons: identity,\n        defaultAllDayEventDuration: createDuration,\n        defaultTimedEventDuration: createDuration,\n        nextDayThreshold: createDuration,\n        scrollTime: createDuration,\n        scrollTimeReset: Boolean,\n        slotMinTime: createDuration,\n        slotMaxTime: createDuration,\n        dayPopoverFormat: createFormatter,\n        slotDuration: createDuration,\n        snapDuration: createDuration,\n        headerToolbar: identity,\n        footerToolbar: identity,\n        defaultRangeSeparator: String,\n        titleRangeSeparator: String,\n        forceEventDuration: Boolean,\n        dayHeaders: Boolean,\n        dayHeaderFormat: createFormatter,\n        dayHeaderClassNames: identity,\n        dayHeaderContent: identity,\n        dayHeaderDidMount: identity,\n        dayHeaderWillUnmount: identity,\n        dayCellClassNames: identity,\n        dayCellContent: identity,\n        dayCellDidMount: identity,\n        dayCellWillUnmount: identity,\n        initialView: String,\n        aspectRatio: Number,\n        weekends: Boolean,\n        weekNumberCalculation: identity,\n        weekNumbers: Boolean,\n        weekNumberClassNames: identity,\n        weekNumberContent: identity,\n        weekNumberDidMount: identity,\n        weekNumberWillUnmount: identity,\n        editable: Boolean,\n        viewClassNames: identity,\n        viewDidMount: identity,\n        viewWillUnmount: identity,\n        nowIndicator: Boolean,\n        nowIndicatorClassNames: identity,\n        nowIndicatorContent: identity,\n        nowIndicatorDidMount: identity,\n        nowIndicatorWillUnmount: identity,\n        showNonCurrentDates: Boolean,\n        lazyFetching: Boolean,\n        startParam: String,\n        endParam: String,\n        timeZoneParam: String,\n        timeZone: String,\n        locales: identity,\n        locale: identity,\n        themeSystem: String,\n        dragRevertDuration: Number,\n        dragScroll: Boolean,\n        allDayMaintainDuration: Boolean,\n        unselectAuto: Boolean,\n        dropAccept: identity,\n        eventOrder: parseFieldSpecs,\n        eventOrderStrict: Boolean,\n        handleWindowResize: Boolean,\n        windowResizeDelay: Number,\n        longPressDelay: Number,\n        eventDragMinDistance: Number,\n        expandRows: Boolean,\n        height: identity,\n        contentHeight: identity,\n        direction: String,\n        weekNumberFormat: createFormatter,\n        eventResizableFromStart: Boolean,\n        displayEventTime: Boolean,\n        displayEventEnd: Boolean,\n        weekText: String,\n        weekTextLong: String,\n        progressiveEventRendering: Boolean,\n        businessHours: identity,\n        initialDate: identity,\n        now: identity,\n        eventDataTransform: identity,\n        stickyHeaderDates: identity,\n        stickyFooterScrollbar: identity,\n        viewHeight: identity,\n        defaultAllDay: Boolean,\n        eventSourceFailure: identity,\n        eventSourceSuccess: identity,\n        eventDisplay: String,\n        eventStartEditable: Boolean,\n        eventDurationEditable: Boolean,\n        eventOverlap: identity,\n        eventConstraint: identity,\n        eventAllow: identity,\n        eventBackgroundColor: String,\n        eventBorderColor: String,\n        eventTextColor: String,\n        eventColor: String,\n        eventClassNames: identity,\n        eventContent: identity,\n        eventDidMount: identity,\n        eventWillUnmount: identity,\n        selectConstraint: identity,\n        selectOverlap: identity,\n        selectAllow: identity,\n        droppable: Boolean,\n        unselectCancel: String,\n        slotLabelFormat: identity,\n        slotLaneClassNames: identity,\n        slotLaneContent: identity,\n        slotLaneDidMount: identity,\n        slotLaneWillUnmount: identity,\n        slotLabelClassNames: identity,\n        slotLabelContent: identity,\n        slotLabelDidMount: identity,\n        slotLabelWillUnmount: identity,\n        dayMaxEvents: identity,\n        dayMaxEventRows: identity,\n        dayMinWidth: Number,\n        slotLabelInterval: createDuration,\n        allDayText: String,\n        allDayClassNames: identity,\n        allDayContent: identity,\n        allDayDidMount: identity,\n        allDayWillUnmount: identity,\n        slotMinWidth: Number,\n        navLinks: Boolean,\n        eventTimeFormat: createFormatter,\n        rerenderDelay: Number,\n        moreLinkText: identity,\n        moreLinkHint: identity,\n        selectMinDistance: Number,\n        selectable: Boolean,\n        selectLongPressDelay: Number,\n        eventLongPressDelay: Number,\n        selectMirror: Boolean,\n        eventMaxStack: Number,\n        eventMinHeight: Number,\n        eventMinWidth: Number,\n        eventShortHeight: Number,\n        slotEventOverlap: Boolean,\n        plugins: identity,\n        firstDay: Number,\n        dayCount: Number,\n        dateAlignment: String,\n        dateIncrement: createDuration,\n        hiddenDays: identity,\n        fixedWeekCount: Boolean,\n        validRange: identity,\n        visibleRange: identity,\n        titleFormat: identity,\n        eventInteractive: Boolean,\n        // only used by list-view, but languages define the value, so we need it in base options\n        noEventsText: String,\n        viewHint: identity,\n        navLinkHint: identity,\n        closeHint: String,\n        timeHint: String,\n        eventHint: String,\n        moreLinkClick: identity,\n        moreLinkClassNames: identity,\n        moreLinkContent: identity,\n        moreLinkDidMount: identity,\n        moreLinkWillUnmount: identity,\n        monthStartFormat: createFormatter,\n        // for connectors\n        // (can't be part of plugin system b/c must be provided at runtime)\n        handleCustomRendering: identity,\n        customRenderingMetaMap: identity,\n        customRenderingReplacesEl: Boolean\n    };\n    // do NOT give a type here. need `typeof BASE_OPTION_DEFAULTS` to give real results.\n    // raw values.\n    const BASE_OPTION_DEFAULTS = {\n        eventDisplay: 'auto',\n        defaultRangeSeparator: ' - ',\n        titleRangeSeparator: ' \\u2013 ',\n        defaultTimedEventDuration: '01:00:00',\n        defaultAllDayEventDuration: {\n            day: 1\n        },\n        forceEventDuration: false,\n        nextDayThreshold: '00:00:00',\n        dayHeaders: true,\n        initialView: '',\n        aspectRatio: 1.35,\n        headerToolbar: {\n            start: 'title',\n            center: '',\n            end: 'today prev,next'\n        },\n        weekends: true,\n        weekNumbers: false,\n        weekNumberCalculation: 'local',\n        editable: false,\n        nowIndicator: false,\n        scrollTime: '06:00:00',\n        scrollTimeReset: true,\n        slotMinTime: '00:00:00',\n        slotMaxTime: '24:00:00',\n        showNonCurrentDates: true,\n        lazyFetching: true,\n        startParam: 'start',\n        endParam: 'end',\n        timeZoneParam: 'timeZone',\n        timeZone: 'local',\n        locales: [],\n        locale: '',\n        themeSystem: 'standard',\n        dragRevertDuration: 500,\n        dragScroll: true,\n        allDayMaintainDuration: false,\n        unselectAuto: true,\n        dropAccept: '*',\n        eventOrder: 'start,-duration,allDay,title',\n        dayPopoverFormat: {\n            month: 'long',\n            day: 'numeric',\n            year: 'numeric'\n        },\n        handleWindowResize: true,\n        windowResizeDelay: 100,\n        longPressDelay: 1000,\n        eventDragMinDistance: 5,\n        expandRows: false,\n        navLinks: false,\n        selectable: false,\n        eventMinHeight: 15,\n        eventMinWidth: 30,\n        eventShortHeight: 30,\n        monthStartFormat: {\n            month: 'long',\n            day: 'numeric'\n        }\n    };\n    // calendar listeners\n    // ------------------\n    const CALENDAR_LISTENER_REFINERS = {\n        datesSet: identity,\n        eventsSet: identity,\n        eventAdd: identity,\n        eventChange: identity,\n        eventRemove: identity,\n        windowResize: identity,\n        eventClick: identity,\n        eventMouseEnter: identity,\n        eventMouseLeave: identity,\n        select: identity,\n        unselect: identity,\n        loading: identity,\n        // internal\n        _unmount: identity,\n        _beforeprint: identity,\n        _afterprint: identity,\n        _noEventDrop: identity,\n        _noEventResize: identity,\n        _resize: identity,\n        _scrollRequest: identity\n    };\n    // calendar-specific options\n    // -------------------------\n    const CALENDAR_OPTION_REFINERS = {\n        buttonText: identity,\n        buttonHints: identity,\n        views: identity,\n        plugins: identity,\n        initialEvents: identity,\n        events: identity,\n        eventSources: identity\n    };\n    const COMPLEX_OPTION_COMPARATORS = {\n        headerToolbar: isMaybeObjectsEqual,\n        footerToolbar: isMaybeObjectsEqual,\n        buttonText: isMaybeObjectsEqual,\n        buttonHints: isMaybeObjectsEqual,\n        buttonIcons: isMaybeObjectsEqual,\n        dateIncrement: isMaybeObjectsEqual,\n        plugins: isMaybeArraysEqual,\n        events: isMaybeArraysEqual,\n        eventSources: isMaybeArraysEqual,\n        ['resources']: isMaybeArraysEqual\n    };\n    function isMaybeObjectsEqual(a, b) {\n        if (typeof a === 'object' && typeof b === 'object' && a && b) {\n            return isPropsEqual(a, b);\n        }\n        return a === b;\n    }\n    function isMaybeArraysEqual(a, b) {\n        if (Array.isArray(a) && Array.isArray(b)) {\n            return isArraysEqual(a, b);\n        }\n        return a === b;\n    }\n    // view-specific options\n    // ---------------------\n    const VIEW_OPTION_REFINERS = {\n        type: String,\n        component: identity,\n        buttonText: String,\n        buttonTextKey: String,\n        dateProfileGeneratorClass: identity,\n        usesMinMaxTime: Boolean,\n        classNames: identity,\n        content: identity,\n        didMount: identity,\n        willUnmount: identity\n    };\n    // util funcs\n    // ----------------------------------------------------------------------------------------------------\n    function mergeRawOptions(optionSets) {\n        return mergeProps(optionSets, COMPLEX_OPTION_COMPARATORS);\n    }\n    function refineProps(input, refiners) {\n        let refined = {};\n        let extra = {};\n        for(let propName in refiners){\n            if (propName in input) {\n                refined[propName] = refiners[propName](input[propName]);\n            }\n        }\n        for(let propName in input){\n            if (!(propName in refiners)) {\n                extra[propName] = input[propName];\n            }\n        }\n        return {\n            refined,\n            extra\n        };\n    }\n    function identity(raw) {\n        return raw;\n    }\n    function createEventInstance(defId, range, forcedStartTzo, forcedEndTzo) {\n        return {\n            instanceId: guid(),\n            defId,\n            range,\n            forcedStartTzo: forcedStartTzo == null ? null : forcedStartTzo,\n            forcedEndTzo: forcedEndTzo == null ? null : forcedEndTzo\n        };\n    }\n    function parseRecurring(refined, defaultAllDay, dateEnv, recurringTypes) {\n        for(let i = 0; i < recurringTypes.length; i += 1){\n            let parsed = recurringTypes[i].parse(refined, dateEnv);\n            if (parsed) {\n                let { allDay } = refined;\n                if (allDay == null) {\n                    allDay = defaultAllDay;\n                    if (allDay == null) {\n                        allDay = parsed.allDayGuess;\n                        if (allDay == null) {\n                            allDay = false;\n                        }\n                    }\n                }\n                return {\n                    allDay,\n                    duration: parsed.duration,\n                    typeData: parsed.typeData,\n                    typeId: i\n                };\n            }\n        }\n        return null;\n    }\n    function expandRecurring(eventStore, framingRange, context) {\n        let { dateEnv, pluginHooks, options } = context;\n        let { defs, instances } = eventStore;\n        // remove existing recurring instances\n        // TODO: bad. always expand events as a second step\n        instances = filterHash(instances, (instance)=>!defs[instance.defId].recurringDef);\n        for(let defId in defs){\n            let def = defs[defId];\n            if (def.recurringDef) {\n                let { duration } = def.recurringDef;\n                if (!duration) {\n                    duration = def.allDay ? options.defaultAllDayEventDuration : options.defaultTimedEventDuration;\n                }\n                let starts = expandRecurringRanges(def, duration, framingRange, dateEnv, pluginHooks.recurringTypes);\n                for (let start of starts){\n                    let instance = createEventInstance(defId, {\n                        start,\n                        end: dateEnv.add(start, duration)\n                    });\n                    instances[instance.instanceId] = instance;\n                }\n            }\n        }\n        return {\n            defs,\n            instances\n        };\n    }\n    /*\r\n    Event MUST have a recurringDef\r\n    */ function expandRecurringRanges(eventDef, duration, framingRange, dateEnv, recurringTypes) {\n        let typeDef = recurringTypes[eventDef.recurringDef.typeId];\n        let markers = typeDef.expand(eventDef.recurringDef.typeData, {\n            start: dateEnv.subtract(framingRange.start, duration),\n            end: framingRange.end\n        }, dateEnv);\n        // the recurrence plugins don't guarantee that all-day events are start-of-day, so we have to\n        if (eventDef.allDay) {\n            markers = markers.map(startOfDay);\n        }\n        return markers;\n    }\n    function parseEvents(rawEvents, eventSource, context, allowOpenRange, defIdMap, instanceIdMap) {\n        let eventStore = createEmptyEventStore();\n        let eventRefiners = buildEventRefiners(context);\n        for (let rawEvent of rawEvents){\n            let tuple = parseEvent(rawEvent, eventSource, context, allowOpenRange, eventRefiners, defIdMap, instanceIdMap);\n            if (tuple) {\n                eventTupleToStore(tuple, eventStore);\n            }\n        }\n        return eventStore;\n    }\n    function eventTupleToStore(tuple) {\n        let eventStore = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : createEmptyEventStore();\n        eventStore.defs[tuple.def.defId] = tuple.def;\n        if (tuple.instance) {\n            eventStore.instances[tuple.instance.instanceId] = tuple.instance;\n        }\n        return eventStore;\n    }\n    // retrieves events that have the same groupId as the instance specified by `instanceId`\n    // or they are the same as the instance.\n    // why might instanceId not be in the store? an event from another calendar?\n    function getRelevantEvents(eventStore, instanceId) {\n        let instance = eventStore.instances[instanceId];\n        if (instance) {\n            let def = eventStore.defs[instance.defId];\n            // get events/instances with same group\n            let newStore = filterEventStoreDefs(eventStore, (lookDef)=>isEventDefsGrouped(def, lookDef));\n            // add the original\n            // TODO: wish we could use eventTupleToStore or something like it\n            newStore.defs[def.defId] = def;\n            newStore.instances[instance.instanceId] = instance;\n            return newStore;\n        }\n        return createEmptyEventStore();\n    }\n    function isEventDefsGrouped(def0, def1) {\n        return Boolean(def0.groupId && def0.groupId === def1.groupId);\n    }\n    function createEmptyEventStore() {\n        return {\n            defs: {},\n            instances: {}\n        };\n    }\n    function mergeEventStores(store0, store1) {\n        return {\n            defs: Object.assign(Object.assign({}, store0.defs), store1.defs),\n            instances: Object.assign(Object.assign({}, store0.instances), store1.instances)\n        };\n    }\n    function filterEventStoreDefs(eventStore, filterFunc) {\n        let defs = filterHash(eventStore.defs, filterFunc);\n        let instances = filterHash(eventStore.instances, (instance)=>defs[instance.defId] // still exists?\n        );\n        return {\n            defs,\n            instances\n        };\n    }\n    function excludeSubEventStore(master, sub) {\n        let { defs, instances } = master;\n        let filteredDefs = {};\n        let filteredInstances = {};\n        for(let defId in defs){\n            if (!sub.defs[defId]) {\n                filteredDefs[defId] = defs[defId];\n            }\n        }\n        for(let instanceId in instances){\n            if (!sub.instances[instanceId] && // not explicitly excluded\n            filteredDefs[instances[instanceId].defId] // def wasn't filtered away\n            ) {\n                filteredInstances[instanceId] = instances[instanceId];\n            }\n        }\n        return {\n            defs: filteredDefs,\n            instances: filteredInstances\n        };\n    }\n    function normalizeConstraint(input, context) {\n        if (Array.isArray(input)) {\n            return parseEvents(input, null, context, true); // allowOpenRange=true\n        }\n        if (typeof input === 'object' && input) {\n            return parseEvents([\n                input\n            ], null, context, true); // allowOpenRange=true\n        }\n        if (input != null) {\n            return String(input);\n        }\n        return null;\n    }\n    function parseClassNames(raw) {\n        if (Array.isArray(raw)) {\n            return raw;\n        }\n        if (typeof raw === 'string') {\n            return raw.split(/\\s+/);\n        }\n        return [];\n    }\n    // TODO: better called \"EventSettings\" or \"EventConfig\"\n    // TODO: move this file into structs\n    // TODO: separate constraint/overlap/allow, because selection uses only that, not other props\n    const EVENT_UI_REFINERS = {\n        display: String,\n        editable: Boolean,\n        startEditable: Boolean,\n        durationEditable: Boolean,\n        constraint: identity,\n        overlap: identity,\n        allow: identity,\n        className: parseClassNames,\n        classNames: parseClassNames,\n        color: String,\n        backgroundColor: String,\n        borderColor: String,\n        textColor: String\n    };\n    const EMPTY_EVENT_UI = {\n        display: null,\n        startEditable: null,\n        durationEditable: null,\n        constraints: [],\n        overlap: null,\n        allows: [],\n        backgroundColor: '',\n        borderColor: '',\n        textColor: '',\n        classNames: []\n    };\n    function createEventUi(refined, context) {\n        let constraint = normalizeConstraint(refined.constraint, context);\n        return {\n            display: refined.display || null,\n            startEditable: refined.startEditable != null ? refined.startEditable : refined.editable,\n            durationEditable: refined.durationEditable != null ? refined.durationEditable : refined.editable,\n            constraints: constraint != null ? [\n                constraint\n            ] : [],\n            overlap: refined.overlap != null ? refined.overlap : null,\n            allows: refined.allow != null ? [\n                refined.allow\n            ] : [],\n            backgroundColor: refined.backgroundColor || refined.color || '',\n            borderColor: refined.borderColor || refined.color || '',\n            textColor: refined.textColor || '',\n            classNames: (refined.className || []).concat(refined.classNames || [])\n        };\n    }\n    // TODO: prevent against problems with <2 args!\n    function combineEventUis(uis) {\n        return uis.reduce(combineTwoEventUis, EMPTY_EVENT_UI);\n    }\n    function combineTwoEventUis(item0, item1) {\n        return {\n            display: item1.display != null ? item1.display : item0.display,\n            startEditable: item1.startEditable != null ? item1.startEditable : item0.startEditable,\n            durationEditable: item1.durationEditable != null ? item1.durationEditable : item0.durationEditable,\n            constraints: item0.constraints.concat(item1.constraints),\n            overlap: typeof item1.overlap === 'boolean' ? item1.overlap : item0.overlap,\n            allows: item0.allows.concat(item1.allows),\n            backgroundColor: item1.backgroundColor || item0.backgroundColor,\n            borderColor: item1.borderColor || item0.borderColor,\n            textColor: item1.textColor || item0.textColor,\n            classNames: item0.classNames.concat(item1.classNames)\n        };\n    }\n    const EVENT_NON_DATE_REFINERS = {\n        id: String,\n        groupId: String,\n        title: String,\n        url: String,\n        interactive: Boolean\n    };\n    const EVENT_DATE_REFINERS = {\n        start: identity,\n        end: identity,\n        date: identity,\n        allDay: Boolean\n    };\n    const EVENT_REFINERS = Object.assign(Object.assign(Object.assign({}, EVENT_NON_DATE_REFINERS), EVENT_DATE_REFINERS), {\n        extendedProps: identity\n    });\n    function parseEvent(raw, eventSource, context, allowOpenRange) {\n        let refiners = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : buildEventRefiners(context), defIdMap = arguments.length > 5 ? arguments[5] : void 0, instanceIdMap = arguments.length > 6 ? arguments[6] : void 0;\n        let { refined, extra } = refineEventDef(raw, context, refiners);\n        let defaultAllDay = computeIsDefaultAllDay(eventSource, context);\n        let recurringRes = parseRecurring(refined, defaultAllDay, context.dateEnv, context.pluginHooks.recurringTypes);\n        if (recurringRes) {\n            let def = parseEventDef(refined, extra, eventSource ? eventSource.sourceId : '', recurringRes.allDay, Boolean(recurringRes.duration), context, defIdMap);\n            def.recurringDef = {\n                typeId: recurringRes.typeId,\n                typeData: recurringRes.typeData,\n                duration: recurringRes.duration\n            };\n            return {\n                def,\n                instance: null\n            };\n        }\n        let singleRes = parseSingle(refined, defaultAllDay, context, allowOpenRange);\n        if (singleRes) {\n            let def = parseEventDef(refined, extra, eventSource ? eventSource.sourceId : '', singleRes.allDay, singleRes.hasEnd, context, defIdMap);\n            let instance = createEventInstance(def.defId, singleRes.range, singleRes.forcedStartTzo, singleRes.forcedEndTzo);\n            if (instanceIdMap && def.publicId && instanceIdMap[def.publicId]) {\n                instance.instanceId = instanceIdMap[def.publicId];\n            }\n            return {\n                def,\n                instance\n            };\n        }\n        return null;\n    }\n    function refineEventDef(raw, context) {\n        let refiners = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : buildEventRefiners(context);\n        return refineProps(raw, refiners);\n    }\n    function buildEventRefiners(context) {\n        return Object.assign(Object.assign(Object.assign({}, EVENT_UI_REFINERS), EVENT_REFINERS), context.pluginHooks.eventRefiners);\n    }\n    /*\r\n    Will NOT populate extendedProps with the leftover properties.\r\n    Will NOT populate date-related props.\r\n    */ function parseEventDef(refined, extra, sourceId, allDay, hasEnd, context, defIdMap) {\n        let def = {\n            title: refined.title || '',\n            groupId: refined.groupId || '',\n            publicId: refined.id || '',\n            url: refined.url || '',\n            recurringDef: null,\n            defId: (defIdMap && refined.id ? defIdMap[refined.id] : '') || guid(),\n            sourceId,\n            allDay,\n            hasEnd,\n            interactive: refined.interactive,\n            ui: createEventUi(refined, context),\n            extendedProps: Object.assign(Object.assign({}, refined.extendedProps || {}), extra)\n        };\n        for (let memberAdder of context.pluginHooks.eventDefMemberAdders){\n            Object.assign(def, memberAdder(refined));\n        }\n        // help out EventImpl from having user modify props\n        Object.freeze(def.ui.classNames);\n        Object.freeze(def.extendedProps);\n        return def;\n    }\n    function parseSingle(refined, defaultAllDay, context, allowOpenRange) {\n        let { allDay } = refined;\n        let startMeta;\n        let startMarker = null;\n        let hasEnd = false;\n        let endMeta;\n        let endMarker = null;\n        let startInput = refined.start != null ? refined.start : refined.date;\n        startMeta = context.dateEnv.createMarkerMeta(startInput);\n        if (startMeta) {\n            startMarker = startMeta.marker;\n        } else if (!allowOpenRange) {\n            return null;\n        }\n        if (refined.end != null) {\n            endMeta = context.dateEnv.createMarkerMeta(refined.end);\n        }\n        if (allDay == null) {\n            if (defaultAllDay != null) {\n                allDay = defaultAllDay;\n            } else {\n                // fall back to the date props LAST\n                allDay = (!startMeta || startMeta.isTimeUnspecified) && (!endMeta || endMeta.isTimeUnspecified);\n            }\n        }\n        if (allDay && startMarker) {\n            startMarker = startOfDay(startMarker);\n        }\n        if (endMeta) {\n            endMarker = endMeta.marker;\n            if (allDay) {\n                endMarker = startOfDay(endMarker);\n            }\n            if (startMarker && endMarker <= startMarker) {\n                endMarker = null;\n            }\n        }\n        if (endMarker) {\n            hasEnd = true;\n        } else if (!allowOpenRange) {\n            hasEnd = context.options.forceEventDuration || false;\n            endMarker = context.dateEnv.add(startMarker, allDay ? context.options.defaultAllDayEventDuration : context.options.defaultTimedEventDuration);\n        }\n        return {\n            allDay,\n            hasEnd,\n            range: {\n                start: startMarker,\n                end: endMarker\n            },\n            forcedStartTzo: startMeta ? startMeta.forcedTzo : null,\n            forcedEndTzo: endMeta ? endMeta.forcedTzo : null\n        };\n    }\n    function computeIsDefaultAllDay(eventSource, context) {\n        let res = null;\n        if (eventSource) {\n            res = eventSource.defaultAllDay;\n        }\n        if (res == null) {\n            res = context.options.defaultAllDay;\n        }\n        return res;\n    }\n    const DEF_DEFAULTS = {\n        startTime: '09:00',\n        endTime: '17:00',\n        daysOfWeek: [\n            1,\n            2,\n            3,\n            4,\n            5\n        ],\n        display: 'inverse-background',\n        classNames: 'fc-non-business',\n        groupId: '_businessHours'\n    };\n    /*\r\n    TODO: pass around as EventDefHash!!!\r\n    */ function parseBusinessHours(input, context) {\n        return parseEvents(refineInputs(input), null, context);\n    }\n    function refineInputs(input) {\n        let rawDefs;\n        if (input === true) {\n            rawDefs = [\n                {}\n            ]; // will get DEF_DEFAULTS verbatim\n        } else if (Array.isArray(input)) {\n            // if specifying an array, every sub-definition NEEDS a day-of-week\n            rawDefs = input.filter((rawDef)=>rawDef.daysOfWeek);\n        } else if (typeof input === 'object' && input) {\n            rawDefs = [\n                input\n            ];\n        } else {\n            rawDefs = [];\n        }\n        rawDefs = rawDefs.map((rawDef)=>Object.assign(Object.assign({}, DEF_DEFAULTS), rawDef));\n        return rawDefs;\n    }\n    /* Date stuff that doesn't belong in datelib core\r\n    ----------------------------------------------------------------------------------------------------------------------*/ // given a timed range, computes an all-day range that has the same exact duration,\n    // but whose start time is aligned with the start of the day.\n    function computeAlignedDayRange(timedRange) {\n        let dayCnt = Math.floor(diffDays(timedRange.start, timedRange.end)) || 1;\n        let start = startOfDay(timedRange.start);\n        let end = addDays(start, dayCnt);\n        return {\n            start,\n            end\n        };\n    }\n    // given a timed range, computes an all-day range based on how for the end date bleeds into the next day\n    // TODO: give nextDayThreshold a default arg\n    function computeVisibleDayRange(timedRange) {\n        let nextDayThreshold = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : createDuration(0);\n        let startDay = null;\n        let endDay = null;\n        if (timedRange.end) {\n            endDay = startOfDay(timedRange.end);\n            let endTimeMS = timedRange.end.valueOf() - endDay.valueOf(); // # of milliseconds into `endDay`\n            // If the end time is actually inclusively part of the next day and is equal to or\n            // beyond the next day threshold, adjust the end to be the exclusive end of `endDay`.\n            // Otherwise, leaving it as inclusive will cause it to exclude `endDay`.\n            if (endTimeMS && endTimeMS >= asRoughMs(nextDayThreshold)) {\n                endDay = addDays(endDay, 1);\n            }\n        }\n        if (timedRange.start) {\n            startDay = startOfDay(timedRange.start); // the beginning of the day the range starts\n            // If end is within `startDay` but not past nextDayThreshold, assign the default duration of one day.\n            if (endDay && endDay <= startDay) {\n                endDay = addDays(startDay, 1);\n            }\n        }\n        return {\n            start: startDay,\n            end: endDay\n        };\n    }\n    // spans from one day into another?\n    function isMultiDayRange(range) {\n        let visibleRange = computeVisibleDayRange(range);\n        return diffDays(visibleRange.start, visibleRange.end) > 1;\n    }\n    function diffDates(date0, date1, dateEnv, largeUnit) {\n        if (largeUnit === 'year') {\n            return createDuration(dateEnv.diffWholeYears(date0, date1), 'year');\n        }\n        if (largeUnit === 'month') {\n            return createDuration(dateEnv.diffWholeMonths(date0, date1), 'month');\n        }\n        return diffDayAndTime(date0, date1); // returns a duration\n    }\n    function pointInsideRect(point, rect) {\n        return point.left >= rect.left && point.left < rect.right && point.top >= rect.top && point.top < rect.bottom;\n    }\n    // Returns a new rectangle that is the intersection of the two rectangles. If they don't intersect, returns false\n    function intersectRects(rect1, rect2) {\n        let res = {\n            left: Math.max(rect1.left, rect2.left),\n            right: Math.min(rect1.right, rect2.right),\n            top: Math.max(rect1.top, rect2.top),\n            bottom: Math.min(rect1.bottom, rect2.bottom)\n        };\n        if (res.left < res.right && res.top < res.bottom) {\n            return res;\n        }\n        return false;\n    }\n    function translateRect(rect, deltaX, deltaY) {\n        return {\n            left: rect.left + deltaX,\n            right: rect.right + deltaX,\n            top: rect.top + deltaY,\n            bottom: rect.bottom + deltaY\n        };\n    }\n    // Returns a new point that will have been moved to reside within the given rectangle\n    function constrainPoint(point, rect) {\n        return {\n            left: Math.min(Math.max(point.left, rect.left), rect.right),\n            top: Math.min(Math.max(point.top, rect.top), rect.bottom)\n        };\n    }\n    // Returns a point that is the center of the given rectangle\n    function getRectCenter(rect) {\n        return {\n            left: (rect.left + rect.right) / 2,\n            top: (rect.top + rect.bottom) / 2\n        };\n    }\n    // Subtracts point2's coordinates from point1's coordinates, returning a delta\n    function diffPoints(point1, point2) {\n        return {\n            left: point1.left - point2.left,\n            top: point1.top - point2.top\n        };\n    }\n    let canVGrowWithinCell;\n    function getCanVGrowWithinCell() {\n        if (canVGrowWithinCell == null) {\n            canVGrowWithinCell = computeCanVGrowWithinCell();\n        }\n        return canVGrowWithinCell;\n    }\n    function computeCanVGrowWithinCell() {\n        // for SSR, because this function is call immediately at top-level\n        // TODO: just make this logic execute top-level, immediately, instead of doing lazily\n        if (typeof document === 'undefined') {\n            return true;\n        }\n        let el = document.createElement('div');\n        el.style.position = 'absolute';\n        el.style.top = '0px';\n        el.style.left = '0px';\n        el.innerHTML = '<table><tr><td><div></div></td></tr></table>';\n        el.querySelector('table').style.height = '100px';\n        el.querySelector('div').style.height = '100%';\n        document.body.appendChild(el);\n        let div = el.querySelector('div');\n        let possible = div.offsetHeight > 0;\n        document.body.removeChild(el);\n        return possible;\n    }\n    const EMPTY_EVENT_STORE = createEmptyEventStore(); // for purecomponents. TODO: keep elsewhere\n    class Splitter {\n        splitProps(props) {\n            let keyInfos = this.getKeyInfo(props);\n            let defKeys = this.getKeysForEventDefs(props.eventStore);\n            let dateSelections = this.splitDateSelection(props.dateSelection);\n            let individualUi = this.splitIndividualUi(props.eventUiBases, defKeys); // the individual *bases*\n            let eventStores = this.splitEventStore(props.eventStore, defKeys);\n            let eventDrags = this.splitEventDrag(props.eventDrag);\n            let eventResizes = this.splitEventResize(props.eventResize);\n            let splitProps = {};\n            this.eventUiBuilders = mapHash(keyInfos, (info, key)=>this.eventUiBuilders[key] || memoize(buildEventUiForKey));\n            for(let key in keyInfos){\n                let keyInfo = keyInfos[key];\n                let eventStore = eventStores[key] || EMPTY_EVENT_STORE;\n                let buildEventUi = this.eventUiBuilders[key];\n                splitProps[key] = {\n                    businessHours: keyInfo.businessHours || props.businessHours,\n                    dateSelection: dateSelections[key] || null,\n                    eventStore,\n                    eventUiBases: buildEventUi(props.eventUiBases[''], keyInfo.ui, individualUi[key]),\n                    eventSelection: eventStore.instances[props.eventSelection] ? props.eventSelection : '',\n                    eventDrag: eventDrags[key] || null,\n                    eventResize: eventResizes[key] || null\n                };\n            }\n            return splitProps;\n        }\n        _splitDateSpan(dateSpan) {\n            let dateSpans = {};\n            if (dateSpan) {\n                let keys = this.getKeysForDateSpan(dateSpan);\n                for (let key of keys){\n                    dateSpans[key] = dateSpan;\n                }\n            }\n            return dateSpans;\n        }\n        _getKeysForEventDefs(eventStore) {\n            return mapHash(eventStore.defs, (eventDef)=>this.getKeysForEventDef(eventDef));\n        }\n        _splitEventStore(eventStore, defKeys) {\n            let { defs, instances } = eventStore;\n            let splitStores = {};\n            for(let defId in defs){\n                for (let key of defKeys[defId]){\n                    if (!splitStores[key]) {\n                        splitStores[key] = createEmptyEventStore();\n                    }\n                    splitStores[key].defs[defId] = defs[defId];\n                }\n            }\n            for(let instanceId in instances){\n                let instance = instances[instanceId];\n                for (let key of defKeys[instance.defId]){\n                    if (splitStores[key]) {\n                        splitStores[key].instances[instanceId] = instance;\n                    }\n                }\n            }\n            return splitStores;\n        }\n        _splitIndividualUi(eventUiBases, defKeys) {\n            let splitHashes = {};\n            for(let defId in eventUiBases){\n                if (defId) {\n                    for (let key of defKeys[defId]){\n                        if (!splitHashes[key]) {\n                            splitHashes[key] = {};\n                        }\n                        splitHashes[key][defId] = eventUiBases[defId];\n                    }\n                }\n            }\n            return splitHashes;\n        }\n        _splitInteraction(interaction) {\n            let splitStates = {};\n            if (interaction) {\n                let affectedStores = this._splitEventStore(interaction.affectedEvents, this._getKeysForEventDefs(interaction.affectedEvents));\n                // can't rely on defKeys because event data is mutated\n                let mutatedKeysByDefId = this._getKeysForEventDefs(interaction.mutatedEvents);\n                let mutatedStores = this._splitEventStore(interaction.mutatedEvents, mutatedKeysByDefId);\n                let populate = (key)=>{\n                    if (!splitStates[key]) {\n                        splitStates[key] = {\n                            affectedEvents: affectedStores[key] || EMPTY_EVENT_STORE,\n                            mutatedEvents: mutatedStores[key] || EMPTY_EVENT_STORE,\n                            isEvent: interaction.isEvent\n                        };\n                    }\n                };\n                for(let key in affectedStores){\n                    populate(key);\n                }\n                for(let key in mutatedStores){\n                    populate(key);\n                }\n            }\n            return splitStates;\n        }\n        constructor(){\n            this.getKeysForEventDefs = memoize(this._getKeysForEventDefs);\n            this.splitDateSelection = memoize(this._splitDateSpan);\n            this.splitEventStore = memoize(this._splitEventStore);\n            this.splitIndividualUi = memoize(this._splitIndividualUi);\n            this.splitEventDrag = memoize(this._splitInteraction);\n            this.splitEventResize = memoize(this._splitInteraction);\n            this.eventUiBuilders = {}; // TODO: typescript protection\n        }\n    }\n    function buildEventUiForKey(allUi, eventUiForKey, individualUi) {\n        let baseParts = [];\n        if (allUi) {\n            baseParts.push(allUi);\n        }\n        if (eventUiForKey) {\n            baseParts.push(eventUiForKey);\n        }\n        let stuff = {\n            '': combineEventUis(baseParts)\n        };\n        if (individualUi) {\n            Object.assign(stuff, individualUi);\n        }\n        return stuff;\n    }\n    function parseRange(input, dateEnv) {\n        let start = null;\n        let end = null;\n        if (input.start) {\n            start = dateEnv.createMarker(input.start);\n        }\n        if (input.end) {\n            end = dateEnv.createMarker(input.end);\n        }\n        if (!start && !end) {\n            return null;\n        }\n        if (start && end && end < start) {\n            return null;\n        }\n        return {\n            start,\n            end\n        };\n    }\n    // SIDE-EFFECT: will mutate ranges.\n    // Will return a new array result.\n    function invertRanges(ranges, constraintRange) {\n        let invertedRanges = [];\n        let { start } = constraintRange; // the end of the previous range. the start of the new range\n        let i;\n        let dateRange;\n        // ranges need to be in order. required for our date-walking algorithm\n        ranges.sort(compareRanges);\n        for(i = 0; i < ranges.length; i += 1){\n            dateRange = ranges[i];\n            // add the span of time before the event (if there is any)\n            if (dateRange.start > start) {\n                invertedRanges.push({\n                    start,\n                    end: dateRange.start\n                });\n            }\n            if (dateRange.end > start) {\n                start = dateRange.end;\n            }\n        }\n        // add the span of time after the last event (if there is any)\n        if (start < constraintRange.end) {\n            invertedRanges.push({\n                start,\n                end: constraintRange.end\n            });\n        }\n        return invertedRanges;\n    }\n    function compareRanges(range0, range1) {\n        return range0.start.valueOf() - range1.start.valueOf(); // earlier ranges go first\n    }\n    function intersectRanges(range0, range1) {\n        let { start, end } = range0;\n        let newRange = null;\n        if (range1.start !== null) {\n            if (start === null) {\n                start = range1.start;\n            } else {\n                start = new Date(Math.max(start.valueOf(), range1.start.valueOf()));\n            }\n        }\n        if (range1.end != null) {\n            if (end === null) {\n                end = range1.end;\n            } else {\n                end = new Date(Math.min(end.valueOf(), range1.end.valueOf()));\n            }\n        }\n        if (start === null || end === null || start < end) {\n            newRange = {\n                start,\n                end\n            };\n        }\n        return newRange;\n    }\n    function rangesEqual(range0, range1) {\n        return (range0.start === null ? null : range0.start.valueOf()) === (range1.start === null ? null : range1.start.valueOf()) && (range0.end === null ? null : range0.end.valueOf()) === (range1.end === null ? null : range1.end.valueOf());\n    }\n    function rangesIntersect(range0, range1) {\n        return (range0.end === null || range1.start === null || range0.end > range1.start) && (range0.start === null || range1.end === null || range0.start < range1.end);\n    }\n    function rangeContainsRange(outerRange, innerRange) {\n        return (outerRange.start === null || innerRange.start !== null && innerRange.start >= outerRange.start) && (outerRange.end === null || innerRange.end !== null && innerRange.end <= outerRange.end);\n    }\n    function rangeContainsMarker(range, date) {\n        return (range.start === null || date >= range.start) && (range.end === null || date < range.end);\n    }\n    // If the given date is not within the given range, move it inside.\n    // (If it's past the end, make it one millisecond before the end).\n    function constrainMarkerToRange(date, range) {\n        if (range.start != null && date < range.start) {\n            return range.start;\n        }\n        if (range.end != null && date >= range.end) {\n            return new Date(range.end.valueOf() - 1);\n        }\n        return date;\n    }\n    function getDateMeta(date, todayRange, nowDate, dateProfile) {\n        return {\n            dow: date.getUTCDay(),\n            isDisabled: Boolean(dateProfile && !rangeContainsMarker(dateProfile.activeRange, date)),\n            isOther: Boolean(dateProfile && !rangeContainsMarker(dateProfile.currentRange, date)),\n            isToday: Boolean(todayRange && rangeContainsMarker(todayRange, date)),\n            isPast: Boolean(nowDate ? date < nowDate : todayRange ? date < todayRange.start : false),\n            isFuture: Boolean(nowDate ? date > nowDate : todayRange ? date >= todayRange.end : false)\n        };\n    }\n    function getDayClassNames(meta, theme) {\n        let classNames = [\n            'fc-day',\n            \"fc-day-\".concat(DAY_IDS[meta.dow])\n        ];\n        if (meta.isDisabled) {\n            classNames.push('fc-day-disabled');\n        } else {\n            if (meta.isToday) {\n                classNames.push('fc-day-today');\n                classNames.push(theme.getClass('today'));\n            }\n            if (meta.isPast) {\n                classNames.push('fc-day-past');\n            }\n            if (meta.isFuture) {\n                classNames.push('fc-day-future');\n            }\n            if (meta.isOther) {\n                classNames.push('fc-day-other');\n            }\n        }\n        return classNames;\n    }\n    function getSlotClassNames(meta, theme) {\n        let classNames = [\n            'fc-slot',\n            \"fc-slot-\".concat(DAY_IDS[meta.dow])\n        ];\n        if (meta.isDisabled) {\n            classNames.push('fc-slot-disabled');\n        } else {\n            if (meta.isToday) {\n                classNames.push('fc-slot-today');\n                classNames.push(theme.getClass('today'));\n            }\n            if (meta.isPast) {\n                classNames.push('fc-slot-past');\n            }\n            if (meta.isFuture) {\n                classNames.push('fc-slot-future');\n            }\n        }\n        return classNames;\n    }\n    const DAY_FORMAT = createFormatter({\n        year: 'numeric',\n        month: 'long',\n        day: 'numeric'\n    });\n    const WEEK_FORMAT = createFormatter({\n        week: 'long'\n    });\n    function buildNavLinkAttrs(context, dateMarker) {\n        let viewType = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 'day', isTabbable = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;\n        const { dateEnv, options, calendarApi } = context;\n        let dateStr = dateEnv.format(dateMarker, viewType === 'week' ? WEEK_FORMAT : DAY_FORMAT);\n        if (options.navLinks) {\n            let zonedDate = dateEnv.toDate(dateMarker);\n            const handleInteraction = (ev)=>{\n                let customAction = viewType === 'day' ? options.navLinkDayClick : viewType === 'week' ? options.navLinkWeekClick : null;\n                if (typeof customAction === 'function') {\n                    customAction.call(calendarApi, dateEnv.toDate(dateMarker), ev);\n                } else {\n                    if (typeof customAction === 'string') {\n                        viewType = customAction;\n                    }\n                    calendarApi.zoomTo(dateMarker, viewType);\n                }\n            };\n            return Object.assign({\n                title: formatWithOrdinals(options.navLinkHint, [\n                    dateStr,\n                    zonedDate\n                ], dateStr),\n                'data-navlink': ''\n            }, isTabbable ? createAriaClickAttrs(handleInteraction) : {\n                onClick: handleInteraction\n            });\n        }\n        return {\n            'aria-label': dateStr\n        };\n    }\n    let _isRtlScrollbarOnLeft = null;\n    function getIsRtlScrollbarOnLeft() {\n        if (_isRtlScrollbarOnLeft === null) {\n            _isRtlScrollbarOnLeft = computeIsRtlScrollbarOnLeft();\n        }\n        return _isRtlScrollbarOnLeft;\n    }\n    function computeIsRtlScrollbarOnLeft() {\n        let outerEl = document.createElement('div');\n        applyStyle(outerEl, {\n            position: 'absolute',\n            top: -1000,\n            left: 0,\n            border: 0,\n            padding: 0,\n            overflow: 'scroll',\n            direction: 'rtl'\n        });\n        outerEl.innerHTML = '<div></div>';\n        document.body.appendChild(outerEl);\n        let innerEl = outerEl.firstChild;\n        let res = innerEl.getBoundingClientRect().left > outerEl.getBoundingClientRect().left;\n        removeElement(outerEl);\n        return res;\n    }\n    let _scrollbarWidths;\n    function getScrollbarWidths() {\n        if (!_scrollbarWidths) {\n            _scrollbarWidths = computeScrollbarWidths();\n        }\n        return _scrollbarWidths;\n    }\n    function computeScrollbarWidths() {\n        let el = document.createElement('div');\n        el.style.overflow = 'scroll';\n        el.style.position = 'absolute';\n        el.style.top = '-9999px';\n        el.style.left = '-9999px';\n        document.body.appendChild(el);\n        let res = computeScrollbarWidthsForEl(el);\n        document.body.removeChild(el);\n        return res;\n    }\n    // WARNING: will include border\n    function computeScrollbarWidthsForEl(el) {\n        return {\n            x: el.offsetHeight - el.clientHeight,\n            y: el.offsetWidth - el.clientWidth\n        };\n    }\n    function computeEdges(el) {\n        let getPadding = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n        let computedStyle = window.getComputedStyle(el);\n        let borderLeft = parseInt(computedStyle.borderLeftWidth, 10) || 0;\n        let borderRight = parseInt(computedStyle.borderRightWidth, 10) || 0;\n        let borderTop = parseInt(computedStyle.borderTopWidth, 10) || 0;\n        let borderBottom = parseInt(computedStyle.borderBottomWidth, 10) || 0;\n        let badScrollbarWidths = computeScrollbarWidthsForEl(el); // includes border!\n        let scrollbarLeftRight = badScrollbarWidths.y - borderLeft - borderRight;\n        let scrollbarBottom = badScrollbarWidths.x - borderTop - borderBottom;\n        let res = {\n            borderLeft,\n            borderRight,\n            borderTop,\n            borderBottom,\n            scrollbarBottom,\n            scrollbarLeft: 0,\n            scrollbarRight: 0\n        };\n        if (getIsRtlScrollbarOnLeft() && computedStyle.direction === 'rtl') {\n            res.scrollbarLeft = scrollbarLeftRight;\n        } else {\n            res.scrollbarRight = scrollbarLeftRight;\n        }\n        if (getPadding) {\n            res.paddingLeft = parseInt(computedStyle.paddingLeft, 10) || 0;\n            res.paddingRight = parseInt(computedStyle.paddingRight, 10) || 0;\n            res.paddingTop = parseInt(computedStyle.paddingTop, 10) || 0;\n            res.paddingBottom = parseInt(computedStyle.paddingBottom, 10) || 0;\n        }\n        return res;\n    }\n    function computeInnerRect(el) {\n        let goWithinPadding = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false, doFromWindowViewport = arguments.length > 2 ? arguments[2] : void 0;\n        let outerRect = doFromWindowViewport ? el.getBoundingClientRect() : computeRect(el);\n        let edges = computeEdges(el, goWithinPadding);\n        let res = {\n            left: outerRect.left + edges.borderLeft + edges.scrollbarLeft,\n            right: outerRect.right - edges.borderRight - edges.scrollbarRight,\n            top: outerRect.top + edges.borderTop,\n            bottom: outerRect.bottom - edges.borderBottom - edges.scrollbarBottom\n        };\n        if (goWithinPadding) {\n            res.left += edges.paddingLeft;\n            res.right -= edges.paddingRight;\n            res.top += edges.paddingTop;\n            res.bottom -= edges.paddingBottom;\n        }\n        return res;\n    }\n    function computeRect(el) {\n        let rect = el.getBoundingClientRect();\n        return {\n            left: rect.left + window.pageXOffset,\n            top: rect.top + window.pageYOffset,\n            right: rect.right + window.pageXOffset,\n            bottom: rect.bottom + window.pageYOffset\n        };\n    }\n    function computeClippedClientRect(el) {\n        let clippingParents = getClippingParents(el);\n        let rect = el.getBoundingClientRect();\n        for (let clippingParent of clippingParents){\n            let intersection = intersectRects(rect, clippingParent.getBoundingClientRect());\n            if (intersection) {\n                rect = intersection;\n            } else {\n                return null;\n            }\n        }\n        return rect;\n    }\n    // does not return window\n    function getClippingParents(el) {\n        let parents = [];\n        while(el instanceof HTMLElement){\n            let computedStyle = window.getComputedStyle(el);\n            if (computedStyle.position === 'fixed') {\n                break;\n            }\n            if (/(auto|scroll)/.test(computedStyle.overflow + computedStyle.overflowY + computedStyle.overflowX)) {\n                parents.push(el);\n            }\n            el = el.parentNode;\n        }\n        return parents;\n    }\n    /*\r\n    given a function that resolves a result asynchronously.\r\n    the function can either call passed-in success and failure callbacks,\r\n    or it can return a promise.\r\n    if you need to pass additional params to func, bind them first.\r\n    */ function unpromisify(func, normalizedSuccessCallback, normalizedFailureCallback) {\n        // guard against success/failure callbacks being called more than once\n        // and guard against a promise AND callback being used together.\n        let isResolved = false;\n        let wrappedSuccess = function(res) {\n            if (!isResolved) {\n                isResolved = true;\n                normalizedSuccessCallback(res);\n            }\n        };\n        let wrappedFailure = function(error) {\n            if (!isResolved) {\n                isResolved = true;\n                normalizedFailureCallback(error);\n            }\n        };\n        let res = func(wrappedSuccess, wrappedFailure);\n        if (res && typeof res.then === 'function') {\n            res.then(wrappedSuccess, wrappedFailure);\n        }\n    }\n    class Emitter {\n        setThisContext(thisContext) {\n            this.thisContext = thisContext;\n        }\n        setOptions(options) {\n            this.options = options;\n        }\n        on(type, handler) {\n            addToHash(this.handlers, type, handler);\n        }\n        off(type, handler) {\n            removeFromHash(this.handlers, type, handler);\n        }\n        trigger(type) {\n            for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n                args[_key - 1] = arguments[_key];\n            }\n            let attachedHandlers = this.handlers[type] || [];\n            let optionHandler = this.options && this.options[type];\n            let handlers = [].concat(optionHandler || [], attachedHandlers);\n            for (let handler of handlers){\n                handler.apply(this.thisContext, args);\n            }\n        }\n        hasHandlers(type) {\n            return Boolean(this.handlers[type] && this.handlers[type].length || this.options && this.options[type]);\n        }\n        constructor(){\n            this.handlers = {};\n            this.thisContext = null;\n        }\n    }\n    function addToHash(hash, type, handler) {\n        (hash[type] || (hash[type] = [])).push(handler);\n    }\n    function removeFromHash(hash, type, handler) {\n        if (handler) {\n            if (hash[type]) {\n                hash[type] = hash[type].filter((func)=>func !== handler);\n            }\n        } else {\n            delete hash[type]; // remove all handler funcs for this type\n        }\n    }\n    /*\r\n    Records offset information for a set of elements, relative to an origin element.\r\n    Can record the left/right OR the top/bottom OR both.\r\n    Provides methods for querying the cache by position.\r\n    */ class PositionCache {\n        // Populates the left/right internal coordinate arrays\n        buildElHorizontals(originClientLeft) {\n            let lefts = [];\n            let rights = [];\n            for (let el of this.els){\n                let rect = el.getBoundingClientRect();\n                lefts.push(rect.left - originClientLeft);\n                rights.push(rect.right - originClientLeft);\n            }\n            this.lefts = lefts;\n            this.rights = rights;\n        }\n        // Populates the top/bottom internal coordinate arrays\n        buildElVerticals(originClientTop) {\n            let tops = [];\n            let bottoms = [];\n            for (let el of this.els){\n                let rect = el.getBoundingClientRect();\n                tops.push(rect.top - originClientTop);\n                bottoms.push(rect.bottom - originClientTop);\n            }\n            this.tops = tops;\n            this.bottoms = bottoms;\n        }\n        // Given a left offset (from document left), returns the index of the el that it horizontally intersects.\n        // If no intersection is made, returns undefined.\n        leftToIndex(leftPosition) {\n            let { lefts, rights } = this;\n            let len = lefts.length;\n            let i;\n            for(i = 0; i < len; i += 1){\n                if (leftPosition >= lefts[i] && leftPosition < rights[i]) {\n                    return i;\n                }\n            }\n            return undefined; // TODO: better\n        }\n        // Given a top offset (from document top), returns the index of the el that it vertically intersects.\n        // If no intersection is made, returns undefined.\n        topToIndex(topPosition) {\n            let { tops, bottoms } = this;\n            let len = tops.length;\n            let i;\n            for(i = 0; i < len; i += 1){\n                if (topPosition >= tops[i] && topPosition < bottoms[i]) {\n                    return i;\n                }\n            }\n            return undefined; // TODO: better\n        }\n        // Gets the width of the element at the given index\n        getWidth(leftIndex) {\n            return this.rights[leftIndex] - this.lefts[leftIndex];\n        }\n        // Gets the height of the element at the given index\n        getHeight(topIndex) {\n            return this.bottoms[topIndex] - this.tops[topIndex];\n        }\n        similarTo(otherCache) {\n            return similarNumArrays(this.tops || [], otherCache.tops || []) && similarNumArrays(this.bottoms || [], otherCache.bottoms || []) && similarNumArrays(this.lefts || [], otherCache.lefts || []) && similarNumArrays(this.rights || [], otherCache.rights || []);\n        }\n        constructor(originEl, els, isHorizontal, isVertical){\n            this.els = els;\n            let originClientRect = this.originClientRect = originEl.getBoundingClientRect(); // relative to viewport top-left\n            if (isHorizontal) {\n                this.buildElHorizontals(originClientRect.left);\n            }\n            if (isVertical) {\n                this.buildElVerticals(originClientRect.top);\n            }\n        }\n    }\n    function similarNumArrays(a, b) {\n        const len = a.length;\n        if (len !== b.length) {\n            return false;\n        }\n        for(let i = 0; i < len; i++){\n            if (Math.round(a[i]) !== Math.round(b[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /* eslint max-classes-per-file: \"off\" */ /*\r\n    An object for getting/setting scroll-related information for an element.\r\n    Internally, this is done very differently for window versus DOM element,\r\n    so this object serves as a common interface.\r\n    */ class ScrollController {\n        getMaxScrollTop() {\n            return this.getScrollHeight() - this.getClientHeight();\n        }\n        getMaxScrollLeft() {\n            return this.getScrollWidth() - this.getClientWidth();\n        }\n        canScrollVertically() {\n            return this.getMaxScrollTop() > 0;\n        }\n        canScrollHorizontally() {\n            return this.getMaxScrollLeft() > 0;\n        }\n        canScrollUp() {\n            return this.getScrollTop() > 0;\n        }\n        canScrollDown() {\n            return this.getScrollTop() < this.getMaxScrollTop();\n        }\n        canScrollLeft() {\n            return this.getScrollLeft() > 0;\n        }\n        canScrollRight() {\n            return this.getScrollLeft() < this.getMaxScrollLeft();\n        }\n    }\n    class ElementScrollController extends ScrollController {\n        getScrollTop() {\n            return this.el.scrollTop;\n        }\n        getScrollLeft() {\n            return this.el.scrollLeft;\n        }\n        setScrollTop(top) {\n            this.el.scrollTop = top;\n        }\n        setScrollLeft(left) {\n            this.el.scrollLeft = left;\n        }\n        getScrollWidth() {\n            return this.el.scrollWidth;\n        }\n        getScrollHeight() {\n            return this.el.scrollHeight;\n        }\n        getClientHeight() {\n            return this.el.clientHeight;\n        }\n        getClientWidth() {\n            return this.el.clientWidth;\n        }\n        constructor(el){\n            super();\n            this.el = el;\n        }\n    }\n    class WindowScrollController extends ScrollController {\n        getScrollTop() {\n            return window.pageYOffset;\n        }\n        getScrollLeft() {\n            return window.pageXOffset;\n        }\n        setScrollTop(n) {\n            window.scroll(window.pageXOffset, n);\n        }\n        setScrollLeft(n) {\n            window.scroll(n, window.pageYOffset);\n        }\n        getScrollWidth() {\n            return document.documentElement.scrollWidth;\n        }\n        getScrollHeight() {\n            return document.documentElement.scrollHeight;\n        }\n        getClientHeight() {\n            return document.documentElement.clientHeight;\n        }\n        getClientWidth() {\n            return document.documentElement.clientWidth;\n        }\n    }\n    class Theme {\n        setIconOverride(iconOverrideHash) {\n            let iconClassesCopy;\n            let buttonName;\n            if (typeof iconOverrideHash === 'object' && iconOverrideHash) {\n                iconClassesCopy = Object.assign({}, this.iconClasses);\n                for(buttonName in iconOverrideHash){\n                    iconClassesCopy[buttonName] = this.applyIconOverridePrefix(iconOverrideHash[buttonName]);\n                }\n                this.iconClasses = iconClassesCopy;\n            } else if (iconOverrideHash === false) {\n                this.iconClasses = {};\n            }\n        }\n        applyIconOverridePrefix(className) {\n            let prefix = this.iconOverridePrefix;\n            if (prefix && className.indexOf(prefix) !== 0) {\n                className = prefix + className;\n            }\n            return className;\n        }\n        getClass(key) {\n            return this.classes[key] || '';\n        }\n        getIconClass(buttonName, isRtl) {\n            let className;\n            if (isRtl && this.rtlIconClasses) {\n                className = this.rtlIconClasses[buttonName] || this.iconClasses[buttonName];\n            } else {\n                className = this.iconClasses[buttonName];\n            }\n            if (className) {\n                return \"\".concat(this.baseIconClass, \" \").concat(className);\n            }\n            return '';\n        }\n        getCustomButtonIconClass(customButtonProps) {\n            let className;\n            if (this.iconOverrideCustomButtonOption) {\n                className = customButtonProps[this.iconOverrideCustomButtonOption];\n                if (className) {\n                    return \"\".concat(this.baseIconClass, \" \").concat(this.applyIconOverridePrefix(className));\n                }\n            }\n            return '';\n        }\n        constructor(calendarOptions){\n            if (this.iconOverrideOption) {\n                this.setIconOverride(calendarOptions[this.iconOverrideOption]);\n            }\n        }\n    }\n    Theme.prototype.classes = {};\n    Theme.prototype.iconClasses = {};\n    Theme.prototype.baseIconClass = '';\n    Theme.prototype.iconOverridePrefix = '';\n    /*\r\n    NOTE: this can be a public API, especially createElement for hooks.\r\n    See examples/typescript-scheduler/src/index.ts\r\n    */ function flushSync(runBeforeFlush) {\n        runBeforeFlush();\n        let oldDebounceRendering = l$1.debounceRendering; // orig\n        let callbackQ = [];\n        function execCallbackSync(callback) {\n            callbackQ.push(callback);\n        }\n        l$1.debounceRendering = execCallbackSync;\n        D$1(y(FakeComponent, {}), document.createElement('div'));\n        while(callbackQ.length){\n            callbackQ.shift()();\n        }\n        l$1.debounceRendering = oldDebounceRendering;\n    }\n    class FakeComponent extends x$1 {\n        render() {\n            return y('div', {});\n        }\n        componentDidMount() {\n            this.setState({});\n        }\n    }\n    // TODO: use preact/compat instead?\n    function createContext(defaultValue) {\n        let ContextType = G$1(defaultValue);\n        let origProvider = ContextType.Provider;\n        ContextType.Provider = function() {\n            let isNew = !this.getChildContext;\n            let children = origProvider.apply(this, arguments); // eslint-disable-line prefer-rest-params\n            if (isNew) {\n                let subs = [];\n                this.shouldComponentUpdate = (_props)=>{\n                    if (this.props.value !== _props.value) {\n                        subs.forEach((c)=>{\n                            c.context = _props.value;\n                            c.forceUpdate();\n                        });\n                    }\n                };\n                this.sub = (c)=>{\n                    subs.push(c);\n                    let old = c.componentWillUnmount;\n                    c.componentWillUnmount = ()=>{\n                        subs.splice(subs.indexOf(c), 1);\n                        old && old.call(c);\n                    };\n                };\n            }\n            return children;\n        };\n        return ContextType;\n    }\n    class ScrollResponder {\n        detach() {\n            this.emitter.off('_scrollRequest', this.handleScrollRequest);\n        }\n        update(isDatesNew) {\n            if (isDatesNew && this.scrollTimeReset) {\n                this.fireInitialScroll(); // will drain\n            } else {\n                this.drain();\n            }\n        }\n        fireInitialScroll() {\n            this.handleScrollRequest({\n                time: this.scrollTime\n            });\n        }\n        drain() {\n            if (this.queuedRequest && this.execFunc(this.queuedRequest)) {\n                this.queuedRequest = null;\n            }\n        }\n        constructor(execFunc, emitter, scrollTime, scrollTimeReset){\n            this.execFunc = execFunc;\n            this.emitter = emitter;\n            this.scrollTime = scrollTime;\n            this.scrollTimeReset = scrollTimeReset;\n            this.handleScrollRequest = (request)=>{\n                this.queuedRequest = Object.assign({}, this.queuedRequest || {}, request);\n                this.drain();\n            };\n            emitter.on('_scrollRequest', this.handleScrollRequest);\n            this.fireInitialScroll();\n        }\n    }\n    const ViewContextType = createContext({}); // for Components\n    function buildViewContext(viewSpec, viewApi, viewOptions, dateProfileGenerator, dateEnv, theme, pluginHooks, dispatch, getCurrentData, emitter, calendarApi, registerInteractiveComponent, unregisterInteractiveComponent) {\n        return {\n            dateEnv,\n            options: viewOptions,\n            pluginHooks,\n            emitter,\n            dispatch,\n            getCurrentData,\n            calendarApi,\n            viewSpec,\n            viewApi,\n            dateProfileGenerator,\n            theme,\n            isRtl: viewOptions.direction === 'rtl',\n            addResizeHandler (handler) {\n                emitter.on('_resize', handler);\n            },\n            removeResizeHandler (handler) {\n                emitter.off('_resize', handler);\n            },\n            createScrollResponder (execFunc) {\n                return new ScrollResponder(execFunc, emitter, createDuration(viewOptions.scrollTime), viewOptions.scrollTimeReset);\n            },\n            registerInteractiveComponent,\n            unregisterInteractiveComponent\n        };\n    }\n    /* eslint max-classes-per-file: off */ class PureComponent extends x$1 {\n        shouldComponentUpdate(nextProps, nextState) {\n            if (this.debug) {\n                // eslint-disable-next-line no-console\n                console.log(getUnequalProps(nextProps, this.props), getUnequalProps(nextState, this.state));\n            }\n            return !compareObjs(this.props, nextProps, this.propEquality) || !compareObjs(this.state, nextState, this.stateEquality);\n        }\n        // HACK for freakin' React StrictMode\n        safeSetState(newState) {\n            if (!compareObjs(this.state, Object.assign(Object.assign({}, this.state), newState), this.stateEquality)) {\n                this.setState(newState);\n            }\n        }\n    }\n    PureComponent.addPropsEquality = addPropsEquality;\n    PureComponent.addStateEquality = addStateEquality;\n    PureComponent.contextType = ViewContextType;\n    PureComponent.prototype.propEquality = {};\n    PureComponent.prototype.stateEquality = {};\n    class BaseComponent extends PureComponent {\n    }\n    BaseComponent.contextType = ViewContextType;\n    function addPropsEquality(propEquality) {\n        let hash = Object.create(this.prototype.propEquality);\n        Object.assign(hash, propEquality);\n        this.prototype.propEquality = hash;\n    }\n    function addStateEquality(stateEquality) {\n        let hash = Object.create(this.prototype.stateEquality);\n        Object.assign(hash, stateEquality);\n        this.prototype.stateEquality = hash;\n    }\n    // use other one\n    function setRef(ref, current) {\n        if (typeof ref === 'function') {\n            ref(current);\n        } else if (ref) {\n            // see https://github.com/facebook/react/issues/13029\n            ref.current = current;\n        }\n    }\n    /*\r\n    an INTERACTABLE date component\r\n\r\n    PURPOSES:\r\n    - hook up to fg, fill, and mirror renderers\r\n    - interface for dragging and hits\r\n    */ class DateComponent extends BaseComponent {\n        // Hit System\n        // -----------------------------------------------------------------------------------------------------------------\n        prepareHits() {}\n        queryHit(positionLeft, positionTop, elWidth, elHeight) {\n            return null; // this should be abstract\n        }\n        // Pointer Interaction Utils\n        // -----------------------------------------------------------------------------------------------------------------\n        isValidSegDownEl(el) {\n            return !this.props.eventDrag && // HACK\n            !this.props.eventResize && // HACK\n            !elementClosest(el, '.fc-event-mirror');\n        }\n        isValidDateDownEl(el) {\n            return !elementClosest(el, '.fc-event:not(.fc-bg-event)') && !elementClosest(el, '.fc-more-link') && // a \"more..\" link\n            !elementClosest(el, 'a[data-navlink]') && // a clickable nav link\n            !elementClosest(el, '.fc-popover'); // hack\n        }\n        constructor(){\n            super(...arguments);\n            this.uid = guid();\n        }\n    }\n    function reduceCurrentDate(currentDate, action) {\n        switch(action.type){\n            case 'CHANGE_DATE':\n                return action.dateMarker;\n            default:\n                return currentDate;\n        }\n    }\n    function getInitialDate(options, dateEnv) {\n        let initialDateInput = options.initialDate;\n        // compute the initial ambig-timezone date\n        if (initialDateInput != null) {\n            return dateEnv.createMarker(initialDateInput);\n        }\n        return getNow(options.now, dateEnv); // getNow already returns unzoned\n    }\n    function getNow(nowInput, dateEnv) {\n        if (typeof nowInput === 'function') {\n            nowInput = nowInput();\n        }\n        if (nowInput == null) {\n            return dateEnv.createNowMarker();\n        }\n        return dateEnv.createMarker(nowInput);\n    }\n    class DateProfileGenerator {\n        /* Date Range Computation\r\n        ------------------------------------------------------------------------------------------------------------------*/ // Builds a structure with info about what the dates/ranges will be for the \"prev\" view.\n        buildPrev(currentDateProfile, currentDate, forceToValid) {\n            let { dateEnv } = this.props;\n            let prevDate = dateEnv.subtract(dateEnv.startOf(currentDate, currentDateProfile.currentRangeUnit), currentDateProfile.dateIncrement);\n            return this.build(prevDate, -1, forceToValid);\n        }\n        // Builds a structure with info about what the dates/ranges will be for the \"next\" view.\n        buildNext(currentDateProfile, currentDate, forceToValid) {\n            let { dateEnv } = this.props;\n            let nextDate = dateEnv.add(dateEnv.startOf(currentDate, currentDateProfile.currentRangeUnit), currentDateProfile.dateIncrement);\n            return this.build(nextDate, 1, forceToValid);\n        }\n        // Builds a structure holding dates/ranges for rendering around the given date.\n        // Optional direction param indicates whether the date is being incremented/decremented\n        // from its previous value. decremented = -1, incremented = 1 (default).\n        build(currentDate, direction) {\n            let forceToValid = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;\n            let { props } = this;\n            let validRange;\n            let currentInfo;\n            let isRangeAllDay;\n            let renderRange;\n            let activeRange;\n            let isValid;\n            validRange = this.buildValidRange();\n            validRange = this.trimHiddenDays(validRange);\n            if (forceToValid) {\n                currentDate = constrainMarkerToRange(currentDate, validRange);\n            }\n            currentInfo = this.buildCurrentRangeInfo(currentDate, direction);\n            isRangeAllDay = /^(year|month|week|day)$/.test(currentInfo.unit);\n            renderRange = this.buildRenderRange(this.trimHiddenDays(currentInfo.range), currentInfo.unit, isRangeAllDay);\n            renderRange = this.trimHiddenDays(renderRange);\n            activeRange = renderRange;\n            if (!props.showNonCurrentDates) {\n                activeRange = intersectRanges(activeRange, currentInfo.range);\n            }\n            activeRange = this.adjustActiveRange(activeRange);\n            activeRange = intersectRanges(activeRange, validRange); // might return null\n            // it's invalid if the originally requested date is not contained,\n            // or if the range is completely outside of the valid range.\n            isValid = rangesIntersect(currentInfo.range, validRange);\n            // HACK: constrain to render-range so `currentDate` is more useful to view rendering\n            if (!rangeContainsMarker(renderRange, currentDate)) {\n                currentDate = renderRange.start;\n            }\n            return {\n                currentDate,\n                // constraint for where prev/next operations can go and where events can be dragged/resized to.\n                // an object with optional start and end properties.\n                validRange,\n                // range the view is formally responsible for.\n                // for example, a month view might have 1st-31st, excluding padded dates\n                currentRange: currentInfo.range,\n                // name of largest unit being displayed, like \"month\" or \"week\"\n                currentRangeUnit: currentInfo.unit,\n                isRangeAllDay,\n                // dates that display events and accept drag-n-drop\n                // will be `null` if no dates accept events\n                activeRange,\n                // date range with a rendered skeleton\n                // includes not-active days that need some sort of DOM\n                renderRange,\n                // Duration object that denotes the first visible time of any given day\n                slotMinTime: props.slotMinTime,\n                // Duration object that denotes the exclusive visible end time of any given day\n                slotMaxTime: props.slotMaxTime,\n                isValid,\n                // how far the current date will move for a prev/next operation\n                dateIncrement: this.buildDateIncrement(currentInfo.duration)\n            };\n        }\n        // Builds an object with optional start/end properties.\n        // Indicates the minimum/maximum dates to display.\n        // not responsible for trimming hidden days.\n        buildValidRange() {\n            let input = this.props.validRangeInput;\n            let simpleInput = typeof input === 'function' ? input.call(this.props.calendarApi, this.nowDate) : input;\n            return this.refineRange(simpleInput) || {\n                start: null,\n                end: null\n            }; // completely open-ended\n        }\n        // Builds a structure with info about the \"current\" range, the range that is\n        // highlighted as being the current month for example.\n        // See build() for a description of `direction`.\n        // Guaranteed to have `range` and `unit` properties. `duration` is optional.\n        buildCurrentRangeInfo(date, direction) {\n            let { props } = this;\n            let duration = null;\n            let unit = null;\n            let range = null;\n            let dayCount;\n            if (props.duration) {\n                duration = props.duration;\n                unit = props.durationUnit;\n                range = this.buildRangeFromDuration(date, direction, duration, unit);\n            } else if (dayCount = this.props.dayCount) {\n                unit = 'day';\n                range = this.buildRangeFromDayCount(date, direction, dayCount);\n            } else if (range = this.buildCustomVisibleRange(date)) {\n                unit = props.dateEnv.greatestWholeUnit(range.start, range.end).unit;\n            } else {\n                duration = this.getFallbackDuration();\n                unit = greatestDurationDenominator(duration).unit;\n                range = this.buildRangeFromDuration(date, direction, duration, unit);\n            }\n            return {\n                duration,\n                unit,\n                range\n            };\n        }\n        getFallbackDuration() {\n            return createDuration({\n                day: 1\n            });\n        }\n        // Returns a new activeRange to have time values (un-ambiguate)\n        // slotMinTime or slotMaxTime causes the range to expand.\n        adjustActiveRange(range) {\n            let { dateEnv, usesMinMaxTime, slotMinTime, slotMaxTime } = this.props;\n            let { start, end } = range;\n            if (usesMinMaxTime) {\n                // expand active range if slotMinTime is negative (why not when positive?)\n                if (asRoughDays(slotMinTime) < 0) {\n                    start = startOfDay(start); // necessary?\n                    start = dateEnv.add(start, slotMinTime);\n                }\n                // expand active range if slotMaxTime is beyond one day (why not when negative?)\n                if (asRoughDays(slotMaxTime) > 1) {\n                    end = startOfDay(end); // necessary?\n                    end = addDays(end, -1);\n                    end = dateEnv.add(end, slotMaxTime);\n                }\n            }\n            return {\n                start,\n                end\n            };\n        }\n        // Builds the \"current\" range when it is specified as an explicit duration.\n        // `unit` is the already-computed greatestDurationDenominator unit of duration.\n        buildRangeFromDuration(date, direction, duration, unit) {\n            let { dateEnv, dateAlignment } = this.props;\n            let start;\n            let end;\n            let res;\n            // compute what the alignment should be\n            if (!dateAlignment) {\n                let { dateIncrement } = this.props;\n                if (dateIncrement) {\n                    // use the smaller of the two units\n                    if (asRoughMs(dateIncrement) < asRoughMs(duration)) {\n                        dateAlignment = greatestDurationDenominator(dateIncrement).unit;\n                    } else {\n                        dateAlignment = unit;\n                    }\n                } else {\n                    dateAlignment = unit;\n                }\n            }\n            // if the view displays a single day or smaller\n            if (asRoughDays(duration) <= 1) {\n                if (this.isHiddenDay(start)) {\n                    start = this.skipHiddenDays(start, direction);\n                    start = startOfDay(start);\n                }\n            }\n            function computeRes() {\n                start = dateEnv.startOf(date, dateAlignment);\n                end = dateEnv.add(start, duration);\n                res = {\n                    start,\n                    end\n                };\n            }\n            computeRes();\n            // if range is completely enveloped by hidden days, go past the hidden days\n            if (!this.trimHiddenDays(res)) {\n                date = this.skipHiddenDays(date, direction);\n                computeRes();\n            }\n            return res;\n        }\n        // Builds the \"current\" range when a dayCount is specified.\n        buildRangeFromDayCount(date, direction, dayCount) {\n            let { dateEnv, dateAlignment } = this.props;\n            let runningCount = 0;\n            let start = date;\n            let end;\n            if (dateAlignment) {\n                start = dateEnv.startOf(start, dateAlignment);\n            }\n            start = startOfDay(start);\n            start = this.skipHiddenDays(start, direction);\n            end = start;\n            do {\n                end = addDays(end, 1);\n                if (!this.isHiddenDay(end)) {\n                    runningCount += 1;\n                }\n            }while (runningCount < dayCount);\n            return {\n                start,\n                end\n            };\n        }\n        // Builds a normalized range object for the \"visible\" range,\n        // which is a way to define the currentRange and activeRange at the same time.\n        buildCustomVisibleRange(date) {\n            let { props } = this;\n            let input = props.visibleRangeInput;\n            let simpleInput = typeof input === 'function' ? input.call(props.calendarApi, props.dateEnv.toDate(date)) : input;\n            let range = this.refineRange(simpleInput);\n            if (range && (range.start == null || range.end == null)) {\n                return null;\n            }\n            return range;\n        }\n        // Computes the range that will represent the element/cells for *rendering*,\n        // but which may have voided days/times.\n        // not responsible for trimming hidden days.\n        buildRenderRange(currentRange, currentRangeUnit, isRangeAllDay) {\n            return currentRange;\n        }\n        // Compute the duration value that should be added/substracted to the current date\n        // when a prev/next operation happens.\n        buildDateIncrement(fallback) {\n            let { dateIncrement } = this.props;\n            let customAlignment;\n            if (dateIncrement) {\n                return dateIncrement;\n            }\n            if (customAlignment = this.props.dateAlignment) {\n                return createDuration(1, customAlignment);\n            }\n            if (fallback) {\n                return fallback;\n            }\n            return createDuration({\n                days: 1\n            });\n        }\n        refineRange(rangeInput) {\n            if (rangeInput) {\n                let range = parseRange(rangeInput, this.props.dateEnv);\n                if (range) {\n                    range = computeVisibleDayRange(range);\n                }\n                return range;\n            }\n            return null;\n        }\n        /* Hidden Days\r\n        ------------------------------------------------------------------------------------------------------------------*/ // Initializes internal variables related to calculating hidden days-of-week\n        initHiddenDays() {\n            let hiddenDays = this.props.hiddenDays || []; // array of day-of-week indices that are hidden\n            let isHiddenDayHash = []; // is the day-of-week hidden? (hash with day-of-week-index -> bool)\n            let dayCnt = 0;\n            let i;\n            if (this.props.weekends === false) {\n                hiddenDays.push(0, 6); // 0=sunday, 6=saturday\n            }\n            for(i = 0; i < 7; i += 1){\n                if (!(isHiddenDayHash[i] = hiddenDays.indexOf(i) !== -1)) {\n                    dayCnt += 1;\n                }\n            }\n            if (!dayCnt) {\n                throw new Error('invalid hiddenDays'); // all days were hidden? bad.\n            }\n            this.isHiddenDayHash = isHiddenDayHash;\n        }\n        // Remove days from the beginning and end of the range that are computed as hidden.\n        // If the whole range is trimmed off, returns null\n        trimHiddenDays(range) {\n            let { start, end } = range;\n            if (start) {\n                start = this.skipHiddenDays(start);\n            }\n            if (end) {\n                end = this.skipHiddenDays(end, -1, true);\n            }\n            if (start == null || end == null || start < end) {\n                return {\n                    start,\n                    end\n                };\n            }\n            return null;\n        }\n        // Is the current day hidden?\n        // `day` is a day-of-week index (0-6), or a Date (used for UTC)\n        isHiddenDay(day) {\n            if (day instanceof Date) {\n                day = day.getUTCDay();\n            }\n            return this.isHiddenDayHash[day];\n        }\n        // Incrementing the current day until it is no longer a hidden day, returning a copy.\n        // DOES NOT CONSIDER validRange!\n        // If the initial value of `date` is not a hidden day, don't do anything.\n        // Pass `isExclusive` as `true` if you are dealing with an end date.\n        // `inc` defaults to `1` (increment one day forward each time)\n        skipHiddenDays(date) {\n            let inc = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1, isExclusive = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;\n            while(this.isHiddenDayHash[(date.getUTCDay() + (isExclusive ? inc : 0) + 7) % 7]){\n                date = addDays(date, inc);\n            }\n            return date;\n        }\n        constructor(props){\n            this.props = props;\n            this.nowDate = getNow(props.nowInput, props.dateEnv);\n            this.initHiddenDays();\n        }\n    }\n    function triggerDateSelect(selection, pev, context) {\n        context.emitter.trigger('select', Object.assign(Object.assign({}, buildDateSpanApiWithContext(selection, context)), {\n            jsEvent: pev ? pev.origEvent : null,\n            view: context.viewApi || context.calendarApi.view\n        }));\n    }\n    function triggerDateUnselect(pev, context) {\n        context.emitter.trigger('unselect', {\n            jsEvent: pev ? pev.origEvent : null,\n            view: context.viewApi || context.calendarApi.view\n        });\n    }\n    function buildDateSpanApiWithContext(dateSpan, context) {\n        let props = {};\n        for (let transform of context.pluginHooks.dateSpanTransforms){\n            Object.assign(props, transform(dateSpan, context));\n        }\n        Object.assign(props, buildDateSpanApi(dateSpan, context.dateEnv));\n        return props;\n    }\n    // Given an event's allDay status and start date, return what its fallback end date should be.\n    // TODO: rename to computeDefaultEventEnd\n    function getDefaultEventEnd(allDay, marker, context) {\n        let { dateEnv, options } = context;\n        let end = marker;\n        if (allDay) {\n            end = startOfDay(end);\n            end = dateEnv.add(end, options.defaultAllDayEventDuration);\n        } else {\n            end = dateEnv.add(end, options.defaultTimedEventDuration);\n        }\n        return end;\n    }\n    // applies the mutation to ALL defs/instances within the event store\n    function applyMutationToEventStore(eventStore, eventConfigBase, mutation, context) {\n        let eventConfigs = compileEventUis(eventStore.defs, eventConfigBase);\n        let dest = createEmptyEventStore();\n        for(let defId in eventStore.defs){\n            let def = eventStore.defs[defId];\n            dest.defs[defId] = applyMutationToEventDef(def, eventConfigs[defId], mutation, context);\n        }\n        for(let instanceId in eventStore.instances){\n            let instance = eventStore.instances[instanceId];\n            let def = dest.defs[instance.defId]; // important to grab the newly modified def\n            dest.instances[instanceId] = applyMutationToEventInstance(instance, def, eventConfigs[instance.defId], mutation, context);\n        }\n        return dest;\n    }\n    function applyMutationToEventDef(eventDef, eventConfig, mutation, context) {\n        let standardProps = mutation.standardProps || {};\n        // if hasEnd has not been specified, guess a good value based on deltas.\n        // if duration will change, there's no way the default duration will persist,\n        // and thus, we need to mark the event as having a real end\n        if (standardProps.hasEnd == null && eventConfig.durationEditable && (mutation.startDelta || mutation.endDelta)) {\n            standardProps.hasEnd = true; // TODO: is this mutation okay?\n        }\n        let copy = Object.assign(Object.assign(Object.assign({}, eventDef), standardProps), {\n            ui: Object.assign(Object.assign({}, eventDef.ui), standardProps.ui)\n        });\n        if (mutation.extendedProps) {\n            copy.extendedProps = Object.assign(Object.assign({}, copy.extendedProps), mutation.extendedProps);\n        }\n        for (let applier of context.pluginHooks.eventDefMutationAppliers){\n            applier(copy, mutation, context);\n        }\n        if (!copy.hasEnd && context.options.forceEventDuration) {\n            copy.hasEnd = true;\n        }\n        return copy;\n    }\n    function applyMutationToEventInstance(eventInstance, eventDef, eventConfig, mutation, context) {\n        let { dateEnv } = context;\n        let forceAllDay = mutation.standardProps && mutation.standardProps.allDay === true;\n        let clearEnd = mutation.standardProps && mutation.standardProps.hasEnd === false;\n        let copy = Object.assign({}, eventInstance);\n        if (forceAllDay) {\n            copy.range = computeAlignedDayRange(copy.range);\n        }\n        if (mutation.datesDelta && eventConfig.startEditable) {\n            copy.range = {\n                start: dateEnv.add(copy.range.start, mutation.datesDelta),\n                end: dateEnv.add(copy.range.end, mutation.datesDelta)\n            };\n        }\n        if (mutation.startDelta && eventConfig.durationEditable) {\n            copy.range = {\n                start: dateEnv.add(copy.range.start, mutation.startDelta),\n                end: copy.range.end\n            };\n        }\n        if (mutation.endDelta && eventConfig.durationEditable) {\n            copy.range = {\n                start: copy.range.start,\n                end: dateEnv.add(copy.range.end, mutation.endDelta)\n            };\n        }\n        if (clearEnd) {\n            copy.range = {\n                start: copy.range.start,\n                end: getDefaultEventEnd(eventDef.allDay, copy.range.start, context)\n            };\n        }\n        // in case event was all-day but the supplied deltas were not\n        // better util for this?\n        if (eventDef.allDay) {\n            copy.range = {\n                start: startOfDay(copy.range.start),\n                end: startOfDay(copy.range.end)\n            };\n        }\n        // handle invalid durations\n        if (copy.range.end < copy.range.start) {\n            copy.range.end = getDefaultEventEnd(eventDef.allDay, copy.range.start, context);\n        }\n        return copy;\n    }\n    class EventSourceImpl {\n        remove() {\n            this.context.dispatch({\n                type: 'REMOVE_EVENT_SOURCE',\n                sourceId: this.internalEventSource.sourceId\n            });\n        }\n        refetch() {\n            this.context.dispatch({\n                type: 'FETCH_EVENT_SOURCES',\n                sourceIds: [\n                    this.internalEventSource.sourceId\n                ],\n                isRefetch: true\n            });\n        }\n        get id() {\n            return this.internalEventSource.publicId;\n        }\n        get url() {\n            return this.internalEventSource.meta.url;\n        }\n        get format() {\n            return this.internalEventSource.meta.format; // TODO: bad. not guaranteed\n        }\n        constructor(context, internalEventSource){\n            this.context = context;\n            this.internalEventSource = internalEventSource;\n        }\n    }\n    class EventImpl {\n        /*\r\n        TODO: make event struct more responsible for this\r\n        */ setProp(name, val) {\n            if (name in EVENT_DATE_REFINERS) {\n                console.warn('Could not set date-related prop \\'name\\'. Use one of the date-related methods instead.');\n            // TODO: make proper aliasing system?\n            } else if (name === 'id') {\n                val = EVENT_NON_DATE_REFINERS[name](val);\n                this.mutate({\n                    standardProps: {\n                        publicId: val\n                    }\n                });\n            } else if (name in EVENT_NON_DATE_REFINERS) {\n                val = EVENT_NON_DATE_REFINERS[name](val);\n                this.mutate({\n                    standardProps: {\n                        [name]: val\n                    }\n                });\n            } else if (name in EVENT_UI_REFINERS) {\n                let ui = EVENT_UI_REFINERS[name](val);\n                if (name === 'color') {\n                    ui = {\n                        backgroundColor: val,\n                        borderColor: val\n                    };\n                } else if (name === 'editable') {\n                    ui = {\n                        startEditable: val,\n                        durationEditable: val\n                    };\n                } else {\n                    ui = {\n                        [name]: val\n                    };\n                }\n                this.mutate({\n                    standardProps: {\n                        ui\n                    }\n                });\n            } else {\n                console.warn(\"Could not set prop '\".concat(name, \"'. Use setExtendedProp instead.\"));\n            }\n        }\n        setExtendedProp(name, val) {\n            this.mutate({\n                extendedProps: {\n                    [name]: val\n                }\n            });\n        }\n        setStart(startInput) {\n            let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n            let { dateEnv } = this._context;\n            let start = dateEnv.createMarker(startInput);\n            if (start && this._instance) {\n                let instanceRange = this._instance.range;\n                let startDelta = diffDates(instanceRange.start, start, dateEnv, options.granularity); // what if parsed bad!?\n                if (options.maintainDuration) {\n                    this.mutate({\n                        datesDelta: startDelta\n                    });\n                } else {\n                    this.mutate({\n                        startDelta\n                    });\n                }\n            }\n        }\n        setEnd(endInput) {\n            let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n            let { dateEnv } = this._context;\n            let end;\n            if (endInput != null) {\n                end = dateEnv.createMarker(endInput);\n                if (!end) {\n                    return; // TODO: warning if parsed bad\n                }\n            }\n            if (this._instance) {\n                if (end) {\n                    let endDelta = diffDates(this._instance.range.end, end, dateEnv, options.granularity);\n                    this.mutate({\n                        endDelta\n                    });\n                } else {\n                    this.mutate({\n                        standardProps: {\n                            hasEnd: false\n                        }\n                    });\n                }\n            }\n        }\n        setDates(startInput, endInput) {\n            let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n            let { dateEnv } = this._context;\n            let standardProps = {\n                allDay: options.allDay\n            };\n            let start = dateEnv.createMarker(startInput);\n            let end;\n            if (!start) {\n                return; // TODO: warning if parsed bad\n            }\n            if (endInput != null) {\n                end = dateEnv.createMarker(endInput);\n                if (!end) {\n                    return;\n                }\n            }\n            if (this._instance) {\n                let instanceRange = this._instance.range;\n                // when computing the diff for an event being converted to all-day,\n                // compute diff off of the all-day values the way event-mutation does.\n                if (options.allDay === true) {\n                    instanceRange = computeAlignedDayRange(instanceRange);\n                }\n                let startDelta = diffDates(instanceRange.start, start, dateEnv, options.granularity);\n                if (end) {\n                    let endDelta = diffDates(instanceRange.end, end, dateEnv, options.granularity);\n                    if (durationsEqual(startDelta, endDelta)) {\n                        this.mutate({\n                            datesDelta: startDelta,\n                            standardProps\n                        });\n                    } else {\n                        this.mutate({\n                            startDelta,\n                            endDelta,\n                            standardProps\n                        });\n                    }\n                } else {\n                    standardProps.hasEnd = false;\n                    this.mutate({\n                        datesDelta: startDelta,\n                        standardProps\n                    });\n                }\n            }\n        }\n        moveStart(deltaInput) {\n            let delta = createDuration(deltaInput);\n            if (delta) {\n                this.mutate({\n                    startDelta: delta\n                });\n            }\n        }\n        moveEnd(deltaInput) {\n            let delta = createDuration(deltaInput);\n            if (delta) {\n                this.mutate({\n                    endDelta: delta\n                });\n            }\n        }\n        moveDates(deltaInput) {\n            let delta = createDuration(deltaInput);\n            if (delta) {\n                this.mutate({\n                    datesDelta: delta\n                });\n            }\n        }\n        setAllDay(allDay) {\n            let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n            let standardProps = {\n                allDay\n            };\n            let { maintainDuration } = options;\n            if (maintainDuration == null) {\n                maintainDuration = this._context.options.allDayMaintainDuration;\n            }\n            if (this._def.allDay !== allDay) {\n                standardProps.hasEnd = maintainDuration;\n            }\n            this.mutate({\n                standardProps\n            });\n        }\n        formatRange(formatInput) {\n            let { dateEnv } = this._context;\n            let instance = this._instance;\n            let formatter = createFormatter(formatInput);\n            if (this._def.hasEnd) {\n                return dateEnv.formatRange(instance.range.start, instance.range.end, formatter, {\n                    forcedStartTzo: instance.forcedStartTzo,\n                    forcedEndTzo: instance.forcedEndTzo\n                });\n            }\n            return dateEnv.format(instance.range.start, formatter, {\n                forcedTzo: instance.forcedStartTzo\n            });\n        }\n        mutate(mutation) {\n            let instance = this._instance;\n            if (instance) {\n                let def = this._def;\n                let context = this._context;\n                let { eventStore } = context.getCurrentData();\n                let relevantEvents = getRelevantEvents(eventStore, instance.instanceId);\n                let eventConfigBase = {\n                    '': {\n                        display: '',\n                        startEditable: true,\n                        durationEditable: true,\n                        constraints: [],\n                        overlap: null,\n                        allows: [],\n                        backgroundColor: '',\n                        borderColor: '',\n                        textColor: '',\n                        classNames: []\n                    }\n                };\n                relevantEvents = applyMutationToEventStore(relevantEvents, eventConfigBase, mutation, context);\n                let oldEvent = new EventImpl(context, def, instance); // snapshot\n                this._def = relevantEvents.defs[def.defId];\n                this._instance = relevantEvents.instances[instance.instanceId];\n                context.dispatch({\n                    type: 'MERGE_EVENTS',\n                    eventStore: relevantEvents\n                });\n                context.emitter.trigger('eventChange', {\n                    oldEvent,\n                    event: this,\n                    relatedEvents: buildEventApis(relevantEvents, context, instance),\n                    revert () {\n                        context.dispatch({\n                            type: 'RESET_EVENTS',\n                            eventStore\n                        });\n                    }\n                });\n            }\n        }\n        remove() {\n            let context = this._context;\n            let asStore = eventApiToStore(this);\n            context.dispatch({\n                type: 'REMOVE_EVENTS',\n                eventStore: asStore\n            });\n            context.emitter.trigger('eventRemove', {\n                event: this,\n                relatedEvents: [],\n                revert () {\n                    context.dispatch({\n                        type: 'MERGE_EVENTS',\n                        eventStore: asStore\n                    });\n                }\n            });\n        }\n        get source() {\n            let { sourceId } = this._def;\n            if (sourceId) {\n                return new EventSourceImpl(this._context, this._context.getCurrentData().eventSources[sourceId]);\n            }\n            return null;\n        }\n        get start() {\n            return this._instance ? this._context.dateEnv.toDate(this._instance.range.start) : null;\n        }\n        get end() {\n            return this._instance && this._def.hasEnd ? this._context.dateEnv.toDate(this._instance.range.end) : null;\n        }\n        get startStr() {\n            let instance = this._instance;\n            if (instance) {\n                return this._context.dateEnv.formatIso(instance.range.start, {\n                    omitTime: this._def.allDay,\n                    forcedTzo: instance.forcedStartTzo\n                });\n            }\n            return '';\n        }\n        get endStr() {\n            let instance = this._instance;\n            if (instance && this._def.hasEnd) {\n                return this._context.dateEnv.formatIso(instance.range.end, {\n                    omitTime: this._def.allDay,\n                    forcedTzo: instance.forcedEndTzo\n                });\n            }\n            return '';\n        }\n        // computable props that all access the def\n        // TODO: find a TypeScript-compatible way to do this at scale\n        get id() {\n            return this._def.publicId;\n        }\n        get groupId() {\n            return this._def.groupId;\n        }\n        get allDay() {\n            return this._def.allDay;\n        }\n        get title() {\n            return this._def.title;\n        }\n        get url() {\n            return this._def.url;\n        }\n        get display() {\n            return this._def.ui.display || 'auto';\n        }\n        get startEditable() {\n            return this._def.ui.startEditable;\n        }\n        get durationEditable() {\n            return this._def.ui.durationEditable;\n        }\n        get constraint() {\n            return this._def.ui.constraints[0] || null;\n        }\n        get overlap() {\n            return this._def.ui.overlap;\n        }\n        get allow() {\n            return this._def.ui.allows[0] || null;\n        }\n        get backgroundColor() {\n            return this._def.ui.backgroundColor;\n        }\n        get borderColor() {\n            return this._def.ui.borderColor;\n        }\n        get textColor() {\n            return this._def.ui.textColor;\n        }\n        // NOTE: user can't modify these because Object.freeze was called in event-def parsing\n        get classNames() {\n            return this._def.ui.classNames;\n        }\n        get extendedProps() {\n            return this._def.extendedProps;\n        }\n        toPlainObject() {\n            let settings = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n            let def = this._def;\n            let { ui } = def;\n            let { startStr, endStr } = this;\n            let res = {\n                allDay: def.allDay\n            };\n            if (def.title) {\n                res.title = def.title;\n            }\n            if (startStr) {\n                res.start = startStr;\n            }\n            if (endStr) {\n                res.end = endStr;\n            }\n            if (def.publicId) {\n                res.id = def.publicId;\n            }\n            if (def.groupId) {\n                res.groupId = def.groupId;\n            }\n            if (def.url) {\n                res.url = def.url;\n            }\n            if (ui.display && ui.display !== 'auto') {\n                res.display = ui.display;\n            }\n            // TODO: what about recurring-event properties???\n            // TODO: include startEditable/durationEditable/constraint/overlap/allow\n            if (settings.collapseColor && ui.backgroundColor && ui.backgroundColor === ui.borderColor) {\n                res.color = ui.backgroundColor;\n            } else {\n                if (ui.backgroundColor) {\n                    res.backgroundColor = ui.backgroundColor;\n                }\n                if (ui.borderColor) {\n                    res.borderColor = ui.borderColor;\n                }\n            }\n            if (ui.textColor) {\n                res.textColor = ui.textColor;\n            }\n            if (ui.classNames.length) {\n                res.classNames = ui.classNames;\n            }\n            if (Object.keys(def.extendedProps).length) {\n                if (settings.collapseExtendedProps) {\n                    Object.assign(res, def.extendedProps);\n                } else {\n                    res.extendedProps = def.extendedProps;\n                }\n            }\n            return res;\n        }\n        toJSON() {\n            return this.toPlainObject();\n        }\n        // instance will be null if expressing a recurring event that has no current instances,\n        // OR if trying to validate an incoming external event that has no dates assigned\n        constructor(context, def, instance){\n            this._context = context;\n            this._def = def;\n            this._instance = instance || null;\n        }\n    }\n    function eventApiToStore(eventApi) {\n        let def = eventApi._def;\n        let instance = eventApi._instance;\n        return {\n            defs: {\n                [def.defId]: def\n            },\n            instances: instance ? {\n                [instance.instanceId]: instance\n            } : {}\n        };\n    }\n    function buildEventApis(eventStore, context, excludeInstance) {\n        let { defs, instances } = eventStore;\n        let eventApis = [];\n        let excludeInstanceId = excludeInstance ? excludeInstance.instanceId : '';\n        for(let id in instances){\n            let instance = instances[id];\n            let def = defs[instance.defId];\n            if (instance.instanceId !== excludeInstanceId) {\n                eventApis.push(new EventImpl(context, def, instance));\n            }\n        }\n        return eventApis;\n    }\n    /*\r\n    Specifying nextDayThreshold signals that all-day ranges should be sliced.\r\n    */ function sliceEventStore(eventStore, eventUiBases, framingRange, nextDayThreshold) {\n        let inverseBgByGroupId = {};\n        let inverseBgByDefId = {};\n        let defByGroupId = {};\n        let bgRanges = [];\n        let fgRanges = [];\n        let eventUis = compileEventUis(eventStore.defs, eventUiBases);\n        for(let defId in eventStore.defs){\n            let def = eventStore.defs[defId];\n            let ui = eventUis[def.defId];\n            if (ui.display === 'inverse-background') {\n                if (def.groupId) {\n                    inverseBgByGroupId[def.groupId] = [];\n                    if (!defByGroupId[def.groupId]) {\n                        defByGroupId[def.groupId] = def;\n                    }\n                } else {\n                    inverseBgByDefId[defId] = [];\n                }\n            }\n        }\n        for(let instanceId in eventStore.instances){\n            let instance = eventStore.instances[instanceId];\n            let def = eventStore.defs[instance.defId];\n            let ui = eventUis[def.defId];\n            let origRange = instance.range;\n            let normalRange = !def.allDay && nextDayThreshold ? computeVisibleDayRange(origRange, nextDayThreshold) : origRange;\n            let slicedRange = intersectRanges(normalRange, framingRange);\n            if (slicedRange) {\n                if (ui.display === 'inverse-background') {\n                    if (def.groupId) {\n                        inverseBgByGroupId[def.groupId].push(slicedRange);\n                    } else {\n                        inverseBgByDefId[instance.defId].push(slicedRange);\n                    }\n                } else if (ui.display !== 'none') {\n                    (ui.display === 'background' ? bgRanges : fgRanges).push({\n                        def,\n                        ui,\n                        instance,\n                        range: slicedRange,\n                        isStart: normalRange.start && normalRange.start.valueOf() === slicedRange.start.valueOf(),\n                        isEnd: normalRange.end && normalRange.end.valueOf() === slicedRange.end.valueOf()\n                    });\n                }\n            }\n        }\n        for(let groupId in inverseBgByGroupId){\n            let ranges = inverseBgByGroupId[groupId];\n            let invertedRanges = invertRanges(ranges, framingRange);\n            for (let invertedRange of invertedRanges){\n                let def = defByGroupId[groupId];\n                let ui = eventUis[def.defId];\n                bgRanges.push({\n                    def,\n                    ui,\n                    instance: null,\n                    range: invertedRange,\n                    isStart: false,\n                    isEnd: false\n                });\n            }\n        }\n        for(let defId in inverseBgByDefId){\n            let ranges = inverseBgByDefId[defId];\n            let invertedRanges = invertRanges(ranges, framingRange);\n            for (let invertedRange of invertedRanges){\n                bgRanges.push({\n                    def: eventStore.defs[defId],\n                    ui: eventUis[defId],\n                    instance: null,\n                    range: invertedRange,\n                    isStart: false,\n                    isEnd: false\n                });\n            }\n        }\n        return {\n            bg: bgRanges,\n            fg: fgRanges\n        };\n    }\n    function hasBgRendering(def) {\n        return def.ui.display === 'background' || def.ui.display === 'inverse-background';\n    }\n    function setElSeg(el, seg) {\n        el.fcSeg = seg;\n    }\n    function getElSeg(el) {\n        return el.fcSeg || el.parentNode.fcSeg || // for the harness\n        null;\n    }\n    // event ui computation\n    function compileEventUis(eventDefs, eventUiBases) {\n        return mapHash(eventDefs, (eventDef)=>compileEventUi(eventDef, eventUiBases));\n    }\n    function compileEventUi(eventDef, eventUiBases) {\n        let uis = [];\n        if (eventUiBases['']) {\n            uis.push(eventUiBases['']);\n        }\n        if (eventUiBases[eventDef.defId]) {\n            uis.push(eventUiBases[eventDef.defId]);\n        }\n        uis.push(eventDef.ui);\n        return combineEventUis(uis);\n    }\n    function sortEventSegs(segs, eventOrderSpecs) {\n        let objs = segs.map(buildSegCompareObj);\n        objs.sort((obj0, obj1)=>compareByFieldSpecs(obj0, obj1, eventOrderSpecs));\n        return objs.map((c)=>c._seg);\n    }\n    // returns a object with all primitive props that can be compared\n    function buildSegCompareObj(seg) {\n        let { eventRange } = seg;\n        let eventDef = eventRange.def;\n        let range = eventRange.instance ? eventRange.instance.range : eventRange.range;\n        let start = range.start ? range.start.valueOf() : 0; // TODO: better support for open-range events\n        let end = range.end ? range.end.valueOf() : 0; // \"\n        return Object.assign(Object.assign(Object.assign({}, eventDef.extendedProps), eventDef), {\n            id: eventDef.publicId,\n            start,\n            end,\n            duration: end - start,\n            allDay: Number(eventDef.allDay),\n            _seg: seg\n        });\n    }\n    function computeSegDraggable(seg, context) {\n        let { pluginHooks } = context;\n        let transformers = pluginHooks.isDraggableTransformers;\n        let { def, ui } = seg.eventRange;\n        let val = ui.startEditable;\n        for (let transformer of transformers){\n            val = transformer(val, def, ui, context);\n        }\n        return val;\n    }\n    function computeSegStartResizable(seg, context) {\n        return seg.isStart && seg.eventRange.ui.durationEditable && context.options.eventResizableFromStart;\n    }\n    function computeSegEndResizable(seg, context) {\n        return seg.isEnd && seg.eventRange.ui.durationEditable;\n    }\n    function buildSegTimeText(seg, timeFormat, context, defaultDisplayEventTime, defaultDisplayEventEnd, startOverride, endOverride) {\n        let { dateEnv, options } = context;\n        let { displayEventTime, displayEventEnd } = options;\n        let eventDef = seg.eventRange.def;\n        let eventInstance = seg.eventRange.instance;\n        if (displayEventTime == null) {\n            displayEventTime = defaultDisplayEventTime !== false;\n        }\n        if (displayEventEnd == null) {\n            displayEventEnd = defaultDisplayEventEnd !== false;\n        }\n        let wholeEventStart = eventInstance.range.start;\n        let wholeEventEnd = eventInstance.range.end;\n        let segStart = startOverride || seg.start || seg.eventRange.range.start;\n        let segEnd = endOverride || seg.end || seg.eventRange.range.end;\n        let isStartDay = startOfDay(wholeEventStart).valueOf() === startOfDay(segStart).valueOf();\n        let isEndDay = startOfDay(addMs(wholeEventEnd, -1)).valueOf() === startOfDay(addMs(segEnd, -1)).valueOf();\n        if (displayEventTime && !eventDef.allDay && (isStartDay || isEndDay)) {\n            segStart = isStartDay ? wholeEventStart : segStart;\n            segEnd = isEndDay ? wholeEventEnd : segEnd;\n            if (displayEventEnd && eventDef.hasEnd) {\n                return dateEnv.formatRange(segStart, segEnd, timeFormat, {\n                    forcedStartTzo: startOverride ? null : eventInstance.forcedStartTzo,\n                    forcedEndTzo: endOverride ? null : eventInstance.forcedEndTzo\n                });\n            }\n            return dateEnv.format(segStart, timeFormat, {\n                forcedTzo: startOverride ? null : eventInstance.forcedStartTzo\n            });\n        }\n        return '';\n    }\n    function getSegMeta(seg, todayRange, nowDate) {\n        let segRange = seg.eventRange.range;\n        return {\n            isPast: segRange.end < (nowDate || todayRange.start),\n            isFuture: segRange.start >= (nowDate || todayRange.end),\n            isToday: todayRange && rangeContainsMarker(todayRange, segRange.start)\n        };\n    }\n    function getEventClassNames(props) {\n        let classNames = [\n            'fc-event'\n        ];\n        if (props.isMirror) {\n            classNames.push('fc-event-mirror');\n        }\n        if (props.isDraggable) {\n            classNames.push('fc-event-draggable');\n        }\n        if (props.isStartResizable || props.isEndResizable) {\n            classNames.push('fc-event-resizable');\n        }\n        if (props.isDragging) {\n            classNames.push('fc-event-dragging');\n        }\n        if (props.isResizing) {\n            classNames.push('fc-event-resizing');\n        }\n        if (props.isSelected) {\n            classNames.push('fc-event-selected');\n        }\n        if (props.isStart) {\n            classNames.push('fc-event-start');\n        }\n        if (props.isEnd) {\n            classNames.push('fc-event-end');\n        }\n        if (props.isPast) {\n            classNames.push('fc-event-past');\n        }\n        if (props.isToday) {\n            classNames.push('fc-event-today');\n        }\n        if (props.isFuture) {\n            classNames.push('fc-event-future');\n        }\n        return classNames;\n    }\n    function buildEventRangeKey(eventRange) {\n        return eventRange.instance ? eventRange.instance.instanceId : \"\".concat(eventRange.def.defId, \":\").concat(eventRange.range.start.toISOString());\n    // inverse-background events don't have specific instances. TODO: better solution\n    }\n    function getSegAnchorAttrs(seg, context) {\n        let { def, instance } = seg.eventRange;\n        let { url } = def;\n        if (url) {\n            return {\n                href: url\n            };\n        }\n        let { emitter, options } = context;\n        let { eventInteractive } = options;\n        if (eventInteractive == null) {\n            eventInteractive = def.interactive;\n            if (eventInteractive == null) {\n                eventInteractive = Boolean(emitter.hasHandlers('eventClick'));\n            }\n        }\n        // mock what happens in EventClicking\n        if (eventInteractive) {\n            // only attach keyboard-related handlers because click handler is already done in EventClicking\n            return createAriaKeyboardAttrs((ev)=>{\n                emitter.trigger('eventClick', {\n                    el: ev.target,\n                    event: new EventImpl(context, def, instance),\n                    jsEvent: ev,\n                    view: context.viewApi\n                });\n            });\n        }\n        return {};\n    }\n    const STANDARD_PROPS = {\n        start: identity,\n        end: identity,\n        allDay: Boolean\n    };\n    function parseDateSpan(raw, dateEnv, defaultDuration) {\n        let span = parseOpenDateSpan(raw, dateEnv);\n        let { range } = span;\n        if (!range.start) {\n            return null;\n        }\n        if (!range.end) {\n            if (defaultDuration == null) {\n                return null;\n            }\n            range.end = dateEnv.add(range.start, defaultDuration);\n        }\n        return span;\n    }\n    /*\r\n    TODO: somehow combine with parseRange?\r\n    Will return null if the start/end props were present but parsed invalidly.\r\n    */ function parseOpenDateSpan(raw, dateEnv) {\n        let { refined: standardProps, extra } = refineProps(raw, STANDARD_PROPS);\n        let startMeta = standardProps.start ? dateEnv.createMarkerMeta(standardProps.start) : null;\n        let endMeta = standardProps.end ? dateEnv.createMarkerMeta(standardProps.end) : null;\n        let { allDay } = standardProps;\n        if (allDay == null) {\n            allDay = startMeta && startMeta.isTimeUnspecified && (!endMeta || endMeta.isTimeUnspecified);\n        }\n        return Object.assign({\n            range: {\n                start: startMeta ? startMeta.marker : null,\n                end: endMeta ? endMeta.marker : null\n            },\n            allDay\n        }, extra);\n    }\n    function isDateSpansEqual(span0, span1) {\n        return rangesEqual(span0.range, span1.range) && span0.allDay === span1.allDay && isSpanPropsEqual(span0, span1);\n    }\n    // the NON-DATE-RELATED props\n    function isSpanPropsEqual(span0, span1) {\n        for(let propName in span1){\n            if (propName !== 'range' && propName !== 'allDay') {\n                if (span0[propName] !== span1[propName]) {\n                    return false;\n                }\n            }\n        }\n        // are there any props that span0 has that span1 DOESN'T have?\n        // both have range/allDay, so no need to special-case.\n        for(let propName in span0){\n            if (!(propName in span1)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    function buildDateSpanApi(span, dateEnv) {\n        return Object.assign(Object.assign({}, buildRangeApi(span.range, dateEnv, span.allDay)), {\n            allDay: span.allDay\n        });\n    }\n    function buildRangeApiWithTimeZone(range, dateEnv, omitTime) {\n        return Object.assign(Object.assign({}, buildRangeApi(range, dateEnv, omitTime)), {\n            timeZone: dateEnv.timeZone\n        });\n    }\n    function buildRangeApi(range, dateEnv, omitTime) {\n        return {\n            start: dateEnv.toDate(range.start),\n            end: dateEnv.toDate(range.end),\n            startStr: dateEnv.formatIso(range.start, {\n                omitTime\n            }),\n            endStr: dateEnv.formatIso(range.end, {\n                omitTime\n            })\n        };\n    }\n    function fabricateEventRange(dateSpan, eventUiBases, context) {\n        let res = refineEventDef({\n            editable: false\n        }, context);\n        let def = parseEventDef(res.refined, res.extra, '', dateSpan.allDay, true, context);\n        return {\n            def,\n            ui: compileEventUi(def, eventUiBases),\n            instance: createEventInstance(def.defId, dateSpan.range),\n            range: dateSpan.range,\n            isStart: true,\n            isEnd: true\n        };\n    }\n    let calendarSystemClassMap = {};\n    function registerCalendarSystem(name, theClass) {\n        calendarSystemClassMap[name] = theClass;\n    }\n    function createCalendarSystem(name) {\n        return new calendarSystemClassMap[name]();\n    }\n    class GregorianCalendarSystem {\n        getMarkerYear(d) {\n            return d.getUTCFullYear();\n        }\n        getMarkerMonth(d) {\n            return d.getUTCMonth();\n        }\n        getMarkerDay(d) {\n            return d.getUTCDate();\n        }\n        arrayToMarker(arr) {\n            return arrayToUtcDate(arr);\n        }\n        markerToArray(marker) {\n            return dateToUtcArray(marker);\n        }\n    }\n    registerCalendarSystem('gregory', GregorianCalendarSystem);\n    const ISO_RE = /^\\s*(\\d{4})(-?(\\d{2})(-?(\\d{2})([T ](\\d{2}):?(\\d{2})(:?(\\d{2})(\\.(\\d+))?)?(Z|(([-+])(\\d{2})(:?(\\d{2}))?))?)?)?)?$/;\n    function parse(str) {\n        let m = ISO_RE.exec(str);\n        if (m) {\n            let marker = new Date(Date.UTC(Number(m[1]), m[3] ? Number(m[3]) - 1 : 0, Number(m[5] || 1), Number(m[7] || 0), Number(m[8] || 0), Number(m[10] || 0), m[12] ? Number(\"0.\".concat(m[12])) * 1000 : 0));\n            if (isValidDate(marker)) {\n                let timeZoneOffset = null;\n                if (m[13]) {\n                    timeZoneOffset = (m[15] === '-' ? -1 : 1) * (Number(m[16] || 0) * 60 + Number(m[18] || 0));\n                }\n                return {\n                    marker,\n                    isTimeUnspecified: !m[6],\n                    timeZoneOffset\n                };\n            }\n        }\n        return null;\n    }\n    class DateEnv {\n        // Creating / Parsing\n        createMarker(input) {\n            let meta = this.createMarkerMeta(input);\n            if (meta === null) {\n                return null;\n            }\n            return meta.marker;\n        }\n        createNowMarker() {\n            if (this.canComputeOffset) {\n                return this.timestampToMarker(new Date().valueOf());\n            }\n            // if we can't compute the current date val for a timezone,\n            // better to give the current local date vals than UTC\n            return arrayToUtcDate(dateToLocalArray(new Date()));\n        }\n        createMarkerMeta(input) {\n            if (typeof input === 'string') {\n                return this.parse(input);\n            }\n            let marker = null;\n            if (typeof input === 'number') {\n                marker = this.timestampToMarker(input);\n            } else if (input instanceof Date) {\n                input = input.valueOf();\n                if (!isNaN(input)) {\n                    marker = this.timestampToMarker(input);\n                }\n            } else if (Array.isArray(input)) {\n                marker = arrayToUtcDate(input);\n            }\n            if (marker === null || !isValidDate(marker)) {\n                return null;\n            }\n            return {\n                marker,\n                isTimeUnspecified: false,\n                forcedTzo: null\n            };\n        }\n        parse(s) {\n            let parts = parse(s);\n            if (parts === null) {\n                return null;\n            }\n            let { marker } = parts;\n            let forcedTzo = null;\n            if (parts.timeZoneOffset !== null) {\n                if (this.canComputeOffset) {\n                    marker = this.timestampToMarker(marker.valueOf() - parts.timeZoneOffset * 60 * 1000);\n                } else {\n                    forcedTzo = parts.timeZoneOffset;\n                }\n            }\n            return {\n                marker,\n                isTimeUnspecified: parts.isTimeUnspecified,\n                forcedTzo\n            };\n        }\n        // Accessors\n        getYear(marker) {\n            return this.calendarSystem.getMarkerYear(marker);\n        }\n        getMonth(marker) {\n            return this.calendarSystem.getMarkerMonth(marker);\n        }\n        getDay(marker) {\n            return this.calendarSystem.getMarkerDay(marker);\n        }\n        // Adding / Subtracting\n        add(marker, dur) {\n            let a = this.calendarSystem.markerToArray(marker);\n            a[0] += dur.years;\n            a[1] += dur.months;\n            a[2] += dur.days;\n            a[6] += dur.milliseconds;\n            return this.calendarSystem.arrayToMarker(a);\n        }\n        subtract(marker, dur) {\n            let a = this.calendarSystem.markerToArray(marker);\n            a[0] -= dur.years;\n            a[1] -= dur.months;\n            a[2] -= dur.days;\n            a[6] -= dur.milliseconds;\n            return this.calendarSystem.arrayToMarker(a);\n        }\n        addYears(marker, n) {\n            let a = this.calendarSystem.markerToArray(marker);\n            a[0] += n;\n            return this.calendarSystem.arrayToMarker(a);\n        }\n        addMonths(marker, n) {\n            let a = this.calendarSystem.markerToArray(marker);\n            a[1] += n;\n            return this.calendarSystem.arrayToMarker(a);\n        }\n        // Diffing Whole Units\n        diffWholeYears(m0, m1) {\n            let { calendarSystem } = this;\n            if (timeAsMs(m0) === timeAsMs(m1) && calendarSystem.getMarkerDay(m0) === calendarSystem.getMarkerDay(m1) && calendarSystem.getMarkerMonth(m0) === calendarSystem.getMarkerMonth(m1)) {\n                return calendarSystem.getMarkerYear(m1) - calendarSystem.getMarkerYear(m0);\n            }\n            return null;\n        }\n        diffWholeMonths(m0, m1) {\n            let { calendarSystem } = this;\n            if (timeAsMs(m0) === timeAsMs(m1) && calendarSystem.getMarkerDay(m0) === calendarSystem.getMarkerDay(m1)) {\n                return calendarSystem.getMarkerMonth(m1) - calendarSystem.getMarkerMonth(m0) + (calendarSystem.getMarkerYear(m1) - calendarSystem.getMarkerYear(m0)) * 12;\n            }\n            return null;\n        }\n        // Range / Duration\n        greatestWholeUnit(m0, m1) {\n            let n = this.diffWholeYears(m0, m1);\n            if (n !== null) {\n                return {\n                    unit: 'year',\n                    value: n\n                };\n            }\n            n = this.diffWholeMonths(m0, m1);\n            if (n !== null) {\n                return {\n                    unit: 'month',\n                    value: n\n                };\n            }\n            n = diffWholeWeeks(m0, m1);\n            if (n !== null) {\n                return {\n                    unit: 'week',\n                    value: n\n                };\n            }\n            n = diffWholeDays(m0, m1);\n            if (n !== null) {\n                return {\n                    unit: 'day',\n                    value: n\n                };\n            }\n            n = diffHours(m0, m1);\n            if (isInt(n)) {\n                return {\n                    unit: 'hour',\n                    value: n\n                };\n            }\n            n = diffMinutes(m0, m1);\n            if (isInt(n)) {\n                return {\n                    unit: 'minute',\n                    value: n\n                };\n            }\n            n = diffSeconds(m0, m1);\n            if (isInt(n)) {\n                return {\n                    unit: 'second',\n                    value: n\n                };\n            }\n            return {\n                unit: 'millisecond',\n                value: m1.valueOf() - m0.valueOf()\n            };\n        }\n        countDurationsBetween(m0, m1, d) {\n            // TODO: can use greatestWholeUnit\n            let diff;\n            if (d.years) {\n                diff = this.diffWholeYears(m0, m1);\n                if (diff !== null) {\n                    return diff / asRoughYears(d);\n                }\n            }\n            if (d.months) {\n                diff = this.diffWholeMonths(m0, m1);\n                if (diff !== null) {\n                    return diff / asRoughMonths(d);\n                }\n            }\n            if (d.days) {\n                diff = diffWholeDays(m0, m1);\n                if (diff !== null) {\n                    return diff / asRoughDays(d);\n                }\n            }\n            return (m1.valueOf() - m0.valueOf()) / asRoughMs(d);\n        }\n        // Start-Of\n        // these DON'T return zoned-dates. only UTC start-of dates\n        startOf(m, unit) {\n            if (unit === 'year') {\n                return this.startOfYear(m);\n            }\n            if (unit === 'month') {\n                return this.startOfMonth(m);\n            }\n            if (unit === 'week') {\n                return this.startOfWeek(m);\n            }\n            if (unit === 'day') {\n                return startOfDay(m);\n            }\n            if (unit === 'hour') {\n                return startOfHour(m);\n            }\n            if (unit === 'minute') {\n                return startOfMinute(m);\n            }\n            if (unit === 'second') {\n                return startOfSecond(m);\n            }\n            return null;\n        }\n        startOfYear(m) {\n            return this.calendarSystem.arrayToMarker([\n                this.calendarSystem.getMarkerYear(m)\n            ]);\n        }\n        startOfMonth(m) {\n            return this.calendarSystem.arrayToMarker([\n                this.calendarSystem.getMarkerYear(m),\n                this.calendarSystem.getMarkerMonth(m)\n            ]);\n        }\n        startOfWeek(m) {\n            return this.calendarSystem.arrayToMarker([\n                this.calendarSystem.getMarkerYear(m),\n                this.calendarSystem.getMarkerMonth(m),\n                m.getUTCDate() - (m.getUTCDay() - this.weekDow + 7) % 7\n            ]);\n        }\n        // Week Number\n        computeWeekNumber(marker) {\n            if (this.weekNumberFunc) {\n                return this.weekNumberFunc(this.toDate(marker));\n            }\n            return weekOfYear(marker, this.weekDow, this.weekDoy);\n        }\n        // TODO: choke on timeZoneName: long\n        format(marker, formatter) {\n            let dateOptions = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n            return formatter.format({\n                marker,\n                timeZoneOffset: dateOptions.forcedTzo != null ? dateOptions.forcedTzo : this.offsetForMarker(marker)\n            }, this);\n        }\n        formatRange(start, end, formatter) {\n            let dateOptions = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};\n            if (dateOptions.isEndExclusive) {\n                end = addMs(end, -1);\n            }\n            return formatter.formatRange({\n                marker: start,\n                timeZoneOffset: dateOptions.forcedStartTzo != null ? dateOptions.forcedStartTzo : this.offsetForMarker(start)\n            }, {\n                marker: end,\n                timeZoneOffset: dateOptions.forcedEndTzo != null ? dateOptions.forcedEndTzo : this.offsetForMarker(end)\n            }, this, dateOptions.defaultSeparator);\n        }\n        /*\r\n        DUMB: the omitTime arg is dumb. if we omit the time, we want to omit the timezone offset. and if we do that,\r\n        might as well use buildIsoString or some other util directly\r\n        */ formatIso(marker) {\n            let extraOptions = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n            let timeZoneOffset = null;\n            if (!extraOptions.omitTimeZoneOffset) {\n                if (extraOptions.forcedTzo != null) {\n                    timeZoneOffset = extraOptions.forcedTzo;\n                } else {\n                    timeZoneOffset = this.offsetForMarker(marker);\n                }\n            }\n            return buildIsoString(marker, timeZoneOffset, extraOptions.omitTime);\n        }\n        // TimeZone\n        timestampToMarker(ms) {\n            if (this.timeZone === 'local') {\n                return arrayToUtcDate(dateToLocalArray(new Date(ms)));\n            }\n            if (this.timeZone === 'UTC' || !this.namedTimeZoneImpl) {\n                return new Date(ms);\n            }\n            return arrayToUtcDate(this.namedTimeZoneImpl.timestampToArray(ms));\n        }\n        offsetForMarker(m) {\n            if (this.timeZone === 'local') {\n                return -arrayToLocalDate(dateToUtcArray(m)).getTimezoneOffset(); // convert \"inverse\" offset to \"normal\" offset\n            }\n            if (this.timeZone === 'UTC') {\n                return 0;\n            }\n            if (this.namedTimeZoneImpl) {\n                return this.namedTimeZoneImpl.offsetForArray(dateToUtcArray(m));\n            }\n            return null;\n        }\n        // Conversion\n        toDate(m, forcedTzo) {\n            if (this.timeZone === 'local') {\n                return arrayToLocalDate(dateToUtcArray(m));\n            }\n            if (this.timeZone === 'UTC') {\n                return new Date(m.valueOf()); // make sure it's a copy\n            }\n            if (!this.namedTimeZoneImpl) {\n                return new Date(m.valueOf() - (forcedTzo || 0));\n            }\n            return new Date(m.valueOf() - this.namedTimeZoneImpl.offsetForArray(dateToUtcArray(m)) * 1000 * 60);\n        }\n        constructor(settings){\n            let timeZone = this.timeZone = settings.timeZone;\n            let isNamedTimeZone = timeZone !== 'local' && timeZone !== 'UTC';\n            if (settings.namedTimeZoneImpl && isNamedTimeZone) {\n                this.namedTimeZoneImpl = new settings.namedTimeZoneImpl(timeZone);\n            }\n            this.canComputeOffset = Boolean(!isNamedTimeZone || this.namedTimeZoneImpl);\n            this.calendarSystem = createCalendarSystem(settings.calendarSystem);\n            this.locale = settings.locale;\n            this.weekDow = settings.locale.week.dow;\n            this.weekDoy = settings.locale.week.doy;\n            if (settings.weekNumberCalculation === 'ISO') {\n                this.weekDow = 1;\n                this.weekDoy = 4;\n            }\n            if (typeof settings.firstDay === 'number') {\n                this.weekDow = settings.firstDay;\n            }\n            if (typeof settings.weekNumberCalculation === 'function') {\n                this.weekNumberFunc = settings.weekNumberCalculation;\n            }\n            this.weekText = settings.weekText != null ? settings.weekText : settings.locale.options.weekText;\n            this.weekTextLong = (settings.weekTextLong != null ? settings.weekTextLong : settings.locale.options.weekTextLong) || this.weekText;\n            this.cmdFormatter = settings.cmdFormatter;\n            this.defaultSeparator = settings.defaultSeparator;\n        }\n    }\n    class NamedTimeZoneImpl {\n        constructor(timeZoneName){\n            this.timeZoneName = timeZoneName;\n        }\n    }\n    class SegHierarchy {\n        addSegs(inputs) {\n            let hiddenEntries = [];\n            for (let input of inputs){\n                this.insertEntry(input, hiddenEntries);\n            }\n            return hiddenEntries;\n        }\n        insertEntry(entry, hiddenEntries) {\n            let insertion = this.findInsertion(entry);\n            if (this.isInsertionValid(insertion, entry)) {\n                this.insertEntryAt(entry, insertion);\n                return 1;\n            }\n            return this.handleInvalidInsertion(insertion, entry, hiddenEntries);\n        }\n        isInsertionValid(insertion, entry) {\n            return (this.maxCoord === -1 || insertion.levelCoord + entry.thickness <= this.maxCoord) && (this.maxStackCnt === -1 || insertion.stackCnt < this.maxStackCnt);\n        }\n        // returns number of new entries inserted\n        handleInvalidInsertion(insertion, entry, hiddenEntries) {\n            if (this.allowReslicing && insertion.touchingEntry) {\n                return this.splitEntry(entry, insertion.touchingEntry, hiddenEntries);\n            }\n            hiddenEntries.push(entry);\n            return 0;\n        }\n        splitEntry(entry, barrier, hiddenEntries) {\n            let partCnt = 0;\n            let splitHiddenEntries = [];\n            let entrySpan = entry.span;\n            let barrierSpan = barrier.span;\n            if (entrySpan.start < barrierSpan.start) {\n                partCnt += this.insertEntry({\n                    index: entry.index,\n                    thickness: entry.thickness,\n                    span: {\n                        start: entrySpan.start,\n                        end: barrierSpan.start\n                    }\n                }, splitHiddenEntries);\n            }\n            if (entrySpan.end > barrierSpan.end) {\n                partCnt += this.insertEntry({\n                    index: entry.index,\n                    thickness: entry.thickness,\n                    span: {\n                        start: barrierSpan.end,\n                        end: entrySpan.end\n                    }\n                }, splitHiddenEntries);\n            }\n            if (partCnt) {\n                hiddenEntries.push({\n                    index: entry.index,\n                    thickness: entry.thickness,\n                    span: intersectSpans(barrierSpan, entrySpan)\n                }, ...splitHiddenEntries);\n                return partCnt;\n            }\n            hiddenEntries.push(entry);\n            return 0;\n        }\n        insertEntryAt(entry, insertion) {\n            let { entriesByLevel, levelCoords } = this;\n            if (insertion.lateral === -1) {\n                // create a new level\n                insertAt(levelCoords, insertion.level, insertion.levelCoord);\n                insertAt(entriesByLevel, insertion.level, [\n                    entry\n                ]);\n            } else {\n                // insert into existing level\n                insertAt(entriesByLevel[insertion.level], insertion.lateral, entry);\n            }\n            this.stackCnts[buildEntryKey(entry)] = insertion.stackCnt;\n        }\n        findInsertion(newEntry) {\n            let { levelCoords, entriesByLevel, strictOrder, stackCnts } = this;\n            let levelCnt = levelCoords.length;\n            let candidateCoord = 0;\n            let touchingLevel = -1;\n            let touchingLateral = -1;\n            let touchingEntry = null;\n            let stackCnt = 0;\n            for(let trackingLevel = 0; trackingLevel < levelCnt; trackingLevel += 1){\n                let trackingCoord = levelCoords[trackingLevel];\n                // if the current level is past the placed entry, we have found a good empty space and can stop.\n                // if strictOrder, keep finding more lateral intersections.\n                if (!strictOrder && trackingCoord >= candidateCoord + newEntry.thickness) {\n                    break;\n                }\n                let trackingEntries = entriesByLevel[trackingLevel];\n                let trackingEntry;\n                let searchRes = binarySearch(trackingEntries, newEntry.span.start, getEntrySpanEnd); // find first entry after newEntry's end\n                let lateralIndex = searchRes[0] + searchRes[1]; // if exact match (which doesn't collide), go to next one\n                while((trackingEntry = trackingEntries[lateralIndex]) && // but not past the whole entry list\n                trackingEntry.span.start < newEntry.span.end // and not entirely past newEntry\n                ){\n                    let trackingEntryBottom = trackingCoord + trackingEntry.thickness;\n                    // intersects into the top of the candidate?\n                    if (trackingEntryBottom > candidateCoord) {\n                        candidateCoord = trackingEntryBottom;\n                        touchingEntry = trackingEntry;\n                        touchingLevel = trackingLevel;\n                        touchingLateral = lateralIndex;\n                    }\n                    // butts up against top of candidate? (will happen if just intersected as well)\n                    if (trackingEntryBottom === candidateCoord) {\n                        // accumulate the highest possible stackCnt of the trackingEntries that butt up\n                        stackCnt = Math.max(stackCnt, stackCnts[buildEntryKey(trackingEntry)] + 1);\n                    }\n                    lateralIndex += 1;\n                }\n            }\n            // the destination level will be after touchingEntry's level. find it\n            let destLevel = 0;\n            if (touchingEntry) {\n                destLevel = touchingLevel + 1;\n                while(destLevel < levelCnt && levelCoords[destLevel] < candidateCoord){\n                    destLevel += 1;\n                }\n            }\n            // if adding to an existing level, find where to insert\n            let destLateral = -1;\n            if (destLevel < levelCnt && levelCoords[destLevel] === candidateCoord) {\n                destLateral = binarySearch(entriesByLevel[destLevel], newEntry.span.end, getEntrySpanEnd)[0];\n            }\n            return {\n                touchingLevel,\n                touchingLateral,\n                touchingEntry,\n                stackCnt,\n                levelCoord: candidateCoord,\n                level: destLevel,\n                lateral: destLateral\n            };\n        }\n        // sorted by levelCoord (lowest to highest)\n        toRects() {\n            let { entriesByLevel, levelCoords } = this;\n            let levelCnt = entriesByLevel.length;\n            let rects = [];\n            for(let level = 0; level < levelCnt; level += 1){\n                let entries = entriesByLevel[level];\n                let levelCoord = levelCoords[level];\n                for (let entry of entries){\n                    rects.push(Object.assign(Object.assign({}, entry), {\n                        levelCoord\n                    }));\n                }\n            }\n            return rects;\n        }\n        constructor(){\n            // settings\n            this.strictOrder = false;\n            this.allowReslicing = false;\n            this.maxCoord = -1; // -1 means no max\n            this.maxStackCnt = -1; // -1 means no max\n            this.levelCoords = []; // ordered\n            this.entriesByLevel = []; // parallel with levelCoords\n            this.stackCnts = {}; // TODO: use better technique!?\n        }\n    }\n    function getEntrySpanEnd(entry) {\n        return entry.span.end;\n    }\n    function buildEntryKey(entry) {\n        return entry.index + ':' + entry.span.start;\n    }\n    // returns groups with entries sorted by input order\n    function groupIntersectingEntries(entries) {\n        let merges = [];\n        for (let entry of entries){\n            let filteredMerges = [];\n            let hungryMerge = {\n                span: entry.span,\n                entries: [\n                    entry\n                ]\n            };\n            for (let merge of merges){\n                if (intersectSpans(merge.span, hungryMerge.span)) {\n                    hungryMerge = {\n                        entries: merge.entries.concat(hungryMerge.entries),\n                        span: joinSpans(merge.span, hungryMerge.span)\n                    };\n                } else {\n                    filteredMerges.push(merge);\n                }\n            }\n            filteredMerges.push(hungryMerge);\n            merges = filteredMerges;\n        }\n        return merges;\n    }\n    function joinSpans(span0, span1) {\n        return {\n            start: Math.min(span0.start, span1.start),\n            end: Math.max(span0.end, span1.end)\n        };\n    }\n    function intersectSpans(span0, span1) {\n        let start = Math.max(span0.start, span1.start);\n        let end = Math.min(span0.end, span1.end);\n        if (start < end) {\n            return {\n                start,\n                end\n            };\n        }\n        return null;\n    }\n    // general util\n    // ---------------------------------------------------------------------------------------------------------------------\n    function insertAt(arr, index, item) {\n        arr.splice(index, 0, item);\n    }\n    function binarySearch(a, searchVal, getItemVal) {\n        let startIndex = 0;\n        let endIndex = a.length; // exclusive\n        if (!endIndex || searchVal < getItemVal(a[startIndex])) {\n            return [\n                0,\n                0\n            ];\n        }\n        if (searchVal > getItemVal(a[endIndex - 1])) {\n            return [\n                endIndex,\n                0\n            ];\n        }\n        while(startIndex < endIndex){\n            let middleIndex = Math.floor(startIndex + (endIndex - startIndex) / 2);\n            let middleVal = getItemVal(a[middleIndex]);\n            if (searchVal < middleVal) {\n                endIndex = middleIndex;\n            } else if (searchVal > middleVal) {\n                startIndex = middleIndex + 1;\n            } else {\n                return [\n                    middleIndex,\n                    1\n                ];\n            }\n        }\n        return [\n            startIndex,\n            0\n        ];\n    }\n    class Interaction {\n        destroy() {}\n        constructor(settings){\n            this.component = settings.component;\n            this.isHitComboAllowed = settings.isHitComboAllowed || null;\n        }\n    }\n    function parseInteractionSettings(component, input) {\n        return {\n            component,\n            el: input.el,\n            useEventCenter: input.useEventCenter != null ? input.useEventCenter : true,\n            isHitComboAllowed: input.isHitComboAllowed || null\n        };\n    }\n    function interactionSettingsToStore(settings) {\n        return {\n            [settings.component.uid]: settings\n        };\n    }\n    // global state\n    const interactionSettingsStore = {};\n    /*\r\n    An abstraction for a dragging interaction originating on an event.\r\n    Does higher-level things than PointerDragger, such as possibly:\r\n    - a \"mirror\" that moves with the pointer\r\n    - a minimum number of pixels or other criteria for a true drag to begin\r\n\r\n    subclasses must emit:\r\n    - pointerdown\r\n    - dragstart\r\n    - dragmove\r\n    - pointerup\r\n    - dragend\r\n    */ class ElementDragging {\n        destroy() {}\n        setMirrorIsVisible(bool) {\n        // optional if subclass doesn't want to support a mirror\n        }\n        setMirrorNeedsRevert(bool) {\n        // optional if subclass doesn't want to support a mirror\n        }\n        setAutoScrollEnabled(bool) {\n        // optional\n        }\n        constructor(el, selector){\n            this.emitter = new Emitter();\n        }\n    }\n    // TODO: get rid of this in favor of options system,\n    // tho it's really easy to access this globally rather than pass thru options.\n    const config = {};\n    /*\r\n    Information about what will happen when an external element is dragged-and-dropped\r\n    onto a calendar. Contains information for creating an event.\r\n    */ const DRAG_META_REFINERS = {\n        startTime: createDuration,\n        duration: createDuration,\n        create: Boolean,\n        sourceId: String\n    };\n    function parseDragMeta(raw) {\n        let { refined, extra } = refineProps(raw, DRAG_META_REFINERS);\n        return {\n            startTime: refined.startTime || null,\n            duration: refined.duration || null,\n            create: refined.create != null ? refined.create : true,\n            sourceId: refined.sourceId,\n            leftoverProps: extra\n        };\n    }\n    class CalendarRoot extends BaseComponent {\n        render() {\n            let { props } = this;\n            let { options } = props;\n            let { forPrint } = this.state;\n            let isHeightAuto = forPrint || options.height === 'auto' || options.contentHeight === 'auto';\n            let height = !isHeightAuto && options.height != null ? options.height : '';\n            let classNames = [\n                'fc',\n                forPrint ? 'fc-media-print' : 'fc-media-screen',\n                \"fc-direction-\".concat(options.direction),\n                props.theme.getClass('root')\n            ];\n            if (!getCanVGrowWithinCell()) {\n                classNames.push('fc-liquid-hack');\n            }\n            return props.children(classNames, height, isHeightAuto, forPrint);\n        }\n        componentDidMount() {\n            let { emitter } = this.props;\n            emitter.on('_beforeprint', this.handleBeforePrint);\n            emitter.on('_afterprint', this.handleAfterPrint);\n        }\n        componentWillUnmount() {\n            let { emitter } = this.props;\n            emitter.off('_beforeprint', this.handleBeforePrint);\n            emitter.off('_afterprint', this.handleAfterPrint);\n        }\n        constructor(){\n            super(...arguments);\n            this.state = {\n                forPrint: false\n            };\n            this.handleBeforePrint = ()=>{\n                this.setState({\n                    forPrint: true\n                });\n            };\n            this.handleAfterPrint = ()=>{\n                this.setState({\n                    forPrint: false\n                });\n            };\n        }\n    }\n    // Computes a default column header formatting string if `colFormat` is not explicitly defined\n    function computeFallbackHeaderFormat(datesRepDistinctDays, dayCnt) {\n        // if more than one week row, or if there are a lot of columns with not much space,\n        // put just the day numbers will be in each cell\n        if (!datesRepDistinctDays || dayCnt > 10) {\n            return createFormatter({\n                weekday: 'short'\n            }); // \"Sat\"\n        }\n        if (dayCnt > 1) {\n            return createFormatter({\n                weekday: 'short',\n                month: 'numeric',\n                day: 'numeric',\n                omitCommas: true\n            }); // \"Sat 11/12\"\n        }\n        return createFormatter({\n            weekday: 'long'\n        }); // \"Saturday\"\n    }\n    const CLASS_NAME = 'fc-col-header-cell'; // do the cushion too? no\n    function renderInner$1(renderProps) {\n        return renderProps.text;\n    }\n    class ContentInjector extends BaseComponent {\n        render() {\n            const { props, context } = this;\n            const { options } = context;\n            const { customGenerator, defaultGenerator, renderProps } = props;\n            const attrs = buildElAttrs(props);\n            let useDefault = false;\n            let innerContent;\n            let queuedDomNodes = [];\n            let currentGeneratorMeta;\n            if (customGenerator != null) {\n                const customGeneratorRes = typeof customGenerator === 'function' ? customGenerator(renderProps, y) : customGenerator;\n                if (customGeneratorRes === true) {\n                    useDefault = true;\n                } else {\n                    const isObject = customGeneratorRes && typeof customGeneratorRes === 'object'; // non-null\n                    if (isObject && 'html' in customGeneratorRes) {\n                        attrs.dangerouslySetInnerHTML = {\n                            __html: customGeneratorRes.html\n                        };\n                    } else if (isObject && 'domNodes' in customGeneratorRes) {\n                        queuedDomNodes = Array.prototype.slice.call(customGeneratorRes.domNodes);\n                    } else if (!isObject && typeof customGeneratorRes !== 'function') {\n                        // primitive value (like string or number)\n                        innerContent = customGeneratorRes;\n                    } else {\n                        // an exotic object for handleCustomRendering\n                        currentGeneratorMeta = customGeneratorRes;\n                    }\n                }\n            } else {\n                useDefault = !hasCustomRenderingHandler(props.generatorName, options);\n            }\n            if (useDefault && defaultGenerator) {\n                innerContent = defaultGenerator(renderProps);\n            }\n            this.queuedDomNodes = queuedDomNodes;\n            this.currentGeneratorMeta = currentGeneratorMeta;\n            return y(props.elTag, attrs, innerContent);\n        }\n        componentDidMount() {\n            this.applyQueueudDomNodes();\n            this.triggerCustomRendering(true);\n        }\n        componentDidUpdate() {\n            this.applyQueueudDomNodes();\n            this.triggerCustomRendering(true);\n        }\n        componentWillUnmount() {\n            this.triggerCustomRendering(false); // TODO: different API for removal?\n        }\n        triggerCustomRendering(isActive) {\n            var _a;\n            const { props, context } = this;\n            const { handleCustomRendering, customRenderingMetaMap } = context.options;\n            if (handleCustomRendering) {\n                const generatorMeta = (_a = this.currentGeneratorMeta) !== null && _a !== void 0 ? _a : customRenderingMetaMap === null || customRenderingMetaMap === void 0 ? void 0 : customRenderingMetaMap[props.generatorName];\n                if (generatorMeta) {\n                    handleCustomRendering(Object.assign(Object.assign({\n                        id: this.id,\n                        isActive,\n                        containerEl: this.base,\n                        reportNewContainerEl: this.handleEl,\n                        generatorMeta\n                    }, props), {\n                        elClasses: (props.elClasses || []).filter(isTruthy)\n                    }));\n                }\n            }\n        }\n        applyQueueudDomNodes() {\n            const { queuedDomNodes, currentDomNodes } = this;\n            const el = this.base;\n            if (!isArraysEqual(queuedDomNodes, currentDomNodes)) {\n                currentDomNodes.forEach(removeElement);\n                for (let newNode of queuedDomNodes){\n                    el.appendChild(newNode);\n                }\n                this.currentDomNodes = queuedDomNodes;\n            }\n        }\n        constructor(){\n            super(...arguments);\n            this.id = guid();\n            this.queuedDomNodes = [];\n            this.currentDomNodes = [];\n            this.handleEl = (el)=>{\n                if (this.props.elRef) {\n                    setRef(this.props.elRef, el);\n                }\n            };\n        }\n    }\n    ContentInjector.addPropsEquality({\n        elClasses: isArraysEqual,\n        elStyle: isPropsEqual,\n        elAttrs: isNonHandlerPropsEqual,\n        renderProps: isPropsEqual\n    });\n    // Util\n    /*\r\n    Does UI-framework provide custom way of rendering?\r\n    */ function hasCustomRenderingHandler(generatorName, options) {\n        var _a;\n        return Boolean(options.handleCustomRendering && generatorName && ((_a = options.customRenderingMetaMap) === null || _a === void 0 ? void 0 : _a[generatorName]));\n    }\n    function buildElAttrs(props, extraClassNames) {\n        const attrs = Object.assign(Object.assign({}, props.elAttrs), {\n            ref: props.elRef\n        });\n        if (props.elClasses || extraClassNames) {\n            attrs.className = (props.elClasses || []).concat(extraClassNames || []).concat(attrs.className || []).filter(Boolean).join(' ');\n        }\n        if (props.elStyle) {\n            attrs.style = props.elStyle;\n        }\n        return attrs;\n    }\n    function isTruthy(val) {\n        return Boolean(val);\n    }\n    const RenderId = createContext(0);\n    class ContentContainer extends x$1 {\n        render() {\n            const { props } = this;\n            const generatedClassNames = generateClassNames(props.classNameGenerator, props.renderProps);\n            if (props.children) {\n                const elAttrs = buildElAttrs(props, generatedClassNames);\n                const children = props.children(this.InnerContent, props.renderProps, elAttrs);\n                if (props.elTag) {\n                    return y(props.elTag, elAttrs, children);\n                } else {\n                    return children;\n                }\n            } else {\n                return y(ContentInjector, Object.assign(Object.assign({}, props), {\n                    elRef: this.handleRootEl,\n                    elTag: props.elTag || 'div',\n                    elClasses: (props.elClasses || []).concat(generatedClassNames),\n                    renderId: this.context\n                }));\n            }\n        }\n        componentDidMount() {\n            var _a, _b;\n            (_b = (_a = this.props).didMount) === null || _b === void 0 ? void 0 : _b.call(_a, Object.assign(Object.assign({}, this.props.renderProps), {\n                el: this.rootEl || this.base\n            }));\n        }\n        componentWillUnmount() {\n            var _a, _b;\n            (_b = (_a = this.props).willUnmount) === null || _b === void 0 ? void 0 : _b.call(_a, Object.assign(Object.assign({}, this.props.renderProps), {\n                el: this.rootEl || this.base\n            }));\n        }\n        constructor(){\n            super(...arguments);\n            this.InnerContent = InnerContentInjector.bind(undefined, this);\n            this.handleRootEl = (el)=>{\n                this.rootEl = el;\n                if (this.props.elRef) {\n                    setRef(this.props.elRef, el);\n                }\n            };\n        }\n    }\n    ContentContainer.contextType = RenderId;\n    function InnerContentInjector(containerComponent, props) {\n        const parentProps = containerComponent.props;\n        return y(ContentInjector, Object.assign({\n            renderProps: parentProps.renderProps,\n            generatorName: parentProps.generatorName,\n            customGenerator: parentProps.customGenerator,\n            defaultGenerator: parentProps.defaultGenerator,\n            renderId: containerComponent.context\n        }, props));\n    }\n    // Utils\n    function generateClassNames(classNameGenerator, renderProps) {\n        const classNames = typeof classNameGenerator === 'function' ? classNameGenerator(renderProps) : classNameGenerator || [];\n        return typeof classNames === 'string' ? [\n            classNames\n        ] : classNames;\n    }\n    // BAD name for this class now. used in the Header\n    class TableDateCell extends BaseComponent {\n        render() {\n            let { dateEnv, options, theme, viewApi } = this.context;\n            let { props } = this;\n            let { date, dateProfile } = props;\n            let dayMeta = getDateMeta(date, props.todayRange, null, dateProfile);\n            let classNames = [\n                CLASS_NAME\n            ].concat(getDayClassNames(dayMeta, theme));\n            let text = dateEnv.format(date, props.dayHeaderFormat);\n            // if colCnt is 1, we are already in a day-view and don't need a navlink\n            let navLinkAttrs = !dayMeta.isDisabled && props.colCnt > 1 ? buildNavLinkAttrs(this.context, date) : {};\n            let renderProps = Object.assign(Object.assign(Object.assign({\n                date: dateEnv.toDate(date),\n                view: viewApi\n            }, props.extraRenderProps), {\n                text\n            }), dayMeta);\n            return y(ContentContainer, {\n                elTag: \"th\",\n                elClasses: classNames,\n                elAttrs: Object.assign({\n                    role: 'columnheader',\n                    colSpan: props.colSpan,\n                    'data-date': !dayMeta.isDisabled ? formatDayString(date) : undefined\n                }, props.extraDataAttrs),\n                renderProps: renderProps,\n                generatorName: \"dayHeaderContent\",\n                customGenerator: options.dayHeaderContent,\n                defaultGenerator: renderInner$1,\n                classNameGenerator: options.dayHeaderClassNames,\n                didMount: options.dayHeaderDidMount,\n                willUnmount: options.dayHeaderWillUnmount\n            }, (InnerContainer)=>y(\"div\", {\n                    className: \"fc-scrollgrid-sync-inner\"\n                }, !dayMeta.isDisabled && y(InnerContainer, {\n                    elTag: \"a\",\n                    elAttrs: navLinkAttrs,\n                    elClasses: [\n                        'fc-col-header-cell-cushion',\n                        props.isSticky && 'fc-sticky'\n                    ]\n                })));\n        }\n    }\n    const WEEKDAY_FORMAT = createFormatter({\n        weekday: 'long'\n    });\n    class TableDowCell extends BaseComponent {\n        render() {\n            let { props } = this;\n            let { dateEnv, theme, viewApi, options } = this.context;\n            let date = addDays(new Date(259200000), props.dow); // start with Sun, 04 Jan 1970 00:00:00 GMT\n            let dateMeta = {\n                dow: props.dow,\n                isDisabled: false,\n                isFuture: false,\n                isPast: false,\n                isToday: false,\n                isOther: false\n            };\n            let text = dateEnv.format(date, props.dayHeaderFormat);\n            let renderProps = Object.assign(Object.assign(Object.assign(Object.assign({\n                date\n            }, dateMeta), {\n                view: viewApi\n            }), props.extraRenderProps), {\n                text\n            });\n            return y(ContentContainer, {\n                elTag: \"th\",\n                elClasses: [\n                    CLASS_NAME,\n                    ...getDayClassNames(dateMeta, theme),\n                    ...props.extraClassNames || []\n                ],\n                elAttrs: Object.assign({\n                    role: 'columnheader',\n                    colSpan: props.colSpan\n                }, props.extraDataAttrs),\n                renderProps: renderProps,\n                generatorName: \"dayHeaderContent\",\n                customGenerator: options.dayHeaderContent,\n                defaultGenerator: renderInner$1,\n                classNameGenerator: options.dayHeaderClassNames,\n                didMount: options.dayHeaderDidMount,\n                willUnmount: options.dayHeaderWillUnmount\n            }, (InnerContent)=>y(\"div\", {\n                    className: \"fc-scrollgrid-sync-inner\"\n                }, y(InnerContent, {\n                    elTag: \"a\",\n                    elClasses: [\n                        'fc-col-header-cell-cushion',\n                        props.isSticky && 'fc-sticky'\n                    ],\n                    elAttrs: {\n                        'aria-label': dateEnv.format(date, WEEKDAY_FORMAT)\n                    }\n                })));\n        }\n    }\n    class NowTimer extends x$1 {\n        render() {\n            let { props, state } = this;\n            return props.children(state.nowDate, state.todayRange);\n        }\n        componentDidMount() {\n            this.setTimeout();\n        }\n        componentDidUpdate(prevProps) {\n            if (prevProps.unit !== this.props.unit) {\n                this.clearTimeout();\n                this.setTimeout();\n            }\n        }\n        componentWillUnmount() {\n            this.clearTimeout();\n        }\n        computeTiming() {\n            let { props, context } = this;\n            let unroundedNow = addMs(this.initialNowDate, new Date().valueOf() - this.initialNowQueriedMs);\n            let currentUnitStart = context.dateEnv.startOf(unroundedNow, props.unit);\n            let nextUnitStart = context.dateEnv.add(currentUnitStart, createDuration(1, props.unit));\n            let waitMs = nextUnitStart.valueOf() - unroundedNow.valueOf();\n            // there is a max setTimeout ms value (https://stackoverflow.com/a/3468650/96342)\n            // ensure no longer than a day\n            waitMs = Math.min(1000 * 60 * 60 * 24, waitMs);\n            return {\n                currentState: {\n                    nowDate: currentUnitStart,\n                    todayRange: buildDayRange(currentUnitStart)\n                },\n                nextState: {\n                    nowDate: nextUnitStart,\n                    todayRange: buildDayRange(nextUnitStart)\n                },\n                waitMs\n            };\n        }\n        setTimeout() {\n            let { nextState, waitMs } = this.computeTiming();\n            this.timeoutId = setTimeout(()=>{\n                this.setState(nextState, ()=>{\n                    this.setTimeout();\n                });\n            }, waitMs);\n        }\n        clearTimeout() {\n            if (this.timeoutId) {\n                clearTimeout(this.timeoutId);\n            }\n        }\n        constructor(props, context){\n            super(props, context);\n            this.initialNowDate = getNow(context.options.now, context.dateEnv);\n            this.initialNowQueriedMs = new Date().valueOf();\n            this.state = this.computeTiming().currentState;\n        }\n    }\n    NowTimer.contextType = ViewContextType;\n    function buildDayRange(date) {\n        let start = startOfDay(date);\n        let end = addDays(start, 1);\n        return {\n            start,\n            end\n        };\n    }\n    class DayHeader extends BaseComponent {\n        render() {\n            let { context } = this;\n            let { dates, dateProfile, datesRepDistinctDays, renderIntro } = this.props;\n            let dayHeaderFormat = this.createDayHeaderFormatter(context.options.dayHeaderFormat, datesRepDistinctDays, dates.length);\n            return y(NowTimer, {\n                unit: \"day\"\n            }, (nowDate, todayRange)=>y(\"tr\", {\n                    role: \"row\"\n                }, renderIntro && renderIntro('day'), dates.map((date)=>datesRepDistinctDays ? y(TableDateCell, {\n                        key: date.toISOString(),\n                        date: date,\n                        dateProfile: dateProfile,\n                        todayRange: todayRange,\n                        colCnt: dates.length,\n                        dayHeaderFormat: dayHeaderFormat\n                    }) : y(TableDowCell, {\n                        key: date.getUTCDay(),\n                        dow: date.getUTCDay(),\n                        dayHeaderFormat: dayHeaderFormat\n                    }))));\n        }\n        constructor(){\n            super(...arguments);\n            this.createDayHeaderFormatter = memoize(createDayHeaderFormatter);\n        }\n    }\n    function createDayHeaderFormatter(explicitFormat, datesRepDistinctDays, dateCnt) {\n        return explicitFormat || computeFallbackHeaderFormat(datesRepDistinctDays, dateCnt);\n    }\n    class DaySeriesModel {\n        sliceRange(range) {\n            let firstIndex = this.getDateDayIndex(range.start); // inclusive first index\n            let lastIndex = this.getDateDayIndex(addDays(range.end, -1)); // inclusive last index\n            let clippedFirstIndex = Math.max(0, firstIndex);\n            let clippedLastIndex = Math.min(this.cnt - 1, lastIndex);\n            // deal with in-between indices\n            clippedFirstIndex = Math.ceil(clippedFirstIndex); // in-between starts round to next cell\n            clippedLastIndex = Math.floor(clippedLastIndex); // in-between ends round to prev cell\n            if (clippedFirstIndex <= clippedLastIndex) {\n                return {\n                    firstIndex: clippedFirstIndex,\n                    lastIndex: clippedLastIndex,\n                    isStart: firstIndex === clippedFirstIndex,\n                    isEnd: lastIndex === clippedLastIndex\n                };\n            }\n            return null;\n        }\n        // Given a date, returns its chronolocial cell-index from the first cell of the grid.\n        // If the date lies between cells (because of hiddenDays), returns a floating-point value between offsets.\n        // If before the first offset, returns a negative number.\n        // If after the last offset, returns an offset past the last cell offset.\n        // Only works for *start* dates of cells. Will not work for exclusive end dates for cells.\n        getDateDayIndex(date) {\n            let { indices } = this;\n            let dayOffset = Math.floor(diffDays(this.dates[0], date));\n            if (dayOffset < 0) {\n                return indices[0] - 1;\n            }\n            if (dayOffset >= indices.length) {\n                return indices[indices.length - 1] + 1;\n            }\n            return indices[dayOffset];\n        }\n        constructor(range, dateProfileGenerator){\n            let date = range.start;\n            let { end } = range;\n            let indices = [];\n            let dates = [];\n            let dayIndex = -1;\n            while(date < end){\n                if (dateProfileGenerator.isHiddenDay(date)) {\n                    indices.push(dayIndex + 0.5); // mark that it's between indices\n                } else {\n                    dayIndex += 1;\n                    indices.push(dayIndex);\n                    dates.push(date);\n                }\n                date = addDays(date, 1);\n            }\n            this.dates = dates;\n            this.indices = indices;\n            this.cnt = dates.length;\n        }\n    }\n    class DayTableModel {\n        buildCells() {\n            let rows = [];\n            for(let row = 0; row < this.rowCnt; row += 1){\n                let cells = [];\n                for(let col = 0; col < this.colCnt; col += 1){\n                    cells.push(this.buildCell(row, col));\n                }\n                rows.push(cells);\n            }\n            return rows;\n        }\n        buildCell(row, col) {\n            let date = this.daySeries.dates[row * this.colCnt + col];\n            return {\n                key: date.toISOString(),\n                date\n            };\n        }\n        buildHeaderDates() {\n            let dates = [];\n            for(let col = 0; col < this.colCnt; col += 1){\n                dates.push(this.cells[0][col].date);\n            }\n            return dates;\n        }\n        sliceRange(range) {\n            let { colCnt } = this;\n            let seriesSeg = this.daySeries.sliceRange(range);\n            let segs = [];\n            if (seriesSeg) {\n                let { firstIndex, lastIndex } = seriesSeg;\n                let index = firstIndex;\n                while(index <= lastIndex){\n                    let row = Math.floor(index / colCnt);\n                    let nextIndex = Math.min((row + 1) * colCnt, lastIndex + 1);\n                    segs.push({\n                        row,\n                        firstCol: index % colCnt,\n                        lastCol: (nextIndex - 1) % colCnt,\n                        isStart: seriesSeg.isStart && index === firstIndex,\n                        isEnd: seriesSeg.isEnd && nextIndex - 1 === lastIndex\n                    });\n                    index = nextIndex;\n                }\n            }\n            return segs;\n        }\n        constructor(daySeries, breakOnWeeks){\n            let { dates } = daySeries;\n            let daysPerRow;\n            let firstDay;\n            let rowCnt;\n            if (breakOnWeeks) {\n                // count columns until the day-of-week repeats\n                firstDay = dates[0].getUTCDay();\n                for(daysPerRow = 1; daysPerRow < dates.length; daysPerRow += 1){\n                    if (dates[daysPerRow].getUTCDay() === firstDay) {\n                        break;\n                    }\n                }\n                rowCnt = Math.ceil(dates.length / daysPerRow);\n            } else {\n                rowCnt = 1;\n                daysPerRow = dates.length;\n            }\n            this.rowCnt = rowCnt;\n            this.colCnt = daysPerRow;\n            this.daySeries = daySeries;\n            this.cells = this.buildCells();\n            this.headerDates = this.buildHeaderDates();\n        }\n    }\n    class Slicer {\n        sliceProps(props, dateProfile, nextDayThreshold, context) {\n            for(var _len = arguments.length, extraArgs = new Array(_len > 4 ? _len - 4 : 0), _key = 4; _key < _len; _key++){\n                extraArgs[_key - 4] = arguments[_key];\n            }\n            let { eventUiBases } = props;\n            let eventSegs = this.sliceEventStore(props.eventStore, eventUiBases, dateProfile, nextDayThreshold, ...extraArgs);\n            return {\n                dateSelectionSegs: this.sliceDateSelection(props.dateSelection, dateProfile, nextDayThreshold, eventUiBases, context, ...extraArgs),\n                businessHourSegs: this.sliceBusinessHours(props.businessHours, dateProfile, nextDayThreshold, context, ...extraArgs),\n                fgEventSegs: eventSegs.fg,\n                bgEventSegs: eventSegs.bg,\n                eventDrag: this.sliceEventDrag(props.eventDrag, eventUiBases, dateProfile, nextDayThreshold, ...extraArgs),\n                eventResize: this.sliceEventResize(props.eventResize, eventUiBases, dateProfile, nextDayThreshold, ...extraArgs),\n                eventSelection: props.eventSelection\n            }; // TODO: give interactionSegs?\n        }\n        sliceNowDate(date, dateProfile, nextDayThreshold, context) {\n            for(var _len = arguments.length, extraArgs = new Array(_len > 4 ? _len - 4 : 0), _key = 4; _key < _len; _key++){\n                extraArgs[_key - 4] = arguments[_key];\n            }\n            return this._sliceDateSpan({\n                range: {\n                    start: date,\n                    end: addMs(date, 1)\n                },\n                allDay: false\n            }, dateProfile, nextDayThreshold, {}, context, ...extraArgs);\n        }\n        _sliceBusinessHours(businessHours, dateProfile, nextDayThreshold, context) {\n            for(var _len = arguments.length, extraArgs = new Array(_len > 4 ? _len - 4 : 0), _key = 4; _key < _len; _key++){\n                extraArgs[_key - 4] = arguments[_key];\n            }\n            if (!businessHours) {\n                return [];\n            }\n            return this._sliceEventStore(expandRecurring(businessHours, computeActiveRange(dateProfile, Boolean(nextDayThreshold)), context), {}, dateProfile, nextDayThreshold, ...extraArgs).bg;\n        }\n        _sliceEventStore(eventStore, eventUiBases, dateProfile, nextDayThreshold) {\n            for(var _len = arguments.length, extraArgs = new Array(_len > 4 ? _len - 4 : 0), _key = 4; _key < _len; _key++){\n                extraArgs[_key - 4] = arguments[_key];\n            }\n            if (eventStore) {\n                let rangeRes = sliceEventStore(eventStore, eventUiBases, computeActiveRange(dateProfile, Boolean(nextDayThreshold)), nextDayThreshold);\n                return {\n                    bg: this.sliceEventRanges(rangeRes.bg, extraArgs),\n                    fg: this.sliceEventRanges(rangeRes.fg, extraArgs)\n                };\n            }\n            return {\n                bg: [],\n                fg: []\n            };\n        }\n        _sliceInteraction(interaction, eventUiBases, dateProfile, nextDayThreshold) {\n            for(var _len = arguments.length, extraArgs = new Array(_len > 4 ? _len - 4 : 0), _key = 4; _key < _len; _key++){\n                extraArgs[_key - 4] = arguments[_key];\n            }\n            if (!interaction) {\n                return null;\n            }\n            let rangeRes = sliceEventStore(interaction.mutatedEvents, eventUiBases, computeActiveRange(dateProfile, Boolean(nextDayThreshold)), nextDayThreshold);\n            return {\n                segs: this.sliceEventRanges(rangeRes.fg, extraArgs),\n                affectedInstances: interaction.affectedEvents.instances,\n                isEvent: interaction.isEvent\n            };\n        }\n        _sliceDateSpan(dateSpan, dateProfile, nextDayThreshold, eventUiBases, context) {\n            for(var _len = arguments.length, extraArgs = new Array(_len > 5 ? _len - 5 : 0), _key = 5; _key < _len; _key++){\n                extraArgs[_key - 5] = arguments[_key];\n            }\n            if (!dateSpan) {\n                return [];\n            }\n            let activeRange = computeActiveRange(dateProfile, Boolean(nextDayThreshold));\n            let activeDateSpanRange = intersectRanges(dateSpan.range, activeRange);\n            if (activeDateSpanRange) {\n                dateSpan = Object.assign(Object.assign({}, dateSpan), {\n                    range: activeDateSpanRange\n                });\n                let eventRange = fabricateEventRange(dateSpan, eventUiBases, context);\n                let segs = this.sliceRange(dateSpan.range, ...extraArgs);\n                for (let seg of segs){\n                    seg.eventRange = eventRange;\n                }\n                return segs;\n            }\n            return [];\n        }\n        /*\r\n        \"complete\" seg means it has component and eventRange\r\n        */ sliceEventRanges(eventRanges, extraArgs) {\n            let segs = [];\n            for (let eventRange of eventRanges){\n                segs.push(...this.sliceEventRange(eventRange, extraArgs));\n            }\n            return segs;\n        }\n        /*\r\n        \"complete\" seg means it has component and eventRange\r\n        */ sliceEventRange(eventRange, extraArgs) {\n            let dateRange = eventRange.range;\n            // hack to make multi-day events that are being force-displayed as list-items to take up only one day\n            if (this.forceDayIfListItem && eventRange.ui.display === 'list-item') {\n                dateRange = {\n                    start: dateRange.start,\n                    end: addDays(dateRange.start, 1)\n                };\n            }\n            let segs = this.sliceRange(dateRange, ...extraArgs);\n            for (let seg of segs){\n                seg.eventRange = eventRange;\n                seg.isStart = eventRange.isStart && seg.isStart;\n                seg.isEnd = eventRange.isEnd && seg.isEnd;\n            }\n            return segs;\n        }\n        constructor(){\n            this.sliceBusinessHours = memoize(this._sliceBusinessHours);\n            this.sliceDateSelection = memoize(this._sliceDateSpan);\n            this.sliceEventStore = memoize(this._sliceEventStore);\n            this.sliceEventDrag = memoize(this._sliceInteraction);\n            this.sliceEventResize = memoize(this._sliceInteraction);\n            this.forceDayIfListItem = false; // hack\n        }\n    }\n    /*\r\n    for incorporating slotMinTime/slotMaxTime if appropriate\r\n    TODO: should be part of DateProfile!\r\n    TimelineDateProfile already does this btw\r\n    */ function computeActiveRange(dateProfile, isComponentAllDay) {\n        let range = dateProfile.activeRange;\n        if (isComponentAllDay) {\n            return range;\n        }\n        return {\n            start: addMs(range.start, dateProfile.slotMinTime.milliseconds),\n            end: addMs(range.end, dateProfile.slotMaxTime.milliseconds - 864e5)\n        };\n    }\n    function reduceEventStore(eventStore, action, eventSources, dateProfile, context) {\n        switch(action.type){\n            case 'RECEIVE_EVENTS':\n                return receiveRawEvents(eventStore, eventSources[action.sourceId], action.fetchId, action.fetchRange, action.rawEvents, context);\n            case 'RESET_RAW_EVENTS':\n                return resetRawEvents(eventStore, eventSources[action.sourceId], action.rawEvents, dateProfile.activeRange, context);\n            case 'ADD_EVENTS':\n                return addEvent(eventStore, action.eventStore, dateProfile ? dateProfile.activeRange : null, context);\n            case 'RESET_EVENTS':\n                return action.eventStore;\n            case 'MERGE_EVENTS':\n                return mergeEventStores(eventStore, action.eventStore);\n            case 'PREV':\n            case 'NEXT':\n            case 'CHANGE_DATE':\n            case 'CHANGE_VIEW_TYPE':\n                if (dateProfile) {\n                    return expandRecurring(eventStore, dateProfile.activeRange, context);\n                }\n                return eventStore;\n            case 'REMOVE_EVENTS':\n                return excludeSubEventStore(eventStore, action.eventStore);\n            case 'REMOVE_EVENT_SOURCE':\n                return excludeEventsBySourceId(eventStore, action.sourceId);\n            case 'REMOVE_ALL_EVENT_SOURCES':\n                return filterEventStoreDefs(eventStore, (eventDef)=>!eventDef.sourceId // only keep events with no source id\n                );\n            case 'REMOVE_ALL_EVENTS':\n                return createEmptyEventStore();\n            default:\n                return eventStore;\n        }\n    }\n    function receiveRawEvents(eventStore, eventSource, fetchId, fetchRange, rawEvents, context) {\n        if (eventSource && // not already removed\n        fetchId === eventSource.latestFetchId // TODO: wish this logic was always in event-sources\n        ) {\n            let subset = parseEvents(transformRawEvents(rawEvents, eventSource, context), eventSource, context);\n            if (fetchRange) {\n                subset = expandRecurring(subset, fetchRange, context);\n            }\n            return mergeEventStores(excludeEventsBySourceId(eventStore, eventSource.sourceId), subset);\n        }\n        return eventStore;\n    }\n    function resetRawEvents(existingEventStore, eventSource, rawEvents, activeRange, context) {\n        const { defIdMap, instanceIdMap } = buildPublicIdMaps(existingEventStore);\n        let newEventStore = parseEvents(transformRawEvents(rawEvents, eventSource, context), eventSource, context, false, defIdMap, instanceIdMap);\n        return expandRecurring(newEventStore, activeRange, context);\n    }\n    function transformRawEvents(rawEvents, eventSource, context) {\n        let calEachTransform = context.options.eventDataTransform;\n        let sourceEachTransform = eventSource ? eventSource.eventDataTransform : null;\n        if (sourceEachTransform) {\n            rawEvents = transformEachRawEvent(rawEvents, sourceEachTransform);\n        }\n        if (calEachTransform) {\n            rawEvents = transformEachRawEvent(rawEvents, calEachTransform);\n        }\n        return rawEvents;\n    }\n    function transformEachRawEvent(rawEvents, func) {\n        let refinedEvents;\n        if (!func) {\n            refinedEvents = rawEvents;\n        } else {\n            refinedEvents = [];\n            for (let rawEvent of rawEvents){\n                let refinedEvent = func(rawEvent);\n                if (refinedEvent) {\n                    refinedEvents.push(refinedEvent);\n                } else if (refinedEvent == null) {\n                    refinedEvents.push(rawEvent);\n                } // if a different falsy value, do nothing\n            }\n        }\n        return refinedEvents;\n    }\n    function addEvent(eventStore, subset, expandRange, context) {\n        if (expandRange) {\n            subset = expandRecurring(subset, expandRange, context);\n        }\n        return mergeEventStores(eventStore, subset);\n    }\n    function rezoneEventStoreDates(eventStore, oldDateEnv, newDateEnv) {\n        let { defs } = eventStore;\n        let instances = mapHash(eventStore.instances, (instance)=>{\n            let def = defs[instance.defId];\n            if (def.allDay) {\n                return instance; // isn't dependent on timezone\n            }\n            return Object.assign(Object.assign({}, instance), {\n                range: {\n                    start: newDateEnv.createMarker(oldDateEnv.toDate(instance.range.start, instance.forcedStartTzo)),\n                    end: newDateEnv.createMarker(oldDateEnv.toDate(instance.range.end, instance.forcedEndTzo))\n                },\n                forcedStartTzo: newDateEnv.canComputeOffset ? null : instance.forcedStartTzo,\n                forcedEndTzo: newDateEnv.canComputeOffset ? null : instance.forcedEndTzo\n            });\n        });\n        return {\n            defs,\n            instances\n        };\n    }\n    function excludeEventsBySourceId(eventStore, sourceId) {\n        return filterEventStoreDefs(eventStore, (eventDef)=>eventDef.sourceId !== sourceId);\n    }\n    // QUESTION: why not just return instances? do a general object-property-exclusion util\n    function excludeInstances(eventStore, removals) {\n        return {\n            defs: eventStore.defs,\n            instances: filterHash(eventStore.instances, (instance)=>!removals[instance.instanceId])\n        };\n    }\n    function buildPublicIdMaps(eventStore) {\n        const { defs, instances } = eventStore;\n        const defIdMap = {};\n        const instanceIdMap = {};\n        for(let defId in defs){\n            const def = defs[defId];\n            const { publicId } = def;\n            if (publicId) {\n                defIdMap[publicId] = defId;\n            }\n        }\n        for(let instanceId in instances){\n            const instance = instances[instanceId];\n            const def = defs[instance.defId];\n            const { publicId } = def;\n            if (publicId) {\n                instanceIdMap[publicId] = instanceId;\n            }\n        }\n        return {\n            defIdMap,\n            instanceIdMap\n        };\n    }\n    // high-level segmenting-aware tester functions\n    // ------------------------------------------------------------------------------------------------------------------------\n    function isInteractionValid(interaction, dateProfile, context) {\n        let { instances } = interaction.mutatedEvents;\n        for(let instanceId in instances){\n            if (!rangeContainsRange(dateProfile.validRange, instances[instanceId].range)) {\n                return false;\n            }\n        }\n        return isNewPropsValid({\n            eventDrag: interaction\n        }, context); // HACK: the eventDrag props is used for ALL interactions\n    }\n    function isDateSelectionValid(dateSelection, dateProfile, context) {\n        if (!rangeContainsRange(dateProfile.validRange, dateSelection.range)) {\n            return false;\n        }\n        return isNewPropsValid({\n            dateSelection\n        }, context);\n    }\n    function isNewPropsValid(newProps, context) {\n        let calendarState = context.getCurrentData();\n        let props = Object.assign({\n            businessHours: calendarState.businessHours,\n            dateSelection: '',\n            eventStore: calendarState.eventStore,\n            eventUiBases: calendarState.eventUiBases,\n            eventSelection: '',\n            eventDrag: null,\n            eventResize: null\n        }, newProps);\n        return (context.pluginHooks.isPropsValid || isPropsValid)(props, context);\n    }\n    function isPropsValid(state, context) {\n        let dateSpanMeta = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, filterConfig = arguments.length > 3 ? arguments[3] : void 0;\n        if (state.eventDrag && !isInteractionPropsValid(state, context, dateSpanMeta, filterConfig)) {\n            return false;\n        }\n        if (state.dateSelection && !isDateSelectionPropsValid(state, context, dateSpanMeta, filterConfig)) {\n            return false;\n        }\n        return true;\n    }\n    // Moving Event Validation\n    // ------------------------------------------------------------------------------------------------------------------------\n    function isInteractionPropsValid(state, context, dateSpanMeta, filterConfig) {\n        let currentState = context.getCurrentData();\n        let interaction = state.eventDrag; // HACK: the eventDrag props is used for ALL interactions\n        let subjectEventStore = interaction.mutatedEvents;\n        let subjectDefs = subjectEventStore.defs;\n        let subjectInstances = subjectEventStore.instances;\n        let subjectConfigs = compileEventUis(subjectDefs, interaction.isEvent ? state.eventUiBases : {\n            '': currentState.selectionConfig\n        });\n        if (filterConfig) {\n            subjectConfigs = mapHash(subjectConfigs, filterConfig);\n        }\n        // exclude the subject events. TODO: exclude defs too?\n        let otherEventStore = excludeInstances(state.eventStore, interaction.affectedEvents.instances);\n        let otherDefs = otherEventStore.defs;\n        let otherInstances = otherEventStore.instances;\n        let otherConfigs = compileEventUis(otherDefs, state.eventUiBases);\n        for(let subjectInstanceId in subjectInstances){\n            let subjectInstance = subjectInstances[subjectInstanceId];\n            let subjectRange = subjectInstance.range;\n            let subjectConfig = subjectConfigs[subjectInstance.defId];\n            let subjectDef = subjectDefs[subjectInstance.defId];\n            // constraint\n            if (!allConstraintsPass(subjectConfig.constraints, subjectRange, otherEventStore, state.businessHours, context)) {\n                return false;\n            }\n            // overlap\n            let { eventOverlap } = context.options;\n            let eventOverlapFunc = typeof eventOverlap === 'function' ? eventOverlap : null;\n            for(let otherInstanceId in otherInstances){\n                let otherInstance = otherInstances[otherInstanceId];\n                // intersect! evaluate\n                if (rangesIntersect(subjectRange, otherInstance.range)) {\n                    let otherOverlap = otherConfigs[otherInstance.defId].overlap;\n                    // consider the other event's overlap. only do this if the subject event is a \"real\" event\n                    if (otherOverlap === false && interaction.isEvent) {\n                        return false;\n                    }\n                    if (subjectConfig.overlap === false) {\n                        return false;\n                    }\n                    if (eventOverlapFunc && !eventOverlapFunc(new EventImpl(context, otherDefs[otherInstance.defId], otherInstance), new EventImpl(context, subjectDef, subjectInstance))) {\n                        return false;\n                    }\n                }\n            }\n            // allow (a function)\n            let calendarEventStore = currentState.eventStore; // need global-to-calendar, not local to component (splittable)state\n            for (let subjectAllow of subjectConfig.allows){\n                let subjectDateSpan = Object.assign(Object.assign({}, dateSpanMeta), {\n                    range: subjectInstance.range,\n                    allDay: subjectDef.allDay\n                });\n                let origDef = calendarEventStore.defs[subjectDef.defId];\n                let origInstance = calendarEventStore.instances[subjectInstanceId];\n                let eventApi;\n                if (origDef) {\n                    eventApi = new EventImpl(context, origDef, origInstance);\n                } else {\n                    eventApi = new EventImpl(context, subjectDef); // no instance, because had no dates\n                }\n                if (!subjectAllow(buildDateSpanApiWithContext(subjectDateSpan, context), eventApi)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    // Date Selection Validation\n    // ------------------------------------------------------------------------------------------------------------------------\n    function isDateSelectionPropsValid(state, context, dateSpanMeta, filterConfig) {\n        let relevantEventStore = state.eventStore;\n        let relevantDefs = relevantEventStore.defs;\n        let relevantInstances = relevantEventStore.instances;\n        let selection = state.dateSelection;\n        let selectionRange = selection.range;\n        let { selectionConfig } = context.getCurrentData();\n        if (filterConfig) {\n            selectionConfig = filterConfig(selectionConfig);\n        }\n        // constraint\n        if (!allConstraintsPass(selectionConfig.constraints, selectionRange, relevantEventStore, state.businessHours, context)) {\n            return false;\n        }\n        // overlap\n        let { selectOverlap } = context.options;\n        let selectOverlapFunc = typeof selectOverlap === 'function' ? selectOverlap : null;\n        for(let relevantInstanceId in relevantInstances){\n            let relevantInstance = relevantInstances[relevantInstanceId];\n            // intersect! evaluate\n            if (rangesIntersect(selectionRange, relevantInstance.range)) {\n                if (selectionConfig.overlap === false) {\n                    return false;\n                }\n                if (selectOverlapFunc && !selectOverlapFunc(new EventImpl(context, relevantDefs[relevantInstance.defId], relevantInstance), null)) {\n                    return false;\n                }\n            }\n        }\n        // allow (a function)\n        for (let selectionAllow of selectionConfig.allows){\n            let fullDateSpan = Object.assign(Object.assign({}, dateSpanMeta), selection);\n            if (!selectionAllow(buildDateSpanApiWithContext(fullDateSpan, context), null)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    // Constraint Utils\n    // ------------------------------------------------------------------------------------------------------------------------\n    function allConstraintsPass(constraints, subjectRange, otherEventStore, businessHoursUnexpanded, context) {\n        for (let constraint of constraints){\n            if (!anyRangesContainRange(constraintToRanges(constraint, subjectRange, otherEventStore, businessHoursUnexpanded, context), subjectRange)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    function constraintToRanges(constraint, subjectRange, otherEventStore, businessHoursUnexpanded, context) {\n        if (constraint === 'businessHours') {\n            return eventStoreToRanges(expandRecurring(businessHoursUnexpanded, subjectRange, context));\n        }\n        if (typeof constraint === 'string') {\n            return eventStoreToRanges(filterEventStoreDefs(otherEventStore, (eventDef)=>eventDef.groupId === constraint));\n        }\n        if (typeof constraint === 'object' && constraint) {\n            return eventStoreToRanges(expandRecurring(constraint, subjectRange, context));\n        }\n        return []; // if it's false\n    }\n    // TODO: move to event-store file?\n    function eventStoreToRanges(eventStore) {\n        let { instances } = eventStore;\n        let ranges = [];\n        for(let instanceId in instances){\n            ranges.push(instances[instanceId].range);\n        }\n        return ranges;\n    }\n    // TODO: move to geom file?\n    function anyRangesContainRange(outerRanges, innerRange) {\n        for (let outerRange of outerRanges){\n            if (rangeContainsRange(outerRange, innerRange)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    class JsonRequestError extends Error {\n        constructor(message, response){\n            super(message);\n            this.response = response;\n        }\n    }\n    function requestJson(method, url, params) {\n        method = method.toUpperCase();\n        const fetchOptions = {\n            method\n        };\n        if (method === 'GET') {\n            url += (url.indexOf('?') === -1 ? '?' : '&') + new URLSearchParams(params);\n        } else {\n            fetchOptions.body = new URLSearchParams(params);\n            fetchOptions.headers = {\n                'Content-Type': 'application/x-www-form-urlencoded'\n            };\n        }\n        return fetch(url, fetchOptions).then((fetchRes)=>{\n            if (fetchRes.ok) {\n                return fetchRes.json().then((parsedResponse)=>{\n                    return [\n                        parsedResponse,\n                        fetchRes\n                    ];\n                }, ()=>{\n                    throw new JsonRequestError('Failure parsing JSON', fetchRes);\n                });\n            } else {\n                throw new JsonRequestError('Request failed', fetchRes);\n            }\n        });\n    }\n    class DelayedRunner {\n        request(delay) {\n            this.isDirty = true;\n            if (!this.isPaused()) {\n                this.clearTimeout();\n                if (delay == null) {\n                    this.tryDrain();\n                } else {\n                    this.timeoutId = setTimeout(this.tryDrain.bind(this), delay);\n                }\n            }\n        }\n        pause() {\n            let scope = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : '';\n            let { pauseDepths } = this;\n            pauseDepths[scope] = (pauseDepths[scope] || 0) + 1;\n            this.clearTimeout();\n        }\n        resume() {\n            let scope = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : '', force = arguments.length > 1 ? arguments[1] : void 0;\n            let { pauseDepths } = this;\n            if (scope in pauseDepths) {\n                if (force) {\n                    delete pauseDepths[scope];\n                } else {\n                    pauseDepths[scope] -= 1;\n                    let depth = pauseDepths[scope];\n                    if (depth <= 0) {\n                        delete pauseDepths[scope];\n                    }\n                }\n                this.tryDrain();\n            }\n        }\n        isPaused() {\n            return Object.keys(this.pauseDepths).length;\n        }\n        tryDrain() {\n            if (!this.isRunning && !this.isPaused()) {\n                this.isRunning = true;\n                while(this.isDirty){\n                    this.isDirty = false;\n                    this.drained(); // might set isDirty to true again\n                }\n                this.isRunning = false;\n            }\n        }\n        clear() {\n            this.clearTimeout();\n            this.isDirty = false;\n            this.pauseDepths = {};\n        }\n        clearTimeout() {\n            if (this.timeoutId) {\n                clearTimeout(this.timeoutId);\n                this.timeoutId = 0;\n            }\n        }\n        drained() {\n            if (this.drainedOption) {\n                this.drainedOption();\n            }\n        }\n        constructor(drainedOption){\n            this.drainedOption = drainedOption;\n            this.isRunning = false;\n            this.isDirty = false;\n            this.pauseDepths = {};\n            this.timeoutId = 0;\n        }\n    }\n    const VISIBLE_HIDDEN_RE = /^(visible|hidden)$/;\n    class Scroller extends BaseComponent {\n        render() {\n            let { props } = this;\n            let { liquid, liquidIsAbsolute } = props;\n            let isAbsolute = liquid && liquidIsAbsolute;\n            let className = [\n                'fc-scroller'\n            ];\n            if (liquid) {\n                if (liquidIsAbsolute) {\n                    className.push('fc-scroller-liquid-absolute');\n                } else {\n                    className.push('fc-scroller-liquid');\n                }\n            }\n            return y(\"div\", {\n                ref: this.handleEl,\n                className: className.join(' '),\n                style: {\n                    overflowX: props.overflowX,\n                    overflowY: props.overflowY,\n                    left: isAbsolute && -(props.overcomeLeft || 0) || '',\n                    right: isAbsolute && -(props.overcomeRight || 0) || '',\n                    bottom: isAbsolute && -(props.overcomeBottom || 0) || '',\n                    marginLeft: !isAbsolute && -(props.overcomeLeft || 0) || '',\n                    marginRight: !isAbsolute && -(props.overcomeRight || 0) || '',\n                    marginBottom: !isAbsolute && -(props.overcomeBottom || 0) || '',\n                    maxHeight: props.maxHeight || ''\n                }\n            }, props.children);\n        }\n        needsXScrolling() {\n            if (VISIBLE_HIDDEN_RE.test(this.props.overflowX)) {\n                return false;\n            }\n            // testing scrollWidth>clientWidth is unreliable cross-browser when pixel heights aren't integers.\n            // much more reliable to see if children are taller than the scroller, even tho doesn't account for\n            // inner-child margins and absolute positioning\n            let { el } = this;\n            let realClientWidth = this.el.getBoundingClientRect().width - this.getYScrollbarWidth();\n            let { children } = el;\n            for(let i = 0; i < children.length; i += 1){\n                let childEl = children[i];\n                if (childEl.getBoundingClientRect().width > realClientWidth) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        needsYScrolling() {\n            if (VISIBLE_HIDDEN_RE.test(this.props.overflowY)) {\n                return false;\n            }\n            // testing scrollHeight>clientHeight is unreliable cross-browser when pixel heights aren't integers.\n            // much more reliable to see if children are taller than the scroller, even tho doesn't account for\n            // inner-child margins and absolute positioning\n            let { el } = this;\n            let realClientHeight = this.el.getBoundingClientRect().height - this.getXScrollbarWidth();\n            let { children } = el;\n            for(let i = 0; i < children.length; i += 1){\n                let childEl = children[i];\n                if (childEl.getBoundingClientRect().height > realClientHeight) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        getXScrollbarWidth() {\n            if (VISIBLE_HIDDEN_RE.test(this.props.overflowX)) {\n                return 0;\n            }\n            return this.el.offsetHeight - this.el.clientHeight; // only works because we guarantee no borders. TODO: add to CSS with important?\n        }\n        getYScrollbarWidth() {\n            if (VISIBLE_HIDDEN_RE.test(this.props.overflowY)) {\n                return 0;\n            }\n            return this.el.offsetWidth - this.el.clientWidth; // only works because we guarantee no borders. TODO: add to CSS with important?\n        }\n        constructor(){\n            super(...arguments);\n            this.handleEl = (el)=>{\n                this.el = el;\n                setRef(this.props.elRef, el);\n            };\n        }\n    }\n    /*\r\n    TODO: somehow infer OtherArgs from masterCallback?\r\n    TODO: infer RefType from masterCallback if provided\r\n    */ class RefMap {\n        createRef(key) {\n            let refCallback = this.callbackMap[key];\n            if (!refCallback) {\n                refCallback = this.callbackMap[key] = (val)=>{\n                    this.handleValue(val, String(key));\n                };\n            }\n            return refCallback;\n        }\n        // TODO: check callers that don't care about order. should use getAll instead\n        // NOTE: this method has become less valuable now that we are encouraged to map order by some other index\n        // TODO: provide ONE array-export function, buildArray, which fails on non-numeric indexes. caller can manipulate and \"collect\"\n        collect(startIndex, endIndex, step) {\n            return collectFromHash(this.currentMap, startIndex, endIndex, step);\n        }\n        getAll() {\n            return hashValuesToArray(this.currentMap);\n        }\n        constructor(masterCallback){\n            this.masterCallback = masterCallback;\n            this.currentMap = {};\n            this.depths = {};\n            this.callbackMap = {};\n            this.handleValue = (val, key)=>{\n                let { depths, currentMap } = this;\n                let removed = false;\n                let added = false;\n                if (val !== null) {\n                    // for bug... ACTUALLY: can probably do away with this now that callers don't share numeric indices anymore\n                    removed = key in currentMap;\n                    currentMap[key] = val;\n                    depths[key] = (depths[key] || 0) + 1;\n                    added = true;\n                } else {\n                    depths[key] -= 1;\n                    if (!depths[key]) {\n                        delete currentMap[key];\n                        delete this.callbackMap[key];\n                        removed = true;\n                    }\n                }\n                if (this.masterCallback) {\n                    if (removed) {\n                        this.masterCallback(null, String(key));\n                    }\n                    if (added) {\n                        this.masterCallback(val, String(key));\n                    }\n                }\n            };\n        }\n    }\n    function computeShrinkWidth(chunkEls) {\n        let shrinkCells = findElements(chunkEls, '.fc-scrollgrid-shrink');\n        let largestWidth = 0;\n        for (let shrinkCell of shrinkCells){\n            largestWidth = Math.max(largestWidth, computeSmallestCellWidth(shrinkCell));\n        }\n        return Math.ceil(largestWidth); // <table> elements work best with integers. round up to ensure contents fits\n    }\n    function getSectionHasLiquidHeight(props, sectionConfig) {\n        return props.liquid && sectionConfig.liquid; // does the section do liquid-height? (need to have whole scrollgrid liquid-height as well)\n    }\n    function getAllowYScrolling(props, sectionConfig) {\n        return sectionConfig.maxHeight != null || // if its possible for the height to max out, we might need scrollbars\n        getSectionHasLiquidHeight(props, sectionConfig); // if the section is liquid height, it might condense enough to require scrollbars\n    }\n    // TODO: ONLY use `arg`. force out internal function to use same API\n    function renderChunkContent(sectionConfig, chunkConfig, arg, isHeader) {\n        let { expandRows } = arg;\n        let content = typeof chunkConfig.content === 'function' ? chunkConfig.content(arg) : y('table', {\n            role: 'presentation',\n            className: [\n                chunkConfig.tableClassName,\n                sectionConfig.syncRowHeights ? 'fc-scrollgrid-sync-table' : ''\n            ].join(' '),\n            style: {\n                minWidth: arg.tableMinWidth,\n                width: arg.clientWidth,\n                height: expandRows ? arg.clientHeight : ''\n            }\n        }, arg.tableColGroupNode, y(isHeader ? 'thead' : 'tbody', {\n            role: 'presentation'\n        }, typeof chunkConfig.rowContent === 'function' ? chunkConfig.rowContent(arg) : chunkConfig.rowContent));\n        return content;\n    }\n    function isColPropsEqual(cols0, cols1) {\n        return isArraysEqual(cols0, cols1, isPropsEqual);\n    }\n    function renderMicroColGroup(cols, shrinkWidth) {\n        let colNodes = [];\n        /*\r\n        for ColProps with spans, it would have been great to make a single <col span=\"\">\r\n        HOWEVER, Chrome was getting messing up distributing the width to <td>/<th> elements with colspans.\r\n        SOLUTION: making individual <col> elements makes Chrome behave.\r\n        */ for (let colProps of cols){\n            let span = colProps.span || 1;\n            for(let i = 0; i < span; i += 1){\n                colNodes.push(y(\"col\", {\n                    style: {\n                        width: colProps.width === 'shrink' ? sanitizeShrinkWidth(shrinkWidth) : colProps.width || '',\n                        minWidth: colProps.minWidth || ''\n                    }\n                }));\n            }\n        }\n        return y('colgroup', {}, ...colNodes);\n    }\n    function sanitizeShrinkWidth(shrinkWidth) {\n        /* why 4? if we do 0, it will kill any border, which are needed for computeSmallestCellWidth\r\n        4 accounts for 2 2-pixel borders. TODO: better solution? */ return shrinkWidth == null ? 4 : shrinkWidth;\n    }\n    function hasShrinkWidth(cols) {\n        for (let col of cols){\n            if (col.width === 'shrink') {\n                return true;\n            }\n        }\n        return false;\n    }\n    function getScrollGridClassNames(liquid, context) {\n        let classNames = [\n            'fc-scrollgrid',\n            context.theme.getClass('table')\n        ];\n        if (liquid) {\n            classNames.push('fc-scrollgrid-liquid');\n        }\n        return classNames;\n    }\n    function getSectionClassNames(sectionConfig, wholeTableVGrow) {\n        let classNames = [\n            'fc-scrollgrid-section',\n            \"fc-scrollgrid-section-\".concat(sectionConfig.type),\n            sectionConfig.className\n        ];\n        if (wholeTableVGrow && sectionConfig.liquid && sectionConfig.maxHeight == null) {\n            classNames.push('fc-scrollgrid-section-liquid');\n        }\n        if (sectionConfig.isSticky) {\n            classNames.push('fc-scrollgrid-section-sticky');\n        }\n        return classNames;\n    }\n    function renderScrollShim(arg) {\n        return y(\"div\", {\n            className: \"fc-scrollgrid-sticky-shim\",\n            style: {\n                width: arg.clientWidth,\n                minWidth: arg.tableMinWidth\n            }\n        });\n    }\n    function getStickyHeaderDates(options) {\n        let { stickyHeaderDates } = options;\n        if (stickyHeaderDates == null || stickyHeaderDates === 'auto') {\n            stickyHeaderDates = options.height === 'auto' || options.viewHeight === 'auto';\n        }\n        return stickyHeaderDates;\n    }\n    function getStickyFooterScrollbar(options) {\n        let { stickyFooterScrollbar } = options;\n        if (stickyFooterScrollbar == null || stickyFooterScrollbar === 'auto') {\n            stickyFooterScrollbar = options.height === 'auto' || options.viewHeight === 'auto';\n        }\n        return stickyFooterScrollbar;\n    }\n    class SimpleScrollGrid extends BaseComponent {\n        render() {\n            let { props, state, context } = this;\n            let sectionConfigs = props.sections || [];\n            let cols = this.processCols(props.cols);\n            let microColGroupNode = this.renderMicroColGroup(cols, state.shrinkWidth);\n            let classNames = getScrollGridClassNames(props.liquid, context);\n            if (props.collapsibleWidth) {\n                classNames.push('fc-scrollgrid-collapsible');\n            }\n            // TODO: make DRY\n            let configCnt = sectionConfigs.length;\n            let configI = 0;\n            let currentConfig;\n            let headSectionNodes = [];\n            let bodySectionNodes = [];\n            let footSectionNodes = [];\n            while(configI < configCnt && (currentConfig = sectionConfigs[configI]).type === 'header'){\n                headSectionNodes.push(this.renderSection(currentConfig, microColGroupNode, true));\n                configI += 1;\n            }\n            while(configI < configCnt && (currentConfig = sectionConfigs[configI]).type === 'body'){\n                bodySectionNodes.push(this.renderSection(currentConfig, microColGroupNode, false));\n                configI += 1;\n            }\n            while(configI < configCnt && (currentConfig = sectionConfigs[configI]).type === 'footer'){\n                footSectionNodes.push(this.renderSection(currentConfig, microColGroupNode, true));\n                configI += 1;\n            }\n            // firefox bug: when setting height on table and there is a thead or tfoot,\n            // the necessary height:100% on the liquid-height body section forces the *whole* table to be taller. (bug #5524)\n            // use getCanVGrowWithinCell as a way to detect table-stupid firefox.\n            // if so, use a simpler dom structure, jam everything into a lone tbody.\n            let isBuggy = !getCanVGrowWithinCell();\n            const roleAttrs = {\n                role: 'rowgroup'\n            };\n            return y('table', {\n                role: 'grid',\n                className: classNames.join(' '),\n                style: {\n                    height: props.height\n                }\n            }, Boolean(!isBuggy && headSectionNodes.length) && y('thead', roleAttrs, ...headSectionNodes), Boolean(!isBuggy && bodySectionNodes.length) && y('tbody', roleAttrs, ...bodySectionNodes), Boolean(!isBuggy && footSectionNodes.length) && y('tfoot', roleAttrs, ...footSectionNodes), isBuggy && y('tbody', roleAttrs, ...headSectionNodes, ...bodySectionNodes, ...footSectionNodes));\n        }\n        renderSection(sectionConfig, microColGroupNode, isHeader) {\n            if ('outerContent' in sectionConfig) {\n                return y(_, {\n                    key: sectionConfig.key\n                }, sectionConfig.outerContent);\n            }\n            return y(\"tr\", {\n                key: sectionConfig.key,\n                role: \"presentation\",\n                className: getSectionClassNames(sectionConfig, this.props.liquid).join(' ')\n            }, this.renderChunkTd(sectionConfig, microColGroupNode, sectionConfig.chunk, isHeader));\n        }\n        renderChunkTd(sectionConfig, microColGroupNode, chunkConfig, isHeader) {\n            if ('outerContent' in chunkConfig) {\n                return chunkConfig.outerContent;\n            }\n            let { props } = this;\n            let { forceYScrollbars, scrollerClientWidths, scrollerClientHeights } = this.state;\n            let needsYScrolling = getAllowYScrolling(props, sectionConfig); // TODO: do lazily. do in section config?\n            let isLiquid = getSectionHasLiquidHeight(props, sectionConfig);\n            // for `!props.liquid` - is WHOLE scrollgrid natural height?\n            // TODO: do same thing in advanced scrollgrid? prolly not b/c always has horizontal scrollbars\n            let overflowY = !props.liquid ? 'visible' : forceYScrollbars ? 'scroll' : !needsYScrolling ? 'hidden' : 'auto';\n            let sectionKey = sectionConfig.key;\n            let content = renderChunkContent(sectionConfig, chunkConfig, {\n                tableColGroupNode: microColGroupNode,\n                tableMinWidth: '',\n                clientWidth: !props.collapsibleWidth && scrollerClientWidths[sectionKey] !== undefined ? scrollerClientWidths[sectionKey] : null,\n                clientHeight: scrollerClientHeights[sectionKey] !== undefined ? scrollerClientHeights[sectionKey] : null,\n                expandRows: sectionConfig.expandRows,\n                syncRowHeights: false,\n                rowSyncHeights: [],\n                reportRowHeightChange: ()=>{}\n            }, isHeader);\n            return y(isHeader ? 'th' : 'td', {\n                ref: chunkConfig.elRef,\n                role: 'presentation'\n            }, y(\"div\", {\n                className: \"fc-scroller-harness\".concat(isLiquid ? ' fc-scroller-harness-liquid' : '')\n            }, y(Scroller, {\n                ref: this.scrollerRefs.createRef(sectionKey),\n                elRef: this.scrollerElRefs.createRef(sectionKey),\n                overflowY: overflowY,\n                overflowX: !props.liquid ? 'visible' : 'hidden' /* natural height? */ ,\n                maxHeight: sectionConfig.maxHeight,\n                liquid: isLiquid,\n                liquidIsAbsolute: true\n            }, content)));\n        }\n        _handleScrollerEl(scrollerEl, key) {\n            let section = getSectionByKey(this.props.sections, key);\n            if (section) {\n                setRef(section.chunk.scrollerElRef, scrollerEl);\n            }\n        }\n        componentDidMount() {\n            this.handleSizing();\n            this.context.addResizeHandler(this.handleSizing);\n        }\n        componentDidUpdate() {\n            // TODO: need better solution when state contains non-sizing things\n            this.handleSizing();\n        }\n        componentWillUnmount() {\n            this.context.removeResizeHandler(this.handleSizing);\n        }\n        computeShrinkWidth() {\n            return hasShrinkWidth(this.props.cols) ? computeShrinkWidth(this.scrollerElRefs.getAll()) : 0;\n        }\n        computeScrollerDims() {\n            let scrollbarWidth = getScrollbarWidths();\n            let { scrollerRefs, scrollerElRefs } = this;\n            let forceYScrollbars = false;\n            let scrollerClientWidths = {};\n            let scrollerClientHeights = {};\n            for(let sectionKey in scrollerRefs.currentMap){\n                let scroller = scrollerRefs.currentMap[sectionKey];\n                if (scroller && scroller.needsYScrolling()) {\n                    forceYScrollbars = true;\n                    break;\n                }\n            }\n            for (let section of this.props.sections){\n                let sectionKey = section.key;\n                let scrollerEl = scrollerElRefs.currentMap[sectionKey];\n                if (scrollerEl) {\n                    let harnessEl = scrollerEl.parentNode; // TODO: weird way to get this. need harness b/c doesn't include table borders\n                    scrollerClientWidths[sectionKey] = Math.floor(harnessEl.getBoundingClientRect().width - (forceYScrollbars ? scrollbarWidth.y // use global because scroller might not have scrollbars yet but will need them in future\n                     : 0));\n                    scrollerClientHeights[sectionKey] = Math.floor(harnessEl.getBoundingClientRect().height);\n                }\n            }\n            return {\n                forceYScrollbars,\n                scrollerClientWidths,\n                scrollerClientHeights\n            };\n        }\n        constructor(){\n            super(...arguments);\n            this.processCols = memoize((a)=>a, isColPropsEqual); // so we get same `cols` props every time\n            // yucky to memoize VNodes, but much more efficient for consumers\n            this.renderMicroColGroup = memoize(renderMicroColGroup);\n            this.scrollerRefs = new RefMap();\n            this.scrollerElRefs = new RefMap(this._handleScrollerEl.bind(this));\n            this.state = {\n                shrinkWidth: null,\n                forceYScrollbars: false,\n                scrollerClientWidths: {},\n                scrollerClientHeights: {}\n            };\n            // TODO: can do a really simple print-view. dont need to join rows\n            this.handleSizing = ()=>{\n                this.safeSetState(Object.assign({\n                    shrinkWidth: this.computeShrinkWidth()\n                }, this.computeScrollerDims()));\n            };\n        }\n    }\n    SimpleScrollGrid.addStateEquality({\n        scrollerClientWidths: isPropsEqual,\n        scrollerClientHeights: isPropsEqual\n    });\n    function getSectionByKey(sections, key) {\n        for (let section of sections){\n            if (section.key === key) {\n                return section;\n            }\n        }\n        return null;\n    }\n    class EventContainer extends BaseComponent {\n        render() {\n            const { props, context } = this;\n            const { options } = context;\n            const { seg } = props;\n            const { eventRange } = seg;\n            const { ui } = eventRange;\n            const renderProps = {\n                event: new EventImpl(context, eventRange.def, eventRange.instance),\n                view: context.viewApi,\n                timeText: props.timeText,\n                textColor: ui.textColor,\n                backgroundColor: ui.backgroundColor,\n                borderColor: ui.borderColor,\n                isDraggable: !props.disableDragging && computeSegDraggable(seg, context),\n                isStartResizable: !props.disableResizing && computeSegStartResizable(seg, context),\n                isEndResizable: !props.disableResizing && computeSegEndResizable(seg),\n                isMirror: Boolean(props.isDragging || props.isResizing || props.isDateSelecting),\n                isStart: Boolean(seg.isStart),\n                isEnd: Boolean(seg.isEnd),\n                isPast: Boolean(props.isPast),\n                isFuture: Boolean(props.isFuture),\n                isToday: Boolean(props.isToday),\n                isSelected: Boolean(props.isSelected),\n                isDragging: Boolean(props.isDragging),\n                isResizing: Boolean(props.isResizing)\n            };\n            return y(ContentContainer, Object.assign({}, props /* contains children */ , {\n                elRef: this.handleEl,\n                elClasses: [\n                    ...getEventClassNames(renderProps),\n                    ...seg.eventRange.ui.classNames,\n                    ...props.elClasses || []\n                ],\n                renderProps: renderProps,\n                generatorName: \"eventContent\",\n                customGenerator: options.eventContent,\n                defaultGenerator: props.defaultGenerator,\n                classNameGenerator: options.eventClassNames,\n                didMount: options.eventDidMount,\n                willUnmount: options.eventWillUnmount\n            }));\n        }\n        componentDidUpdate(prevProps) {\n            if (this.el && this.props.seg !== prevProps.seg) {\n                setElSeg(this.el, this.props.seg);\n            }\n        }\n        constructor(){\n            super(...arguments);\n            this.handleEl = (el)=>{\n                this.el = el;\n                if (el) {\n                    setElSeg(el, this.props.seg);\n                }\n            };\n        }\n    }\n    // should not be a purecomponent\n    class StandardEvent extends BaseComponent {\n        render() {\n            let { props, context } = this;\n            let { options } = context;\n            let { seg } = props;\n            let { ui } = seg.eventRange;\n            let timeFormat = options.eventTimeFormat || props.defaultTimeFormat;\n            let timeText = buildSegTimeText(seg, timeFormat, context, props.defaultDisplayEventTime, props.defaultDisplayEventEnd);\n            return y(EventContainer, Object.assign({}, props /* includes elRef */ , {\n                elTag: \"a\",\n                elStyle: {\n                    borderColor: ui.borderColor,\n                    backgroundColor: ui.backgroundColor\n                },\n                elAttrs: getSegAnchorAttrs(seg, context),\n                defaultGenerator: renderInnerContent$1$1,\n                timeText: timeText\n            }), (InnerContent, eventContentArg)=>y(_, null, y(InnerContent, {\n                    elTag: \"div\",\n                    elClasses: [\n                        'fc-event-main'\n                    ],\n                    elStyle: {\n                        color: eventContentArg.textColor\n                    }\n                }), Boolean(eventContentArg.isStartResizable) && y(\"div\", {\n                    className: \"fc-event-resizer fc-event-resizer-start\"\n                }), Boolean(eventContentArg.isEndResizable) && y(\"div\", {\n                    className: \"fc-event-resizer fc-event-resizer-end\"\n                })));\n        }\n    }\n    function renderInnerContent$1$1(innerProps) {\n        return y(\"div\", {\n            className: \"fc-event-main-frame\"\n        }, innerProps.timeText && y(\"div\", {\n            className: \"fc-event-time\"\n        }, innerProps.timeText), y(\"div\", {\n            className: \"fc-event-title-container\"\n        }, y(\"div\", {\n            className: \"fc-event-title fc-sticky\"\n        }, innerProps.event.title || y(_, null, \"\\u00A0\"))));\n    }\n    const NowIndicatorContainer = (props)=>y(ViewContextType.Consumer, null, (context)=>{\n            let { options } = context;\n            let renderProps = {\n                isAxis: props.isAxis,\n                date: context.dateEnv.toDate(props.date),\n                view: context.viewApi\n            };\n            return y(ContentContainer, Object.assign({}, props /* includes children */ , {\n                elTag: props.elTag || 'div',\n                renderProps: renderProps,\n                generatorName: \"nowIndicatorContent\",\n                customGenerator: options.nowIndicatorContent,\n                classNameGenerator: options.nowIndicatorClassNames,\n                didMount: options.nowIndicatorDidMount,\n                willUnmount: options.nowIndicatorWillUnmount\n            }));\n        });\n    const DAY_NUM_FORMAT = createFormatter({\n        day: 'numeric'\n    });\n    class DayCellContainer extends BaseComponent {\n        render() {\n            let { props, context } = this;\n            let { options } = context;\n            let renderProps = this.refineRenderProps({\n                date: props.date,\n                dateProfile: props.dateProfile,\n                todayRange: props.todayRange,\n                isMonthStart: props.isMonthStart || false,\n                showDayNumber: props.showDayNumber,\n                extraRenderProps: props.extraRenderProps,\n                viewApi: context.viewApi,\n                dateEnv: context.dateEnv,\n                monthStartFormat: options.monthStartFormat\n            });\n            return y(ContentContainer, Object.assign({}, props /* includes children */ , {\n                elClasses: [\n                    ...getDayClassNames(renderProps, context.theme),\n                    ...props.elClasses || []\n                ],\n                elAttrs: Object.assign(Object.assign({}, props.elAttrs), renderProps.isDisabled ? {} : {\n                    'data-date': formatDayString(props.date)\n                }),\n                renderProps: renderProps,\n                generatorName: \"dayCellContent\",\n                customGenerator: options.dayCellContent,\n                defaultGenerator: props.defaultGenerator,\n                classNameGenerator: // don't use custom classNames if disabled\n                renderProps.isDisabled ? undefined : options.dayCellClassNames,\n                didMount: options.dayCellDidMount,\n                willUnmount: options.dayCellWillUnmount\n            }));\n        }\n        constructor(){\n            super(...arguments);\n            this.refineRenderProps = memoizeObjArg(refineRenderProps);\n        }\n    }\n    function hasCustomDayCellContent(options) {\n        return Boolean(options.dayCellContent || hasCustomRenderingHandler('dayCellContent', options));\n    }\n    function refineRenderProps(raw) {\n        let { date, dateEnv, dateProfile, isMonthStart } = raw;\n        let dayMeta = getDateMeta(date, raw.todayRange, null, dateProfile);\n        let dayNumberText = raw.showDayNumber ? dateEnv.format(date, isMonthStart ? raw.monthStartFormat : DAY_NUM_FORMAT) : '';\n        return Object.assign(Object.assign(Object.assign({\n            date: dateEnv.toDate(date),\n            view: raw.viewApi\n        }, dayMeta), {\n            isMonthStart,\n            dayNumberText\n        }), raw.extraRenderProps);\n    }\n    class BgEvent extends BaseComponent {\n        render() {\n            let { props } = this;\n            let { seg } = props;\n            return y(EventContainer, {\n                elTag: \"div\",\n                elClasses: [\n                    'fc-bg-event'\n                ],\n                elStyle: {\n                    backgroundColor: seg.eventRange.ui.backgroundColor\n                },\n                defaultGenerator: renderInnerContent$3,\n                seg: seg,\n                timeText: \"\",\n                isDragging: false,\n                isResizing: false,\n                isDateSelecting: false,\n                isSelected: false,\n                isPast: props.isPast,\n                isFuture: props.isFuture,\n                isToday: props.isToday,\n                disableDragging: true,\n                disableResizing: true\n            });\n        }\n    }\n    function renderInnerContent$3(props) {\n        let { title } = props.event;\n        return title && y(\"div\", {\n            className: \"fc-event-title\"\n        }, props.event.title);\n    }\n    function renderFill(fillType) {\n        return y(\"div\", {\n            className: \"fc-\".concat(fillType)\n        });\n    }\n    const WeekNumberContainer = (props)=>y(ViewContextType.Consumer, null, (context)=>{\n            let { dateEnv, options } = context;\n            let { date } = props;\n            let format = options.weekNumberFormat || props.defaultFormat;\n            let num = dateEnv.computeWeekNumber(date); // TODO: somehow use for formatting as well?\n            let text = dateEnv.format(date, format);\n            let renderProps = {\n                num,\n                text,\n                date\n            };\n            return y(ContentContainer // why isn't WeekNumberContentArg being auto-detected?\n            , Object.assign({}, props /* includes children */ , {\n                renderProps: renderProps,\n                generatorName: \"weekNumberContent\",\n                customGenerator: options.weekNumberContent,\n                defaultGenerator: renderInner,\n                classNameGenerator: options.weekNumberClassNames,\n                didMount: options.weekNumberDidMount,\n                willUnmount: options.weekNumberWillUnmount\n            }));\n        });\n    function renderInner(innerProps) {\n        return innerProps.text;\n    }\n    const PADDING_FROM_VIEWPORT = 10;\n    class Popover extends BaseComponent {\n        render() {\n            let { theme, options } = this.context;\n            let { props, state } = this;\n            let classNames = [\n                'fc-popover',\n                theme.getClass('popover')\n            ].concat(props.extraClassNames || []);\n            return j(y(\"div\", Object.assign({}, props.extraAttrs, {\n                id: props.id,\n                className: classNames.join(' '),\n                \"aria-labelledby\": state.titleId,\n                ref: this.handleRootEl\n            }), y(\"div\", {\n                className: 'fc-popover-header ' + theme.getClass('popoverHeader')\n            }, y(\"span\", {\n                className: \"fc-popover-title\",\n                id: state.titleId\n            }, props.title), y(\"span\", {\n                className: 'fc-popover-close ' + theme.getIconClass('close'),\n                title: options.closeHint,\n                onClick: this.handleCloseClick\n            })), y(\"div\", {\n                className: 'fc-popover-body ' + theme.getClass('popoverContent')\n            }, props.children)), props.parentEl);\n        }\n        componentDidMount() {\n            document.addEventListener('mousedown', this.handleDocumentMouseDown);\n            document.addEventListener('keydown', this.handleDocumentKeyDown);\n            this.updateSize();\n        }\n        componentWillUnmount() {\n            document.removeEventListener('mousedown', this.handleDocumentMouseDown);\n            document.removeEventListener('keydown', this.handleDocumentKeyDown);\n        }\n        updateSize() {\n            let { isRtl } = this.context;\n            let { alignmentEl, alignGridTop } = this.props;\n            let { rootEl } = this;\n            let alignmentRect = computeClippedClientRect(alignmentEl);\n            if (alignmentRect) {\n                let popoverDims = rootEl.getBoundingClientRect();\n                // position relative to viewport\n                let popoverTop = alignGridTop ? elementClosest(alignmentEl, '.fc-scrollgrid').getBoundingClientRect().top : alignmentRect.top;\n                let popoverLeft = isRtl ? alignmentRect.right - popoverDims.width : alignmentRect.left;\n                // constrain\n                popoverTop = Math.max(popoverTop, PADDING_FROM_VIEWPORT);\n                popoverLeft = Math.min(popoverLeft, document.documentElement.clientWidth - PADDING_FROM_VIEWPORT - popoverDims.width);\n                popoverLeft = Math.max(popoverLeft, PADDING_FROM_VIEWPORT);\n                let origin = rootEl.offsetParent.getBoundingClientRect();\n                applyStyle(rootEl, {\n                    top: popoverTop - origin.top,\n                    left: popoverLeft - origin.left\n                });\n            }\n        }\n        constructor(){\n            super(...arguments);\n            this.state = {\n                titleId: getUniqueDomId()\n            };\n            this.handleRootEl = (el)=>{\n                this.rootEl = el;\n                if (this.props.elRef) {\n                    setRef(this.props.elRef, el);\n                }\n            };\n            // Triggered when the user clicks *anywhere* in the document, for the autoHide feature\n            this.handleDocumentMouseDown = (ev)=>{\n                // only hide the popover if the click happened outside the popover\n                const target = getEventTargetViaRoot(ev);\n                if (!this.rootEl.contains(target)) {\n                    this.handleCloseClick();\n                }\n            };\n            this.handleDocumentKeyDown = (ev)=>{\n                if (ev.key === 'Escape') {\n                    this.handleCloseClick();\n                }\n            };\n            this.handleCloseClick = ()=>{\n                let { onClose } = this.props;\n                if (onClose) {\n                    onClose();\n                }\n            };\n        }\n    }\n    class MorePopover extends DateComponent {\n        render() {\n            let { options, dateEnv } = this.context;\n            let { props } = this;\n            let { startDate, todayRange, dateProfile } = props;\n            let title = dateEnv.format(startDate, options.dayPopoverFormat);\n            return y(DayCellContainer, {\n                elRef: this.handleRootEl,\n                date: startDate,\n                dateProfile: dateProfile,\n                todayRange: todayRange\n            }, (InnerContent, renderProps, elAttrs)=>y(Popover, {\n                    elRef: elAttrs.ref,\n                    id: props.id,\n                    title: title,\n                    extraClassNames: [\n                        'fc-more-popover'\n                    ].concat(elAttrs.className || []),\n                    extraAttrs: elAttrs /* TODO: make these time-based when not whole-day? */ ,\n                    parentEl: props.parentEl,\n                    alignmentEl: props.alignmentEl,\n                    alignGridTop: props.alignGridTop,\n                    onClose: props.onClose\n                }, hasCustomDayCellContent(options) && y(InnerContent, {\n                    elTag: \"div\",\n                    elClasses: [\n                        'fc-more-popover-misc'\n                    ]\n                }), props.children));\n        }\n        queryHit(positionLeft, positionTop, elWidth, elHeight) {\n            let { rootEl, props } = this;\n            if (positionLeft >= 0 && positionLeft < elWidth && positionTop >= 0 && positionTop < elHeight) {\n                return {\n                    dateProfile: props.dateProfile,\n                    dateSpan: Object.assign({\n                        allDay: !props.forceTimed,\n                        range: {\n                            start: props.startDate,\n                            end: props.endDate\n                        }\n                    }, props.extraDateSpan),\n                    dayEl: rootEl,\n                    rect: {\n                        left: 0,\n                        top: 0,\n                        right: elWidth,\n                        bottom: elHeight\n                    },\n                    layer: 1\n                };\n            }\n            return null;\n        }\n        constructor(){\n            super(...arguments);\n            this.handleRootEl = (rootEl)=>{\n                this.rootEl = rootEl;\n                if (rootEl) {\n                    this.context.registerInteractiveComponent(this, {\n                        el: rootEl,\n                        useEventCenter: false\n                    });\n                } else {\n                    this.context.unregisterInteractiveComponent(this);\n                }\n            };\n        }\n    }\n    class MoreLinkContainer extends BaseComponent {\n        render() {\n            let { props, state } = this;\n            return y(ViewContextType.Consumer, null, (context)=>{\n                let { viewApi, options, calendarApi } = context;\n                let { moreLinkText } = options;\n                let { moreCnt } = props;\n                let range = computeRange(props);\n                let text = typeof moreLinkText === 'function' // TODO: eventually use formatWithOrdinals\n                 ? moreLinkText.call(calendarApi, moreCnt) : \"+\".concat(moreCnt, \" \").concat(moreLinkText);\n                let hint = formatWithOrdinals(options.moreLinkHint, [\n                    moreCnt\n                ], text);\n                let renderProps = {\n                    num: moreCnt,\n                    shortText: \"+\".concat(moreCnt),\n                    text,\n                    view: viewApi\n                };\n                return y(_, null, Boolean(props.moreCnt) && y(ContentContainer, {\n                    elTag: props.elTag || 'a',\n                    elRef: this.handleLinkEl,\n                    elClasses: [\n                        ...props.elClasses || [],\n                        'fc-more-link'\n                    ],\n                    elStyle: props.elStyle,\n                    elAttrs: Object.assign(Object.assign(Object.assign({}, props.elAttrs), createAriaClickAttrs(this.handleClick)), {\n                        title: hint,\n                        'aria-expanded': state.isPopoverOpen,\n                        'aria-controls': state.isPopoverOpen ? state.popoverId : ''\n                    }),\n                    renderProps: renderProps,\n                    generatorName: \"moreLinkContent\",\n                    customGenerator: options.moreLinkContent,\n                    defaultGenerator: props.defaultGenerator || renderMoreLinkInner$1,\n                    classNameGenerator: options.moreLinkClassNames,\n                    didMount: options.moreLinkDidMount,\n                    willUnmount: options.moreLinkWillUnmount\n                }, props.children), state.isPopoverOpen && y(MorePopover, {\n                    id: state.popoverId,\n                    startDate: range.start,\n                    endDate: range.end,\n                    dateProfile: props.dateProfile,\n                    todayRange: props.todayRange,\n                    extraDateSpan: props.extraDateSpan,\n                    parentEl: this.parentEl,\n                    alignmentEl: props.alignmentElRef ? props.alignmentElRef.current : this.linkEl,\n                    alignGridTop: props.alignGridTop,\n                    forceTimed: props.forceTimed,\n                    onClose: this.handlePopoverClose\n                }, props.popoverContent()));\n            });\n        }\n        componentDidMount() {\n            this.updateParentEl();\n        }\n        componentDidUpdate() {\n            this.updateParentEl();\n        }\n        updateParentEl() {\n            if (this.linkEl) {\n                this.parentEl = elementClosest(this.linkEl, '.fc-view-harness');\n            }\n        }\n        constructor(){\n            super(...arguments);\n            this.state = {\n                isPopoverOpen: false,\n                popoverId: getUniqueDomId()\n            };\n            this.handleLinkEl = (linkEl)=>{\n                this.linkEl = linkEl;\n                if (this.props.elRef) {\n                    setRef(this.props.elRef, linkEl);\n                }\n            };\n            this.handleClick = (ev)=>{\n                let { props, context } = this;\n                let { moreLinkClick } = context.options;\n                let date = computeRange(props).start;\n                function buildPublicSeg(seg) {\n                    let { def, instance, range } = seg.eventRange;\n                    return {\n                        event: new EventImpl(context, def, instance),\n                        start: context.dateEnv.toDate(range.start),\n                        end: context.dateEnv.toDate(range.end),\n                        isStart: seg.isStart,\n                        isEnd: seg.isEnd\n                    };\n                }\n                if (typeof moreLinkClick === 'function') {\n                    moreLinkClick = moreLinkClick({\n                        date,\n                        allDay: Boolean(props.allDayDate),\n                        allSegs: props.allSegs.map(buildPublicSeg),\n                        hiddenSegs: props.hiddenSegs.map(buildPublicSeg),\n                        jsEvent: ev,\n                        view: context.viewApi\n                    });\n                }\n                if (!moreLinkClick || moreLinkClick === 'popover') {\n                    this.setState({\n                        isPopoverOpen: true\n                    });\n                } else if (typeof moreLinkClick === 'string') {\n                    context.calendarApi.zoomTo(date, moreLinkClick);\n                }\n            };\n            this.handlePopoverClose = ()=>{\n                this.setState({\n                    isPopoverOpen: false\n                });\n            };\n        }\n    }\n    function renderMoreLinkInner$1(props) {\n        return props.text;\n    }\n    function computeRange(props) {\n        if (props.allDayDate) {\n            return {\n                start: props.allDayDate,\n                end: addDays(props.allDayDate, 1)\n            };\n        }\n        let { hiddenSegs } = props;\n        return {\n            start: computeEarliestSegStart(hiddenSegs),\n            end: computeLatestSegEnd(hiddenSegs)\n        };\n    }\n    function computeEarliestSegStart(segs) {\n        return segs.reduce(pickEarliestStart).eventRange.range.start;\n    }\n    function pickEarliestStart(seg0, seg1) {\n        return seg0.eventRange.range.start < seg1.eventRange.range.start ? seg0 : seg1;\n    }\n    function computeLatestSegEnd(segs) {\n        return segs.reduce(pickLatestEnd).eventRange.range.end;\n    }\n    function pickLatestEnd(seg0, seg1) {\n        return seg0.eventRange.range.end > seg1.eventRange.range.end ? seg0 : seg1;\n    }\n    class ViewContainer extends BaseComponent {\n        render() {\n            let { props, context } = this;\n            let { options } = context;\n            let renderProps = {\n                view: context.viewApi\n            };\n            return y(ContentContainer, Object.assign({}, props, {\n                elTag: props.elTag || 'div',\n                elClasses: [\n                    ...buildViewClassNames(props.viewSpec),\n                    ...props.elClasses || []\n                ],\n                renderProps: renderProps,\n                classNameGenerator: options.viewClassNames,\n                generatorName: undefined,\n                didMount: options.viewDidMount,\n                willUnmount: options.viewWillUnmount\n            }), ()=>props.children);\n        }\n    }\n    function buildViewClassNames(viewSpec) {\n        return [\n            \"fc-\".concat(viewSpec.type, \"-view\"),\n            'fc-view'\n        ];\n    }\n    const EVENT_SOURCE_REFINERS = {\n        id: String,\n        defaultAllDay: Boolean,\n        url: String,\n        format: String,\n        events: identity,\n        eventDataTransform: identity,\n        // for any network-related sources\n        success: identity,\n        failure: identity\n    };\n    function parseEventSource(raw, context) {\n        let refiners = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : buildEventSourceRefiners(context);\n        let rawObj;\n        if (typeof raw === 'string') {\n            rawObj = {\n                url: raw\n            };\n        } else if (typeof raw === 'function' || Array.isArray(raw)) {\n            rawObj = {\n                events: raw\n            };\n        } else if (typeof raw === 'object' && raw) {\n            rawObj = raw;\n        }\n        if (rawObj) {\n            let { refined, extra } = refineProps(rawObj, refiners);\n            let metaRes = buildEventSourceMeta(refined, context);\n            if (metaRes) {\n                return {\n                    _raw: raw,\n                    isFetching: false,\n                    latestFetchId: '',\n                    fetchRange: null,\n                    defaultAllDay: refined.defaultAllDay,\n                    eventDataTransform: refined.eventDataTransform,\n                    success: refined.success,\n                    failure: refined.failure,\n                    publicId: refined.id || '',\n                    sourceId: guid(),\n                    sourceDefId: metaRes.sourceDefId,\n                    meta: metaRes.meta,\n                    ui: createEventUi(refined, context),\n                    extendedProps: extra\n                };\n            }\n        }\n        return null;\n    }\n    function buildEventSourceRefiners(context) {\n        return Object.assign(Object.assign(Object.assign({}, EVENT_UI_REFINERS), EVENT_SOURCE_REFINERS), context.pluginHooks.eventSourceRefiners);\n    }\n    function buildEventSourceMeta(raw, context) {\n        let defs = context.pluginHooks.eventSourceDefs;\n        for(let i = defs.length - 1; i >= 0; i -= 1){\n            let def = defs[i];\n            let meta = def.parseMeta(raw);\n            if (meta) {\n                return {\n                    sourceDefId: i,\n                    meta\n                };\n            }\n        }\n        return null;\n    }\n    class CalendarImpl {\n        getCurrentData() {\n            return this.currentDataManager.getCurrentData();\n        }\n        dispatch(action) {\n            this.currentDataManager.dispatch(action);\n        }\n        get view() {\n            return this.getCurrentData().viewApi;\n        }\n        batchRendering(callback) {\n            callback();\n        }\n        updateSize() {\n            this.trigger('_resize', true);\n        }\n        // Options\n        // -----------------------------------------------------------------------------------------------------------------\n        setOption(name, val) {\n            this.dispatch({\n                type: 'SET_OPTION',\n                optionName: name,\n                rawOptionValue: val\n            });\n        }\n        getOption(name) {\n            return this.currentDataManager.currentCalendarOptionsInput[name];\n        }\n        getAvailableLocaleCodes() {\n            return Object.keys(this.getCurrentData().availableRawLocales);\n        }\n        // Trigger\n        // -----------------------------------------------------------------------------------------------------------------\n        on(handlerName, handler) {\n            let { currentDataManager } = this;\n            if (currentDataManager.currentCalendarOptionsRefiners[handlerName]) {\n                currentDataManager.emitter.on(handlerName, handler);\n            } else {\n                console.warn(\"Unknown listener name '\".concat(handlerName, \"'\"));\n            }\n        }\n        off(handlerName, handler) {\n            this.currentDataManager.emitter.off(handlerName, handler);\n        }\n        // not meant for public use\n        trigger(handlerName) {\n            for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n                args[_key - 1] = arguments[_key];\n            }\n            this.currentDataManager.emitter.trigger(handlerName, ...args);\n        }\n        // View\n        // -----------------------------------------------------------------------------------------------------------------\n        changeView(viewType, dateOrRange) {\n            this.batchRendering(()=>{\n                this.unselect();\n                if (dateOrRange) {\n                    if (dateOrRange.start && dateOrRange.end) {\n                        this.dispatch({\n                            type: 'CHANGE_VIEW_TYPE',\n                            viewType\n                        });\n                        this.dispatch({\n                            type: 'SET_OPTION',\n                            optionName: 'visibleRange',\n                            rawOptionValue: dateOrRange\n                        });\n                    } else {\n                        let { dateEnv } = this.getCurrentData();\n                        this.dispatch({\n                            type: 'CHANGE_VIEW_TYPE',\n                            viewType,\n                            dateMarker: dateEnv.createMarker(dateOrRange)\n                        });\n                    }\n                } else {\n                    this.dispatch({\n                        type: 'CHANGE_VIEW_TYPE',\n                        viewType\n                    });\n                }\n            });\n        }\n        // Forces navigation to a view for the given date.\n        // `viewType` can be a specific view name or a generic one like \"week\" or \"day\".\n        // needs to change\n        zoomTo(dateMarker, viewType) {\n            let state = this.getCurrentData();\n            let spec;\n            viewType = viewType || 'day'; // day is default zoom\n            spec = state.viewSpecs[viewType] || this.getUnitViewSpec(viewType);\n            this.unselect();\n            if (spec) {\n                this.dispatch({\n                    type: 'CHANGE_VIEW_TYPE',\n                    viewType: spec.type,\n                    dateMarker\n                });\n            } else {\n                this.dispatch({\n                    type: 'CHANGE_DATE',\n                    dateMarker\n                });\n            }\n        }\n        // Given a duration singular unit, like \"week\" or \"day\", finds a matching view spec.\n        // Preference is given to views that have corresponding buttons.\n        getUnitViewSpec(unit) {\n            let { viewSpecs, toolbarConfig } = this.getCurrentData();\n            let viewTypes = [].concat(toolbarConfig.header ? toolbarConfig.header.viewsWithButtons : [], toolbarConfig.footer ? toolbarConfig.footer.viewsWithButtons : []);\n            let i;\n            let spec;\n            for(let viewType in viewSpecs){\n                viewTypes.push(viewType);\n            }\n            for(i = 0; i < viewTypes.length; i += 1){\n                spec = viewSpecs[viewTypes[i]];\n                if (spec) {\n                    if (spec.singleUnit === unit) {\n                        return spec;\n                    }\n                }\n            }\n            return null;\n        }\n        // Current Date\n        // -----------------------------------------------------------------------------------------------------------------\n        prev() {\n            this.unselect();\n            this.dispatch({\n                type: 'PREV'\n            });\n        }\n        next() {\n            this.unselect();\n            this.dispatch({\n                type: 'NEXT'\n            });\n        }\n        prevYear() {\n            let state = this.getCurrentData();\n            this.unselect();\n            this.dispatch({\n                type: 'CHANGE_DATE',\n                dateMarker: state.dateEnv.addYears(state.currentDate, -1)\n            });\n        }\n        nextYear() {\n            let state = this.getCurrentData();\n            this.unselect();\n            this.dispatch({\n                type: 'CHANGE_DATE',\n                dateMarker: state.dateEnv.addYears(state.currentDate, 1)\n            });\n        }\n        today() {\n            let state = this.getCurrentData();\n            this.unselect();\n            this.dispatch({\n                type: 'CHANGE_DATE',\n                dateMarker: getNow(state.calendarOptions.now, state.dateEnv)\n            });\n        }\n        gotoDate(zonedDateInput) {\n            let state = this.getCurrentData();\n            this.unselect();\n            this.dispatch({\n                type: 'CHANGE_DATE',\n                dateMarker: state.dateEnv.createMarker(zonedDateInput)\n            });\n        }\n        incrementDate(deltaInput) {\n            let state = this.getCurrentData();\n            let delta = createDuration(deltaInput);\n            if (delta) {\n                this.unselect();\n                this.dispatch({\n                    type: 'CHANGE_DATE',\n                    dateMarker: state.dateEnv.add(state.currentDate, delta)\n                });\n            }\n        }\n        getDate() {\n            let state = this.getCurrentData();\n            return state.dateEnv.toDate(state.currentDate);\n        }\n        // Date Formatting Utils\n        // -----------------------------------------------------------------------------------------------------------------\n        formatDate(d, formatter) {\n            let { dateEnv } = this.getCurrentData();\n            return dateEnv.format(dateEnv.createMarker(d), createFormatter(formatter));\n        }\n        // `settings` is for formatter AND isEndExclusive\n        formatRange(d0, d1, settings) {\n            let { dateEnv } = this.getCurrentData();\n            return dateEnv.formatRange(dateEnv.createMarker(d0), dateEnv.createMarker(d1), createFormatter(settings), settings);\n        }\n        formatIso(d, omitTime) {\n            let { dateEnv } = this.getCurrentData();\n            return dateEnv.formatIso(dateEnv.createMarker(d), {\n                omitTime\n            });\n        }\n        // Date Selection / Event Selection / DayClick\n        // -----------------------------------------------------------------------------------------------------------------\n        select(dateOrObj, endDate) {\n            let selectionInput;\n            if (endDate == null) {\n                if (dateOrObj.start != null) {\n                    selectionInput = dateOrObj;\n                } else {\n                    selectionInput = {\n                        start: dateOrObj,\n                        end: null\n                    };\n                }\n            } else {\n                selectionInput = {\n                    start: dateOrObj,\n                    end: endDate\n                };\n            }\n            let state = this.getCurrentData();\n            let selection = parseDateSpan(selectionInput, state.dateEnv, createDuration({\n                days: 1\n            }));\n            if (selection) {\n                this.dispatch({\n                    type: 'SELECT_DATES',\n                    selection\n                });\n                triggerDateSelect(selection, null, state);\n            }\n        }\n        unselect(pev) {\n            let state = this.getCurrentData();\n            if (state.dateSelection) {\n                this.dispatch({\n                    type: 'UNSELECT_DATES'\n                });\n                triggerDateUnselect(pev, state);\n            }\n        }\n        // Public Events API\n        // -----------------------------------------------------------------------------------------------------------------\n        addEvent(eventInput, sourceInput) {\n            if (eventInput instanceof EventImpl) {\n                let def = eventInput._def;\n                let instance = eventInput._instance;\n                let currentData = this.getCurrentData();\n                // not already present? don't want to add an old snapshot\n                if (!currentData.eventStore.defs[def.defId]) {\n                    this.dispatch({\n                        type: 'ADD_EVENTS',\n                        eventStore: eventTupleToStore({\n                            def,\n                            instance\n                        })\n                    });\n                    this.triggerEventAdd(eventInput);\n                }\n                return eventInput;\n            }\n            let state = this.getCurrentData();\n            let eventSource;\n            if (sourceInput instanceof EventSourceImpl) {\n                eventSource = sourceInput.internalEventSource;\n            } else if (typeof sourceInput === 'boolean') {\n                if (sourceInput) {\n                    [eventSource] = hashValuesToArray(state.eventSources);\n                }\n            } else if (sourceInput != null) {\n                let sourceApi = this.getEventSourceById(sourceInput); // TODO: use an internal function\n                if (!sourceApi) {\n                    console.warn('Could not find an event source with ID \"'.concat(sourceInput, '\"')); // TODO: test\n                    return null;\n                }\n                eventSource = sourceApi.internalEventSource;\n            }\n            let tuple = parseEvent(eventInput, eventSource, state, false);\n            if (tuple) {\n                let newEventApi = new EventImpl(state, tuple.def, tuple.def.recurringDef ? null : tuple.instance);\n                this.dispatch({\n                    type: 'ADD_EVENTS',\n                    eventStore: eventTupleToStore(tuple)\n                });\n                this.triggerEventAdd(newEventApi);\n                return newEventApi;\n            }\n            return null;\n        }\n        triggerEventAdd(eventApi) {\n            let { emitter } = this.getCurrentData();\n            emitter.trigger('eventAdd', {\n                event: eventApi,\n                relatedEvents: [],\n                revert: ()=>{\n                    this.dispatch({\n                        type: 'REMOVE_EVENTS',\n                        eventStore: eventApiToStore(eventApi)\n                    });\n                }\n            });\n        }\n        // TODO: optimize\n        getEventById(id) {\n            let state = this.getCurrentData();\n            let { defs, instances } = state.eventStore;\n            id = String(id);\n            for(let defId in defs){\n                let def = defs[defId];\n                if (def.publicId === id) {\n                    if (def.recurringDef) {\n                        return new EventImpl(state, def, null);\n                    }\n                    for(let instanceId in instances){\n                        let instance = instances[instanceId];\n                        if (instance.defId === def.defId) {\n                            return new EventImpl(state, def, instance);\n                        }\n                    }\n                }\n            }\n            return null;\n        }\n        getEvents() {\n            let currentData = this.getCurrentData();\n            return buildEventApis(currentData.eventStore, currentData);\n        }\n        removeAllEvents() {\n            this.dispatch({\n                type: 'REMOVE_ALL_EVENTS'\n            });\n        }\n        // Public Event Sources API\n        // -----------------------------------------------------------------------------------------------------------------\n        getEventSources() {\n            let state = this.getCurrentData();\n            let sourceHash = state.eventSources;\n            let sourceApis = [];\n            for(let internalId in sourceHash){\n                sourceApis.push(new EventSourceImpl(state, sourceHash[internalId]));\n            }\n            return sourceApis;\n        }\n        getEventSourceById(id) {\n            let state = this.getCurrentData();\n            let sourceHash = state.eventSources;\n            id = String(id);\n            for(let sourceId in sourceHash){\n                if (sourceHash[sourceId].publicId === id) {\n                    return new EventSourceImpl(state, sourceHash[sourceId]);\n                }\n            }\n            return null;\n        }\n        addEventSource(sourceInput) {\n            let state = this.getCurrentData();\n            if (sourceInput instanceof EventSourceImpl) {\n                // not already present? don't want to add an old snapshot\n                if (!state.eventSources[sourceInput.internalEventSource.sourceId]) {\n                    this.dispatch({\n                        type: 'ADD_EVENT_SOURCES',\n                        sources: [\n                            sourceInput.internalEventSource\n                        ]\n                    });\n                }\n                return sourceInput;\n            }\n            let eventSource = parseEventSource(sourceInput, state);\n            if (eventSource) {\n                this.dispatch({\n                    type: 'ADD_EVENT_SOURCES',\n                    sources: [\n                        eventSource\n                    ]\n                });\n                return new EventSourceImpl(state, eventSource);\n            }\n            return null;\n        }\n        removeAllEventSources() {\n            this.dispatch({\n                type: 'REMOVE_ALL_EVENT_SOURCES'\n            });\n        }\n        refetchEvents() {\n            this.dispatch({\n                type: 'FETCH_EVENT_SOURCES',\n                isRefetch: true\n            });\n        }\n        // Scroll\n        // -----------------------------------------------------------------------------------------------------------------\n        scrollToTime(timeInput) {\n            let time = createDuration(timeInput);\n            if (time) {\n                this.trigger('_scrollRequest', {\n                    time\n                });\n            }\n        }\n    }\n    class Store {\n        set(value) {\n            this.currentValue = value;\n            for (let handler of this.handlers){\n                handler(value);\n            }\n        }\n        subscribe(handler) {\n            this.handlers.push(handler);\n            if (this.currentValue !== undefined) {\n                handler(this.currentValue);\n            }\n        }\n        constructor(){\n            this.handlers = [];\n        }\n    }\n    /*\r\n    Subscribers will get a LIST of CustomRenderings\r\n    */ class CustomRenderingStore extends Store {\n        // for consistent order\n        handle(customRendering) {\n            const { map } = this;\n            let updated = false;\n            if (customRendering.isActive) {\n                map.set(customRendering.id, customRendering);\n                updated = true;\n            } else if (map.has(customRendering.id)) {\n                map.delete(customRendering.id);\n                updated = true;\n            }\n            if (updated) {\n                this.set(map);\n            }\n        }\n        constructor(){\n            super(...arguments);\n            this.map = new Map();\n        }\n    }\n    var internal = {\n        __proto__: null,\n        BASE_OPTION_DEFAULTS: BASE_OPTION_DEFAULTS,\n        BaseComponent: BaseComponent,\n        BgEvent: BgEvent,\n        CalendarImpl: CalendarImpl,\n        CalendarRoot: CalendarRoot,\n        ContentContainer: ContentContainer,\n        CustomRenderingStore: CustomRenderingStore,\n        DateComponent: DateComponent,\n        DateEnv: DateEnv,\n        DateProfileGenerator: DateProfileGenerator,\n        DayCellContainer: DayCellContainer,\n        DayHeader: DayHeader,\n        DaySeriesModel: DaySeriesModel,\n        DayTableModel: DayTableModel,\n        DelayedRunner: DelayedRunner,\n        ElementDragging: ElementDragging,\n        ElementScrollController: ElementScrollController,\n        Emitter: Emitter,\n        EventContainer: EventContainer,\n        EventImpl: EventImpl,\n        Interaction: Interaction,\n        MoreLinkContainer: MoreLinkContainer,\n        NamedTimeZoneImpl: NamedTimeZoneImpl,\n        NowIndicatorContainer: NowIndicatorContainer,\n        NowTimer: NowTimer,\n        PositionCache: PositionCache,\n        RefMap: RefMap,\n        ScrollController: ScrollController,\n        ScrollResponder: ScrollResponder,\n        Scroller: Scroller,\n        SegHierarchy: SegHierarchy,\n        SimpleScrollGrid: SimpleScrollGrid,\n        Slicer: Slicer,\n        Splitter: Splitter,\n        StandardEvent: StandardEvent,\n        TableDateCell: TableDateCell,\n        TableDowCell: TableDowCell,\n        Theme: Theme,\n        ViewContainer: ViewContainer,\n        ViewContextType: ViewContextType,\n        WeekNumberContainer: WeekNumberContainer,\n        WindowScrollController: WindowScrollController,\n        addDays: addDays,\n        addDurations: addDurations,\n        addMs: addMs,\n        addWeeks: addWeeks,\n        allowContextMenu: allowContextMenu,\n        allowSelection: allowSelection,\n        applyMutationToEventStore: applyMutationToEventStore,\n        applyStyle: applyStyle,\n        asCleanDays: asCleanDays,\n        asRoughMinutes: asRoughMinutes,\n        asRoughMs: asRoughMs,\n        asRoughSeconds: asRoughSeconds,\n        binarySearch: binarySearch,\n        buildElAttrs: buildElAttrs,\n        buildEntryKey: buildEntryKey,\n        buildEventApis: buildEventApis,\n        buildEventRangeKey: buildEventRangeKey,\n        buildIsoString: buildIsoString,\n        buildNavLinkAttrs: buildNavLinkAttrs,\n        buildSegTimeText: buildSegTimeText,\n        collectFromHash: collectFromHash,\n        combineEventUis: combineEventUis,\n        compareByFieldSpecs: compareByFieldSpecs,\n        compareNumbers: compareNumbers,\n        compareObjs: compareObjs,\n        computeEarliestSegStart: computeEarliestSegStart,\n        computeEdges: computeEdges,\n        computeFallbackHeaderFormat: computeFallbackHeaderFormat,\n        computeInnerRect: computeInnerRect,\n        computeRect: computeRect,\n        computeShrinkWidth: computeShrinkWidth,\n        computeVisibleDayRange: computeVisibleDayRange,\n        config: config,\n        constrainPoint: constrainPoint,\n        createDuration: createDuration,\n        createEmptyEventStore: createEmptyEventStore,\n        createEventInstance: createEventInstance,\n        createEventUi: createEventUi,\n        createFormatter: createFormatter,\n        diffDates: diffDates,\n        diffDayAndTime: diffDayAndTime,\n        diffDays: diffDays,\n        diffPoints: diffPoints,\n        diffWeeks: diffWeeks,\n        diffWholeDays: diffWholeDays,\n        diffWholeWeeks: diffWholeWeeks,\n        disableCursor: disableCursor,\n        elementClosest: elementClosest,\n        elementMatches: elementMatches,\n        enableCursor: enableCursor,\n        eventTupleToStore: eventTupleToStore,\n        filterHash: filterHash,\n        findDirectChildren: findDirectChildren,\n        findElements: findElements,\n        flexibleCompare: flexibleCompare,\n        formatDayString: formatDayString,\n        formatIsoMonthStr: formatIsoMonthStr,\n        formatIsoTimeString: formatIsoTimeString,\n        getAllowYScrolling: getAllowYScrolling,\n        getCanVGrowWithinCell: getCanVGrowWithinCell,\n        getClippingParents: getClippingParents,\n        getDateMeta: getDateMeta,\n        getDayClassNames: getDayClassNames,\n        getDefaultEventEnd: getDefaultEventEnd,\n        getElSeg: getElSeg,\n        getEntrySpanEnd: getEntrySpanEnd,\n        getEventTargetViaRoot: getEventTargetViaRoot,\n        getIsRtlScrollbarOnLeft: getIsRtlScrollbarOnLeft,\n        getRectCenter: getRectCenter,\n        getRelevantEvents: getRelevantEvents,\n        getScrollGridClassNames: getScrollGridClassNames,\n        getScrollbarWidths: getScrollbarWidths,\n        getSectionClassNames: getSectionClassNames,\n        getSectionHasLiquidHeight: getSectionHasLiquidHeight,\n        getSegAnchorAttrs: getSegAnchorAttrs,\n        getSegMeta: getSegMeta,\n        getSlotClassNames: getSlotClassNames,\n        getStickyFooterScrollbar: getStickyFooterScrollbar,\n        getStickyHeaderDates: getStickyHeaderDates,\n        getUniqueDomId: getUniqueDomId,\n        greatestDurationDenominator: greatestDurationDenominator,\n        groupIntersectingEntries: groupIntersectingEntries,\n        guid: guid,\n        hasBgRendering: hasBgRendering,\n        hasCustomDayCellContent: hasCustomDayCellContent,\n        hasShrinkWidth: hasShrinkWidth,\n        identity: identity,\n        injectStyles: injectStyles,\n        interactionSettingsStore: interactionSettingsStore,\n        interactionSettingsToStore: interactionSettingsToStore,\n        intersectRanges: intersectRanges,\n        intersectRects: intersectRects,\n        intersectSpans: intersectSpans,\n        isArraysEqual: isArraysEqual,\n        isColPropsEqual: isColPropsEqual,\n        isDateSelectionValid: isDateSelectionValid,\n        isDateSpansEqual: isDateSpansEqual,\n        isInt: isInt,\n        isInteractionValid: isInteractionValid,\n        isMultiDayRange: isMultiDayRange,\n        isPropsEqual: isPropsEqual,\n        isPropsValid: isPropsValid,\n        isValidDate: isValidDate,\n        mapHash: mapHash,\n        memoize: memoize,\n        memoizeArraylike: memoizeArraylike,\n        memoizeHashlike: memoizeHashlike,\n        memoizeObjArg: memoizeObjArg,\n        mergeEventStores: mergeEventStores,\n        multiplyDuration: multiplyDuration,\n        padStart: padStart,\n        parseBusinessHours: parseBusinessHours,\n        parseClassNames: parseClassNames,\n        parseDragMeta: parseDragMeta,\n        parseEventDef: parseEventDef,\n        parseFieldSpecs: parseFieldSpecs,\n        parseMarker: parse,\n        pointInsideRect: pointInsideRect,\n        preventContextMenu: preventContextMenu,\n        preventDefault: preventDefault,\n        preventSelection: preventSelection,\n        rangeContainsMarker: rangeContainsMarker,\n        rangeContainsRange: rangeContainsRange,\n        rangesEqual: rangesEqual,\n        rangesIntersect: rangesIntersect,\n        refineEventDef: refineEventDef,\n        refineProps: refineProps,\n        removeElement: removeElement,\n        removeExact: removeExact,\n        renderChunkContent: renderChunkContent,\n        renderFill: renderFill,\n        renderMicroColGroup: renderMicroColGroup,\n        renderScrollShim: renderScrollShim,\n        requestJson: requestJson,\n        sanitizeShrinkWidth: sanitizeShrinkWidth,\n        setRef: setRef,\n        sliceEventStore: sliceEventStore,\n        sortEventSegs: sortEventSegs,\n        startOfDay: startOfDay,\n        translateRect: translateRect,\n        triggerDateSelect: triggerDateSelect,\n        unpromisify: unpromisify,\n        whenTransitionDone: whenTransitionDone,\n        wholeDivideDurations: wholeDivideDurations\n    };\n    var preact = {\n        __proto__: null,\n        createPortal: j,\n        createContext: createContext,\n        flushSync: flushSync,\n        Component: x$1,\n        Fragment: _,\n        cloneElement: F$1,\n        createElement: y,\n        createRef: d,\n        h: y,\n        hydrate: E,\n        get isValidElement () {\n            return i$1;\n        },\n        get options () {\n            return l$1;\n        },\n        render: D$1,\n        toChildArray: j$2\n    };\n    const globalLocales = [];\n    const MINIMAL_RAW_EN_LOCALE = {\n        code: 'en',\n        week: {\n            dow: 0,\n            doy: 4\n        },\n        direction: 'ltr',\n        buttonText: {\n            prev: 'prev',\n            next: 'next',\n            prevYear: 'prev year',\n            nextYear: 'next year',\n            year: 'year',\n            today: 'today',\n            month: 'month',\n            week: 'week',\n            day: 'day',\n            list: 'list'\n        },\n        weekText: 'W',\n        weekTextLong: 'Week',\n        closeHint: 'Close',\n        timeHint: 'Time',\n        eventHint: 'Event',\n        allDayText: 'all-day',\n        moreLinkText: 'more',\n        noEventsText: 'No events to display'\n    };\n    const RAW_EN_LOCALE = Object.assign(Object.assign({}, MINIMAL_RAW_EN_LOCALE), {\n        // Includes things we don't want other locales to inherit,\n        // things that derive from other translatable strings.\n        buttonHints: {\n            prev: 'Previous $0',\n            next: 'Next $0',\n            today (buttonText, unit) {\n                return unit === 'day' ? 'Today' : \"This \".concat(buttonText);\n            }\n        },\n        viewHint: '$0 view',\n        navLinkHint: 'Go to $0',\n        moreLinkHint (eventCnt) {\n            return \"Show \".concat(eventCnt, \" more event\").concat(eventCnt === 1 ? '' : 's');\n        }\n    });\n    function organizeRawLocales(explicitRawLocales) {\n        let defaultCode = explicitRawLocales.length > 0 ? explicitRawLocales[0].code : 'en';\n        let allRawLocales = globalLocales.concat(explicitRawLocales);\n        let rawLocaleMap = {\n            en: RAW_EN_LOCALE\n        };\n        for (let rawLocale of allRawLocales){\n            rawLocaleMap[rawLocale.code] = rawLocale;\n        }\n        return {\n            map: rawLocaleMap,\n            defaultCode\n        };\n    }\n    function buildLocale(inputSingular, available) {\n        if (typeof inputSingular === 'object' && !Array.isArray(inputSingular)) {\n            return parseLocale(inputSingular.code, [\n                inputSingular.code\n            ], inputSingular);\n        }\n        return queryLocale(inputSingular, available);\n    }\n    function queryLocale(codeArg, available) {\n        let codes = [].concat(codeArg || []); // will convert to array\n        let raw = queryRawLocale(codes, available) || RAW_EN_LOCALE;\n        return parseLocale(codeArg, codes, raw);\n    }\n    function queryRawLocale(codes, available) {\n        for(let i = 0; i < codes.length; i += 1){\n            let parts = codes[i].toLocaleLowerCase().split('-');\n            for(let j = parts.length; j > 0; j -= 1){\n                let simpleId = parts.slice(0, j).join('-');\n                if (available[simpleId]) {\n                    return available[simpleId];\n                }\n            }\n        }\n        return null;\n    }\n    function parseLocale(codeArg, codes, raw) {\n        let merged = mergeProps([\n            MINIMAL_RAW_EN_LOCALE,\n            raw\n        ], [\n            'buttonText'\n        ]);\n        delete merged.code; // don't want this part of the options\n        let { week } = merged;\n        delete merged.week;\n        return {\n            codeArg,\n            codes,\n            week,\n            simpleNumberFormat: new Intl.NumberFormat(codeArg),\n            options: merged\n        };\n    }\n    // TODO: easier way to add new hooks? need to update a million things\n    function createPlugin(input) {\n        return {\n            id: guid(),\n            name: input.name,\n            premiumReleaseDate: input.premiumReleaseDate ? new Date(input.premiumReleaseDate) : undefined,\n            deps: input.deps || [],\n            reducers: input.reducers || [],\n            isLoadingFuncs: input.isLoadingFuncs || [],\n            contextInit: [].concat(input.contextInit || []),\n            eventRefiners: input.eventRefiners || {},\n            eventDefMemberAdders: input.eventDefMemberAdders || [],\n            eventSourceRefiners: input.eventSourceRefiners || {},\n            isDraggableTransformers: input.isDraggableTransformers || [],\n            eventDragMutationMassagers: input.eventDragMutationMassagers || [],\n            eventDefMutationAppliers: input.eventDefMutationAppliers || [],\n            dateSelectionTransformers: input.dateSelectionTransformers || [],\n            datePointTransforms: input.datePointTransforms || [],\n            dateSpanTransforms: input.dateSpanTransforms || [],\n            views: input.views || {},\n            viewPropsTransformers: input.viewPropsTransformers || [],\n            isPropsValid: input.isPropsValid || null,\n            externalDefTransforms: input.externalDefTransforms || [],\n            viewContainerAppends: input.viewContainerAppends || [],\n            eventDropTransformers: input.eventDropTransformers || [],\n            componentInteractions: input.componentInteractions || [],\n            calendarInteractions: input.calendarInteractions || [],\n            themeClasses: input.themeClasses || {},\n            eventSourceDefs: input.eventSourceDefs || [],\n            cmdFormatter: input.cmdFormatter,\n            recurringTypes: input.recurringTypes || [],\n            namedTimeZonedImpl: input.namedTimeZonedImpl,\n            initialView: input.initialView || '',\n            elementDraggingImpl: input.elementDraggingImpl,\n            optionChangeHandlers: input.optionChangeHandlers || {},\n            scrollGridImpl: input.scrollGridImpl || null,\n            listenerRefiners: input.listenerRefiners || {},\n            optionRefiners: input.optionRefiners || {},\n            propSetHandlers: input.propSetHandlers || {}\n        };\n    }\n    function buildPluginHooks(pluginDefs, globalDefs) {\n        let currentPluginIds = {};\n        let hooks = {\n            premiumReleaseDate: undefined,\n            reducers: [],\n            isLoadingFuncs: [],\n            contextInit: [],\n            eventRefiners: {},\n            eventDefMemberAdders: [],\n            eventSourceRefiners: {},\n            isDraggableTransformers: [],\n            eventDragMutationMassagers: [],\n            eventDefMutationAppliers: [],\n            dateSelectionTransformers: [],\n            datePointTransforms: [],\n            dateSpanTransforms: [],\n            views: {},\n            viewPropsTransformers: [],\n            isPropsValid: null,\n            externalDefTransforms: [],\n            viewContainerAppends: [],\n            eventDropTransformers: [],\n            componentInteractions: [],\n            calendarInteractions: [],\n            themeClasses: {},\n            eventSourceDefs: [],\n            cmdFormatter: null,\n            recurringTypes: [],\n            namedTimeZonedImpl: null,\n            initialView: '',\n            elementDraggingImpl: null,\n            optionChangeHandlers: {},\n            scrollGridImpl: null,\n            listenerRefiners: {},\n            optionRefiners: {},\n            propSetHandlers: {}\n        };\n        function addDefs(defs) {\n            for (let def of defs){\n                const pluginName = def.name;\n                const currentId = currentPluginIds[pluginName];\n                if (currentId === undefined) {\n                    currentPluginIds[pluginName] = def.id;\n                    addDefs(def.deps);\n                    hooks = combineHooks(hooks, def);\n                } else if (currentId !== def.id) {\n                    // different ID than the one already added\n                    console.warn(\"Duplicate plugin '\".concat(pluginName, \"'\"));\n                }\n            }\n        }\n        if (pluginDefs) {\n            addDefs(pluginDefs);\n        }\n        addDefs(globalDefs);\n        return hooks;\n    }\n    function buildBuildPluginHooks() {\n        let currentOverrideDefs = [];\n        let currentGlobalDefs = [];\n        let currentHooks;\n        return (overrideDefs, globalDefs)=>{\n            if (!currentHooks || !isArraysEqual(overrideDefs, currentOverrideDefs) || !isArraysEqual(globalDefs, currentGlobalDefs)) {\n                currentHooks = buildPluginHooks(overrideDefs, globalDefs);\n            }\n            currentOverrideDefs = overrideDefs;\n            currentGlobalDefs = globalDefs;\n            return currentHooks;\n        };\n    }\n    function combineHooks(hooks0, hooks1) {\n        return {\n            premiumReleaseDate: compareOptionalDates(hooks0.premiumReleaseDate, hooks1.premiumReleaseDate),\n            reducers: hooks0.reducers.concat(hooks1.reducers),\n            isLoadingFuncs: hooks0.isLoadingFuncs.concat(hooks1.isLoadingFuncs),\n            contextInit: hooks0.contextInit.concat(hooks1.contextInit),\n            eventRefiners: Object.assign(Object.assign({}, hooks0.eventRefiners), hooks1.eventRefiners),\n            eventDefMemberAdders: hooks0.eventDefMemberAdders.concat(hooks1.eventDefMemberAdders),\n            eventSourceRefiners: Object.assign(Object.assign({}, hooks0.eventSourceRefiners), hooks1.eventSourceRefiners),\n            isDraggableTransformers: hooks0.isDraggableTransformers.concat(hooks1.isDraggableTransformers),\n            eventDragMutationMassagers: hooks0.eventDragMutationMassagers.concat(hooks1.eventDragMutationMassagers),\n            eventDefMutationAppliers: hooks0.eventDefMutationAppliers.concat(hooks1.eventDefMutationAppliers),\n            dateSelectionTransformers: hooks0.dateSelectionTransformers.concat(hooks1.dateSelectionTransformers),\n            datePointTransforms: hooks0.datePointTransforms.concat(hooks1.datePointTransforms),\n            dateSpanTransforms: hooks0.dateSpanTransforms.concat(hooks1.dateSpanTransforms),\n            views: Object.assign(Object.assign({}, hooks0.views), hooks1.views),\n            viewPropsTransformers: hooks0.viewPropsTransformers.concat(hooks1.viewPropsTransformers),\n            isPropsValid: hooks1.isPropsValid || hooks0.isPropsValid,\n            externalDefTransforms: hooks0.externalDefTransforms.concat(hooks1.externalDefTransforms),\n            viewContainerAppends: hooks0.viewContainerAppends.concat(hooks1.viewContainerAppends),\n            eventDropTransformers: hooks0.eventDropTransformers.concat(hooks1.eventDropTransformers),\n            calendarInteractions: hooks0.calendarInteractions.concat(hooks1.calendarInteractions),\n            componentInteractions: hooks0.componentInteractions.concat(hooks1.componentInteractions),\n            themeClasses: Object.assign(Object.assign({}, hooks0.themeClasses), hooks1.themeClasses),\n            eventSourceDefs: hooks0.eventSourceDefs.concat(hooks1.eventSourceDefs),\n            cmdFormatter: hooks1.cmdFormatter || hooks0.cmdFormatter,\n            recurringTypes: hooks0.recurringTypes.concat(hooks1.recurringTypes),\n            namedTimeZonedImpl: hooks1.namedTimeZonedImpl || hooks0.namedTimeZonedImpl,\n            initialView: hooks0.initialView || hooks1.initialView,\n            elementDraggingImpl: hooks0.elementDraggingImpl || hooks1.elementDraggingImpl,\n            optionChangeHandlers: Object.assign(Object.assign({}, hooks0.optionChangeHandlers), hooks1.optionChangeHandlers),\n            scrollGridImpl: hooks1.scrollGridImpl || hooks0.scrollGridImpl,\n            listenerRefiners: Object.assign(Object.assign({}, hooks0.listenerRefiners), hooks1.listenerRefiners),\n            optionRefiners: Object.assign(Object.assign({}, hooks0.optionRefiners), hooks1.optionRefiners),\n            propSetHandlers: Object.assign(Object.assign({}, hooks0.propSetHandlers), hooks1.propSetHandlers)\n        };\n    }\n    function compareOptionalDates(date0, date1) {\n        if (date0 === undefined) {\n            return date1;\n        }\n        if (date1 === undefined) {\n            return date0;\n        }\n        return new Date(Math.max(date0.valueOf(), date1.valueOf()));\n    }\n    class StandardTheme extends Theme {\n    }\n    StandardTheme.prototype.classes = {\n        root: 'fc-theme-standard',\n        tableCellShaded: 'fc-cell-shaded',\n        buttonGroup: 'fc-button-group',\n        button: 'fc-button fc-button-primary',\n        buttonActive: 'fc-button-active'\n    };\n    StandardTheme.prototype.baseIconClass = 'fc-icon';\n    StandardTheme.prototype.iconClasses = {\n        close: 'fc-icon-x',\n        prev: 'fc-icon-chevron-left',\n        next: 'fc-icon-chevron-right',\n        prevYear: 'fc-icon-chevrons-left',\n        nextYear: 'fc-icon-chevrons-right'\n    };\n    StandardTheme.prototype.rtlIconClasses = {\n        prev: 'fc-icon-chevron-right',\n        next: 'fc-icon-chevron-left',\n        prevYear: 'fc-icon-chevrons-right',\n        nextYear: 'fc-icon-chevrons-left'\n    };\n    StandardTheme.prototype.iconOverrideOption = 'buttonIcons'; // TODO: make TS-friendly\n    StandardTheme.prototype.iconOverrideCustomButtonOption = 'icon';\n    StandardTheme.prototype.iconOverridePrefix = 'fc-icon-';\n    function compileViewDefs(defaultConfigs, overrideConfigs) {\n        let hash = {};\n        let viewType;\n        for(viewType in defaultConfigs){\n            ensureViewDef(viewType, hash, defaultConfigs, overrideConfigs);\n        }\n        for(viewType in overrideConfigs){\n            ensureViewDef(viewType, hash, defaultConfigs, overrideConfigs);\n        }\n        return hash;\n    }\n    function ensureViewDef(viewType, hash, defaultConfigs, overrideConfigs) {\n        if (hash[viewType]) {\n            return hash[viewType];\n        }\n        let viewDef = buildViewDef(viewType, hash, defaultConfigs, overrideConfigs);\n        if (viewDef) {\n            hash[viewType] = viewDef;\n        }\n        return viewDef;\n    }\n    function buildViewDef(viewType, hash, defaultConfigs, overrideConfigs) {\n        let defaultConfig = defaultConfigs[viewType];\n        let overrideConfig = overrideConfigs[viewType];\n        let queryProp = (name)=>defaultConfig && defaultConfig[name] !== null ? defaultConfig[name] : overrideConfig && overrideConfig[name] !== null ? overrideConfig[name] : null;\n        let theComponent = queryProp('component');\n        let superType = queryProp('superType');\n        let superDef = null;\n        if (superType) {\n            if (superType === viewType) {\n                throw new Error('Can\\'t have a custom view type that references itself');\n            }\n            superDef = ensureViewDef(superType, hash, defaultConfigs, overrideConfigs);\n        }\n        if (!theComponent && superDef) {\n            theComponent = superDef.component;\n        }\n        if (!theComponent) {\n            return null; // don't throw a warning, might be settings for a single-unit view\n        }\n        return {\n            type: viewType,\n            component: theComponent,\n            defaults: Object.assign(Object.assign({}, superDef ? superDef.defaults : {}), defaultConfig ? defaultConfig.rawOptions : {}),\n            overrides: Object.assign(Object.assign({}, superDef ? superDef.overrides : {}), overrideConfig ? overrideConfig.rawOptions : {})\n        };\n    }\n    function parseViewConfigs(inputs) {\n        return mapHash(inputs, parseViewConfig);\n    }\n    function parseViewConfig(input) {\n        let rawOptions = typeof input === 'function' ? {\n            component: input\n        } : input;\n        let { component } = rawOptions;\n        if (rawOptions.content) {\n            // TODO: remove content/classNames/didMount/etc from options?\n            component = createViewHookComponent(rawOptions);\n        } else if (component && !(component.prototype instanceof BaseComponent)) {\n            // WHY?: people were using `component` property for `content`\n            // TODO: converge on one setting name\n            component = createViewHookComponent(Object.assign(Object.assign({}, rawOptions), {\n                content: component\n            }));\n        }\n        return {\n            superType: rawOptions.type,\n            component: component,\n            rawOptions\n        };\n    }\n    function createViewHookComponent(options) {\n        return (viewProps)=>y(ViewContextType.Consumer, null, (context)=>y(ContentContainer, {\n                    elTag: \"div\",\n                    elClasses: buildViewClassNames(context.viewSpec),\n                    renderProps: Object.assign(Object.assign({}, viewProps), {\n                        nextDayThreshold: context.options.nextDayThreshold\n                    }),\n                    generatorName: undefined,\n                    customGenerator: options.content,\n                    classNameGenerator: options.classNames,\n                    didMount: options.didMount,\n                    willUnmount: options.willUnmount\n                }));\n    }\n    function buildViewSpecs(defaultInputs, optionOverrides, dynamicOptionOverrides, localeDefaults) {\n        let defaultConfigs = parseViewConfigs(defaultInputs);\n        let overrideConfigs = parseViewConfigs(optionOverrides.views);\n        let viewDefs = compileViewDefs(defaultConfigs, overrideConfigs);\n        return mapHash(viewDefs, (viewDef)=>buildViewSpec(viewDef, overrideConfigs, optionOverrides, dynamicOptionOverrides, localeDefaults));\n    }\n    function buildViewSpec(viewDef, overrideConfigs, optionOverrides, dynamicOptionOverrides, localeDefaults) {\n        let durationInput = viewDef.overrides.duration || viewDef.defaults.duration || dynamicOptionOverrides.duration || optionOverrides.duration;\n        let duration = null;\n        let durationUnit = '';\n        let singleUnit = '';\n        let singleUnitOverrides = {};\n        if (durationInput) {\n            duration = createDurationCached(durationInput);\n            if (duration) {\n                let denom = greatestDurationDenominator(duration);\n                durationUnit = denom.unit;\n                if (denom.value === 1) {\n                    singleUnit = durationUnit;\n                    singleUnitOverrides = overrideConfigs[durationUnit] ? overrideConfigs[durationUnit].rawOptions : {};\n                }\n            }\n        }\n        let queryButtonText = (optionsSubset)=>{\n            let buttonTextMap = optionsSubset.buttonText || {};\n            let buttonTextKey = viewDef.defaults.buttonTextKey;\n            if (buttonTextKey != null && buttonTextMap[buttonTextKey] != null) {\n                return buttonTextMap[buttonTextKey];\n            }\n            if (buttonTextMap[viewDef.type] != null) {\n                return buttonTextMap[viewDef.type];\n            }\n            if (buttonTextMap[singleUnit] != null) {\n                return buttonTextMap[singleUnit];\n            }\n            return null;\n        };\n        let queryButtonTitle = (optionsSubset)=>{\n            let buttonHints = optionsSubset.buttonHints || {};\n            let buttonKey = viewDef.defaults.buttonTextKey; // use same key as text\n            if (buttonKey != null && buttonHints[buttonKey] != null) {\n                return buttonHints[buttonKey];\n            }\n            if (buttonHints[viewDef.type] != null) {\n                return buttonHints[viewDef.type];\n            }\n            if (buttonHints[singleUnit] != null) {\n                return buttonHints[singleUnit];\n            }\n            return null;\n        };\n        return {\n            type: viewDef.type,\n            component: viewDef.component,\n            duration,\n            durationUnit,\n            singleUnit,\n            optionDefaults: viewDef.defaults,\n            optionOverrides: Object.assign(Object.assign({}, singleUnitOverrides), viewDef.overrides),\n            buttonTextOverride: queryButtonText(dynamicOptionOverrides) || queryButtonText(optionOverrides) || // constructor-specified buttonText lookup hash takes precedence\n            viewDef.overrides.buttonText,\n            buttonTextDefault: queryButtonText(localeDefaults) || viewDef.defaults.buttonText || queryButtonText(BASE_OPTION_DEFAULTS) || viewDef.type,\n            // not DRY\n            buttonTitleOverride: queryButtonTitle(dynamicOptionOverrides) || queryButtonTitle(optionOverrides) || viewDef.overrides.buttonHint,\n            buttonTitleDefault: queryButtonTitle(localeDefaults) || viewDef.defaults.buttonHint || queryButtonTitle(BASE_OPTION_DEFAULTS)\n        };\n    }\n    // hack to get memoization working\n    let durationInputMap = {};\n    function createDurationCached(durationInput) {\n        let json = JSON.stringify(durationInput);\n        let res = durationInputMap[json];\n        if (res === undefined) {\n            res = createDuration(durationInput);\n            durationInputMap[json] = res;\n        }\n        return res;\n    }\n    function reduceViewType(viewType, action) {\n        switch(action.type){\n            case 'CHANGE_VIEW_TYPE':\n                viewType = action.viewType;\n        }\n        return viewType;\n    }\n    function reduceDynamicOptionOverrides(dynamicOptionOverrides, action) {\n        switch(action.type){\n            case 'SET_OPTION':\n                return Object.assign(Object.assign({}, dynamicOptionOverrides), {\n                    [action.optionName]: action.rawOptionValue\n                });\n            default:\n                return dynamicOptionOverrides;\n        }\n    }\n    function reduceDateProfile(currentDateProfile, action, currentDate, dateProfileGenerator) {\n        let dp;\n        switch(action.type){\n            case 'CHANGE_VIEW_TYPE':\n                return dateProfileGenerator.build(action.dateMarker || currentDate);\n            case 'CHANGE_DATE':\n                return dateProfileGenerator.build(action.dateMarker);\n            case 'PREV':\n                dp = dateProfileGenerator.buildPrev(currentDateProfile, currentDate);\n                if (dp.isValid) {\n                    return dp;\n                }\n                break;\n            case 'NEXT':\n                dp = dateProfileGenerator.buildNext(currentDateProfile, currentDate);\n                if (dp.isValid) {\n                    return dp;\n                }\n                break;\n        }\n        return currentDateProfile;\n    }\n    function initEventSources(calendarOptions, dateProfile, context) {\n        let activeRange = dateProfile ? dateProfile.activeRange : null;\n        return addSources({}, parseInitialSources(calendarOptions, context), activeRange, context);\n    }\n    function reduceEventSources(eventSources, action, dateProfile, context) {\n        let activeRange = dateProfile ? dateProfile.activeRange : null; // need this check?\n        switch(action.type){\n            case 'ADD_EVENT_SOURCES':\n                return addSources(eventSources, action.sources, activeRange, context);\n            case 'REMOVE_EVENT_SOURCE':\n                return removeSource(eventSources, action.sourceId);\n            case 'PREV':\n            case 'NEXT':\n            case 'CHANGE_DATE':\n            case 'CHANGE_VIEW_TYPE':\n                if (dateProfile) {\n                    return fetchDirtySources(eventSources, activeRange, context);\n                }\n                return eventSources;\n            case 'FETCH_EVENT_SOURCES':\n                return fetchSourcesByIds(eventSources, action.sourceIds ? arrayToHash(action.sourceIds) : excludeStaticSources(eventSources, context), activeRange, action.isRefetch || false, context);\n            case 'RECEIVE_EVENTS':\n            case 'RECEIVE_EVENT_ERROR':\n                return receiveResponse(eventSources, action.sourceId, action.fetchId, action.fetchRange);\n            case 'REMOVE_ALL_EVENT_SOURCES':\n                return {};\n            default:\n                return eventSources;\n        }\n    }\n    function reduceEventSourcesNewTimeZone(eventSources, dateProfile, context) {\n        let activeRange = dateProfile ? dateProfile.activeRange : null; // need this check?\n        return fetchSourcesByIds(eventSources, excludeStaticSources(eventSources, context), activeRange, true, context);\n    }\n    function computeEventSourcesLoading(eventSources) {\n        for(let sourceId in eventSources){\n            if (eventSources[sourceId].isFetching) {\n                return true;\n            }\n        }\n        return false;\n    }\n    function addSources(eventSourceHash, sources, fetchRange, context) {\n        let hash = {};\n        for (let source of sources){\n            hash[source.sourceId] = source;\n        }\n        if (fetchRange) {\n            hash = fetchDirtySources(hash, fetchRange, context);\n        }\n        return Object.assign(Object.assign({}, eventSourceHash), hash);\n    }\n    function removeSource(eventSourceHash, sourceId) {\n        return filterHash(eventSourceHash, (eventSource)=>eventSource.sourceId !== sourceId);\n    }\n    function fetchDirtySources(sourceHash, fetchRange, context) {\n        return fetchSourcesByIds(sourceHash, filterHash(sourceHash, (eventSource)=>isSourceDirty(eventSource, fetchRange, context)), fetchRange, false, context);\n    }\n    function isSourceDirty(eventSource, fetchRange, context) {\n        if (!doesSourceNeedRange(eventSource, context)) {\n            return !eventSource.latestFetchId;\n        }\n        return !context.options.lazyFetching || !eventSource.fetchRange || eventSource.isFetching || // always cancel outdated in-progress fetches\n        fetchRange.start < eventSource.fetchRange.start || fetchRange.end > eventSource.fetchRange.end;\n    }\n    function fetchSourcesByIds(prevSources, sourceIdHash, fetchRange, isRefetch, context) {\n        let nextSources = {};\n        for(let sourceId in prevSources){\n            let source = prevSources[sourceId];\n            if (sourceIdHash[sourceId]) {\n                nextSources[sourceId] = fetchSource(source, fetchRange, isRefetch, context);\n            } else {\n                nextSources[sourceId] = source;\n            }\n        }\n        return nextSources;\n    }\n    function fetchSource(eventSource, fetchRange, isRefetch, context) {\n        let { options, calendarApi } = context;\n        let sourceDef = context.pluginHooks.eventSourceDefs[eventSource.sourceDefId];\n        let fetchId = guid();\n        sourceDef.fetch({\n            eventSource,\n            range: fetchRange,\n            isRefetch,\n            context\n        }, (res)=>{\n            let { rawEvents } = res;\n            if (options.eventSourceSuccess) {\n                rawEvents = options.eventSourceSuccess.call(calendarApi, rawEvents, res.response) || rawEvents;\n            }\n            if (eventSource.success) {\n                rawEvents = eventSource.success.call(calendarApi, rawEvents, res.response) || rawEvents;\n            }\n            context.dispatch({\n                type: 'RECEIVE_EVENTS',\n                sourceId: eventSource.sourceId,\n                fetchId,\n                fetchRange,\n                rawEvents\n            });\n        }, (error)=>{\n            let errorHandled = false;\n            if (options.eventSourceFailure) {\n                options.eventSourceFailure.call(calendarApi, error);\n                errorHandled = true;\n            }\n            if (eventSource.failure) {\n                eventSource.failure(error);\n                errorHandled = true;\n            }\n            if (!errorHandled) {\n                console.warn(error.message, error);\n            }\n            context.dispatch({\n                type: 'RECEIVE_EVENT_ERROR',\n                sourceId: eventSource.sourceId,\n                fetchId,\n                fetchRange,\n                error\n            });\n        });\n        return Object.assign(Object.assign({}, eventSource), {\n            isFetching: true,\n            latestFetchId: fetchId\n        });\n    }\n    function receiveResponse(sourceHash, sourceId, fetchId, fetchRange) {\n        let eventSource = sourceHash[sourceId];\n        if (eventSource && // not already removed\n        fetchId === eventSource.latestFetchId) {\n            return Object.assign(Object.assign({}, sourceHash), {\n                [sourceId]: Object.assign(Object.assign({}, eventSource), {\n                    isFetching: false,\n                    fetchRange\n                })\n            });\n        }\n        return sourceHash;\n    }\n    function excludeStaticSources(eventSources, context) {\n        return filterHash(eventSources, (eventSource)=>doesSourceNeedRange(eventSource, context));\n    }\n    function parseInitialSources(rawOptions, context) {\n        let refiners = buildEventSourceRefiners(context);\n        let rawSources = [].concat(rawOptions.eventSources || []);\n        let sources = []; // parsed\n        if (rawOptions.initialEvents) {\n            rawSources.unshift(rawOptions.initialEvents);\n        }\n        if (rawOptions.events) {\n            rawSources.unshift(rawOptions.events);\n        }\n        for (let rawSource of rawSources){\n            let source = parseEventSource(rawSource, context, refiners);\n            if (source) {\n                sources.push(source);\n            }\n        }\n        return sources;\n    }\n    function doesSourceNeedRange(eventSource, context) {\n        let defs = context.pluginHooks.eventSourceDefs;\n        return !defs[eventSource.sourceDefId].ignoreRange;\n    }\n    function reduceDateSelection(currentSelection, action) {\n        switch(action.type){\n            case 'UNSELECT_DATES':\n                return null;\n            case 'SELECT_DATES':\n                return action.selection;\n            default:\n                return currentSelection;\n        }\n    }\n    function reduceSelectedEvent(currentInstanceId, action) {\n        switch(action.type){\n            case 'UNSELECT_EVENT':\n                return '';\n            case 'SELECT_EVENT':\n                return action.eventInstanceId;\n            default:\n                return currentInstanceId;\n        }\n    }\n    function reduceEventDrag(currentDrag, action) {\n        let newDrag;\n        switch(action.type){\n            case 'UNSET_EVENT_DRAG':\n                return null;\n            case 'SET_EVENT_DRAG':\n                newDrag = action.state;\n                return {\n                    affectedEvents: newDrag.affectedEvents,\n                    mutatedEvents: newDrag.mutatedEvents,\n                    isEvent: newDrag.isEvent\n                };\n            default:\n                return currentDrag;\n        }\n    }\n    function reduceEventResize(currentResize, action) {\n        let newResize;\n        switch(action.type){\n            case 'UNSET_EVENT_RESIZE':\n                return null;\n            case 'SET_EVENT_RESIZE':\n                newResize = action.state;\n                return {\n                    affectedEvents: newResize.affectedEvents,\n                    mutatedEvents: newResize.mutatedEvents,\n                    isEvent: newResize.isEvent\n                };\n            default:\n                return currentResize;\n        }\n    }\n    function parseToolbars(calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi) {\n        let header = calendarOptions.headerToolbar ? parseToolbar(calendarOptions.headerToolbar, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi) : null;\n        let footer = calendarOptions.footerToolbar ? parseToolbar(calendarOptions.footerToolbar, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi) : null;\n        return {\n            header,\n            footer\n        };\n    }\n    function parseToolbar(sectionStrHash, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi) {\n        let sectionWidgets = {};\n        let viewsWithButtons = [];\n        let hasTitle = false;\n        for(let sectionName in sectionStrHash){\n            let sectionStr = sectionStrHash[sectionName];\n            let sectionRes = parseSection(sectionStr, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi);\n            sectionWidgets[sectionName] = sectionRes.widgets;\n            viewsWithButtons.push(...sectionRes.viewsWithButtons);\n            hasTitle = hasTitle || sectionRes.hasTitle;\n        }\n        return {\n            sectionWidgets,\n            viewsWithButtons,\n            hasTitle\n        };\n    }\n    /*\r\n    BAD: querying icons and text here. should be done at render time\r\n    */ function parseSection(sectionStr, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi) {\n        let isRtl = calendarOptions.direction === 'rtl';\n        let calendarCustomButtons = calendarOptions.customButtons || {};\n        let calendarButtonTextOverrides = calendarOptionOverrides.buttonText || {};\n        let calendarButtonText = calendarOptions.buttonText || {};\n        let calendarButtonHintOverrides = calendarOptionOverrides.buttonHints || {};\n        let calendarButtonHints = calendarOptions.buttonHints || {};\n        let sectionSubstrs = sectionStr ? sectionStr.split(' ') : [];\n        let viewsWithButtons = [];\n        let hasTitle = false;\n        let widgets = sectionSubstrs.map((buttonGroupStr)=>buttonGroupStr.split(',').map((buttonName)=>{\n                if (buttonName === 'title') {\n                    hasTitle = true;\n                    return {\n                        buttonName\n                    };\n                }\n                let customButtonProps;\n                let viewSpec;\n                let buttonClick;\n                let buttonIcon; // only one of these will be set\n                let buttonText; // \"\n                let buttonHint;\n                // ^ for the title=\"\" attribute, for accessibility\n                if (customButtonProps = calendarCustomButtons[buttonName]) {\n                    buttonClick = (ev)=>{\n                        if (customButtonProps.click) {\n                            customButtonProps.click.call(ev.target, ev, ev.target); // TODO: use Calendar this context?\n                        }\n                    };\n                    (buttonIcon = theme.getCustomButtonIconClass(customButtonProps)) || (buttonIcon = theme.getIconClass(buttonName, isRtl)) || (buttonText = customButtonProps.text);\n                    buttonHint = customButtonProps.hint || customButtonProps.text;\n                } else if (viewSpec = viewSpecs[buttonName]) {\n                    viewsWithButtons.push(buttonName);\n                    buttonClick = ()=>{\n                        calendarApi.changeView(buttonName);\n                    };\n                    (buttonText = viewSpec.buttonTextOverride) || (buttonIcon = theme.getIconClass(buttonName, isRtl)) || (buttonText = viewSpec.buttonTextDefault);\n                    let textFallback = viewSpec.buttonTextOverride || viewSpec.buttonTextDefault;\n                    buttonHint = formatWithOrdinals(viewSpec.buttonTitleOverride || viewSpec.buttonTitleDefault || calendarOptions.viewHint, [\n                        textFallback,\n                        buttonName\n                    ], textFallback);\n                } else if (calendarApi[buttonName]) {\n                    buttonClick = ()=>{\n                        calendarApi[buttonName]();\n                    };\n                    (buttonText = calendarButtonTextOverrides[buttonName]) || (buttonIcon = theme.getIconClass(buttonName, isRtl)) || (buttonText = calendarButtonText[buttonName]); // everything else is considered default\n                    if (buttonName === 'prevYear' || buttonName === 'nextYear') {\n                        let prevOrNext = buttonName === 'prevYear' ? 'prev' : 'next';\n                        buttonHint = formatWithOrdinals(calendarButtonHintOverrides[prevOrNext] || calendarButtonHints[prevOrNext], [\n                            calendarButtonText.year || 'year',\n                            'year'\n                        ], calendarButtonText[buttonName]);\n                    } else {\n                        buttonHint = (navUnit)=>formatWithOrdinals(calendarButtonHintOverrides[buttonName] || calendarButtonHints[buttonName], [\n                                calendarButtonText[navUnit] || navUnit,\n                                navUnit\n                            ], calendarButtonText[buttonName]);\n                    }\n                }\n                return {\n                    buttonName,\n                    buttonClick,\n                    buttonIcon,\n                    buttonText,\n                    buttonHint\n                };\n            }));\n        return {\n            widgets,\n            viewsWithButtons,\n            hasTitle\n        };\n    }\n    // always represents the current view. otherwise, it'd need to change value every time date changes\n    class ViewImpl {\n        get calendar() {\n            return this.getCurrentData().calendarApi;\n        }\n        get title() {\n            return this.getCurrentData().viewTitle;\n        }\n        get activeStart() {\n            return this.dateEnv.toDate(this.getCurrentData().dateProfile.activeRange.start);\n        }\n        get activeEnd() {\n            return this.dateEnv.toDate(this.getCurrentData().dateProfile.activeRange.end);\n        }\n        get currentStart() {\n            return this.dateEnv.toDate(this.getCurrentData().dateProfile.currentRange.start);\n        }\n        get currentEnd() {\n            return this.dateEnv.toDate(this.getCurrentData().dateProfile.currentRange.end);\n        }\n        getOption(name) {\n            return this.getCurrentData().options[name]; // are the view-specific options\n        }\n        constructor(type, getCurrentData, dateEnv){\n            this.type = type;\n            this.getCurrentData = getCurrentData;\n            this.dateEnv = dateEnv;\n        }\n    }\n    let eventSourceDef$2 = {\n        ignoreRange: true,\n        parseMeta (refined) {\n            if (Array.isArray(refined.events)) {\n                return refined.events;\n            }\n            return null;\n        },\n        fetch (arg, successCallback) {\n            successCallback({\n                rawEvents: arg.eventSource.meta\n            });\n        }\n    };\n    const arrayEventSourcePlugin = createPlugin({\n        name: 'array-event-source',\n        eventSourceDefs: [\n            eventSourceDef$2\n        ]\n    });\n    let eventSourceDef$1 = {\n        parseMeta (refined) {\n            if (typeof refined.events === 'function') {\n                return refined.events;\n            }\n            return null;\n        },\n        fetch (arg, successCallback, errorCallback) {\n            const { dateEnv } = arg.context;\n            const func = arg.eventSource.meta;\n            unpromisify(func.bind(null, buildRangeApiWithTimeZone(arg.range, dateEnv)), (rawEvents)=>successCallback({\n                    rawEvents\n                }), errorCallback);\n        }\n    };\n    const funcEventSourcePlugin = createPlugin({\n        name: 'func-event-source',\n        eventSourceDefs: [\n            eventSourceDef$1\n        ]\n    });\n    const JSON_FEED_EVENT_SOURCE_REFINERS = {\n        method: String,\n        extraParams: identity,\n        startParam: String,\n        endParam: String,\n        timeZoneParam: String\n    };\n    let eventSourceDef = {\n        parseMeta (refined) {\n            if (refined.url && (refined.format === 'json' || !refined.format)) {\n                return {\n                    url: refined.url,\n                    format: 'json',\n                    method: (refined.method || 'GET').toUpperCase(),\n                    extraParams: refined.extraParams,\n                    startParam: refined.startParam,\n                    endParam: refined.endParam,\n                    timeZoneParam: refined.timeZoneParam\n                };\n            }\n            return null;\n        },\n        fetch (arg, successCallback, errorCallback) {\n            const { meta } = arg.eventSource;\n            const requestParams = buildRequestParams(meta, arg.range, arg.context);\n            requestJson(meta.method, meta.url, requestParams).then((param)=>{\n                let [rawEvents, response] = param;\n                successCallback({\n                    rawEvents,\n                    response\n                });\n            }, errorCallback);\n        }\n    };\n    const jsonFeedEventSourcePlugin = createPlugin({\n        name: 'json-event-source',\n        eventSourceRefiners: JSON_FEED_EVENT_SOURCE_REFINERS,\n        eventSourceDefs: [\n            eventSourceDef\n        ]\n    });\n    function buildRequestParams(meta, range, context) {\n        let { dateEnv, options } = context;\n        let startParam;\n        let endParam;\n        let timeZoneParam;\n        let customRequestParams;\n        let params = {};\n        startParam = meta.startParam;\n        if (startParam == null) {\n            startParam = options.startParam;\n        }\n        endParam = meta.endParam;\n        if (endParam == null) {\n            endParam = options.endParam;\n        }\n        timeZoneParam = meta.timeZoneParam;\n        if (timeZoneParam == null) {\n            timeZoneParam = options.timeZoneParam;\n        }\n        // retrieve any outbound GET/POST data from the options\n        if (typeof meta.extraParams === 'function') {\n            // supplied as a function that returns a key/value object\n            customRequestParams = meta.extraParams();\n        } else {\n            // probably supplied as a straight key/value object\n            customRequestParams = meta.extraParams || {};\n        }\n        Object.assign(params, customRequestParams);\n        params[startParam] = dateEnv.formatIso(range.start);\n        params[endParam] = dateEnv.formatIso(range.end);\n        if (dateEnv.timeZone !== 'local') {\n            params[timeZoneParam] = dateEnv.timeZone;\n        }\n        return params;\n    }\n    const SIMPLE_RECURRING_REFINERS = {\n        daysOfWeek: identity,\n        startTime: createDuration,\n        endTime: createDuration,\n        duration: createDuration,\n        startRecur: identity,\n        endRecur: identity\n    };\n    let recurring = {\n        parse (refined, dateEnv) {\n            if (refined.daysOfWeek || refined.startTime || refined.endTime || refined.startRecur || refined.endRecur) {\n                let recurringData = {\n                    daysOfWeek: refined.daysOfWeek || null,\n                    startTime: refined.startTime || null,\n                    endTime: refined.endTime || null,\n                    startRecur: refined.startRecur ? dateEnv.createMarker(refined.startRecur) : null,\n                    endRecur: refined.endRecur ? dateEnv.createMarker(refined.endRecur) : null\n                };\n                let duration;\n                if (refined.duration) {\n                    duration = refined.duration;\n                }\n                if (!duration && refined.startTime && refined.endTime) {\n                    duration = subtractDurations(refined.endTime, refined.startTime);\n                }\n                return {\n                    allDayGuess: Boolean(!refined.startTime && !refined.endTime),\n                    duration,\n                    typeData: recurringData\n                };\n            }\n            return null;\n        },\n        expand (typeData, framingRange, dateEnv) {\n            let clippedFramingRange = intersectRanges(framingRange, {\n                start: typeData.startRecur,\n                end: typeData.endRecur\n            });\n            if (clippedFramingRange) {\n                return expandRanges(typeData.daysOfWeek, typeData.startTime, clippedFramingRange, dateEnv);\n            }\n            return [];\n        }\n    };\n    const simpleRecurringEventsPlugin = createPlugin({\n        name: 'simple-recurring-event',\n        recurringTypes: [\n            recurring\n        ],\n        eventRefiners: SIMPLE_RECURRING_REFINERS\n    });\n    function expandRanges(daysOfWeek, startTime, framingRange, dateEnv) {\n        let dowHash = daysOfWeek ? arrayToHash(daysOfWeek) : null;\n        let dayMarker = startOfDay(framingRange.start);\n        let endMarker = framingRange.end;\n        let instanceStarts = [];\n        while(dayMarker < endMarker){\n            let instanceStart;\n            // if everyday, or this particular day-of-week\n            if (!dowHash || dowHash[dayMarker.getUTCDay()]) {\n                if (startTime) {\n                    instanceStart = dateEnv.add(dayMarker, startTime);\n                } else {\n                    instanceStart = dayMarker;\n                }\n                instanceStarts.push(instanceStart);\n            }\n            dayMarker = addDays(dayMarker, 1);\n        }\n        return instanceStarts;\n    }\n    const changeHandlerPlugin = createPlugin({\n        name: 'change-handler',\n        optionChangeHandlers: {\n            events (events, context) {\n                handleEventSources([\n                    events\n                ], context);\n            },\n            eventSources: handleEventSources\n        }\n    });\n    /*\r\n    BUG: if `event` was supplied, all previously-given `eventSources` will be wiped out\r\n    */ function handleEventSources(inputs, context) {\n        let unfoundSources = hashValuesToArray(context.getCurrentData().eventSources);\n        if (unfoundSources.length === 1 && inputs.length === 1 && Array.isArray(unfoundSources[0]._raw) && Array.isArray(inputs[0])) {\n            context.dispatch({\n                type: 'RESET_RAW_EVENTS',\n                sourceId: unfoundSources[0].sourceId,\n                rawEvents: inputs[0]\n            });\n            return;\n        }\n        let newInputs = [];\n        for (let input of inputs){\n            let inputFound = false;\n            for(let i = 0; i < unfoundSources.length; i += 1){\n                if (unfoundSources[i]._raw === input) {\n                    unfoundSources.splice(i, 1); // delete\n                    inputFound = true;\n                    break;\n                }\n            }\n            if (!inputFound) {\n                newInputs.push(input);\n            }\n        }\n        for (let unfoundSource of unfoundSources){\n            context.dispatch({\n                type: 'REMOVE_EVENT_SOURCE',\n                sourceId: unfoundSource.sourceId\n            });\n        }\n        for (let newInput of newInputs){\n            context.calendarApi.addEventSource(newInput);\n        }\n    }\n    function handleDateProfile(dateProfile, context) {\n        context.emitter.trigger('datesSet', Object.assign(Object.assign({}, buildRangeApiWithTimeZone(dateProfile.activeRange, context.dateEnv)), {\n            view: context.viewApi\n        }));\n    }\n    function handleEventStore(eventStore, context) {\n        let { emitter } = context;\n        if (emitter.hasHandlers('eventsSet')) {\n            emitter.trigger('eventsSet', buildEventApis(eventStore, context));\n        }\n    }\n    /*\r\n    this array is exposed on the root namespace so that UMD plugins can add to it.\r\n    see the rollup-bundles script.\r\n    */ const globalPlugins = [\n        arrayEventSourcePlugin,\n        funcEventSourcePlugin,\n        jsonFeedEventSourcePlugin,\n        simpleRecurringEventsPlugin,\n        changeHandlerPlugin,\n        createPlugin({\n            name: 'misc',\n            isLoadingFuncs: [\n                (state)=>computeEventSourcesLoading(state.eventSources)\n            ],\n            propSetHandlers: {\n                dateProfile: handleDateProfile,\n                eventStore: handleEventStore\n            }\n        })\n    ];\n    class TaskRunner {\n        request(task, delay) {\n            this.queue.push(task);\n            this.delayedRunner.request(delay);\n        }\n        pause(scope) {\n            this.delayedRunner.pause(scope);\n        }\n        resume(scope, force) {\n            this.delayedRunner.resume(scope, force);\n        }\n        drain() {\n            let { queue } = this;\n            while(queue.length){\n                let completedTasks = [];\n                let task;\n                while(task = queue.shift()){\n                    this.runTask(task);\n                    completedTasks.push(task);\n                }\n                this.drained(completedTasks);\n            } // keep going, in case new tasks were added in the drained handler\n        }\n        runTask(task) {\n            if (this.runTaskOption) {\n                this.runTaskOption(task);\n            }\n        }\n        drained(completedTasks) {\n            if (this.drainedOption) {\n                this.drainedOption(completedTasks);\n            }\n        }\n        constructor(runTaskOption, drainedOption){\n            this.runTaskOption = runTaskOption;\n            this.drainedOption = drainedOption;\n            this.queue = [];\n            this.delayedRunner = new DelayedRunner(this.drain.bind(this));\n        }\n    }\n    // Computes what the title at the top of the calendarApi should be for this view\n    function buildTitle(dateProfile, viewOptions, dateEnv) {\n        let range;\n        // for views that span a large unit of time, show the proper interval, ignoring stray days before and after\n        if (/^(year|month)$/.test(dateProfile.currentRangeUnit)) {\n            range = dateProfile.currentRange;\n        } else {\n            range = dateProfile.activeRange;\n        }\n        return dateEnv.formatRange(range.start, range.end, createFormatter(viewOptions.titleFormat || buildTitleFormat(dateProfile)), {\n            isEndExclusive: dateProfile.isRangeAllDay,\n            defaultSeparator: viewOptions.titleRangeSeparator\n        });\n    }\n    // Generates the format string that should be used to generate the title for the current date range.\n    // Attempts to compute the most appropriate format if not explicitly specified with `titleFormat`.\n    function buildTitleFormat(dateProfile) {\n        let { currentRangeUnit } = dateProfile;\n        if (currentRangeUnit === 'year') {\n            return {\n                year: 'numeric'\n            };\n        }\n        if (currentRangeUnit === 'month') {\n            return {\n                year: 'numeric',\n                month: 'long'\n            }; // like \"September 2014\"\n        }\n        let days = diffWholeDays(dateProfile.currentRange.start, dateProfile.currentRange.end);\n        if (days !== null && days > 1) {\n            // multi-day range. shorter, like \"Sep 9 - 10 2014\"\n            return {\n                year: 'numeric',\n                month: 'short',\n                day: 'numeric'\n            };\n        }\n        // one day. longer, like \"September 9 2014\"\n        return {\n            year: 'numeric',\n            month: 'long',\n            day: 'numeric'\n        };\n    }\n    // in future refactor, do the redux-style function(state=initial) for initial-state\n    // also, whatever is happening in constructor, have it happen in action queue too\n    class CalendarDataManager {\n        resetOptions(optionOverrides, changedOptionNames) {\n            let { props } = this;\n            if (changedOptionNames === undefined) {\n                props.optionOverrides = optionOverrides;\n            } else {\n                props.optionOverrides = Object.assign(Object.assign({}, props.optionOverrides || {}), optionOverrides);\n                this.optionsForRefining.push(...changedOptionNames);\n            }\n            if (changedOptionNames === undefined || changedOptionNames.length) {\n                this.actionRunner.request({\n                    type: 'NOTHING'\n                });\n            }\n        }\n        _handleAction(action) {\n            let { props, state, emitter } = this;\n            let dynamicOptionOverrides = reduceDynamicOptionOverrides(state.dynamicOptionOverrides, action);\n            let optionsData = this.computeOptionsData(props.optionOverrides, dynamicOptionOverrides, props.calendarApi);\n            let currentViewType = reduceViewType(state.currentViewType, action);\n            let currentViewData = this.computeCurrentViewData(currentViewType, optionsData, props.optionOverrides, dynamicOptionOverrides);\n            // wire things up\n            // TODO: not DRY\n            props.calendarApi.currentDataManager = this;\n            emitter.setThisContext(props.calendarApi);\n            emitter.setOptions(currentViewData.options);\n            let calendarContext = {\n                dateEnv: optionsData.dateEnv,\n                options: optionsData.calendarOptions,\n                pluginHooks: optionsData.pluginHooks,\n                calendarApi: props.calendarApi,\n                dispatch: this.dispatch,\n                emitter,\n                getCurrentData: this.getCurrentData\n            };\n            let { currentDate, dateProfile } = state;\n            if (this.data && this.data.dateProfileGenerator !== currentViewData.dateProfileGenerator) {\n                dateProfile = currentViewData.dateProfileGenerator.build(currentDate);\n            }\n            currentDate = reduceCurrentDate(currentDate, action);\n            dateProfile = reduceDateProfile(dateProfile, action, currentDate, currentViewData.dateProfileGenerator);\n            if (action.type === 'PREV' || // TODO: move this logic into DateProfileGenerator\n            action.type === 'NEXT' || // \"\n            !rangeContainsMarker(dateProfile.currentRange, currentDate)) {\n                currentDate = dateProfile.currentRange.start;\n            }\n            let eventSources = reduceEventSources(state.eventSources, action, dateProfile, calendarContext);\n            let eventStore = reduceEventStore(state.eventStore, action, eventSources, dateProfile, calendarContext);\n            let isEventsLoading = computeEventSourcesLoading(eventSources); // BAD. also called in this func in computeIsLoading\n            let renderableEventStore = isEventsLoading && !currentViewData.options.progressiveEventRendering ? state.renderableEventStore || eventStore : eventStore;\n            let { eventUiSingleBase, selectionConfig } = this.buildViewUiProps(calendarContext); // will memoize obj\n            let eventUiBySource = this.buildEventUiBySource(eventSources);\n            let eventUiBases = this.buildEventUiBases(renderableEventStore.defs, eventUiSingleBase, eventUiBySource);\n            let newState = {\n                dynamicOptionOverrides,\n                currentViewType,\n                currentDate,\n                dateProfile,\n                eventSources,\n                eventStore,\n                renderableEventStore,\n                selectionConfig,\n                eventUiBases,\n                businessHours: this.parseContextBusinessHours(calendarContext),\n                dateSelection: reduceDateSelection(state.dateSelection, action),\n                eventSelection: reduceSelectedEvent(state.eventSelection, action),\n                eventDrag: reduceEventDrag(state.eventDrag, action),\n                eventResize: reduceEventResize(state.eventResize, action)\n            };\n            let contextAndState = Object.assign(Object.assign({}, calendarContext), newState);\n            for (let reducer of optionsData.pluginHooks.reducers){\n                Object.assign(newState, reducer(state, action, contextAndState)); // give the OLD state, for old value\n            }\n            let wasLoading = computeIsLoading(state, calendarContext);\n            let isLoading = computeIsLoading(newState, calendarContext);\n            // TODO: use propSetHandlers in plugin system\n            if (!wasLoading && isLoading) {\n                emitter.trigger('loading', true);\n            } else if (wasLoading && !isLoading) {\n                emitter.trigger('loading', false);\n            }\n            this.state = newState;\n            if (props.onAction) {\n                props.onAction(action);\n            }\n        }\n        updateData() {\n            let { props, state } = this;\n            let oldData = this.data;\n            let optionsData = this.computeOptionsData(props.optionOverrides, state.dynamicOptionOverrides, props.calendarApi);\n            let currentViewData = this.computeCurrentViewData(state.currentViewType, optionsData, props.optionOverrides, state.dynamicOptionOverrides);\n            let data = this.data = Object.assign(Object.assign(Object.assign({\n                viewTitle: this.buildTitle(state.dateProfile, currentViewData.options, optionsData.dateEnv),\n                calendarApi: props.calendarApi,\n                dispatch: this.dispatch,\n                emitter: this.emitter,\n                getCurrentData: this.getCurrentData\n            }, optionsData), currentViewData), state);\n            let changeHandlers = optionsData.pluginHooks.optionChangeHandlers;\n            let oldCalendarOptions = oldData && oldData.calendarOptions;\n            let newCalendarOptions = optionsData.calendarOptions;\n            if (oldCalendarOptions && oldCalendarOptions !== newCalendarOptions) {\n                if (oldCalendarOptions.timeZone !== newCalendarOptions.timeZone) {\n                    // hack\n                    state.eventSources = data.eventSources = reduceEventSourcesNewTimeZone(data.eventSources, state.dateProfile, data);\n                    state.eventStore = data.eventStore = rezoneEventStoreDates(data.eventStore, oldData.dateEnv, data.dateEnv);\n                    state.renderableEventStore = data.renderableEventStore = rezoneEventStoreDates(data.renderableEventStore, oldData.dateEnv, data.dateEnv);\n                }\n                for(let optionName in changeHandlers){\n                    if (this.optionsForHandling.indexOf(optionName) !== -1 || oldCalendarOptions[optionName] !== newCalendarOptions[optionName]) {\n                        changeHandlers[optionName](newCalendarOptions[optionName], data);\n                    }\n                }\n            }\n            this.optionsForHandling = [];\n            if (props.onData) {\n                props.onData(data);\n            }\n        }\n        computeOptionsData(optionOverrides, dynamicOptionOverrides, calendarApi) {\n            // TODO: blacklist options that are handled by optionChangeHandlers\n            if (!this.optionsForRefining.length && optionOverrides === this.stableOptionOverrides && dynamicOptionOverrides === this.stableDynamicOptionOverrides) {\n                return this.stableCalendarOptionsData;\n            }\n            let { refinedOptions, pluginHooks, localeDefaults, availableLocaleData, extra } = this.processRawCalendarOptions(optionOverrides, dynamicOptionOverrides);\n            warnUnknownOptions(extra);\n            let dateEnv = this.buildDateEnv(refinedOptions.timeZone, refinedOptions.locale, refinedOptions.weekNumberCalculation, refinedOptions.firstDay, refinedOptions.weekText, pluginHooks, availableLocaleData, refinedOptions.defaultRangeSeparator);\n            let viewSpecs = this.buildViewSpecs(pluginHooks.views, this.stableOptionOverrides, this.stableDynamicOptionOverrides, localeDefaults);\n            let theme = this.buildTheme(refinedOptions, pluginHooks);\n            let toolbarConfig = this.parseToolbars(refinedOptions, this.stableOptionOverrides, theme, viewSpecs, calendarApi);\n            return this.stableCalendarOptionsData = {\n                calendarOptions: refinedOptions,\n                pluginHooks,\n                dateEnv,\n                viewSpecs,\n                theme,\n                toolbarConfig,\n                localeDefaults,\n                availableRawLocales: availableLocaleData.map\n            };\n        }\n        // always called from behind a memoizer\n        processRawCalendarOptions(optionOverrides, dynamicOptionOverrides) {\n            let { locales, locale } = mergeRawOptions([\n                BASE_OPTION_DEFAULTS,\n                optionOverrides,\n                dynamicOptionOverrides\n            ]);\n            let availableLocaleData = this.organizeRawLocales(locales);\n            let availableRawLocales = availableLocaleData.map;\n            let localeDefaults = this.buildLocale(locale || availableLocaleData.defaultCode, availableRawLocales).options;\n            let pluginHooks = this.buildPluginHooks(optionOverrides.plugins || [], globalPlugins);\n            let refiners = this.currentCalendarOptionsRefiners = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, BASE_OPTION_REFINERS), CALENDAR_LISTENER_REFINERS), CALENDAR_OPTION_REFINERS), pluginHooks.listenerRefiners), pluginHooks.optionRefiners);\n            let extra = {};\n            let raw = mergeRawOptions([\n                BASE_OPTION_DEFAULTS,\n                localeDefaults,\n                optionOverrides,\n                dynamicOptionOverrides\n            ]);\n            let refined = {};\n            let currentRaw = this.currentCalendarOptionsInput;\n            let currentRefined = this.currentCalendarOptionsRefined;\n            let anyChanges = false;\n            for(let optionName in raw){\n                if (this.optionsForRefining.indexOf(optionName) === -1 && (raw[optionName] === currentRaw[optionName] || COMPLEX_OPTION_COMPARATORS[optionName] && optionName in currentRaw && COMPLEX_OPTION_COMPARATORS[optionName](currentRaw[optionName], raw[optionName]))) {\n                    refined[optionName] = currentRefined[optionName];\n                } else if (refiners[optionName]) {\n                    refined[optionName] = refiners[optionName](raw[optionName]);\n                    anyChanges = true;\n                } else {\n                    extra[optionName] = currentRaw[optionName];\n                }\n            }\n            if (anyChanges) {\n                this.currentCalendarOptionsInput = raw;\n                this.currentCalendarOptionsRefined = refined;\n                this.stableOptionOverrides = optionOverrides;\n                this.stableDynamicOptionOverrides = dynamicOptionOverrides;\n            }\n            this.optionsForHandling.push(...this.optionsForRefining);\n            this.optionsForRefining = [];\n            return {\n                rawOptions: this.currentCalendarOptionsInput,\n                refinedOptions: this.currentCalendarOptionsRefined,\n                pluginHooks,\n                availableLocaleData,\n                localeDefaults,\n                extra\n            };\n        }\n        _computeCurrentViewData(viewType, optionsData, optionOverrides, dynamicOptionOverrides) {\n            let viewSpec = optionsData.viewSpecs[viewType];\n            if (!viewSpec) {\n                throw new Error('viewType \"'.concat(viewType, \"\\\" is not available. Please make sure you've loaded all neccessary plugins\"));\n            }\n            let { refinedOptions, extra } = this.processRawViewOptions(viewSpec, optionsData.pluginHooks, optionsData.localeDefaults, optionOverrides, dynamicOptionOverrides);\n            warnUnknownOptions(extra);\n            let dateProfileGenerator = this.buildDateProfileGenerator({\n                dateProfileGeneratorClass: viewSpec.optionDefaults.dateProfileGeneratorClass,\n                duration: viewSpec.duration,\n                durationUnit: viewSpec.durationUnit,\n                usesMinMaxTime: viewSpec.optionDefaults.usesMinMaxTime,\n                dateEnv: optionsData.dateEnv,\n                calendarApi: this.props.calendarApi,\n                slotMinTime: refinedOptions.slotMinTime,\n                slotMaxTime: refinedOptions.slotMaxTime,\n                showNonCurrentDates: refinedOptions.showNonCurrentDates,\n                dayCount: refinedOptions.dayCount,\n                dateAlignment: refinedOptions.dateAlignment,\n                dateIncrement: refinedOptions.dateIncrement,\n                hiddenDays: refinedOptions.hiddenDays,\n                weekends: refinedOptions.weekends,\n                nowInput: refinedOptions.now,\n                validRangeInput: refinedOptions.validRange,\n                visibleRangeInput: refinedOptions.visibleRange,\n                fixedWeekCount: refinedOptions.fixedWeekCount\n            });\n            let viewApi = this.buildViewApi(viewType, this.getCurrentData, optionsData.dateEnv);\n            return {\n                viewSpec,\n                options: refinedOptions,\n                dateProfileGenerator,\n                viewApi\n            };\n        }\n        processRawViewOptions(viewSpec, pluginHooks, localeDefaults, optionOverrides, dynamicOptionOverrides) {\n            let raw = mergeRawOptions([\n                BASE_OPTION_DEFAULTS,\n                viewSpec.optionDefaults,\n                localeDefaults,\n                optionOverrides,\n                viewSpec.optionOverrides,\n                dynamicOptionOverrides\n            ]);\n            let refiners = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, BASE_OPTION_REFINERS), CALENDAR_LISTENER_REFINERS), CALENDAR_OPTION_REFINERS), VIEW_OPTION_REFINERS), pluginHooks.listenerRefiners), pluginHooks.optionRefiners);\n            let refined = {};\n            let currentRaw = this.currentViewOptionsInput;\n            let currentRefined = this.currentViewOptionsRefined;\n            let anyChanges = false;\n            let extra = {};\n            for(let optionName in raw){\n                if (raw[optionName] === currentRaw[optionName] || COMPLEX_OPTION_COMPARATORS[optionName] && COMPLEX_OPTION_COMPARATORS[optionName](raw[optionName], currentRaw[optionName])) {\n                    refined[optionName] = currentRefined[optionName];\n                } else {\n                    if (raw[optionName] === this.currentCalendarOptionsInput[optionName] || COMPLEX_OPTION_COMPARATORS[optionName] && COMPLEX_OPTION_COMPARATORS[optionName](raw[optionName], this.currentCalendarOptionsInput[optionName])) {\n                        if (optionName in this.currentCalendarOptionsRefined) {\n                            refined[optionName] = this.currentCalendarOptionsRefined[optionName];\n                        }\n                    } else if (refiners[optionName]) {\n                        refined[optionName] = refiners[optionName](raw[optionName]);\n                    } else {\n                        extra[optionName] = raw[optionName];\n                    }\n                    anyChanges = true;\n                }\n            }\n            if (anyChanges) {\n                this.currentViewOptionsInput = raw;\n                this.currentViewOptionsRefined = refined;\n            }\n            return {\n                rawOptions: this.currentViewOptionsInput,\n                refinedOptions: this.currentViewOptionsRefined,\n                extra\n            };\n        }\n        constructor(props){\n            this.computeCurrentViewData = memoize(this._computeCurrentViewData);\n            this.organizeRawLocales = memoize(organizeRawLocales);\n            this.buildLocale = memoize(buildLocale);\n            this.buildPluginHooks = buildBuildPluginHooks();\n            this.buildDateEnv = memoize(buildDateEnv$1);\n            this.buildTheme = memoize(buildTheme);\n            this.parseToolbars = memoize(parseToolbars);\n            this.buildViewSpecs = memoize(buildViewSpecs);\n            this.buildDateProfileGenerator = memoizeObjArg(buildDateProfileGenerator);\n            this.buildViewApi = memoize(buildViewApi);\n            this.buildViewUiProps = memoizeObjArg(buildViewUiProps);\n            this.buildEventUiBySource = memoize(buildEventUiBySource, isPropsEqual);\n            this.buildEventUiBases = memoize(buildEventUiBases);\n            this.parseContextBusinessHours = memoizeObjArg(parseContextBusinessHours);\n            this.buildTitle = memoize(buildTitle);\n            this.emitter = new Emitter();\n            this.actionRunner = new TaskRunner(this._handleAction.bind(this), this.updateData.bind(this));\n            this.currentCalendarOptionsInput = {};\n            this.currentCalendarOptionsRefined = {};\n            this.currentViewOptionsInput = {};\n            this.currentViewOptionsRefined = {};\n            this.currentCalendarOptionsRefiners = {};\n            this.optionsForRefining = [];\n            this.optionsForHandling = [];\n            this.getCurrentData = ()=>this.data;\n            this.dispatch = (action)=>{\n                this.actionRunner.request(action); // protects against recursive calls to _handleAction\n            };\n            this.props = props;\n            this.actionRunner.pause();\n            let dynamicOptionOverrides = {};\n            let optionsData = this.computeOptionsData(props.optionOverrides, dynamicOptionOverrides, props.calendarApi);\n            let currentViewType = optionsData.calendarOptions.initialView || optionsData.pluginHooks.initialView;\n            let currentViewData = this.computeCurrentViewData(currentViewType, optionsData, props.optionOverrides, dynamicOptionOverrides);\n            // wire things up\n            // TODO: not DRY\n            props.calendarApi.currentDataManager = this;\n            this.emitter.setThisContext(props.calendarApi);\n            this.emitter.setOptions(currentViewData.options);\n            let currentDate = getInitialDate(optionsData.calendarOptions, optionsData.dateEnv);\n            let dateProfile = currentViewData.dateProfileGenerator.build(currentDate);\n            if (!rangeContainsMarker(dateProfile.activeRange, currentDate)) {\n                currentDate = dateProfile.currentRange.start;\n            }\n            let calendarContext = {\n                dateEnv: optionsData.dateEnv,\n                options: optionsData.calendarOptions,\n                pluginHooks: optionsData.pluginHooks,\n                calendarApi: props.calendarApi,\n                dispatch: this.dispatch,\n                emitter: this.emitter,\n                getCurrentData: this.getCurrentData\n            };\n            // needs to be after setThisContext\n            for (let callback of optionsData.pluginHooks.contextInit){\n                callback(calendarContext);\n            }\n            // NOT DRY\n            let eventSources = initEventSources(optionsData.calendarOptions, dateProfile, calendarContext);\n            let initialState = {\n                dynamicOptionOverrides,\n                currentViewType,\n                currentDate,\n                dateProfile,\n                businessHours: this.parseContextBusinessHours(calendarContext),\n                eventSources,\n                eventUiBases: {},\n                eventStore: createEmptyEventStore(),\n                renderableEventStore: createEmptyEventStore(),\n                dateSelection: null,\n                eventSelection: '',\n                eventDrag: null,\n                eventResize: null,\n                selectionConfig: this.buildViewUiProps(calendarContext).selectionConfig\n            };\n            let contextAndState = Object.assign(Object.assign({}, calendarContext), initialState);\n            for (let reducer of optionsData.pluginHooks.reducers){\n                Object.assign(initialState, reducer(null, null, contextAndState));\n            }\n            if (computeIsLoading(initialState, calendarContext)) {\n                this.emitter.trigger('loading', true); // NOT DRY\n            }\n            this.state = initialState;\n            this.updateData();\n            this.actionRunner.resume();\n        }\n    }\n    function buildDateEnv$1(timeZone, explicitLocale, weekNumberCalculation, firstDay, weekText, pluginHooks, availableLocaleData, defaultSeparator) {\n        let locale = buildLocale(explicitLocale || availableLocaleData.defaultCode, availableLocaleData.map);\n        return new DateEnv({\n            calendarSystem: 'gregory',\n            timeZone,\n            namedTimeZoneImpl: pluginHooks.namedTimeZonedImpl,\n            locale,\n            weekNumberCalculation,\n            firstDay,\n            weekText,\n            cmdFormatter: pluginHooks.cmdFormatter,\n            defaultSeparator\n        });\n    }\n    function buildTheme(options, pluginHooks) {\n        let ThemeClass = pluginHooks.themeClasses[options.themeSystem] || StandardTheme;\n        return new ThemeClass(options);\n    }\n    function buildDateProfileGenerator(props) {\n        let DateProfileGeneratorClass = props.dateProfileGeneratorClass || DateProfileGenerator;\n        return new DateProfileGeneratorClass(props);\n    }\n    function buildViewApi(type, getCurrentData, dateEnv) {\n        return new ViewImpl(type, getCurrentData, dateEnv);\n    }\n    function buildEventUiBySource(eventSources) {\n        return mapHash(eventSources, (eventSource)=>eventSource.ui);\n    }\n    function buildEventUiBases(eventDefs, eventUiSingleBase, eventUiBySource) {\n        let eventUiBases = {\n            '': eventUiSingleBase\n        };\n        for(let defId in eventDefs){\n            let def = eventDefs[defId];\n            if (def.sourceId && eventUiBySource[def.sourceId]) {\n                eventUiBases[defId] = eventUiBySource[def.sourceId];\n            }\n        }\n        return eventUiBases;\n    }\n    function buildViewUiProps(calendarContext) {\n        let { options } = calendarContext;\n        return {\n            eventUiSingleBase: createEventUi({\n                display: options.eventDisplay,\n                editable: options.editable,\n                startEditable: options.eventStartEditable,\n                durationEditable: options.eventDurationEditable,\n                constraint: options.eventConstraint,\n                overlap: typeof options.eventOverlap === 'boolean' ? options.eventOverlap : undefined,\n                allow: options.eventAllow,\n                backgroundColor: options.eventBackgroundColor,\n                borderColor: options.eventBorderColor,\n                textColor: options.eventTextColor,\n                color: options.eventColor\n            }, calendarContext),\n            selectionConfig: createEventUi({\n                constraint: options.selectConstraint,\n                overlap: typeof options.selectOverlap === 'boolean' ? options.selectOverlap : undefined,\n                allow: options.selectAllow\n            }, calendarContext)\n        };\n    }\n    function computeIsLoading(state, context) {\n        for (let isLoadingFunc of context.pluginHooks.isLoadingFuncs){\n            if (isLoadingFunc(state)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    function parseContextBusinessHours(calendarContext) {\n        return parseBusinessHours(calendarContext.options.businessHours, calendarContext);\n    }\n    function warnUnknownOptions(options, viewName) {\n        for(let optionName in options){\n            console.warn(\"Unknown option '\".concat(optionName, \"'\") + (viewName ? \" for view '\".concat(viewName, \"'\") : ''));\n        }\n    }\n    class ToolbarSection extends BaseComponent {\n        render() {\n            let children = this.props.widgetGroups.map((widgetGroup)=>this.renderWidgetGroup(widgetGroup));\n            return y('div', {\n                className: 'fc-toolbar-chunk'\n            }, ...children);\n        }\n        renderWidgetGroup(widgetGroup) {\n            let { props } = this;\n            let { theme } = this.context;\n            let children = [];\n            let isOnlyButtons = true;\n            for (let widget of widgetGroup){\n                let { buttonName, buttonClick, buttonText, buttonIcon, buttonHint } = widget;\n                if (buttonName === 'title') {\n                    isOnlyButtons = false;\n                    children.push(y(\"h2\", {\n                        className: \"fc-toolbar-title\",\n                        id: props.titleId\n                    }, props.title));\n                } else {\n                    let isPressed = buttonName === props.activeButton;\n                    let isDisabled = !props.isTodayEnabled && buttonName === 'today' || !props.isPrevEnabled && buttonName === 'prev' || !props.isNextEnabled && buttonName === 'next';\n                    let buttonClasses = [\n                        \"fc-\".concat(buttonName, \"-button\"),\n                        theme.getClass('button')\n                    ];\n                    if (isPressed) {\n                        buttonClasses.push(theme.getClass('buttonActive'));\n                    }\n                    children.push(y(\"button\", {\n                        type: \"button\",\n                        title: typeof buttonHint === 'function' ? buttonHint(props.navUnit) : buttonHint,\n                        disabled: isDisabled,\n                        \"aria-pressed\": isPressed,\n                        className: buttonClasses.join(' '),\n                        onClick: buttonClick\n                    }, buttonText || (buttonIcon ? y(\"span\", {\n                        className: buttonIcon\n                    }) : '')));\n                }\n            }\n            if (children.length > 1) {\n                let groupClassName = isOnlyButtons && theme.getClass('buttonGroup') || '';\n                return y('div', {\n                    className: groupClassName\n                }, ...children);\n            }\n            return children[0];\n        }\n    }\n    class Toolbar extends BaseComponent {\n        render() {\n            let { model, extraClassName } = this.props;\n            let forceLtr = false;\n            let startContent;\n            let endContent;\n            let sectionWidgets = model.sectionWidgets;\n            let centerContent = sectionWidgets.center;\n            if (sectionWidgets.left) {\n                forceLtr = true;\n                startContent = sectionWidgets.left;\n            } else {\n                startContent = sectionWidgets.start;\n            }\n            if (sectionWidgets.right) {\n                forceLtr = true;\n                endContent = sectionWidgets.right;\n            } else {\n                endContent = sectionWidgets.end;\n            }\n            let classNames = [\n                extraClassName || '',\n                'fc-toolbar',\n                forceLtr ? 'fc-toolbar-ltr' : ''\n            ];\n            return y(\"div\", {\n                className: classNames.join(' ')\n            }, this.renderSection('start', startContent || []), this.renderSection('center', centerContent || []), this.renderSection('end', endContent || []));\n        }\n        renderSection(key, widgetGroups) {\n            let { props } = this;\n            return y(ToolbarSection, {\n                key: key,\n                widgetGroups: widgetGroups,\n                title: props.title,\n                navUnit: props.navUnit,\n                activeButton: props.activeButton,\n                isTodayEnabled: props.isTodayEnabled,\n                isPrevEnabled: props.isPrevEnabled,\n                isNextEnabled: props.isNextEnabled,\n                titleId: props.titleId\n            });\n        }\n    }\n    class ViewHarness extends BaseComponent {\n        render() {\n            let { props, state } = this;\n            let { aspectRatio } = props;\n            let classNames = [\n                'fc-view-harness',\n                aspectRatio || props.liquid || props.height ? 'fc-view-harness-active' // harness controls the height\n                 : 'fc-view-harness-passive'\n            ];\n            let height = '';\n            let paddingBottom = '';\n            if (aspectRatio) {\n                if (state.availableWidth !== null) {\n                    height = state.availableWidth / aspectRatio;\n                } else {\n                    // while waiting to know availableWidth, we can't set height to *zero*\n                    // because will cause lots of unnecessary scrollbars within scrollgrid.\n                    // BETTER: don't start rendering ANYTHING yet until we know container width\n                    // NOTE: why not always use paddingBottom? Causes height oscillation (issue 5606)\n                    paddingBottom = \"\".concat(1 / aspectRatio * 100, \"%\");\n                }\n            } else {\n                height = props.height || '';\n            }\n            return y(\"div\", {\n                \"aria-labelledby\": props.labeledById,\n                ref: this.handleEl,\n                className: classNames.join(' '),\n                style: {\n                    height,\n                    paddingBottom\n                }\n            }, props.children);\n        }\n        componentDidMount() {\n            this.context.addResizeHandler(this.handleResize);\n        }\n        componentWillUnmount() {\n            this.context.removeResizeHandler(this.handleResize);\n        }\n        updateAvailableWidth() {\n            if (this.el && // needed. but why?\n            this.props.aspectRatio // aspectRatio is the only height setting that needs availableWidth\n            ) {\n                this.setState({\n                    availableWidth: this.el.offsetWidth\n                });\n            }\n        }\n        constructor(){\n            super(...arguments);\n            this.state = {\n                availableWidth: null\n            };\n            this.handleEl = (el)=>{\n                this.el = el;\n                setRef(this.props.elRef, el);\n                this.updateAvailableWidth();\n            };\n            this.handleResize = ()=>{\n                this.updateAvailableWidth();\n            };\n        }\n    }\n    /*\r\n    Detects when the user clicks on an event within a DateComponent\r\n    */ class EventClicking extends Interaction {\n        constructor(settings){\n            super(settings);\n            this.handleSegClick = (ev, segEl)=>{\n                let { component } = this;\n                let { context } = component;\n                let seg = getElSeg(segEl);\n                if (seg && // might be the <div> surrounding the more link\n                component.isValidSegDownEl(ev.target)) {\n                    // our way to simulate a link click for elements that can't be <a> tags\n                    // grab before trigger fired in case trigger trashes DOM thru rerendering\n                    let hasUrlContainer = elementClosest(ev.target, '.fc-event-forced-url');\n                    let url = hasUrlContainer ? hasUrlContainer.querySelector('a[href]').href : '';\n                    context.emitter.trigger('eventClick', {\n                        el: segEl,\n                        event: new EventImpl(component.context, seg.eventRange.def, seg.eventRange.instance),\n                        jsEvent: ev,\n                        view: context.viewApi\n                    });\n                    if (url && !ev.defaultPrevented) {\n                        window.location.href = url;\n                    }\n                }\n            };\n            this.destroy = listenBySelector(settings.el, 'click', '.fc-event', this.handleSegClick);\n        }\n    }\n    /*\r\n    Triggers events and adds/removes core classNames when the user's pointer\r\n    enters/leaves event-elements of a component.\r\n    */ class EventHovering extends Interaction {\n        destroy() {\n            this.removeHoverListeners();\n        }\n        triggerEvent(publicEvName, ev, segEl) {\n            let { component } = this;\n            let { context } = component;\n            let seg = getElSeg(segEl);\n            if (!ev || component.isValidSegDownEl(ev.target)) {\n                context.emitter.trigger(publicEvName, {\n                    el: segEl,\n                    event: new EventImpl(context, seg.eventRange.def, seg.eventRange.instance),\n                    jsEvent: ev,\n                    view: context.viewApi\n                });\n            }\n        }\n        constructor(settings){\n            super(settings);\n            // for simulating an eventMouseLeave when the event el is destroyed while mouse is over it\n            this.handleEventElRemove = (el)=>{\n                if (el === this.currentSegEl) {\n                    this.handleSegLeave(null, this.currentSegEl);\n                }\n            };\n            this.handleSegEnter = (ev, segEl)=>{\n                if (getElSeg(segEl)) {\n                    this.currentSegEl = segEl;\n                    this.triggerEvent('eventMouseEnter', ev, segEl);\n                }\n            };\n            this.handleSegLeave = (ev, segEl)=>{\n                if (this.currentSegEl) {\n                    this.currentSegEl = null;\n                    this.triggerEvent('eventMouseLeave', ev, segEl);\n                }\n            };\n            this.removeHoverListeners = listenToHoverBySelector(settings.el, '.fc-event', this.handleSegEnter, this.handleSegLeave);\n        }\n    }\n    class CalendarContent extends PureComponent {\n        /*\r\n        renders INSIDE of an outer div\r\n        */ render() {\n            let { props } = this;\n            let { toolbarConfig, options } = props;\n            let toolbarProps = this.buildToolbarProps(props.viewSpec, props.dateProfile, props.dateProfileGenerator, props.currentDate, getNow(props.options.now, props.dateEnv), props.viewTitle);\n            let viewVGrow = false;\n            let viewHeight = '';\n            let viewAspectRatio;\n            if (props.isHeightAuto || props.forPrint) {\n                viewHeight = '';\n            } else if (options.height != null) {\n                viewVGrow = true;\n            } else if (options.contentHeight != null) {\n                viewHeight = options.contentHeight;\n            } else {\n                viewAspectRatio = Math.max(options.aspectRatio, 0.5); // prevent from getting too tall\n            }\n            let viewContext = this.buildViewContext(props.viewSpec, props.viewApi, props.options, props.dateProfileGenerator, props.dateEnv, props.theme, props.pluginHooks, props.dispatch, props.getCurrentData, props.emitter, props.calendarApi, this.registerInteractiveComponent, this.unregisterInteractiveComponent);\n            let viewLabelId = toolbarConfig.header && toolbarConfig.header.hasTitle ? this.state.viewLabelId : '';\n            return y(ViewContextType.Provider, {\n                value: viewContext\n            }, toolbarConfig.header && y(Toolbar, Object.assign({\n                ref: this.headerRef,\n                extraClassName: \"fc-header-toolbar\",\n                model: toolbarConfig.header,\n                titleId: viewLabelId\n            }, toolbarProps)), y(ViewHarness, {\n                liquid: viewVGrow,\n                height: viewHeight,\n                aspectRatio: viewAspectRatio,\n                labeledById: viewLabelId\n            }, this.renderView(props), this.buildAppendContent()), toolbarConfig.footer && y(Toolbar, Object.assign({\n                ref: this.footerRef,\n                extraClassName: \"fc-footer-toolbar\",\n                model: toolbarConfig.footer,\n                titleId: \"\"\n            }, toolbarProps)));\n        }\n        componentDidMount() {\n            let { props } = this;\n            this.calendarInteractions = props.pluginHooks.calendarInteractions.map((CalendarInteractionClass)=>new CalendarInteractionClass(props));\n            window.addEventListener('resize', this.handleWindowResize);\n            let { propSetHandlers } = props.pluginHooks;\n            for(let propName in propSetHandlers){\n                propSetHandlers[propName](props[propName], props);\n            }\n        }\n        componentDidUpdate(prevProps) {\n            let { props } = this;\n            let { propSetHandlers } = props.pluginHooks;\n            for(let propName in propSetHandlers){\n                if (props[propName] !== prevProps[propName]) {\n                    propSetHandlers[propName](props[propName], props);\n                }\n            }\n        }\n        componentWillUnmount() {\n            window.removeEventListener('resize', this.handleWindowResize);\n            this.resizeRunner.clear();\n            for (let interaction of this.calendarInteractions){\n                interaction.destroy();\n            }\n            this.props.emitter.trigger('_unmount');\n        }\n        buildAppendContent() {\n            let { props } = this;\n            let children = props.pluginHooks.viewContainerAppends.map((buildAppendContent)=>buildAppendContent(props));\n            return y(_, {}, ...children);\n        }\n        renderView(props) {\n            let { pluginHooks } = props;\n            let { viewSpec } = props;\n            let viewProps = {\n                dateProfile: props.dateProfile,\n                businessHours: props.businessHours,\n                eventStore: props.renderableEventStore,\n                eventUiBases: props.eventUiBases,\n                dateSelection: props.dateSelection,\n                eventSelection: props.eventSelection,\n                eventDrag: props.eventDrag,\n                eventResize: props.eventResize,\n                isHeightAuto: props.isHeightAuto,\n                forPrint: props.forPrint\n            };\n            let transformers = this.buildViewPropTransformers(pluginHooks.viewPropsTransformers);\n            for (let transformer of transformers){\n                Object.assign(viewProps, transformer.transform(viewProps, props));\n            }\n            let ViewComponent = viewSpec.component;\n            return y(ViewComponent, Object.assign({}, viewProps));\n        }\n        constructor(){\n            super(...arguments);\n            this.buildViewContext = memoize(buildViewContext);\n            this.buildViewPropTransformers = memoize(buildViewPropTransformers);\n            this.buildToolbarProps = memoize(buildToolbarProps);\n            this.headerRef = d();\n            this.footerRef = d();\n            this.interactionsStore = {};\n            // eslint-disable-next-line\n            this.state = {\n                viewLabelId: getUniqueDomId()\n            };\n            // Component Registration\n            // -----------------------------------------------------------------------------------------------------------------\n            this.registerInteractiveComponent = (component, settingsInput)=>{\n                let settings = parseInteractionSettings(component, settingsInput);\n                let DEFAULT_INTERACTIONS = [\n                    EventClicking,\n                    EventHovering\n                ];\n                let interactionClasses = DEFAULT_INTERACTIONS.concat(this.props.pluginHooks.componentInteractions);\n                let interactions = interactionClasses.map((TheInteractionClass)=>new TheInteractionClass(settings));\n                this.interactionsStore[component.uid] = interactions;\n                interactionSettingsStore[component.uid] = settings;\n            };\n            this.unregisterInteractiveComponent = (component)=>{\n                let listeners = this.interactionsStore[component.uid];\n                if (listeners) {\n                    for (let listener of listeners){\n                        listener.destroy();\n                    }\n                    delete this.interactionsStore[component.uid];\n                }\n                delete interactionSettingsStore[component.uid];\n            };\n            // Resizing\n            // -----------------------------------------------------------------------------------------------------------------\n            this.resizeRunner = new DelayedRunner(()=>{\n                this.props.emitter.trigger('_resize', true); // should window resizes be considered \"forced\" ?\n                this.props.emitter.trigger('windowResize', {\n                    view: this.props.viewApi\n                });\n            });\n            this.handleWindowResize = (ev)=>{\n                let { options } = this.props;\n                if (options.handleWindowResize && ev.target === window // avoid jqui events\n                ) {\n                    this.resizeRunner.request(options.windowResizeDelay);\n                }\n            };\n        }\n    }\n    function buildToolbarProps(viewSpec, dateProfile, dateProfileGenerator, currentDate, now, title) {\n        // don't force any date-profiles to valid date profiles (the `false`) so that we can tell if it's invalid\n        let todayInfo = dateProfileGenerator.build(now, undefined, false); // TODO: need `undefined` or else INFINITE LOOP for some reason\n        let prevInfo = dateProfileGenerator.buildPrev(dateProfile, currentDate, false);\n        let nextInfo = dateProfileGenerator.buildNext(dateProfile, currentDate, false);\n        return {\n            title,\n            activeButton: viewSpec.type,\n            navUnit: viewSpec.singleUnit,\n            isTodayEnabled: todayInfo.isValid && !rangeContainsMarker(dateProfile.currentRange, now),\n            isPrevEnabled: prevInfo.isValid,\n            isNextEnabled: nextInfo.isValid\n        };\n    }\n    // Plugin\n    // -----------------------------------------------------------------------------------------------------------------\n    function buildViewPropTransformers(theClasses) {\n        return theClasses.map((TheClass)=>new TheClass());\n    }\n    class Calendar extends CalendarImpl {\n        render() {\n            let wasRendering = this.isRendering;\n            if (!wasRendering) {\n                this.isRendering = true;\n            } else {\n                this.customContentRenderId += 1;\n            }\n            this.renderRunner.request();\n            if (wasRendering) {\n                this.updateSize();\n            }\n        }\n        destroy() {\n            if (this.isRendering) {\n                this.isRendering = false;\n                this.renderRunner.request();\n            }\n        }\n        updateSize() {\n            flushSync(()=>{\n                super.updateSize();\n            });\n        }\n        batchRendering(func) {\n            this.renderRunner.pause('batchRendering');\n            func();\n            this.renderRunner.resume('batchRendering');\n        }\n        pauseRendering() {\n            this.renderRunner.pause('pauseRendering');\n        }\n        resumeRendering() {\n            this.renderRunner.resume('pauseRendering', true);\n        }\n        resetOptions(optionOverrides, changedOptionNames) {\n            this.currentDataManager.resetOptions(optionOverrides, changedOptionNames);\n        }\n        setClassNames(classNames) {\n            if (!isArraysEqual(classNames, this.currentClassNames)) {\n                let { classList } = this.el;\n                for (let className of this.currentClassNames){\n                    classList.remove(className);\n                }\n                for (let className of classNames){\n                    classList.add(className);\n                }\n                this.currentClassNames = classNames;\n            }\n        }\n        setHeight(height) {\n            applyStyleProp(this.el, 'height', height);\n        }\n        constructor(el, optionOverrides = {}){\n            super();\n            this.isRendering = false;\n            this.isRendered = false;\n            this.currentClassNames = [];\n            this.customContentRenderId = 0;\n            this.handleAction = (action)=>{\n                // actions we know we want to render immediately\n                switch(action.type){\n                    case 'SET_EVENT_DRAG':\n                    case 'SET_EVENT_RESIZE':\n                        this.renderRunner.tryDrain();\n                }\n            };\n            this.handleData = (data)=>{\n                this.currentData = data;\n                this.renderRunner.request(data.calendarOptions.rerenderDelay);\n            };\n            this.handleRenderRequest = ()=>{\n                if (this.isRendering) {\n                    this.isRendered = true;\n                    let { currentData } = this;\n                    flushSync(()=>{\n                        D$1(y(CalendarRoot, {\n                            options: currentData.calendarOptions,\n                            theme: currentData.theme,\n                            emitter: currentData.emitter\n                        }, (classNames, height, isHeightAuto, forPrint)=>{\n                            this.setClassNames(classNames);\n                            this.setHeight(height);\n                            return y(RenderId.Provider, {\n                                value: this.customContentRenderId\n                            }, y(CalendarContent, Object.assign({\n                                isHeightAuto: isHeightAuto,\n                                forPrint: forPrint\n                            }, currentData)));\n                        }), this.el);\n                    });\n                } else if (this.isRendered) {\n                    this.isRendered = false;\n                    D$1(null, this.el);\n                    this.setClassNames([]);\n                    this.setHeight('');\n                }\n            };\n            ensureElHasStyles(el);\n            this.el = el;\n            this.renderRunner = new DelayedRunner(this.handleRenderRequest);\n            new CalendarDataManager({\n                optionOverrides,\n                calendarApi: this,\n                onAction: this.handleAction,\n                onData: this.handleData\n            });\n        }\n    }\n    function formatDate(dateInput) {\n        let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n        let dateEnv = buildDateEnv(options);\n        let formatter = createFormatter(options);\n        let dateMeta = dateEnv.createMarkerMeta(dateInput);\n        if (!dateMeta) {\n            return '';\n        }\n        return dateEnv.format(dateMeta.marker, formatter, {\n            forcedTzo: dateMeta.forcedTzo\n        });\n    }\n    function formatRange(startInput, endInput, options) {\n        let dateEnv = buildDateEnv(typeof options === 'object' && options ? options : {}); // pass in if non-null object\n        let formatter = createFormatter(options);\n        let startMeta = dateEnv.createMarkerMeta(startInput);\n        let endMeta = dateEnv.createMarkerMeta(endInput);\n        if (!startMeta || !endMeta) {\n            return '';\n        }\n        return dateEnv.formatRange(startMeta.marker, endMeta.marker, formatter, {\n            forcedStartTzo: startMeta.forcedTzo,\n            forcedEndTzo: endMeta.forcedTzo,\n            isEndExclusive: options.isEndExclusive,\n            defaultSeparator: BASE_OPTION_DEFAULTS.defaultRangeSeparator\n        });\n    }\n    // TODO: more DRY and optimized\n    function buildDateEnv(settings) {\n        let locale = buildLocale(settings.locale || 'en', organizeRawLocales([]).map); // TODO: don't hardcode 'en' everywhere\n        return new DateEnv(Object.assign(Object.assign({\n            timeZone: BASE_OPTION_DEFAULTS.timeZone,\n            calendarSystem: 'gregory'\n        }, settings), {\n            locale\n        }));\n    }\n    // HELPERS\n    /*\r\n    if nextDayThreshold is specified, slicing is done in an all-day fashion.\r\n    you can get nextDayThreshold from context.nextDayThreshold\r\n    */ function sliceEvents(props, allDay) {\n        return sliceEventStore(props.eventStore, props.eventUiBases, props.dateProfile.activeRange, allDay ? props.nextDayThreshold : null).fg;\n    }\n    const version = '6.1.8';\n    config.touchMouseIgnoreWait = 500;\n    let ignoreMouseDepth = 0;\n    let listenerCnt = 0;\n    let isWindowTouchMoveCancelled = false;\n    /*\r\n    Uses a \"pointer\" abstraction, which monitors UI events for both mouse and touch.\r\n    Tracks when the pointer \"drags\" on a certain element, meaning down+move+up.\r\n\r\n    Also, tracks if there was touch-scrolling.\r\n    Also, can prevent touch-scrolling from happening.\r\n    Also, can fire pointermove events when scrolling happens underneath, even when no real pointer movement.\r\n\r\n    emits:\r\n    - pointerdown\r\n    - pointermove\r\n    - pointerup\r\n    */ class PointerDragging {\n        destroy() {\n            this.containerEl.removeEventListener('mousedown', this.handleMouseDown);\n            this.containerEl.removeEventListener('touchstart', this.handleTouchStart, {\n                passive: true\n            });\n            listenerDestroyed();\n        }\n        tryStart(ev) {\n            let subjectEl = this.querySubjectEl(ev);\n            let downEl = ev.target;\n            if (subjectEl && (!this.handleSelector || elementClosest(downEl, this.handleSelector))) {\n                this.subjectEl = subjectEl;\n                this.isDragging = true; // do this first so cancelTouchScroll will work\n                this.wasTouchScroll = false;\n                return true;\n            }\n            return false;\n        }\n        cleanup() {\n            isWindowTouchMoveCancelled = false;\n            this.isDragging = false;\n            this.subjectEl = null;\n            // keep wasTouchScroll around for later access\n            this.destroyScrollWatch();\n        }\n        querySubjectEl(ev) {\n            if (this.selector) {\n                return elementClosest(ev.target, this.selector);\n            }\n            return this.containerEl;\n        }\n        shouldIgnoreMouse() {\n            return ignoreMouseDepth || this.isTouchDragging;\n        }\n        // can be called by user of this class, to cancel touch-based scrolling for the current drag\n        cancelTouchScroll() {\n            if (this.isDragging) {\n                isWindowTouchMoveCancelled = true;\n            }\n        }\n        // Scrolling that simulates pointermoves\n        // ----------------------------------------------------------------------------------------------------\n        initScrollWatch(ev) {\n            if (this.shouldWatchScroll) {\n                this.recordCoords(ev);\n                window.addEventListener('scroll', this.handleScroll, true); // useCapture=true\n            }\n        }\n        recordCoords(ev) {\n            if (this.shouldWatchScroll) {\n                this.prevPageX = ev.pageX;\n                this.prevPageY = ev.pageY;\n                this.prevScrollX = window.pageXOffset;\n                this.prevScrollY = window.pageYOffset;\n            }\n        }\n        destroyScrollWatch() {\n            if (this.shouldWatchScroll) {\n                window.removeEventListener('scroll', this.handleScroll, true); // useCaptured=true\n            }\n        }\n        // Event Normalization\n        // ----------------------------------------------------------------------------------------------------\n        createEventFromMouse(ev, isFirst) {\n            let deltaX = 0;\n            let deltaY = 0;\n            // TODO: repeat code\n            if (isFirst) {\n                this.origPageX = ev.pageX;\n                this.origPageY = ev.pageY;\n            } else {\n                deltaX = ev.pageX - this.origPageX;\n                deltaY = ev.pageY - this.origPageY;\n            }\n            return {\n                origEvent: ev,\n                isTouch: false,\n                subjectEl: this.subjectEl,\n                pageX: ev.pageX,\n                pageY: ev.pageY,\n                deltaX,\n                deltaY\n            };\n        }\n        createEventFromTouch(ev, isFirst) {\n            let touches = ev.touches;\n            let pageX;\n            let pageY;\n            let deltaX = 0;\n            let deltaY = 0;\n            // if touch coords available, prefer,\n            // because FF would give bad ev.pageX ev.pageY\n            if (touches && touches.length) {\n                pageX = touches[0].pageX;\n                pageY = touches[0].pageY;\n            } else {\n                pageX = ev.pageX;\n                pageY = ev.pageY;\n            }\n            // TODO: repeat code\n            if (isFirst) {\n                this.origPageX = pageX;\n                this.origPageY = pageY;\n            } else {\n                deltaX = pageX - this.origPageX;\n                deltaY = pageY - this.origPageY;\n            }\n            return {\n                origEvent: ev,\n                isTouch: true,\n                subjectEl: this.subjectEl,\n                pageX,\n                pageY,\n                deltaX,\n                deltaY\n            };\n        }\n        constructor(containerEl){\n            this.subjectEl = null;\n            // options that can be directly assigned by caller\n            this.selector = ''; // will cause subjectEl in all emitted events to be this element\n            this.handleSelector = '';\n            this.shouldIgnoreMove = false;\n            this.shouldWatchScroll = true; // for simulating pointermove on scroll\n            // internal states\n            this.isDragging = false;\n            this.isTouchDragging = false;\n            this.wasTouchScroll = false;\n            // Mouse\n            // ----------------------------------------------------------------------------------------------------\n            this.handleMouseDown = (ev)=>{\n                if (!this.shouldIgnoreMouse() && isPrimaryMouseButton(ev) && this.tryStart(ev)) {\n                    let pev = this.createEventFromMouse(ev, true);\n                    this.emitter.trigger('pointerdown', pev);\n                    this.initScrollWatch(pev);\n                    if (!this.shouldIgnoreMove) {\n                        document.addEventListener('mousemove', this.handleMouseMove);\n                    }\n                    document.addEventListener('mouseup', this.handleMouseUp);\n                }\n            };\n            this.handleMouseMove = (ev)=>{\n                let pev = this.createEventFromMouse(ev);\n                this.recordCoords(pev);\n                this.emitter.trigger('pointermove', pev);\n            };\n            this.handleMouseUp = (ev)=>{\n                document.removeEventListener('mousemove', this.handleMouseMove);\n                document.removeEventListener('mouseup', this.handleMouseUp);\n                this.emitter.trigger('pointerup', this.createEventFromMouse(ev));\n                this.cleanup(); // call last so that pointerup has access to props\n            };\n            // Touch\n            // ----------------------------------------------------------------------------------------------------\n            this.handleTouchStart = (ev)=>{\n                if (this.tryStart(ev)) {\n                    this.isTouchDragging = true;\n                    let pev = this.createEventFromTouch(ev, true);\n                    this.emitter.trigger('pointerdown', pev);\n                    this.initScrollWatch(pev);\n                    // unlike mouse, need to attach to target, not document\n                    // https://stackoverflow.com/a/45760014\n                    let targetEl = ev.target;\n                    if (!this.shouldIgnoreMove) {\n                        targetEl.addEventListener('touchmove', this.handleTouchMove);\n                    }\n                    targetEl.addEventListener('touchend', this.handleTouchEnd);\n                    targetEl.addEventListener('touchcancel', this.handleTouchEnd); // treat it as a touch end\n                    // attach a handler to get called when ANY scroll action happens on the page.\n                    // this was impossible to do with normal on/off because 'scroll' doesn't bubble.\n                    // http://stackoverflow.com/a/32954565/96342\n                    window.addEventListener('scroll', this.handleTouchScroll, true);\n                }\n            };\n            this.handleTouchMove = (ev)=>{\n                let pev = this.createEventFromTouch(ev);\n                this.recordCoords(pev);\n                this.emitter.trigger('pointermove', pev);\n            };\n            this.handleTouchEnd = (ev)=>{\n                if (this.isDragging) {\n                    let targetEl = ev.target;\n                    targetEl.removeEventListener('touchmove', this.handleTouchMove);\n                    targetEl.removeEventListener('touchend', this.handleTouchEnd);\n                    targetEl.removeEventListener('touchcancel', this.handleTouchEnd);\n                    window.removeEventListener('scroll', this.handleTouchScroll, true); // useCaptured=true\n                    this.emitter.trigger('pointerup', this.createEventFromTouch(ev));\n                    this.cleanup(); // call last so that pointerup has access to props\n                    this.isTouchDragging = false;\n                    startIgnoringMouse();\n                }\n            };\n            this.handleTouchScroll = ()=>{\n                this.wasTouchScroll = true;\n            };\n            this.handleScroll = (ev)=>{\n                if (!this.shouldIgnoreMove) {\n                    let pageX = window.pageXOffset - this.prevScrollX + this.prevPageX;\n                    let pageY = window.pageYOffset - this.prevScrollY + this.prevPageY;\n                    this.emitter.trigger('pointermove', {\n                        origEvent: ev,\n                        isTouch: this.isTouchDragging,\n                        subjectEl: this.subjectEl,\n                        pageX,\n                        pageY,\n                        deltaX: pageX - this.origPageX,\n                        deltaY: pageY - this.origPageY\n                    });\n                }\n            };\n            this.containerEl = containerEl;\n            this.emitter = new Emitter();\n            containerEl.addEventListener('mousedown', this.handleMouseDown);\n            containerEl.addEventListener('touchstart', this.handleTouchStart, {\n                passive: true\n            });\n            listenerCreated();\n        }\n    }\n    // Returns a boolean whether this was a left mouse click and no ctrl key (which means right click on Mac)\n    function isPrimaryMouseButton(ev) {\n        return ev.button === 0 && !ev.ctrlKey;\n    }\n    // Ignoring fake mouse events generated by touch\n    // ----------------------------------------------------------------------------------------------------\n    function startIgnoringMouse() {\n        ignoreMouseDepth += 1;\n        setTimeout(()=>{\n            ignoreMouseDepth -= 1;\n        }, config.touchMouseIgnoreWait);\n    }\n    // We want to attach touchmove as early as possible for Safari\n    // ----------------------------------------------------------------------------------------------------\n    function listenerCreated() {\n        listenerCnt += 1;\n        if (listenerCnt === 1) {\n            window.addEventListener('touchmove', onWindowTouchMove, {\n                passive: false\n            });\n        }\n    }\n    function listenerDestroyed() {\n        listenerCnt -= 1;\n        if (!listenerCnt) {\n            window.removeEventListener('touchmove', onWindowTouchMove, {\n                passive: false\n            });\n        }\n    }\n    function onWindowTouchMove(ev) {\n        if (isWindowTouchMoveCancelled) {\n            ev.preventDefault();\n        }\n    }\n    /*\r\n    An effect in which an element follows the movement of a pointer across the screen.\r\n    The moving element is a clone of some other element.\r\n    Must call start + handleMove + stop.\r\n    */ class ElementMirror {\n        start(sourceEl, pageX, pageY) {\n            this.sourceEl = sourceEl;\n            this.sourceElRect = this.sourceEl.getBoundingClientRect();\n            this.origScreenX = pageX - window.pageXOffset;\n            this.origScreenY = pageY - window.pageYOffset;\n            this.deltaX = 0;\n            this.deltaY = 0;\n            this.updateElPosition();\n        }\n        handleMove(pageX, pageY) {\n            this.deltaX = pageX - window.pageXOffset - this.origScreenX;\n            this.deltaY = pageY - window.pageYOffset - this.origScreenY;\n            this.updateElPosition();\n        }\n        // can be called before start\n        setIsVisible(bool) {\n            if (bool) {\n                if (!this.isVisible) {\n                    if (this.mirrorEl) {\n                        this.mirrorEl.style.display = '';\n                    }\n                    this.isVisible = bool; // needs to happen before updateElPosition\n                    this.updateElPosition(); // because was not updating the position while invisible\n                }\n            } else if (this.isVisible) {\n                if (this.mirrorEl) {\n                    this.mirrorEl.style.display = 'none';\n                }\n                this.isVisible = bool;\n            }\n        }\n        // always async\n        stop(needsRevertAnimation, callback) {\n            let done = ()=>{\n                this.cleanup();\n                callback();\n            };\n            if (needsRevertAnimation && this.mirrorEl && this.isVisible && this.revertDuration && // if 0, transition won't work\n            (this.deltaX || this.deltaY // if same coords, transition won't work\n            )) {\n                this.doRevertAnimation(done, this.revertDuration);\n            } else {\n                setTimeout(done, 0);\n            }\n        }\n        doRevertAnimation(callback, revertDuration) {\n            let mirrorEl = this.mirrorEl;\n            let finalSourceElRect = this.sourceEl.getBoundingClientRect(); // because autoscrolling might have happened\n            mirrorEl.style.transition = 'top ' + revertDuration + 'ms,' + 'left ' + revertDuration + 'ms';\n            applyStyle(mirrorEl, {\n                left: finalSourceElRect.left,\n                top: finalSourceElRect.top\n            });\n            whenTransitionDone(mirrorEl, ()=>{\n                mirrorEl.style.transition = '';\n                callback();\n            });\n        }\n        cleanup() {\n            if (this.mirrorEl) {\n                removeElement(this.mirrorEl);\n                this.mirrorEl = null;\n            }\n            this.sourceEl = null;\n        }\n        updateElPosition() {\n            if (this.sourceEl && this.isVisible) {\n                applyStyle(this.getMirrorEl(), {\n                    left: this.sourceElRect.left + this.deltaX,\n                    top: this.sourceElRect.top + this.deltaY\n                });\n            }\n        }\n        getMirrorEl() {\n            let sourceElRect = this.sourceElRect;\n            let mirrorEl = this.mirrorEl;\n            if (!mirrorEl) {\n                mirrorEl = this.mirrorEl = this.sourceEl.cloneNode(true); // cloneChildren=true\n                // we don't want long taps or any mouse interaction causing selection/menus.\n                // would use preventSelection(), but that prevents selectstart, causing problems.\n                mirrorEl.style.userSelect = 'none';\n                mirrorEl.classList.add('fc-event-dragging');\n                applyStyle(mirrorEl, {\n                    position: 'fixed',\n                    zIndex: this.zIndex,\n                    visibility: '',\n                    boxSizing: 'border-box',\n                    width: sourceElRect.right - sourceElRect.left,\n                    height: sourceElRect.bottom - sourceElRect.top,\n                    right: 'auto',\n                    bottom: 'auto',\n                    margin: 0\n                });\n                this.parentNode.appendChild(mirrorEl);\n            }\n            return mirrorEl;\n        }\n        constructor(){\n            this.isVisible = false; // must be explicitly enabled\n            this.sourceEl = null;\n            this.mirrorEl = null;\n            this.sourceElRect = null; // screen coords relative to viewport\n            // options that can be set directly by caller\n            this.parentNode = document.body; // HIGHLY SUGGESTED to set this to sidestep ShadowDOM issues\n            this.zIndex = 9999;\n            this.revertDuration = 0;\n        }\n    }\n    /*\r\n    Is a cache for a given element's scroll information (all the info that ScrollController stores)\r\n    in addition the \"client rectangle\" of the element.. the area within the scrollbars.\r\n\r\n    The cache can be in one of two modes:\r\n    - doesListening:false - ignores when the container is scrolled by someone else\r\n    - doesListening:true - watch for scrolling and update the cache\r\n    */ class ScrollGeomCache extends ScrollController {\n        destroy() {\n            if (this.doesListening) {\n                this.getEventTarget().removeEventListener('scroll', this.handleScroll);\n            }\n        }\n        getScrollTop() {\n            return this.scrollTop;\n        }\n        getScrollLeft() {\n            return this.scrollLeft;\n        }\n        setScrollTop(top) {\n            this.scrollController.setScrollTop(top);\n            if (!this.doesListening) {\n                // we are not relying on the element to normalize out-of-bounds scroll values\n                // so we need to sanitize ourselves\n                this.scrollTop = Math.max(Math.min(top, this.getMaxScrollTop()), 0);\n                this.handleScrollChange();\n            }\n        }\n        setScrollLeft(top) {\n            this.scrollController.setScrollLeft(top);\n            if (!this.doesListening) {\n                // we are not relying on the element to normalize out-of-bounds scroll values\n                // so we need to sanitize ourselves\n                this.scrollLeft = Math.max(Math.min(top, this.getMaxScrollLeft()), 0);\n                this.handleScrollChange();\n            }\n        }\n        getClientWidth() {\n            return this.clientWidth;\n        }\n        getClientHeight() {\n            return this.clientHeight;\n        }\n        getScrollWidth() {\n            return this.scrollWidth;\n        }\n        getScrollHeight() {\n            return this.scrollHeight;\n        }\n        handleScrollChange() {}\n        constructor(scrollController, doesListening){\n            super();\n            this.handleScroll = ()=>{\n                this.scrollTop = this.scrollController.getScrollTop();\n                this.scrollLeft = this.scrollController.getScrollLeft();\n                this.handleScrollChange();\n            };\n            this.scrollController = scrollController;\n            this.doesListening = doesListening;\n            this.scrollTop = this.origScrollTop = scrollController.getScrollTop();\n            this.scrollLeft = this.origScrollLeft = scrollController.getScrollLeft();\n            this.scrollWidth = scrollController.getScrollWidth();\n            this.scrollHeight = scrollController.getScrollHeight();\n            this.clientWidth = scrollController.getClientWidth();\n            this.clientHeight = scrollController.getClientHeight();\n            this.clientRect = this.computeClientRect(); // do last in case it needs cached values\n            if (this.doesListening) {\n                this.getEventTarget().addEventListener('scroll', this.handleScroll);\n            }\n        }\n    }\n    class ElementScrollGeomCache extends ScrollGeomCache {\n        getEventTarget() {\n            return this.scrollController.el;\n        }\n        computeClientRect() {\n            return computeInnerRect(this.scrollController.el);\n        }\n        constructor(el, doesListening){\n            super(new ElementScrollController(el), doesListening);\n        }\n    }\n    class WindowScrollGeomCache extends ScrollGeomCache {\n        getEventTarget() {\n            return window;\n        }\n        computeClientRect() {\n            return {\n                left: this.scrollLeft,\n                right: this.scrollLeft + this.clientWidth,\n                top: this.scrollTop,\n                bottom: this.scrollTop + this.clientHeight\n            };\n        }\n        // the window is the only scroll object that changes it's rectangle relative\n        // to the document's topleft as it scrolls\n        handleScrollChange() {\n            this.clientRect = this.computeClientRect();\n        }\n        constructor(doesListening){\n            super(new WindowScrollController(), doesListening);\n        }\n    }\n    // If available we are using native \"performance\" API instead of \"Date\"\n    // Read more about it on MDN:\n    // https://developer.mozilla.org/en-US/docs/Web/API/Performance\n    const getTime = typeof performance === 'function' ? performance.now : Date.now;\n    /*\r\n    For a pointer interaction, automatically scrolls certain scroll containers when the pointer\r\n    approaches the edge.\r\n\r\n    The caller must call start + handleMove + stop.\r\n    */ class AutoScroller {\n        start(pageX, pageY, scrollStartEl) {\n            if (this.isEnabled) {\n                this.scrollCaches = this.buildCaches(scrollStartEl);\n                this.pointerScreenX = null;\n                this.pointerScreenY = null;\n                this.everMovedUp = false;\n                this.everMovedDown = false;\n                this.everMovedLeft = false;\n                this.everMovedRight = false;\n                this.handleMove(pageX, pageY);\n            }\n        }\n        handleMove(pageX, pageY) {\n            if (this.isEnabled) {\n                let pointerScreenX = pageX - window.pageXOffset;\n                let pointerScreenY = pageY - window.pageYOffset;\n                let yDelta = this.pointerScreenY === null ? 0 : pointerScreenY - this.pointerScreenY;\n                let xDelta = this.pointerScreenX === null ? 0 : pointerScreenX - this.pointerScreenX;\n                if (yDelta < 0) {\n                    this.everMovedUp = true;\n                } else if (yDelta > 0) {\n                    this.everMovedDown = true;\n                }\n                if (xDelta < 0) {\n                    this.everMovedLeft = true;\n                } else if (xDelta > 0) {\n                    this.everMovedRight = true;\n                }\n                this.pointerScreenX = pointerScreenX;\n                this.pointerScreenY = pointerScreenY;\n                if (!this.isAnimating) {\n                    this.isAnimating = true;\n                    this.requestAnimation(getTime());\n                }\n            }\n        }\n        stop() {\n            if (this.isEnabled) {\n                this.isAnimating = false; // will stop animation\n                for (let scrollCache of this.scrollCaches){\n                    scrollCache.destroy();\n                }\n                this.scrollCaches = null;\n            }\n        }\n        requestAnimation(now) {\n            this.msSinceRequest = now;\n            requestAnimationFrame(this.animate);\n        }\n        handleSide(edge, seconds) {\n            let { scrollCache } = edge;\n            let { edgeThreshold } = this;\n            let invDistance = edgeThreshold - edge.distance;\n            let velocity = invDistance * invDistance / (edgeThreshold * edgeThreshold) * // quadratic\n            this.maxVelocity * seconds;\n            let sign = 1;\n            switch(edge.name){\n                case 'left':\n                    sign = -1;\n                // falls through\n                case 'right':\n                    scrollCache.setScrollLeft(scrollCache.getScrollLeft() + velocity * sign);\n                    break;\n                case 'top':\n                    sign = -1;\n                // falls through\n                case 'bottom':\n                    scrollCache.setScrollTop(scrollCache.getScrollTop() + velocity * sign);\n                    break;\n            }\n        }\n        // left/top are relative to document topleft\n        computeBestEdge(left, top) {\n            let { edgeThreshold } = this;\n            let bestSide = null;\n            let scrollCaches = this.scrollCaches || [];\n            for (let scrollCache of scrollCaches){\n                let rect = scrollCache.clientRect;\n                let leftDist = left - rect.left;\n                let rightDist = rect.right - left;\n                let topDist = top - rect.top;\n                let bottomDist = rect.bottom - top;\n                // completely within the rect?\n                if (leftDist >= 0 && rightDist >= 0 && topDist >= 0 && bottomDist >= 0) {\n                    if (topDist <= edgeThreshold && this.everMovedUp && scrollCache.canScrollUp() && (!bestSide || bestSide.distance > topDist)) {\n                        bestSide = {\n                            scrollCache,\n                            name: 'top',\n                            distance: topDist\n                        };\n                    }\n                    if (bottomDist <= edgeThreshold && this.everMovedDown && scrollCache.canScrollDown() && (!bestSide || bestSide.distance > bottomDist)) {\n                        bestSide = {\n                            scrollCache,\n                            name: 'bottom',\n                            distance: bottomDist\n                        };\n                    }\n                    if (leftDist <= edgeThreshold && this.everMovedLeft && scrollCache.canScrollLeft() && (!bestSide || bestSide.distance > leftDist)) {\n                        bestSide = {\n                            scrollCache,\n                            name: 'left',\n                            distance: leftDist\n                        };\n                    }\n                    if (rightDist <= edgeThreshold && this.everMovedRight && scrollCache.canScrollRight() && (!bestSide || bestSide.distance > rightDist)) {\n                        bestSide = {\n                            scrollCache,\n                            name: 'right',\n                            distance: rightDist\n                        };\n                    }\n                }\n            }\n            return bestSide;\n        }\n        buildCaches(scrollStartEl) {\n            return this.queryScrollEls(scrollStartEl).map((el)=>{\n                if (el === window) {\n                    return new WindowScrollGeomCache(false); // false = don't listen to user-generated scrolls\n                }\n                return new ElementScrollGeomCache(el, false); // false = don't listen to user-generated scrolls\n            });\n        }\n        queryScrollEls(scrollStartEl) {\n            let els = [];\n            for (let query of this.scrollQuery){\n                if (typeof query === 'object') {\n                    els.push(query);\n                } else {\n                    els.push(...Array.prototype.slice.call(scrollStartEl.getRootNode().querySelectorAll(query)));\n                }\n            }\n            return els;\n        }\n        constructor(){\n            // options that can be set by caller\n            this.isEnabled = true;\n            this.scrollQuery = [\n                window,\n                '.fc-scroller'\n            ];\n            this.edgeThreshold = 50; // pixels\n            this.maxVelocity = 300; // pixels per second\n            // internal state\n            this.pointerScreenX = null;\n            this.pointerScreenY = null;\n            this.isAnimating = false;\n            this.scrollCaches = null;\n            // protect against the initial pointerdown being too close to an edge and starting the scroll\n            this.everMovedUp = false;\n            this.everMovedDown = false;\n            this.everMovedLeft = false;\n            this.everMovedRight = false;\n            this.animate = ()=>{\n                if (this.isAnimating) {\n                    let edge = this.computeBestEdge(this.pointerScreenX + window.pageXOffset, this.pointerScreenY + window.pageYOffset);\n                    if (edge) {\n                        let now = getTime();\n                        this.handleSide(edge, (now - this.msSinceRequest) / 1000);\n                        this.requestAnimation(now);\n                    } else {\n                        this.isAnimating = false; // will stop animation\n                    }\n                }\n            };\n        }\n    }\n    /*\r\n    Monitors dragging on an element. Has a number of high-level features:\r\n    - minimum distance required before dragging\r\n    - minimum wait time (\"delay\") before dragging\r\n    - a mirror element that follows the pointer\r\n    */ class FeaturefulElementDragging extends ElementDragging {\n        destroy() {\n            this.pointer.destroy();\n            // HACK: simulate a pointer-up to end the current drag\n            // TODO: fire 'dragend' directly and stop interaction. discourage use of pointerup event (b/c might not fire)\n            this.onPointerUp({});\n        }\n        startDelay(ev) {\n            if (typeof this.delay === 'number') {\n                this.delayTimeoutId = setTimeout(()=>{\n                    this.delayTimeoutId = null;\n                    this.handleDelayEnd(ev);\n                }, this.delay); // not assignable to number!\n            } else {\n                this.handleDelayEnd(ev);\n            }\n        }\n        handleDelayEnd(ev) {\n            this.isDelayEnded = true;\n            this.tryStartDrag(ev);\n        }\n        handleDistanceSurpassed(ev) {\n            this.isDistanceSurpassed = true;\n            this.tryStartDrag(ev);\n        }\n        tryStartDrag(ev) {\n            if (this.isDelayEnded && this.isDistanceSurpassed) {\n                if (!this.pointer.wasTouchScroll || this.touchScrollAllowed) {\n                    this.isDragging = true;\n                    this.mirrorNeedsRevert = false;\n                    this.autoScroller.start(ev.pageX, ev.pageY, this.containerEl);\n                    this.emitter.trigger('dragstart', ev);\n                    if (this.touchScrollAllowed === false) {\n                        this.pointer.cancelTouchScroll();\n                    }\n                }\n            }\n        }\n        tryStopDrag(ev) {\n            // .stop() is ALWAYS asynchronous, which we NEED because we want all pointerup events\n            // that come from the document to fire beforehand. much more convenient this way.\n            this.mirror.stop(this.mirrorNeedsRevert, this.stopDrag.bind(this, ev));\n        }\n        stopDrag(ev) {\n            this.isDragging = false;\n            this.emitter.trigger('dragend', ev);\n        }\n        // fill in the implementations...\n        setIgnoreMove(bool) {\n            this.pointer.shouldIgnoreMove = bool;\n        }\n        setMirrorIsVisible(bool) {\n            this.mirror.setIsVisible(bool);\n        }\n        setMirrorNeedsRevert(bool) {\n            this.mirrorNeedsRevert = bool;\n        }\n        setAutoScrollEnabled(bool) {\n            this.autoScroller.isEnabled = bool;\n        }\n        constructor(containerEl, selector){\n            super(containerEl);\n            this.containerEl = containerEl;\n            // options that can be directly set by caller\n            // the caller can also set the PointerDragging's options as well\n            this.delay = null;\n            this.minDistance = 0;\n            this.touchScrollAllowed = true; // prevents drag from starting and blocks scrolling during drag\n            this.mirrorNeedsRevert = false;\n            this.isInteracting = false; // is the user validly moving the pointer? lasts until pointerup\n            this.isDragging = false; // is it INTENTFULLY dragging? lasts until after revert animation\n            this.isDelayEnded = false;\n            this.isDistanceSurpassed = false;\n            this.delayTimeoutId = null;\n            this.onPointerDown = (ev)=>{\n                if (!this.isDragging) {\n                    this.isInteracting = true;\n                    this.isDelayEnded = false;\n                    this.isDistanceSurpassed = false;\n                    preventSelection(document.body);\n                    preventContextMenu(document.body);\n                    // prevent links from being visited if there's an eventual drag.\n                    // also prevents selection in older browsers (maybe?).\n                    // not necessary for touch, besides, browser would complain about passiveness.\n                    if (!ev.isTouch) {\n                        ev.origEvent.preventDefault();\n                    }\n                    this.emitter.trigger('pointerdown', ev);\n                    if (this.isInteracting && // not destroyed via pointerdown handler\n                    !this.pointer.shouldIgnoreMove) {\n                        // actions related to initiating dragstart+dragmove+dragend...\n                        this.mirror.setIsVisible(false); // reset. caller must set-visible\n                        this.mirror.start(ev.subjectEl, ev.pageX, ev.pageY); // must happen on first pointer down\n                        this.startDelay(ev);\n                        if (!this.minDistance) {\n                            this.handleDistanceSurpassed(ev);\n                        }\n                    }\n                }\n            };\n            this.onPointerMove = (ev)=>{\n                if (this.isInteracting) {\n                    this.emitter.trigger('pointermove', ev);\n                    if (!this.isDistanceSurpassed) {\n                        let minDistance = this.minDistance;\n                        let distanceSq; // current distance from the origin, squared\n                        let { deltaX, deltaY } = ev;\n                        distanceSq = deltaX * deltaX + deltaY * deltaY;\n                        if (distanceSq >= minDistance * minDistance) {\n                            this.handleDistanceSurpassed(ev);\n                        }\n                    }\n                    if (this.isDragging) {\n                        // a real pointer move? (not one simulated by scrolling)\n                        if (ev.origEvent.type !== 'scroll') {\n                            this.mirror.handleMove(ev.pageX, ev.pageY);\n                            this.autoScroller.handleMove(ev.pageX, ev.pageY);\n                        }\n                        this.emitter.trigger('dragmove', ev);\n                    }\n                }\n            };\n            this.onPointerUp = (ev)=>{\n                if (this.isInteracting) {\n                    this.isInteracting = false;\n                    allowSelection(document.body);\n                    allowContextMenu(document.body);\n                    this.emitter.trigger('pointerup', ev); // can potentially set mirrorNeedsRevert\n                    if (this.isDragging) {\n                        this.autoScroller.stop();\n                        this.tryStopDrag(ev); // which will stop the mirror\n                    }\n                    if (this.delayTimeoutId) {\n                        clearTimeout(this.delayTimeoutId);\n                        this.delayTimeoutId = null;\n                    }\n                }\n            };\n            let pointer = this.pointer = new PointerDragging(containerEl);\n            pointer.emitter.on('pointerdown', this.onPointerDown);\n            pointer.emitter.on('pointermove', this.onPointerMove);\n            pointer.emitter.on('pointerup', this.onPointerUp);\n            if (selector) {\n                pointer.selector = selector;\n            }\n            this.mirror = new ElementMirror();\n            this.autoScroller = new AutoScroller();\n        }\n    }\n    /*\r\n    When this class is instantiated, it records the offset of an element (relative to the document topleft),\r\n    and continues to monitor scrolling, updating the cached coordinates if it needs to.\r\n    Does not access the DOM after instantiation, so highly performant.\r\n\r\n    Also keeps track of all scrolling/overflow:hidden containers that are parents of the given element\r\n    and an determine if a given point is inside the combined clipping rectangle.\r\n    */ class OffsetTracker {\n        destroy() {\n            for (let scrollCache of this.scrollCaches){\n                scrollCache.destroy();\n            }\n        }\n        computeLeft() {\n            let left = this.origRect.left;\n            for (let scrollCache of this.scrollCaches){\n                left += scrollCache.origScrollLeft - scrollCache.getScrollLeft();\n            }\n            return left;\n        }\n        computeTop() {\n            let top = this.origRect.top;\n            for (let scrollCache of this.scrollCaches){\n                top += scrollCache.origScrollTop - scrollCache.getScrollTop();\n            }\n            return top;\n        }\n        isWithinClipping(pageX, pageY) {\n            let point = {\n                left: pageX,\n                top: pageY\n            };\n            for (let scrollCache of this.scrollCaches){\n                if (!isIgnoredClipping(scrollCache.getEventTarget()) && !pointInsideRect(point, scrollCache.clientRect)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        constructor(el){\n            this.origRect = computeRect(el);\n            // will work fine for divs that have overflow:hidden\n            this.scrollCaches = getClippingParents(el).map((scrollEl)=>new ElementScrollGeomCache(scrollEl, true));\n        }\n    }\n    // certain clipping containers should never constrain interactions, like <html> and <body>\n    // https://github.com/fullcalendar/fullcalendar/issues/3615\n    function isIgnoredClipping(node) {\n        let tagName = node.tagName;\n        return tagName === 'HTML' || tagName === 'BODY';\n    }\n    /*\r\n    Tracks movement over multiple droppable areas (aka \"hits\")\r\n    that exist in one or more DateComponents.\r\n    Relies on an existing draggable.\r\n\r\n    emits:\r\n    - pointerdown\r\n    - dragstart\r\n    - hitchange - fires initially, even if not over a hit\r\n    - pointerup\r\n    - (hitchange - again, to null, if ended over a hit)\r\n    - dragend\r\n    */ class HitDragging {\n        // sets initialHit\n        // sets coordAdjust\n        processFirstCoord(ev) {\n            let origPoint = {\n                left: ev.pageX,\n                top: ev.pageY\n            };\n            let adjustedPoint = origPoint;\n            let subjectEl = ev.subjectEl;\n            let subjectRect;\n            if (subjectEl instanceof HTMLElement) {\n                subjectRect = computeRect(subjectEl);\n                adjustedPoint = constrainPoint(adjustedPoint, subjectRect);\n            }\n            let initialHit = this.initialHit = this.queryHitForOffset(adjustedPoint.left, adjustedPoint.top);\n            if (initialHit) {\n                if (this.useSubjectCenter && subjectRect) {\n                    let slicedSubjectRect = intersectRects(subjectRect, initialHit.rect);\n                    if (slicedSubjectRect) {\n                        adjustedPoint = getRectCenter(slicedSubjectRect);\n                    }\n                }\n                this.coordAdjust = diffPoints(adjustedPoint, origPoint);\n            } else {\n                this.coordAdjust = {\n                    left: 0,\n                    top: 0\n                };\n            }\n        }\n        handleMove(ev, forceHandle) {\n            let hit = this.queryHitForOffset(ev.pageX + this.coordAdjust.left, ev.pageY + this.coordAdjust.top);\n            if (forceHandle || !isHitsEqual(this.movingHit, hit)) {\n                this.movingHit = hit;\n                this.emitter.trigger('hitupdate', hit, false, ev);\n            }\n        }\n        prepareHits() {\n            this.offsetTrackers = mapHash(this.droppableStore, (interactionSettings)=>{\n                interactionSettings.component.prepareHits();\n                return new OffsetTracker(interactionSettings.el);\n            });\n        }\n        releaseHits() {\n            let { offsetTrackers } = this;\n            for(let id in offsetTrackers){\n                offsetTrackers[id].destroy();\n            }\n            this.offsetTrackers = {};\n        }\n        queryHitForOffset(offsetLeft, offsetTop) {\n            let { droppableStore, offsetTrackers } = this;\n            let bestHit = null;\n            for(let id in droppableStore){\n                let component = droppableStore[id].component;\n                let offsetTracker = offsetTrackers[id];\n                if (offsetTracker && // wasn't destroyed mid-drag\n                offsetTracker.isWithinClipping(offsetLeft, offsetTop)) {\n                    let originLeft = offsetTracker.computeLeft();\n                    let originTop = offsetTracker.computeTop();\n                    let positionLeft = offsetLeft - originLeft;\n                    let positionTop = offsetTop - originTop;\n                    let { origRect } = offsetTracker;\n                    let width = origRect.right - origRect.left;\n                    let height = origRect.bottom - origRect.top;\n                    if (// must be within the element's bounds\n                    positionLeft >= 0 && positionLeft < width && positionTop >= 0 && positionTop < height) {\n                        let hit = component.queryHit(positionLeft, positionTop, width, height);\n                        if (hit && // make sure the hit is within activeRange, meaning it's not a dead cell\n                        rangeContainsRange(hit.dateProfile.activeRange, hit.dateSpan.range) && (!bestHit || hit.layer > bestHit.layer)) {\n                            hit.componentId = id;\n                            hit.context = component.context;\n                            // TODO: better way to re-orient rectangle\n                            hit.rect.left += originLeft;\n                            hit.rect.right += originLeft;\n                            hit.rect.top += originTop;\n                            hit.rect.bottom += originTop;\n                            bestHit = hit;\n                        }\n                    }\n                }\n            }\n            return bestHit;\n        }\n        constructor(dragging, droppableStore){\n            // options that can be set by caller\n            this.useSubjectCenter = false;\n            this.requireInitial = true; // if doesn't start out on a hit, won't emit any events\n            this.initialHit = null;\n            this.movingHit = null;\n            this.finalHit = null; // won't ever be populated if shouldIgnoreMove\n            this.handlePointerDown = (ev)=>{\n                let { dragging } = this;\n                this.initialHit = null;\n                this.movingHit = null;\n                this.finalHit = null;\n                this.prepareHits();\n                this.processFirstCoord(ev);\n                if (this.initialHit || !this.requireInitial) {\n                    dragging.setIgnoreMove(false);\n                    // TODO: fire this before computing processFirstCoord, so listeners can cancel. this gets fired by almost every handler :(\n                    this.emitter.trigger('pointerdown', ev);\n                } else {\n                    dragging.setIgnoreMove(true);\n                }\n            };\n            this.handleDragStart = (ev)=>{\n                this.emitter.trigger('dragstart', ev);\n                this.handleMove(ev, true); // force = fire even if initially null\n            };\n            this.handleDragMove = (ev)=>{\n                this.emitter.trigger('dragmove', ev);\n                this.handleMove(ev);\n            };\n            this.handlePointerUp = (ev)=>{\n                this.releaseHits();\n                this.emitter.trigger('pointerup', ev);\n            };\n            this.handleDragEnd = (ev)=>{\n                if (this.movingHit) {\n                    this.emitter.trigger('hitupdate', null, true, ev);\n                }\n                this.finalHit = this.movingHit;\n                this.movingHit = null;\n                this.emitter.trigger('dragend', ev);\n            };\n            this.droppableStore = droppableStore;\n            dragging.emitter.on('pointerdown', this.handlePointerDown);\n            dragging.emitter.on('dragstart', this.handleDragStart);\n            dragging.emitter.on('dragmove', this.handleDragMove);\n            dragging.emitter.on('pointerup', this.handlePointerUp);\n            dragging.emitter.on('dragend', this.handleDragEnd);\n            this.dragging = dragging;\n            this.emitter = new Emitter();\n        }\n    }\n    function isHitsEqual(hit0, hit1) {\n        if (!hit0 && !hit1) {\n            return true;\n        }\n        if (Boolean(hit0) !== Boolean(hit1)) {\n            return false;\n        }\n        return isDateSpansEqual(hit0.dateSpan, hit1.dateSpan);\n    }\n    function buildDatePointApiWithContext(dateSpan, context) {\n        let props = {};\n        for (let transform of context.pluginHooks.datePointTransforms){\n            Object.assign(props, transform(dateSpan, context));\n        }\n        Object.assign(props, buildDatePointApi(dateSpan, context.dateEnv));\n        return props;\n    }\n    function buildDatePointApi(span, dateEnv) {\n        return {\n            date: dateEnv.toDate(span.range.start),\n            dateStr: dateEnv.formatIso(span.range.start, {\n                omitTime: span.allDay\n            }),\n            allDay: span.allDay\n        };\n    }\n    /*\r\n    Monitors when the user clicks on a specific date/time of a component.\r\n    A pointerdown+pointerup on the same \"hit\" constitutes a click.\r\n    */ class DateClicking extends Interaction {\n        destroy() {\n            this.dragging.destroy();\n        }\n        constructor(settings){\n            super(settings);\n            this.handlePointerDown = (pev)=>{\n                let { dragging } = this;\n                let downEl = pev.origEvent.target;\n                // do this in pointerdown (not dragend) because DOM might be mutated by the time dragend is fired\n                dragging.setIgnoreMove(!this.component.isValidDateDownEl(downEl));\n            };\n            // won't even fire if moving was ignored\n            this.handleDragEnd = (ev)=>{\n                let { component } = this;\n                let { pointer } = this.dragging;\n                if (!pointer.wasTouchScroll) {\n                    let { initialHit, finalHit } = this.hitDragging;\n                    if (initialHit && finalHit && isHitsEqual(initialHit, finalHit)) {\n                        let { context } = component;\n                        let arg = Object.assign(Object.assign({}, buildDatePointApiWithContext(initialHit.dateSpan, context)), {\n                            dayEl: initialHit.dayEl,\n                            jsEvent: ev.origEvent,\n                            view: context.viewApi || context.calendarApi.view\n                        });\n                        context.emitter.trigger('dateClick', arg);\n                    }\n                }\n            };\n            // we DO want to watch pointer moves because otherwise finalHit won't get populated\n            this.dragging = new FeaturefulElementDragging(settings.el);\n            this.dragging.autoScroller.isEnabled = false;\n            let hitDragging = this.hitDragging = new HitDragging(this.dragging, interactionSettingsToStore(settings));\n            hitDragging.emitter.on('pointerdown', this.handlePointerDown);\n            hitDragging.emitter.on('dragend', this.handleDragEnd);\n        }\n    }\n    /*\r\n    Tracks when the user selects a portion of time of a component,\r\n    constituted by a drag over date cells, with a possible delay at the beginning of the drag.\r\n    */ class DateSelecting extends Interaction {\n        destroy() {\n            this.dragging.destroy();\n        }\n        constructor(settings){\n            super(settings);\n            this.dragSelection = null;\n            this.handlePointerDown = (ev)=>{\n                let { component, dragging } = this;\n                let { options } = component.context;\n                let canSelect = options.selectable && component.isValidDateDownEl(ev.origEvent.target);\n                // don't bother to watch expensive moves if component won't do selection\n                dragging.setIgnoreMove(!canSelect);\n                // if touch, require user to hold down\n                dragging.delay = ev.isTouch ? getComponentTouchDelay$1(component) : null;\n            };\n            this.handleDragStart = (ev)=>{\n                this.component.context.calendarApi.unselect(ev); // unselect previous selections\n            };\n            this.handleHitUpdate = (hit, isFinal)=>{\n                let { context } = this.component;\n                let dragSelection = null;\n                let isInvalid = false;\n                if (hit) {\n                    let initialHit = this.hitDragging.initialHit;\n                    let disallowed = hit.componentId === initialHit.componentId && this.isHitComboAllowed && !this.isHitComboAllowed(initialHit, hit);\n                    if (!disallowed) {\n                        dragSelection = joinHitsIntoSelection(initialHit, hit, context.pluginHooks.dateSelectionTransformers);\n                    }\n                    if (!dragSelection || !isDateSelectionValid(dragSelection, hit.dateProfile, context)) {\n                        isInvalid = true;\n                        dragSelection = null;\n                    }\n                }\n                if (dragSelection) {\n                    context.dispatch({\n                        type: 'SELECT_DATES',\n                        selection: dragSelection\n                    });\n                } else if (!isFinal) {\n                    context.dispatch({\n                        type: 'UNSELECT_DATES'\n                    });\n                }\n                if (!isInvalid) {\n                    enableCursor();\n                } else {\n                    disableCursor();\n                }\n                if (!isFinal) {\n                    this.dragSelection = dragSelection; // only clear if moved away from all hits while dragging\n                }\n            };\n            this.handlePointerUp = (pev)=>{\n                if (this.dragSelection) {\n                    // selection is already rendered, so just need to report selection\n                    triggerDateSelect(this.dragSelection, pev, this.component.context);\n                    this.dragSelection = null;\n                }\n            };\n            let { component } = settings;\n            let { options } = component.context;\n            let dragging = this.dragging = new FeaturefulElementDragging(settings.el);\n            dragging.touchScrollAllowed = false;\n            dragging.minDistance = options.selectMinDistance || 0;\n            dragging.autoScroller.isEnabled = options.dragScroll;\n            let hitDragging = this.hitDragging = new HitDragging(this.dragging, interactionSettingsToStore(settings));\n            hitDragging.emitter.on('pointerdown', this.handlePointerDown);\n            hitDragging.emitter.on('dragstart', this.handleDragStart);\n            hitDragging.emitter.on('hitupdate', this.handleHitUpdate);\n            hitDragging.emitter.on('pointerup', this.handlePointerUp);\n        }\n    }\n    function getComponentTouchDelay$1(component) {\n        let { options } = component.context;\n        let delay = options.selectLongPressDelay;\n        if (delay == null) {\n            delay = options.longPressDelay;\n        }\n        return delay;\n    }\n    function joinHitsIntoSelection(hit0, hit1, dateSelectionTransformers) {\n        let dateSpan0 = hit0.dateSpan;\n        let dateSpan1 = hit1.dateSpan;\n        let ms = [\n            dateSpan0.range.start,\n            dateSpan0.range.end,\n            dateSpan1.range.start,\n            dateSpan1.range.end\n        ];\n        ms.sort(compareNumbers);\n        let props = {};\n        for (let transformer of dateSelectionTransformers){\n            let res = transformer(hit0, hit1);\n            if (res === false) {\n                return null;\n            }\n            if (res) {\n                Object.assign(props, res);\n            }\n        }\n        props.range = {\n            start: ms[0],\n            end: ms[3]\n        };\n        props.allDay = dateSpan0.allDay;\n        return props;\n    }\n    class EventDragging extends Interaction {\n        destroy() {\n            this.dragging.destroy();\n        }\n        // render a drag state on the next receivingCalendar\n        displayDrag(nextContext, state) {\n            let initialContext = this.component.context;\n            let prevContext = this.receivingContext;\n            // does the previous calendar need to be cleared?\n            if (prevContext && prevContext !== nextContext) {\n                // does the initial calendar need to be cleared?\n                // if so, don't clear all the way. we still need to to hide the affectedEvents\n                if (prevContext === initialContext) {\n                    prevContext.dispatch({\n                        type: 'SET_EVENT_DRAG',\n                        state: {\n                            affectedEvents: state.affectedEvents,\n                            mutatedEvents: createEmptyEventStore(),\n                            isEvent: true\n                        }\n                    });\n                // completely clear the old calendar if it wasn't the initial\n                } else {\n                    prevContext.dispatch({\n                        type: 'UNSET_EVENT_DRAG'\n                    });\n                }\n            }\n            if (nextContext) {\n                nextContext.dispatch({\n                    type: 'SET_EVENT_DRAG',\n                    state\n                });\n            }\n        }\n        clearDrag() {\n            let initialCalendar = this.component.context;\n            let { receivingContext } = this;\n            if (receivingContext) {\n                receivingContext.dispatch({\n                    type: 'UNSET_EVENT_DRAG'\n                });\n            }\n            // the initial calendar might have an dummy drag state from displayDrag\n            if (initialCalendar !== receivingContext) {\n                initialCalendar.dispatch({\n                    type: 'UNSET_EVENT_DRAG'\n                });\n            }\n        }\n        cleanup() {\n            this.subjectSeg = null;\n            this.isDragging = false;\n            this.eventRange = null;\n            this.relevantEvents = null;\n            this.receivingContext = null;\n            this.validMutation = null;\n            this.mutatedRelevantEvents = null;\n        }\n        constructor(settings){\n            super(settings);\n            // internal state\n            this.subjectEl = null;\n            this.subjectSeg = null; // the seg being selected/dragged\n            this.isDragging = false;\n            this.eventRange = null;\n            this.relevantEvents = null; // the events being dragged\n            this.receivingContext = null;\n            this.validMutation = null;\n            this.mutatedRelevantEvents = null;\n            this.handlePointerDown = (ev)=>{\n                let origTarget = ev.origEvent.target;\n                let { component, dragging } = this;\n                let { mirror } = dragging;\n                let { options } = component.context;\n                let initialContext = component.context;\n                this.subjectEl = ev.subjectEl;\n                let subjectSeg = this.subjectSeg = getElSeg(ev.subjectEl);\n                let eventRange = this.eventRange = subjectSeg.eventRange;\n                let eventInstanceId = eventRange.instance.instanceId;\n                this.relevantEvents = getRelevantEvents(initialContext.getCurrentData().eventStore, eventInstanceId);\n                dragging.minDistance = ev.isTouch ? 0 : options.eventDragMinDistance;\n                dragging.delay = // only do a touch delay if touch and this event hasn't been selected yet\n                ev.isTouch && eventInstanceId !== component.props.eventSelection ? getComponentTouchDelay(component) : null;\n                if (options.fixedMirrorParent) {\n                    mirror.parentNode = options.fixedMirrorParent;\n                } else {\n                    mirror.parentNode = elementClosest(origTarget, '.fc');\n                }\n                mirror.revertDuration = options.dragRevertDuration;\n                let isValid = component.isValidSegDownEl(origTarget) && !elementClosest(origTarget, '.fc-event-resizer'); // NOT on a resizer\n                dragging.setIgnoreMove(!isValid);\n                // disable dragging for elements that are resizable (ie, selectable)\n                // but are not draggable\n                this.isDragging = isValid && ev.subjectEl.classList.contains('fc-event-draggable');\n            };\n            this.handleDragStart = (ev)=>{\n                let initialContext = this.component.context;\n                let eventRange = this.eventRange;\n                let eventInstanceId = eventRange.instance.instanceId;\n                if (ev.isTouch) {\n                    // need to select a different event?\n                    if (eventInstanceId !== this.component.props.eventSelection) {\n                        initialContext.dispatch({\n                            type: 'SELECT_EVENT',\n                            eventInstanceId\n                        });\n                    }\n                } else {\n                    // if now using mouse, but was previous touch interaction, clear selected event\n                    initialContext.dispatch({\n                        type: 'UNSELECT_EVENT'\n                    });\n                }\n                if (this.isDragging) {\n                    initialContext.calendarApi.unselect(ev); // unselect *date* selection\n                    initialContext.emitter.trigger('eventDragStart', {\n                        el: this.subjectEl,\n                        event: new EventImpl(initialContext, eventRange.def, eventRange.instance),\n                        jsEvent: ev.origEvent,\n                        view: initialContext.viewApi\n                    });\n                }\n            };\n            this.handleHitUpdate = (hit, isFinal)=>{\n                if (!this.isDragging) {\n                    return;\n                }\n                let relevantEvents = this.relevantEvents;\n                let initialHit = this.hitDragging.initialHit;\n                let initialContext = this.component.context;\n                // states based on new hit\n                let receivingContext = null;\n                let mutation = null;\n                let mutatedRelevantEvents = null;\n                let isInvalid = false;\n                let interaction = {\n                    affectedEvents: relevantEvents,\n                    mutatedEvents: createEmptyEventStore(),\n                    isEvent: true\n                };\n                if (hit) {\n                    receivingContext = hit.context;\n                    let receivingOptions = receivingContext.options;\n                    if (initialContext === receivingContext || receivingOptions.editable && receivingOptions.droppable) {\n                        mutation = computeEventMutation(initialHit, hit, receivingContext.getCurrentData().pluginHooks.eventDragMutationMassagers);\n                        if (mutation) {\n                            mutatedRelevantEvents = applyMutationToEventStore(relevantEvents, receivingContext.getCurrentData().eventUiBases, mutation, receivingContext);\n                            interaction.mutatedEvents = mutatedRelevantEvents;\n                            if (!isInteractionValid(interaction, hit.dateProfile, receivingContext)) {\n                                isInvalid = true;\n                                mutation = null;\n                                mutatedRelevantEvents = null;\n                                interaction.mutatedEvents = createEmptyEventStore();\n                            }\n                        }\n                    } else {\n                        receivingContext = null;\n                    }\n                }\n                this.displayDrag(receivingContext, interaction);\n                if (!isInvalid) {\n                    enableCursor();\n                } else {\n                    disableCursor();\n                }\n                if (!isFinal) {\n                    if (initialContext === receivingContext && // TODO: write test for this\n                    isHitsEqual(initialHit, hit)) {\n                        mutation = null;\n                    }\n                    this.dragging.setMirrorNeedsRevert(!mutation);\n                    // render the mirror if no already-rendered mirror\n                    // TODO: wish we could somehow wait for dispatch to guarantee render\n                    this.dragging.setMirrorIsVisible(!hit || !this.subjectEl.getRootNode().querySelector('.fc-event-mirror'));\n                    // assign states based on new hit\n                    this.receivingContext = receivingContext;\n                    this.validMutation = mutation;\n                    this.mutatedRelevantEvents = mutatedRelevantEvents;\n                }\n            };\n            this.handlePointerUp = ()=>{\n                if (!this.isDragging) {\n                    this.cleanup(); // because handleDragEnd won't fire\n                }\n            };\n            this.handleDragEnd = (ev)=>{\n                if (this.isDragging) {\n                    let initialContext = this.component.context;\n                    let initialView = initialContext.viewApi;\n                    let { receivingContext, validMutation } = this;\n                    let eventDef = this.eventRange.def;\n                    let eventInstance = this.eventRange.instance;\n                    let eventApi = new EventImpl(initialContext, eventDef, eventInstance);\n                    let relevantEvents = this.relevantEvents;\n                    let mutatedRelevantEvents = this.mutatedRelevantEvents;\n                    let { finalHit } = this.hitDragging;\n                    this.clearDrag(); // must happen after revert animation\n                    initialContext.emitter.trigger('eventDragStop', {\n                        el: this.subjectEl,\n                        event: eventApi,\n                        jsEvent: ev.origEvent,\n                        view: initialView\n                    });\n                    if (validMutation) {\n                        // dropped within same calendar\n                        if (receivingContext === initialContext) {\n                            let updatedEventApi = new EventImpl(initialContext, mutatedRelevantEvents.defs[eventDef.defId], eventInstance ? mutatedRelevantEvents.instances[eventInstance.instanceId] : null);\n                            initialContext.dispatch({\n                                type: 'MERGE_EVENTS',\n                                eventStore: mutatedRelevantEvents\n                            });\n                            let eventChangeArg = {\n                                oldEvent: eventApi,\n                                event: updatedEventApi,\n                                relatedEvents: buildEventApis(mutatedRelevantEvents, initialContext, eventInstance),\n                                revert () {\n                                    initialContext.dispatch({\n                                        type: 'MERGE_EVENTS',\n                                        eventStore: relevantEvents\n                                    });\n                                }\n                            };\n                            let transformed = {};\n                            for (let transformer of initialContext.getCurrentData().pluginHooks.eventDropTransformers){\n                                Object.assign(transformed, transformer(validMutation, initialContext));\n                            }\n                            initialContext.emitter.trigger('eventDrop', Object.assign(Object.assign(Object.assign({}, eventChangeArg), transformed), {\n                                el: ev.subjectEl,\n                                delta: validMutation.datesDelta,\n                                jsEvent: ev.origEvent,\n                                view: initialView\n                            }));\n                            initialContext.emitter.trigger('eventChange', eventChangeArg);\n                        // dropped in different calendar\n                        } else if (receivingContext) {\n                            let eventRemoveArg = {\n                                event: eventApi,\n                                relatedEvents: buildEventApis(relevantEvents, initialContext, eventInstance),\n                                revert () {\n                                    initialContext.dispatch({\n                                        type: 'MERGE_EVENTS',\n                                        eventStore: relevantEvents\n                                    });\n                                }\n                            };\n                            initialContext.emitter.trigger('eventLeave', Object.assign(Object.assign({}, eventRemoveArg), {\n                                draggedEl: ev.subjectEl,\n                                view: initialView\n                            }));\n                            initialContext.dispatch({\n                                type: 'REMOVE_EVENTS',\n                                eventStore: relevantEvents\n                            });\n                            initialContext.emitter.trigger('eventRemove', eventRemoveArg);\n                            let addedEventDef = mutatedRelevantEvents.defs[eventDef.defId];\n                            let addedEventInstance = mutatedRelevantEvents.instances[eventInstance.instanceId];\n                            let addedEventApi = new EventImpl(receivingContext, addedEventDef, addedEventInstance);\n                            receivingContext.dispatch({\n                                type: 'MERGE_EVENTS',\n                                eventStore: mutatedRelevantEvents\n                            });\n                            let eventAddArg = {\n                                event: addedEventApi,\n                                relatedEvents: buildEventApis(mutatedRelevantEvents, receivingContext, addedEventInstance),\n                                revert () {\n                                    receivingContext.dispatch({\n                                        type: 'REMOVE_EVENTS',\n                                        eventStore: mutatedRelevantEvents\n                                    });\n                                }\n                            };\n                            receivingContext.emitter.trigger('eventAdd', eventAddArg);\n                            if (ev.isTouch) {\n                                receivingContext.dispatch({\n                                    type: 'SELECT_EVENT',\n                                    eventInstanceId: eventInstance.instanceId\n                                });\n                            }\n                            receivingContext.emitter.trigger('drop', Object.assign(Object.assign({}, buildDatePointApiWithContext(finalHit.dateSpan, receivingContext)), {\n                                draggedEl: ev.subjectEl,\n                                jsEvent: ev.origEvent,\n                                view: finalHit.context.viewApi\n                            }));\n                            receivingContext.emitter.trigger('eventReceive', Object.assign(Object.assign({}, eventAddArg), {\n                                draggedEl: ev.subjectEl,\n                                view: finalHit.context.viewApi\n                            }));\n                        }\n                    } else {\n                        initialContext.emitter.trigger('_noEventDrop');\n                    }\n                }\n                this.cleanup();\n            };\n            let { component } = this;\n            let { options } = component.context;\n            let dragging = this.dragging = new FeaturefulElementDragging(settings.el);\n            dragging.pointer.selector = EventDragging.SELECTOR;\n            dragging.touchScrollAllowed = false;\n            dragging.autoScroller.isEnabled = options.dragScroll;\n            let hitDragging = this.hitDragging = new HitDragging(this.dragging, interactionSettingsStore);\n            hitDragging.useSubjectCenter = settings.useEventCenter;\n            hitDragging.emitter.on('pointerdown', this.handlePointerDown);\n            hitDragging.emitter.on('dragstart', this.handleDragStart);\n            hitDragging.emitter.on('hitupdate', this.handleHitUpdate);\n            hitDragging.emitter.on('pointerup', this.handlePointerUp);\n            hitDragging.emitter.on('dragend', this.handleDragEnd);\n        }\n    }\n    // TODO: test this in IE11\n    // QUESTION: why do we need it on the resizable???\n    EventDragging.SELECTOR = '.fc-event-draggable, .fc-event-resizable';\n    function computeEventMutation(hit0, hit1, massagers) {\n        let dateSpan0 = hit0.dateSpan;\n        let dateSpan1 = hit1.dateSpan;\n        let date0 = dateSpan0.range.start;\n        let date1 = dateSpan1.range.start;\n        let standardProps = {};\n        if (dateSpan0.allDay !== dateSpan1.allDay) {\n            standardProps.allDay = dateSpan1.allDay;\n            standardProps.hasEnd = hit1.context.options.allDayMaintainDuration;\n            if (dateSpan1.allDay) {\n                // means date1 is already start-of-day,\n                // but date0 needs to be converted\n                date0 = startOfDay(date0);\n            }\n        }\n        let delta = diffDates(date0, date1, hit0.context.dateEnv, hit0.componentId === hit1.componentId ? hit0.largeUnit : null);\n        if (delta.milliseconds) {\n            standardProps.allDay = false;\n        }\n        let mutation = {\n            datesDelta: delta,\n            standardProps\n        };\n        for (let massager of massagers){\n            massager(mutation, hit0, hit1);\n        }\n        return mutation;\n    }\n    function getComponentTouchDelay(component) {\n        let { options } = component.context;\n        let delay = options.eventLongPressDelay;\n        if (delay == null) {\n            delay = options.longPressDelay;\n        }\n        return delay;\n    }\n    class EventResizing extends Interaction {\n        destroy() {\n            this.dragging.destroy();\n        }\n        querySegEl(ev) {\n            return elementClosest(ev.subjectEl, '.fc-event');\n        }\n        constructor(settings){\n            super(settings);\n            // internal state\n            this.draggingSegEl = null;\n            this.draggingSeg = null; // TODO: rename to resizingSeg? subjectSeg?\n            this.eventRange = null;\n            this.relevantEvents = null;\n            this.validMutation = null;\n            this.mutatedRelevantEvents = null;\n            this.handlePointerDown = (ev)=>{\n                let { component } = this;\n                let segEl = this.querySegEl(ev);\n                let seg = getElSeg(segEl);\n                let eventRange = this.eventRange = seg.eventRange;\n                this.dragging.minDistance = component.context.options.eventDragMinDistance;\n                // if touch, need to be working with a selected event\n                this.dragging.setIgnoreMove(!this.component.isValidSegDownEl(ev.origEvent.target) || ev.isTouch && this.component.props.eventSelection !== eventRange.instance.instanceId);\n            };\n            this.handleDragStart = (ev)=>{\n                let { context } = this.component;\n                let eventRange = this.eventRange;\n                this.relevantEvents = getRelevantEvents(context.getCurrentData().eventStore, this.eventRange.instance.instanceId);\n                let segEl = this.querySegEl(ev);\n                this.draggingSegEl = segEl;\n                this.draggingSeg = getElSeg(segEl);\n                context.calendarApi.unselect();\n                context.emitter.trigger('eventResizeStart', {\n                    el: segEl,\n                    event: new EventImpl(context, eventRange.def, eventRange.instance),\n                    jsEvent: ev.origEvent,\n                    view: context.viewApi\n                });\n            };\n            this.handleHitUpdate = (hit, isFinal, ev)=>{\n                let { context } = this.component;\n                let relevantEvents = this.relevantEvents;\n                let initialHit = this.hitDragging.initialHit;\n                let eventInstance = this.eventRange.instance;\n                let mutation = null;\n                let mutatedRelevantEvents = null;\n                let isInvalid = false;\n                let interaction = {\n                    affectedEvents: relevantEvents,\n                    mutatedEvents: createEmptyEventStore(),\n                    isEvent: true\n                };\n                if (hit) {\n                    let disallowed = hit.componentId === initialHit.componentId && this.isHitComboAllowed && !this.isHitComboAllowed(initialHit, hit);\n                    if (!disallowed) {\n                        mutation = computeMutation(initialHit, hit, ev.subjectEl.classList.contains('fc-event-resizer-start'), eventInstance.range);\n                    }\n                }\n                if (mutation) {\n                    mutatedRelevantEvents = applyMutationToEventStore(relevantEvents, context.getCurrentData().eventUiBases, mutation, context);\n                    interaction.mutatedEvents = mutatedRelevantEvents;\n                    if (!isInteractionValid(interaction, hit.dateProfile, context)) {\n                        isInvalid = true;\n                        mutation = null;\n                        mutatedRelevantEvents = null;\n                        interaction.mutatedEvents = null;\n                    }\n                }\n                if (mutatedRelevantEvents) {\n                    context.dispatch({\n                        type: 'SET_EVENT_RESIZE',\n                        state: interaction\n                    });\n                } else {\n                    context.dispatch({\n                        type: 'UNSET_EVENT_RESIZE'\n                    });\n                }\n                if (!isInvalid) {\n                    enableCursor();\n                } else {\n                    disableCursor();\n                }\n                if (!isFinal) {\n                    if (mutation && isHitsEqual(initialHit, hit)) {\n                        mutation = null;\n                    }\n                    this.validMutation = mutation;\n                    this.mutatedRelevantEvents = mutatedRelevantEvents;\n                }\n            };\n            this.handleDragEnd = (ev)=>{\n                let { context } = this.component;\n                let eventDef = this.eventRange.def;\n                let eventInstance = this.eventRange.instance;\n                let eventApi = new EventImpl(context, eventDef, eventInstance);\n                let relevantEvents = this.relevantEvents;\n                let mutatedRelevantEvents = this.mutatedRelevantEvents;\n                context.emitter.trigger('eventResizeStop', {\n                    el: this.draggingSegEl,\n                    event: eventApi,\n                    jsEvent: ev.origEvent,\n                    view: context.viewApi\n                });\n                if (this.validMutation) {\n                    let updatedEventApi = new EventImpl(context, mutatedRelevantEvents.defs[eventDef.defId], eventInstance ? mutatedRelevantEvents.instances[eventInstance.instanceId] : null);\n                    context.dispatch({\n                        type: 'MERGE_EVENTS',\n                        eventStore: mutatedRelevantEvents\n                    });\n                    let eventChangeArg = {\n                        oldEvent: eventApi,\n                        event: updatedEventApi,\n                        relatedEvents: buildEventApis(mutatedRelevantEvents, context, eventInstance),\n                        revert () {\n                            context.dispatch({\n                                type: 'MERGE_EVENTS',\n                                eventStore: relevantEvents\n                            });\n                        }\n                    };\n                    context.emitter.trigger('eventResize', Object.assign(Object.assign({}, eventChangeArg), {\n                        el: this.draggingSegEl,\n                        startDelta: this.validMutation.startDelta || createDuration(0),\n                        endDelta: this.validMutation.endDelta || createDuration(0),\n                        jsEvent: ev.origEvent,\n                        view: context.viewApi\n                    }));\n                    context.emitter.trigger('eventChange', eventChangeArg);\n                } else {\n                    context.emitter.trigger('_noEventResize');\n                }\n                // reset all internal state\n                this.draggingSeg = null;\n                this.relevantEvents = null;\n                this.validMutation = null;\n            // okay to keep eventInstance around. useful to set it in handlePointerDown\n            };\n            let { component } = settings;\n            let dragging = this.dragging = new FeaturefulElementDragging(settings.el);\n            dragging.pointer.selector = '.fc-event-resizer';\n            dragging.touchScrollAllowed = false;\n            dragging.autoScroller.isEnabled = component.context.options.dragScroll;\n            let hitDragging = this.hitDragging = new HitDragging(this.dragging, interactionSettingsToStore(settings));\n            hitDragging.emitter.on('pointerdown', this.handlePointerDown);\n            hitDragging.emitter.on('dragstart', this.handleDragStart);\n            hitDragging.emitter.on('hitupdate', this.handleHitUpdate);\n            hitDragging.emitter.on('dragend', this.handleDragEnd);\n        }\n    }\n    function computeMutation(hit0, hit1, isFromStart, instanceRange) {\n        let dateEnv = hit0.context.dateEnv;\n        let date0 = hit0.dateSpan.range.start;\n        let date1 = hit1.dateSpan.range.start;\n        let delta = diffDates(date0, date1, dateEnv, hit0.largeUnit);\n        if (isFromStart) {\n            if (dateEnv.add(instanceRange.start, delta) < instanceRange.end) {\n                return {\n                    startDelta: delta\n                };\n            }\n        } else if (dateEnv.add(instanceRange.end, delta) > instanceRange.start) {\n            return {\n                endDelta: delta\n            };\n        }\n        return null;\n    }\n    class UnselectAuto {\n        destroy() {\n            this.context.emitter.off('select', this.onSelect);\n            this.documentPointer.destroy();\n        }\n        constructor(context){\n            this.context = context;\n            this.isRecentPointerDateSelect = false; // wish we could use a selector to detect date selection, but uses hit system\n            this.matchesCancel = false;\n            this.matchesEvent = false;\n            this.onSelect = (selectInfo)=>{\n                if (selectInfo.jsEvent) {\n                    this.isRecentPointerDateSelect = true;\n                }\n            };\n            this.onDocumentPointerDown = (pev)=>{\n                let unselectCancel = this.context.options.unselectCancel;\n                let downEl = getEventTargetViaRoot(pev.origEvent);\n                this.matchesCancel = !!elementClosest(downEl, unselectCancel);\n                this.matchesEvent = !!elementClosest(downEl, EventDragging.SELECTOR); // interaction started on an event?\n            };\n            this.onDocumentPointerUp = (pev)=>{\n                let { context } = this;\n                let { documentPointer } = this;\n                let calendarState = context.getCurrentData();\n                // touch-scrolling should never unfocus any type of selection\n                if (!documentPointer.wasTouchScroll) {\n                    if (calendarState.dateSelection && // an existing date selection?\n                    !this.isRecentPointerDateSelect // a new pointer-initiated date selection since last onDocumentPointerUp?\n                    ) {\n                        let unselectAuto = context.options.unselectAuto;\n                        if (unselectAuto && (!unselectAuto || !this.matchesCancel)) {\n                            context.calendarApi.unselect(pev);\n                        }\n                    }\n                    if (calendarState.eventSelection && // an existing event selected?\n                    !this.matchesEvent // interaction DIDN'T start on an event\n                    ) {\n                        context.dispatch({\n                            type: 'UNSELECT_EVENT'\n                        });\n                    }\n                }\n                this.isRecentPointerDateSelect = false;\n            };\n            let documentPointer = this.documentPointer = new PointerDragging(document);\n            documentPointer.shouldIgnoreMove = true;\n            documentPointer.shouldWatchScroll = false;\n            documentPointer.emitter.on('pointerdown', this.onDocumentPointerDown);\n            documentPointer.emitter.on('pointerup', this.onDocumentPointerUp);\n            /*\r\n            TODO: better way to know about whether there was a selection with the pointer\r\n            */ context.emitter.on('select', this.onSelect);\n        }\n    }\n    const OPTION_REFINERS$3 = {\n        fixedMirrorParent: identity\n    };\n    const LISTENER_REFINERS = {\n        dateClick: identity,\n        eventDragStart: identity,\n        eventDragStop: identity,\n        eventDrop: identity,\n        eventResizeStart: identity,\n        eventResizeStop: identity,\n        eventResize: identity,\n        drop: identity,\n        eventReceive: identity,\n        eventLeave: identity\n    };\n    /*\r\n    Given an already instantiated draggable object for one-or-more elements,\r\n    Interprets any dragging as an attempt to drag an events that lives outside\r\n    of a calendar onto a calendar.\r\n    */ class ExternalElementDragging {\n        buildDragMeta(subjectEl) {\n            if (typeof this.suppliedDragMeta === 'object') {\n                return parseDragMeta(this.suppliedDragMeta);\n            }\n            if (typeof this.suppliedDragMeta === 'function') {\n                return parseDragMeta(this.suppliedDragMeta(subjectEl));\n            }\n            return getDragMetaFromEl(subjectEl);\n        }\n        displayDrag(nextContext, state) {\n            let prevContext = this.receivingContext;\n            if (prevContext && prevContext !== nextContext) {\n                prevContext.dispatch({\n                    type: 'UNSET_EVENT_DRAG'\n                });\n            }\n            if (nextContext) {\n                nextContext.dispatch({\n                    type: 'SET_EVENT_DRAG',\n                    state\n                });\n            }\n        }\n        clearDrag() {\n            if (this.receivingContext) {\n                this.receivingContext.dispatch({\n                    type: 'UNSET_EVENT_DRAG'\n                });\n            }\n        }\n        canDropElOnCalendar(el, receivingContext) {\n            let dropAccept = receivingContext.options.dropAccept;\n            if (typeof dropAccept === 'function') {\n                return dropAccept.call(receivingContext.calendarApi, el);\n            }\n            if (typeof dropAccept === 'string' && dropAccept) {\n                return Boolean(elementMatches(el, dropAccept));\n            }\n            return true;\n        }\n        constructor(dragging, suppliedDragMeta){\n            this.receivingContext = null;\n            this.droppableEvent = null; // will exist for all drags, even if create:false\n            this.suppliedDragMeta = null;\n            this.dragMeta = null;\n            this.handleDragStart = (ev)=>{\n                this.dragMeta = this.buildDragMeta(ev.subjectEl);\n            };\n            this.handleHitUpdate = (hit, isFinal, ev)=>{\n                let { dragging } = this.hitDragging;\n                let receivingContext = null;\n                let droppableEvent = null;\n                let isInvalid = false;\n                let interaction = {\n                    affectedEvents: createEmptyEventStore(),\n                    mutatedEvents: createEmptyEventStore(),\n                    isEvent: this.dragMeta.create\n                };\n                if (hit) {\n                    receivingContext = hit.context;\n                    if (this.canDropElOnCalendar(ev.subjectEl, receivingContext)) {\n                        droppableEvent = computeEventForDateSpan(hit.dateSpan, this.dragMeta, receivingContext);\n                        interaction.mutatedEvents = eventTupleToStore(droppableEvent);\n                        isInvalid = !isInteractionValid(interaction, hit.dateProfile, receivingContext);\n                        if (isInvalid) {\n                            interaction.mutatedEvents = createEmptyEventStore();\n                            droppableEvent = null;\n                        }\n                    }\n                }\n                this.displayDrag(receivingContext, interaction);\n                // show mirror if no already-rendered mirror element OR if we are shutting down the mirror (?)\n                // TODO: wish we could somehow wait for dispatch to guarantee render\n                dragging.setMirrorIsVisible(isFinal || !droppableEvent || !document.querySelector('.fc-event-mirror'));\n                if (!isInvalid) {\n                    enableCursor();\n                } else {\n                    disableCursor();\n                }\n                if (!isFinal) {\n                    dragging.setMirrorNeedsRevert(!droppableEvent);\n                    this.receivingContext = receivingContext;\n                    this.droppableEvent = droppableEvent;\n                }\n            };\n            this.handleDragEnd = (pev)=>{\n                let { receivingContext, droppableEvent } = this;\n                this.clearDrag();\n                if (receivingContext && droppableEvent) {\n                    let finalHit = this.hitDragging.finalHit;\n                    let finalView = finalHit.context.viewApi;\n                    let dragMeta = this.dragMeta;\n                    receivingContext.emitter.trigger('drop', Object.assign(Object.assign({}, buildDatePointApiWithContext(finalHit.dateSpan, receivingContext)), {\n                        draggedEl: pev.subjectEl,\n                        jsEvent: pev.origEvent,\n                        view: finalView\n                    }));\n                    if (dragMeta.create) {\n                        let addingEvents = eventTupleToStore(droppableEvent);\n                        receivingContext.dispatch({\n                            type: 'MERGE_EVENTS',\n                            eventStore: addingEvents\n                        });\n                        if (pev.isTouch) {\n                            receivingContext.dispatch({\n                                type: 'SELECT_EVENT',\n                                eventInstanceId: droppableEvent.instance.instanceId\n                            });\n                        }\n                        // signal that an external event landed\n                        receivingContext.emitter.trigger('eventReceive', {\n                            event: new EventImpl(receivingContext, droppableEvent.def, droppableEvent.instance),\n                            relatedEvents: [],\n                            revert () {\n                                receivingContext.dispatch({\n                                    type: 'REMOVE_EVENTS',\n                                    eventStore: addingEvents\n                                });\n                            },\n                            draggedEl: pev.subjectEl,\n                            view: finalView\n                        });\n                    }\n                }\n                this.receivingContext = null;\n                this.droppableEvent = null;\n            };\n            let hitDragging = this.hitDragging = new HitDragging(dragging, interactionSettingsStore);\n            hitDragging.requireInitial = false; // will start outside of a component\n            hitDragging.emitter.on('dragstart', this.handleDragStart);\n            hitDragging.emitter.on('hitupdate', this.handleHitUpdate);\n            hitDragging.emitter.on('dragend', this.handleDragEnd);\n            this.suppliedDragMeta = suppliedDragMeta;\n        }\n    }\n    // Utils for computing event store from the DragMeta\n    // ----------------------------------------------------------------------------------------------------\n    function computeEventForDateSpan(dateSpan, dragMeta, context) {\n        let defProps = Object.assign({}, dragMeta.leftoverProps);\n        for (let transform of context.pluginHooks.externalDefTransforms){\n            Object.assign(defProps, transform(dateSpan, dragMeta));\n        }\n        let { refined, extra } = refineEventDef(defProps, context);\n        let def = parseEventDef(refined, extra, dragMeta.sourceId, dateSpan.allDay, context.options.forceEventDuration || Boolean(dragMeta.duration), context);\n        let start = dateSpan.range.start;\n        // only rely on time info if drop zone is all-day,\n        // otherwise, we already know the time\n        if (dateSpan.allDay && dragMeta.startTime) {\n            start = context.dateEnv.add(start, dragMeta.startTime);\n        }\n        let end = dragMeta.duration ? context.dateEnv.add(start, dragMeta.duration) : getDefaultEventEnd(dateSpan.allDay, start, context);\n        let instance = createEventInstance(def.defId, {\n            start,\n            end\n        });\n        return {\n            def,\n            instance\n        };\n    }\n    // Utils for extracting data from element\n    // ----------------------------------------------------------------------------------------------------\n    function getDragMetaFromEl(el) {\n        let str = getEmbeddedElData(el, 'event');\n        let obj = str ? JSON.parse(str) : {\n            create: false\n        }; // if no embedded data, assume no event creation\n        return parseDragMeta(obj);\n    }\n    config.dataAttrPrefix = '';\n    function getEmbeddedElData(el, name) {\n        let prefix = config.dataAttrPrefix;\n        let prefixedName = (prefix ? prefix + '-' : '') + name;\n        return el.getAttribute('data-' + prefixedName) || '';\n    }\n    /*\r\n    Makes an element (that is *external* to any calendar) draggable.\r\n    Can pass in data that determines how an event will be created when dropped onto a calendar.\r\n    Leverages FullCalendar's internal drag-n-drop functionality WITHOUT a third-party drag system.\r\n    */ class ExternalDraggable {\n        destroy() {\n            this.dragging.destroy();\n        }\n        constructor(el, settings = {}){\n            this.handlePointerDown = (ev)=>{\n                let { dragging } = this;\n                let { minDistance, longPressDelay } = this.settings;\n                dragging.minDistance = minDistance != null ? minDistance : ev.isTouch ? 0 : BASE_OPTION_DEFAULTS.eventDragMinDistance;\n                dragging.delay = ev.isTouch ? longPressDelay != null ? longPressDelay : BASE_OPTION_DEFAULTS.longPressDelay : 0;\n            };\n            this.handleDragStart = (ev)=>{\n                if (ev.isTouch && this.dragging.delay && ev.subjectEl.classList.contains('fc-event')) {\n                    this.dragging.mirror.getMirrorEl().classList.add('fc-event-selected');\n                }\n            };\n            this.settings = settings;\n            let dragging = this.dragging = new FeaturefulElementDragging(el);\n            dragging.touchScrollAllowed = false;\n            if (settings.itemSelector != null) {\n                dragging.pointer.selector = settings.itemSelector;\n            }\n            if (settings.appendTo != null) {\n                dragging.mirror.parentNode = settings.appendTo; // TODO: write tests\n            }\n            dragging.emitter.on('pointerdown', this.handlePointerDown);\n            dragging.emitter.on('dragstart', this.handleDragStart);\n            new ExternalElementDragging(dragging, settings.eventData); // eslint-disable-line no-new\n        }\n    }\n    /*\r\n    Detects when a *THIRD-PARTY* drag-n-drop system interacts with elements.\r\n    The third-party system is responsible for drawing the visuals effects of the drag.\r\n    This class simply monitors for pointer movements and fires events.\r\n    It also has the ability to hide the moving element (the \"mirror\") during the drag.\r\n    */ class InferredElementDragging extends ElementDragging {\n        destroy() {\n            this.pointer.destroy();\n        }\n        setIgnoreMove(bool) {\n            this.shouldIgnoreMove = bool;\n        }\n        setMirrorIsVisible(bool) {\n            if (bool) {\n                // restore a previously hidden element.\n                // use the reference in case the selector class has already been removed.\n                if (this.currentMirrorEl) {\n                    this.currentMirrorEl.style.visibility = '';\n                    this.currentMirrorEl = null;\n                }\n            } else {\n                let mirrorEl = this.mirrorSelector ? document.querySelector(this.mirrorSelector) : null;\n                if (mirrorEl) {\n                    this.currentMirrorEl = mirrorEl;\n                    mirrorEl.style.visibility = 'hidden';\n                }\n            }\n        }\n        constructor(containerEl){\n            super(containerEl);\n            this.shouldIgnoreMove = false;\n            this.mirrorSelector = '';\n            this.currentMirrorEl = null;\n            this.handlePointerDown = (ev)=>{\n                this.emitter.trigger('pointerdown', ev);\n                if (!this.shouldIgnoreMove) {\n                    // fire dragstart right away. does not support delay or min-distance\n                    this.emitter.trigger('dragstart', ev);\n                }\n            };\n            this.handlePointerMove = (ev)=>{\n                if (!this.shouldIgnoreMove) {\n                    this.emitter.trigger('dragmove', ev);\n                }\n            };\n            this.handlePointerUp = (ev)=>{\n                this.emitter.trigger('pointerup', ev);\n                if (!this.shouldIgnoreMove) {\n                    // fire dragend right away. does not support a revert animation\n                    this.emitter.trigger('dragend', ev);\n                }\n            };\n            let pointer = this.pointer = new PointerDragging(containerEl);\n            pointer.emitter.on('pointerdown', this.handlePointerDown);\n            pointer.emitter.on('pointermove', this.handlePointerMove);\n            pointer.emitter.on('pointerup', this.handlePointerUp);\n        }\n    }\n    /*\r\n    Bridges third-party drag-n-drop systems with FullCalendar.\r\n    Must be instantiated and destroyed by caller.\r\n    */ class ThirdPartyDraggable {\n        destroy() {\n            this.dragging.destroy();\n        }\n        constructor(containerOrSettings, settings){\n            let containerEl = document;\n            if (// wish we could just test instanceof EventTarget, but doesn't work in IE11\n            containerOrSettings === document || containerOrSettings instanceof Element) {\n                containerEl = containerOrSettings;\n                settings = settings || {};\n            } else {\n                settings = containerOrSettings || {};\n            }\n            let dragging = this.dragging = new InferredElementDragging(containerEl);\n            if (typeof settings.itemSelector === 'string') {\n                dragging.pointer.selector = settings.itemSelector;\n            } else if (containerEl === document) {\n                dragging.pointer.selector = '[data-event]';\n            }\n            if (typeof settings.mirrorSelector === 'string') {\n                dragging.mirrorSelector = settings.mirrorSelector;\n            }\n            new ExternalElementDragging(dragging, settings.eventData); // eslint-disable-line no-new\n        }\n    }\n    var index$4 = createPlugin({\n        name: '@fullcalendar/interaction',\n        componentInteractions: [\n            DateClicking,\n            DateSelecting,\n            EventDragging,\n            EventResizing\n        ],\n        calendarInteractions: [\n            UnselectAuto\n        ],\n        elementDraggingImpl: FeaturefulElementDragging,\n        optionRefiners: OPTION_REFINERS$3,\n        listenerRefiners: LISTENER_REFINERS\n    });\n    var css_248z$3 = \":root{--fc-daygrid-event-dot-width:8px}.fc-daygrid-day-events:after,.fc-daygrid-day-events:before,.fc-daygrid-day-frame:after,.fc-daygrid-day-frame:before,.fc-daygrid-event-harness:after,.fc-daygrid-event-harness:before{clear:both;content:\\\"\\\";display:table}.fc .fc-daygrid-body{position:relative;z-index:1}.fc .fc-daygrid-day.fc-day-today{background-color:var(--fc-today-bg-color)}.fc .fc-daygrid-day-frame{min-height:100%;position:relative}.fc .fc-daygrid-day-top{display:flex;flex-direction:row-reverse}.fc .fc-day-other .fc-daygrid-day-top{opacity:.3}.fc .fc-daygrid-day-number{padding:4px;position:relative;z-index:4}.fc .fc-daygrid-month-start{font-size:1.1em;font-weight:700}.fc .fc-daygrid-day-events{margin-top:1px}.fc .fc-daygrid-body-balanced .fc-daygrid-day-events{left:0;position:absolute;right:0}.fc .fc-daygrid-body-unbalanced .fc-daygrid-day-events{min-height:2em;position:relative}.fc .fc-daygrid-body-natural .fc-daygrid-day-events{margin-bottom:1em}.fc .fc-daygrid-event-harness{position:relative}.fc .fc-daygrid-event-harness-abs{left:0;position:absolute;right:0;top:0}.fc .fc-daygrid-bg-harness{bottom:0;position:absolute;top:0}.fc .fc-daygrid-day-bg .fc-non-business{z-index:1}.fc .fc-daygrid-day-bg .fc-bg-event{z-index:2}.fc .fc-daygrid-day-bg .fc-highlight{z-index:3}.fc .fc-daygrid-event{margin-top:1px;z-index:6}.fc .fc-daygrid-event.fc-event-mirror{z-index:7}.fc .fc-daygrid-day-bottom{font-size:.85em;margin:0 2px}.fc .fc-daygrid-day-bottom:after,.fc .fc-daygrid-day-bottom:before{clear:both;content:\\\"\\\";display:table}.fc .fc-daygrid-more-link{border-radius:3px;cursor:pointer;line-height:1;margin-top:1px;max-width:100%;overflow:hidden;padding:2px;position:relative;white-space:nowrap;z-index:4}.fc .fc-daygrid-more-link:hover{background-color:rgba(0,0,0,.1)}.fc .fc-daygrid-week-number{background-color:var(--fc-neutral-bg-color);color:var(--fc-neutral-text-color);min-width:1.5em;padding:2px;position:absolute;text-align:center;top:0;z-index:5}.fc .fc-more-popover .fc-popover-body{min-width:220px;padding:10px}.fc-direction-ltr .fc-daygrid-event.fc-event-start,.fc-direction-rtl .fc-daygrid-event.fc-event-end{margin-left:2px}.fc-direction-ltr .fc-daygrid-event.fc-event-end,.fc-direction-rtl .fc-daygrid-event.fc-event-start{margin-right:2px}.fc-direction-ltr .fc-daygrid-more-link{float:left}.fc-direction-ltr .fc-daygrid-week-number{border-radius:0 0 3px 0;left:0}.fc-direction-rtl .fc-daygrid-more-link{float:right}.fc-direction-rtl .fc-daygrid-week-number{border-radius:0 0 0 3px;right:0}.fc-liquid-hack .fc-daygrid-day-frame{position:static}.fc-daygrid-event{border-radius:3px;font-size:var(--fc-small-font-size);position:relative;white-space:nowrap}.fc-daygrid-block-event .fc-event-time{font-weight:700}.fc-daygrid-block-event .fc-event-time,.fc-daygrid-block-event .fc-event-title{padding:1px}.fc-daygrid-dot-event{align-items:center;display:flex;padding:2px 0}.fc-daygrid-dot-event .fc-event-title{flex-grow:1;flex-shrink:1;font-weight:700;min-width:0;overflow:hidden}.fc-daygrid-dot-event.fc-event-mirror,.fc-daygrid-dot-event:hover{background:rgba(0,0,0,.1)}.fc-daygrid-dot-event.fc-event-selected:before{bottom:-10px;top:-10px}.fc-daygrid-event-dot{border:calc(var(--fc-daygrid-event-dot-width)/2) solid var(--fc-event-border-color);border-radius:calc(var(--fc-daygrid-event-dot-width)/2);box-sizing:content-box;height:0;margin:0 4px;width:0}.fc-direction-ltr .fc-daygrid-event .fc-event-time{margin-right:3px}.fc-direction-rtl .fc-daygrid-event .fc-event-time{margin-left:3px}\";\n    injectStyles(css_248z$3);\n    function splitSegsByRow(segs, rowCnt) {\n        let byRow = [];\n        for(let i = 0; i < rowCnt; i += 1){\n            byRow[i] = [];\n        }\n        for (let seg of segs){\n            byRow[seg.row].push(seg);\n        }\n        return byRow;\n    }\n    function splitSegsByFirstCol(segs, colCnt) {\n        let byCol = [];\n        for(let i = 0; i < colCnt; i += 1){\n            byCol[i] = [];\n        }\n        for (let seg of segs){\n            byCol[seg.firstCol].push(seg);\n        }\n        return byCol;\n    }\n    function splitInteractionByRow(ui, rowCnt) {\n        let byRow = [];\n        if (!ui) {\n            for(let i = 0; i < rowCnt; i += 1){\n                byRow[i] = null;\n            }\n        } else {\n            for(let i = 0; i < rowCnt; i += 1){\n                byRow[i] = {\n                    affectedInstances: ui.affectedInstances,\n                    isEvent: ui.isEvent,\n                    segs: []\n                };\n            }\n            for (let seg of ui.segs){\n                byRow[seg.row].segs.push(seg);\n            }\n        }\n        return byRow;\n    }\n    const DEFAULT_TABLE_EVENT_TIME_FORMAT = createFormatter({\n        hour: 'numeric',\n        minute: '2-digit',\n        omitZeroMinute: true,\n        meridiem: 'narrow'\n    });\n    function hasListItemDisplay(seg) {\n        let { display } = seg.eventRange.ui;\n        return display === 'list-item' || display === 'auto' && !seg.eventRange.def.allDay && seg.firstCol === seg.lastCol && // can't be multi-day\n        seg.isStart && // \"\n        seg.isEnd // \"\n        ;\n    }\n    class TableBlockEvent extends BaseComponent {\n        render() {\n            let { props } = this;\n            return y(StandardEvent, Object.assign({}, props, {\n                elClasses: [\n                    'fc-daygrid-event',\n                    'fc-daygrid-block-event',\n                    'fc-h-event'\n                ],\n                defaultTimeFormat: DEFAULT_TABLE_EVENT_TIME_FORMAT,\n                defaultDisplayEventEnd: props.defaultDisplayEventEnd,\n                disableResizing: !props.seg.eventRange.def.allDay\n            }));\n        }\n    }\n    class TableListItemEvent extends BaseComponent {\n        render() {\n            let { props, context } = this;\n            let { options } = context;\n            let { seg } = props;\n            let timeFormat = options.eventTimeFormat || DEFAULT_TABLE_EVENT_TIME_FORMAT;\n            let timeText = buildSegTimeText(seg, timeFormat, context, true, props.defaultDisplayEventEnd);\n            return y(EventContainer, Object.assign({}, props, {\n                elTag: \"a\",\n                elClasses: [\n                    'fc-daygrid-event',\n                    'fc-daygrid-dot-event'\n                ],\n                elAttrs: getSegAnchorAttrs(props.seg, context),\n                defaultGenerator: renderInnerContent$2,\n                timeText: timeText,\n                isResizing: false,\n                isDateSelecting: false\n            }));\n        }\n    }\n    function renderInnerContent$2(renderProps) {\n        return y(_, null, y(\"div\", {\n            className: \"fc-daygrid-event-dot\",\n            style: {\n                borderColor: renderProps.borderColor || renderProps.backgroundColor\n            }\n        }), renderProps.timeText && y(\"div\", {\n            className: \"fc-event-time\"\n        }, renderProps.timeText), y(\"div\", {\n            className: \"fc-event-title\"\n        }, renderProps.event.title || y(_, null, \"\\u00A0\")));\n    }\n    class TableCellMoreLink extends BaseComponent {\n        render() {\n            let { props } = this;\n            let { allSegs, invisibleSegs } = this.compileSegs(props.singlePlacements);\n            return y(MoreLinkContainer, {\n                elClasses: [\n                    'fc-daygrid-more-link'\n                ],\n                dateProfile: props.dateProfile,\n                todayRange: props.todayRange,\n                allDayDate: props.allDayDate,\n                moreCnt: props.moreCnt,\n                allSegs: allSegs,\n                hiddenSegs: invisibleSegs,\n                alignmentElRef: props.alignmentElRef,\n                alignGridTop: props.alignGridTop,\n                extraDateSpan: props.extraDateSpan,\n                popoverContent: ()=>{\n                    let isForcedInvisible = (props.eventDrag ? props.eventDrag.affectedInstances : null) || (props.eventResize ? props.eventResize.affectedInstances : null) || {};\n                    return y(_, null, allSegs.map((seg)=>{\n                        let instanceId = seg.eventRange.instance.instanceId;\n                        return y(\"div\", {\n                            className: \"fc-daygrid-event-harness\",\n                            key: instanceId,\n                            style: {\n                                visibility: isForcedInvisible[instanceId] ? 'hidden' : ''\n                            }\n                        }, hasListItemDisplay(seg) ? y(TableListItemEvent, Object.assign({\n                            seg: seg,\n                            isDragging: false,\n                            isSelected: instanceId === props.eventSelection,\n                            defaultDisplayEventEnd: false\n                        }, getSegMeta(seg, props.todayRange))) : y(TableBlockEvent, Object.assign({\n                            seg: seg,\n                            isDragging: false,\n                            isResizing: false,\n                            isDateSelecting: false,\n                            isSelected: instanceId === props.eventSelection,\n                            defaultDisplayEventEnd: false\n                        }, getSegMeta(seg, props.todayRange))));\n                    }));\n                }\n            });\n        }\n        constructor(){\n            super(...arguments);\n            this.compileSegs = memoize(compileSegs);\n        }\n    }\n    function compileSegs(singlePlacements) {\n        let allSegs = [];\n        let invisibleSegs = [];\n        for (let placement of singlePlacements){\n            allSegs.push(placement.seg);\n            if (!placement.isVisible) {\n                invisibleSegs.push(placement.seg);\n            }\n        }\n        return {\n            allSegs,\n            invisibleSegs\n        };\n    }\n    const DEFAULT_WEEK_NUM_FORMAT$1 = createFormatter({\n        week: 'narrow'\n    });\n    class TableCell extends DateComponent {\n        render() {\n            let { context, props, state, rootElRef } = this;\n            let { options, dateEnv } = context;\n            let { date, dateProfile } = props;\n            // TODO: memoize this?\n            const isMonthStart = props.showDayNumber && shouldDisplayMonthStart(date, dateProfile.currentRange, dateEnv);\n            return y(DayCellContainer, {\n                elTag: \"td\",\n                elRef: this.handleRootEl,\n                elClasses: [\n                    'fc-daygrid-day',\n                    ...props.extraClassNames || []\n                ],\n                elAttrs: Object.assign(Object.assign(Object.assign({}, props.extraDataAttrs), props.showDayNumber ? {\n                    'aria-labelledby': state.dayNumberId\n                } : {}), {\n                    role: 'gridcell'\n                }),\n                defaultGenerator: renderTopInner,\n                date: date,\n                dateProfile: dateProfile,\n                todayRange: props.todayRange,\n                showDayNumber: props.showDayNumber,\n                isMonthStart: isMonthStart,\n                extraRenderProps: props.extraRenderProps\n            }, (InnerContent, renderProps)=>y(\"div\", {\n                    ref: props.innerElRef,\n                    className: \"fc-daygrid-day-frame fc-scrollgrid-sync-inner\",\n                    style: {\n                        minHeight: props.minHeight\n                    }\n                }, props.showWeekNumber && y(WeekNumberContainer, {\n                    elTag: \"a\",\n                    elClasses: [\n                        'fc-daygrid-week-number'\n                    ],\n                    elAttrs: buildNavLinkAttrs(context, date, 'week'),\n                    date: date,\n                    defaultFormat: DEFAULT_WEEK_NUM_FORMAT$1\n                }), !renderProps.isDisabled && (props.showDayNumber || hasCustomDayCellContent(options) || props.forceDayTop) ? y(\"div\", {\n                    className: \"fc-daygrid-day-top\"\n                }, y(InnerContent, {\n                    elTag: \"a\",\n                    elClasses: [\n                        'fc-daygrid-day-number',\n                        isMonthStart && 'fc-daygrid-month-start'\n                    ],\n                    elAttrs: Object.assign(Object.assign({}, buildNavLinkAttrs(context, date)), {\n                        id: state.dayNumberId\n                    })\n                })) : props.showDayNumber ? // for creating correct amount of space (see issue #7162)\n                y(\"div\", {\n                    className: \"fc-daygrid-day-top\",\n                    style: {\n                        visibility: 'hidden'\n                    }\n                }, y(\"a\", {\n                    className: \"fc-daygrid-day-number\"\n                }, \"\\u00A0\")) : undefined, y(\"div\", {\n                    className: \"fc-daygrid-day-events\",\n                    ref: props.fgContentElRef\n                }, props.fgContent, y(\"div\", {\n                    className: \"fc-daygrid-day-bottom\",\n                    style: {\n                        marginTop: props.moreMarginTop\n                    }\n                }, y(TableCellMoreLink, {\n                    allDayDate: date,\n                    singlePlacements: props.singlePlacements,\n                    moreCnt: props.moreCnt,\n                    alignmentElRef: rootElRef,\n                    alignGridTop: !props.showDayNumber,\n                    extraDateSpan: props.extraDateSpan,\n                    dateProfile: props.dateProfile,\n                    eventSelection: props.eventSelection,\n                    eventDrag: props.eventDrag,\n                    eventResize: props.eventResize,\n                    todayRange: props.todayRange\n                }))), y(\"div\", {\n                    className: \"fc-daygrid-day-bg\"\n                }, props.bgContent)));\n        }\n        constructor(){\n            super(...arguments);\n            this.rootElRef = d();\n            this.state = {\n                dayNumberId: getUniqueDomId()\n            };\n            this.handleRootEl = (el)=>{\n                setRef(this.rootElRef, el);\n                setRef(this.props.elRef, el);\n            };\n        }\n    }\n    function renderTopInner(props) {\n        return props.dayNumberText || y(_, null, \"\\u00A0\");\n    }\n    function shouldDisplayMonthStart(date, currentRange, dateEnv) {\n        const { start: currentStart, end: currentEnd } = currentRange;\n        const currentEndIncl = addMs(currentEnd, -1);\n        const currentFirstYear = dateEnv.getYear(currentStart);\n        const currentFirstMonth = dateEnv.getMonth(currentStart);\n        const currentLastYear = dateEnv.getYear(currentEndIncl);\n        const currentLastMonth = dateEnv.getMonth(currentEndIncl);\n        // spans more than one month?\n        return !(currentFirstYear === currentLastYear && currentFirstMonth === currentLastMonth) && Boolean(// first date in current view?\n        date.valueOf() === currentStart.valueOf() || // a month-start that's within the current range?\n        dateEnv.getDay(date) === 1 && date.valueOf() < currentEnd.valueOf());\n    }\n    function computeFgSegPlacement(segs, dayMaxEvents, dayMaxEventRows, strictOrder, eventInstanceHeights, maxContentHeight, cells) {\n        let hierarchy = new DayGridSegHierarchy();\n        hierarchy.allowReslicing = true;\n        hierarchy.strictOrder = strictOrder;\n        if (dayMaxEvents === true || dayMaxEventRows === true) {\n            hierarchy.maxCoord = maxContentHeight;\n            hierarchy.hiddenConsumes = true;\n        } else if (typeof dayMaxEvents === 'number') {\n            hierarchy.maxStackCnt = dayMaxEvents;\n        } else if (typeof dayMaxEventRows === 'number') {\n            hierarchy.maxStackCnt = dayMaxEventRows;\n            hierarchy.hiddenConsumes = true;\n        }\n        // create segInputs only for segs with known heights\n        let segInputs = [];\n        let unknownHeightSegs = [];\n        for(let i = 0; i < segs.length; i += 1){\n            let seg = segs[i];\n            let { instanceId } = seg.eventRange.instance;\n            let eventHeight = eventInstanceHeights[instanceId];\n            if (eventHeight != null) {\n                segInputs.push({\n                    index: i,\n                    thickness: eventHeight,\n                    span: {\n                        start: seg.firstCol,\n                        end: seg.lastCol + 1\n                    }\n                });\n            } else {\n                unknownHeightSegs.push(seg);\n            }\n        }\n        let hiddenEntries = hierarchy.addSegs(segInputs);\n        let segRects = hierarchy.toRects();\n        let { singleColPlacements, multiColPlacements, leftoverMargins } = placeRects(segRects, segs, cells);\n        let moreCnts = [];\n        let moreMarginTops = [];\n        // add segs with unknown heights\n        for (let seg of unknownHeightSegs){\n            multiColPlacements[seg.firstCol].push({\n                seg,\n                isVisible: false,\n                isAbsolute: true,\n                absoluteTop: 0,\n                marginTop: 0\n            });\n            for(let col = seg.firstCol; col <= seg.lastCol; col += 1){\n                singleColPlacements[col].push({\n                    seg: resliceSeg(seg, col, col + 1, cells),\n                    isVisible: false,\n                    isAbsolute: false,\n                    absoluteTop: 0,\n                    marginTop: 0\n                });\n            }\n        }\n        // add the hidden entries\n        for(let col = 0; col < cells.length; col += 1){\n            moreCnts.push(0);\n        }\n        for (let hiddenEntry of hiddenEntries){\n            let seg = segs[hiddenEntry.index];\n            let hiddenSpan = hiddenEntry.span;\n            multiColPlacements[hiddenSpan.start].push({\n                seg: resliceSeg(seg, hiddenSpan.start, hiddenSpan.end, cells),\n                isVisible: false,\n                isAbsolute: true,\n                absoluteTop: 0,\n                marginTop: 0\n            });\n            for(let col = hiddenSpan.start; col < hiddenSpan.end; col += 1){\n                moreCnts[col] += 1;\n                singleColPlacements[col].push({\n                    seg: resliceSeg(seg, col, col + 1, cells),\n                    isVisible: false,\n                    isAbsolute: false,\n                    absoluteTop: 0,\n                    marginTop: 0\n                });\n            }\n        }\n        // deal with leftover margins\n        for(let col = 0; col < cells.length; col += 1){\n            moreMarginTops.push(leftoverMargins[col]);\n        }\n        return {\n            singleColPlacements,\n            multiColPlacements,\n            moreCnts,\n            moreMarginTops\n        };\n    }\n    // rects ordered by top coord, then left\n    function placeRects(allRects, segs, cells) {\n        let rectsByEachCol = groupRectsByEachCol(allRects, cells.length);\n        let singleColPlacements = [];\n        let multiColPlacements = [];\n        let leftoverMargins = [];\n        for(let col = 0; col < cells.length; col += 1){\n            let rects = rectsByEachCol[col];\n            // compute all static segs in singlePlacements\n            let singlePlacements = [];\n            let currentHeight = 0;\n            let currentMarginTop = 0;\n            for (let rect of rects){\n                let seg = segs[rect.index];\n                singlePlacements.push({\n                    seg: resliceSeg(seg, col, col + 1, cells),\n                    isVisible: true,\n                    isAbsolute: false,\n                    absoluteTop: rect.levelCoord,\n                    marginTop: rect.levelCoord - currentHeight\n                });\n                currentHeight = rect.levelCoord + rect.thickness;\n            }\n            // compute mixed static/absolute segs in multiPlacements\n            let multiPlacements = [];\n            currentHeight = 0;\n            currentMarginTop = 0;\n            for (let rect of rects){\n                let seg = segs[rect.index];\n                let isAbsolute = rect.span.end - rect.span.start > 1; // multi-column?\n                let isFirstCol = rect.span.start === col;\n                currentMarginTop += rect.levelCoord - currentHeight; // amount of space since bottom of previous seg\n                currentHeight = rect.levelCoord + rect.thickness; // height will now be bottom of current seg\n                if (isAbsolute) {\n                    currentMarginTop += rect.thickness;\n                    if (isFirstCol) {\n                        multiPlacements.push({\n                            seg: resliceSeg(seg, rect.span.start, rect.span.end, cells),\n                            isVisible: true,\n                            isAbsolute: true,\n                            absoluteTop: rect.levelCoord,\n                            marginTop: 0\n                        });\n                    }\n                } else if (isFirstCol) {\n                    multiPlacements.push({\n                        seg: resliceSeg(seg, rect.span.start, rect.span.end, cells),\n                        isVisible: true,\n                        isAbsolute: false,\n                        absoluteTop: rect.levelCoord,\n                        marginTop: currentMarginTop\n                    });\n                    currentMarginTop = 0;\n                }\n            }\n            singleColPlacements.push(singlePlacements);\n            multiColPlacements.push(multiPlacements);\n            leftoverMargins.push(currentMarginTop);\n        }\n        return {\n            singleColPlacements,\n            multiColPlacements,\n            leftoverMargins\n        };\n    }\n    function groupRectsByEachCol(rects, colCnt) {\n        let rectsByEachCol = [];\n        for(let col = 0; col < colCnt; col += 1){\n            rectsByEachCol.push([]);\n        }\n        for (let rect of rects){\n            for(let col = rect.span.start; col < rect.span.end; col += 1){\n                rectsByEachCol[col].push(rect);\n            }\n        }\n        return rectsByEachCol;\n    }\n    function resliceSeg(seg, spanStart, spanEnd, cells) {\n        if (seg.firstCol === spanStart && seg.lastCol === spanEnd - 1) {\n            return seg;\n        }\n        let eventRange = seg.eventRange;\n        let origRange = eventRange.range;\n        let slicedRange = intersectRanges(origRange, {\n            start: cells[spanStart].date,\n            end: addDays(cells[spanEnd - 1].date, 1)\n        });\n        return Object.assign(Object.assign({}, seg), {\n            firstCol: spanStart,\n            lastCol: spanEnd - 1,\n            eventRange: {\n                def: eventRange.def,\n                ui: Object.assign(Object.assign({}, eventRange.ui), {\n                    durationEditable: false\n                }),\n                instance: eventRange.instance,\n                range: slicedRange\n            },\n            isStart: seg.isStart && slicedRange.start.valueOf() === origRange.start.valueOf(),\n            isEnd: seg.isEnd && slicedRange.end.valueOf() === origRange.end.valueOf()\n        });\n    }\n    class DayGridSegHierarchy extends SegHierarchy {\n        addSegs(segInputs) {\n            const hiddenSegs = super.addSegs(segInputs);\n            const { entriesByLevel } = this;\n            const excludeHidden = (entry)=>!this.forceHidden[buildEntryKey(entry)];\n            // remove the forced-hidden segs\n            for(let level = 0; level < entriesByLevel.length; level += 1){\n                entriesByLevel[level] = entriesByLevel[level].filter(excludeHidden);\n            }\n            return hiddenSegs;\n        }\n        handleInvalidInsertion(insertion, entry, hiddenEntries) {\n            const { entriesByLevel, forceHidden } = this;\n            const { touchingEntry, touchingLevel, touchingLateral } = insertion;\n            if (this.hiddenConsumes && touchingEntry) {\n                const touchingEntryId = buildEntryKey(touchingEntry);\n                // if not already hidden\n                if (!forceHidden[touchingEntryId]) {\n                    if (this.allowReslicing) {\n                        const placeholderEntry = Object.assign(Object.assign({}, touchingEntry), {\n                            span: intersectSpans(touchingEntry.span, entry.span)\n                        });\n                        const placeholderEntryId = buildEntryKey(placeholderEntry);\n                        forceHidden[placeholderEntryId] = true;\n                        entriesByLevel[touchingLevel][touchingLateral] = placeholderEntry; // replace touchingEntry with our placeholder\n                        this.splitEntry(touchingEntry, entry, hiddenEntries); // split up the touchingEntry, reinsert it\n                    } else {\n                        forceHidden[touchingEntryId] = true;\n                        hiddenEntries.push(touchingEntry);\n                    }\n                }\n            }\n            return super.handleInvalidInsertion(insertion, entry, hiddenEntries);\n        }\n        constructor(){\n            super(...arguments);\n            // config\n            this.hiddenConsumes = false;\n            // allows us to keep hidden entries in the hierarchy so they take up space\n            this.forceHidden = {};\n        }\n    }\n    class TableRow extends DateComponent {\n        render() {\n            let { props, state, context } = this;\n            let { options } = context;\n            let colCnt = props.cells.length;\n            let businessHoursByCol = splitSegsByFirstCol(props.businessHourSegs, colCnt);\n            let bgEventSegsByCol = splitSegsByFirstCol(props.bgEventSegs, colCnt);\n            let highlightSegsByCol = splitSegsByFirstCol(this.getHighlightSegs(), colCnt);\n            let mirrorSegsByCol = splitSegsByFirstCol(this.getMirrorSegs(), colCnt);\n            let { singleColPlacements, multiColPlacements, moreCnts, moreMarginTops } = computeFgSegPlacement(sortEventSegs(props.fgEventSegs, options.eventOrder), props.dayMaxEvents, props.dayMaxEventRows, options.eventOrderStrict, state.eventInstanceHeights, state.maxContentHeight, props.cells);\n            let isForcedInvisible = props.eventDrag && props.eventDrag.affectedInstances || props.eventResize && props.eventResize.affectedInstances || {};\n            return y(\"tr\", {\n                ref: this.rootElRef,\n                role: \"row\"\n            }, props.renderIntro && props.renderIntro(), props.cells.map((cell, col)=>{\n                let normalFgNodes = this.renderFgSegs(col, props.forPrint ? singleColPlacements[col] : multiColPlacements[col], props.todayRange, isForcedInvisible);\n                let mirrorFgNodes = this.renderFgSegs(col, buildMirrorPlacements(mirrorSegsByCol[col], multiColPlacements), props.todayRange, {}, Boolean(props.eventDrag), Boolean(props.eventResize), false);\n                return y(TableCell, {\n                    key: cell.key,\n                    elRef: this.cellElRefs.createRef(cell.key),\n                    innerElRef: this.frameElRefs.createRef(cell.key),\n                    dateProfile: props.dateProfile,\n                    date: cell.date,\n                    showDayNumber: props.showDayNumbers,\n                    showWeekNumber: props.showWeekNumbers && col === 0,\n                    forceDayTop: props.showWeekNumbers /* even displaying weeknum for row, not necessarily day */ ,\n                    todayRange: props.todayRange,\n                    eventSelection: props.eventSelection,\n                    eventDrag: props.eventDrag,\n                    eventResize: props.eventResize,\n                    extraRenderProps: cell.extraRenderProps,\n                    extraDataAttrs: cell.extraDataAttrs,\n                    extraClassNames: cell.extraClassNames,\n                    extraDateSpan: cell.extraDateSpan,\n                    moreCnt: moreCnts[col],\n                    moreMarginTop: moreMarginTops[col],\n                    singlePlacements: singleColPlacements[col],\n                    fgContentElRef: this.fgElRefs.createRef(cell.key),\n                    fgContent: y(_, null, y(_, null, normalFgNodes), y(_, null, mirrorFgNodes)),\n                    bgContent: y(_, null, this.renderFillSegs(highlightSegsByCol[col], 'highlight'), this.renderFillSegs(businessHoursByCol[col], 'non-business'), this.renderFillSegs(bgEventSegsByCol[col], 'bg-event')),\n                    minHeight: props.cellMinHeight\n                });\n            }));\n        }\n        componentDidMount() {\n            this.updateSizing(true);\n            this.context.addResizeHandler(this.handleResize);\n        }\n        componentDidUpdate(prevProps, prevState) {\n            let currentProps = this.props;\n            this.updateSizing(!isPropsEqual(prevProps, currentProps));\n        }\n        componentWillUnmount() {\n            this.context.removeResizeHandler(this.handleResize);\n        }\n        getHighlightSegs() {\n            let { props } = this;\n            if (props.eventDrag && props.eventDrag.segs.length) {\n                return props.eventDrag.segs;\n            }\n            if (props.eventResize && props.eventResize.segs.length) {\n                return props.eventResize.segs;\n            }\n            return props.dateSelectionSegs;\n        }\n        getMirrorSegs() {\n            let { props } = this;\n            if (props.eventResize && props.eventResize.segs.length) {\n                return props.eventResize.segs;\n            }\n            return [];\n        }\n        renderFgSegs(col, segPlacements, todayRange, isForcedInvisible, isDragging, isResizing, isDateSelecting) {\n            let { context } = this;\n            let { eventSelection } = this.props;\n            let { framePositions } = this.state;\n            let defaultDisplayEventEnd = this.props.cells.length === 1; // colCnt === 1\n            let isMirror = isDragging || isResizing || isDateSelecting;\n            let nodes = [];\n            if (framePositions) {\n                for (let placement of segPlacements){\n                    let { seg } = placement;\n                    let { instanceId } = seg.eventRange.instance;\n                    let key = instanceId + ':' + col;\n                    let isVisible = placement.isVisible && !isForcedInvisible[instanceId];\n                    let isAbsolute = placement.isAbsolute;\n                    let left = '';\n                    let right = '';\n                    if (isAbsolute) {\n                        if (context.isRtl) {\n                            right = 0;\n                            left = framePositions.lefts[seg.lastCol] - framePositions.lefts[seg.firstCol];\n                        } else {\n                            left = 0;\n                            right = framePositions.rights[seg.firstCol] - framePositions.rights[seg.lastCol];\n                        }\n                    }\n                    /*\r\n                    known bug: events that are force to be list-item but span multiple days still take up space in later columns\r\n                    todo: in print view, for multi-day events, don't display title within non-start/end segs\r\n                    */ nodes.push(y(\"div\", {\n                        className: 'fc-daygrid-event-harness' + (isAbsolute ? ' fc-daygrid-event-harness-abs' : ''),\n                        key: key,\n                        ref: isMirror ? null : this.segHarnessRefs.createRef(key),\n                        style: {\n                            visibility: isVisible ? '' : 'hidden',\n                            marginTop: isAbsolute ? '' : placement.marginTop,\n                            top: isAbsolute ? placement.absoluteTop : '',\n                            left,\n                            right\n                        }\n                    }, hasListItemDisplay(seg) ? y(TableListItemEvent, Object.assign({\n                        seg: seg,\n                        isDragging: isDragging,\n                        isSelected: instanceId === eventSelection,\n                        defaultDisplayEventEnd: defaultDisplayEventEnd\n                    }, getSegMeta(seg, todayRange))) : y(TableBlockEvent, Object.assign({\n                        seg: seg,\n                        isDragging: isDragging,\n                        isResizing: isResizing,\n                        isDateSelecting: isDateSelecting,\n                        isSelected: instanceId === eventSelection,\n                        defaultDisplayEventEnd: defaultDisplayEventEnd\n                    }, getSegMeta(seg, todayRange)))));\n                }\n            }\n            return nodes;\n        }\n        renderFillSegs(segs, fillType) {\n            let { isRtl } = this.context;\n            let { todayRange } = this.props;\n            let { framePositions } = this.state;\n            let nodes = [];\n            if (framePositions) {\n                for (let seg of segs){\n                    let leftRightCss = isRtl ? {\n                        right: 0,\n                        left: framePositions.lefts[seg.lastCol] - framePositions.lefts[seg.firstCol]\n                    } : {\n                        left: 0,\n                        right: framePositions.rights[seg.firstCol] - framePositions.rights[seg.lastCol]\n                    };\n                    nodes.push(y(\"div\", {\n                        key: buildEventRangeKey(seg.eventRange),\n                        className: \"fc-daygrid-bg-harness\",\n                        style: leftRightCss\n                    }, fillType === 'bg-event' ? y(BgEvent, Object.assign({\n                        seg: seg\n                    }, getSegMeta(seg, todayRange))) : renderFill(fillType)));\n                }\n            }\n            return y(_, {}, ...nodes);\n        }\n        updateSizing(isExternalSizingChange) {\n            let { props, state, frameElRefs } = this;\n            if (!props.forPrint && props.clientWidth !== null // positioning ready?\n            ) {\n                if (isExternalSizingChange) {\n                    let frameEls = props.cells.map((cell)=>frameElRefs.currentMap[cell.key]);\n                    if (frameEls.length) {\n                        let originEl = this.rootElRef.current;\n                        let newPositionCache = new PositionCache(originEl, frameEls, true, false);\n                        if (!state.framePositions || !state.framePositions.similarTo(newPositionCache)) {\n                            this.setState({\n                                framePositions: new PositionCache(originEl, frameEls, true, false)\n                            });\n                        }\n                    }\n                }\n                const oldInstanceHeights = this.state.eventInstanceHeights;\n                const newInstanceHeights = this.queryEventInstanceHeights();\n                const limitByContentHeight = props.dayMaxEvents === true || props.dayMaxEventRows === true;\n                this.safeSetState({\n                    // HACK to prevent oscillations of events being shown/hidden from max-event-rows\n                    // Essentially, once you compute an element's height, never null-out.\n                    // TODO: always display all events, as visibility:hidden?\n                    eventInstanceHeights: Object.assign(Object.assign({}, oldInstanceHeights), newInstanceHeights),\n                    maxContentHeight: limitByContentHeight ? this.computeMaxContentHeight() : null\n                });\n            }\n        }\n        queryEventInstanceHeights() {\n            let segElMap = this.segHarnessRefs.currentMap;\n            let eventInstanceHeights = {};\n            // get the max height amongst instance segs\n            for(let key in segElMap){\n                let height = Math.round(segElMap[key].getBoundingClientRect().height);\n                let instanceId = key.split(':')[0]; // deconstruct how renderFgSegs makes the key\n                eventInstanceHeights[instanceId] = Math.max(eventInstanceHeights[instanceId] || 0, height);\n            }\n            return eventInstanceHeights;\n        }\n        computeMaxContentHeight() {\n            let firstKey = this.props.cells[0].key;\n            let cellEl = this.cellElRefs.currentMap[firstKey];\n            let fcContainerEl = this.fgElRefs.currentMap[firstKey];\n            return cellEl.getBoundingClientRect().bottom - fcContainerEl.getBoundingClientRect().top;\n        }\n        getCellEls() {\n            let elMap = this.cellElRefs.currentMap;\n            return this.props.cells.map((cell)=>elMap[cell.key]);\n        }\n        constructor(){\n            super(...arguments);\n            this.cellElRefs = new RefMap(); // the <td>\n            this.frameElRefs = new RefMap(); // the fc-daygrid-day-frame\n            this.fgElRefs = new RefMap(); // the fc-daygrid-day-events\n            this.segHarnessRefs = new RefMap(); // indexed by \"instanceId:firstCol\"\n            this.rootElRef = d();\n            this.state = {\n                framePositions: null,\n                maxContentHeight: null,\n                eventInstanceHeights: {}\n            };\n            this.handleResize = (isForced)=>{\n                if (isForced) {\n                    this.updateSizing(true); // isExternal=true\n                }\n            };\n        }\n    }\n    TableRow.addStateEquality({\n        eventInstanceHeights: isPropsEqual\n    });\n    function buildMirrorPlacements(mirrorSegs, colPlacements) {\n        if (!mirrorSegs.length) {\n            return [];\n        }\n        let topsByInstanceId = buildAbsoluteTopHash(colPlacements); // TODO: cache this at first render?\n        return mirrorSegs.map((seg)=>({\n                seg,\n                isVisible: true,\n                isAbsolute: true,\n                absoluteTop: topsByInstanceId[seg.eventRange.instance.instanceId],\n                marginTop: 0\n            }));\n    }\n    function buildAbsoluteTopHash(colPlacements) {\n        let topsByInstanceId = {};\n        for (let placements of colPlacements){\n            for (let placement of placements){\n                topsByInstanceId[placement.seg.eventRange.instance.instanceId] = placement.absoluteTop;\n            }\n        }\n        return topsByInstanceId;\n    }\n    class TableRows extends DateComponent {\n        render() {\n            let { props, context } = this;\n            let rowCnt = props.cells.length;\n            let businessHourSegsByRow = this.splitBusinessHourSegs(props.businessHourSegs, rowCnt);\n            let bgEventSegsByRow = this.splitBgEventSegs(props.bgEventSegs, rowCnt);\n            let fgEventSegsByRow = this.splitFgEventSegs(props.fgEventSegs, rowCnt);\n            let dateSelectionSegsByRow = this.splitDateSelectionSegs(props.dateSelectionSegs, rowCnt);\n            let eventDragByRow = this.splitEventDrag(props.eventDrag, rowCnt);\n            let eventResizeByRow = this.splitEventResize(props.eventResize, rowCnt);\n            // for DayGrid view with many rows, force a min-height on cells so doesn't appear squished\n            // choose 7 because a month view will have max 6 rows\n            let cellMinHeight = rowCnt >= 7 && props.clientWidth ? props.clientWidth / context.options.aspectRatio / 6 : null;\n            return y(NowTimer, {\n                unit: \"day\"\n            }, (nowDate, todayRange)=>y(_, null, props.cells.map((cells, row)=>y(TableRow, {\n                        ref: this.rowRefs.createRef(row),\n                        key: cells.length ? cells[0].date.toISOString() : row // in case there are no cells (like when resource view is loading)\n                        ,\n                        showDayNumbers: rowCnt > 1,\n                        showWeekNumbers: props.showWeekNumbers,\n                        todayRange: todayRange,\n                        dateProfile: props.dateProfile,\n                        cells: cells,\n                        renderIntro: props.renderRowIntro,\n                        businessHourSegs: businessHourSegsByRow[row],\n                        eventSelection: props.eventSelection,\n                        bgEventSegs: bgEventSegsByRow[row].filter(isSegAllDay),\n                        fgEventSegs: fgEventSegsByRow[row],\n                        dateSelectionSegs: dateSelectionSegsByRow[row],\n                        eventDrag: eventDragByRow[row],\n                        eventResize: eventResizeByRow[row],\n                        dayMaxEvents: props.dayMaxEvents,\n                        dayMaxEventRows: props.dayMaxEventRows,\n                        clientWidth: props.clientWidth,\n                        clientHeight: props.clientHeight,\n                        cellMinHeight: cellMinHeight,\n                        forPrint: props.forPrint\n                    }))));\n        }\n        componentDidMount() {\n            // HACK: need a daygrid wrapper parent to do positioning\n            // NOTE: a daygrid resource view w/o resources can have zero cells\n            const firstCellEl = this.rowRefs.currentMap[0].getCellEls()[0];\n            this.rootEl = firstCellEl ? firstCellEl.closest('.fc-daygrid-body') : null;\n            if (this.rootEl) {\n                this.context.registerInteractiveComponent(this, {\n                    el: this.rootEl,\n                    isHitComboAllowed: this.props.isHitComboAllowed\n                });\n            }\n        }\n        componentWillUnmount() {\n            if (this.rootEl) {\n                this.context.unregisterInteractiveComponent(this);\n                this.rootEl = null;\n            }\n        }\n        // Hit System\n        // ----------------------------------------------------------------------------------------------------\n        prepareHits() {\n            this.rowPositions = new PositionCache(this.rootEl, this.rowRefs.collect().map((rowObj)=>rowObj.getCellEls()[0]), false, true);\n            this.colPositions = new PositionCache(this.rootEl, this.rowRefs.currentMap[0].getCellEls(), true, false);\n        }\n        queryHit(positionLeft, positionTop) {\n            let { colPositions, rowPositions } = this;\n            let col = colPositions.leftToIndex(positionLeft);\n            let row = rowPositions.topToIndex(positionTop);\n            if (row != null && col != null) {\n                let cell = this.props.cells[row][col];\n                return {\n                    dateProfile: this.props.dateProfile,\n                    dateSpan: Object.assign({\n                        range: this.getCellRange(row, col),\n                        allDay: true\n                    }, cell.extraDateSpan),\n                    dayEl: this.getCellEl(row, col),\n                    rect: {\n                        left: colPositions.lefts[col],\n                        right: colPositions.rights[col],\n                        top: rowPositions.tops[row],\n                        bottom: rowPositions.bottoms[row]\n                    },\n                    layer: 0\n                };\n            }\n            return null;\n        }\n        getCellEl(row, col) {\n            return this.rowRefs.currentMap[row].getCellEls()[col]; // TODO: not optimal\n        }\n        getCellRange(row, col) {\n            let start = this.props.cells[row][col].date;\n            let end = addDays(start, 1);\n            return {\n                start,\n                end\n            };\n        }\n        constructor(){\n            super(...arguments);\n            this.splitBusinessHourSegs = memoize(splitSegsByRow);\n            this.splitBgEventSegs = memoize(splitSegsByRow);\n            this.splitFgEventSegs = memoize(splitSegsByRow);\n            this.splitDateSelectionSegs = memoize(splitSegsByRow);\n            this.splitEventDrag = memoize(splitInteractionByRow);\n            this.splitEventResize = memoize(splitInteractionByRow);\n            this.rowRefs = new RefMap();\n        }\n    }\n    function isSegAllDay(seg) {\n        return seg.eventRange.def.allDay;\n    }\n    class Table extends DateComponent {\n        render() {\n            let { props } = this;\n            let { dayMaxEventRows, dayMaxEvents, expandRows } = props;\n            let limitViaBalanced = dayMaxEvents === true || dayMaxEventRows === true;\n            // if rows can't expand to fill fixed height, can't do balanced-height event limit\n            // TODO: best place to normalize these options?\n            if (limitViaBalanced && !expandRows) {\n                limitViaBalanced = false;\n                dayMaxEventRows = null;\n                dayMaxEvents = null;\n            }\n            let classNames = [\n                'fc-daygrid-body',\n                limitViaBalanced ? 'fc-daygrid-body-balanced' : 'fc-daygrid-body-unbalanced',\n                expandRows ? '' : 'fc-daygrid-body-natural'\n            ];\n            return y(\"div\", {\n                ref: this.elRef,\n                className: classNames.join(' '),\n                style: {\n                    // these props are important to give this wrapper correct dimensions for interactions\n                    // TODO: if we set it here, can we avoid giving to inner tables?\n                    width: props.clientWidth,\n                    minWidth: props.tableMinWidth\n                }\n            }, y(\"table\", {\n                role: \"presentation\",\n                className: \"fc-scrollgrid-sync-table\",\n                style: {\n                    width: props.clientWidth,\n                    minWidth: props.tableMinWidth,\n                    height: expandRows ? props.clientHeight : ''\n                }\n            }, props.colGroupNode, y(\"tbody\", {\n                role: \"presentation\"\n            }, y(TableRows, {\n                dateProfile: props.dateProfile,\n                cells: props.cells,\n                renderRowIntro: props.renderRowIntro,\n                showWeekNumbers: props.showWeekNumbers,\n                clientWidth: props.clientWidth,\n                clientHeight: props.clientHeight,\n                businessHourSegs: props.businessHourSegs,\n                bgEventSegs: props.bgEventSegs,\n                fgEventSegs: props.fgEventSegs,\n                dateSelectionSegs: props.dateSelectionSegs,\n                eventSelection: props.eventSelection,\n                eventDrag: props.eventDrag,\n                eventResize: props.eventResize,\n                dayMaxEvents: dayMaxEvents,\n                dayMaxEventRows: dayMaxEventRows,\n                forPrint: props.forPrint,\n                isHitComboAllowed: props.isHitComboAllowed\n            }))));\n        }\n        componentDidMount() {\n            this.requestScrollReset();\n        }\n        componentDidUpdate(prevProps) {\n            if (prevProps.dateProfile !== this.props.dateProfile) {\n                this.requestScrollReset();\n            } else {\n                this.flushScrollReset();\n            }\n        }\n        requestScrollReset() {\n            this.needsScrollReset = true;\n            this.flushScrollReset();\n        }\n        flushScrollReset() {\n            if (this.needsScrollReset && this.props.clientWidth // sizes computed?\n            ) {\n                const subjectEl = getScrollSubjectEl(this.elRef.current, this.props.dateProfile);\n                if (subjectEl) {\n                    const originEl = subjectEl.closest('.fc-daygrid-body');\n                    const scrollEl = originEl.closest('.fc-scroller');\n                    const scrollTop = subjectEl.getBoundingClientRect().top - originEl.getBoundingClientRect().top;\n                    scrollEl.scrollTop = scrollTop ? scrollTop + 1 : 0; // overcome border\n                }\n                this.needsScrollReset = false;\n            }\n        }\n        constructor(){\n            super(...arguments);\n            this.elRef = d();\n            this.needsScrollReset = false;\n        }\n    }\n    function getScrollSubjectEl(containerEl, dateProfile) {\n        let el;\n        if (dateProfile.currentRangeUnit.match(/year|month/)) {\n            el = containerEl.querySelector('[data-date=\"'.concat(formatIsoMonthStr(dateProfile.currentDate), '-01\"]'));\n        // even if view is month-based, first-of-month might be hidden...\n        }\n        if (!el) {\n            el = containerEl.querySelector('[data-date=\"'.concat(formatDayString(dateProfile.currentDate), '\"]'));\n        // could still be hidden if an interior-view hidden day\n        }\n        return el;\n    }\n    class DayTableSlicer extends Slicer {\n        sliceRange(dateRange, dayTableModel) {\n            return dayTableModel.sliceRange(dateRange);\n        }\n        constructor(){\n            super(...arguments);\n            this.forceDayIfListItem = true;\n        }\n    }\n    class DayTable extends DateComponent {\n        render() {\n            let { props, context } = this;\n            return y(Table, Object.assign({\n                ref: this.tableRef\n            }, this.slicer.sliceProps(props, props.dateProfile, props.nextDayThreshold, context, props.dayTableModel), {\n                dateProfile: props.dateProfile,\n                cells: props.dayTableModel.cells,\n                colGroupNode: props.colGroupNode,\n                tableMinWidth: props.tableMinWidth,\n                renderRowIntro: props.renderRowIntro,\n                dayMaxEvents: props.dayMaxEvents,\n                dayMaxEventRows: props.dayMaxEventRows,\n                showWeekNumbers: props.showWeekNumbers,\n                expandRows: props.expandRows,\n                headerAlignElRef: props.headerAlignElRef,\n                clientWidth: props.clientWidth,\n                clientHeight: props.clientHeight,\n                forPrint: props.forPrint\n            }));\n        }\n        constructor(){\n            super(...arguments);\n            this.slicer = new DayTableSlicer();\n            this.tableRef = d();\n        }\n    }\n    class TableDateProfileGenerator extends DateProfileGenerator {\n        // Computes the date range that will be rendered\n        buildRenderRange(currentRange, currentRangeUnit, isRangeAllDay) {\n            let renderRange = super.buildRenderRange(currentRange, currentRangeUnit, isRangeAllDay);\n            let { props } = this;\n            return buildDayTableRenderRange({\n                currentRange: renderRange,\n                snapToWeek: /^(year|month)$/.test(currentRangeUnit),\n                fixedWeekCount: props.fixedWeekCount,\n                dateEnv: props.dateEnv\n            });\n        }\n    }\n    function buildDayTableRenderRange(props) {\n        let { dateEnv, currentRange } = props;\n        let { start, end } = currentRange;\n        let endOfWeek;\n        // year and month views should be aligned with weeks. this is already done for week\n        if (props.snapToWeek) {\n            start = dateEnv.startOfWeek(start);\n            // make end-of-week if not already\n            endOfWeek = dateEnv.startOfWeek(end);\n            if (endOfWeek.valueOf() !== end.valueOf()) {\n                end = addWeeks(endOfWeek, 1);\n            }\n        }\n        // ensure 6 weeks\n        if (props.fixedWeekCount) {\n            // TODO: instead of these date-math gymnastics (for multimonth view),\n            // compute dateprofiles of all months, then use start of first and end of last.\n            let lastMonthRenderStart = dateEnv.startOfWeek(dateEnv.startOfMonth(addDays(currentRange.end, -1)));\n            let rowCnt = Math.ceil(diffWeeks(lastMonthRenderStart, end));\n            end = addWeeks(end, 6 - rowCnt);\n        }\n        return {\n            start,\n            end\n        };\n    }\n    /* An abstract class for the daygrid views, as well as month view. Renders one or more rows of day cells.\r\n    ----------------------------------------------------------------------------------------------------------------------*/ // It is a manager for a Table subcomponent, which does most of the heavy lifting.\n    // It is responsible for managing width/height.\n    class TableView extends DateComponent {\n        renderSimpleLayout(headerRowContent, bodyContent) {\n            let { props, context } = this;\n            let sections = [];\n            let stickyHeaderDates = getStickyHeaderDates(context.options);\n            if (headerRowContent) {\n                sections.push({\n                    type: 'header',\n                    key: 'header',\n                    isSticky: stickyHeaderDates,\n                    chunk: {\n                        elRef: this.headerElRef,\n                        tableClassName: 'fc-col-header',\n                        rowContent: headerRowContent\n                    }\n                });\n            }\n            sections.push({\n                type: 'body',\n                key: 'body',\n                liquid: true,\n                chunk: {\n                    content: bodyContent\n                }\n            });\n            return y(ViewContainer, {\n                elClasses: [\n                    'fc-daygrid'\n                ],\n                viewSpec: context.viewSpec\n            }, y(SimpleScrollGrid, {\n                liquid: !props.isHeightAuto && !props.forPrint,\n                collapsibleWidth: props.forPrint,\n                cols: [],\n                sections: sections\n            }));\n        }\n        renderHScrollLayout(headerRowContent, bodyContent, colCnt, dayMinWidth) {\n            let ScrollGrid = this.context.pluginHooks.scrollGridImpl;\n            if (!ScrollGrid) {\n                throw new Error('No ScrollGrid implementation');\n            }\n            let { props, context } = this;\n            let stickyHeaderDates = !props.forPrint && getStickyHeaderDates(context.options);\n            let stickyFooterScrollbar = !props.forPrint && getStickyFooterScrollbar(context.options);\n            let sections = [];\n            if (headerRowContent) {\n                sections.push({\n                    type: 'header',\n                    key: 'header',\n                    isSticky: stickyHeaderDates,\n                    chunks: [\n                        {\n                            key: 'main',\n                            elRef: this.headerElRef,\n                            tableClassName: 'fc-col-header',\n                            rowContent: headerRowContent\n                        }\n                    ]\n                });\n            }\n            sections.push({\n                type: 'body',\n                key: 'body',\n                liquid: true,\n                chunks: [\n                    {\n                        key: 'main',\n                        content: bodyContent\n                    }\n                ]\n            });\n            if (stickyFooterScrollbar) {\n                sections.push({\n                    type: 'footer',\n                    key: 'footer',\n                    isSticky: true,\n                    chunks: [\n                        {\n                            key: 'main',\n                            content: renderScrollShim\n                        }\n                    ]\n                });\n            }\n            return y(ViewContainer, {\n                elClasses: [\n                    'fc-daygrid'\n                ],\n                viewSpec: context.viewSpec\n            }, y(ScrollGrid, {\n                liquid: !props.isHeightAuto && !props.forPrint,\n                forPrint: props.forPrint,\n                collapsibleWidth: props.forPrint,\n                colGroups: [\n                    {\n                        cols: [\n                            {\n                                span: colCnt,\n                                minWidth: dayMinWidth\n                            }\n                        ]\n                    }\n                ],\n                sections: sections\n            }));\n        }\n        constructor(){\n            super(...arguments);\n            this.headerElRef = d();\n        }\n    }\n    class DayTableView extends TableView {\n        render() {\n            let { options, dateProfileGenerator } = this.context;\n            let { props } = this;\n            let dayTableModel = this.buildDayTableModel(props.dateProfile, dateProfileGenerator);\n            let headerContent = options.dayHeaders && y(DayHeader, {\n                ref: this.headerRef,\n                dateProfile: props.dateProfile,\n                dates: dayTableModel.headerDates,\n                datesRepDistinctDays: dayTableModel.rowCnt === 1\n            });\n            let bodyContent = (contentArg)=>y(DayTable, {\n                    ref: this.tableRef,\n                    dateProfile: props.dateProfile,\n                    dayTableModel: dayTableModel,\n                    businessHours: props.businessHours,\n                    dateSelection: props.dateSelection,\n                    eventStore: props.eventStore,\n                    eventUiBases: props.eventUiBases,\n                    eventSelection: props.eventSelection,\n                    eventDrag: props.eventDrag,\n                    eventResize: props.eventResize,\n                    nextDayThreshold: options.nextDayThreshold,\n                    colGroupNode: contentArg.tableColGroupNode,\n                    tableMinWidth: contentArg.tableMinWidth,\n                    dayMaxEvents: options.dayMaxEvents,\n                    dayMaxEventRows: options.dayMaxEventRows,\n                    showWeekNumbers: options.weekNumbers,\n                    expandRows: !props.isHeightAuto,\n                    headerAlignElRef: this.headerElRef,\n                    clientWidth: contentArg.clientWidth,\n                    clientHeight: contentArg.clientHeight,\n                    forPrint: props.forPrint\n                });\n            return options.dayMinWidth ? this.renderHScrollLayout(headerContent, bodyContent, dayTableModel.colCnt, options.dayMinWidth) : this.renderSimpleLayout(headerContent, bodyContent);\n        }\n        constructor(){\n            super(...arguments);\n            this.buildDayTableModel = memoize(buildDayTableModel);\n            this.headerRef = d();\n            this.tableRef = d();\n        // can't override any lifecycle methods from parent\n        }\n    }\n    function buildDayTableModel(dateProfile, dateProfileGenerator) {\n        let daySeries = new DaySeriesModel(dateProfile.renderRange, dateProfileGenerator);\n        return new DayTableModel(daySeries, /year|month|week/.test(dateProfile.currentRangeUnit));\n    }\n    var index$3 = createPlugin({\n        name: '@fullcalendar/daygrid',\n        initialView: 'dayGridMonth',\n        views: {\n            dayGrid: {\n                component: DayTableView,\n                dateProfileGeneratorClass: TableDateProfileGenerator\n            },\n            dayGridDay: {\n                type: 'dayGrid',\n                duration: {\n                    days: 1\n                }\n            },\n            dayGridWeek: {\n                type: 'dayGrid',\n                duration: {\n                    weeks: 1\n                }\n            },\n            dayGridMonth: {\n                type: 'dayGrid',\n                duration: {\n                    months: 1\n                },\n                fixedWeekCount: true\n            },\n            dayGridYear: {\n                type: 'dayGrid',\n                duration: {\n                    years: 1\n                }\n            }\n        }\n    });\n    var css_248z$2 = \".fc-v-event{background-color:var(--fc-event-bg-color);border:1px solid var(--fc-event-border-color);display:block}.fc-v-event .fc-event-main{color:var(--fc-event-text-color);height:100%}.fc-v-event .fc-event-main-frame{display:flex;flex-direction:column;height:100%}.fc-v-event .fc-event-time{flex-grow:0;flex-shrink:0;max-height:100%;overflow:hidden}.fc-v-event .fc-event-title-container{flex-grow:1;flex-shrink:1;min-height:0}.fc-v-event .fc-event-title{bottom:0;max-height:100%;overflow:hidden;top:0}.fc-v-event:not(.fc-event-start){border-top-left-radius:0;border-top-right-radius:0;border-top-width:0}.fc-v-event:not(.fc-event-end){border-bottom-left-radius:0;border-bottom-right-radius:0;border-bottom-width:0}.fc-v-event.fc-event-selected:before{left:-10px;right:-10px}.fc-v-event .fc-event-resizer-start{cursor:n-resize}.fc-v-event .fc-event-resizer-end{cursor:s-resize}.fc-v-event:not(.fc-event-selected) .fc-event-resizer{height:var(--fc-event-resizer-thickness);left:0;right:0}.fc-v-event:not(.fc-event-selected) .fc-event-resizer-start{top:calc(var(--fc-event-resizer-thickness)/-2)}.fc-v-event:not(.fc-event-selected) .fc-event-resizer-end{bottom:calc(var(--fc-event-resizer-thickness)/-2)}.fc-v-event.fc-event-selected .fc-event-resizer{left:50%;margin-left:calc(var(--fc-event-resizer-dot-total-width)/-2)}.fc-v-event.fc-event-selected .fc-event-resizer-start{top:calc(var(--fc-event-resizer-dot-total-width)/-2)}.fc-v-event.fc-event-selected .fc-event-resizer-end{bottom:calc(var(--fc-event-resizer-dot-total-width)/-2)}.fc .fc-timegrid .fc-daygrid-body{z-index:2}.fc .fc-timegrid-divider{padding:0 0 2px}.fc .fc-timegrid-body{min-height:100%;position:relative;z-index:1}.fc .fc-timegrid-axis-chunk{position:relative}.fc .fc-timegrid-axis-chunk>table,.fc .fc-timegrid-slots{position:relative;z-index:1}.fc .fc-timegrid-slot{border-bottom:0;height:1.5em}.fc .fc-timegrid-slot:empty:before{content:\\\"\\\\00a0\\\"}.fc .fc-timegrid-slot-minor{border-top-style:dotted}.fc .fc-timegrid-slot-label-cushion{display:inline-block;white-space:nowrap}.fc .fc-timegrid-slot-label{vertical-align:middle}.fc .fc-timegrid-axis-cushion,.fc .fc-timegrid-slot-label-cushion{padding:0 4px}.fc .fc-timegrid-axis-frame-liquid{height:100%}.fc .fc-timegrid-axis-frame{align-items:center;display:flex;justify-content:flex-end;overflow:hidden}.fc .fc-timegrid-axis-cushion{flex-shrink:0;max-width:60px}.fc-direction-ltr .fc-timegrid-slot-label-frame{text-align:right}.fc-direction-rtl .fc-timegrid-slot-label-frame{text-align:left}.fc-liquid-hack .fc-timegrid-axis-frame-liquid{bottom:0;height:auto;left:0;position:absolute;right:0;top:0}.fc .fc-timegrid-col.fc-day-today{background-color:var(--fc-today-bg-color)}.fc .fc-timegrid-col-frame{min-height:100%;position:relative}.fc-media-screen.fc-liquid-hack .fc-timegrid-col-frame{bottom:0;height:auto;left:0;position:absolute;right:0;top:0}.fc-media-screen .fc-timegrid-cols{bottom:0;left:0;position:absolute;right:0;top:0}.fc-media-screen .fc-timegrid-cols>table{height:100%}.fc-media-screen .fc-timegrid-col-bg,.fc-media-screen .fc-timegrid-col-events,.fc-media-screen .fc-timegrid-now-indicator-container{left:0;position:absolute;right:0;top:0}.fc .fc-timegrid-col-bg{z-index:2}.fc .fc-timegrid-col-bg .fc-non-business{z-index:1}.fc .fc-timegrid-col-bg .fc-bg-event{z-index:2}.fc .fc-timegrid-col-bg .fc-highlight{z-index:3}.fc .fc-timegrid-bg-harness{left:0;position:absolute;right:0}.fc .fc-timegrid-col-events{z-index:3}.fc .fc-timegrid-now-indicator-container{bottom:0;overflow:hidden}.fc-direction-ltr .fc-timegrid-col-events{margin:0 2.5% 0 2px}.fc-direction-rtl .fc-timegrid-col-events{margin:0 2px 0 2.5%}.fc-timegrid-event-harness{position:absolute}.fc-timegrid-event-harness>.fc-timegrid-event{bottom:0;left:0;position:absolute;right:0;top:0}.fc-timegrid-event-harness-inset .fc-timegrid-event,.fc-timegrid-event.fc-event-mirror,.fc-timegrid-more-link{box-shadow:0 0 0 1px var(--fc-page-bg-color)}.fc-timegrid-event,.fc-timegrid-more-link{border-radius:3px;font-size:var(--fc-small-font-size)}.fc-timegrid-event{margin-bottom:1px}.fc-timegrid-event .fc-event-main{padding:1px 1px 0}.fc-timegrid-event .fc-event-time{font-size:var(--fc-small-font-size);margin-bottom:1px;white-space:nowrap}.fc-timegrid-event-short .fc-event-main-frame{flex-direction:row;overflow:hidden}.fc-timegrid-event-short .fc-event-time:after{content:\\\"\\\\00a0-\\\\00a0\\\"}.fc-timegrid-event-short .fc-event-title{font-size:var(--fc-small-font-size)}.fc-timegrid-more-link{background:var(--fc-more-link-bg-color);color:var(--fc-more-link-text-color);cursor:pointer;margin-bottom:1px;position:absolute;z-index:9999}.fc-timegrid-more-link-inner{padding:3px 2px;top:0}.fc-direction-ltr .fc-timegrid-more-link{right:0}.fc-direction-rtl .fc-timegrid-more-link{left:0}.fc .fc-timegrid-now-indicator-line{border-color:var(--fc-now-indicator-color);border-style:solid;border-width:1px 0 0;left:0;position:absolute;right:0;z-index:4}.fc .fc-timegrid-now-indicator-arrow{border-color:var(--fc-now-indicator-color);border-style:solid;margin-top:-5px;position:absolute;z-index:4}.fc-direction-ltr .fc-timegrid-now-indicator-arrow{border-bottom-color:transparent;border-top-color:transparent;border-width:5px 0 5px 6px;left:0}.fc-direction-rtl .fc-timegrid-now-indicator-arrow{border-bottom-color:transparent;border-top-color:transparent;border-width:5px 6px 5px 0;right:0}\";\n    injectStyles(css_248z$2);\n    class AllDaySplitter extends Splitter {\n        getKeyInfo() {\n            return {\n                allDay: {},\n                timed: {}\n            };\n        }\n        getKeysForDateSpan(dateSpan) {\n            if (dateSpan.allDay) {\n                return [\n                    'allDay'\n                ];\n            }\n            return [\n                'timed'\n            ];\n        }\n        getKeysForEventDef(eventDef) {\n            if (!eventDef.allDay) {\n                return [\n                    'timed'\n                ];\n            }\n            if (hasBgRendering(eventDef)) {\n                return [\n                    'timed',\n                    'allDay'\n                ];\n            }\n            return [\n                'allDay'\n            ];\n        }\n    }\n    const DEFAULT_SLAT_LABEL_FORMAT = createFormatter({\n        hour: 'numeric',\n        minute: '2-digit',\n        omitZeroMinute: true,\n        meridiem: 'short'\n    });\n    function TimeColsAxisCell(props) {\n        let classNames = [\n            'fc-timegrid-slot',\n            'fc-timegrid-slot-label',\n            props.isLabeled ? 'fc-scrollgrid-shrink' : 'fc-timegrid-slot-minor'\n        ];\n        return y(ViewContextType.Consumer, null, (context)=>{\n            if (!props.isLabeled) {\n                return y(\"td\", {\n                    className: classNames.join(' '),\n                    \"data-time\": props.isoTimeStr\n                });\n            }\n            let { dateEnv, options, viewApi } = context;\n            let labelFormat = options.slotLabelFormat == null ? DEFAULT_SLAT_LABEL_FORMAT : Array.isArray(options.slotLabelFormat) ? createFormatter(options.slotLabelFormat[0]) : createFormatter(options.slotLabelFormat);\n            let renderProps = {\n                level: 0,\n                time: props.time,\n                date: dateEnv.toDate(props.date),\n                view: viewApi,\n                text: dateEnv.format(props.date, labelFormat)\n            };\n            return y(ContentContainer, {\n                elTag: \"td\",\n                elClasses: classNames,\n                elAttrs: {\n                    'data-time': props.isoTimeStr\n                },\n                renderProps: renderProps,\n                generatorName: \"slotLabelContent\",\n                customGenerator: options.slotLabelContent,\n                defaultGenerator: renderInnerContent$1,\n                classNameGenerator: options.slotLabelClassNames,\n                didMount: options.slotLabelDidMount,\n                willUnmount: options.slotLabelWillUnmount\n            }, (InnerContent)=>y(\"div\", {\n                    className: \"fc-timegrid-slot-label-frame fc-scrollgrid-shrink-frame\"\n                }, y(InnerContent, {\n                    elTag: \"div\",\n                    elClasses: [\n                        'fc-timegrid-slot-label-cushion',\n                        'fc-scrollgrid-shrink-cushion'\n                    ]\n                })));\n        });\n    }\n    function renderInnerContent$1(props) {\n        return props.text;\n    }\n    class TimeBodyAxis extends BaseComponent {\n        render() {\n            return this.props.slatMetas.map((slatMeta)=>y(\"tr\", {\n                    key: slatMeta.key\n                }, y(TimeColsAxisCell, Object.assign({}, slatMeta))));\n        }\n    }\n    const DEFAULT_WEEK_NUM_FORMAT = createFormatter({\n        week: 'short'\n    });\n    const AUTO_ALL_DAY_MAX_EVENT_ROWS = 5;\n    class TimeColsView extends DateComponent {\n        // rendering\n        // ----------------------------------------------------------------------------------------------------\n        renderSimpleLayout(headerRowContent, allDayContent, timeContent) {\n            let { context, props } = this;\n            let sections = [];\n            let stickyHeaderDates = getStickyHeaderDates(context.options);\n            if (headerRowContent) {\n                sections.push({\n                    type: 'header',\n                    key: 'header',\n                    isSticky: stickyHeaderDates,\n                    chunk: {\n                        elRef: this.headerElRef,\n                        tableClassName: 'fc-col-header',\n                        rowContent: headerRowContent\n                    }\n                });\n            }\n            if (allDayContent) {\n                sections.push({\n                    type: 'body',\n                    key: 'all-day',\n                    chunk: {\n                        content: allDayContent\n                    }\n                });\n                sections.push({\n                    type: 'body',\n                    key: 'all-day-divider',\n                    outerContent: y(\"tr\", {\n                        role: \"presentation\",\n                        className: \"fc-scrollgrid-section\"\n                    }, y(\"td\", {\n                        className: 'fc-timegrid-divider ' + context.theme.getClass('tableCellShaded')\n                    }))\n                });\n            }\n            sections.push({\n                type: 'body',\n                key: 'body',\n                liquid: true,\n                expandRows: Boolean(context.options.expandRows),\n                chunk: {\n                    scrollerElRef: this.scrollerElRef,\n                    content: timeContent\n                }\n            });\n            return y(ViewContainer, {\n                elRef: this.rootElRef,\n                elClasses: [\n                    'fc-timegrid'\n                ],\n                viewSpec: context.viewSpec\n            }, y(SimpleScrollGrid, {\n                liquid: !props.isHeightAuto && !props.forPrint,\n                collapsibleWidth: props.forPrint,\n                cols: [\n                    {\n                        width: 'shrink'\n                    }\n                ],\n                sections: sections\n            }));\n        }\n        renderHScrollLayout(headerRowContent, allDayContent, timeContent, colCnt, dayMinWidth, slatMetas, slatCoords) {\n            let ScrollGrid = this.context.pluginHooks.scrollGridImpl;\n            if (!ScrollGrid) {\n                throw new Error('No ScrollGrid implementation');\n            }\n            let { context, props } = this;\n            let stickyHeaderDates = !props.forPrint && getStickyHeaderDates(context.options);\n            let stickyFooterScrollbar = !props.forPrint && getStickyFooterScrollbar(context.options);\n            let sections = [];\n            if (headerRowContent) {\n                sections.push({\n                    type: 'header',\n                    key: 'header',\n                    isSticky: stickyHeaderDates,\n                    syncRowHeights: true,\n                    chunks: [\n                        {\n                            key: 'axis',\n                            rowContent: (arg)=>y(\"tr\", {\n                                    role: \"presentation\"\n                                }, this.renderHeadAxis('day', arg.rowSyncHeights[0]))\n                        },\n                        {\n                            key: 'cols',\n                            elRef: this.headerElRef,\n                            tableClassName: 'fc-col-header',\n                            rowContent: headerRowContent\n                        }\n                    ]\n                });\n            }\n            if (allDayContent) {\n                sections.push({\n                    type: 'body',\n                    key: 'all-day',\n                    syncRowHeights: true,\n                    chunks: [\n                        {\n                            key: 'axis',\n                            rowContent: (contentArg)=>y(\"tr\", {\n                                    role: \"presentation\"\n                                }, this.renderTableRowAxis(contentArg.rowSyncHeights[0]))\n                        },\n                        {\n                            key: 'cols',\n                            content: allDayContent\n                        }\n                    ]\n                });\n                sections.push({\n                    key: 'all-day-divider',\n                    type: 'body',\n                    outerContent: y(\"tr\", {\n                        role: \"presentation\",\n                        className: \"fc-scrollgrid-section\"\n                    }, y(\"td\", {\n                        colSpan: 2,\n                        className: 'fc-timegrid-divider ' + context.theme.getClass('tableCellShaded')\n                    }))\n                });\n            }\n            let isNowIndicator = context.options.nowIndicator;\n            sections.push({\n                type: 'body',\n                key: 'body',\n                liquid: true,\n                expandRows: Boolean(context.options.expandRows),\n                chunks: [\n                    {\n                        key: 'axis',\n                        content: (arg)=>// TODO: make this now-indicator arrow more DRY with TimeColsContent\n                            y(\"div\", {\n                                className: \"fc-timegrid-axis-chunk\"\n                            }, y(\"table\", {\n                                \"aria-hidden\": true,\n                                style: {\n                                    height: arg.expandRows ? arg.clientHeight : ''\n                                }\n                            }, arg.tableColGroupNode, y(\"tbody\", null, y(TimeBodyAxis, {\n                                slatMetas: slatMetas\n                            }))), y(\"div\", {\n                                className: \"fc-timegrid-now-indicator-container\"\n                            }, y(NowTimer, {\n                                unit: isNowIndicator ? 'minute' : 'day' /* hacky */ \n                            }, (nowDate)=>{\n                                let nowIndicatorTop = isNowIndicator && slatCoords && slatCoords.safeComputeTop(nowDate); // might return void\n                                if (typeof nowIndicatorTop === 'number') {\n                                    return y(NowIndicatorContainer, {\n                                        elClasses: [\n                                            'fc-timegrid-now-indicator-arrow'\n                                        ],\n                                        elStyle: {\n                                            top: nowIndicatorTop\n                                        },\n                                        isAxis: true,\n                                        date: nowDate\n                                    });\n                                }\n                                return null;\n                            })))\n                    },\n                    {\n                        key: 'cols',\n                        scrollerElRef: this.scrollerElRef,\n                        content: timeContent\n                    }\n                ]\n            });\n            if (stickyFooterScrollbar) {\n                sections.push({\n                    key: 'footer',\n                    type: 'footer',\n                    isSticky: true,\n                    chunks: [\n                        {\n                            key: 'axis',\n                            content: renderScrollShim\n                        },\n                        {\n                            key: 'cols',\n                            content: renderScrollShim\n                        }\n                    ]\n                });\n            }\n            return y(ViewContainer, {\n                elRef: this.rootElRef,\n                elClasses: [\n                    'fc-timegrid'\n                ],\n                viewSpec: context.viewSpec\n            }, y(ScrollGrid, {\n                liquid: !props.isHeightAuto && !props.forPrint,\n                forPrint: props.forPrint,\n                collapsibleWidth: false,\n                colGroups: [\n                    {\n                        width: 'shrink',\n                        cols: [\n                            {\n                                width: 'shrink'\n                            }\n                        ]\n                    },\n                    {\n                        cols: [\n                            {\n                                span: colCnt,\n                                minWidth: dayMinWidth\n                            }\n                        ]\n                    }\n                ],\n                sections: sections\n            }));\n        }\n        /* Dimensions\r\n        ------------------------------------------------------------------------------------------------------------------*/ getAllDayMaxEventProps() {\n            let { dayMaxEvents, dayMaxEventRows } = this.context.options;\n            if (dayMaxEvents === true || dayMaxEventRows === true) {\n                dayMaxEvents = undefined;\n                dayMaxEventRows = AUTO_ALL_DAY_MAX_EVENT_ROWS; // make sure \"auto\" goes to a real number\n            }\n            return {\n                dayMaxEvents,\n                dayMaxEventRows\n            };\n        }\n        constructor(){\n            var _this;\n            super(...arguments), _this = this;\n            this.allDaySplitter = new AllDaySplitter(); // for use by subclasses\n            this.headerElRef = d();\n            this.rootElRef = d();\n            this.scrollerElRef = d();\n            this.state = {\n                slatCoords: null\n            };\n            this.handleScrollTopRequest = (scrollTop)=>{\n                let scrollerEl = this.scrollerElRef.current;\n                if (scrollerEl) {\n                    scrollerEl.scrollTop = scrollTop;\n                }\n            };\n            /* Header Render Methods\r\n            ------------------------------------------------------------------------------------------------------------------*/ this.renderHeadAxis = function(rowKey) {\n                let frameHeight = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : '';\n                let { options } = _this.context;\n                let { dateProfile } = _this.props;\n                let range = dateProfile.renderRange;\n                let dayCnt = diffDays(range.start, range.end);\n                // only do in day views (to avoid doing in week views that dont need it)\n                let navLinkAttrs = dayCnt === 1 ? buildNavLinkAttrs(_this.context, range.start, 'week') : {};\n                if (options.weekNumbers && rowKey === 'day') {\n                    return y(WeekNumberContainer, {\n                        elTag: \"th\",\n                        elClasses: [\n                            'fc-timegrid-axis',\n                            'fc-scrollgrid-shrink'\n                        ],\n                        elAttrs: {\n                            'aria-hidden': true\n                        },\n                        date: range.start,\n                        defaultFormat: DEFAULT_WEEK_NUM_FORMAT\n                    }, (InnerContent)=>y(\"div\", {\n                            className: [\n                                'fc-timegrid-axis-frame',\n                                'fc-scrollgrid-shrink-frame',\n                                'fc-timegrid-axis-frame-liquid'\n                            ].join(' '),\n                            style: {\n                                height: frameHeight\n                            }\n                        }, y(InnerContent, {\n                            elTag: \"a\",\n                            elClasses: [\n                                'fc-timegrid-axis-cushion',\n                                'fc-scrollgrid-shrink-cushion',\n                                'fc-scrollgrid-sync-inner'\n                            ],\n                            elAttrs: navLinkAttrs\n                        })));\n                }\n                return y(\"th\", {\n                    \"aria-hidden\": true,\n                    className: \"fc-timegrid-axis\"\n                }, y(\"div\", {\n                    className: \"fc-timegrid-axis-frame\",\n                    style: {\n                        height: frameHeight\n                    }\n                }));\n            };\n            /* Table Component Render Methods\r\n            ------------------------------------------------------------------------------------------------------------------*/ // only a one-way height sync. we don't send the axis inner-content height to the DayGrid,\n            // but DayGrid still needs to have classNames on inner elements in order to measure.\n            this.renderTableRowAxis = (rowHeight)=>{\n                let { options, viewApi } = this.context;\n                let renderProps = {\n                    text: options.allDayText,\n                    view: viewApi\n                };\n                return(// TODO: make reusable hook. used in list view too\n                y(ContentContainer, {\n                    elTag: \"td\",\n                    elClasses: [\n                        'fc-timegrid-axis',\n                        'fc-scrollgrid-shrink'\n                    ],\n                    elAttrs: {\n                        'aria-hidden': true\n                    },\n                    renderProps: renderProps,\n                    generatorName: \"allDayContent\",\n                    customGenerator: options.allDayContent,\n                    defaultGenerator: renderAllDayInner$1,\n                    classNameGenerator: options.allDayClassNames,\n                    didMount: options.allDayDidMount,\n                    willUnmount: options.allDayWillUnmount\n                }, (InnerContent)=>y(\"div\", {\n                        className: [\n                            'fc-timegrid-axis-frame',\n                            'fc-scrollgrid-shrink-frame',\n                            rowHeight == null ? ' fc-timegrid-axis-frame-liquid' : ''\n                        ].join(' '),\n                        style: {\n                            height: rowHeight\n                        }\n                    }, y(InnerContent, {\n                        elTag: \"span\",\n                        elClasses: [\n                            'fc-timegrid-axis-cushion',\n                            'fc-scrollgrid-shrink-cushion',\n                            'fc-scrollgrid-sync-inner'\n                        ]\n                    }))));\n            };\n            this.handleSlatCoords = (slatCoords)=>{\n                this.setState({\n                    slatCoords\n                });\n            };\n        }\n    }\n    function renderAllDayInner$1(renderProps) {\n        return renderProps.text;\n    }\n    class TimeColsSlatsCoords {\n        safeComputeTop(date) {\n            let { dateProfile } = this;\n            if (rangeContainsMarker(dateProfile.currentRange, date)) {\n                let startOfDayDate = startOfDay(date);\n                let timeMs = date.valueOf() - startOfDayDate.valueOf();\n                if (timeMs >= asRoughMs(dateProfile.slotMinTime) && timeMs < asRoughMs(dateProfile.slotMaxTime)) {\n                    return this.computeTimeTop(createDuration(timeMs));\n                }\n            }\n            return null;\n        }\n        // Computes the top coordinate, relative to the bounds of the grid, of the given date.\n        // A `startOfDayDate` must be given for avoiding ambiguity over how to treat midnight.\n        computeDateTop(when, startOfDayDate) {\n            if (!startOfDayDate) {\n                startOfDayDate = startOfDay(when);\n            }\n            return this.computeTimeTop(createDuration(when.valueOf() - startOfDayDate.valueOf()));\n        }\n        // Computes the top coordinate, relative to the bounds of the grid, of the given time (a Duration).\n        // This is a makeshify way to compute the time-top. Assumes all slatMetas dates are uniform.\n        // Eventually allow computation with arbirary slat dates.\n        computeTimeTop(duration) {\n            let { positions, dateProfile } = this;\n            let len = positions.els.length;\n            // floating-point value of # of slots covered\n            let slatCoverage = (duration.milliseconds - asRoughMs(dateProfile.slotMinTime)) / asRoughMs(this.slotDuration);\n            let slatIndex;\n            let slatRemainder;\n            // compute a floating-point number for how many slats should be progressed through.\n            // from 0 to number of slats (inclusive)\n            // constrained because slotMinTime/slotMaxTime might be customized.\n            slatCoverage = Math.max(0, slatCoverage);\n            slatCoverage = Math.min(len, slatCoverage);\n            // an integer index of the furthest whole slat\n            // from 0 to number slats (*exclusive*, so len-1)\n            slatIndex = Math.floor(slatCoverage);\n            slatIndex = Math.min(slatIndex, len - 1);\n            // how much further through the slatIndex slat (from 0.0-1.0) must be covered in addition.\n            // could be 1.0 if slatCoverage is covering *all* the slots\n            slatRemainder = slatCoverage - slatIndex;\n            return positions.tops[slatIndex] + positions.getHeight(slatIndex) * slatRemainder;\n        }\n        constructor(positions, dateProfile, slotDuration){\n            this.positions = positions;\n            this.dateProfile = dateProfile;\n            this.slotDuration = slotDuration;\n        }\n    }\n    class TimeColsSlatsBody extends BaseComponent {\n        render() {\n            let { props, context } = this;\n            let { options } = context;\n            let { slatElRefs } = props;\n            return y(\"tbody\", null, props.slatMetas.map((slatMeta, i)=>{\n                let renderProps = {\n                    time: slatMeta.time,\n                    date: context.dateEnv.toDate(slatMeta.date),\n                    view: context.viewApi\n                };\n                return y(\"tr\", {\n                    key: slatMeta.key,\n                    ref: slatElRefs.createRef(slatMeta.key)\n                }, props.axis && y(TimeColsAxisCell, Object.assign({}, slatMeta)), y(ContentContainer, {\n                    elTag: \"td\",\n                    elClasses: [\n                        'fc-timegrid-slot',\n                        'fc-timegrid-slot-lane',\n                        !slatMeta.isLabeled && 'fc-timegrid-slot-minor'\n                    ],\n                    elAttrs: {\n                        'data-time': slatMeta.isoTimeStr\n                    },\n                    renderProps: renderProps,\n                    generatorName: \"slotLaneContent\",\n                    customGenerator: options.slotLaneContent,\n                    classNameGenerator: options.slotLaneClassNames,\n                    didMount: options.slotLaneDidMount,\n                    willUnmount: options.slotLaneWillUnmount\n                }));\n            }));\n        }\n    }\n    /*\r\n    for the horizontal \"slats\" that run width-wise. Has a time axis on a side. Depends on RTL.\r\n    */ class TimeColsSlats extends BaseComponent {\n        render() {\n            let { props, context } = this;\n            return y(\"div\", {\n                ref: this.rootElRef,\n                className: \"fc-timegrid-slots\"\n            }, y(\"table\", {\n                \"aria-hidden\": true,\n                className: context.theme.getClass('table'),\n                style: {\n                    minWidth: props.tableMinWidth,\n                    width: props.clientWidth,\n                    height: props.minHeight\n                }\n            }, props.tableColGroupNode /* relies on there only being a single <col> for the axis */ , y(TimeColsSlatsBody, {\n                slatElRefs: this.slatElRefs,\n                axis: props.axis,\n                slatMetas: props.slatMetas\n            })));\n        }\n        componentDidMount() {\n            this.updateSizing();\n        }\n        componentDidUpdate() {\n            this.updateSizing();\n        }\n        componentWillUnmount() {\n            if (this.props.onCoords) {\n                this.props.onCoords(null);\n            }\n        }\n        updateSizing() {\n            let { context, props } = this;\n            if (props.onCoords && props.clientWidth !== null // means sizing has stabilized\n            ) {\n                let rootEl = this.rootElRef.current;\n                if (rootEl.offsetHeight) {\n                    props.onCoords(new TimeColsSlatsCoords(new PositionCache(this.rootElRef.current, collectSlatEls(this.slatElRefs.currentMap, props.slatMetas), false, true), this.props.dateProfile, context.options.slotDuration));\n                }\n            }\n        }\n        constructor(){\n            super(...arguments);\n            this.rootElRef = d();\n            this.slatElRefs = new RefMap();\n        }\n    }\n    function collectSlatEls(elMap, slatMetas) {\n        return slatMetas.map((slatMeta)=>elMap[slatMeta.key]);\n    }\n    function splitSegsByCol(segs, colCnt) {\n        let segsByCol = [];\n        let i;\n        for(i = 0; i < colCnt; i += 1){\n            segsByCol.push([]);\n        }\n        if (segs) {\n            for(i = 0; i < segs.length; i += 1){\n                segsByCol[segs[i].col].push(segs[i]);\n            }\n        }\n        return segsByCol;\n    }\n    function splitInteractionByCol(ui, colCnt) {\n        let byRow = [];\n        if (!ui) {\n            for(let i = 0; i < colCnt; i += 1){\n                byRow[i] = null;\n            }\n        } else {\n            for(let i = 0; i < colCnt; i += 1){\n                byRow[i] = {\n                    affectedInstances: ui.affectedInstances,\n                    isEvent: ui.isEvent,\n                    segs: []\n                };\n            }\n            for (let seg of ui.segs){\n                byRow[seg.col].segs.push(seg);\n            }\n        }\n        return byRow;\n    }\n    class TimeColMoreLink extends BaseComponent {\n        render() {\n            let { props } = this;\n            return y(MoreLinkContainer, {\n                elClasses: [\n                    'fc-timegrid-more-link'\n                ],\n                elStyle: {\n                    top: props.top,\n                    bottom: props.bottom\n                },\n                allDayDate: null,\n                moreCnt: props.hiddenSegs.length,\n                allSegs: props.hiddenSegs,\n                hiddenSegs: props.hiddenSegs,\n                extraDateSpan: props.extraDateSpan,\n                dateProfile: props.dateProfile,\n                todayRange: props.todayRange,\n                popoverContent: ()=>renderPlainFgSegs(props.hiddenSegs, props),\n                defaultGenerator: renderMoreLinkInner,\n                forceTimed: true\n            }, (InnerContent)=>y(InnerContent, {\n                    elTag: \"div\",\n                    elClasses: [\n                        'fc-timegrid-more-link-inner',\n                        'fc-sticky'\n                    ]\n                }));\n        }\n    }\n    function renderMoreLinkInner(props) {\n        return props.shortText;\n    }\n    // segInputs assumed sorted\n    function buildPositioning(segInputs, strictOrder, maxStackCnt) {\n        let hierarchy = new SegHierarchy();\n        if (strictOrder != null) {\n            hierarchy.strictOrder = strictOrder;\n        }\n        if (maxStackCnt != null) {\n            hierarchy.maxStackCnt = maxStackCnt;\n        }\n        let hiddenEntries = hierarchy.addSegs(segInputs);\n        let hiddenGroups = groupIntersectingEntries(hiddenEntries);\n        let web = buildWeb(hierarchy);\n        web = stretchWeb(web, 1); // all levelCoords/thickness will have 0.0-1.0\n        let segRects = webToRects(web);\n        return {\n            segRects,\n            hiddenGroups\n        };\n    }\n    function buildWeb(hierarchy) {\n        const { entriesByLevel } = hierarchy;\n        const buildNode = cacheable((level, lateral)=>level + ':' + lateral, (level, lateral)=>{\n            let siblingRange = findNextLevelSegs(hierarchy, level, lateral);\n            let nextLevelRes = buildNodes(siblingRange, buildNode);\n            let entry = entriesByLevel[level][lateral];\n            return [\n                Object.assign(Object.assign({}, entry), {\n                    nextLevelNodes: nextLevelRes[0]\n                }),\n                entry.thickness + nextLevelRes[1]\n            ];\n        });\n        return buildNodes(entriesByLevel.length ? {\n            level: 0,\n            lateralStart: 0,\n            lateralEnd: entriesByLevel[0].length\n        } : null, buildNode)[0];\n    }\n    function buildNodes(siblingRange, buildNode) {\n        if (!siblingRange) {\n            return [\n                [],\n                0\n            ];\n        }\n        let { level, lateralStart, lateralEnd } = siblingRange;\n        let lateral = lateralStart;\n        let pairs = [];\n        while(lateral < lateralEnd){\n            pairs.push(buildNode(level, lateral));\n            lateral += 1;\n        }\n        pairs.sort(cmpDescPressures);\n        return [\n            pairs.map(extractNode),\n            pairs[0][1]\n        ];\n    }\n    function cmpDescPressures(a, b) {\n        return b[1] - a[1];\n    }\n    function extractNode(a) {\n        return a[0];\n    }\n    function findNextLevelSegs(hierarchy, subjectLevel, subjectLateral) {\n        let { levelCoords, entriesByLevel } = hierarchy;\n        let subjectEntry = entriesByLevel[subjectLevel][subjectLateral];\n        let afterSubject = levelCoords[subjectLevel] + subjectEntry.thickness;\n        let levelCnt = levelCoords.length;\n        let level = subjectLevel;\n        // skip past levels that are too high up\n        for(; level < levelCnt && levelCoords[level] < afterSubject; level += 1); // do nothing\n        for(; level < levelCnt; level += 1){\n            let entries = entriesByLevel[level];\n            let entry;\n            let searchIndex = binarySearch(entries, subjectEntry.span.start, getEntrySpanEnd);\n            let lateralStart = searchIndex[0] + searchIndex[1]; // if exact match (which doesn't collide), go to next one\n            let lateralEnd = lateralStart;\n            while((entry = entries[lateralEnd]) && // but not past the whole seg list\n            entry.span.start < subjectEntry.span.end){\n                lateralEnd += 1;\n            }\n            if (lateralStart < lateralEnd) {\n                return {\n                    level,\n                    lateralStart,\n                    lateralEnd\n                };\n            }\n        }\n        return null;\n    }\n    function stretchWeb(topLevelNodes, totalThickness) {\n        const stretchNode = cacheable((node, startCoord, prevThickness)=>buildEntryKey(node), (node, startCoord, prevThickness)=>{\n            let { nextLevelNodes, thickness } = node;\n            let allThickness = thickness + prevThickness;\n            let thicknessFraction = thickness / allThickness;\n            let endCoord;\n            let newChildren = [];\n            if (!nextLevelNodes.length) {\n                endCoord = totalThickness;\n            } else {\n                for (let childNode of nextLevelNodes){\n                    if (endCoord === undefined) {\n                        let res = stretchNode(childNode, startCoord, allThickness);\n                        endCoord = res[0];\n                        newChildren.push(res[1]);\n                    } else {\n                        let res = stretchNode(childNode, endCoord, 0);\n                        newChildren.push(res[1]);\n                    }\n                }\n            }\n            let newThickness = (endCoord - startCoord) * thicknessFraction;\n            return [\n                endCoord - newThickness,\n                Object.assign(Object.assign({}, node), {\n                    thickness: newThickness,\n                    nextLevelNodes: newChildren\n                })\n            ];\n        });\n        return topLevelNodes.map((node)=>stretchNode(node, 0, 0)[1]);\n    }\n    // not sorted in any particular order\n    function webToRects(topLevelNodes) {\n        let rects = [];\n        const processNode = cacheable((node, levelCoord, stackDepth)=>buildEntryKey(node), (node, levelCoord, stackDepth)=>{\n            let rect = Object.assign(Object.assign({}, node), {\n                levelCoord,\n                stackDepth,\n                stackForward: 0\n            });\n            rects.push(rect);\n            return rect.stackForward = processNodes(node.nextLevelNodes, levelCoord + node.thickness, stackDepth + 1) + 1;\n        });\n        function processNodes(nodes, levelCoord, stackDepth) {\n            let stackForward = 0;\n            for (let node of nodes){\n                stackForward = Math.max(processNode(node, levelCoord, stackDepth), stackForward);\n            }\n            return stackForward;\n        }\n        processNodes(topLevelNodes, 0, 0);\n        return rects; // TODO: sort rects by levelCoord to be consistent with toRects?\n    }\n    // TODO: move to general util\n    function cacheable(keyFunc, workFunc) {\n        const cache = {};\n        return function() {\n            for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                args[_key] = arguments[_key];\n            }\n            let key = keyFunc(...args);\n            return key in cache ? cache[key] : cache[key] = workFunc(...args);\n        };\n    }\n    function computeSegVCoords(segs, colDate) {\n        let slatCoords = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null, eventMinHeight = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;\n        let vcoords = [];\n        if (slatCoords) {\n            for(let i = 0; i < segs.length; i += 1){\n                let seg = segs[i];\n                let spanStart = slatCoords.computeDateTop(seg.start, colDate);\n                let spanEnd = Math.max(spanStart + (eventMinHeight || 0), slatCoords.computeDateTop(seg.end, colDate));\n                vcoords.push({\n                    start: Math.round(spanStart),\n                    end: Math.round(spanEnd)\n                });\n            }\n        }\n        return vcoords;\n    }\n    function computeFgSegPlacements(segs, segVCoords, eventOrderStrict, eventMaxStack) {\n        let segInputs = [];\n        let dumbSegs = []; // segs without coords\n        for(let i = 0; i < segs.length; i += 1){\n            let vcoords = segVCoords[i];\n            if (vcoords) {\n                segInputs.push({\n                    index: i,\n                    thickness: 1,\n                    span: vcoords\n                });\n            } else {\n                dumbSegs.push(segs[i]);\n            }\n        }\n        let { segRects, hiddenGroups } = buildPositioning(segInputs, eventOrderStrict, eventMaxStack);\n        let segPlacements = [];\n        for (let segRect of segRects){\n            segPlacements.push({\n                seg: segs[segRect.index],\n                rect: segRect\n            });\n        }\n        for (let dumbSeg of dumbSegs){\n            segPlacements.push({\n                seg: dumbSeg,\n                rect: null\n            });\n        }\n        return {\n            segPlacements,\n            hiddenGroups\n        };\n    }\n    const DEFAULT_TIME_FORMAT$1 = createFormatter({\n        hour: 'numeric',\n        minute: '2-digit',\n        meridiem: false\n    });\n    class TimeColEvent extends BaseComponent {\n        render() {\n            return y(StandardEvent, Object.assign({}, this.props, {\n                elClasses: [\n                    'fc-timegrid-event',\n                    'fc-v-event',\n                    this.props.isShort && 'fc-timegrid-event-short'\n                ],\n                defaultTimeFormat: DEFAULT_TIME_FORMAT$1\n            }));\n        }\n    }\n    class TimeCol extends BaseComponent {\n        // TODO: memoize event-placement?\n        render() {\n            let { props, context } = this;\n            let { options } = context;\n            let isSelectMirror = options.selectMirror;\n            let mirrorSegs = props.eventDrag && props.eventDrag.segs || props.eventResize && props.eventResize.segs || isSelectMirror && props.dateSelectionSegs || [];\n            let interactionAffectedInstances = props.eventDrag && props.eventDrag.affectedInstances || props.eventResize && props.eventResize.affectedInstances || {};\n            let sortedFgSegs = this.sortEventSegs(props.fgEventSegs, options.eventOrder);\n            return y(DayCellContainer, {\n                elTag: \"td\",\n                elRef: props.elRef,\n                elClasses: [\n                    'fc-timegrid-col',\n                    ...props.extraClassNames || []\n                ],\n                elAttrs: Object.assign({\n                    role: 'gridcell'\n                }, props.extraDataAttrs),\n                date: props.date,\n                dateProfile: props.dateProfile,\n                todayRange: props.todayRange,\n                extraRenderProps: props.extraRenderProps\n            }, (InnerContent)=>y(\"div\", {\n                    className: \"fc-timegrid-col-frame\"\n                }, y(\"div\", {\n                    className: \"fc-timegrid-col-bg\"\n                }, this.renderFillSegs(props.businessHourSegs, 'non-business'), this.renderFillSegs(props.bgEventSegs, 'bg-event'), this.renderFillSegs(props.dateSelectionSegs, 'highlight')), y(\"div\", {\n                    className: \"fc-timegrid-col-events\"\n                }, this.renderFgSegs(sortedFgSegs, interactionAffectedInstances, false, false, false)), y(\"div\", {\n                    className: \"fc-timegrid-col-events\"\n                }, this.renderFgSegs(mirrorSegs, {}, Boolean(props.eventDrag), Boolean(props.eventResize), Boolean(isSelectMirror), 'mirror')), y(\"div\", {\n                    className: \"fc-timegrid-now-indicator-container\"\n                }, this.renderNowIndicator(props.nowIndicatorSegs)), hasCustomDayCellContent(options) && y(InnerContent, {\n                    elTag: \"div\",\n                    elClasses: [\n                        'fc-timegrid-col-misc'\n                    ]\n                })));\n        }\n        renderFgSegs(sortedFgSegs, segIsInvisible, isDragging, isResizing, isDateSelecting, forcedKey) {\n            let { props } = this;\n            if (props.forPrint) {\n                return renderPlainFgSegs(sortedFgSegs, props);\n            }\n            return this.renderPositionedFgSegs(sortedFgSegs, segIsInvisible, isDragging, isResizing, isDateSelecting, forcedKey);\n        }\n        renderPositionedFgSegs(segs, segIsInvisible, isDragging, isResizing, isDateSelecting, forcedKey) {\n            let { eventMaxStack, eventShortHeight, eventOrderStrict, eventMinHeight } = this.context.options;\n            let { date, slatCoords, eventSelection, todayRange, nowDate } = this.props;\n            let isMirror = isDragging || isResizing || isDateSelecting;\n            let segVCoords = computeSegVCoords(segs, date, slatCoords, eventMinHeight);\n            let { segPlacements, hiddenGroups } = computeFgSegPlacements(segs, segVCoords, eventOrderStrict, eventMaxStack);\n            return y(_, null, this.renderHiddenGroups(hiddenGroups, segs), segPlacements.map((segPlacement)=>{\n                let { seg, rect } = segPlacement;\n                let instanceId = seg.eventRange.instance.instanceId;\n                let isVisible = isMirror || Boolean(!segIsInvisible[instanceId] && rect);\n                let vStyle = computeSegVStyle(rect && rect.span);\n                let hStyle = !isMirror && rect ? this.computeSegHStyle(rect) : {\n                    left: 0,\n                    right: 0\n                };\n                let isInset = Boolean(rect) && rect.stackForward > 0;\n                let isShort = Boolean(rect) && rect.span.end - rect.span.start < eventShortHeight; // look at other places for this problem\n                return y(\"div\", {\n                    className: 'fc-timegrid-event-harness' + (isInset ? ' fc-timegrid-event-harness-inset' : ''),\n                    key: forcedKey || instanceId,\n                    style: Object.assign(Object.assign({\n                        visibility: isVisible ? '' : 'hidden'\n                    }, vStyle), hStyle)\n                }, y(TimeColEvent, Object.assign({\n                    seg: seg,\n                    isDragging: isDragging,\n                    isResizing: isResizing,\n                    isDateSelecting: isDateSelecting,\n                    isSelected: instanceId === eventSelection,\n                    isShort: isShort\n                }, getSegMeta(seg, todayRange, nowDate))));\n            }));\n        }\n        // will already have eventMinHeight applied because segInputs already had it\n        renderHiddenGroups(hiddenGroups, segs) {\n            let { extraDateSpan, dateProfile, todayRange, nowDate, eventSelection, eventDrag, eventResize } = this.props;\n            return y(_, null, hiddenGroups.map((hiddenGroup)=>{\n                let positionCss = computeSegVStyle(hiddenGroup.span);\n                let hiddenSegs = compileSegsFromEntries(hiddenGroup.entries, segs);\n                return y(TimeColMoreLink, {\n                    key: buildIsoString(computeEarliestSegStart(hiddenSegs)),\n                    hiddenSegs: hiddenSegs,\n                    top: positionCss.top,\n                    bottom: positionCss.bottom,\n                    extraDateSpan: extraDateSpan,\n                    dateProfile: dateProfile,\n                    todayRange: todayRange,\n                    nowDate: nowDate,\n                    eventSelection: eventSelection,\n                    eventDrag: eventDrag,\n                    eventResize: eventResize\n                });\n            }));\n        }\n        renderFillSegs(segs, fillType) {\n            let { props, context } = this;\n            let segVCoords = computeSegVCoords(segs, props.date, props.slatCoords, context.options.eventMinHeight); // don't assume all populated\n            let children = segVCoords.map((vcoords, i)=>{\n                let seg = segs[i];\n                return y(\"div\", {\n                    key: buildEventRangeKey(seg.eventRange),\n                    className: \"fc-timegrid-bg-harness\",\n                    style: computeSegVStyle(vcoords)\n                }, fillType === 'bg-event' ? y(BgEvent, Object.assign({\n                    seg: seg\n                }, getSegMeta(seg, props.todayRange, props.nowDate))) : renderFill(fillType));\n            });\n            return y(_, null, children);\n        }\n        renderNowIndicator(segs) {\n            let { slatCoords, date } = this.props;\n            if (!slatCoords) {\n                return null;\n            }\n            return segs.map((seg, i)=>y(NowIndicatorContainer, {\n                    // key doesn't matter. will only ever be one\n                    key: i,\n                    elClasses: [\n                        'fc-timegrid-now-indicator-line'\n                    ],\n                    elStyle: {\n                        top: slatCoords.computeDateTop(seg.start, date)\n                    },\n                    isAxis: false,\n                    date: date\n                }));\n        }\n        computeSegHStyle(segHCoords) {\n            let { isRtl, options } = this.context;\n            let shouldOverlap = options.slotEventOverlap;\n            let nearCoord = segHCoords.levelCoord; // the left side if LTR. the right side if RTL. floating-point\n            let farCoord = segHCoords.levelCoord + segHCoords.thickness; // the right side if LTR. the left side if RTL. floating-point\n            let left; // amount of space from left edge, a fraction of the total width\n            let right; // amount of space from right edge, a fraction of the total width\n            if (shouldOverlap) {\n                // double the width, but don't go beyond the maximum forward coordinate (1.0)\n                farCoord = Math.min(1, nearCoord + (farCoord - nearCoord) * 2);\n            }\n            if (isRtl) {\n                left = 1 - farCoord;\n                right = nearCoord;\n            } else {\n                left = nearCoord;\n                right = 1 - farCoord;\n            }\n            let props = {\n                zIndex: segHCoords.stackDepth + 1,\n                left: left * 100 + '%',\n                right: right * 100 + '%'\n            };\n            if (shouldOverlap && !segHCoords.stackForward) {\n                // add padding to the edge so that forward stacked events don't cover the resizer's icon\n                props[isRtl ? 'marginLeft' : 'marginRight'] = 10 * 2; // 10 is a guesstimate of the icon's width\n            }\n            return props;\n        }\n        constructor(){\n            super(...arguments);\n            this.sortEventSegs = memoize(sortEventSegs);\n        }\n    }\n    function renderPlainFgSegs(sortedFgSegs, param) {\n        let { todayRange, nowDate, eventSelection, eventDrag, eventResize } = param;\n        let hiddenInstances = (eventDrag ? eventDrag.affectedInstances : null) || (eventResize ? eventResize.affectedInstances : null) || {};\n        return y(_, null, sortedFgSegs.map((seg)=>{\n            let instanceId = seg.eventRange.instance.instanceId;\n            return y(\"div\", {\n                key: instanceId,\n                style: {\n                    visibility: hiddenInstances[instanceId] ? 'hidden' : ''\n                }\n            }, y(TimeColEvent, Object.assign({\n                seg: seg,\n                isDragging: false,\n                isResizing: false,\n                isDateSelecting: false,\n                isSelected: instanceId === eventSelection,\n                isShort: false\n            }, getSegMeta(seg, todayRange, nowDate))));\n        }));\n    }\n    function computeSegVStyle(segVCoords) {\n        if (!segVCoords) {\n            return {\n                top: '',\n                bottom: ''\n            };\n        }\n        return {\n            top: segVCoords.start,\n            bottom: -segVCoords.end\n        };\n    }\n    function compileSegsFromEntries(segEntries, allSegs) {\n        return segEntries.map((segEntry)=>allSegs[segEntry.index]);\n    }\n    class TimeColsContent extends BaseComponent {\n        render() {\n            let { props, context } = this;\n            let nowIndicatorTop = context.options.nowIndicator && props.slatCoords && props.slatCoords.safeComputeTop(props.nowDate); // might return void\n            let colCnt = props.cells.length;\n            let fgEventSegsByRow = this.splitFgEventSegs(props.fgEventSegs, colCnt);\n            let bgEventSegsByRow = this.splitBgEventSegs(props.bgEventSegs, colCnt);\n            let businessHourSegsByRow = this.splitBusinessHourSegs(props.businessHourSegs, colCnt);\n            let nowIndicatorSegsByRow = this.splitNowIndicatorSegs(props.nowIndicatorSegs, colCnt);\n            let dateSelectionSegsByRow = this.splitDateSelectionSegs(props.dateSelectionSegs, colCnt);\n            let eventDragByRow = this.splitEventDrag(props.eventDrag, colCnt);\n            let eventResizeByRow = this.splitEventResize(props.eventResize, colCnt);\n            return y(\"div\", {\n                className: \"fc-timegrid-cols\",\n                ref: this.rootElRef\n            }, y(\"table\", {\n                role: \"presentation\",\n                style: {\n                    minWidth: props.tableMinWidth,\n                    width: props.clientWidth\n                }\n            }, props.tableColGroupNode, y(\"tbody\", {\n                role: \"presentation\"\n            }, y(\"tr\", {\n                role: \"row\"\n            }, props.axis && y(\"td\", {\n                \"aria-hidden\": true,\n                className: \"fc-timegrid-col fc-timegrid-axis\"\n            }, y(\"div\", {\n                className: \"fc-timegrid-col-frame\"\n            }, y(\"div\", {\n                className: \"fc-timegrid-now-indicator-container\"\n            }, typeof nowIndicatorTop === 'number' && y(NowIndicatorContainer, {\n                elClasses: [\n                    'fc-timegrid-now-indicator-arrow'\n                ],\n                elStyle: {\n                    top: nowIndicatorTop\n                },\n                isAxis: true,\n                date: props.nowDate\n            })))), props.cells.map((cell, i)=>y(TimeCol, {\n                    key: cell.key,\n                    elRef: this.cellElRefs.createRef(cell.key),\n                    dateProfile: props.dateProfile,\n                    date: cell.date,\n                    nowDate: props.nowDate,\n                    todayRange: props.todayRange,\n                    extraRenderProps: cell.extraRenderProps,\n                    extraDataAttrs: cell.extraDataAttrs,\n                    extraClassNames: cell.extraClassNames,\n                    extraDateSpan: cell.extraDateSpan,\n                    fgEventSegs: fgEventSegsByRow[i],\n                    bgEventSegs: bgEventSegsByRow[i],\n                    businessHourSegs: businessHourSegsByRow[i],\n                    nowIndicatorSegs: nowIndicatorSegsByRow[i],\n                    dateSelectionSegs: dateSelectionSegsByRow[i],\n                    eventDrag: eventDragByRow[i],\n                    eventResize: eventResizeByRow[i],\n                    slatCoords: props.slatCoords,\n                    eventSelection: props.eventSelection,\n                    forPrint: props.forPrint\n                }))))));\n        }\n        componentDidMount() {\n            this.updateCoords();\n        }\n        componentDidUpdate() {\n            this.updateCoords();\n        }\n        updateCoords() {\n            let { props } = this;\n            if (props.onColCoords && props.clientWidth !== null // means sizing has stabilized\n            ) {\n                props.onColCoords(new PositionCache(this.rootElRef.current, collectCellEls(this.cellElRefs.currentMap, props.cells), true, false));\n            }\n        }\n        constructor(){\n            super(...arguments);\n            this.splitFgEventSegs = memoize(splitSegsByCol);\n            this.splitBgEventSegs = memoize(splitSegsByCol);\n            this.splitBusinessHourSegs = memoize(splitSegsByCol);\n            this.splitNowIndicatorSegs = memoize(splitSegsByCol);\n            this.splitDateSelectionSegs = memoize(splitSegsByCol);\n            this.splitEventDrag = memoize(splitInteractionByCol);\n            this.splitEventResize = memoize(splitInteractionByCol);\n            this.rootElRef = d();\n            this.cellElRefs = new RefMap();\n        }\n    }\n    function collectCellEls(elMap, cells) {\n        return cells.map((cell)=>elMap[cell.key]);\n    }\n    /* A component that renders one or more columns of vertical time slots\r\n    ----------------------------------------------------------------------------------------------------------------------*/ class TimeCols extends DateComponent {\n        render() {\n            let { props, state } = this;\n            return y(\"div\", {\n                className: \"fc-timegrid-body\",\n                ref: this.handleRootEl,\n                style: {\n                    // these props are important to give this wrapper correct dimensions for interactions\n                    // TODO: if we set it here, can we avoid giving to inner tables?\n                    width: props.clientWidth,\n                    minWidth: props.tableMinWidth\n                }\n            }, y(TimeColsSlats, {\n                axis: props.axis,\n                dateProfile: props.dateProfile,\n                slatMetas: props.slatMetas,\n                clientWidth: props.clientWidth,\n                minHeight: props.expandRows ? props.clientHeight : '',\n                tableMinWidth: props.tableMinWidth,\n                tableColGroupNode: props.axis ? props.tableColGroupNode : null,\n                onCoords: this.handleSlatCoords\n            }), y(TimeColsContent, {\n                cells: props.cells,\n                axis: props.axis,\n                dateProfile: props.dateProfile,\n                businessHourSegs: props.businessHourSegs,\n                bgEventSegs: props.bgEventSegs,\n                fgEventSegs: props.fgEventSegs,\n                dateSelectionSegs: props.dateSelectionSegs,\n                eventSelection: props.eventSelection,\n                eventDrag: props.eventDrag,\n                eventResize: props.eventResize,\n                todayRange: props.todayRange,\n                nowDate: props.nowDate,\n                nowIndicatorSegs: props.nowIndicatorSegs,\n                clientWidth: props.clientWidth,\n                tableMinWidth: props.tableMinWidth,\n                tableColGroupNode: props.tableColGroupNode,\n                slatCoords: state.slatCoords,\n                onColCoords: this.handleColCoords,\n                forPrint: props.forPrint\n            }));\n        }\n        componentDidMount() {\n            this.scrollResponder = this.context.createScrollResponder(this.handleScrollRequest);\n        }\n        componentDidUpdate(prevProps) {\n            this.scrollResponder.update(prevProps.dateProfile !== this.props.dateProfile);\n        }\n        componentWillUnmount() {\n            this.scrollResponder.detach();\n        }\n        queryHit(positionLeft, positionTop) {\n            let { dateEnv, options } = this.context;\n            let { colCoords } = this;\n            let { dateProfile } = this.props;\n            let { slatCoords } = this.state;\n            let { snapDuration, snapsPerSlot } = this.processSlotOptions(this.props.slotDuration, options.snapDuration);\n            let colIndex = colCoords.leftToIndex(positionLeft);\n            let slatIndex = slatCoords.positions.topToIndex(positionTop);\n            if (colIndex != null && slatIndex != null) {\n                let cell = this.props.cells[colIndex];\n                let slatTop = slatCoords.positions.tops[slatIndex];\n                let slatHeight = slatCoords.positions.getHeight(slatIndex);\n                let partial = (positionTop - slatTop) / slatHeight; // floating point number between 0 and 1\n                let localSnapIndex = Math.floor(partial * snapsPerSlot); // the snap # relative to start of slat\n                let snapIndex = slatIndex * snapsPerSlot + localSnapIndex;\n                let dayDate = this.props.cells[colIndex].date;\n                let time = addDurations(dateProfile.slotMinTime, multiplyDuration(snapDuration, snapIndex));\n                let start = dateEnv.add(dayDate, time);\n                let end = dateEnv.add(start, snapDuration);\n                return {\n                    dateProfile,\n                    dateSpan: Object.assign({\n                        range: {\n                            start,\n                            end\n                        },\n                        allDay: false\n                    }, cell.extraDateSpan),\n                    dayEl: colCoords.els[colIndex],\n                    rect: {\n                        left: colCoords.lefts[colIndex],\n                        right: colCoords.rights[colIndex],\n                        top: slatTop,\n                        bottom: slatTop + slatHeight\n                    },\n                    layer: 0\n                };\n            }\n            return null;\n        }\n        constructor(){\n            super(...arguments);\n            this.processSlotOptions = memoize(processSlotOptions);\n            this.state = {\n                slatCoords: null\n            };\n            this.handleRootEl = (el)=>{\n                if (el) {\n                    this.context.registerInteractiveComponent(this, {\n                        el,\n                        isHitComboAllowed: this.props.isHitComboAllowed\n                    });\n                } else {\n                    this.context.unregisterInteractiveComponent(this);\n                }\n            };\n            this.handleScrollRequest = (request)=>{\n                let { onScrollTopRequest } = this.props;\n                let { slatCoords } = this.state;\n                if (onScrollTopRequest && slatCoords) {\n                    if (request.time) {\n                        let top = slatCoords.computeTimeTop(request.time);\n                        top = Math.ceil(top); // zoom can give weird floating-point values. rather scroll a little bit further\n                        if (top) {\n                            top += 1; // to overcome top border that slots beyond the first have. looks better\n                        }\n                        onScrollTopRequest(top);\n                    }\n                    return true;\n                }\n                return false;\n            };\n            this.handleColCoords = (colCoords)=>{\n                this.colCoords = colCoords;\n            };\n            this.handleSlatCoords = (slatCoords)=>{\n                this.setState({\n                    slatCoords\n                });\n                if (this.props.onSlatCoords) {\n                    this.props.onSlatCoords(slatCoords);\n                }\n            };\n        }\n    }\n    function processSlotOptions(slotDuration, snapDurationOverride) {\n        let snapDuration = snapDurationOverride || slotDuration;\n        let snapsPerSlot = wholeDivideDurations(slotDuration, snapDuration);\n        if (snapsPerSlot === null) {\n            snapDuration = slotDuration;\n            snapsPerSlot = 1;\n        // TODO: say warning?\n        }\n        return {\n            snapDuration,\n            snapsPerSlot\n        };\n    }\n    class DayTimeColsSlicer extends Slicer {\n        sliceRange(range, dayRanges) {\n            let segs = [];\n            for(let col = 0; col < dayRanges.length; col += 1){\n                let segRange = intersectRanges(range, dayRanges[col]);\n                if (segRange) {\n                    segs.push({\n                        start: segRange.start,\n                        end: segRange.end,\n                        isStart: segRange.start.valueOf() === range.start.valueOf(),\n                        isEnd: segRange.end.valueOf() === range.end.valueOf(),\n                        col\n                    });\n                }\n            }\n            return segs;\n        }\n    }\n    class DayTimeCols extends DateComponent {\n        render() {\n            let { props, context } = this;\n            let { dateProfile, dayTableModel } = props;\n            let { nowIndicator, nextDayThreshold } = context.options;\n            let dayRanges = this.buildDayRanges(dayTableModel, dateProfile, context.dateEnv);\n            // give it the first row of cells\n            // TODO: would move this further down hierarchy, but sliceNowDate needs it\n            return y(NowTimer, {\n                unit: nowIndicator ? 'minute' : 'day'\n            }, (nowDate, todayRange)=>y(TimeCols, Object.assign({\n                    ref: this.timeColsRef\n                }, this.slicer.sliceProps(props, dateProfile, null, context, dayRanges), {\n                    forPrint: props.forPrint,\n                    axis: props.axis,\n                    dateProfile: dateProfile,\n                    slatMetas: props.slatMetas,\n                    slotDuration: props.slotDuration,\n                    cells: dayTableModel.cells[0],\n                    tableColGroupNode: props.tableColGroupNode,\n                    tableMinWidth: props.tableMinWidth,\n                    clientWidth: props.clientWidth,\n                    clientHeight: props.clientHeight,\n                    expandRows: props.expandRows,\n                    nowDate: nowDate,\n                    nowIndicatorSegs: nowIndicator && this.slicer.sliceNowDate(nowDate, dateProfile, nextDayThreshold, context, dayRanges),\n                    todayRange: todayRange,\n                    onScrollTopRequest: props.onScrollTopRequest,\n                    onSlatCoords: props.onSlatCoords\n                })));\n        }\n        constructor(){\n            super(...arguments);\n            this.buildDayRanges = memoize(buildDayRanges);\n            this.slicer = new DayTimeColsSlicer();\n            this.timeColsRef = d();\n        }\n    }\n    function buildDayRanges(dayTableModel, dateProfile, dateEnv) {\n        let ranges = [];\n        for (let date of dayTableModel.headerDates){\n            ranges.push({\n                start: dateEnv.add(date, dateProfile.slotMinTime),\n                end: dateEnv.add(date, dateProfile.slotMaxTime)\n            });\n        }\n        return ranges;\n    }\n    // potential nice values for the slot-duration and interval-duration\n    // from largest to smallest\n    const STOCK_SUB_DURATIONS = [\n        {\n            hours: 1\n        },\n        {\n            minutes: 30\n        },\n        {\n            minutes: 15\n        },\n        {\n            seconds: 30\n        },\n        {\n            seconds: 15\n        }\n    ];\n    function buildSlatMetas(slotMinTime, slotMaxTime, explicitLabelInterval, slotDuration, dateEnv) {\n        let dayStart = new Date(0);\n        let slatTime = slotMinTime;\n        let slatIterator = createDuration(0);\n        let labelInterval = explicitLabelInterval || computeLabelInterval(slotDuration);\n        let metas = [];\n        while(asRoughMs(slatTime) < asRoughMs(slotMaxTime)){\n            let date = dateEnv.add(dayStart, slatTime);\n            let isLabeled = wholeDivideDurations(slatIterator, labelInterval) !== null;\n            metas.push({\n                date,\n                time: slatTime,\n                key: date.toISOString(),\n                isoTimeStr: formatIsoTimeString(date),\n                isLabeled\n            });\n            slatTime = addDurations(slatTime, slotDuration);\n            slatIterator = addDurations(slatIterator, slotDuration);\n        }\n        return metas;\n    }\n    // Computes an automatic value for slotLabelInterval\n    function computeLabelInterval(slotDuration) {\n        let i;\n        let labelInterval;\n        let slotsPerLabel;\n        // find the smallest stock label interval that results in more than one slots-per-label\n        for(i = STOCK_SUB_DURATIONS.length - 1; i >= 0; i -= 1){\n            labelInterval = createDuration(STOCK_SUB_DURATIONS[i]);\n            slotsPerLabel = wholeDivideDurations(labelInterval, slotDuration);\n            if (slotsPerLabel !== null && slotsPerLabel > 1) {\n                return labelInterval;\n            }\n        }\n        return slotDuration; // fall back\n    }\n    class DayTimeColsView extends TimeColsView {\n        render() {\n            let { options, dateEnv, dateProfileGenerator } = this.context;\n            let { props } = this;\n            let { dateProfile } = props;\n            let dayTableModel = this.buildTimeColsModel(dateProfile, dateProfileGenerator);\n            let splitProps = this.allDaySplitter.splitProps(props);\n            let slatMetas = this.buildSlatMetas(dateProfile.slotMinTime, dateProfile.slotMaxTime, options.slotLabelInterval, options.slotDuration, dateEnv);\n            let { dayMinWidth } = options;\n            let hasAttachedAxis = !dayMinWidth;\n            let hasDetachedAxis = dayMinWidth;\n            let headerContent = options.dayHeaders && y(DayHeader, {\n                dates: dayTableModel.headerDates,\n                dateProfile: dateProfile,\n                datesRepDistinctDays: true,\n                renderIntro: hasAttachedAxis ? this.renderHeadAxis : null\n            });\n            let allDayContent = options.allDaySlot !== false && ((contentArg)=>y(DayTable, Object.assign({}, splitProps.allDay, {\n                    dateProfile: dateProfile,\n                    dayTableModel: dayTableModel,\n                    nextDayThreshold: options.nextDayThreshold,\n                    tableMinWidth: contentArg.tableMinWidth,\n                    colGroupNode: contentArg.tableColGroupNode,\n                    renderRowIntro: hasAttachedAxis ? this.renderTableRowAxis : null,\n                    showWeekNumbers: false,\n                    expandRows: false,\n                    headerAlignElRef: this.headerElRef,\n                    clientWidth: contentArg.clientWidth,\n                    clientHeight: contentArg.clientHeight,\n                    forPrint: props.forPrint\n                }, this.getAllDayMaxEventProps())));\n            let timeGridContent = (contentArg)=>y(DayTimeCols, Object.assign({}, splitProps.timed, {\n                    dayTableModel: dayTableModel,\n                    dateProfile: dateProfile,\n                    axis: hasAttachedAxis,\n                    slotDuration: options.slotDuration,\n                    slatMetas: slatMetas,\n                    forPrint: props.forPrint,\n                    tableColGroupNode: contentArg.tableColGroupNode,\n                    tableMinWidth: contentArg.tableMinWidth,\n                    clientWidth: contentArg.clientWidth,\n                    clientHeight: contentArg.clientHeight,\n                    onSlatCoords: this.handleSlatCoords,\n                    expandRows: contentArg.expandRows,\n                    onScrollTopRequest: this.handleScrollTopRequest\n                }));\n            return hasDetachedAxis ? this.renderHScrollLayout(headerContent, allDayContent, timeGridContent, dayTableModel.colCnt, dayMinWidth, slatMetas, this.state.slatCoords) : this.renderSimpleLayout(headerContent, allDayContent, timeGridContent);\n        }\n        constructor(){\n            super(...arguments);\n            this.buildTimeColsModel = memoize(buildTimeColsModel);\n            this.buildSlatMetas = memoize(buildSlatMetas);\n        }\n    }\n    function buildTimeColsModel(dateProfile, dateProfileGenerator) {\n        let daySeries = new DaySeriesModel(dateProfile.renderRange, dateProfileGenerator);\n        return new DayTableModel(daySeries, false);\n    }\n    const OPTION_REFINERS$2 = {\n        allDaySlot: Boolean\n    };\n    var index$2 = createPlugin({\n        name: '@fullcalendar/timegrid',\n        initialView: 'timeGridWeek',\n        optionRefiners: OPTION_REFINERS$2,\n        views: {\n            timeGrid: {\n                component: DayTimeColsView,\n                usesMinMaxTime: true,\n                allDaySlot: true,\n                slotDuration: '00:30:00',\n                slotEventOverlap: true\n            },\n            timeGridDay: {\n                type: 'timeGrid',\n                duration: {\n                    days: 1\n                }\n            },\n            timeGridWeek: {\n                type: 'timeGrid',\n                duration: {\n                    weeks: 1\n                }\n            }\n        }\n    });\n    var css_248z$1 = \":root{--fc-list-event-dot-width:10px;--fc-list-event-hover-bg-color:#f5f5f5}.fc-theme-standard .fc-list{border:1px solid var(--fc-border-color)}.fc .fc-list-empty{align-items:center;background-color:var(--fc-neutral-bg-color);display:flex;height:100%;justify-content:center}.fc .fc-list-empty-cushion{margin:5em 0}.fc .fc-list-table{border-style:hidden;width:100%}.fc .fc-list-table tr>*{border-left:0;border-right:0}.fc .fc-list-sticky .fc-list-day>*{background:var(--fc-page-bg-color);position:sticky;top:0}.fc .fc-list-table thead{left:-10000px;position:absolute}.fc .fc-list-table tbody>tr:first-child th{border-top:0}.fc .fc-list-table th{padding:0}.fc .fc-list-day-cushion,.fc .fc-list-table td{padding:8px 14px}.fc .fc-list-day-cushion:after{clear:both;content:\\\"\\\";display:table}.fc-theme-standard .fc-list-day-cushion{background-color:var(--fc-neutral-bg-color)}.fc-direction-ltr .fc-list-day-text,.fc-direction-rtl .fc-list-day-side-text{float:left}.fc-direction-ltr .fc-list-day-side-text,.fc-direction-rtl .fc-list-day-text{float:right}.fc-direction-ltr .fc-list-table .fc-list-event-graphic{padding-right:0}.fc-direction-rtl .fc-list-table .fc-list-event-graphic{padding-left:0}.fc .fc-list-event.fc-event-forced-url{cursor:pointer}.fc .fc-list-event:hover td{background-color:var(--fc-list-event-hover-bg-color)}.fc .fc-list-event-graphic,.fc .fc-list-event-time{white-space:nowrap;width:1px}.fc .fc-list-event-dot{border:calc(var(--fc-list-event-dot-width)/2) solid var(--fc-event-border-color);border-radius:calc(var(--fc-list-event-dot-width)/2);box-sizing:content-box;display:inline-block;height:0;width:0}.fc .fc-list-event-title a{color:inherit;text-decoration:none}.fc .fc-list-event.fc-event-forced-url:hover a{text-decoration:underline}\";\n    injectStyles(css_248z$1);\n    class ListViewHeaderRow extends BaseComponent {\n        render() {\n            let { theme, dateEnv, options, viewApi } = this.context;\n            let { cellId, dayDate, todayRange } = this.props;\n            let { textId } = this.state;\n            let dayMeta = getDateMeta(dayDate, todayRange);\n            // will ever be falsy?\n            let text = options.listDayFormat ? dateEnv.format(dayDate, options.listDayFormat) : '';\n            // will ever be falsy? also, BAD NAME \"alt\"\n            let sideText = options.listDaySideFormat ? dateEnv.format(dayDate, options.listDaySideFormat) : '';\n            let renderProps = Object.assign({\n                date: dateEnv.toDate(dayDate),\n                view: viewApi,\n                textId,\n                text,\n                sideText,\n                navLinkAttrs: buildNavLinkAttrs(this.context, dayDate),\n                sideNavLinkAttrs: buildNavLinkAttrs(this.context, dayDate, 'day', false)\n            }, dayMeta);\n            // TODO: make a reusable HOC for dayHeader (used in daygrid/timegrid too)\n            return y(ContentContainer, {\n                elTag: \"tr\",\n                elClasses: [\n                    'fc-list-day',\n                    ...getDayClassNames(dayMeta, theme)\n                ],\n                elAttrs: {\n                    'data-date': formatDayString(dayDate)\n                },\n                renderProps: renderProps,\n                generatorName: \"dayHeaderContent\",\n                customGenerator: options.dayHeaderContent,\n                defaultGenerator: renderInnerContent,\n                classNameGenerator: options.dayHeaderClassNames,\n                didMount: options.dayHeaderDidMount,\n                willUnmount: options.dayHeaderWillUnmount\n            }, (InnerContent)=>y(\"th\", {\n                    scope: \"colgroup\",\n                    colSpan: 3,\n                    id: cellId,\n                    \"aria-labelledby\": textId\n                }, y(InnerContent, {\n                    elTag: \"div\",\n                    elClasses: [\n                        'fc-list-day-cushion',\n                        theme.getClass('tableCellShaded')\n                    ]\n                })));\n        }\n        constructor(){\n            super(...arguments);\n            this.state = {\n                textId: getUniqueDomId()\n            };\n        }\n    }\n    function renderInnerContent(props) {\n        return y(_, null, props.text && y(\"a\", Object.assign({\n            id: props.textId,\n            className: \"fc-list-day-text\"\n        }, props.navLinkAttrs), props.text), props.sideText && /* not keyboard tabbable */ y(\"a\", Object.assign({\n            \"aria-hidden\": true,\n            className: \"fc-list-day-side-text\"\n        }, props.sideNavLinkAttrs), props.sideText));\n    }\n    const DEFAULT_TIME_FORMAT = createFormatter({\n        hour: 'numeric',\n        minute: '2-digit',\n        meridiem: 'short'\n    });\n    class ListViewEventRow extends BaseComponent {\n        render() {\n            let { props, context } = this;\n            let { options } = context;\n            let { seg, timeHeaderId, eventHeaderId, dateHeaderId } = props;\n            let timeFormat = options.eventTimeFormat || DEFAULT_TIME_FORMAT;\n            return y(EventContainer, Object.assign({}, props, {\n                elTag: \"tr\",\n                elClasses: [\n                    'fc-list-event',\n                    seg.eventRange.def.url && 'fc-event-forced-url'\n                ],\n                defaultGenerator: ()=>renderEventInnerContent(seg, context),\n                seg: seg,\n                timeText: \"\",\n                disableDragging: true,\n                disableResizing: true\n            }), (InnerContent, eventContentArg)=>y(_, null, buildTimeContent(seg, timeFormat, context, timeHeaderId, dateHeaderId), y(\"td\", {\n                    \"aria-hidden\": true,\n                    className: \"fc-list-event-graphic\"\n                }, y(\"span\", {\n                    className: \"fc-list-event-dot\",\n                    style: {\n                        borderColor: eventContentArg.borderColor || eventContentArg.backgroundColor\n                    }\n                })), y(InnerContent, {\n                    elTag: \"td\",\n                    elClasses: [\n                        'fc-list-event-title'\n                    ],\n                    elAttrs: {\n                        headers: \"\".concat(eventHeaderId, \" \").concat(dateHeaderId)\n                    }\n                })));\n        }\n    }\n    function renderEventInnerContent(seg, context) {\n        let interactiveAttrs = getSegAnchorAttrs(seg, context);\n        return y(\"a\", Object.assign({}, interactiveAttrs), seg.eventRange.def.title);\n    }\n    function buildTimeContent(seg, timeFormat, context, timeHeaderId, dateHeaderId) {\n        let { options } = context;\n        if (options.displayEventTime !== false) {\n            let eventDef = seg.eventRange.def;\n            let eventInstance = seg.eventRange.instance;\n            let doAllDay = false;\n            let timeText;\n            if (eventDef.allDay) {\n                doAllDay = true;\n            } else if (isMultiDayRange(seg.eventRange.range)) {\n                if (seg.isStart) {\n                    timeText = buildSegTimeText(seg, timeFormat, context, null, null, eventInstance.range.start, seg.end);\n                } else if (seg.isEnd) {\n                    timeText = buildSegTimeText(seg, timeFormat, context, null, null, seg.start, eventInstance.range.end);\n                } else {\n                    doAllDay = true;\n                }\n            } else {\n                timeText = buildSegTimeText(seg, timeFormat, context);\n            }\n            if (doAllDay) {\n                let renderProps = {\n                    text: context.options.allDayText,\n                    view: context.viewApi\n                };\n                return y(ContentContainer, {\n                    elTag: \"td\",\n                    elClasses: [\n                        'fc-list-event-time'\n                    ],\n                    elAttrs: {\n                        headers: \"\".concat(timeHeaderId, \" \").concat(dateHeaderId)\n                    },\n                    renderProps: renderProps,\n                    generatorName: \"allDayContent\",\n                    customGenerator: options.allDayContent,\n                    defaultGenerator: renderAllDayInner,\n                    classNameGenerator: options.allDayClassNames,\n                    didMount: options.allDayDidMount,\n                    willUnmount: options.allDayWillUnmount\n                });\n            }\n            return y(\"td\", {\n                className: \"fc-list-event-time\"\n            }, timeText);\n        }\n        return null;\n    }\n    function renderAllDayInner(renderProps) {\n        return renderProps.text;\n    }\n    /*\r\n    Responsible for the scroller, and forwarding event-related actions into the \"grid\".\r\n    */ class ListView extends DateComponent {\n        render() {\n            let { props, context } = this;\n            let { dayDates, dayRanges } = this.computeDateVars(props.dateProfile);\n            let eventSegs = this.eventStoreToSegs(props.eventStore, props.eventUiBases, dayRanges);\n            return y(ViewContainer, {\n                elRef: this.setRootEl,\n                elClasses: [\n                    'fc-list',\n                    context.theme.getClass('table'),\n                    context.options.stickyHeaderDates !== false ? 'fc-list-sticky' : ''\n                ],\n                viewSpec: context.viewSpec\n            }, y(Scroller, {\n                liquid: !props.isHeightAuto,\n                overflowX: props.isHeightAuto ? 'visible' : 'hidden',\n                overflowY: props.isHeightAuto ? 'visible' : 'auto'\n            }, eventSegs.length > 0 ? this.renderSegList(eventSegs, dayDates) : this.renderEmptyMessage()));\n        }\n        renderEmptyMessage() {\n            let { options, viewApi } = this.context;\n            let renderProps = {\n                text: options.noEventsText,\n                view: viewApi\n            };\n            return y(ContentContainer, {\n                elTag: \"div\",\n                elClasses: [\n                    'fc-list-empty'\n                ],\n                renderProps: renderProps,\n                generatorName: \"noEventsContent\",\n                customGenerator: options.noEventsContent,\n                defaultGenerator: renderNoEventsInner,\n                classNameGenerator: options.noEventsClassNames,\n                didMount: options.noEventsDidMount,\n                willUnmount: options.noEventsWillUnmount\n            }, (InnerContent)=>y(InnerContent, {\n                    elTag: \"div\",\n                    elClasses: [\n                        'fc-list-empty-cushion'\n                    ]\n                }));\n        }\n        renderSegList(allSegs, dayDates) {\n            let { theme, options } = this.context;\n            let { timeHeaderId, eventHeaderId, dateHeaderIdRoot } = this.state;\n            let segsByDay = groupSegsByDay(allSegs); // sparse array\n            return y(NowTimer, {\n                unit: \"day\"\n            }, (nowDate, todayRange)=>{\n                let innerNodes = [];\n                for(let dayIndex = 0; dayIndex < segsByDay.length; dayIndex += 1){\n                    let daySegs = segsByDay[dayIndex];\n                    if (daySegs) {\n                        let dayStr = formatDayString(dayDates[dayIndex]);\n                        let dateHeaderId = dateHeaderIdRoot + '-' + dayStr;\n                        // append a day header\n                        innerNodes.push(y(ListViewHeaderRow, {\n                            key: dayStr,\n                            cellId: dateHeaderId,\n                            dayDate: dayDates[dayIndex],\n                            todayRange: todayRange\n                        }));\n                        daySegs = sortEventSegs(daySegs, options.eventOrder);\n                        for (let seg of daySegs){\n                            innerNodes.push(y(ListViewEventRow, Object.assign({\n                                key: dayStr + ':' + seg.eventRange.instance.instanceId /* are multiple segs for an instanceId */ ,\n                                seg: seg,\n                                isDragging: false,\n                                isResizing: false,\n                                isDateSelecting: false,\n                                isSelected: false,\n                                timeHeaderId: timeHeaderId,\n                                eventHeaderId: eventHeaderId,\n                                dateHeaderId: dateHeaderId\n                            }, getSegMeta(seg, todayRange, nowDate))));\n                        }\n                    }\n                }\n                return y(\"table\", {\n                    className: 'fc-list-table ' + theme.getClass('table')\n                }, y(\"thead\", null, y(\"tr\", null, y(\"th\", {\n                    scope: \"col\",\n                    id: timeHeaderId\n                }, options.timeHint), y(\"th\", {\n                    scope: \"col\",\n                    \"aria-hidden\": true\n                }), y(\"th\", {\n                    scope: \"col\",\n                    id: eventHeaderId\n                }, options.eventHint))), y(\"tbody\", null, innerNodes));\n            });\n        }\n        _eventStoreToSegs(eventStore, eventUiBases, dayRanges) {\n            return this.eventRangesToSegs(sliceEventStore(eventStore, eventUiBases, this.props.dateProfile.activeRange, this.context.options.nextDayThreshold).fg, dayRanges);\n        }\n        eventRangesToSegs(eventRanges, dayRanges) {\n            let segs = [];\n            for (let eventRange of eventRanges){\n                segs.push(...this.eventRangeToSegs(eventRange, dayRanges));\n            }\n            return segs;\n        }\n        eventRangeToSegs(eventRange, dayRanges) {\n            let { dateEnv } = this.context;\n            let { nextDayThreshold } = this.context.options;\n            let range = eventRange.range;\n            let allDay = eventRange.def.allDay;\n            let dayIndex;\n            let segRange;\n            let seg;\n            let segs = [];\n            for(dayIndex = 0; dayIndex < dayRanges.length; dayIndex += 1){\n                segRange = intersectRanges(range, dayRanges[dayIndex]);\n                if (segRange) {\n                    seg = {\n                        component: this,\n                        eventRange,\n                        start: segRange.start,\n                        end: segRange.end,\n                        isStart: eventRange.isStart && segRange.start.valueOf() === range.start.valueOf(),\n                        isEnd: eventRange.isEnd && segRange.end.valueOf() === range.end.valueOf(),\n                        dayIndex\n                    };\n                    segs.push(seg);\n                    // detect when range won't go fully into the next day,\n                    // and mutate the latest seg to the be the end.\n                    if (!seg.isEnd && !allDay && dayIndex + 1 < dayRanges.length && range.end < dateEnv.add(dayRanges[dayIndex + 1].start, nextDayThreshold)) {\n                        seg.end = range.end;\n                        seg.isEnd = true;\n                        break;\n                    }\n                }\n            }\n            return segs;\n        }\n        constructor(){\n            super(...arguments);\n            this.computeDateVars = memoize(computeDateVars);\n            this.eventStoreToSegs = memoize(this._eventStoreToSegs);\n            this.state = {\n                timeHeaderId: getUniqueDomId(),\n                eventHeaderId: getUniqueDomId(),\n                dateHeaderIdRoot: getUniqueDomId()\n            };\n            this.setRootEl = (rootEl)=>{\n                if (rootEl) {\n                    this.context.registerInteractiveComponent(this, {\n                        el: rootEl\n                    });\n                } else {\n                    this.context.unregisterInteractiveComponent(this);\n                }\n            };\n        }\n    }\n    function renderNoEventsInner(renderProps) {\n        return renderProps.text;\n    }\n    function computeDateVars(dateProfile) {\n        let dayStart = startOfDay(dateProfile.renderRange.start);\n        let viewEnd = dateProfile.renderRange.end;\n        let dayDates = [];\n        let dayRanges = [];\n        while(dayStart < viewEnd){\n            dayDates.push(dayStart);\n            dayRanges.push({\n                start: dayStart,\n                end: addDays(dayStart, 1)\n            });\n            dayStart = addDays(dayStart, 1);\n        }\n        return {\n            dayDates,\n            dayRanges\n        };\n    }\n    // Returns a sparse array of arrays, segs grouped by their dayIndex\n    function groupSegsByDay(segs) {\n        let segsByDay = []; // sparse array\n        let i;\n        let seg;\n        for(i = 0; i < segs.length; i += 1){\n            seg = segs[i];\n            (segsByDay[seg.dayIndex] || (segsByDay[seg.dayIndex] = [])).push(seg);\n        }\n        return segsByDay;\n    }\n    const OPTION_REFINERS$1 = {\n        listDayFormat: createFalsableFormatter,\n        listDaySideFormat: createFalsableFormatter,\n        noEventsClassNames: identity,\n        noEventsContent: identity,\n        noEventsDidMount: identity,\n        noEventsWillUnmount: identity\n    };\n    function createFalsableFormatter(input) {\n        return input === false ? null : createFormatter(input);\n    }\n    var index$1 = createPlugin({\n        name: '@fullcalendar/list',\n        optionRefiners: OPTION_REFINERS$1,\n        views: {\n            list: {\n                component: ListView,\n                buttonTextKey: 'list',\n                listDayFormat: {\n                    month: 'long',\n                    day: 'numeric',\n                    year: 'numeric'\n                }\n            },\n            listDay: {\n                type: 'list',\n                duration: {\n                    days: 1\n                },\n                listDayFormat: {\n                    weekday: 'long'\n                }\n            },\n            listWeek: {\n                type: 'list',\n                duration: {\n                    weeks: 1\n                },\n                listDayFormat: {\n                    weekday: 'long'\n                },\n                listDaySideFormat: {\n                    month: 'long',\n                    day: 'numeric',\n                    year: 'numeric'\n                }\n            },\n            listMonth: {\n                type: 'list',\n                duration: {\n                    month: 1\n                },\n                listDaySideFormat: {\n                    weekday: 'long'\n                }\n            },\n            listYear: {\n                type: 'list',\n                duration: {\n                    year: 1\n                },\n                listDaySideFormat: {\n                    weekday: 'long'\n                }\n            }\n        }\n    });\n    class SingleMonth extends DateComponent {\n        render() {\n            const { props, state, context } = this;\n            const { dateProfile, forPrint } = props;\n            const { options } = context;\n            const dayTableModel = this.buildDayTableModel(dateProfile, context.dateProfileGenerator);\n            const slicedProps = this.slicer.sliceProps(props, dateProfile, options.nextDayThreshold, context, dayTableModel);\n            // ensure single-month has aspect ratio\n            const tableHeight = props.tableWidth != null ? props.tableWidth / options.aspectRatio : null;\n            const rowCnt = dayTableModel.cells.length;\n            const rowHeight = tableHeight != null ? tableHeight / rowCnt : null;\n            return y(\"div\", {\n                ref: props.elRef,\n                \"data-date\": props.isoDateStr,\n                className: \"fc-multimonth-month\",\n                style: {\n                    width: props.width\n                },\n                role: \"grid\",\n                \"aria-labelledby\": state.labelId\n            }, y(\"div\", {\n                className: \"fc-multimonth-header\",\n                style: {\n                    marginBottom: rowHeight\n                },\n                role: \"presentation\"\n            }, y(\"div\", {\n                className: \"fc-multimonth-title\",\n                id: state.labelId\n            }, context.dateEnv.format(props.dateProfile.currentRange.start, props.titleFormat)), y(\"table\", {\n                className: [\n                    'fc-multimonth-header-table',\n                    context.theme.getClass('table')\n                ].join(' '),\n                role: \"presentation\"\n            }, y(\"thead\", {\n                role: \"rowgroup\"\n            }, y(DayHeader, {\n                dateProfile: props.dateProfile,\n                dates: dayTableModel.headerDates,\n                datesRepDistinctDays: false\n            })))), y(\"div\", {\n                className: [\n                    'fc-multimonth-daygrid',\n                    'fc-daygrid',\n                    'fc-daygrid-body',\n                    !forPrint && 'fc-daygrid-body-balanced',\n                    forPrint && 'fc-daygrid-body-unbalanced',\n                    forPrint && 'fc-daygrid-body-natural'\n                ].join(' '),\n                style: {\n                    marginTop: -rowHeight\n                }\n            }, y(\"table\", {\n                className: [\n                    'fc-multimonth-daygrid-table',\n                    context.theme.getClass('table')\n                ].join(' '),\n                style: {\n                    height: forPrint ? '' : tableHeight\n                },\n                role: \"presentation\"\n            }, y(\"tbody\", {\n                role: \"rowgroup\"\n            }, y(TableRows, Object.assign({}, slicedProps, {\n                dateProfile: dateProfile,\n                cells: dayTableModel.cells,\n                eventSelection: props.eventSelection,\n                dayMaxEvents: !forPrint,\n                dayMaxEventRows: !forPrint,\n                showWeekNumbers: options.weekNumbers,\n                clientWidth: props.clientWidth,\n                clientHeight: props.clientHeight,\n                forPrint: forPrint\n            }))))));\n        }\n        constructor(){\n            super(...arguments);\n            this.buildDayTableModel = memoize(buildDayTableModel);\n            this.slicer = new DayTableSlicer();\n            this.state = {\n                labelId: getUniqueDomId()\n            };\n        }\n    }\n    class MultiMonthView extends DateComponent {\n        render() {\n            const { context, props, state } = this;\n            const { options } = context;\n            const { clientWidth, clientHeight } = state;\n            const monthHPadding = state.monthHPadding || 0;\n            const colCount = Math.min(clientWidth != null ? Math.floor(clientWidth / (options.multiMonthMinWidth + monthHPadding)) : 1, options.multiMonthMaxColumns) || 1;\n            const monthWidthPct = 100 / colCount + '%';\n            const monthTableWidth = clientWidth == null ? null : clientWidth / colCount - monthHPadding;\n            const isLegitSingleCol = clientWidth != null && colCount === 1;\n            const monthDateProfiles = this.splitDateProfileByMonth(context.dateProfileGenerator, props.dateProfile, context.dateEnv, isLegitSingleCol ? false : options.fixedWeekCount, options.showNonCurrentDates);\n            const monthTitleFormat = this.buildMonthFormat(options.multiMonthTitleFormat, monthDateProfiles);\n            const rootClassNames = [\n                'fc-multimonth',\n                isLegitSingleCol ? 'fc-multimonth-singlecol' : 'fc-multimonth-multicol',\n                monthTableWidth != null && monthTableWidth < 400 ? 'fc-multimonth-compact' : ''\n            ];\n            return y(ViewContainer, {\n                elRef: this.scrollElRef,\n                elClasses: rootClassNames,\n                viewSpec: context.viewSpec\n            }, monthDateProfiles.map((monthDateProfile, i)=>{\n                const monthStr = formatIsoMonthStr(monthDateProfile.currentRange.start);\n                return y(SingleMonth, Object.assign({}, props, {\n                    key: monthStr,\n                    isoDateStr: monthStr,\n                    elRef: i === 0 ? this.firstMonthElRef : undefined,\n                    titleFormat: monthTitleFormat,\n                    dateProfile: monthDateProfile,\n                    width: monthWidthPct,\n                    tableWidth: monthTableWidth,\n                    clientWidth: clientWidth,\n                    clientHeight: clientHeight\n                }));\n            }));\n        }\n        componentDidMount() {\n            this.updateSize();\n            this.context.addResizeHandler(this.handleSizing);\n            this.requestScrollReset();\n        }\n        componentDidUpdate(prevProps) {\n            if (!isPropsEqual(prevProps, this.props)) {\n                this.handleSizing(false);\n            }\n            if (prevProps.dateProfile !== this.props.dateProfile) {\n                this.requestScrollReset();\n            } else {\n                this.flushScrollReset();\n            }\n        }\n        componentWillUnmount() {\n            this.context.removeResizeHandler(this.handleSizing);\n        }\n        updateSize() {\n            const scrollEl = this.scrollElRef.current;\n            const firstMonthEl = this.firstMonthElRef.current;\n            if (scrollEl) {\n                this.setState({\n                    clientWidth: scrollEl.clientWidth,\n                    clientHeight: scrollEl.clientHeight\n                });\n            }\n            if (firstMonthEl && scrollEl) {\n                if (this.state.monthHPadding == null) {\n                    this.setState({\n                        monthHPadding: scrollEl.clientWidth - // go within padding\n                        firstMonthEl.firstChild.offsetWidth\n                    });\n                }\n            }\n        }\n        requestScrollReset() {\n            this.needsScrollReset = true;\n            this.flushScrollReset();\n        }\n        flushScrollReset() {\n            if (this.needsScrollReset && this.state.monthHPadding != null // indicates sizing already happened\n            ) {\n                const { currentDate } = this.props.dateProfile;\n                const scrollEl = this.scrollElRef.current;\n                const monthEl = scrollEl.querySelector('[data-date=\"'.concat(formatIsoMonthStr(currentDate), '\"]'));\n                scrollEl.scrollTop = monthEl.getBoundingClientRect().top - this.firstMonthElRef.current.getBoundingClientRect().top;\n                this.needsScrollReset = false;\n            }\n        }\n        // workaround for when queued setState render (w/ clientWidth) gets cancelled because\n        // subsequent update and shouldComponentUpdate says not to render :(\n        shouldComponentUpdate() {\n            return true;\n        }\n        constructor(){\n            super(...arguments);\n            this.splitDateProfileByMonth = memoize(splitDateProfileByMonth);\n            this.buildMonthFormat = memoize(buildMonthFormat);\n            this.scrollElRef = d();\n            this.firstMonthElRef = d();\n            this.needsScrollReset = false;\n            this.handleSizing = (isForced)=>{\n                if (isForced) {\n                    this.updateSize();\n                }\n            };\n        }\n    }\n    // date profile\n    // -------------------------------------------------------------------------------------------------\n    const oneMonthDuration = createDuration(1, 'month');\n    function splitDateProfileByMonth(dateProfileGenerator, dateProfile, dateEnv, fixedWeekCount, showNonCurrentDates) {\n        const { start, end } = dateProfile.currentRange;\n        let monthStart = start;\n        const monthDateProfiles = [];\n        while(monthStart.valueOf() < end.valueOf()){\n            const monthEnd = dateEnv.add(monthStart, oneMonthDuration);\n            const currentRange = {\n                // yuck\n                start: dateProfileGenerator.skipHiddenDays(monthStart),\n                end: dateProfileGenerator.skipHiddenDays(monthEnd, -1, true)\n            };\n            let renderRange = buildDayTableRenderRange({\n                currentRange,\n                snapToWeek: true,\n                fixedWeekCount,\n                dateEnv\n            });\n            renderRange = {\n                // yuck\n                start: dateProfileGenerator.skipHiddenDays(renderRange.start),\n                end: dateProfileGenerator.skipHiddenDays(renderRange.end, -1, true)\n            };\n            const activeRange = dateProfile.activeRange ? intersectRanges(dateProfile.activeRange, showNonCurrentDates ? renderRange : currentRange) : null;\n            monthDateProfiles.push({\n                currentDate: dateProfile.currentDate,\n                isValid: dateProfile.isValid,\n                validRange: dateProfile.validRange,\n                renderRange,\n                activeRange,\n                currentRange,\n                currentRangeUnit: 'month',\n                isRangeAllDay: true,\n                dateIncrement: dateProfile.dateIncrement,\n                slotMinTime: dateProfile.slotMaxTime,\n                slotMaxTime: dateProfile.slotMinTime\n            });\n            monthStart = monthEnd;\n        }\n        return monthDateProfiles;\n    }\n    // date formatting\n    // -------------------------------------------------------------------------------------------------\n    const YEAR_MONTH_FORMATTER = createFormatter({\n        year: 'numeric',\n        month: 'long'\n    });\n    const YEAR_FORMATTER = createFormatter({\n        month: 'long'\n    });\n    function buildMonthFormat(formatOverride, monthDateProfiles) {\n        return formatOverride || (monthDateProfiles[0].currentRange.start.getUTCFullYear() !== monthDateProfiles[monthDateProfiles.length - 1].currentRange.start.getUTCFullYear() ? YEAR_MONTH_FORMATTER : YEAR_FORMATTER);\n    }\n    const OPTION_REFINERS = {\n        multiMonthTitleFormat: createFormatter,\n        multiMonthMaxColumns: Number,\n        multiMonthMinWidth: Number\n    };\n    var css_248z = \".fc .fc-multimonth{border:1px solid var(--fc-border-color);display:flex;flex-wrap:wrap;overflow-x:hidden;overflow-y:auto}.fc .fc-multimonth-title{font-size:1.2em;font-weight:700;padding:1em 0;text-align:center}.fc .fc-multimonth-daygrid{background:var(--fc-page-bg-color)}.fc .fc-multimonth-daygrid-table,.fc .fc-multimonth-header-table{table-layout:fixed;width:100%}.fc .fc-multimonth-daygrid-table{border-top-style:hidden!important}.fc .fc-multimonth-singlecol .fc-multimonth{position:relative}.fc .fc-multimonth-singlecol .fc-multimonth-header{background:var(--fc-page-bg-color);position:relative;top:0;z-index:2}.fc .fc-multimonth-singlecol .fc-multimonth-daygrid{position:relative;z-index:1}.fc .fc-multimonth-singlecol .fc-multimonth-daygrid-table,.fc .fc-multimonth-singlecol .fc-multimonth-header-table{border-left-style:hidden;border-right-style:hidden}.fc .fc-multimonth-singlecol .fc-multimonth-month:last-child .fc-multimonth-daygrid-table{border-bottom-style:hidden}.fc .fc-multimonth-multicol{line-height:1}.fc .fc-multimonth-multicol .fc-multimonth-month{padding:0 1.2em 1.2em}.fc .fc-multimonth-multicol .fc-daygrid-more-link{border:1px solid var(--fc-event-border-color);display:block;float:none;padding:1px}.fc .fc-multimonth-compact{line-height:1}.fc .fc-multimonth-compact .fc-multimonth-daygrid-table,.fc .fc-multimonth-compact .fc-multimonth-header-table{font-size:.9em}.fc-media-screen .fc-multimonth-singlecol .fc-multimonth-header{position:sticky}.fc-media-print .fc-multimonth{overflow:visible}\";\n    injectStyles(css_248z);\n    var index = createPlugin({\n        name: '@fullcalendar/multimonth',\n        initialView: 'multiMonthYear',\n        optionRefiners: OPTION_REFINERS,\n        views: {\n            multiMonth: {\n                component: MultiMonthView,\n                dateProfileGeneratorClass: TableDateProfileGenerator,\n                multiMonthMinWidth: 350,\n                multiMonthMaxColumns: 3\n            },\n            multiMonthYear: {\n                type: 'multiMonth',\n                duration: {\n                    years: 1\n                },\n                fixedWeekCount: true,\n                showNonCurrentDates: false\n            }\n        }\n    });\n    globalPlugins.push(index$4, index$3, index$2, index$1, index);\n    exports.Calendar = Calendar;\n    exports.Draggable = ExternalDraggable;\n    exports.Internal = internal;\n    exports.JsonRequestError = JsonRequestError;\n    exports.Preact = preact;\n    exports.ThirdPartyDraggable = ThirdPartyDraggable;\n    exports.createPlugin = createPlugin;\n    exports.formatDate = formatDate;\n    exports.formatRange = formatRange;\n    exports.globalLocales = globalLocales;\n    exports.globalPlugins = globalPlugins;\n    exports.sliceEvents = sliceEvents;\n    exports.version = version;\n    Object.defineProperty(exports, '__esModule', {\n        value: true\n    });\n    return exports;\n}({});\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy92ZW5kb3IvZnVsbGNhbGVuZGFyL2dsb2JhbC5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7OztBQUlBLEdBQ0EsSUFBSUEsZUFBZSxTQUFXQyxPQUFPO0lBQ2pDO0lBRUEsSUFBSUMsR0FBRUMsS0FBSUMsS0FBSUMsS0FBSUMsR0FBRUMsS0FBSUMsR0FBRUMsS0FBSUMsS0FBSUMsTUFBSSxDQUFDLEdBQUVDLElBQUUsRUFBRSxFQUFDQyxNQUFJO0lBQW9FLFNBQVNDLEVBQUVaLENBQUMsRUFBQ2EsQ0FBQztRQUFFLElBQUksSUFBSUMsS0FBS0QsRUFBRWIsQ0FBQyxDQUFDYyxFQUFFLEdBQUNELENBQUMsQ0FBQ0MsRUFBRTtRQUFDLE9BQU9kO0lBQUM7SUFBQyxTQUFTZSxJQUFJZixDQUFDO1FBQUUsSUFBSWEsSUFBRWIsRUFBRWdCLFVBQVU7UUFBQ0gsS0FBR0EsRUFBRUksV0FBVyxDQUFDakI7SUFBRztJQUFDLFNBQVNrQixFQUFFTCxDQUFDLEVBQUNDLENBQUMsRUFBQ0ssQ0FBQztRQUFFLElBQUlmLEdBQUVnQixHQUFFZCxHQUFFZSxJQUFFLENBQUM7UUFBRSxJQUFJZixLQUFLUSxFQUFFLFNBQU9SLElBQUVGLElBQUVVLENBQUMsQ0FBQ1IsRUFBRSxHQUFDLFNBQU9BLElBQUVjLElBQUVOLENBQUMsQ0FBQ1IsRUFBRSxHQUFDZSxDQUFDLENBQUNmLEVBQUUsR0FBQ1EsQ0FBQyxDQUFDUixFQUFFO1FBQUMsSUFBR2dCLFVBQVVDLE1BQU0sR0FBQyxLQUFJRixDQUFBQSxFQUFFRyxRQUFRLEdBQUNGLFVBQVVDLE1BQU0sR0FBQyxJQUFFdkIsRUFBRXlCLElBQUksQ0FBQ0gsV0FBVSxLQUFHSCxDQUFBQSxHQUFHLGNBQVksT0FBT04sS0FBRyxRQUFNQSxFQUFFYSxZQUFZLEVBQUMsSUFBSXBCLEtBQUtPLEVBQUVhLFlBQVksQ0FBQyxLQUFLLE1BQUlMLENBQUMsQ0FBQ2YsRUFBRSxJQUFHZSxDQUFBQSxDQUFDLENBQUNm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Q2pCemxFLFFBQVFzdUYsbUJBQW1CLEdBQUdBO0lBQzlCdHVGLFFBQVF1bkUsWUFBWSxHQUFHQTtJQUN2QnZuRSxRQUFRdWpFLFVBQVUsR0FBR0E7SUFDckJ2akUsUUFBUXFrQixXQUFXLEdBQUdBO0lBQ3RCcmtCLFFBQVFpbUUsYUFBYSxHQUFHQTtJQUN4QmptRSxRQUFReXpFLGFBQWEsR0FBR0E7SUFDeEJ6ekUsUUFBUWc5RSxXQUFXLEdBQUdBO0lBQ3RCaDlFLFFBQVFpOUUsT0FBTyxHQUFHQTtJQUVsQm53RSxPQUFPQyxjQUFjLENBQUMvTSxTQUFTLGNBQWM7UUFBRTZHLE9BQU87SUFBSztJQUUzRCxPQUFPN0c7QUFFWCxFQUFHLENBQUMiLCJzb3VyY2VzIjpbIkQ6XFxuZXh0XFxvcmdcXHNyY1xcdmVuZG9yXFxmdWxsY2FsZW5kYXJcXGdsb2JhbC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcclxuRnVsbENhbGVuZGFyIFN0YW5kYXJkIEJ1bmRsZSB2Ni4xLjhcclxuRG9jcyAmIExpY2Vuc2U6IGh0dHBzOi8vZnVsbGNhbGVuZGFyLmlvL2RvY3MvaW5pdGlhbGl6ZS1nbG9iYWxzXHJcbihjKSAyMDIzIEFkYW0gU2hhd1xyXG4qL1xyXG52YXIgRnVsbENhbGVuZGFyID0gKGZ1bmN0aW9uIChleHBvcnRzKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcblxyXG4gICAgdmFyIG4sbCQxLHUkMSxpJDEsdCxyJDEsbyxmJDEsZSQxLGMkMT17fSxzPVtdLGEkMT0vYWNpdHxleCg/OnN8Z3xufHB8JCl8cnBofGdyaWR8b3dzfG1uY3xudHd8aW5lW2NoXXx6b298Xm9yZHxpdGVyYS9pO2Z1bmN0aW9uIGgobixsKXtmb3IodmFyIHUgaW4gbCluW3VdPWxbdV07cmV0dXJuIG59ZnVuY3Rpb24gdiQxKG4pe3ZhciBsPW4ucGFyZW50Tm9kZTtsJiZsLnJlbW92ZUNoaWxkKG4pO31mdW5jdGlvbiB5KGwsdSxpKXt2YXIgdCxyLG8sZj17fTtmb3IobyBpbiB1KVwia2V5XCI9PW8/dD11W29dOlwicmVmXCI9PW8/cj11W29dOmZbb109dVtvXTtpZihhcmd1bWVudHMubGVuZ3RoPjImJihmLmNoaWxkcmVuPWFyZ3VtZW50cy5sZW5ndGg+Mz9uLmNhbGwoYXJndW1lbnRzLDIpOmkpLFwiZnVuY3Rpb25cIj09dHlwZW9mIGwmJm51bGwhPWwuZGVmYXVsdFByb3BzKWZvcihvIGluIGwuZGVmYXVsdFByb3BzKXZvaWQgMD09PWZbb10mJihmW29dPWwuZGVmYXVsdFByb3BzW29dKTtyZXR1cm4gcChsLGYsdCxyLG51bGwpfWZ1bmN0aW9uIHAobixpLHQscixvKXt2YXIgZj17dHlwZTpuLHByb3BzOmksa2V5OnQscmVmOnIsX19rOm51bGwsX186bnVsbCxfX2I6MCxfX2U6bnVsbCxfX2Q6dm9pZCAwLF9fYzpudWxsLF9faDpudWxsLGNvbnN0cnVjdG9yOnZvaWQgMCxfX3Y6bnVsbD09bz8rK3UkMTpvfTtyZXR1cm4gbnVsbD09byYmbnVsbCE9bCQxLnZub2RlJiZsJDEudm5vZGUoZiksZn1mdW5jdGlvbiBkKCl7cmV0dXJuIHtjdXJyZW50Om51bGx9fWZ1bmN0aW9uIF8obil7cmV0dXJuIG4uY2hpbGRyZW59ZnVuY3Rpb24gayQxKG4sbCx1LGksdCl7dmFyIHI7Zm9yKHIgaW4gdSlcImNoaWxkcmVuXCI9PT1yfHxcImtleVwiPT09cnx8ciBpbiBsfHxnJDIobixyLG51bGwsdVtyXSxpKTtmb3IociBpbiBsKXQmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIGxbcl18fFwiY2hpbGRyZW5cIj09PXJ8fFwia2V5XCI9PT1yfHxcInZhbHVlXCI9PT1yfHxcImNoZWNrZWRcIj09PXJ8fHVbcl09PT1sW3JdfHxnJDIobixyLGxbcl0sdVtyXSxpKTt9ZnVuY3Rpb24gYiQxKG4sbCx1KXtcIi1cIj09PWxbMF0/bi5zZXRQcm9wZXJ0eShsLG51bGw9PXU/XCJcIjp1KTpuW2xdPW51bGw9PXU/XCJcIjpcIm51bWJlclwiIT10eXBlb2YgdXx8YSQxLnRlc3QobCk/dTp1K1wicHhcIjt9ZnVuY3Rpb24gZyQyKG4sbCx1LGksdCl7dmFyIHI7bjppZihcInN0eWxlXCI9PT1sKWlmKFwic3RyaW5nXCI9PXR5cGVvZiB1KW4uc3R5bGUuY3NzVGV4dD11O2Vsc2Uge2lmKFwic3RyaW5nXCI9PXR5cGVvZiBpJiYobi5zdHlsZS5jc3NUZXh0PWk9XCJcIiksaSlmb3IobCBpbiBpKXUmJmwgaW4gdXx8YiQxKG4uc3R5bGUsbCxcIlwiKTtpZih1KWZvcihsIGluIHUpaSYmdVtsXT09PWlbbF18fGIkMShuLnN0eWxlLGwsdVtsXSk7fWVsc2UgaWYoXCJvXCI9PT1sWzBdJiZcIm5cIj09PWxbMV0pcj1sIT09KGw9bC5yZXBsYWNlKC9DYXB0dXJlJC8sXCJcIikpLGw9bC50b0xvd2VyQ2FzZSgpaW4gbj9sLnRvTG93ZXJDYXNlKCkuc2xpY2UoMik6bC5zbGljZSgyKSxuLmx8fChuLmw9e30pLG4ubFtsK3JdPXUsdT9pfHxuLmFkZEV2ZW50TGlzdGVuZXIobCxyP3ckMjptJDEscik6bi5yZW1vdmVFdmVudExpc3RlbmVyKGwscj93JDI6bSQxLHIpO2Vsc2UgaWYoXCJkYW5nZXJvdXNseVNldElubmVySFRNTFwiIT09bCl7aWYodClsPWwucmVwbGFjZSgveGxpbmsoSHw6aCkvLFwiaFwiKS5yZXBsYWNlKC9zTmFtZSQvLFwic1wiKTtlbHNlIGlmKFwid2lkdGhcIiE9PWwmJlwiaGVpZ2h0XCIhPT1sJiZcImhyZWZcIiE9PWwmJlwibGlzdFwiIT09bCYmXCJmb3JtXCIhPT1sJiZcInRhYkluZGV4XCIhPT1sJiZcImRvd25sb2FkXCIhPT1sJiZsIGluIG4pdHJ5e25bbF09bnVsbD09dT9cIlwiOnU7YnJlYWsgbn1jYXRjaChuKXt9XCJmdW5jdGlvblwiPT10eXBlb2YgdXx8KG51bGw9PXV8fCExPT09dSYmLTE9PWwuaW5kZXhPZihcIi1cIik/bi5yZW1vdmVBdHRyaWJ1dGUobCk6bi5zZXRBdHRyaWJ1dGUobCx1KSk7fX1mdW5jdGlvbiBtJDEobil7dD0hMDt0cnl7cmV0dXJuIHRoaXMubFtuLnR5cGUrITFdKGwkMS5ldmVudD9sJDEuZXZlbnQobik6bil9ZmluYWxseXt0PSExO319ZnVuY3Rpb24gdyQyKG4pe3Q9ITA7dHJ5e3JldHVybiB0aGlzLmxbbi50eXBlKyEwXShsJDEuZXZlbnQ/bCQxLmV2ZW50KG4pOm4pfWZpbmFsbHl7dD0hMTt9fWZ1bmN0aW9uIHgkMShuLGwpe3RoaXMucHJvcHM9bix0aGlzLmNvbnRleHQ9bDt9ZnVuY3Rpb24gQShuLGwpe2lmKG51bGw9PWwpcmV0dXJuIG4uX18/QShuLl9fLG4uX18uX19rLmluZGV4T2YobikrMSk6bnVsbDtmb3IodmFyIHU7bDxuLl9fay5sZW5ndGg7bCsrKWlmKG51bGwhPSh1PW4uX19rW2xdKSYmbnVsbCE9dS5fX2UpcmV0dXJuIHUuX19lO3JldHVybiBcImZ1bmN0aW9uXCI9PXR5cGVvZiBuLnR5cGU/QShuKTpudWxsfWZ1bmN0aW9uIFAkMShuKXt2YXIgbCx1O2lmKG51bGwhPShuPW4uX18pJiZudWxsIT1uLl9fYyl7Zm9yKG4uX19lPW4uX19jLmJhc2U9bnVsbCxsPTA7bDxuLl9fay5sZW5ndGg7bCsrKWlmKG51bGwhPSh1PW4uX19rW2xdKSYmbnVsbCE9dS5fX2Upe24uX19lPW4uX19jLmJhc2U9dS5fX2U7YnJlYWt9cmV0dXJuIFAkMShuKX19ZnVuY3Rpb24gQyQxKG4pe3Q/c2V0VGltZW91dChuKTpmJDEobik7fWZ1bmN0aW9uIFQkMShuKXsoIW4uX19kJiYobi5fX2Q9ITApJiZyJDEucHVzaChuKSYmISQkMS5fX3IrK3x8byE9PWwkMS5kZWJvdW5jZVJlbmRlcmluZykmJigobz1sJDEuZGVib3VuY2VSZW5kZXJpbmcpfHxDJDEpKCQkMSk7fWZ1bmN0aW9uICQkMSgpe3ZhciBuLGwsdSxpLHQsbyxmLGU7Zm9yKHIkMS5zb3J0KGZ1bmN0aW9uKG4sbCl7cmV0dXJuIG4uX192Ll9fYi1sLl9fdi5fX2J9KTtuPXIkMS5zaGlmdCgpOyluLl9fZCYmKGw9ciQxLmxlbmd0aCxpPXZvaWQgMCx0PXZvaWQgMCxmPShvPSh1PW4pLl9fdikuX19lLChlPXUuX19QKSYmKGk9W10sKHQ9aCh7fSxvKSkuX192PW8uX192KzEsTShlLG8sdCx1Ll9fbix2b2lkIDAhPT1lLm93bmVyU1ZHRWxlbWVudCxudWxsIT1vLl9faD9bZl06bnVsbCxpLG51bGw9PWY/QShvKTpmLG8uX19oKSxOKGksbyksby5fX2UhPWYmJlAkMShvKSksciQxLmxlbmd0aD5sJiZyJDEuc29ydChmdW5jdGlvbihuLGwpe3JldHVybiBuLl9fdi5fX2ItbC5fX3YuX19ifSkpOyQkMS5fX3I9MDt9ZnVuY3Rpb24gSCQxKG4sbCx1LGksdCxyLG8sZixlLGEpe3ZhciBoLHYseSxkLGssYixnLG09aSYmaS5fX2t8fHMsdz1tLmxlbmd0aDtmb3IodS5fX2s9W10saD0wO2g8bC5sZW5ndGg7aCsrKWlmKG51bGwhPShkPXUuX19rW2hdPW51bGw9PShkPWxbaF0pfHxcImJvb2xlYW5cIj09dHlwZW9mIGQ/bnVsbDpcInN0cmluZ1wiPT10eXBlb2YgZHx8XCJudW1iZXJcIj09dHlwZW9mIGR8fFwiYmlnaW50XCI9PXR5cGVvZiBkP3AobnVsbCxkLG51bGwsbnVsbCxkKTpBcnJheS5pc0FycmF5KGQpP3AoXyx7Y2hpbGRyZW46ZH0sbnVsbCxudWxsLG51bGwpOmQuX19iPjA/cChkLnR5cGUsZC5wcm9wcyxkLmtleSxkLnJlZj9kLnJlZjpudWxsLGQuX192KTpkKSl7aWYoZC5fXz11LGQuX19iPXUuX19iKzEsbnVsbD09PSh5PW1baF0pfHx5JiZkLmtleT09eS5rZXkmJmQudHlwZT09PXkudHlwZSltW2hdPXZvaWQgMDtlbHNlIGZvcih2PTA7djx3O3YrKyl7aWYoKHk9bVt2XSkmJmQua2V5PT15LmtleSYmZC50eXBlPT09eS50eXBlKXttW3ZdPXZvaWQgMDticmVha315PW51bGw7fU0obixkLHk9eXx8YyQxLHQscixvLGYsZSxhKSxrPWQuX19lLCh2PWQucmVmKSYmeS5yZWYhPXYmJihnfHwoZz1bXSkseS5yZWYmJmcucHVzaCh5LnJlZixudWxsLGQpLGcucHVzaCh2LGQuX19jfHxrLGQpKSxudWxsIT1rPyhudWxsPT1iJiYoYj1rKSxcImZ1bmN0aW9uXCI9PXR5cGVvZiBkLnR5cGUmJmQuX19rPT09eS5fX2s/ZC5fX2Q9ZT1JJDEoZCxlLG4pOmU9eiQxKG4sZCx5LG0sayxlKSxcImZ1bmN0aW9uXCI9PXR5cGVvZiB1LnR5cGUmJih1Ll9fZD1lKSk6ZSYmeS5fX2U9PWUmJmUucGFyZW50Tm9kZSE9biYmKGU9QSh5KSk7fWZvcih1Ll9fZT1iLGg9dztoLS07KW51bGwhPW1baF0mJihcImZ1bmN0aW9uXCI9PXR5cGVvZiB1LnR5cGUmJm51bGwhPW1baF0uX19lJiZtW2hdLl9fZT09dS5fX2QmJih1Ll9fZD1MJDEoaSkubmV4dFNpYmxpbmcpLHEobVtoXSxtW2hdKSk7aWYoZylmb3IoaD0wO2g8Zy5sZW5ndGg7aCsrKVMoZ1toXSxnWysraF0sZ1srK2hdKTt9ZnVuY3Rpb24gSSQxKG4sbCx1KXtmb3IodmFyIGksdD1uLl9fayxyPTA7dCYmcjx0Lmxlbmd0aDtyKyspKGk9dFtyXSkmJihpLl9fPW4sbD1cImZ1bmN0aW9uXCI9PXR5cGVvZiBpLnR5cGU/SSQxKGksbCx1KTp6JDEodSxpLGksdCxpLl9fZSxsKSk7cmV0dXJuIGx9ZnVuY3Rpb24gaiQyKG4sbCl7cmV0dXJuIGw9bHx8W10sbnVsbD09bnx8XCJib29sZWFuXCI9PXR5cGVvZiBufHwoQXJyYXkuaXNBcnJheShuKT9uLnNvbWUoZnVuY3Rpb24obil7aiQyKG4sbCk7fSk6bC5wdXNoKG4pKSxsfWZ1bmN0aW9uIHokMShuLGwsdSxpLHQscil7dmFyIG8sZixlO2lmKHZvaWQgMCE9PWwuX19kKW89bC5fX2QsbC5fX2Q9dm9pZCAwO2Vsc2UgaWYobnVsbD09dXx8dCE9cnx8bnVsbD09dC5wYXJlbnROb2RlKW46aWYobnVsbD09cnx8ci5wYXJlbnROb2RlIT09biluLmFwcGVuZENoaWxkKHQpLG89bnVsbDtlbHNlIHtmb3IoZj1yLGU9MDsoZj1mLm5leHRTaWJsaW5nKSYmZTxpLmxlbmd0aDtlKz0xKWlmKGY9PXQpYnJlYWsgbjtuLmluc2VydEJlZm9yZSh0LHIpLG89cjt9cmV0dXJuIHZvaWQgMCE9PW8/bzp0Lm5leHRTaWJsaW5nfWZ1bmN0aW9uIEwkMShuKXt2YXIgbCx1LGk7aWYobnVsbD09bi50eXBlfHxcInN0cmluZ1wiPT10eXBlb2Ygbi50eXBlKXJldHVybiBuLl9fZTtpZihuLl9faylmb3IobD1uLl9fay5sZW5ndGgtMTtsPj0wO2wtLSlpZigodT1uLl9fa1tsXSkmJihpPUwkMSh1KSkpcmV0dXJuIGk7cmV0dXJuIG51bGx9ZnVuY3Rpb24gTShuLHUsaSx0LHIsbyxmLGUsYyl7dmFyIHMsYSx2LHkscCxkLGssYixnLG0sdyxBLFAsQyxULCQ9dS50eXBlO2lmKHZvaWQgMCE9PXUuY29uc3RydWN0b3IpcmV0dXJuIG51bGw7bnVsbCE9aS5fX2gmJihjPWkuX19oLGU9dS5fX2U9aS5fX2UsdS5fX2g9bnVsbCxvPVtlXSksKHM9bCQxLl9fYikmJnModSk7dHJ5e246aWYoXCJmdW5jdGlvblwiPT10eXBlb2YgJCl7aWYoYj11LnByb3BzLGc9KHM9JC5jb250ZXh0VHlwZSkmJnRbcy5fX2NdLG09cz9nP2cucHJvcHMudmFsdWU6cy5fXzp0LGkuX19jP2s9KGE9dS5fX2M9aS5fX2MpLl9fPWEuX19FOihcInByb3RvdHlwZVwiaW4gJCYmJC5wcm90b3R5cGUucmVuZGVyP3UuX19jPWE9bmV3ICQoYixtKToodS5fX2M9YT1uZXcgeCQxKGIsbSksYS5jb25zdHJ1Y3Rvcj0kLGEucmVuZGVyPUIkMSksZyYmZy5zdWIoYSksYS5wcm9wcz1iLGEuc3RhdGV8fChhLnN0YXRlPXt9KSxhLmNvbnRleHQ9bSxhLl9fbj10LHY9YS5fX2Q9ITAsYS5fX2g9W10sYS5fc2I9W10pLG51bGw9PWEuX19zJiYoYS5fX3M9YS5zdGF0ZSksbnVsbCE9JC5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMmJihhLl9fcz09YS5zdGF0ZSYmKGEuX19zPWgoe30sYS5fX3MpKSxoKGEuX19zLCQuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKGIsYS5fX3MpKSkseT1hLnByb3BzLHA9YS5zdGF0ZSxhLl9fdj11LHYpbnVsbD09JC5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMmJm51bGwhPWEuY29tcG9uZW50V2lsbE1vdW50JiZhLmNvbXBvbmVudFdpbGxNb3VudCgpLG51bGwhPWEuY29tcG9uZW50RGlkTW91bnQmJmEuX19oLnB1c2goYS5jb21wb25lbnREaWRNb3VudCk7ZWxzZSB7aWYobnVsbD09JC5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMmJmIhPT15JiZudWxsIT1hLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMmJmEuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhiLG0pLCFhLl9fZSYmbnVsbCE9YS5zaG91bGRDb21wb25lbnRVcGRhdGUmJiExPT09YS5zaG91bGRDb21wb25lbnRVcGRhdGUoYixhLl9fcyxtKXx8dS5fX3Y9PT1pLl9fdil7Zm9yKHUuX192IT09aS5fX3YmJihhLnByb3BzPWIsYS5zdGF0ZT1hLl9fcyxhLl9fZD0hMSksdS5fX2U9aS5fX2UsdS5fX2s9aS5fX2ssdS5fX2suZm9yRWFjaChmdW5jdGlvbihuKXtuJiYobi5fXz11KTt9KSx3PTA7dzxhLl9zYi5sZW5ndGg7dysrKWEuX19oLnB1c2goYS5fc2Jbd10pO2EuX3NiPVtdLGEuX19oLmxlbmd0aCYmZi5wdXNoKGEpO2JyZWFrIG59bnVsbCE9YS5jb21wb25lbnRXaWxsVXBkYXRlJiZhLmNvbXBvbmVudFdpbGxVcGRhdGUoYixhLl9fcyxtKSxudWxsIT1hLmNvbXBvbmVudERpZFVwZGF0ZSYmYS5fX2gucHVzaChmdW5jdGlvbigpe2EuY29tcG9uZW50RGlkVXBkYXRlKHkscCxkKTt9KTt9aWYoYS5jb250ZXh0PW0sYS5wcm9wcz1iLGEuX19QPW4sQT1sJDEuX19yLFA9MCxcInByb3RvdHlwZVwiaW4gJCYmJC5wcm90b3R5cGUucmVuZGVyKXtmb3IoYS5zdGF0ZT1hLl9fcyxhLl9fZD0hMSxBJiZBKHUpLHM9YS5yZW5kZXIoYS5wcm9wcyxhLnN0YXRlLGEuY29udGV4dCksQz0wO0M8YS5fc2IubGVuZ3RoO0MrKylhLl9faC5wdXNoKGEuX3NiW0NdKTthLl9zYj1bXTt9ZWxzZSBkb3thLl9fZD0hMSxBJiZBKHUpLHM9YS5yZW5kZXIoYS5wcm9wcyxhLnN0YXRlLGEuY29udGV4dCksYS5zdGF0ZT1hLl9fczt9d2hpbGUoYS5fX2QmJisrUDwyNSk7YS5zdGF0ZT1hLl9fcyxudWxsIT1hLmdldENoaWxkQ29udGV4dCYmKHQ9aChoKHt9LHQpLGEuZ2V0Q2hpbGRDb250ZXh0KCkpKSx2fHxudWxsPT1hLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlfHwoZD1hLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlKHkscCkpLFQ9bnVsbCE9cyYmcy50eXBlPT09XyYmbnVsbD09cy5rZXk/cy5wcm9wcy5jaGlsZHJlbjpzLEgkMShuLEFycmF5LmlzQXJyYXkoVCk/VDpbVF0sdSxpLHQscixvLGYsZSxjKSxhLmJhc2U9dS5fX2UsdS5fX2g9bnVsbCxhLl9faC5sZW5ndGgmJmYucHVzaChhKSxrJiYoYS5fX0U9YS5fXz1udWxsKSxhLl9fZT0hMTt9ZWxzZSBudWxsPT1vJiZ1Ll9fdj09PWkuX192Pyh1Ll9faz1pLl9fayx1Ll9fZT1pLl9fZSk6dS5fX2U9TyhpLl9fZSx1LGksdCxyLG8sZixjKTsocz1sJDEuZGlmZmVkKSYmcyh1KTt9Y2F0Y2gobil7dS5fX3Y9bnVsbCwoY3x8bnVsbCE9bykmJih1Ll9fZT1lLHUuX19oPSEhYyxvW28uaW5kZXhPZihlKV09bnVsbCksbCQxLl9fZShuLHUsaSk7fX1mdW5jdGlvbiBOKG4sdSl7bCQxLl9fYyYmbCQxLl9fYyh1LG4pLG4uc29tZShmdW5jdGlvbih1KXt0cnl7bj11Ll9faCx1Ll9faD1bXSxuLnNvbWUoZnVuY3Rpb24obil7bi5jYWxsKHUpO30pO31jYXRjaChuKXtsJDEuX19lKG4sdS5fX3YpO319KTt9ZnVuY3Rpb24gTyhsLHUsaSx0LHIsbyxmLGUpe3ZhciBzLGEsaCx5PWkucHJvcHMscD11LnByb3BzLGQ9dS50eXBlLF89MDtpZihcInN2Z1wiPT09ZCYmKHI9ITApLG51bGwhPW8pZm9yKDtfPG8ubGVuZ3RoO18rKylpZigocz1vW19dKSYmXCJzZXRBdHRyaWJ1dGVcImluIHM9PSEhZCYmKGQ/cy5sb2NhbE5hbWU9PT1kOjM9PT1zLm5vZGVUeXBlKSl7bD1zLG9bX109bnVsbDticmVha31pZihudWxsPT1sKXtpZihudWxsPT09ZClyZXR1cm4gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUocCk7bD1yP2RvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsZCk6ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChkLHAuaXMmJnApLG89bnVsbCxlPSExO31pZihudWxsPT09ZCl5PT09cHx8ZSYmbC5kYXRhPT09cHx8KGwuZGF0YT1wKTtlbHNlIHtpZihvPW8mJm4uY2FsbChsLmNoaWxkTm9kZXMpLGE9KHk9aS5wcm9wc3x8YyQxKS5kYW5nZXJvdXNseVNldElubmVySFRNTCxoPXAuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwsIWUpe2lmKG51bGwhPW8pZm9yKHk9e30sXz0wO188bC5hdHRyaWJ1dGVzLmxlbmd0aDtfKyspeVtsLmF0dHJpYnV0ZXNbX10ubmFtZV09bC5hdHRyaWJ1dGVzW19dLnZhbHVlOyhofHxhKSYmKGgmJihhJiZoLl9faHRtbD09YS5fX2h0bWx8fGguX19odG1sPT09bC5pbm5lckhUTUwpfHwobC5pbm5lckhUTUw9aCYmaC5fX2h0bWx8fFwiXCIpKTt9aWYoayQxKGwscCx5LHIsZSksaCl1Ll9faz1bXTtlbHNlIGlmKF89dS5wcm9wcy5jaGlsZHJlbixIJDEobCxBcnJheS5pc0FycmF5KF8pP186W19dLHUsaSx0LHImJlwiZm9yZWlnbk9iamVjdFwiIT09ZCxvLGYsbz9vWzBdOmkuX19rJiZBKGksMCksZSksbnVsbCE9bylmb3IoXz1vLmxlbmd0aDtfLS07KW51bGwhPW9bX10mJnYkMShvW19dKTtlfHwoXCJ2YWx1ZVwiaW4gcCYmdm9pZCAwIT09KF89cC52YWx1ZSkmJihfIT09bC52YWx1ZXx8XCJwcm9ncmVzc1wiPT09ZCYmIV98fFwib3B0aW9uXCI9PT1kJiZfIT09eS52YWx1ZSkmJmckMihsLFwidmFsdWVcIixfLHkudmFsdWUsITEpLFwiY2hlY2tlZFwiaW4gcCYmdm9pZCAwIT09KF89cC5jaGVja2VkKSYmXyE9PWwuY2hlY2tlZCYmZyQyKGwsXCJjaGVja2VkXCIsXyx5LmNoZWNrZWQsITEpKTt9cmV0dXJuIGx9ZnVuY3Rpb24gUyhuLHUsaSl7dHJ5e1wiZnVuY3Rpb25cIj09dHlwZW9mIG4/bih1KTpuLmN1cnJlbnQ9dTt9Y2F0Y2gobil7bCQxLl9fZShuLGkpO319ZnVuY3Rpb24gcShuLHUsaSl7dmFyIHQscjtpZihsJDEudW5tb3VudCYmbCQxLnVubW91bnQobiksKHQ9bi5yZWYpJiYodC5jdXJyZW50JiZ0LmN1cnJlbnQhPT1uLl9fZXx8Uyh0LG51bGwsdSkpLG51bGwhPSh0PW4uX19jKSl7aWYodC5jb21wb25lbnRXaWxsVW5tb3VudCl0cnl7dC5jb21wb25lbnRXaWxsVW5tb3VudCgpO31jYXRjaChuKXtsJDEuX19lKG4sdSk7fXQuYmFzZT10Ll9fUD1udWxsLG4uX19jPXZvaWQgMDt9aWYodD1uLl9faylmb3Iocj0wO3I8dC5sZW5ndGg7cisrKXRbcl0mJnEodFtyXSx1LGl8fFwiZnVuY3Rpb25cIiE9dHlwZW9mIG4udHlwZSk7aXx8bnVsbD09bi5fX2V8fHYkMShuLl9fZSksbi5fXz1uLl9fZT1uLl9fZD12b2lkIDA7fWZ1bmN0aW9uIEIkMShuLGwsdSl7cmV0dXJuIHRoaXMuY29uc3RydWN0b3Iobix1KX1mdW5jdGlvbiBEJDEodSxpLHQpe3ZhciByLG8sZjtsJDEuX18mJmwkMS5fXyh1LGkpLG89KHI9XCJmdW5jdGlvblwiPT10eXBlb2YgdCk/bnVsbDp0JiZ0Ll9fa3x8aS5fX2ssZj1bXSxNKGksdT0oIXImJnR8fGkpLl9faz15KF8sbnVsbCxbdV0pLG98fGMkMSxjJDEsdm9pZCAwIT09aS5vd25lclNWR0VsZW1lbnQsIXImJnQ/W3RdOm8/bnVsbDppLmZpcnN0Q2hpbGQ/bi5jYWxsKGkuY2hpbGROb2Rlcyk6bnVsbCxmLCFyJiZ0P3Q6bz9vLl9fZTppLmZpcnN0Q2hpbGQsciksTihmLHUpO31mdW5jdGlvbiBFKG4sbCl7RCQxKG4sbCxFKTt9ZnVuY3Rpb24gRiQxKGwsdSxpKXt2YXIgdCxyLG8sZj1oKHt9LGwucHJvcHMpO2ZvcihvIGluIHUpXCJrZXlcIj09bz90PXVbb106XCJyZWZcIj09bz9yPXVbb106ZltvXT11W29dO3JldHVybiBhcmd1bWVudHMubGVuZ3RoPjImJihmLmNoaWxkcmVuPWFyZ3VtZW50cy5sZW5ndGg+Mz9uLmNhbGwoYXJndW1lbnRzLDIpOmkpLHAobC50eXBlLGYsdHx8bC5rZXkscnx8bC5yZWYsbnVsbCl9ZnVuY3Rpb24gRyQxKG4sbCl7dmFyIHU9e19fYzpsPVwiX19jQ1wiK2UkMSsrLF9fOm4sQ29uc3VtZXI6ZnVuY3Rpb24obixsKXtyZXR1cm4gbi5jaGlsZHJlbihsKX0sUHJvdmlkZXI6ZnVuY3Rpb24obil7dmFyIHUsaTtyZXR1cm4gdGhpcy5nZXRDaGlsZENvbnRleHR8fCh1PVtdLChpPXt9KVtsXT10aGlzLHRoaXMuZ2V0Q2hpbGRDb250ZXh0PWZ1bmN0aW9uKCl7cmV0dXJuIGl9LHRoaXMuc2hvdWxkQ29tcG9uZW50VXBkYXRlPWZ1bmN0aW9uKG4pe3RoaXMucHJvcHMudmFsdWUhPT1uLnZhbHVlJiZ1LnNvbWUoZnVuY3Rpb24obil7bi5fX2U9ITAsVCQxKG4pO30pO30sdGhpcy5zdWI9ZnVuY3Rpb24obil7dS5wdXNoKG4pO3ZhciBsPW4uY29tcG9uZW50V2lsbFVubW91bnQ7bi5jb21wb25lbnRXaWxsVW5tb3VudD1mdW5jdGlvbigpe3Uuc3BsaWNlKHUuaW5kZXhPZihuKSwxKSxsJiZsLmNhbGwobik7fTt9KSxuLmNoaWxkcmVufX07cmV0dXJuIHUuUHJvdmlkZXIuX189dS5Db25zdW1lci5jb250ZXh0VHlwZT11fW49cy5zbGljZSxsJDE9e19fZTpmdW5jdGlvbihuLGwsdSxpKXtmb3IodmFyIHQscixvO2w9bC5fXzspaWYoKHQ9bC5fX2MpJiYhdC5fXyl0cnl7aWYoKHI9dC5jb25zdHJ1Y3RvcikmJm51bGwhPXIuZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yJiYodC5zZXRTdGF0ZShyLmdldERlcml2ZWRTdGF0ZUZyb21FcnJvcihuKSksbz10Ll9fZCksbnVsbCE9dC5jb21wb25lbnREaWRDYXRjaCYmKHQuY29tcG9uZW50RGlkQ2F0Y2gobixpfHx7fSksbz10Ll9fZCksbylyZXR1cm4gdC5fX0U9dH1jYXRjaChsKXtuPWw7fXRocm93IG59fSx1JDE9MCxpJDE9ZnVuY3Rpb24obil7cmV0dXJuIG51bGwhPW4mJnZvaWQgMD09PW4uY29uc3RydWN0b3J9LHQ9ITEseCQxLnByb3RvdHlwZS5zZXRTdGF0ZT1mdW5jdGlvbihuLGwpe3ZhciB1O3U9bnVsbCE9dGhpcy5fX3MmJnRoaXMuX19zIT09dGhpcy5zdGF0ZT90aGlzLl9fczp0aGlzLl9fcz1oKHt9LHRoaXMuc3RhdGUpLFwiZnVuY3Rpb25cIj09dHlwZW9mIG4mJihuPW4oaCh7fSx1KSx0aGlzLnByb3BzKSksbiYmaCh1LG4pLG51bGwhPW4mJnRoaXMuX192JiYobCYmdGhpcy5fc2IucHVzaChsKSxUJDEodGhpcykpO30seCQxLnByb3RvdHlwZS5mb3JjZVVwZGF0ZT1mdW5jdGlvbihuKXt0aGlzLl9fdiYmKHRoaXMuX19lPSEwLG4mJnRoaXMuX19oLnB1c2gobiksVCQxKHRoaXMpKTt9LHgkMS5wcm90b3R5cGUucmVuZGVyPV8sciQxPVtdLGYkMT1cImZ1bmN0aW9uXCI9PXR5cGVvZiBQcm9taXNlP1Byb21pc2UucHJvdG90eXBlLnRoZW4uYmluZChQcm9taXNlLnJlc29sdmUoKSk6c2V0VGltZW91dCwkJDEuX19yPTAsZSQxPTA7XHJcblxyXG4gICAgdmFyIHIsdSxpLGY9W10sYz1bXSxlPWwkMS5fX2IsYT1sJDEuX19yLHY9bCQxLmRpZmZlZCxsPWwkMS5fX2MsbT1sJDEudW5tb3VudDtmdW5jdGlvbiBiKCl7Zm9yKHZhciB0O3Q9Zi5zaGlmdCgpOylpZih0Ll9fUCYmdC5fX0gpdHJ5e3QuX19ILl9faC5mb3JFYWNoKGspLHQuX19ILl9faC5mb3JFYWNoKHckMSksdC5fX0guX19oPVtdO31jYXRjaChyKXt0Ll9fSC5fX2g9W10sbCQxLl9fZShyLHQuX192KTt9fWwkMS5fX2I9ZnVuY3Rpb24obil7cj1udWxsLGUmJmUobik7fSxsJDEuX19yPWZ1bmN0aW9uKG4pe2EmJmEobik7dmFyIGk9KHI9bi5fX2MpLl9fSDtpJiYodT09PXI/KGkuX19oPVtdLHIuX19oPVtdLGkuX18uZm9yRWFjaChmdW5jdGlvbihuKXtuLl9fTiYmKG4uX189bi5fX04pLG4uX19WPWMsbi5fX049bi5pPXZvaWQgMDt9KSk6KGkuX19oLmZvckVhY2goayksaS5fX2guZm9yRWFjaCh3JDEpLGkuX19oPVtdKSksdT1yO30sbCQxLmRpZmZlZD1mdW5jdGlvbih0KXt2JiZ2KHQpO3ZhciBvPXQuX19jO28mJm8uX19IJiYoby5fX0guX19oLmxlbmd0aCYmKDEhPT1mLnB1c2gobykmJmk9PT1sJDEucmVxdWVzdEFuaW1hdGlvbkZyYW1lfHwoKGk9bCQxLnJlcXVlc3RBbmltYXRpb25GcmFtZSl8fGokMSkoYikpLG8uX19ILl9fLmZvckVhY2goZnVuY3Rpb24obil7bi5pJiYobi5fX0g9bi5pKSxuLl9fViE9PWMmJihuLl9fPW4uX19WKSxuLmk9dm9pZCAwLG4uX19WPWM7fSkpLHU9cj1udWxsO30sbCQxLl9fYz1mdW5jdGlvbih0LHIpe3Iuc29tZShmdW5jdGlvbih0KXt0cnl7dC5fX2guZm9yRWFjaChrKSx0Ll9faD10Ll9faC5maWx0ZXIoZnVuY3Rpb24obil7cmV0dXJuICFuLl9ffHx3JDEobil9KTt9Y2F0Y2godSl7ci5zb21lKGZ1bmN0aW9uKG4pe24uX19oJiYobi5fX2g9W10pO30pLHI9W10sbCQxLl9fZSh1LHQuX192KTt9fSksbCYmbCh0LHIpO30sbCQxLnVubW91bnQ9ZnVuY3Rpb24odCl7bSYmbSh0KTt2YXIgcix1PXQuX19jO3UmJnUuX19IJiYodS5fX0guX18uZm9yRWFjaChmdW5jdGlvbihuKXt0cnl7ayhuKTt9Y2F0Y2gobil7cj1uO319KSx1Ll9fSD12b2lkIDAsciYmbCQxLl9fZShyLHUuX192KSk7fTt2YXIgZyQxPVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVlc3RBbmltYXRpb25GcmFtZTtmdW5jdGlvbiBqJDEobil7dmFyIHQscj1mdW5jdGlvbigpe2NsZWFyVGltZW91dCh1KSxnJDEmJmNhbmNlbEFuaW1hdGlvbkZyYW1lKHQpLHNldFRpbWVvdXQobik7fSx1PXNldFRpbWVvdXQociwxMDApO2ckMSYmKHQ9cmVxdWVzdEFuaW1hdGlvbkZyYW1lKHIpKTt9ZnVuY3Rpb24gayhuKXt2YXIgdD1yLHU9bi5fX2M7XCJmdW5jdGlvblwiPT10eXBlb2YgdSYmKG4uX19jPXZvaWQgMCx1KCkpLHI9dDt9ZnVuY3Rpb24gdyQxKG4pe3ZhciB0PXI7bi5fX2M9bi5fXygpLHI9dDt9XHJcblxyXG4gICAgZnVuY3Rpb24gZyhuLHQpe2Zvcih2YXIgZSBpbiB0KW5bZV09dFtlXTtyZXR1cm4gbn1mdW5jdGlvbiBDKG4sdCl7Zm9yKHZhciBlIGluIG4paWYoXCJfX3NvdXJjZVwiIT09ZSYmIShlIGluIHQpKXJldHVybiAhMDtmb3IodmFyIHIgaW4gdClpZihcIl9fc291cmNlXCIhPT1yJiZuW3JdIT09dFtyXSlyZXR1cm4gITA7cmV0dXJuICExfWZ1bmN0aW9uIHcobil7dGhpcy5wcm9wcz1uO30ody5wcm90b3R5cGU9bmV3IHgkMSkuaXNQdXJlUmVhY3RDb21wb25lbnQ9ITAsdy5wcm90b3R5cGUuc2hvdWxkQ29tcG9uZW50VXBkYXRlPWZ1bmN0aW9uKG4sdCl7cmV0dXJuIEModGhpcy5wcm9wcyxuKXx8Qyh0aGlzLnN0YXRlLHQpfTt2YXIgeD1sJDEuX19iO2wkMS5fX2I9ZnVuY3Rpb24obil7bi50eXBlJiZuLnR5cGUuX19mJiZuLnJlZiYmKG4ucHJvcHMucmVmPW4ucmVmLG4ucmVmPW51bGwpLHgmJngobik7fTt2YXIgVD1sJDEuX19lO2wkMS5fX2U9ZnVuY3Rpb24obix0LGUscil7aWYobi50aGVuKWZvcih2YXIgdSxvPXQ7bz1vLl9fOylpZigodT1vLl9fYykmJnUuX19jKXJldHVybiBudWxsPT10Ll9fZSYmKHQuX19lPWUuX19lLHQuX19rPWUuX19rKSx1Ll9fYyhuLHQpO1Qobix0LGUscik7fTt2YXIgST1sJDEudW5tb3VudDtmdW5jdGlvbiBMKG4sdCxlKXtyZXR1cm4gbiYmKG4uX19jJiZuLl9fYy5fX0gmJihuLl9fYy5fX0guX18uZm9yRWFjaChmdW5jdGlvbihuKXtcImZ1bmN0aW9uXCI9PXR5cGVvZiBuLl9fYyYmbi5fX2MoKTt9KSxuLl9fYy5fX0g9bnVsbCksbnVsbCE9KG49Zyh7fSxuKSkuX19jJiYobi5fX2MuX19QPT09ZSYmKG4uX19jLl9fUD10KSxuLl9fYz1udWxsKSxuLl9faz1uLl9fayYmbi5fX2subWFwKGZ1bmN0aW9uKG4pe3JldHVybiBMKG4sdCxlKX0pKSxufWZ1bmN0aW9uIFUobix0LGUpe3JldHVybiBuJiYobi5fX3Y9bnVsbCxuLl9faz1uLl9fayYmbi5fX2subWFwKGZ1bmN0aW9uKG4pe3JldHVybiBVKG4sdCxlKX0pLG4uX19jJiZuLl9fYy5fX1A9PT10JiYobi5fX2UmJmUuaW5zZXJ0QmVmb3JlKG4uX19lLG4uX19kKSxuLl9fYy5fX2U9ITAsbi5fX2MuX19QPWUpKSxufWZ1bmN0aW9uIEQoKXt0aGlzLl9fdT0wLHRoaXMudD1udWxsLHRoaXMuX19iPW51bGw7fWZ1bmN0aW9uIEYobil7dmFyIHQ9bi5fXy5fX2M7cmV0dXJuIHQmJnQuX19hJiZ0Ll9fYShuKX1mdW5jdGlvbiBWKCl7dGhpcy51PW51bGwsdGhpcy5vPW51bGw7fWwkMS51bm1vdW50PWZ1bmN0aW9uKG4pe3ZhciB0PW4uX19jO3QmJnQuX19SJiZ0Ll9fUigpLHQmJiEwPT09bi5fX2gmJihuLnR5cGU9bnVsbCksSSYmSShuKTt9LChELnByb3RvdHlwZT1uZXcgeCQxKS5fX2M9ZnVuY3Rpb24obix0KXt2YXIgZT10Ll9fYyxyPXRoaXM7bnVsbD09ci50JiYoci50PVtdKSxyLnQucHVzaChlKTt2YXIgdT1GKHIuX192KSxvPSExLGk9ZnVuY3Rpb24oKXtvfHwobz0hMCxlLl9fUj1udWxsLHU/dShsKTpsKCkpO307ZS5fX1I9aTt2YXIgbD1mdW5jdGlvbigpe2lmKCEtLXIuX191KXtpZihyLnN0YXRlLl9fYSl7dmFyIG49ci5zdGF0ZS5fX2E7ci5fX3YuX19rWzBdPVUobixuLl9fYy5fX1Asbi5fX2MuX19PKTt9dmFyIHQ7Zm9yKHIuc2V0U3RhdGUoe19fYTpyLl9fYj1udWxsfSk7dD1yLnQucG9wKCk7KXQuZm9yY2VVcGRhdGUoKTt9fSxjPSEwPT09dC5fX2g7ci5fX3UrK3x8Y3x8ci5zZXRTdGF0ZSh7X19hOnIuX19iPXIuX192Ll9fa1swXX0pLG4udGhlbihpLGkpO30sRC5wcm90b3R5cGUuY29tcG9uZW50V2lsbFVubW91bnQ9ZnVuY3Rpb24oKXt0aGlzLnQ9W107fSxELnByb3RvdHlwZS5yZW5kZXI9ZnVuY3Rpb24obixlKXtpZih0aGlzLl9fYil7aWYodGhpcy5fX3YuX19rKXt2YXIgcj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLG89dGhpcy5fX3YuX19rWzBdLl9fYzt0aGlzLl9fdi5fX2tbMF09TCh0aGlzLl9fYixyLG8uX19PPW8uX19QKTt9dGhpcy5fX2I9bnVsbDt9dmFyIGk9ZS5fX2EmJnkoXyxudWxsLG4uZmFsbGJhY2spO3JldHVybiBpJiYoaS5fX2g9bnVsbCksW3koXyxudWxsLGUuX19hP251bGw6bi5jaGlsZHJlbiksaV19O3ZhciBXPWZ1bmN0aW9uKG4sdCxlKXtpZigrK2VbMV09PT1lWzBdJiZuLm8uZGVsZXRlKHQpLG4ucHJvcHMucmV2ZWFsT3JkZXImJihcInRcIiE9PW4ucHJvcHMucmV2ZWFsT3JkZXJbMF18fCFuLm8uc2l6ZSkpZm9yKGU9bi51O2U7KXtmb3IoO2UubGVuZ3RoPjM7KWUucG9wKCkoKTtpZihlWzFdPGVbMF0pYnJlYWs7bi51PWU9ZVsyXTt9fTtmdW5jdGlvbiBQKG4pe3JldHVybiB0aGlzLmdldENoaWxkQ29udGV4dD1mdW5jdGlvbigpe3JldHVybiBuLmNvbnRleHR9LG4uY2hpbGRyZW59ZnVuY3Rpb24gJChuKXt2YXIgZT10aGlzLHI9bi5pO2UuY29tcG9uZW50V2lsbFVubW91bnQ9ZnVuY3Rpb24oKXtEJDEobnVsbCxlLmwpLGUubD1udWxsLGUuaT1udWxsO30sZS5pJiZlLmkhPT1yJiZlLmNvbXBvbmVudFdpbGxVbm1vdW50KCksbi5fX3Y/KGUubHx8KGUuaT1yLGUubD17bm9kZVR5cGU6MSxwYXJlbnROb2RlOnIsY2hpbGROb2RlczpbXSxhcHBlbmRDaGlsZDpmdW5jdGlvbihuKXt0aGlzLmNoaWxkTm9kZXMucHVzaChuKSxlLmkuYXBwZW5kQ2hpbGQobik7fSxpbnNlcnRCZWZvcmU6ZnVuY3Rpb24obix0KXt0aGlzLmNoaWxkTm9kZXMucHVzaChuKSxlLmkuYXBwZW5kQ2hpbGQobik7fSxyZW1vdmVDaGlsZDpmdW5jdGlvbihuKXt0aGlzLmNoaWxkTm9kZXMuc3BsaWNlKHRoaXMuY2hpbGROb2Rlcy5pbmRleE9mKG4pPj4+MSwxKSxlLmkucmVtb3ZlQ2hpbGQobik7fX0pLEQkMSh5KFAse2NvbnRleHQ6ZS5jb250ZXh0fSxuLl9fdiksZS5sKSk6ZS5sJiZlLmNvbXBvbmVudFdpbGxVbm1vdW50KCk7fWZ1bmN0aW9uIGoobixlKXt2YXIgcj15KCQse19fdjpuLGk6ZX0pO3JldHVybiByLmNvbnRhaW5lckluZm89ZSxyfShWLnByb3RvdHlwZT1uZXcgeCQxKS5fX2E9ZnVuY3Rpb24obil7dmFyIHQ9dGhpcyxlPUYodC5fX3YpLHI9dC5vLmdldChuKTtyZXR1cm4gclswXSsrLGZ1bmN0aW9uKHUpe3ZhciBvPWZ1bmN0aW9uKCl7dC5wcm9wcy5yZXZlYWxPcmRlcj8oci5wdXNoKHUpLFcodCxuLHIpKTp1KCk7fTtlP2Uobyk6bygpO319LFYucHJvdG90eXBlLnJlbmRlcj1mdW5jdGlvbihuKXt0aGlzLnU9bnVsbCx0aGlzLm89bmV3IE1hcDt2YXIgdD1qJDIobi5jaGlsZHJlbik7bi5yZXZlYWxPcmRlciYmXCJiXCI9PT1uLnJldmVhbE9yZGVyWzBdJiZ0LnJldmVyc2UoKTtmb3IodmFyIGU9dC5sZW5ndGg7ZS0tOyl0aGlzLm8uc2V0KHRbZV0sdGhpcy51PVsxLDAsdGhpcy51XSk7cmV0dXJuIG4uY2hpbGRyZW59LFYucHJvdG90eXBlLmNvbXBvbmVudERpZFVwZGF0ZT1WLnByb3RvdHlwZS5jb21wb25lbnREaWRNb3VudD1mdW5jdGlvbigpe3ZhciBuPXRoaXM7dGhpcy5vLmZvckVhY2goZnVuY3Rpb24odCxlKXtXKG4sZSx0KTt9KTt9O3ZhciB6PVwidW5kZWZpbmVkXCIhPXR5cGVvZiBTeW1ib2wmJlN5bWJvbC5mb3ImJlN5bWJvbC5mb3IoXCJyZWFjdC5lbGVtZW50XCIpfHw2MDEwMyxCPS9eKD86YWNjZW50fGFsaWdubWVudHxhcmFiaWN8YmFzZWxpbmV8Y2FwfGNsaXAoPyFQYXRoVSl8Y29sb3J8ZG9taW5hbnR8ZmlsbHxmbG9vZHxmb250fGdseXBoKD8hUil8aG9yaXp8aW1hZ2V8bGV0dGVyfGxpZ2h0aW5nfG1hcmtlcig/IUh8V3xVKXxvdmVybGluZXxwYWludHxwb2ludGVyfHNoYXBlfHN0b3B8c3RyaWtldGhyb3VnaHxzdHJva2V8dGV4dCg/IUwpfHRyYW5zZm9ybXx1bmRlcmxpbmV8dW5pY29kZXx1bml0c3x2fHZlY3Rvcnx2ZXJ0fHdvcmR8d3JpdGluZ3x4KD8hQykpW0EtWl0vLEg9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGRvY3VtZW50LFo9ZnVuY3Rpb24obil7cmV0dXJuIChcInVuZGVmaW5lZFwiIT10eXBlb2YgU3ltYm9sJiZcInN5bWJvbFwiPT10eXBlb2YgU3ltYm9sKCk/L2ZpbHxjaGV8cmFkL2k6L2ZpbHxjaGV8cmEvaSkudGVzdChuKX07eCQxLnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50PXt9LFtcImNvbXBvbmVudFdpbGxNb3VudFwiLFwiY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1wiLFwiY29tcG9uZW50V2lsbFVwZGF0ZVwiXS5mb3JFYWNoKGZ1bmN0aW9uKHQpe09iamVjdC5kZWZpbmVQcm9wZXJ0eSh4JDEucHJvdG90eXBlLHQse2NvbmZpZ3VyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc1tcIlVOU0FGRV9cIit0XX0sc2V0OmZ1bmN0aW9uKG4pe09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLHQse2NvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpufSk7fX0pO30pO3ZhciBHPWwkMS5ldmVudDtmdW5jdGlvbiBKKCl7fWZ1bmN0aW9uIEsoKXtyZXR1cm4gdGhpcy5jYW5jZWxCdWJibGV9ZnVuY3Rpb24gUSgpe3JldHVybiB0aGlzLmRlZmF1bHRQcmV2ZW50ZWR9bCQxLmV2ZW50PWZ1bmN0aW9uKG4pe3JldHVybiBHJiYobj1HKG4pKSxuLnBlcnNpc3Q9SixuLmlzUHJvcGFnYXRpb25TdG9wcGVkPUssbi5pc0RlZmF1bHRQcmV2ZW50ZWQ9USxuLm5hdGl2ZUV2ZW50PW59O3ZhciBubj17Y29uZmlndXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNsYXNzfX0sdG49bCQxLnZub2RlO2wkMS52bm9kZT1mdW5jdGlvbihuKXt2YXIgdD1uLnR5cGUsZT1uLnByb3BzLHU9ZTtpZihcInN0cmluZ1wiPT10eXBlb2YgdCl7dmFyIG89LTE9PT10LmluZGV4T2YoXCItXCIpO2Zvcih2YXIgaSBpbiB1PXt9LGUpe3ZhciBsPWVbaV07SCYmXCJjaGlsZHJlblwiPT09aSYmXCJub3NjcmlwdFwiPT09dHx8XCJ2YWx1ZVwiPT09aSYmXCJkZWZhdWx0VmFsdWVcImluIGUmJm51bGw9PWx8fChcImRlZmF1bHRWYWx1ZVwiPT09aSYmXCJ2YWx1ZVwiaW4gZSYmbnVsbD09ZS52YWx1ZT9pPVwidmFsdWVcIjpcImRvd25sb2FkXCI9PT1pJiYhMD09PWw/bD1cIlwiOi9vbmRvdWJsZWNsaWNrL2kudGVzdChpKT9pPVwib25kYmxjbGlja1wiOi9eb25jaGFuZ2UodGV4dGFyZWF8aW5wdXQpL2kudGVzdChpK3QpJiYhWihlLnR5cGUpP2k9XCJvbmlucHV0XCI6L15vbmZvY3VzJC9pLnRlc3QoaSk/aT1cIm9uZm9jdXNpblwiOi9eb25ibHVyJC9pLnRlc3QoaSk/aT1cIm9uZm9jdXNvdXRcIjovXm9uKEFuaXxUcmF8VG91fEJlZm9yZUlucHxDb21wbykvLnRlc3QoaSk/aT1pLnRvTG93ZXJDYXNlKCk6byYmQi50ZXN0KGkpP2k9aS5yZXBsYWNlKC9bQS1aMC05XS9nLFwiLSQmXCIpLnRvTG93ZXJDYXNlKCk6bnVsbD09PWwmJihsPXZvaWQgMCksL15vbmlucHV0JC9pLnRlc3QoaSkmJihpPWkudG9Mb3dlckNhc2UoKSx1W2ldJiYoaT1cIm9uaW5wdXRDYXB0dXJlXCIpKSx1W2ldPWwpO31cInNlbGVjdFwiPT10JiZ1Lm11bHRpcGxlJiZBcnJheS5pc0FycmF5KHUudmFsdWUpJiYodS52YWx1ZT1qJDIoZS5jaGlsZHJlbikuZm9yRWFjaChmdW5jdGlvbihuKXtuLnByb3BzLnNlbGVjdGVkPS0xIT11LnZhbHVlLmluZGV4T2Yobi5wcm9wcy52YWx1ZSk7fSkpLFwic2VsZWN0XCI9PXQmJm51bGwhPXUuZGVmYXVsdFZhbHVlJiYodS52YWx1ZT1qJDIoZS5jaGlsZHJlbikuZm9yRWFjaChmdW5jdGlvbihuKXtuLnByb3BzLnNlbGVjdGVkPXUubXVsdGlwbGU/LTEhPXUuZGVmYXVsdFZhbHVlLmluZGV4T2Yobi5wcm9wcy52YWx1ZSk6dS5kZWZhdWx0VmFsdWU9PW4ucHJvcHMudmFsdWU7fSkpLG4ucHJvcHM9dSxlLmNsYXNzIT1lLmNsYXNzTmFtZSYmKG5uLmVudW1lcmFibGU9XCJjbGFzc05hbWVcImluIGUsbnVsbCE9ZS5jbGFzc05hbWUmJih1LmNsYXNzPWUuY2xhc3NOYW1lKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodSxcImNsYXNzTmFtZVwiLG5uKSk7fW4uJCR0eXBlb2Y9eix0biYmdG4obik7fTt2YXIgZW49bCQxLl9fcjtsJDEuX19yPWZ1bmN0aW9uKG4pe2VuJiZlbihuKSxuLl9fYzt9O1xyXG5cclxuICAgIGNvbnN0IHN0eWxlVGV4dHMgPSBbXTtcclxuICAgIGNvbnN0IHN0eWxlRWxzID0gbmV3IE1hcCgpO1xyXG4gICAgZnVuY3Rpb24gaW5qZWN0U3R5bGVzKHN0eWxlVGV4dCkge1xyXG4gICAgICAgIHN0eWxlVGV4dHMucHVzaChzdHlsZVRleHQpO1xyXG4gICAgICAgIHN0eWxlRWxzLmZvckVhY2goKHN0eWxlRWwpID0+IHtcclxuICAgICAgICAgICAgYXBwZW5kU3R5bGVzVG8oc3R5bGVFbCwgc3R5bGVUZXh0KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGVuc3VyZUVsSGFzU3R5bGVzKGVsKSB7XHJcbiAgICAgICAgaWYgKGVsLmlzQ29ubmVjdGVkKSB7XHJcbiAgICAgICAgICAgIHJlZ2lzdGVyU3R5bGVzUm9vdChlbC5nZXRSb290Tm9kZSgpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiByZWdpc3RlclN0eWxlc1Jvb3Qocm9vdE5vZGUpIHtcclxuICAgICAgICBsZXQgc3R5bGVFbCA9IHN0eWxlRWxzLmdldChyb290Tm9kZSk7XHJcbiAgICAgICAgaWYgKCFzdHlsZUVsIHx8ICFzdHlsZUVsLmlzQ29ubmVjdGVkKSB7XHJcbiAgICAgICAgICAgIHN0eWxlRWwgPSByb290Tm9kZS5xdWVyeVNlbGVjdG9yKCdzdHlsZVtkYXRhLWZ1bGxjYWxlbmRhcl0nKTtcclxuICAgICAgICAgICAgaWYgKCFzdHlsZUVsKSB7XHJcbiAgICAgICAgICAgICAgICBzdHlsZUVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcclxuICAgICAgICAgICAgICAgIHN0eWxlRWwuc2V0QXR0cmlidXRlKCdkYXRhLWZ1bGxjYWxlbmRhcicsICcnKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5vbmNlID0gZ2V0Tm9uY2VWYWx1ZSgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG5vbmNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVFbC5ub25jZSA9IG5vbmNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29uc3QgcGFyZW50RWwgPSByb290Tm9kZSA9PT0gZG9jdW1lbnQgPyBkb2N1bWVudC5oZWFkIDogcm9vdE5vZGU7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBpbnNlcnRCZWZvcmUgPSByb290Tm9kZSA9PT0gZG9jdW1lbnRcclxuICAgICAgICAgICAgICAgICAgICA/IHBhcmVudEVsLnF1ZXJ5U2VsZWN0b3IoJ3NjcmlwdCxsaW5rW3JlbD1zdHlsZXNoZWV0XSxsaW5rW2FzPXN0eWxlXSxzdHlsZScpXHJcbiAgICAgICAgICAgICAgICAgICAgOiBwYXJlbnRFbC5maXJzdENoaWxkO1xyXG4gICAgICAgICAgICAgICAgcGFyZW50RWwuaW5zZXJ0QmVmb3JlKHN0eWxlRWwsIGluc2VydEJlZm9yZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc3R5bGVFbHMuc2V0KHJvb3ROb2RlLCBzdHlsZUVsKTtcclxuICAgICAgICAgICAgaHlkcmF0ZVN0eWxlc1Jvb3Qoc3R5bGVFbCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gaHlkcmF0ZVN0eWxlc1Jvb3Qoc3R5bGVFbCkge1xyXG4gICAgICAgIGZvciAoY29uc3Qgc3R5bGVUZXh0IG9mIHN0eWxlVGV4dHMpIHtcclxuICAgICAgICAgICAgYXBwZW5kU3R5bGVzVG8oc3R5bGVFbCwgc3R5bGVUZXh0KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBhcHBlbmRTdHlsZXNUbyhzdHlsZUVsLCBzdHlsZVRleHQpIHtcclxuICAgICAgICBjb25zdCB7IHNoZWV0IH0gPSBzdHlsZUVsO1xyXG4gICAgICAgIGNvbnN0IHJ1bGVDbnQgPSBzaGVldC5jc3NSdWxlcy5sZW5ndGg7XHJcbiAgICAgICAgc3R5bGVUZXh0LnNwbGl0KCd9JykuZm9yRWFjaCgoc3R5bGVTdHIsIGkpID0+IHtcclxuICAgICAgICAgICAgc3R5bGVTdHIgPSBzdHlsZVN0ci50cmltKCk7XHJcbiAgICAgICAgICAgIGlmIChzdHlsZVN0cikge1xyXG4gICAgICAgICAgICAgICAgc2hlZXQuaW5zZXJ0UnVsZShzdHlsZVN0ciArICd9JywgcnVsZUNudCArIGkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvLyBub25jZVxyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgbGV0IHF1ZXJpZWROb25jZVZhbHVlO1xyXG4gICAgZnVuY3Rpb24gZ2V0Tm9uY2VWYWx1ZSgpIHtcclxuICAgICAgICBpZiAocXVlcmllZE5vbmNlVmFsdWUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBxdWVyaWVkTm9uY2VWYWx1ZSA9IHF1ZXJ5Tm9uY2VWYWx1ZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcXVlcmllZE5vbmNlVmFsdWU7XHJcbiAgICB9XHJcbiAgICAvKlxyXG4gICAgVE9ETzogZGlzY291cmFnZSBtZXRhIHRhZyBhbmQgaW5zdGVhZCBwdXQgbm9uY2UgYXR0cmlidXRlIG9uIHBsYWNlaG9sZGVyIDxzdHlsZT4gdGFnXHJcbiAgICAqL1xyXG4gICAgZnVuY3Rpb24gcXVlcnlOb25jZVZhbHVlKCkge1xyXG4gICAgICAgIGNvbnN0IG1ldGFXaXRoTm9uY2UgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdtZXRhW25hbWU9XCJjc3Atbm9uY2VcIl0nKTtcclxuICAgICAgICBpZiAobWV0YVdpdGhOb25jZSAmJiBtZXRhV2l0aE5vbmNlLmhhc0F0dHJpYnV0ZSgnY29udGVudCcpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBtZXRhV2l0aE5vbmNlLmdldEF0dHJpYnV0ZSgnY29udGVudCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBlbFdpdGhOb25jZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ3NjcmlwdFtub25jZV0nKTtcclxuICAgICAgICBpZiAoZWxXaXRoTm9uY2UpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGVsV2l0aE5vbmNlLm5vbmNlIHx8ICcnO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gJyc7XHJcbiAgICB9XHJcbiAgICAvLyBtYWluXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIHJlZ2lzdGVyU3R5bGVzUm9vdChkb2N1bWVudCk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGNzc18yNDh6JDQgPSBcIjpyb290ey0tZmMtc21hbGwtZm9udC1zaXplOi44NWVtOy0tZmMtcGFnZS1iZy1jb2xvcjojZmZmOy0tZmMtbmV1dHJhbC1iZy1jb2xvcjpoc2xhKDAsMCUsODIlLC4zKTstLWZjLW5ldXRyYWwtdGV4dC1jb2xvcjpncmV5Oy0tZmMtYm9yZGVyLWNvbG9yOiNkZGQ7LS1mYy1idXR0b24tdGV4dC1jb2xvcjojZmZmOy0tZmMtYnV0dG9uLWJnLWNvbG9yOiMyYzNlNTA7LS1mYy1idXR0b24tYm9yZGVyLWNvbG9yOiMyYzNlNTA7LS1mYy1idXR0b24taG92ZXItYmctY29sb3I6IzFlMmIzNzstLWZjLWJ1dHRvbi1ob3Zlci1ib3JkZXItY29sb3I6IzFhMjUyZjstLWZjLWJ1dHRvbi1hY3RpdmUtYmctY29sb3I6IzFhMjUyZjstLWZjLWJ1dHRvbi1hY3RpdmUtYm9yZGVyLWNvbG9yOiMxNTFlMjc7LS1mYy1ldmVudC1iZy1jb2xvcjojMzc4OGQ4Oy0tZmMtZXZlbnQtYm9yZGVyLWNvbG9yOiMzNzg4ZDg7LS1mYy1ldmVudC10ZXh0LWNvbG9yOiNmZmY7LS1mYy1ldmVudC1zZWxlY3RlZC1vdmVybGF5LWNvbG9yOnJnYmEoMCwwLDAsLjI1KTstLWZjLW1vcmUtbGluay1iZy1jb2xvcjojZDBkMGQwOy0tZmMtbW9yZS1saW5rLXRleHQtY29sb3I6aW5oZXJpdDstLWZjLWV2ZW50LXJlc2l6ZXItdGhpY2tuZXNzOjhweDstLWZjLWV2ZW50LXJlc2l6ZXItZG90LXRvdGFsLXdpZHRoOjhweDstLWZjLWV2ZW50LXJlc2l6ZXItZG90LWJvcmRlci13aWR0aDoxcHg7LS1mYy1ub24tYnVzaW5lc3MtY29sb3I6aHNsYSgwLDAlLDg0JSwuMyk7LS1mYy1iZy1ldmVudC1jb2xvcjojOGZkZjgyOy0tZmMtYmctZXZlbnQtb3BhY2l0eTowLjM7LS1mYy1oaWdobGlnaHQtY29sb3I6cmdiYSgxODgsMjMyLDI0MSwuMyk7LS1mYy10b2RheS1iZy1jb2xvcjpyZ2JhKDI1NSwyMjAsNDAsLjE1KTstLWZjLW5vdy1pbmRpY2F0b3ItY29sb3I6cmVkfS5mYy1ub3QtYWxsb3dlZCwuZmMtbm90LWFsbG93ZWQgLmZjLWV2ZW50e2N1cnNvcjpub3QtYWxsb3dlZH0uZmN7ZGlzcGxheTpmbGV4O2ZsZXgtZGlyZWN0aW9uOmNvbHVtbjtmb250LXNpemU6MWVtfS5mYywuZmMgKiwuZmMgOmFmdGVyLC5mYyA6YmVmb3Jle2JveC1zaXppbmc6Ym9yZGVyLWJveH0uZmMgdGFibGV7Ym9yZGVyLWNvbGxhcHNlOmNvbGxhcHNlO2JvcmRlci1zcGFjaW5nOjA7Zm9udC1zaXplOjFlbX0uZmMgdGh7dGV4dC1hbGlnbjpjZW50ZXJ9LmZjIHRkLC5mYyB0aHtwYWRkaW5nOjA7dmVydGljYWwtYWxpZ246dG9wfS5mYyBhW2RhdGEtbmF2bGlua117Y3Vyc29yOnBvaW50ZXJ9LmZjIGFbZGF0YS1uYXZsaW5rXTpob3Zlcnt0ZXh0LWRlY29yYXRpb246dW5kZXJsaW5lfS5mYy1kaXJlY3Rpb24tbHRye2RpcmVjdGlvbjpsdHI7dGV4dC1hbGlnbjpsZWZ0fS5mYy1kaXJlY3Rpb24tcnRse2RpcmVjdGlvbjpydGw7dGV4dC1hbGlnbjpyaWdodH0uZmMtdGhlbWUtc3RhbmRhcmQgdGQsLmZjLXRoZW1lLXN0YW5kYXJkIHRoe2JvcmRlcjoxcHggc29saWQgdmFyKC0tZmMtYm9yZGVyLWNvbG9yKX0uZmMtbGlxdWlkLWhhY2sgdGQsLmZjLWxpcXVpZC1oYWNrIHRoe3Bvc2l0aW9uOnJlbGF0aXZlfUBmb250LWZhY2V7Zm9udC1mYW1pbHk6ZmNpY29ucztmb250LXN0eWxlOm5vcm1hbDtmb250LXdlaWdodDo0MDA7c3JjOnVybChcXFwiZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtdHRmO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LEFBRUFBQUFMQUlBQUF3QXdUMU12TWc4U0JmQUFBQUM4QUFBQVlHTnRZWEFYVnRLTkFBQUJIQUFBQUZSbllYTndBQUFBRUFBQUFYQUFBQUFJWjJ4NVpnWXlkeElBQUFGNEFBQUZOR2hsWVdRVUo3Y0lBQUFHckFBQUFEWm9hR1ZoQjIwRHpBQUFCdVFBQUFBa2FHMTBlQ0lBQmhRQUFBY0lBQUFBTEd4dlkyRUQ0QVU2QUFBSE5BQUFBQmh0WVhod0FBOEFqQUFBQjB3QUFBQWdibUZ0WlhzcjY5MEFBQWRzQUFBQmhuQnZjM1FBQXdBQUFBQUk5QUFBQUNBQUF3UEFBWkFBQlFBQUFwa0N6QUFBQUk4Q21RTE1BQUFCNndBekFRa0FBQUFBQUFBQUFBQUFBQUFBQUFBQkVBQUFBQUFBQUFBQUFBQUFBQUFBQUFCQUFBRHBCZ1BBLzhBQVFBUEFBRUFBQUFBQkFBQUFBQUFBQUFBQUFBQWdBQUFBQUFBREFBQUFBd0FBQUJ3QUFRQURBQUFBSEFBREFBRUFBQUFjQUFRQU9BQUFBQW9BQ0FBQ0FBSUFBUUFnNlFiLy9mLy9BQUFBQUFBZzZRRC8vZi8vQUFILzR4Y0VBQU1BQVFBQUFBQUFBQUFBQUFBQUFRQUIvLzhBRHdBQkFBQUFBQUFBQUFBQUFnQUFOemtCQUFBQUFBRUFBQUFBQUFBQUFBQUNBQUEzT1FFQUFBQUFBUUFBQUFBQUFBQUFBQUlBQURjNUFRQUFBQUFCQVdJQWpRS2VBc2tBRXdBQUpTYzNOalFuSmlJSEFRWVVGd0VXTWpjMk5DY0NudUxpRFEwTUpBei9BQTBOQVFBTUpBd05EY25pNGd3akRRd00vd0FOSXd6L0FBME5EQ01OQUFBQUFRRmlBSTBDbmdMSkFCTUFBQ1VCTmpRbkFTWWlCd1lVSHdFSEJoUVhGakkzQVo0QkFBME4vd0FNSkF3TkRlTGlEUTBNSkF5TkFRQU1JdzBCQUF3TURTTU00dUlOSXd3TkRRQUFBQUlBNGdDM0F4NENuZ0FUQUNjQUFDVW5OelkwSnlZaUR3RUdGQjhCRmpJM05qUW5JU2MzTmpRbkppSVBBUVlVSHdFV01qYzJOQ2NCODdlM0RRME1JdzNWRFEzVkRTTU1EUTBCSzdlM0RRME1KQXpWRFEzVkRDUU1EUTN6dUxjTUpBd05EZFVOSXd6V0RBd05Jd3k0dHd3a0RBME4xUTBqRE5ZTURBMGpEQUFBQWdEaUFMY0RIZ0tlQUJNQUp3QUFKVGMyTkM4QkppSUhCaFFmQVFjR0ZCY1dNamNoTnpZMEx3RW1JZ2NHRkI4QkJ3WVVGeFl5TndKSjFRME4xUTBqREEwTnQ3Y05EUXdqRGY3VjFRME4xUXdrREEwTnQ3Y05EUXdrRExmV0RDTU4xUTBORENRTXQ3Z01JdzBNRE5ZTUl3M1ZEUTBNSkF5M3VBd2pEUXdNQUFBREFGVUFBQU9yQTFVQU13Qm9BSGNBQUJNaUJnY09BUWNPQVFjT0FSVVJGQllYSGdFWEhnRVhIZ0V6SVRJMk56NEJOejRCTno0Qk5SRTBKaWN1QVNjdUFTY3VBU01GSVRJV0Z4NEJGeDRCRng0QkZSRVVCZ2NPQVFjT0FRY09BU01oSWlZbkxnRW5MZ0VuTGdFMUVUUTJOejRCTno0Qk56NEJNeE1oTWpZMU5DWWpJU0lHRlJRV005VU5HQXdMRlFrSkRnVUZCUVVGQlE0SkNSVUxEQmdOQWxZTkdBd0xGUWtKRGdVRkJRVUZCUTRKQ1JVTERCZ04vYW9DVmdRSUJBUUhBd01GQVFJQkFRSUJCUU1EQndRRUNBVDlxZ1FJQkFRSEF3TUZBUUlCQVFJQkJRTURCd1FFQ0FTQUFWWVJHUmtSL3FvUkdSa1JBMVVGQkFVT0NRa1ZEQXNaRGYyckRSa0xEQlVKQ0E0RkJRVUZCUVVPQ1FnVkRBc1pEUUpWRFJrTERCVUpDUTRGQkFWVkFnRUNCUU1DQndRRUNBWDlxd1FKQXdRSEF3TUZBUUlDQWdJQkJRTURCd1FEQ1FRQ1ZRVUlCQVFIQWdNRkFnRUMvb0FaRWhFWkdSRVNHUUFBQUFBREFGVUFBQU9yQTFVQU13Qm9BSWtBQUJNaUJnY09BUWNPQVFjT0FSVVJGQllYSGdFWEhnRVhIZ0V6SVRJMk56NEJOejRCTno0Qk5SRTBKaWN1QVNjdUFTY3VBU01GSVRJV0Z4NEJGeDRCRng0QkZSRVVCZ2NPQVFjT0FRY09BU01oSWlZbkxnRW5MZ0VuTGdFMUVUUTJOejRCTno0Qk56NEJNeE16RlJRV016STJQUUV6TWpZMU5DWXJBVFUwSmlNaUJoMEJJeUlHRlJRV005VU5HQXdMRlFrSkRnVUZCUVVGQlE0SkNSVUxEQmdOQWxZTkdBd0xGUWtKRGdVRkJRVUZCUTRKQ1JVTERCZ04vYW9DVmdRSUJBUUhBd01GQVFJQkFRSUJCUU1EQndRRUNBVDlxZ1FJQkFRSEF3TUZBUUlCQVFJQkJRTURCd1FFQ0FTQWdCa1NFaG1BRVJrWkVZQVpFaElaZ0JFWkdSRURWUVVFQlE0SkNSVU1DeGtOL2FzTkdRc01GUWtJRGdVRkJRVUZCUTRKQ0JVTUN4a05BbFVOR1FzTUZRa0pEZ1VFQlZVQ0FRSUZBd0lIQkFRSUJmMnJCQWtEQkFjREF3VUJBZ0lDQWdFRkF3TUhCQU1KQkFKVkJRZ0VCQWNDQXdVQ0FRTCtnSUFTR1JrU2dCa1NFUm1BRWhrWkVvQVpFUklaQUFBQkFPSUFqUU1lQXNrQUlBQUFFeGNIQmhRWEZqSS9BUmNXTWpjMk5DOEJOelkwSnlZaUR3RW5KaUlIQmhRWDR1TGlEUTBNSkF6aTRnd2tEQTBONHVJTkRRd2tET0xpRENRTURRMENqZUxpRFNNTURRM2g0UTBORENNTjR1SU1JdzBNRE9MaURBd05Jd3dBQUFBQkFBQUFBUUFBYTVuMHkxOFBQUFVBQ3dRQUFBQUFBTml2T1ZzQUFBQUEySzg1V3dBQUFBQURxd05WQUFBQUNBQUNBQUFBQUFBQUFBRUFBQVBBLzhBQUFBUUFBQUFBQUFPckFBRUFBQUFBQUFBQUFBQUFBQUFBQUFBTEJBQUFBQUFBQUFBQUFBQUFBZ0FBQUFRQUFXSUVBQUZpQkFBQTRnUUFBT0lFQUFCVkJBQUFWUVFBQU9JQUFBQUFBQW9BRkFBZUFFUUFhZ0NxQU9vQm5nSmtBcG9BQVFBQUFBc0FpZ0FEQUFBQUFBQUNBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQTRBcmdBQkFBQUFBQUFCQUFjQUFBQUJBQUFBQUFBQ0FBY0FZQUFCQUFBQUFBQURBQWNBTmdBQkFBQUFBQUFFQUFjQWRRQUJBQUFBQUFBRkFBc0FGUUFCQUFBQUFBQUdBQWNBU3dBQkFBQUFBQUFLQUJvQWlnQURBQUVFQ1FBQkFBNEFCd0FEQUFFRUNRQUNBQTRBWndBREFBRUVDUUFEQUE0QVBRQURBQUVFQ1FBRUFBNEFmQUFEQUFFRUNRQUZBQllBSUFBREFBRUVDUUFHQUE0QVVnQURBQUVFQ1FBS0FEUUFwR1pqYVdOdmJuTUFaZ0JqQUdrQVl3QnZBRzRBYzFabGNuTnBiMjRnTVM0d0FGWUFaUUJ5QUhNQWFRQnZBRzRBSUFBeEFDNEFNR1pqYVdOdmJuTUFaZ0JqQUdrQVl3QnZBRzRBYzJaamFXTnZibk1BWmdCakFHa0FZd0J2QUc0QWMxSmxaM1ZzWVhJQVVnQmxBR2NBZFFCc0FHRUFjbVpqYVdOdmJuTUFaZ0JqQUdrQVl3QnZBRzRBYzBadmJuUWdaMlZ1WlhKaGRHVmtJR0o1SUVsamIwMXZiMjR1QUVZQWJ3QnVBSFFBSUFCbkFHVUFiZ0JsQUhJQVlRQjBBR1VBWkFBZ0FHSUFlUUFnQUVrQVl3QnZBRTBBYndCdkFHNEFMZ0FBQUFNQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQT1cXFwiKSBmb3JtYXQoXFxcInRydWV0eXBlXFxcIil9LmZjLWljb257c3BlYWs6bm9uZTstd2Via2l0LWZvbnQtc21vb3RoaW5nOmFudGlhbGlhc2VkOy1tb3otb3N4LWZvbnQtc21vb3RoaW5nOmdyYXlzY2FsZTtkaXNwbGF5OmlubGluZS1ibG9jaztmb250LWZhbWlseTpmY2ljb25zIWltcG9ydGFudDtmb250LXN0eWxlOm5vcm1hbDtmb250LXZhcmlhbnQ6bm9ybWFsO2ZvbnQtd2VpZ2h0OjQwMDtoZWlnaHQ6MWVtO2xpbmUtaGVpZ2h0OjE7dGV4dC1hbGlnbjpjZW50ZXI7dGV4dC10cmFuc2Zvcm06bm9uZTstd2Via2l0LXVzZXItc2VsZWN0Om5vbmU7LW1vei11c2VyLXNlbGVjdDpub25lO3VzZXItc2VsZWN0Om5vbmU7d2lkdGg6MWVtfS5mYy1pY29uLWNoZXZyb24tbGVmdDpiZWZvcmV7Y29udGVudDpcXFwiXFxcXGU5MDBcXFwifS5mYy1pY29uLWNoZXZyb24tcmlnaHQ6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxlOTAxXFxcIn0uZmMtaWNvbi1jaGV2cm9ucy1sZWZ0OmJlZm9yZXtjb250ZW50OlxcXCJcXFxcZTkwMlxcXCJ9LmZjLWljb24tY2hldnJvbnMtcmlnaHQ6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxlOTAzXFxcIn0uZmMtaWNvbi1taW51cy1zcXVhcmU6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxlOTA0XFxcIn0uZmMtaWNvbi1wbHVzLXNxdWFyZTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXGU5MDVcXFwifS5mYy1pY29uLXg6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxlOTA2XFxcIn0uZmMgLmZjLWJ1dHRvbntib3JkZXItcmFkaXVzOjA7Zm9udC1mYW1pbHk6aW5oZXJpdDtmb250LXNpemU6aW5oZXJpdDtsaW5lLWhlaWdodDppbmhlcml0O21hcmdpbjowO292ZXJmbG93OnZpc2libGU7dGV4dC10cmFuc2Zvcm06bm9uZX0uZmMgLmZjLWJ1dHRvbjpmb2N1c3tvdXRsaW5lOjFweCBkb3R0ZWQ7b3V0bGluZTo1cHggYXV0byAtd2Via2l0LWZvY3VzLXJpbmctY29sb3J9LmZjIC5mYy1idXR0b257LXdlYmtpdC1hcHBlYXJhbmNlOmJ1dHRvbn0uZmMgLmZjLWJ1dHRvbjpub3QoOmRpc2FibGVkKXtjdXJzb3I6cG9pbnRlcn0uZmMgLmZjLWJ1dHRvbntiYWNrZ3JvdW5kLWNvbG9yOnRyYW5zcGFyZW50O2JvcmRlcjoxcHggc29saWQgdHJhbnNwYXJlbnQ7Ym9yZGVyLXJhZGl1czouMjVlbTtkaXNwbGF5OmlubGluZS1ibG9jaztmb250LXNpemU6MWVtO2ZvbnQtd2VpZ2h0OjQwMDtsaW5lLWhlaWdodDoxLjU7cGFkZGluZzouNGVtIC42NWVtO3RleHQtYWxpZ246Y2VudGVyOy13ZWJraXQtdXNlci1zZWxlY3Q6bm9uZTstbW96LXVzZXItc2VsZWN0Om5vbmU7dXNlci1zZWxlY3Q6bm9uZTt2ZXJ0aWNhbC1hbGlnbjptaWRkbGV9LmZjIC5mYy1idXR0b246aG92ZXJ7dGV4dC1kZWNvcmF0aW9uOm5vbmV9LmZjIC5mYy1idXR0b246Zm9jdXN7Ym94LXNoYWRvdzowIDAgMCAuMnJlbSByZ2JhKDQ0LDYyLDgwLC4yNSk7b3V0bGluZTowfS5mYyAuZmMtYnV0dG9uOmRpc2FibGVke29wYWNpdHk6LjY1fS5mYyAuZmMtYnV0dG9uLXByaW1hcnl7YmFja2dyb3VuZC1jb2xvcjp2YXIoLS1mYy1idXR0b24tYmctY29sb3IpO2JvcmRlci1jb2xvcjp2YXIoLS1mYy1idXR0b24tYm9yZGVyLWNvbG9yKTtjb2xvcjp2YXIoLS1mYy1idXR0b24tdGV4dC1jb2xvcil9LmZjIC5mYy1idXR0b24tcHJpbWFyeTpob3ZlcntiYWNrZ3JvdW5kLWNvbG9yOnZhcigtLWZjLWJ1dHRvbi1ob3Zlci1iZy1jb2xvcik7Ym9yZGVyLWNvbG9yOnZhcigtLWZjLWJ1dHRvbi1ob3Zlci1ib3JkZXItY29sb3IpO2NvbG9yOnZhcigtLWZjLWJ1dHRvbi10ZXh0LWNvbG9yKX0uZmMgLmZjLWJ1dHRvbi1wcmltYXJ5OmRpc2FibGVke2JhY2tncm91bmQtY29sb3I6dmFyKC0tZmMtYnV0dG9uLWJnLWNvbG9yKTtib3JkZXItY29sb3I6dmFyKC0tZmMtYnV0dG9uLWJvcmRlci1jb2xvcik7Y29sb3I6dmFyKC0tZmMtYnV0dG9uLXRleHQtY29sb3IpfS5mYyAuZmMtYnV0dG9uLXByaW1hcnk6Zm9jdXN7Ym94LXNoYWRvdzowIDAgMCAuMnJlbSByZ2JhKDc2LDkxLDEwNiwuNSl9LmZjIC5mYy1idXR0b24tcHJpbWFyeTpub3QoOmRpc2FibGVkKS5mYy1idXR0b24tYWN0aXZlLC5mYyAuZmMtYnV0dG9uLXByaW1hcnk6bm90KDpkaXNhYmxlZCk6YWN0aXZle2JhY2tncm91bmQtY29sb3I6dmFyKC0tZmMtYnV0dG9uLWFjdGl2ZS1iZy1jb2xvcik7Ym9yZGVyLWNvbG9yOnZhcigtLWZjLWJ1dHRvbi1hY3RpdmUtYm9yZGVyLWNvbG9yKTtjb2xvcjp2YXIoLS1mYy1idXR0b24tdGV4dC1jb2xvcil9LmZjIC5mYy1idXR0b24tcHJpbWFyeTpub3QoOmRpc2FibGVkKS5mYy1idXR0b24tYWN0aXZlOmZvY3VzLC5mYyAuZmMtYnV0dG9uLXByaW1hcnk6bm90KDpkaXNhYmxlZCk6YWN0aXZlOmZvY3Vze2JveC1zaGFkb3c6MCAwIDAgLjJyZW0gcmdiYSg3Niw5MSwxMDYsLjUpfS5mYyAuZmMtYnV0dG9uIC5mYy1pY29ue2ZvbnQtc2l6ZToxLjVlbTt2ZXJ0aWNhbC1hbGlnbjptaWRkbGV9LmZjIC5mYy1idXR0b24tZ3JvdXB7ZGlzcGxheTppbmxpbmUtZmxleDtwb3NpdGlvbjpyZWxhdGl2ZTt2ZXJ0aWNhbC1hbGlnbjptaWRkbGV9LmZjIC5mYy1idXR0b24tZ3JvdXA+LmZjLWJ1dHRvbntmbGV4OjEgMSBhdXRvO3Bvc2l0aW9uOnJlbGF0aXZlfS5mYyAuZmMtYnV0dG9uLWdyb3VwPi5mYy1idXR0b24uZmMtYnV0dG9uLWFjdGl2ZSwuZmMgLmZjLWJ1dHRvbi1ncm91cD4uZmMtYnV0dG9uOmFjdGl2ZSwuZmMgLmZjLWJ1dHRvbi1ncm91cD4uZmMtYnV0dG9uOmZvY3VzLC5mYyAuZmMtYnV0dG9uLWdyb3VwPi5mYy1idXR0b246aG92ZXJ7ei1pbmRleDoxfS5mYy1kaXJlY3Rpb24tbHRyIC5mYy1idXR0b24tZ3JvdXA+LmZjLWJ1dHRvbjpub3QoOmZpcnN0LWNoaWxkKXtib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOjA7Ym9yZGVyLXRvcC1sZWZ0LXJhZGl1czowO21hcmdpbi1sZWZ0Oi0xcHh9LmZjLWRpcmVjdGlvbi1sdHIgLmZjLWJ1dHRvbi1ncm91cD4uZmMtYnV0dG9uOm5vdCg6bGFzdC1jaGlsZCl7Ym9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6MDtib3JkZXItdG9wLXJpZ2h0LXJhZGl1czowfS5mYy1kaXJlY3Rpb24tcnRsIC5mYy1idXR0b24tZ3JvdXA+LmZjLWJ1dHRvbjpub3QoOmZpcnN0LWNoaWxkKXtib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1czowO2JvcmRlci10b3AtcmlnaHQtcmFkaXVzOjA7bWFyZ2luLXJpZ2h0Oi0xcHh9LmZjLWRpcmVjdGlvbi1ydGwgLmZjLWJ1dHRvbi1ncm91cD4uZmMtYnV0dG9uOm5vdCg6bGFzdC1jaGlsZCl7Ym9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1czowO2JvcmRlci10b3AtbGVmdC1yYWRpdXM6MH0uZmMgLmZjLXRvb2xiYXJ7YWxpZ24taXRlbXM6Y2VudGVyO2Rpc3BsYXk6ZmxleDtqdXN0aWZ5LWNvbnRlbnQ6c3BhY2UtYmV0d2Vlbn0uZmMgLmZjLXRvb2xiYXIuZmMtaGVhZGVyLXRvb2xiYXJ7bWFyZ2luLWJvdHRvbToxLjVlbX0uZmMgLmZjLXRvb2xiYXIuZmMtZm9vdGVyLXRvb2xiYXJ7bWFyZ2luLXRvcDoxLjVlbX0uZmMgLmZjLXRvb2xiYXItdGl0bGV7Zm9udC1zaXplOjEuNzVlbTttYXJnaW46MH0uZmMtZGlyZWN0aW9uLWx0ciAuZmMtdG9vbGJhcj4qPjpub3QoOmZpcnN0LWNoaWxkKXttYXJnaW4tbGVmdDouNzVlbX0uZmMtZGlyZWN0aW9uLXJ0bCAuZmMtdG9vbGJhcj4qPjpub3QoOmZpcnN0LWNoaWxkKXttYXJnaW4tcmlnaHQ6Ljc1ZW19LmZjLWRpcmVjdGlvbi1ydGwgLmZjLXRvb2xiYXItbHRye2ZsZXgtZGlyZWN0aW9uOnJvdy1yZXZlcnNlfS5mYyAuZmMtc2Nyb2xsZXJ7LXdlYmtpdC1vdmVyZmxvdy1zY3JvbGxpbmc6dG91Y2g7cG9zaXRpb246cmVsYXRpdmV9LmZjIC5mYy1zY3JvbGxlci1saXF1aWR7aGVpZ2h0OjEwMCV9LmZjIC5mYy1zY3JvbGxlci1saXF1aWQtYWJzb2x1dGV7Ym90dG9tOjA7bGVmdDowO3Bvc2l0aW9uOmFic29sdXRlO3JpZ2h0OjA7dG9wOjB9LmZjIC5mYy1zY3JvbGxlci1oYXJuZXNze2RpcmVjdGlvbjpsdHI7b3ZlcmZsb3c6aGlkZGVuO3Bvc2l0aW9uOnJlbGF0aXZlfS5mYyAuZmMtc2Nyb2xsZXItaGFybmVzcy1saXF1aWR7aGVpZ2h0OjEwMCV9LmZjLWRpcmVjdGlvbi1ydGwgLmZjLXNjcm9sbGVyLWhhcm5lc3M+LmZjLXNjcm9sbGVye2RpcmVjdGlvbjpydGx9LmZjLXRoZW1lLXN0YW5kYXJkIC5mYy1zY3JvbGxncmlke2JvcmRlcjoxcHggc29saWQgdmFyKC0tZmMtYm9yZGVyLWNvbG9yKX0uZmMgLmZjLXNjcm9sbGdyaWQsLmZjIC5mYy1zY3JvbGxncmlkIHRhYmxle3RhYmxlLWxheW91dDpmaXhlZDt3aWR0aDoxMDAlfS5mYyAuZmMtc2Nyb2xsZ3JpZCB0YWJsZXtib3JkZXItbGVmdC1zdHlsZTpoaWRkZW47Ym9yZGVyLXJpZ2h0LXN0eWxlOmhpZGRlbjtib3JkZXItdG9wLXN0eWxlOmhpZGRlbn0uZmMgLmZjLXNjcm9sbGdyaWR7Ym9yZGVyLWJvdHRvbS13aWR0aDowO2JvcmRlci1jb2xsYXBzZTpzZXBhcmF0ZTtib3JkZXItcmlnaHQtd2lkdGg6MH0uZmMgLmZjLXNjcm9sbGdyaWQtbGlxdWlke2hlaWdodDoxMDAlfS5mYyAuZmMtc2Nyb2xsZ3JpZC1zZWN0aW9uLC5mYyAuZmMtc2Nyb2xsZ3JpZC1zZWN0aW9uIHRhYmxlLC5mYyAuZmMtc2Nyb2xsZ3JpZC1zZWN0aW9uPnRke2hlaWdodDoxcHh9LmZjIC5mYy1zY3JvbGxncmlkLXNlY3Rpb24tbGlxdWlkPnRke2hlaWdodDoxMDAlfS5mYyAuZmMtc2Nyb2xsZ3JpZC1zZWN0aW9uPip7Ym9yZGVyLWxlZnQtd2lkdGg6MDtib3JkZXItdG9wLXdpZHRoOjB9LmZjIC5mYy1zY3JvbGxncmlkLXNlY3Rpb24tZm9vdGVyPiosLmZjIC5mYy1zY3JvbGxncmlkLXNlY3Rpb24taGVhZGVyPip7Ym9yZGVyLWJvdHRvbS13aWR0aDowfS5mYyAuZmMtc2Nyb2xsZ3JpZC1zZWN0aW9uLWJvZHkgdGFibGUsLmZjIC5mYy1zY3JvbGxncmlkLXNlY3Rpb24tZm9vdGVyIHRhYmxle2JvcmRlci1ib3R0b20tc3R5bGU6aGlkZGVufS5mYyAuZmMtc2Nyb2xsZ3JpZC1zZWN0aW9uLXN0aWNreT4qe2JhY2tncm91bmQ6dmFyKC0tZmMtcGFnZS1iZy1jb2xvcik7cG9zaXRpb246c3RpY2t5O3otaW5kZXg6M30uZmMgLmZjLXNjcm9sbGdyaWQtc2VjdGlvbi1oZWFkZXIuZmMtc2Nyb2xsZ3JpZC1zZWN0aW9uLXN0aWNreT4qe3RvcDowfS5mYyAuZmMtc2Nyb2xsZ3JpZC1zZWN0aW9uLWZvb3Rlci5mYy1zY3JvbGxncmlkLXNlY3Rpb24tc3RpY2t5Pip7Ym90dG9tOjB9LmZjIC5mYy1zY3JvbGxncmlkLXN0aWNreS1zaGlte2hlaWdodDoxcHg7bWFyZ2luLWJvdHRvbTotMXB4fS5mYy1zdGlja3l7cG9zaXRpb246c3RpY2t5fS5mYyAuZmMtdmlldy1oYXJuZXNze2ZsZXgtZ3JvdzoxO3Bvc2l0aW9uOnJlbGF0aXZlfS5mYyAuZmMtdmlldy1oYXJuZXNzLWFjdGl2ZT4uZmMtdmlld3tib3R0b206MDtsZWZ0OjA7cG9zaXRpb246YWJzb2x1dGU7cmlnaHQ6MDt0b3A6MH0uZmMgLmZjLWNvbC1oZWFkZXItY2VsbC1jdXNoaW9ue2Rpc3BsYXk6aW5saW5lLWJsb2NrO3BhZGRpbmc6MnB4IDRweH0uZmMgLmZjLWJnLWV2ZW50LC5mYyAuZmMtaGlnaGxpZ2h0LC5mYyAuZmMtbm9uLWJ1c2luZXNze2JvdHRvbTowO2xlZnQ6MDtwb3NpdGlvbjphYnNvbHV0ZTtyaWdodDowO3RvcDowfS5mYyAuZmMtbm9uLWJ1c2luZXNze2JhY2tncm91bmQ6dmFyKC0tZmMtbm9uLWJ1c2luZXNzLWNvbG9yKX0uZmMgLmZjLWJnLWV2ZW50e2JhY2tncm91bmQ6dmFyKC0tZmMtYmctZXZlbnQtY29sb3IpO29wYWNpdHk6dmFyKC0tZmMtYmctZXZlbnQtb3BhY2l0eSl9LmZjIC5mYy1iZy1ldmVudCAuZmMtZXZlbnQtdGl0bGV7Zm9udC1zaXplOnZhcigtLWZjLXNtYWxsLWZvbnQtc2l6ZSk7Zm9udC1zdHlsZTppdGFsaWM7bWFyZ2luOi41ZW19LmZjIC5mYy1oaWdobGlnaHR7YmFja2dyb3VuZDp2YXIoLS1mYy1oaWdobGlnaHQtY29sb3IpfS5mYyAuZmMtY2VsbC1zaGFkZWQsLmZjIC5mYy1kYXktZGlzYWJsZWR7YmFja2dyb3VuZDp2YXIoLS1mYy1uZXV0cmFsLWJnLWNvbG9yKX1hLmZjLWV2ZW50LGEuZmMtZXZlbnQ6aG92ZXJ7dGV4dC1kZWNvcmF0aW9uOm5vbmV9LmZjLWV2ZW50LmZjLWV2ZW50LWRyYWdnYWJsZSwuZmMtZXZlbnRbaHJlZl17Y3Vyc29yOnBvaW50ZXJ9LmZjLWV2ZW50IC5mYy1ldmVudC1tYWlue3Bvc2l0aW9uOnJlbGF0aXZlO3otaW5kZXg6Mn0uZmMtZXZlbnQtZHJhZ2dpbmc6bm90KC5mYy1ldmVudC1zZWxlY3RlZCl7b3BhY2l0eTouNzV9LmZjLWV2ZW50LWRyYWdnaW5nLmZjLWV2ZW50LXNlbGVjdGVke2JveC1zaGFkb3c6MCAycHggN3B4IHJnYmEoMCwwLDAsLjMpfS5mYy1ldmVudCAuZmMtZXZlbnQtcmVzaXplcntkaXNwbGF5Om5vbmU7cG9zaXRpb246YWJzb2x1dGU7ei1pbmRleDo0fS5mYy1ldmVudC1zZWxlY3RlZCAuZmMtZXZlbnQtcmVzaXplciwuZmMtZXZlbnQ6aG92ZXIgLmZjLWV2ZW50LXJlc2l6ZXJ7ZGlzcGxheTpibG9ja30uZmMtZXZlbnQtc2VsZWN0ZWQgLmZjLWV2ZW50LXJlc2l6ZXJ7YmFja2dyb3VuZDp2YXIoLS1mYy1wYWdlLWJnLWNvbG9yKTtib3JkZXItY29sb3I6aW5oZXJpdDtib3JkZXItcmFkaXVzOmNhbGModmFyKC0tZmMtZXZlbnQtcmVzaXplci1kb3QtdG90YWwtd2lkdGgpLzIpO2JvcmRlci1zdHlsZTpzb2xpZDtib3JkZXItd2lkdGg6dmFyKC0tZmMtZXZlbnQtcmVzaXplci1kb3QtYm9yZGVyLXdpZHRoKTtoZWlnaHQ6dmFyKC0tZmMtZXZlbnQtcmVzaXplci1kb3QtdG90YWwtd2lkdGgpO3dpZHRoOnZhcigtLWZjLWV2ZW50LXJlc2l6ZXItZG90LXRvdGFsLXdpZHRoKX0uZmMtZXZlbnQtc2VsZWN0ZWQgLmZjLWV2ZW50LXJlc2l6ZXI6YmVmb3Jle2JvdHRvbTotMjBweDtjb250ZW50OlxcXCJcXFwiO2xlZnQ6LTIwcHg7cG9zaXRpb246YWJzb2x1dGU7cmlnaHQ6LTIwcHg7dG9wOi0yMHB4fS5mYy1ldmVudC1zZWxlY3RlZCwuZmMtZXZlbnQ6Zm9jdXN7Ym94LXNoYWRvdzowIDJweCA1cHggcmdiYSgwLDAsMCwuMil9LmZjLWV2ZW50LXNlbGVjdGVkOmJlZm9yZSwuZmMtZXZlbnQ6Zm9jdXM6YmVmb3Jle2JvdHRvbTowO2NvbnRlbnQ6XFxcIlxcXCI7bGVmdDowO3Bvc2l0aW9uOmFic29sdXRlO3JpZ2h0OjA7dG9wOjA7ei1pbmRleDozfS5mYy1ldmVudC1zZWxlY3RlZDphZnRlciwuZmMtZXZlbnQ6Zm9jdXM6YWZ0ZXJ7YmFja2dyb3VuZDp2YXIoLS1mYy1ldmVudC1zZWxlY3RlZC1vdmVybGF5LWNvbG9yKTtib3R0b206LTFweDtjb250ZW50OlxcXCJcXFwiO2xlZnQ6LTFweDtwb3NpdGlvbjphYnNvbHV0ZTtyaWdodDotMXB4O3RvcDotMXB4O3otaW5kZXg6MX0uZmMtaC1ldmVudHtiYWNrZ3JvdW5kLWNvbG9yOnZhcigtLWZjLWV2ZW50LWJnLWNvbG9yKTtib3JkZXI6MXB4IHNvbGlkIHZhcigtLWZjLWV2ZW50LWJvcmRlci1jb2xvcik7ZGlzcGxheTpibG9ja30uZmMtaC1ldmVudCAuZmMtZXZlbnQtbWFpbntjb2xvcjp2YXIoLS1mYy1ldmVudC10ZXh0LWNvbG9yKX0uZmMtaC1ldmVudCAuZmMtZXZlbnQtbWFpbi1mcmFtZXtkaXNwbGF5OmZsZXh9LmZjLWgtZXZlbnQgLmZjLWV2ZW50LXRpbWV7bWF4LXdpZHRoOjEwMCU7b3ZlcmZsb3c6aGlkZGVufS5mYy1oLWV2ZW50IC5mYy1ldmVudC10aXRsZS1jb250YWluZXJ7ZmxleC1ncm93OjE7ZmxleC1zaHJpbms6MTttaW4td2lkdGg6MH0uZmMtaC1ldmVudCAuZmMtZXZlbnQtdGl0bGV7ZGlzcGxheTppbmxpbmUtYmxvY2s7bGVmdDowO21heC13aWR0aDoxMDAlO292ZXJmbG93OmhpZGRlbjtyaWdodDowO3ZlcnRpY2FsLWFsaWduOnRvcH0uZmMtaC1ldmVudC5mYy1ldmVudC1zZWxlY3RlZDpiZWZvcmV7Ym90dG9tOi0xMHB4O3RvcDotMTBweH0uZmMtZGlyZWN0aW9uLWx0ciAuZmMtZGF5Z3JpZC1ibG9jay1ldmVudDpub3QoLmZjLWV2ZW50LXN0YXJ0KSwuZmMtZGlyZWN0aW9uLXJ0bCAuZmMtZGF5Z3JpZC1ibG9jay1ldmVudDpub3QoLmZjLWV2ZW50LWVuZCl7Ym9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1czowO2JvcmRlci1sZWZ0LXdpZHRoOjA7Ym9yZGVyLXRvcC1sZWZ0LXJhZGl1czowfS5mYy1kaXJlY3Rpb24tbHRyIC5mYy1kYXlncmlkLWJsb2NrLWV2ZW50Om5vdCguZmMtZXZlbnQtZW5kKSwuZmMtZGlyZWN0aW9uLXJ0bCAuZmMtZGF5Z3JpZC1ibG9jay1ldmVudDpub3QoLmZjLWV2ZW50LXN0YXJ0KXtib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1czowO2JvcmRlci1yaWdodC13aWR0aDowO2JvcmRlci10b3AtcmlnaHQtcmFkaXVzOjB9LmZjLWgtZXZlbnQ6bm90KC5mYy1ldmVudC1zZWxlY3RlZCkgLmZjLWV2ZW50LXJlc2l6ZXJ7Ym90dG9tOjA7dG9wOjA7d2lkdGg6dmFyKC0tZmMtZXZlbnQtcmVzaXplci10aGlja25lc3MpfS5mYy1kaXJlY3Rpb24tbHRyIC5mYy1oLWV2ZW50Om5vdCguZmMtZXZlbnQtc2VsZWN0ZWQpIC5mYy1ldmVudC1yZXNpemVyLXN0YXJ0LC5mYy1kaXJlY3Rpb24tcnRsIC5mYy1oLWV2ZW50Om5vdCguZmMtZXZlbnQtc2VsZWN0ZWQpIC5mYy1ldmVudC1yZXNpemVyLWVuZHtjdXJzb3I6dy1yZXNpemU7bGVmdDpjYWxjKHZhcigtLWZjLWV2ZW50LXJlc2l6ZXItdGhpY2tuZXNzKSotLjUpfS5mYy1kaXJlY3Rpb24tbHRyIC5mYy1oLWV2ZW50Om5vdCguZmMtZXZlbnQtc2VsZWN0ZWQpIC5mYy1ldmVudC1yZXNpemVyLWVuZCwuZmMtZGlyZWN0aW9uLXJ0bCAuZmMtaC1ldmVudDpub3QoLmZjLWV2ZW50LXNlbGVjdGVkKSAuZmMtZXZlbnQtcmVzaXplci1zdGFydHtjdXJzb3I6ZS1yZXNpemU7cmlnaHQ6Y2FsYyh2YXIoLS1mYy1ldmVudC1yZXNpemVyLXRoaWNrbmVzcykqLS41KX0uZmMtaC1ldmVudC5mYy1ldmVudC1zZWxlY3RlZCAuZmMtZXZlbnQtcmVzaXplcnttYXJnaW4tdG9wOmNhbGModmFyKC0tZmMtZXZlbnQtcmVzaXplci1kb3QtdG90YWwtd2lkdGgpKi0uNSk7dG9wOjUwJX0uZmMtZGlyZWN0aW9uLWx0ciAuZmMtaC1ldmVudC5mYy1ldmVudC1zZWxlY3RlZCAuZmMtZXZlbnQtcmVzaXplci1zdGFydCwuZmMtZGlyZWN0aW9uLXJ0bCAuZmMtaC1ldmVudC5mYy1ldmVudC1zZWxlY3RlZCAuZmMtZXZlbnQtcmVzaXplci1lbmR7bGVmdDpjYWxjKHZhcigtLWZjLWV2ZW50LXJlc2l6ZXItZG90LXRvdGFsLXdpZHRoKSotLjUpfS5mYy1kaXJlY3Rpb24tbHRyIC5mYy1oLWV2ZW50LmZjLWV2ZW50LXNlbGVjdGVkIC5mYy1ldmVudC1yZXNpemVyLWVuZCwuZmMtZGlyZWN0aW9uLXJ0bCAuZmMtaC1ldmVudC5mYy1ldmVudC1zZWxlY3RlZCAuZmMtZXZlbnQtcmVzaXplci1zdGFydHtyaWdodDpjYWxjKHZhcigtLWZjLWV2ZW50LXJlc2l6ZXItZG90LXRvdGFsLXdpZHRoKSotLjUpfS5mYyAuZmMtcG9wb3Zlcntib3gtc2hhZG93OjAgMnB4IDZweCByZ2JhKDAsMCwwLC4xNSk7cG9zaXRpb246YWJzb2x1dGU7ei1pbmRleDo5OTk5fS5mYyAuZmMtcG9wb3Zlci1oZWFkZXJ7YWxpZ24taXRlbXM6Y2VudGVyO2Rpc3BsYXk6ZmxleDtmbGV4LWRpcmVjdGlvbjpyb3c7anVzdGlmeS1jb250ZW50OnNwYWNlLWJldHdlZW47cGFkZGluZzozcHggNHB4fS5mYyAuZmMtcG9wb3Zlci10aXRsZXttYXJnaW46MCAycHh9LmZjIC5mYy1wb3BvdmVyLWNsb3Nle2N1cnNvcjpwb2ludGVyO2ZvbnQtc2l6ZToxLjFlbTtvcGFjaXR5Oi42NX0uZmMtdGhlbWUtc3RhbmRhcmQgLmZjLXBvcG92ZXJ7YmFja2dyb3VuZDp2YXIoLS1mYy1wYWdlLWJnLWNvbG9yKTtib3JkZXI6MXB4IHNvbGlkIHZhcigtLWZjLWJvcmRlci1jb2xvcil9LmZjLXRoZW1lLXN0YW5kYXJkIC5mYy1wb3BvdmVyLWhlYWRlcntiYWNrZ3JvdW5kOnZhcigtLWZjLW5ldXRyYWwtYmctY29sb3IpfVwiO1xyXG4gICAgaW5qZWN0U3R5bGVzKGNzc18yNDh6JDQpO1xyXG5cclxuICAgIGZ1bmN0aW9uIHJlbW92ZUVsZW1lbnQoZWwpIHtcclxuICAgICAgICBpZiAoZWwucGFyZW50Tm9kZSkge1xyXG4gICAgICAgICAgICBlbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBRdWVyeWluZ1xyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgZnVuY3Rpb24gZWxlbWVudENsb3Nlc3QoZWwsIHNlbGVjdG9yKSB7XHJcbiAgICAgICAgaWYgKGVsLmNsb3Nlc3QpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGVsLmNsb3Nlc3Qoc2VsZWN0b3IpO1xyXG4gICAgICAgICAgICAvLyByZWFsbHkgYmFkIGZhbGxiYWNrIGZvciBJRVxyXG4gICAgICAgICAgICAvLyBmcm9tIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FbGVtZW50L2Nsb3Nlc3RcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY29udGFpbnMoZWwpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgIGlmIChlbGVtZW50TWF0Y2hlcyhlbCwgc2VsZWN0b3IpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZWw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWwgPSAoZWwucGFyZW50RWxlbWVudCB8fCBlbC5wYXJlbnROb2RlKTtcclxuICAgICAgICB9IHdoaWxlIChlbCAhPT0gbnVsbCAmJiBlbC5ub2RlVHlwZSA9PT0gMSk7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBlbGVtZW50TWF0Y2hlcyhlbCwgc2VsZWN0b3IpIHtcclxuICAgICAgICBsZXQgbWV0aG9kID0gZWwubWF0Y2hlcyB8fCBlbC5tYXRjaGVzU2VsZWN0b3IgfHwgZWwubXNNYXRjaGVzU2VsZWN0b3I7XHJcbiAgICAgICAgcmV0dXJuIG1ldGhvZC5jYWxsKGVsLCBzZWxlY3Rvcik7XHJcbiAgICB9XHJcbiAgICAvLyBhY2NlcHRzIG11bHRpcGxlIHN1YmplY3QgZWxzXHJcbiAgICAvLyByZXR1cm5zIGEgcmVhbCBhcnJheS4gZ29vZCBmb3IgbWV0aG9kcyBsaWtlIGZvckVhY2hcclxuICAgIC8vIFRPRE86IGFjY2VwdCB0aGUgZG9jdW1lbnRcclxuICAgIGZ1bmN0aW9uIGZpbmRFbGVtZW50cyhjb250YWluZXIsIHNlbGVjdG9yKSB7XHJcbiAgICAgICAgbGV0IGNvbnRhaW5lcnMgPSBjb250YWluZXIgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCA/IFtjb250YWluZXJdIDogY29udGFpbmVyO1xyXG4gICAgICAgIGxldCBhbGxNYXRjaGVzID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb250YWluZXJzLmxlbmd0aDsgaSArPSAxKSB7XHJcbiAgICAgICAgICAgIGxldCBtYXRjaGVzID0gY29udGFpbmVyc1tpXS5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBtYXRjaGVzLmxlbmd0aDsgaiArPSAxKSB7XHJcbiAgICAgICAgICAgICAgICBhbGxNYXRjaGVzLnB1c2gobWF0Y2hlc1tqXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGFsbE1hdGNoZXM7XHJcbiAgICB9XHJcbiAgICAvLyBhY2NlcHRzIG11bHRpcGxlIHN1YmplY3QgZWxzXHJcbiAgICAvLyBvbmx5IHF1ZXJpZXMgZGlyZWN0IGNoaWxkIGVsZW1lbnRzIC8vIFRPRE86IHJlbmFtZSB0byBmaW5kRGlyZWN0Q2hpbGRyZW4hXHJcbiAgICBmdW5jdGlvbiBmaW5kRGlyZWN0Q2hpbGRyZW4ocGFyZW50LCBzZWxlY3Rvcikge1xyXG4gICAgICAgIGxldCBwYXJlbnRzID0gcGFyZW50IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgPyBbcGFyZW50XSA6IHBhcmVudDtcclxuICAgICAgICBsZXQgYWxsTWF0Y2hlcyA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFyZW50cy5sZW5ndGg7IGkgKz0gMSkge1xyXG4gICAgICAgICAgICBsZXQgY2hpbGROb2RlcyA9IHBhcmVudHNbaV0uY2hpbGRyZW47IC8vIG9ubHkgZXZlciBlbGVtZW50c1xyXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNoaWxkTm9kZXMubGVuZ3RoOyBqICs9IDEpIHtcclxuICAgICAgICAgICAgICAgIGxldCBjaGlsZE5vZGUgPSBjaGlsZE5vZGVzW2pdO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFzZWxlY3RvciB8fCBlbGVtZW50TWF0Y2hlcyhjaGlsZE5vZGUsIHNlbGVjdG9yKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGFsbE1hdGNoZXMucHVzaChjaGlsZE5vZGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhbGxNYXRjaGVzO1xyXG4gICAgfVxyXG4gICAgLy8gU3R5bGVcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIGNvbnN0IFBJWEVMX1BST1BfUkUgPSAvKHRvcHxsZWZ0fHJpZ2h0fGJvdHRvbXx3aWR0aHxoZWlnaHQpJC9pO1xyXG4gICAgZnVuY3Rpb24gYXBwbHlTdHlsZShlbCwgcHJvcHMpIHtcclxuICAgICAgICBmb3IgKGxldCBwcm9wTmFtZSBpbiBwcm9wcykge1xyXG4gICAgICAgICAgICBhcHBseVN0eWxlUHJvcChlbCwgcHJvcE5hbWUsIHByb3BzW3Byb3BOYW1lXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYXBwbHlTdHlsZVByb3AoZWwsIG5hbWUsIHZhbCkge1xyXG4gICAgICAgIGlmICh2YWwgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBlbC5zdHlsZVtuYW1lXSA9ICcnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJyAmJiBQSVhFTF9QUk9QX1JFLnRlc3QobmFtZSkpIHtcclxuICAgICAgICAgICAgZWwuc3R5bGVbbmFtZV0gPSBgJHt2YWx9cHhgO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZWwuc3R5bGVbbmFtZV0gPSB2YWw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gRXZlbnQgSGFuZGxpbmdcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIC8vIGlmIGludGVyY2VwdGluZyBidWJibGVkIGV2ZW50cyBhdCB0aGUgZG9jdW1lbnQvd2luZG93L2JvZHkgbGV2ZWwsXHJcbiAgICAvLyBhbmQgd2FudCB0byBzZWUgb3JpZ2luYXRpbmcgZWxlbWVudCAodGhlICd0YXJnZXQnKSwgdXNlIHRoaXMgdXRpbCBpbnN0ZWFkXHJcbiAgICAvLyBvZiBgZXYudGFyZ2V0YCBiZWNhdXNlIGl0IGdvZXMgd2l0aGluIHdlYi1jb21wb25lbnQgYm91bmRhcmllcy5cclxuICAgIGZ1bmN0aW9uIGdldEV2ZW50VGFyZ2V0VmlhUm9vdChldikge1xyXG4gICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgcmV0dXJuIChfYiA9IChfYSA9IGV2LmNvbXBvc2VkUGF0aCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwoZXYpWzBdKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBldi50YXJnZXQ7XHJcbiAgICB9XHJcbiAgICAvLyBVbmlxdWUgSUQgZm9yIERPTSBhdHRyaWJ1dGVcclxuICAgIGxldCBndWlkJDEgPSAwO1xyXG4gICAgZnVuY3Rpb24gZ2V0VW5pcXVlRG9tSWQoKSB7XHJcbiAgICAgICAgZ3VpZCQxICs9IDE7XHJcbiAgICAgICAgcmV0dXJuICdmYy1kb20tJyArIGd1aWQkMTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBTdG9wcyBhIG1vdXNlL3RvdWNoIGV2ZW50IGZyb20gZG9pbmcgaXQncyBuYXRpdmUgYnJvd3NlciBhY3Rpb25cclxuICAgIGZ1bmN0aW9uIHByZXZlbnREZWZhdWx0KGV2KSB7XHJcbiAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcclxuICAgIH1cclxuICAgIC8vIEV2ZW50IERlbGVnYXRpb25cclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIGZ1bmN0aW9uIGJ1aWxkRGVsZWdhdGlvbkhhbmRsZXIoc2VsZWN0b3IsIGhhbmRsZXIpIHtcclxuICAgICAgICByZXR1cm4gKGV2KSA9PiB7XHJcbiAgICAgICAgICAgIGxldCBtYXRjaGVkQ2hpbGQgPSBlbGVtZW50Q2xvc2VzdChldi50YXJnZXQsIHNlbGVjdG9yKTtcclxuICAgICAgICAgICAgaWYgKG1hdGNoZWRDaGlsZCkge1xyXG4gICAgICAgICAgICAgICAgaGFuZGxlci5jYWxsKG1hdGNoZWRDaGlsZCwgZXYsIG1hdGNoZWRDaGlsZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gbGlzdGVuQnlTZWxlY3Rvcihjb250YWluZXIsIGV2ZW50VHlwZSwgc2VsZWN0b3IsIGhhbmRsZXIpIHtcclxuICAgICAgICBsZXQgYXR0YWNoZWRIYW5kbGVyID0gYnVpbGREZWxlZ2F0aW9uSGFuZGxlcihzZWxlY3RvciwgaGFuZGxlcik7XHJcbiAgICAgICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBhdHRhY2hlZEhhbmRsZXIpO1xyXG4gICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgYXR0YWNoZWRIYW5kbGVyKTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gbGlzdGVuVG9Ib3ZlckJ5U2VsZWN0b3IoY29udGFpbmVyLCBzZWxlY3Rvciwgb25Nb3VzZUVudGVyLCBvbk1vdXNlTGVhdmUpIHtcclxuICAgICAgICBsZXQgY3VycmVudE1hdGNoZWRDaGlsZDtcclxuICAgICAgICByZXR1cm4gbGlzdGVuQnlTZWxlY3Rvcihjb250YWluZXIsICdtb3VzZW92ZXInLCBzZWxlY3RvciwgKG1vdXNlT3ZlckV2LCBtYXRjaGVkQ2hpbGQpID0+IHtcclxuICAgICAgICAgICAgaWYgKG1hdGNoZWRDaGlsZCAhPT0gY3VycmVudE1hdGNoZWRDaGlsZCkge1xyXG4gICAgICAgICAgICAgICAgY3VycmVudE1hdGNoZWRDaGlsZCA9IG1hdGNoZWRDaGlsZDtcclxuICAgICAgICAgICAgICAgIG9uTW91c2VFbnRlcihtb3VzZU92ZXJFdiwgbWF0Y2hlZENoaWxkKTtcclxuICAgICAgICAgICAgICAgIGxldCByZWFsT25Nb3VzZUxlYXZlID0gKG1vdXNlTGVhdmVFdikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRNYXRjaGVkQ2hpbGQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIG9uTW91c2VMZWF2ZShtb3VzZUxlYXZlRXYsIG1hdGNoZWRDaGlsZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZENoaWxkLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCByZWFsT25Nb3VzZUxlYXZlKTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAvLyBsaXN0ZW4gdG8gdGhlIG5leHQgbW91c2VsZWF2ZSwgYW5kIHRoZW4gdW5hdHRhY2hcclxuICAgICAgICAgICAgICAgIG1hdGNoZWRDaGlsZC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgcmVhbE9uTW91c2VMZWF2ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8vIEFuaW1hdGlvblxyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgY29uc3QgdHJhbnNpdGlvbkV2ZW50TmFtZXMgPSBbXHJcbiAgICAgICAgJ3dlYmtpdFRyYW5zaXRpb25FbmQnLFxyXG4gICAgICAgICdvdHJhbnNpdGlvbmVuZCcsXHJcbiAgICAgICAgJ29UcmFuc2l0aW9uRW5kJyxcclxuICAgICAgICAnbXNUcmFuc2l0aW9uRW5kJyxcclxuICAgICAgICAndHJhbnNpdGlvbmVuZCcsXHJcbiAgICBdO1xyXG4gICAgLy8gdHJpZ2dlcmVkIG9ubHkgd2hlbiB0aGUgbmV4dCBzaW5nbGUgc3Vic2VxdWVudCB0cmFuc2l0aW9uIGZpbmlzaGVzXHJcbiAgICBmdW5jdGlvbiB3aGVuVHJhbnNpdGlvbkRvbmUoZWwsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgbGV0IHJlYWxDYWxsYmFjayA9IChldikgPT4ge1xyXG4gICAgICAgICAgICBjYWxsYmFjayhldik7XHJcbiAgICAgICAgICAgIHRyYW5zaXRpb25FdmVudE5hbWVzLmZvckVhY2goKGV2ZW50TmFtZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIHJlYWxDYWxsYmFjayk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdHJhbnNpdGlvbkV2ZW50TmFtZXMuZm9yRWFjaCgoZXZlbnROYW1lKSA9PiB7XHJcbiAgICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCByZWFsQ2FsbGJhY2spOyAvLyBjcm9zcy1icm93c2VyIHdheSB0byBkZXRlcm1pbmUgd2hlbiB0aGUgdHJhbnNpdGlvbiBmaW5pc2hlc1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLy8gQVJJQSB3b3JrYXJvdW5kc1xyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgZnVuY3Rpb24gY3JlYXRlQXJpYUNsaWNrQXR0cnMoaGFuZGxlcikge1xyXG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHsgb25DbGljazogaGFuZGxlciB9LCBjcmVhdGVBcmlhS2V5Ym9hcmRBdHRycyhoYW5kbGVyKSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBjcmVhdGVBcmlhS2V5Ym9hcmRBdHRycyhoYW5kbGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdGFiSW5kZXg6IDAsXHJcbiAgICAgICAgICAgIG9uS2V5RG93bihldikge1xyXG4gICAgICAgICAgICAgICAgaWYgKGV2LmtleSA9PT0gJ0VudGVyJyB8fCBldi5rZXkgPT09ICcgJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZXIoZXYpO1xyXG4gICAgICAgICAgICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7IC8vIGlmIHNwYWNlLCBkb24ndCBzY3JvbGwgZG93biBwYWdlXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBsZXQgZ3VpZE51bWJlciA9IDA7XHJcbiAgICBmdW5jdGlvbiBndWlkKCkge1xyXG4gICAgICAgIGd1aWROdW1iZXIgKz0gMTtcclxuICAgICAgICByZXR1cm4gU3RyaW5nKGd1aWROdW1iZXIpO1xyXG4gICAgfVxyXG4gICAgLyogRnVsbENhbGVuZGFyLXNwZWNpZmljIERPTSBVdGlsaXRpZXNcclxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgLy8gTWFrZSB0aGUgbW91c2UgY3Vyc29yIGV4cHJlc3MgdGhhdCBhbiBldmVudCBpcyBub3QgYWxsb3dlZCBpbiB0aGUgY3VycmVudCBhcmVhXHJcbiAgICBmdW5jdGlvbiBkaXNhYmxlQ3Vyc29yKCkge1xyXG4gICAgICAgIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LmFkZCgnZmMtbm90LWFsbG93ZWQnKTtcclxuICAgIH1cclxuICAgIC8vIFJldHVybnMgdGhlIG1vdXNlIGN1cnNvciB0byBpdHMgb3JpZ2luYWwgbG9va1xyXG4gICAgZnVuY3Rpb24gZW5hYmxlQ3Vyc29yKCkge1xyXG4gICAgICAgIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LnJlbW92ZSgnZmMtbm90LWFsbG93ZWQnKTtcclxuICAgIH1cclxuICAgIC8qIFNlbGVjdGlvblxyXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbiAgICBmdW5jdGlvbiBwcmV2ZW50U2VsZWN0aW9uKGVsKSB7XHJcbiAgICAgICAgZWwuc3R5bGUudXNlclNlbGVjdCA9ICdub25lJztcclxuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdzZWxlY3RzdGFydCcsIHByZXZlbnREZWZhdWx0KTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGFsbG93U2VsZWN0aW9uKGVsKSB7XHJcbiAgICAgICAgZWwuc3R5bGUudXNlclNlbGVjdCA9ICcnO1xyXG4gICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3NlbGVjdHN0YXJ0JywgcHJldmVudERlZmF1bHQpO1xyXG4gICAgfVxyXG4gICAgLyogQ29udGV4dCBNZW51XHJcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgIGZ1bmN0aW9uIHByZXZlbnRDb250ZXh0TWVudShlbCkge1xyXG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NvbnRleHRtZW51JywgcHJldmVudERlZmF1bHQpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYWxsb3dDb250ZXh0TWVudShlbCkge1xyXG4gICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NvbnRleHRtZW51JywgcHJldmVudERlZmF1bHQpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gcGFyc2VGaWVsZFNwZWNzKGlucHV0KSB7XHJcbiAgICAgICAgbGV0IHNwZWNzID0gW107XHJcbiAgICAgICAgbGV0IHRva2VucyA9IFtdO1xyXG4gICAgICAgIGxldCBpO1xyXG4gICAgICAgIGxldCB0b2tlbjtcclxuICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICB0b2tlbnMgPSBpbnB1dC5zcGxpdCgvXFxzKixcXHMqLyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICB0b2tlbnMgPSBbaW5wdXRdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGlucHV0KSkge1xyXG4gICAgICAgICAgICB0b2tlbnMgPSBpbnB1dDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkgKz0gMSkge1xyXG4gICAgICAgICAgICB0b2tlbiA9IHRva2Vuc1tpXTtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB0b2tlbiA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgIHNwZWNzLnB1c2godG9rZW4uY2hhckF0KDApID09PSAnLScgP1xyXG4gICAgICAgICAgICAgICAgICAgIHsgZmllbGQ6IHRva2VuLnN1YnN0cmluZygxKSwgb3JkZXI6IC0xIH0gOlxyXG4gICAgICAgICAgICAgICAgICAgIHsgZmllbGQ6IHRva2VuLCBvcmRlcjogMSB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdG9rZW4gPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICAgIHNwZWNzLnB1c2goeyBmdW5jOiB0b2tlbiB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc3BlY3M7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBjb21wYXJlQnlGaWVsZFNwZWNzKG9iajAsIG9iajEsIGZpZWxkU3BlY3MpIHtcclxuICAgICAgICBsZXQgaTtcclxuICAgICAgICBsZXQgY21wO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBmaWVsZFNwZWNzLmxlbmd0aDsgaSArPSAxKSB7XHJcbiAgICAgICAgICAgIGNtcCA9IGNvbXBhcmVCeUZpZWxkU3BlYyhvYmowLCBvYmoxLCBmaWVsZFNwZWNzW2ldKTtcclxuICAgICAgICAgICAgaWYgKGNtcCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNtcDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gMDtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGNvbXBhcmVCeUZpZWxkU3BlYyhvYmowLCBvYmoxLCBmaWVsZFNwZWMpIHtcclxuICAgICAgICBpZiAoZmllbGRTcGVjLmZ1bmMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZpZWxkU3BlYy5mdW5jKG9iajAsIG9iajEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmxleGlibGVDb21wYXJlKG9iajBbZmllbGRTcGVjLmZpZWxkXSwgb2JqMVtmaWVsZFNwZWMuZmllbGRdKVxyXG4gICAgICAgICAgICAqIChmaWVsZFNwZWMub3JkZXIgfHwgMSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBmbGV4aWJsZUNvbXBhcmUoYSwgYikge1xyXG4gICAgICAgIGlmICghYSAmJiAhYikge1xyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGIgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChhID09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlb2YgYSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGIgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBTdHJpbmcoYSkubG9jYWxlQ29tcGFyZShTdHJpbmcoYikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYSAtIGI7XHJcbiAgICB9XHJcbiAgICAvKiBTdHJpbmcgVXRpbGl0aWVzXHJcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgIGZ1bmN0aW9uIHBhZFN0YXJ0KHZhbCwgbGVuKSB7XHJcbiAgICAgICAgbGV0IHMgPSBTdHJpbmcodmFsKTtcclxuICAgICAgICByZXR1cm4gJzAwMCcuc3Vic3RyKDAsIGxlbiAtIHMubGVuZ3RoKSArIHM7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBmb3JtYXRXaXRoT3JkaW5hbHMoZm9ybWF0dGVyLCBhcmdzLCBmYWxsYmFja1RleHQpIHtcclxuICAgICAgICBpZiAodHlwZW9mIGZvcm1hdHRlciA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0dGVyKC4uLmFyZ3MpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mIGZvcm1hdHRlciA9PT0gJ3N0cmluZycpIHsgLy8gbm9uLWJsYW5rIHN0cmluZ1xyXG4gICAgICAgICAgICByZXR1cm4gYXJncy5yZWR1Y2UoKHN0ciwgYXJnLCBpbmRleCkgPT4gKHN0ci5yZXBsYWNlKCckJyArIGluZGV4LCBhcmcgfHwgJycpKSwgZm9ybWF0dGVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbGxiYWNrVGV4dDtcclxuICAgIH1cclxuICAgIC8qIE51bWJlciBVdGlsaXRpZXNcclxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgZnVuY3Rpb24gY29tcGFyZU51bWJlcnMoYSwgYikge1xyXG4gICAgICAgIHJldHVybiBhIC0gYjtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGlzSW50KG4pIHtcclxuICAgICAgICByZXR1cm4gbiAlIDEgPT09IDA7XHJcbiAgICB9XHJcbiAgICAvKiBGQy1zcGVjaWZpYyBET00gZGltZW5zaW9uIHN0dWZmXHJcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgIGZ1bmN0aW9uIGNvbXB1dGVTbWFsbGVzdENlbGxXaWR0aChjZWxsRWwpIHtcclxuICAgICAgICBsZXQgYWxsV2lkdGhFbCA9IGNlbGxFbC5xdWVyeVNlbGVjdG9yKCcuZmMtc2Nyb2xsZ3JpZC1zaHJpbmstZnJhbWUnKTtcclxuICAgICAgICBsZXQgY29udGVudFdpZHRoRWwgPSBjZWxsRWwucXVlcnlTZWxlY3RvcignLmZjLXNjcm9sbGdyaWQtc2hyaW5rLWN1c2hpb24nKTtcclxuICAgICAgICBpZiAoIWFsbFdpZHRoRWwpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCduZWVkcyBmYy1zY3JvbGxncmlkLXNocmluay1mcmFtZSBjbGFzc05hbWUnKTsgLy8gVE9ETzogdXNlIGNvbnN0XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghY29udGVudFdpZHRoRWwpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCduZWVkcyBmYy1zY3JvbGxncmlkLXNocmluay1jdXNoaW9uIGNsYXNzTmFtZScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY2VsbEVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoIC0gYWxsV2lkdGhFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCArIC8vIHRoZSBjZWxsIHBhZGRpbmcrYm9yZGVyXHJcbiAgICAgICAgICAgIGNvbnRlbnRXaWR0aEVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IElOVEVSTkFMX1VOSVRTID0gWyd5ZWFycycsICdtb250aHMnLCAnZGF5cycsICdtaWxsaXNlY29uZHMnXTtcclxuICAgIGNvbnN0IFBBUlNFX1JFID0gL14oLT8pKD86KFxcZCspXFwuKT8oXFxkKyk6KFxcZFxcZCkoPzo6KFxcZFxcZCkoPzpcXC4oXFxkXFxkXFxkKSk/KT8vO1xyXG4gICAgLy8gUGFyc2luZyBhbmQgQ3JlYXRpb25cclxuICAgIGZ1bmN0aW9uIGNyZWF0ZUR1cmF0aW9uKGlucHV0LCB1bml0KSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlU3RyaW5nKGlucHV0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ29iamVjdCcgJiYgaW5wdXQpIHsgLy8gbm9uLW51bGwgb2JqZWN0XHJcbiAgICAgICAgICAgIHJldHVybiBwYXJzZU9iamVjdChpbnB1dCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBwYXJzZU9iamVjdCh7IFt1bml0IHx8ICdtaWxsaXNlY29uZHMnXTogaW5wdXQgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gcGFyc2VTdHJpbmcocykge1xyXG4gICAgICAgIGxldCBtID0gUEFSU0VfUkUuZXhlYyhzKTtcclxuICAgICAgICBpZiAobSkge1xyXG4gICAgICAgICAgICBsZXQgc2lnbiA9IG1bMV0gPyAtMSA6IDE7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICB5ZWFyczogMCxcclxuICAgICAgICAgICAgICAgIG1vbnRoczogMCxcclxuICAgICAgICAgICAgICAgIGRheXM6IHNpZ24gKiAobVsyXSA/IHBhcnNlSW50KG1bMl0sIDEwKSA6IDApLFxyXG4gICAgICAgICAgICAgICAgbWlsbGlzZWNvbmRzOiBzaWduICogKChtWzNdID8gcGFyc2VJbnQobVszXSwgMTApIDogMCkgKiA2MCAqIDYwICogMTAwMCArIC8vIGhvdXJzXHJcbiAgICAgICAgICAgICAgICAgICAgKG1bNF0gPyBwYXJzZUludChtWzRdLCAxMCkgOiAwKSAqIDYwICogMTAwMCArIC8vIG1pbnV0ZXNcclxuICAgICAgICAgICAgICAgICAgICAobVs1XSA/IHBhcnNlSW50KG1bNV0sIDEwKSA6IDApICogMTAwMCArIC8vIHNlY29uZHNcclxuICAgICAgICAgICAgICAgICAgICAobVs2XSA/IHBhcnNlSW50KG1bNl0sIDEwKSA6IDApIC8vIG1zXHJcbiAgICAgICAgICAgICAgICApLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHBhcnNlT2JqZWN0KG9iaikge1xyXG4gICAgICAgIGxldCBkdXJhdGlvbiA9IHtcclxuICAgICAgICAgICAgeWVhcnM6IG9iai55ZWFycyB8fCBvYmoueWVhciB8fCAwLFxyXG4gICAgICAgICAgICBtb250aHM6IG9iai5tb250aHMgfHwgb2JqLm1vbnRoIHx8IDAsXHJcbiAgICAgICAgICAgIGRheXM6IG9iai5kYXlzIHx8IG9iai5kYXkgfHwgMCxcclxuICAgICAgICAgICAgbWlsbGlzZWNvbmRzOiAob2JqLmhvdXJzIHx8IG9iai5ob3VyIHx8IDApICogNjAgKiA2MCAqIDEwMDAgKyAvLyBob3Vyc1xyXG4gICAgICAgICAgICAgICAgKG9iai5taW51dGVzIHx8IG9iai5taW51dGUgfHwgMCkgKiA2MCAqIDEwMDAgKyAvLyBtaW51dGVzXHJcbiAgICAgICAgICAgICAgICAob2JqLnNlY29uZHMgfHwgb2JqLnNlY29uZCB8fCAwKSAqIDEwMDAgKyAvLyBzZWNvbmRzXHJcbiAgICAgICAgICAgICAgICAob2JqLm1pbGxpc2Vjb25kcyB8fCBvYmoubWlsbGlzZWNvbmQgfHwgb2JqLm1zIHx8IDApLCAvLyBtc1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgbGV0IHdlZWtzID0gb2JqLndlZWtzIHx8IG9iai53ZWVrO1xyXG4gICAgICAgIGlmICh3ZWVrcykge1xyXG4gICAgICAgICAgICBkdXJhdGlvbi5kYXlzICs9IHdlZWtzICogNztcclxuICAgICAgICAgICAgZHVyYXRpb24uc3BlY2lmaWVkV2Vla3MgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZHVyYXRpb247XHJcbiAgICB9XHJcbiAgICAvLyBFcXVhbGl0eVxyXG4gICAgZnVuY3Rpb24gZHVyYXRpb25zRXF1YWwoZDAsIGQxKSB7XHJcbiAgICAgICAgcmV0dXJuIGQwLnllYXJzID09PSBkMS55ZWFycyAmJlxyXG4gICAgICAgICAgICBkMC5tb250aHMgPT09IGQxLm1vbnRocyAmJlxyXG4gICAgICAgICAgICBkMC5kYXlzID09PSBkMS5kYXlzICYmXHJcbiAgICAgICAgICAgIGQwLm1pbGxpc2Vjb25kcyA9PT0gZDEubWlsbGlzZWNvbmRzO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYXNDbGVhbkRheXMoZHVyKSB7XHJcbiAgICAgICAgaWYgKCFkdXIueWVhcnMgJiYgIWR1ci5tb250aHMgJiYgIWR1ci5taWxsaXNlY29uZHMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGR1ci5kYXlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gMDtcclxuICAgIH1cclxuICAgIC8vIFNpbXBsZSBNYXRoXHJcbiAgICBmdW5jdGlvbiBhZGREdXJhdGlvbnMoZDAsIGQxKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgeWVhcnM6IGQwLnllYXJzICsgZDEueWVhcnMsXHJcbiAgICAgICAgICAgIG1vbnRoczogZDAubW9udGhzICsgZDEubW9udGhzLFxyXG4gICAgICAgICAgICBkYXlzOiBkMC5kYXlzICsgZDEuZGF5cyxcclxuICAgICAgICAgICAgbWlsbGlzZWNvbmRzOiBkMC5taWxsaXNlY29uZHMgKyBkMS5taWxsaXNlY29uZHMsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHN1YnRyYWN0RHVyYXRpb25zKGQxLCBkMCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHllYXJzOiBkMS55ZWFycyAtIGQwLnllYXJzLFxyXG4gICAgICAgICAgICBtb250aHM6IGQxLm1vbnRocyAtIGQwLm1vbnRocyxcclxuICAgICAgICAgICAgZGF5czogZDEuZGF5cyAtIGQwLmRheXMsXHJcbiAgICAgICAgICAgIG1pbGxpc2Vjb25kczogZDEubWlsbGlzZWNvbmRzIC0gZDAubWlsbGlzZWNvbmRzLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBtdWx0aXBseUR1cmF0aW9uKGQsIG4pIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB5ZWFyczogZC55ZWFycyAqIG4sXHJcbiAgICAgICAgICAgIG1vbnRoczogZC5tb250aHMgKiBuLFxyXG4gICAgICAgICAgICBkYXlzOiBkLmRheXMgKiBuLFxyXG4gICAgICAgICAgICBtaWxsaXNlY29uZHM6IGQubWlsbGlzZWNvbmRzICogbixcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgLy8gQ29udmVyc2lvbnNcclxuICAgIC8vIFwiUm91Z2hcIiBiZWNhdXNlIHRoZXkgYXJlIGJhc2VkIG9uIGF2ZXJhZ2UtY2FzZSBHcmVnb3JpYW4gbW9udGhzL3llYXJzXHJcbiAgICBmdW5jdGlvbiBhc1JvdWdoWWVhcnMoZHVyKSB7XHJcbiAgICAgICAgcmV0dXJuIGFzUm91Z2hEYXlzKGR1cikgLyAzNjU7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBhc1JvdWdoTW9udGhzKGR1cikge1xyXG4gICAgICAgIHJldHVybiBhc1JvdWdoRGF5cyhkdXIpIC8gMzA7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBhc1JvdWdoRGF5cyhkdXIpIHtcclxuICAgICAgICByZXR1cm4gYXNSb3VnaE1zKGR1cikgLyA4NjRlNTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGFzUm91Z2hNaW51dGVzKGR1cikge1xyXG4gICAgICAgIHJldHVybiBhc1JvdWdoTXMoZHVyKSAvICgxMDAwICogNjApO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYXNSb3VnaFNlY29uZHMoZHVyKSB7XHJcbiAgICAgICAgcmV0dXJuIGFzUm91Z2hNcyhkdXIpIC8gMTAwMDtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGFzUm91Z2hNcyhkdXIpIHtcclxuICAgICAgICByZXR1cm4gZHVyLnllYXJzICogKDM2NSAqIDg2NGU1KSArXHJcbiAgICAgICAgICAgIGR1ci5tb250aHMgKiAoMzAgKiA4NjRlNSkgK1xyXG4gICAgICAgICAgICBkdXIuZGF5cyAqIDg2NGU1ICtcclxuICAgICAgICAgICAgZHVyLm1pbGxpc2Vjb25kcztcclxuICAgIH1cclxuICAgIC8vIEFkdmFuY2VkIE1hdGhcclxuICAgIGZ1bmN0aW9uIHdob2xlRGl2aWRlRHVyYXRpb25zKG51bWVyYXRvciwgZGVub21pbmF0b3IpIHtcclxuICAgICAgICBsZXQgcmVzID0gbnVsbDtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IElOVEVSTkFMX1VOSVRTLmxlbmd0aDsgaSArPSAxKSB7XHJcbiAgICAgICAgICAgIGxldCB1bml0ID0gSU5URVJOQUxfVU5JVFNbaV07XHJcbiAgICAgICAgICAgIGlmIChkZW5vbWluYXRvclt1bml0XSkge1xyXG4gICAgICAgICAgICAgICAgbGV0IGxvY2FsUmVzID0gbnVtZXJhdG9yW3VuaXRdIC8gZGVub21pbmF0b3JbdW5pdF07XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzSW50KGxvY2FsUmVzKSB8fCAocmVzICE9PSBudWxsICYmIHJlcyAhPT0gbG9jYWxSZXMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXMgPSBsb2NhbFJlcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChudW1lcmF0b3JbdW5pdF0pIHtcclxuICAgICAgICAgICAgICAgIC8vIG5lZWRzIHRvIGRpdmlkZSBieSBzb21ldGhpbmcgYnV0IGNhbid0IVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGdyZWF0ZXN0RHVyYXRpb25EZW5vbWluYXRvcihkdXIpIHtcclxuICAgICAgICBsZXQgbXMgPSBkdXIubWlsbGlzZWNvbmRzO1xyXG4gICAgICAgIGlmIChtcykge1xyXG4gICAgICAgICAgICBpZiAobXMgJSAxMDAwICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4geyB1bml0OiAnbWlsbGlzZWNvbmQnLCB2YWx1ZTogbXMgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobXMgJSAoMTAwMCAqIDYwKSAhPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdW5pdDogJ3NlY29uZCcsIHZhbHVlOiBtcyAvIDEwMDAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobXMgJSAoMTAwMCAqIDYwICogNjApICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4geyB1bml0OiAnbWludXRlJywgdmFsdWU6IG1zIC8gKDEwMDAgKiA2MCkgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobXMpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7IHVuaXQ6ICdob3VyJywgdmFsdWU6IG1zIC8gKDEwMDAgKiA2MCAqIDYwKSB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChkdXIuZGF5cykge1xyXG4gICAgICAgICAgICBpZiAoZHVyLnNwZWNpZmllZFdlZWtzICYmIGR1ci5kYXlzICUgNyA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdW5pdDogJ3dlZWsnLCB2YWx1ZTogZHVyLmRheXMgLyA3IH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHsgdW5pdDogJ2RheScsIHZhbHVlOiBkdXIuZGF5cyB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZHVyLm1vbnRocykge1xyXG4gICAgICAgICAgICByZXR1cm4geyB1bml0OiAnbW9udGgnLCB2YWx1ZTogZHVyLm1vbnRocyB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZHVyLnllYXJzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7IHVuaXQ6ICd5ZWFyJywgdmFsdWU6IGR1ci55ZWFycyB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4geyB1bml0OiAnbWlsbGlzZWNvbmQnLCB2YWx1ZTogMCB9O1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHsgaGFzT3duUHJvcGVydHkgfSA9IE9iamVjdC5wcm90b3R5cGU7XHJcbiAgICAvLyBNZXJnZXMgYW4gYXJyYXkgb2Ygb2JqZWN0cyBpbnRvIGEgc2luZ2xlIG9iamVjdC5cclxuICAgIC8vIFRoZSBzZWNvbmQgYXJndW1lbnQgYWxsb3dzIGZvciBhbiBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyB3aG8ncyBvYmplY3QgdmFsdWVzIHdpbGwgYmUgbWVyZ2VkIHRvZ2V0aGVyLlxyXG4gICAgZnVuY3Rpb24gbWVyZ2VQcm9wcyhwcm9wT2JqcywgY29tcGxleFByb3BzTWFwKSB7XHJcbiAgICAgICAgbGV0IGRlc3QgPSB7fTtcclxuICAgICAgICBpZiAoY29tcGxleFByb3BzTWFwKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IG5hbWUgaW4gY29tcGxleFByb3BzTWFwKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY29tcGxleFByb3BzTWFwW25hbWVdID09PSBpc01heWJlT2JqZWN0c0VxdWFsKSB7IC8vIGltcGxpZXMgdGhhdCBpdCdzIG9iamVjdC1tZXJnZWFibGVcclxuICAgICAgICAgICAgICAgICAgICBsZXQgY29tcGxleE9ianMgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBjb2xsZWN0IHRoZSB0cmFpbGluZyBvYmplY3QgdmFsdWVzLCBzdG9wcGluZyB3aGVuIGEgbm9uLW9iamVjdCBpcyBkaXNjb3ZlcmVkXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IHByb3BPYmpzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaSAtPSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB2YWwgPSBwcm9wT2Jqc1tpXVtuYW1lXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdvYmplY3QnICYmIHZhbCkgeyAvLyBub24tbnVsbCBvYmplY3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBsZXhPYmpzLnVuc2hpZnQodmFsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh2YWwgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVzdFtuYW1lXSA9IHZhbDsgLy8gaWYgdGhlcmUgd2VyZSBubyBvYmplY3RzLCB0aGlzIHZhbHVlIHdpbGwgYmUgdXNlZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIHRyYWlsaW5nIHZhbHVlcyB3ZXJlIG9iamVjdHMsIHVzZSB0aGUgbWVyZ2VkIHZhbHVlXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXBsZXhPYmpzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXN0W25hbWVdID0gbWVyZ2VQcm9wcyhjb21wbGV4T2Jqcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGNvcHkgdmFsdWVzIGludG8gdGhlIGRlc3RpbmF0aW9uLCBnb2luZyBmcm9tIGxhc3QgdG8gZmlyc3RcclxuICAgICAgICBmb3IgKGxldCBpID0gcHJvcE9ianMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpIC09IDEpIHtcclxuICAgICAgICAgICAgbGV0IHByb3BzID0gcHJvcE9ianNbaV07XHJcbiAgICAgICAgICAgIGZvciAobGV0IG5hbWUgaW4gcHJvcHMpIHtcclxuICAgICAgICAgICAgICAgIGlmICghKG5hbWUgaW4gZGVzdCkpIHsgLy8gaWYgYWxyZWFkeSBhc3NpZ25lZCBieSBwcmV2aW91cyBwcm9wcyBvciBjb21wbGV4IHByb3BzLCBkb24ndCByZWFzc2lnblxyXG4gICAgICAgICAgICAgICAgICAgIGRlc3RbbmFtZV0gPSBwcm9wc1tuYW1lXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZGVzdDtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGZpbHRlckhhc2goaGFzaCwgZnVuYykge1xyXG4gICAgICAgIGxldCBmaWx0ZXJlZCA9IHt9O1xyXG4gICAgICAgIGZvciAobGV0IGtleSBpbiBoYXNoKSB7XHJcbiAgICAgICAgICAgIGlmIChmdW5jKGhhc2hba2V5XSwga2V5KSkge1xyXG4gICAgICAgICAgICAgICAgZmlsdGVyZWRba2V5XSA9IGhhc2hba2V5XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmlsdGVyZWQ7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBtYXBIYXNoKGhhc2gsIGZ1bmMpIHtcclxuICAgICAgICBsZXQgbmV3SGFzaCA9IHt9O1xyXG4gICAgICAgIGZvciAobGV0IGtleSBpbiBoYXNoKSB7XHJcbiAgICAgICAgICAgIG5ld0hhc2hba2V5XSA9IGZ1bmMoaGFzaFtrZXldLCBrZXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3SGFzaDtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGFycmF5VG9IYXNoKGEpIHtcclxuICAgICAgICBsZXQgaGFzaCA9IHt9O1xyXG4gICAgICAgIGZvciAobGV0IGl0ZW0gb2YgYSkge1xyXG4gICAgICAgICAgICBoYXNoW2l0ZW1dID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGhhc2g7XHJcbiAgICB9XHJcbiAgICAvLyBUT0RPOiByZWFzc2VzcyBicm93c2VyIHN1cHBvcnRcclxuICAgIC8vIGh0dHBzOi8vY2FuaXVzZS5jb20vP3NlYXJjaD1vYmplY3QudmFsdWVzXHJcbiAgICBmdW5jdGlvbiBoYXNoVmFsdWVzVG9BcnJheShvYmopIHtcclxuICAgICAgICBsZXQgYSA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IGtleSBpbiBvYmopIHtcclxuICAgICAgICAgICAgYS5wdXNoKG9ialtrZXldKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGE7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBpc1Byb3BzRXF1YWwob2JqMCwgb2JqMSkge1xyXG4gICAgICAgIGlmIChvYmowID09PSBvYmoxKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGxldCBrZXkgaW4gb2JqMCkge1xyXG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmowLCBrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIShrZXkgaW4gb2JqMSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChsZXQga2V5IGluIG9iajEpIHtcclxuICAgICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqMSwga2V5KSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG9iajBba2V5XSAhPT0gb2JqMVtrZXldKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgY29uc3QgSEFORExFUl9SRSA9IC9eb25bQS1aXS87XHJcbiAgICBmdW5jdGlvbiBpc05vbkhhbmRsZXJQcm9wc0VxdWFsKG9iajAsIG9iajEpIHtcclxuICAgICAgICBjb25zdCBrZXlzID0gZ2V0VW5lcXVhbFByb3BzKG9iajAsIG9iajEpO1xyXG4gICAgICAgIGZvciAobGV0IGtleSBvZiBrZXlzKSB7XHJcbiAgICAgICAgICAgIGlmICghSEFORExFUl9SRS50ZXN0KGtleSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGdldFVuZXF1YWxQcm9wcyhvYmowLCBvYmoxKSB7XHJcbiAgICAgICAgbGV0IGtleXMgPSBbXTtcclxuICAgICAgICBmb3IgKGxldCBrZXkgaW4gb2JqMCkge1xyXG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmowLCBrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIShrZXkgaW4gb2JqMSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBrZXlzLnB1c2goa2V5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGxldCBrZXkgaW4gb2JqMSkge1xyXG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmoxLCBrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAob2JqMFtrZXldICE9PSBvYmoxW2tleV0pIHtcclxuICAgICAgICAgICAgICAgICAgICBrZXlzLnB1c2goa2V5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4ga2V5cztcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGNvbXBhcmVPYmpzKG9sZFByb3BzLCBuZXdQcm9wcywgZXF1YWxpdHlGdW5jcyA9IHt9KSB7XHJcbiAgICAgICAgaWYgKG9sZFByb3BzID09PSBuZXdQcm9wcykge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChsZXQga2V5IGluIG5ld1Byb3BzKSB7XHJcbiAgICAgICAgICAgIGlmIChrZXkgaW4gb2xkUHJvcHMgJiYgaXNPYmpWYWxzRXF1YWwob2xkUHJvcHNba2V5XSwgbmV3UHJvcHNba2V5XSwgZXF1YWxpdHlGdW5jc1trZXldKSkgO1xyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBjaGVjayBmb3IgcHJvcHMgdGhhdCB3ZXJlIG9taXR0ZWQgaW4gdGhlIG5ld1xyXG4gICAgICAgIGZvciAobGV0IGtleSBpbiBvbGRQcm9wcykge1xyXG4gICAgICAgICAgICBpZiAoIShrZXkgaW4gbmV3UHJvcHMpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICAvKlxyXG4gICAgYXNzdW1lZCBcInRydWVcIiBlcXVhbGl0eSBmb3IgaGFuZGxlciBuYW1lcyBsaWtlIFwib25SZWNlaXZlU29tZXRoaW5nXCJcclxuICAgICovXHJcbiAgICBmdW5jdGlvbiBpc09ialZhbHNFcXVhbCh2YWwwLCB2YWwxLCBjb21wYXJhdG9yKSB7XHJcbiAgICAgICAgaWYgKHZhbDAgPT09IHZhbDEgfHwgY29tcGFyYXRvciA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNvbXBhcmF0b3IpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmF0b3IodmFsMCwgdmFsMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGNvbGxlY3RGcm9tSGFzaChoYXNoLCBzdGFydEluZGV4ID0gMCwgZW5kSW5kZXgsIHN0ZXAgPSAxKSB7XHJcbiAgICAgICAgbGV0IHJlcyA9IFtdO1xyXG4gICAgICAgIGlmIChlbmRJbmRleCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGVuZEluZGV4ID0gT2JqZWN0LmtleXMoaGFzaCkubGVuZ3RoO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGxldCBpID0gc3RhcnRJbmRleDsgaSA8IGVuZEluZGV4OyBpICs9IHN0ZXApIHtcclxuICAgICAgICAgICAgbGV0IHZhbCA9IGhhc2hbaV07XHJcbiAgICAgICAgICAgIGlmICh2YWwgIT09IHVuZGVmaW5lZCkgeyAvLyB3aWxsIGRpc3JlZ2FyZCB1bmRlZmluZWQgZm9yIHNwYXJzZSBhcnJheXNcclxuICAgICAgICAgICAgICAgIHJlcy5wdXNoKHZhbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgIH1cclxuXHJcbiAgICAvLyBUT0RPOiBuZXcgdXRpbCBhcnJheWlmeT9cclxuICAgIGZ1bmN0aW9uIHJlbW92ZUV4YWN0KGFycmF5LCBleGFjdFZhbCkge1xyXG4gICAgICAgIGxldCByZW1vdmVDbnQgPSAwO1xyXG4gICAgICAgIGxldCBpID0gMDtcclxuICAgICAgICB3aGlsZSAoaSA8IGFycmF5Lmxlbmd0aCkge1xyXG4gICAgICAgICAgICBpZiAoYXJyYXlbaV0gPT09IGV4YWN0VmFsKSB7XHJcbiAgICAgICAgICAgICAgICBhcnJheS5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgICAgICAgICByZW1vdmVDbnQgKz0gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGkgKz0gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVtb3ZlQ250O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gaXNBcnJheXNFcXVhbChhMCwgYTEsIGVxdWFsaXR5RnVuYykge1xyXG4gICAgICAgIGlmIChhMCA9PT0gYTEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBsZW4gPSBhMC5sZW5ndGg7XHJcbiAgICAgICAgbGV0IGk7XHJcbiAgICAgICAgaWYgKGxlbiAhPT0gYTEubGVuZ3RoKSB7IC8vIG5vdCBhcnJheT8gb3Igbm90IHNhbWUgbGVuZ3RoP1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgICAgICAgICBpZiAoIShlcXVhbGl0eUZ1bmMgPyBlcXVhbGl0eUZ1bmMoYTBbaV0sIGExW2ldKSA6IGEwW2ldID09PSBhMVtpXSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBEQVlfSURTID0gWydzdW4nLCAnbW9uJywgJ3R1ZScsICd3ZWQnLCAndGh1JywgJ2ZyaScsICdzYXQnXTtcclxuICAgIC8vIEFkZGluZ1xyXG4gICAgZnVuY3Rpb24gYWRkV2Vla3MobSwgbikge1xyXG4gICAgICAgIGxldCBhID0gZGF0ZVRvVXRjQXJyYXkobSk7XHJcbiAgICAgICAgYVsyXSArPSBuICogNztcclxuICAgICAgICByZXR1cm4gYXJyYXlUb1V0Y0RhdGUoYSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBhZGREYXlzKG0sIG4pIHtcclxuICAgICAgICBsZXQgYSA9IGRhdGVUb1V0Y0FycmF5KG0pO1xyXG4gICAgICAgIGFbMl0gKz0gbjtcclxuICAgICAgICByZXR1cm4gYXJyYXlUb1V0Y0RhdGUoYSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBhZGRNcyhtLCBuKSB7XHJcbiAgICAgICAgbGV0IGEgPSBkYXRlVG9VdGNBcnJheShtKTtcclxuICAgICAgICBhWzZdICs9IG47XHJcbiAgICAgICAgcmV0dXJuIGFycmF5VG9VdGNEYXRlKGEpO1xyXG4gICAgfVxyXG4gICAgLy8gRGlmZmluZyAoYWxsIHJldHVybiBmbG9hdHMpXHJcbiAgICAvLyBUT0RPOiB3aHkgbm90IHVzZSByYW5nZXM/XHJcbiAgICBmdW5jdGlvbiBkaWZmV2Vla3MobTAsIG0xKSB7XHJcbiAgICAgICAgcmV0dXJuIGRpZmZEYXlzKG0wLCBtMSkgLyA3O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZGlmZkRheXMobTAsIG0xKSB7XHJcbiAgICAgICAgcmV0dXJuIChtMS52YWx1ZU9mKCkgLSBtMC52YWx1ZU9mKCkpIC8gKDEwMDAgKiA2MCAqIDYwICogMjQpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZGlmZkhvdXJzKG0wLCBtMSkge1xyXG4gICAgICAgIHJldHVybiAobTEudmFsdWVPZigpIC0gbTAudmFsdWVPZigpKSAvICgxMDAwICogNjAgKiA2MCk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBkaWZmTWludXRlcyhtMCwgbTEpIHtcclxuICAgICAgICByZXR1cm4gKG0xLnZhbHVlT2YoKSAtIG0wLnZhbHVlT2YoKSkgLyAoMTAwMCAqIDYwKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGRpZmZTZWNvbmRzKG0wLCBtMSkge1xyXG4gICAgICAgIHJldHVybiAobTEudmFsdWVPZigpIC0gbTAudmFsdWVPZigpKSAvIDEwMDA7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBkaWZmRGF5QW5kVGltZShtMCwgbTEpIHtcclxuICAgICAgICBsZXQgbTBkYXkgPSBzdGFydE9mRGF5KG0wKTtcclxuICAgICAgICBsZXQgbTFkYXkgPSBzdGFydE9mRGF5KG0xKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB5ZWFyczogMCxcclxuICAgICAgICAgICAgbW9udGhzOiAwLFxyXG4gICAgICAgICAgICBkYXlzOiBNYXRoLnJvdW5kKGRpZmZEYXlzKG0wZGF5LCBtMWRheSkpLFxyXG4gICAgICAgICAgICBtaWxsaXNlY29uZHM6IChtMS52YWx1ZU9mKCkgLSBtMWRheS52YWx1ZU9mKCkpIC0gKG0wLnZhbHVlT2YoKSAtIG0wZGF5LnZhbHVlT2YoKSksXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIC8vIERpZmZpbmcgV2hvbGUgVW5pdHNcclxuICAgIGZ1bmN0aW9uIGRpZmZXaG9sZVdlZWtzKG0wLCBtMSkge1xyXG4gICAgICAgIGxldCBkID0gZGlmZldob2xlRGF5cyhtMCwgbTEpO1xyXG4gICAgICAgIGlmIChkICE9PSBudWxsICYmIGQgJSA3ID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkIC8gNztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBkaWZmV2hvbGVEYXlzKG0wLCBtMSkge1xyXG4gICAgICAgIGlmICh0aW1lQXNNcyhtMCkgPT09IHRpbWVBc01zKG0xKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5yb3VuZChkaWZmRGF5cyhtMCwgbTEpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICAvLyBTdGFydC1PZlxyXG4gICAgZnVuY3Rpb24gc3RhcnRPZkRheShtKSB7XHJcbiAgICAgICAgcmV0dXJuIGFycmF5VG9VdGNEYXRlKFtcclxuICAgICAgICAgICAgbS5nZXRVVENGdWxsWWVhcigpLFxyXG4gICAgICAgICAgICBtLmdldFVUQ01vbnRoKCksXHJcbiAgICAgICAgICAgIG0uZ2V0VVRDRGF0ZSgpLFxyXG4gICAgICAgIF0pO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gc3RhcnRPZkhvdXIobSkge1xyXG4gICAgICAgIHJldHVybiBhcnJheVRvVXRjRGF0ZShbXHJcbiAgICAgICAgICAgIG0uZ2V0VVRDRnVsbFllYXIoKSxcclxuICAgICAgICAgICAgbS5nZXRVVENNb250aCgpLFxyXG4gICAgICAgICAgICBtLmdldFVUQ0RhdGUoKSxcclxuICAgICAgICAgICAgbS5nZXRVVENIb3VycygpLFxyXG4gICAgICAgIF0pO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gc3RhcnRPZk1pbnV0ZShtKSB7XHJcbiAgICAgICAgcmV0dXJuIGFycmF5VG9VdGNEYXRlKFtcclxuICAgICAgICAgICAgbS5nZXRVVENGdWxsWWVhcigpLFxyXG4gICAgICAgICAgICBtLmdldFVUQ01vbnRoKCksXHJcbiAgICAgICAgICAgIG0uZ2V0VVRDRGF0ZSgpLFxyXG4gICAgICAgICAgICBtLmdldFVUQ0hvdXJzKCksXHJcbiAgICAgICAgICAgIG0uZ2V0VVRDTWludXRlcygpLFxyXG4gICAgICAgIF0pO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gc3RhcnRPZlNlY29uZChtKSB7XHJcbiAgICAgICAgcmV0dXJuIGFycmF5VG9VdGNEYXRlKFtcclxuICAgICAgICAgICAgbS5nZXRVVENGdWxsWWVhcigpLFxyXG4gICAgICAgICAgICBtLmdldFVUQ01vbnRoKCksXHJcbiAgICAgICAgICAgIG0uZ2V0VVRDRGF0ZSgpLFxyXG4gICAgICAgICAgICBtLmdldFVUQ0hvdXJzKCksXHJcbiAgICAgICAgICAgIG0uZ2V0VVRDTWludXRlcygpLFxyXG4gICAgICAgICAgICBtLmdldFVUQ1NlY29uZHMoKSxcclxuICAgICAgICBdKTtcclxuICAgIH1cclxuICAgIC8vIFdlZWsgQ29tcHV0YXRpb25cclxuICAgIGZ1bmN0aW9uIHdlZWtPZlllYXIobWFya2VyLCBkb3csIGRveSkge1xyXG4gICAgICAgIGxldCB5ID0gbWFya2VyLmdldFVUQ0Z1bGxZZWFyKCk7XHJcbiAgICAgICAgbGV0IHcgPSB3ZWVrT2ZHaXZlblllYXIobWFya2VyLCB5LCBkb3csIGRveSk7XHJcbiAgICAgICAgaWYgKHcgPCAxKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB3ZWVrT2ZHaXZlblllYXIobWFya2VyLCB5IC0gMSwgZG93LCBkb3kpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgbmV4dFcgPSB3ZWVrT2ZHaXZlblllYXIobWFya2VyLCB5ICsgMSwgZG93LCBkb3kpO1xyXG4gICAgICAgIGlmIChuZXh0VyA+PSAxKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBNYXRoLm1pbih3LCBuZXh0Vyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB3O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gd2Vla09mR2l2ZW5ZZWFyKG1hcmtlciwgeWVhciwgZG93LCBkb3kpIHtcclxuICAgICAgICBsZXQgZmlyc3RXZWVrU3RhcnQgPSBhcnJheVRvVXRjRGF0ZShbeWVhciwgMCwgMSArIGZpcnN0V2Vla09mZnNldCh5ZWFyLCBkb3csIGRveSldKTtcclxuICAgICAgICBsZXQgZGF5U3RhcnQgPSBzdGFydE9mRGF5KG1hcmtlcik7XHJcbiAgICAgICAgbGV0IGRheXMgPSBNYXRoLnJvdW5kKGRpZmZEYXlzKGZpcnN0V2Vla1N0YXJ0LCBkYXlTdGFydCkpO1xyXG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKGRheXMgLyA3KSArIDE7IC8vIHplcm8taW5kZXhlZFxyXG4gICAgfVxyXG4gICAgLy8gc3RhcnQtb2YtZmlyc3Qtd2VlayAtIHN0YXJ0LW9mLXllYXJcclxuICAgIGZ1bmN0aW9uIGZpcnN0V2Vla09mZnNldCh5ZWFyLCBkb3csIGRveSkge1xyXG4gICAgICAgIC8vIGZpcnN0LXdlZWsgZGF5IC0tIHdoaWNoIGphbnVhcnkgaXMgYWx3YXlzIGluIHRoZSBmaXJzdCB3ZWVrICg0IGZvciBpc28sIDEgZm9yIG90aGVyKVxyXG4gICAgICAgIGxldCBmd2QgPSA3ICsgZG93IC0gZG95O1xyXG4gICAgICAgIC8vIGZpcnN0LXdlZWsgZGF5IGxvY2FsIHdlZWtkYXkgLS0gd2hpY2ggbG9jYWwgd2Vla2RheSBpcyBmd2RcclxuICAgICAgICBsZXQgZndkbHcgPSAoNyArIGFycmF5VG9VdGNEYXRlKFt5ZWFyLCAwLCBmd2RdKS5nZXRVVENEYXkoKSAtIGRvdykgJSA3O1xyXG4gICAgICAgIHJldHVybiAtZndkbHcgKyBmd2QgLSAxO1xyXG4gICAgfVxyXG4gICAgLy8gQXJyYXkgQ29udmVyc2lvblxyXG4gICAgZnVuY3Rpb24gZGF0ZVRvTG9jYWxBcnJheShkYXRlKSB7XHJcbiAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgZGF0ZS5nZXRGdWxsWWVhcigpLFxyXG4gICAgICAgICAgICBkYXRlLmdldE1vbnRoKCksXHJcbiAgICAgICAgICAgIGRhdGUuZ2V0RGF0ZSgpLFxyXG4gICAgICAgICAgICBkYXRlLmdldEhvdXJzKCksXHJcbiAgICAgICAgICAgIGRhdGUuZ2V0TWludXRlcygpLFxyXG4gICAgICAgICAgICBkYXRlLmdldFNlY29uZHMoKSxcclxuICAgICAgICAgICAgZGF0ZS5nZXRNaWxsaXNlY29uZHMoKSxcclxuICAgICAgICBdO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYXJyYXlUb0xvY2FsRGF0ZShhKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKGFbMF0sIGFbMV0gfHwgMCwgYVsyXSA9PSBudWxsID8gMSA6IGFbMl0sIC8vIGRheSBvZiBtb250aFxyXG4gICAgICAgIGFbM10gfHwgMCwgYVs0XSB8fCAwLCBhWzVdIHx8IDApO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZGF0ZVRvVXRjQXJyYXkoZGF0ZSkge1xyXG4gICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgIGRhdGUuZ2V0VVRDRnVsbFllYXIoKSxcclxuICAgICAgICAgICAgZGF0ZS5nZXRVVENNb250aCgpLFxyXG4gICAgICAgICAgICBkYXRlLmdldFVUQ0RhdGUoKSxcclxuICAgICAgICAgICAgZGF0ZS5nZXRVVENIb3VycygpLFxyXG4gICAgICAgICAgICBkYXRlLmdldFVUQ01pbnV0ZXMoKSxcclxuICAgICAgICAgICAgZGF0ZS5nZXRVVENTZWNvbmRzKCksXHJcbiAgICAgICAgICAgIGRhdGUuZ2V0VVRDTWlsbGlzZWNvbmRzKCksXHJcbiAgICAgICAgXTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGFycmF5VG9VdGNEYXRlKGEpIHtcclxuICAgICAgICAvLyBhY2NvcmRpbmcgdG8gd2ViIHN0YW5kYXJkcyAoYW5kIFNhZmFyaSksIGEgbW9udGggaW5kZXggaXMgcmVxdWlyZWQuXHJcbiAgICAgICAgLy8gbWFzc2FnZSBpZiBvbmx5IGdpdmVuIGEgeWVhci5cclxuICAgICAgICBpZiAoYS5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICAgICAgYSA9IGEuY29uY2F0KFswXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShEYXRlLlVUQyguLi5hKSk7XHJcbiAgICB9XHJcbiAgICAvLyBPdGhlciBVdGlsc1xyXG4gICAgZnVuY3Rpb24gaXNWYWxpZERhdGUobSkge1xyXG4gICAgICAgIHJldHVybiAhaXNOYU4obS52YWx1ZU9mKCkpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gdGltZUFzTXMobSkge1xyXG4gICAgICAgIHJldHVybiBtLmdldFVUQ0hvdXJzKCkgKiAxMDAwICogNjAgKiA2MCArXHJcbiAgICAgICAgICAgIG0uZ2V0VVRDTWludXRlcygpICogMTAwMCAqIDYwICtcclxuICAgICAgICAgICAgbS5nZXRVVENTZWNvbmRzKCkgKiAxMDAwICtcclxuICAgICAgICAgICAgbS5nZXRVVENNaWxsaXNlY29uZHMoKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyB0aW1lWm9uZU9mZnNldCBpcyBpbiBtaW51dGVzXHJcbiAgICBmdW5jdGlvbiBidWlsZElzb1N0cmluZyhtYXJrZXIsIHRpbWVab25lT2Zmc2V0LCBzdHJpcFplcm9UaW1lID0gZmFsc2UpIHtcclxuICAgICAgICBsZXQgcyA9IG1hcmtlci50b0lTT1N0cmluZygpO1xyXG4gICAgICAgIHMgPSBzLnJlcGxhY2UoJy4wMDAnLCAnJyk7XHJcbiAgICAgICAgaWYgKHN0cmlwWmVyb1RpbWUpIHtcclxuICAgICAgICAgICAgcyA9IHMucmVwbGFjZSgnVDAwOjAwOjAwWicsICcnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHMubGVuZ3RoID4gMTApIHsgLy8gdGltZSBwYXJ0IHdhc24ndCBzdHJpcHBlZCwgY2FuIGFkZCB0aW1lem9uZSBpbmZvXHJcbiAgICAgICAgICAgIGlmICh0aW1lWm9uZU9mZnNldCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBzID0gcy5yZXBsYWNlKCdaJywgJycpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHRpbWVab25lT2Zmc2V0ICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBzID0gcy5yZXBsYWNlKCdaJywgZm9ybWF0VGltZVpvbmVPZmZzZXQodGltZVpvbmVPZmZzZXQsIHRydWUpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBvdGhlcndpc2UsIGl0cyBVVEMtMCBhbmQgd2Ugd2FudCB0byBrZWVwIHRoZSBaXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzO1xyXG4gICAgfVxyXG4gICAgLy8gZm9ybWF0cyB0aGUgZGF0ZSwgYnV0IHdpdGggbm8gdGltZSBwYXJ0XHJcbiAgICAvLyBUT0RPOiBzb21laG93IG1lcmdlIHdpdGggYnVpbGRJc29TdHJpbmcgYW5kIHN0cmlwWmVyb1RpbWVcclxuICAgIC8vIFRPRE86IHJlbmFtZS4gb21pdCBcInN0cmluZ1wiXHJcbiAgICBmdW5jdGlvbiBmb3JtYXREYXlTdHJpbmcobWFya2VyKSB7XHJcbiAgICAgICAgcmV0dXJuIG1hcmtlci50b0lTT1N0cmluZygpLnJlcGxhY2UoL1QuKiQvLCAnJyk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBmb3JtYXRJc29Nb250aFN0cihtYXJrZXIpIHtcclxuICAgICAgICByZXR1cm4gbWFya2VyLnRvSVNPU3RyaW5nKCkubWF0Y2goL15cXGR7NH0tXFxkezJ9LylbMF07XHJcbiAgICB9XHJcbiAgICAvLyBUT0RPOiB1c2UgRGF0ZTo6dG9JU09TdHJpbmcgYW5kIHVzZSBldmVyeXRoaW5nIGFmdGVyIHRoZSBUP1xyXG4gICAgZnVuY3Rpb24gZm9ybWF0SXNvVGltZVN0cmluZyhtYXJrZXIpIHtcclxuICAgICAgICByZXR1cm4gcGFkU3RhcnQobWFya2VyLmdldFVUQ0hvdXJzKCksIDIpICsgJzonICtcclxuICAgICAgICAgICAgcGFkU3RhcnQobWFya2VyLmdldFVUQ01pbnV0ZXMoKSwgMikgKyAnOicgK1xyXG4gICAgICAgICAgICBwYWRTdGFydChtYXJrZXIuZ2V0VVRDU2Vjb25kcygpLCAyKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGZvcm1hdFRpbWVab25lT2Zmc2V0KG1pbnV0ZXMsIGRvSXNvID0gZmFsc2UpIHtcclxuICAgICAgICBsZXQgc2lnbiA9IG1pbnV0ZXMgPCAwID8gJy0nIDogJysnO1xyXG4gICAgICAgIGxldCBhYnMgPSBNYXRoLmFicyhtaW51dGVzKTtcclxuICAgICAgICBsZXQgaG91cnMgPSBNYXRoLmZsb29yKGFicyAvIDYwKTtcclxuICAgICAgICBsZXQgbWlucyA9IE1hdGgucm91bmQoYWJzICUgNjApO1xyXG4gICAgICAgIGlmIChkb0lzbykge1xyXG4gICAgICAgICAgICByZXR1cm4gYCR7c2lnbiArIHBhZFN0YXJ0KGhvdXJzLCAyKX06JHtwYWRTdGFydChtaW5zLCAyKX1gO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYEdNVCR7c2lnbn0ke2hvdXJzfSR7bWlucyA/IGA6JHtwYWRTdGFydChtaW5zLCAyKX1gIDogJyd9YDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBtZW1vaXplKHdvcmtlckZ1bmMsIHJlc0VxdWFsaXR5LCB0ZWFyZG93bkZ1bmMpIHtcclxuICAgICAgICBsZXQgY3VycmVudEFyZ3M7XHJcbiAgICAgICAgbGV0IGN1cnJlbnRSZXM7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICguLi5uZXdBcmdzKSB7XHJcbiAgICAgICAgICAgIGlmICghY3VycmVudEFyZ3MpIHtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRSZXMgPSB3b3JrZXJGdW5jLmFwcGx5KHRoaXMsIG5ld0FyZ3MpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCFpc0FycmF5c0VxdWFsKGN1cnJlbnRBcmdzLCBuZXdBcmdzKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRlYXJkb3duRnVuYykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRlYXJkb3duRnVuYyhjdXJyZW50UmVzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGxldCByZXMgPSB3b3JrZXJGdW5jLmFwcGx5KHRoaXMsIG5ld0FyZ3MpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFyZXNFcXVhbGl0eSB8fCAhcmVzRXF1YWxpdHkocmVzLCBjdXJyZW50UmVzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRSZXMgPSByZXM7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY3VycmVudEFyZ3MgPSBuZXdBcmdzO1xyXG4gICAgICAgICAgICByZXR1cm4gY3VycmVudFJlcztcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gbWVtb2l6ZU9iakFyZyh3b3JrZXJGdW5jLCByZXNFcXVhbGl0eSwgdGVhcmRvd25GdW5jKSB7XHJcbiAgICAgICAgbGV0IGN1cnJlbnRBcmc7XHJcbiAgICAgICAgbGV0IGN1cnJlbnRSZXM7XHJcbiAgICAgICAgcmV0dXJuIChuZXdBcmcpID0+IHtcclxuICAgICAgICAgICAgaWYgKCFjdXJyZW50QXJnKSB7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50UmVzID0gd29ya2VyRnVuYy5jYWxsKHRoaXMsIG5ld0FyZyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoIWlzUHJvcHNFcXVhbChjdXJyZW50QXJnLCBuZXdBcmcpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGVhcmRvd25GdW5jKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGVhcmRvd25GdW5jKGN1cnJlbnRSZXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbGV0IHJlcyA9IHdvcmtlckZ1bmMuY2FsbCh0aGlzLCBuZXdBcmcpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFyZXNFcXVhbGl0eSB8fCAhcmVzRXF1YWxpdHkocmVzLCBjdXJyZW50UmVzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRSZXMgPSByZXM7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY3VycmVudEFyZyA9IG5ld0FyZztcclxuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRSZXM7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIG1lbW9pemVBcnJheWxpa2UoLy8gdXNlZCBhdCBhbGw/XHJcbiAgICB3b3JrZXJGdW5jLCByZXNFcXVhbGl0eSwgdGVhcmRvd25GdW5jKSB7XHJcbiAgICAgICAgbGV0IGN1cnJlbnRBcmdTZXRzID0gW107XHJcbiAgICAgICAgbGV0IGN1cnJlbnRSZXN1bHRzID0gW107XHJcbiAgICAgICAgcmV0dXJuIChuZXdBcmdTZXRzKSA9PiB7XHJcbiAgICAgICAgICAgIGxldCBjdXJyZW50TGVuID0gY3VycmVudEFyZ1NldHMubGVuZ3RoO1xyXG4gICAgICAgICAgICBsZXQgbmV3TGVuID0gbmV3QXJnU2V0cy5sZW5ndGg7XHJcbiAgICAgICAgICAgIGxldCBpID0gMDtcclxuICAgICAgICAgICAgZm9yICg7IGkgPCBjdXJyZW50TGVuOyBpICs9IDEpIHtcclxuICAgICAgICAgICAgICAgIGlmICghbmV3QXJnU2V0c1tpXSkgeyAvLyBvbmUgb2YgdGhlIG9sZCBzZXRzIG5vIGxvbmdlciBleGlzdHNcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGVhcmRvd25GdW5jKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlYXJkb3duRnVuYyhjdXJyZW50UmVzdWx0c1tpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIWlzQXJyYXlzRXF1YWwoY3VycmVudEFyZ1NldHNbaV0sIG5ld0FyZ1NldHNbaV0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRlYXJkb3duRnVuYykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZWFyZG93bkZ1bmMoY3VycmVudFJlc3VsdHNbaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBsZXQgcmVzID0gd29ya2VyRnVuYy5hcHBseSh0aGlzLCBuZXdBcmdTZXRzW2ldKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXJlc0VxdWFsaXR5IHx8ICFyZXNFcXVhbGl0eShyZXMsIGN1cnJlbnRSZXN1bHRzW2ldKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UmVzdWx0c1tpXSA9IHJlcztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yICg7IGkgPCBuZXdMZW47IGkgKz0gMSkge1xyXG4gICAgICAgICAgICAgICAgY3VycmVudFJlc3VsdHNbaV0gPSB3b3JrZXJGdW5jLmFwcGx5KHRoaXMsIG5ld0FyZ1NldHNbaV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGN1cnJlbnRBcmdTZXRzID0gbmV3QXJnU2V0cztcclxuICAgICAgICAgICAgY3VycmVudFJlc3VsdHMuc3BsaWNlKG5ld0xlbik7IC8vIHJlbW92ZSBleGNlc3NcclxuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRSZXN1bHRzO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBtZW1vaXplSGFzaGxpa2Uod29ya2VyRnVuYywgcmVzRXF1YWxpdHksIHRlYXJkb3duRnVuYykge1xyXG4gICAgICAgIGxldCBjdXJyZW50QXJnSGFzaCA9IHt9O1xyXG4gICAgICAgIGxldCBjdXJyZW50UmVzSGFzaCA9IHt9O1xyXG4gICAgICAgIHJldHVybiAobmV3QXJnSGFzaCkgPT4ge1xyXG4gICAgICAgICAgICBsZXQgbmV3UmVzSGFzaCA9IHt9O1xyXG4gICAgICAgICAgICBmb3IgKGxldCBrZXkgaW4gbmV3QXJnSGFzaCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFjdXJyZW50UmVzSGFzaFtrZXldKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3UmVzSGFzaFtrZXldID0gd29ya2VyRnVuYy5hcHBseSh0aGlzLCBuZXdBcmdIYXNoW2tleV0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIWlzQXJyYXlzRXF1YWwoY3VycmVudEFyZ0hhc2hba2V5XSwgbmV3QXJnSGFzaFtrZXldKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ZWFyZG93bkZ1bmMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGVhcmRvd25GdW5jKGN1cnJlbnRSZXNIYXNoW2tleV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBsZXQgcmVzID0gd29ya2VyRnVuYy5hcHBseSh0aGlzLCBuZXdBcmdIYXNoW2tleV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld1Jlc0hhc2hba2V5XSA9IChyZXNFcXVhbGl0eSAmJiByZXNFcXVhbGl0eShyZXMsIGN1cnJlbnRSZXNIYXNoW2tleV0pKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGN1cnJlbnRSZXNIYXNoW2tleV1cclxuICAgICAgICAgICAgICAgICAgICAgICAgOiByZXM7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXdSZXNIYXNoW2tleV0gPSBjdXJyZW50UmVzSGFzaFtrZXldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGN1cnJlbnRBcmdIYXNoID0gbmV3QXJnSGFzaDtcclxuICAgICAgICAgICAgY3VycmVudFJlc0hhc2ggPSBuZXdSZXNIYXNoO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3UmVzSGFzaDtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IEVYVEVOREVEX1NFVFRJTkdTX0FORF9TRVZFUklUSUVTID0ge1xyXG4gICAgICAgIHdlZWs6IDMsXHJcbiAgICAgICAgc2VwYXJhdG9yOiAwLFxyXG4gICAgICAgIG9taXRaZXJvTWludXRlOiAwLFxyXG4gICAgICAgIG1lcmlkaWVtOiAwLFxyXG4gICAgICAgIG9taXRDb21tYXM6IDAsXHJcbiAgICB9O1xyXG4gICAgY29uc3QgU1RBTkRBUkRfREFURV9QUk9QX1NFVkVSSVRJRVMgPSB7XHJcbiAgICAgICAgdGltZVpvbmVOYW1lOiA3LFxyXG4gICAgICAgIGVyYTogNixcclxuICAgICAgICB5ZWFyOiA1LFxyXG4gICAgICAgIG1vbnRoOiA0LFxyXG4gICAgICAgIGRheTogMixcclxuICAgICAgICB3ZWVrZGF5OiAyLFxyXG4gICAgICAgIGhvdXI6IDEsXHJcbiAgICAgICAgbWludXRlOiAxLFxyXG4gICAgICAgIHNlY29uZDogMSxcclxuICAgIH07XHJcbiAgICBjb25zdCBNRVJJRElFTV9SRSA9IC9cXHMqKFthcF0pXFwuP21cXC4/L2k7IC8vIGVhdHMgdXAgbGVhZGluZyBzcGFjZXMgdG9vXHJcbiAgICBjb25zdCBDT01NQV9SRSA9IC8sL2c7IC8vIHdlIG5lZWQgcmUgZm9yIGdsb2JhbG5lc3NcclxuICAgIGNvbnN0IE1VTFRJX1NQQUNFX1JFID0gL1xccysvZztcclxuICAgIGNvbnN0IExUUl9SRSA9IC9cXHUyMDBlL2c7IC8vIGNvbnRyb2wgY2hhcmFjdGVyXHJcbiAgICBjb25zdCBVVENfUkUgPSAvVVRDfEdNVC87XHJcbiAgICBjbGFzcyBOYXRpdmVGb3JtYXR0ZXIge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yKGZvcm1hdFNldHRpbmdzKSB7XHJcbiAgICAgICAgICAgIGxldCBzdGFuZGFyZERhdGVQcm9wcyA9IHt9O1xyXG4gICAgICAgICAgICBsZXQgZXh0ZW5kZWRTZXR0aW5ncyA9IHt9O1xyXG4gICAgICAgICAgICBsZXQgc2V2ZXJpdHkgPSAwO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBuYW1lIGluIGZvcm1hdFNldHRpbmdzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobmFtZSBpbiBFWFRFTkRFRF9TRVRUSU5HU19BTkRfU0VWRVJJVElFUykge1xyXG4gICAgICAgICAgICAgICAgICAgIGV4dGVuZGVkU2V0dGluZ3NbbmFtZV0gPSBmb3JtYXRTZXR0aW5nc1tuYW1lXTtcclxuICAgICAgICAgICAgICAgICAgICBzZXZlcml0eSA9IE1hdGgubWF4KEVYVEVOREVEX1NFVFRJTkdTX0FORF9TRVZFUklUSUVTW25hbWVdLCBzZXZlcml0eSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBzdGFuZGFyZERhdGVQcm9wc1tuYW1lXSA9IGZvcm1hdFNldHRpbmdzW25hbWVdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChuYW1lIGluIFNUQU5EQVJEX0RBVEVfUFJPUF9TRVZFUklUSUVTKSB7IC8vIFRPRE86IHdoYXQgYWJvdXQgaG91cjEyPyBubyBzZXZlcml0eVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXZlcml0eSA9IE1hdGgubWF4KFNUQU5EQVJEX0RBVEVfUFJPUF9TRVZFUklUSUVTW25hbWVdLCBzZXZlcml0eSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuc3RhbmRhcmREYXRlUHJvcHMgPSBzdGFuZGFyZERhdGVQcm9wcztcclxuICAgICAgICAgICAgdGhpcy5leHRlbmRlZFNldHRpbmdzID0gZXh0ZW5kZWRTZXR0aW5ncztcclxuICAgICAgICAgICAgdGhpcy5zZXZlcml0eSA9IHNldmVyaXR5O1xyXG4gICAgICAgICAgICB0aGlzLmJ1aWxkRm9ybWF0dGluZ0Z1bmMgPSBtZW1vaXplKGJ1aWxkRm9ybWF0dGluZ0Z1bmMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3JtYXQoZGF0ZSwgY29udGV4dCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5idWlsZEZvcm1hdHRpbmdGdW5jKHRoaXMuc3RhbmRhcmREYXRlUHJvcHMsIHRoaXMuZXh0ZW5kZWRTZXR0aW5ncywgY29udGV4dCkoZGF0ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvcm1hdFJhbmdlKHN0YXJ0LCBlbmQsIGNvbnRleHQsIGJldHRlckRlZmF1bHRTZXBhcmF0b3IpIHtcclxuICAgICAgICAgICAgbGV0IHsgc3RhbmRhcmREYXRlUHJvcHMsIGV4dGVuZGVkU2V0dGluZ3MgfSA9IHRoaXM7XHJcbiAgICAgICAgICAgIGxldCBkaWZmU2V2ZXJpdHkgPSBjb21wdXRlTWFya2VyRGlmZlNldmVyaXR5KHN0YXJ0Lm1hcmtlciwgZW5kLm1hcmtlciwgY29udGV4dC5jYWxlbmRhclN5c3RlbSk7XHJcbiAgICAgICAgICAgIGlmICghZGlmZlNldmVyaXR5KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXQoc3RhcnQsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxldCBiaWdnZXN0VW5pdEZvclBhcnRpYWwgPSBkaWZmU2V2ZXJpdHk7XHJcbiAgICAgICAgICAgIGlmIChiaWdnZXN0VW5pdEZvclBhcnRpYWwgPiAxICYmIC8vIHRoZSB0d28gZGF0ZXMgYXJlIGRpZmZlcmVudCBpbiBhIHdheSB0aGF0J3MgbGFyZ2VyIHNjYWxlIHRoYW4gdGltZVxyXG4gICAgICAgICAgICAgICAgKHN0YW5kYXJkRGF0ZVByb3BzLnllYXIgPT09ICdudW1lcmljJyB8fCBzdGFuZGFyZERhdGVQcm9wcy55ZWFyID09PSAnMi1kaWdpdCcpICYmXHJcbiAgICAgICAgICAgICAgICAoc3RhbmRhcmREYXRlUHJvcHMubW9udGggPT09ICdudW1lcmljJyB8fCBzdGFuZGFyZERhdGVQcm9wcy5tb250aCA9PT0gJzItZGlnaXQnKSAmJlxyXG4gICAgICAgICAgICAgICAgKHN0YW5kYXJkRGF0ZVByb3BzLmRheSA9PT0gJ251bWVyaWMnIHx8IHN0YW5kYXJkRGF0ZVByb3BzLmRheSA9PT0gJzItZGlnaXQnKSkge1xyXG4gICAgICAgICAgICAgICAgYmlnZ2VzdFVuaXRGb3JQYXJ0aWFsID0gMTsgLy8gbWFrZSBpdCBsb29rIGxpa2UgdGhlIGRhdGVzIGFyZSBvbmx5IGRpZmZlcmVudCBpbiB0ZXJtcyBvZiB0aW1lXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IGZ1bGwwID0gdGhpcy5mb3JtYXQoc3RhcnQsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICBsZXQgZnVsbDEgPSB0aGlzLmZvcm1hdChlbmQsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICBpZiAoZnVsbDAgPT09IGZ1bGwxKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVsbDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IHBhcnRpYWxEYXRlUHJvcHMgPSBjb21wdXRlUGFydGlhbEZvcm1hdHRpbmdPcHRpb25zKHN0YW5kYXJkRGF0ZVByb3BzLCBiaWdnZXN0VW5pdEZvclBhcnRpYWwpO1xyXG4gICAgICAgICAgICBsZXQgcGFydGlhbEZvcm1hdHRpbmdGdW5jID0gYnVpbGRGb3JtYXR0aW5nRnVuYyhwYXJ0aWFsRGF0ZVByb3BzLCBleHRlbmRlZFNldHRpbmdzLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgbGV0IHBhcnRpYWwwID0gcGFydGlhbEZvcm1hdHRpbmdGdW5jKHN0YXJ0KTtcclxuICAgICAgICAgICAgbGV0IHBhcnRpYWwxID0gcGFydGlhbEZvcm1hdHRpbmdGdW5jKGVuZCk7XHJcbiAgICAgICAgICAgIGxldCBpbnNlcnRpb24gPSBmaW5kQ29tbW9uSW5zZXJ0aW9uKGZ1bGwwLCBwYXJ0aWFsMCwgZnVsbDEsIHBhcnRpYWwxKTtcclxuICAgICAgICAgICAgbGV0IHNlcGFyYXRvciA9IGV4dGVuZGVkU2V0dGluZ3Muc2VwYXJhdG9yIHx8IGJldHRlckRlZmF1bHRTZXBhcmF0b3IgfHwgY29udGV4dC5kZWZhdWx0U2VwYXJhdG9yIHx8ICcnO1xyXG4gICAgICAgICAgICBpZiAoaW5zZXJ0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5zZXJ0aW9uLmJlZm9yZSArIHBhcnRpYWwwICsgc2VwYXJhdG9yICsgcGFydGlhbDEgKyBpbnNlcnRpb24uYWZ0ZXI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGZ1bGwwICsgc2VwYXJhdG9yICsgZnVsbDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGdldExhcmdlc3RVbml0KCkge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMuc2V2ZXJpdHkpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgNzpcclxuICAgICAgICAgICAgICAgIGNhc2UgNjpcclxuICAgICAgICAgICAgICAgIGNhc2UgNTpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ3llYXInO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA0OlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnbW9udGgnO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnd2Vlayc7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdkYXknO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ3RpbWUnOyAvLyByZWFsbHk/XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBidWlsZEZvcm1hdHRpbmdGdW5jKHN0YW5kYXJkRGF0ZVByb3BzLCBleHRlbmRlZFNldHRpbmdzLCBjb250ZXh0KSB7XHJcbiAgICAgICAgbGV0IHN0YW5kYXJkRGF0ZVByb3BDbnQgPSBPYmplY3Qua2V5cyhzdGFuZGFyZERhdGVQcm9wcykubGVuZ3RoO1xyXG4gICAgICAgIGlmIChzdGFuZGFyZERhdGVQcm9wQ250ID09PSAxICYmIHN0YW5kYXJkRGF0ZVByb3BzLnRpbWVab25lTmFtZSA9PT0gJ3Nob3J0Jykge1xyXG4gICAgICAgICAgICByZXR1cm4gKGRhdGUpID0+IChmb3JtYXRUaW1lWm9uZU9mZnNldChkYXRlLnRpbWVab25lT2Zmc2V0KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzdGFuZGFyZERhdGVQcm9wQ250ID09PSAwICYmIGV4dGVuZGVkU2V0dGluZ3Mud2Vlaykge1xyXG4gICAgICAgICAgICByZXR1cm4gKGRhdGUpID0+IChmb3JtYXRXZWVrTnVtYmVyKGNvbnRleHQuY29tcHV0ZVdlZWtOdW1iZXIoZGF0ZS5tYXJrZXIpLCBjb250ZXh0LndlZWtUZXh0LCBjb250ZXh0LndlZWtUZXh0TG9uZywgY29udGV4dC5sb2NhbGUsIGV4dGVuZGVkU2V0dGluZ3Mud2VlaykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYnVpbGROYXRpdmVGb3JtYXR0aW5nRnVuYyhzdGFuZGFyZERhdGVQcm9wcywgZXh0ZW5kZWRTZXR0aW5ncywgY29udGV4dCk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBidWlsZE5hdGl2ZUZvcm1hdHRpbmdGdW5jKHN0YW5kYXJkRGF0ZVByb3BzLCBleHRlbmRlZFNldHRpbmdzLCBjb250ZXh0KSB7XHJcbiAgICAgICAgc3RhbmRhcmREYXRlUHJvcHMgPSBPYmplY3QuYXNzaWduKHt9LCBzdGFuZGFyZERhdGVQcm9wcyk7IC8vIGNvcHlcclxuICAgICAgICBleHRlbmRlZFNldHRpbmdzID0gT2JqZWN0LmFzc2lnbih7fSwgZXh0ZW5kZWRTZXR0aW5ncyk7IC8vIGNvcHlcclxuICAgICAgICBzYW5pdGl6ZVNldHRpbmdzKHN0YW5kYXJkRGF0ZVByb3BzLCBleHRlbmRlZFNldHRpbmdzKTtcclxuICAgICAgICBzdGFuZGFyZERhdGVQcm9wcy50aW1lWm9uZSA9ICdVVEMnOyAvLyB3ZSBsZXZlcmFnZSB0aGUgb25seSBndWFyYW50ZWVkIHRpbWVab25lIGZvciBvdXIgVVRDIG1hcmtlcnNcclxuICAgICAgICBsZXQgbm9ybWFsRm9ybWF0ID0gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQoY29udGV4dC5sb2NhbGUuY29kZXMsIHN0YW5kYXJkRGF0ZVByb3BzKTtcclxuICAgICAgICBsZXQgemVyb0Zvcm1hdDsgLy8gbmVlZGVkP1xyXG4gICAgICAgIGlmIChleHRlbmRlZFNldHRpbmdzLm9taXRaZXJvTWludXRlKSB7XHJcbiAgICAgICAgICAgIGxldCB6ZXJvUHJvcHMgPSBPYmplY3QuYXNzaWduKHt9LCBzdGFuZGFyZERhdGVQcm9wcyk7XHJcbiAgICAgICAgICAgIGRlbGV0ZSB6ZXJvUHJvcHMubWludXRlOyAvLyBzZWNvbmRzIGFuZCBtcyB3ZXJlIGFscmVhZHkgY29uc2lkZXJlZCBpbiBzYW5pdGl6ZVNldHRpbmdzXHJcbiAgICAgICAgICAgIHplcm9Gb3JtYXQgPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChjb250ZXh0LmxvY2FsZS5jb2RlcywgemVyb1Byb3BzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIChkYXRlKSA9PiB7XHJcbiAgICAgICAgICAgIGxldCB7IG1hcmtlciB9ID0gZGF0ZTtcclxuICAgICAgICAgICAgbGV0IGZvcm1hdDtcclxuICAgICAgICAgICAgaWYgKHplcm9Gb3JtYXQgJiYgIW1hcmtlci5nZXRVVENNaW51dGVzKCkpIHtcclxuICAgICAgICAgICAgICAgIGZvcm1hdCA9IHplcm9Gb3JtYXQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBmb3JtYXQgPSBub3JtYWxGb3JtYXQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IHMgPSBmb3JtYXQuZm9ybWF0KG1hcmtlcik7XHJcbiAgICAgICAgICAgIHJldHVybiBwb3N0UHJvY2VzcyhzLCBkYXRlLCBzdGFuZGFyZERhdGVQcm9wcywgZXh0ZW5kZWRTZXR0aW5ncywgY29udGV4dCk7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHNhbml0aXplU2V0dGluZ3Moc3RhbmRhcmREYXRlUHJvcHMsIGV4dGVuZGVkU2V0dGluZ3MpIHtcclxuICAgICAgICAvLyBkZWFsIHdpdGggYSBicm93c2VyIGluY29uc2lzdGVuY3kgd2hlcmUgZm9ybWF0dGluZyB0aGUgdGltZXpvbmVcclxuICAgICAgICAvLyByZXF1aXJlcyB0aGF0IHRoZSBob3VyL21pbnV0ZSBiZSBwcmVzZW50LlxyXG4gICAgICAgIGlmIChzdGFuZGFyZERhdGVQcm9wcy50aW1lWm9uZU5hbWUpIHtcclxuICAgICAgICAgICAgaWYgKCFzdGFuZGFyZERhdGVQcm9wcy5ob3VyKSB7XHJcbiAgICAgICAgICAgICAgICBzdGFuZGFyZERhdGVQcm9wcy5ob3VyID0gJzItZGlnaXQnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghc3RhbmRhcmREYXRlUHJvcHMubWludXRlKSB7XHJcbiAgICAgICAgICAgICAgICBzdGFuZGFyZERhdGVQcm9wcy5taW51dGUgPSAnMi1kaWdpdCc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gb25seSBzdXBwb3J0IHNob3J0IHRpbWV6b25lIG5hbWVzXHJcbiAgICAgICAgaWYgKHN0YW5kYXJkRGF0ZVByb3BzLnRpbWVab25lTmFtZSA9PT0gJ2xvbmcnKSB7XHJcbiAgICAgICAgICAgIHN0YW5kYXJkRGF0ZVByb3BzLnRpbWVab25lTmFtZSA9ICdzaG9ydCc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGlmIHJlcXVlc3RpbmcgdG8gZGlzcGxheSBzZWNvbmRzLCBNVVNUIGRpc3BsYXkgbWludXRlc1xyXG4gICAgICAgIGlmIChleHRlbmRlZFNldHRpbmdzLm9taXRaZXJvTWludXRlICYmIChzdGFuZGFyZERhdGVQcm9wcy5zZWNvbmQgfHwgc3RhbmRhcmREYXRlUHJvcHMubWlsbGlzZWNvbmQpKSB7XHJcbiAgICAgICAgICAgIGRlbGV0ZSBleHRlbmRlZFNldHRpbmdzLm9taXRaZXJvTWludXRlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHBvc3RQcm9jZXNzKHMsIGRhdGUsIHN0YW5kYXJkRGF0ZVByb3BzLCBleHRlbmRlZFNldHRpbmdzLCBjb250ZXh0KSB7XHJcbiAgICAgICAgcyA9IHMucmVwbGFjZShMVFJfUkUsICcnKTsgLy8gcmVtb3ZlIGxlZnQtdG8tcmlnaHQgY29udHJvbCBjaGFycy4gZG8gZmlyc3QuIGdvb2QgZm9yIG90aGVyIHJlZ2V4ZXNcclxuICAgICAgICBpZiAoc3RhbmRhcmREYXRlUHJvcHMudGltZVpvbmVOYW1lID09PSAnc2hvcnQnKSB7XHJcbiAgICAgICAgICAgIHMgPSBpbmplY3RUem9TdHIocywgKGNvbnRleHQudGltZVpvbmUgPT09ICdVVEMnIHx8IGRhdGUudGltZVpvbmVPZmZzZXQgPT0gbnVsbCkgP1xyXG4gICAgICAgICAgICAgICAgJ1VUQycgOiAvLyBpbXBvcnRhbnQgdG8gbm9ybWFsaXplIGZvciBJRSwgd2hpY2ggZG9lcyBcIkdNVFwiXHJcbiAgICAgICAgICAgICAgICBmb3JtYXRUaW1lWm9uZU9mZnNldChkYXRlLnRpbWVab25lT2Zmc2V0KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChleHRlbmRlZFNldHRpbmdzLm9taXRDb21tYXMpIHtcclxuICAgICAgICAgICAgcyA9IHMucmVwbGFjZShDT01NQV9SRSwgJycpLnRyaW0oKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGV4dGVuZGVkU2V0dGluZ3Mub21pdFplcm9NaW51dGUpIHtcclxuICAgICAgICAgICAgcyA9IHMucmVwbGFjZSgnOjAwJywgJycpOyAvLyB6ZXJvRm9ybWF0IGRvZXNuJ3QgYWx3YXlzIGFjaGlldmUgdGhpc1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBeIGRvIGFueXRoaW5nIHRoYXQgbWlnaHQgY3JlYXRlIGFkamFjZW50IHNwYWNlcyBiZWZvcmUgdGhpcyBwb2ludCxcclxuICAgICAgICAvLyBiZWNhdXNlIE1FUklESUVNX1JFIGxpa2VzIHRvIGVhdCB1cCBsb2FkaW5nIHNwYWNlc1xyXG4gICAgICAgIGlmIChleHRlbmRlZFNldHRpbmdzLm1lcmlkaWVtID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICBzID0gcy5yZXBsYWNlKE1FUklESUVNX1JFLCAnJykudHJpbSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChleHRlbmRlZFNldHRpbmdzLm1lcmlkaWVtID09PSAnbmFycm93JykgeyAvLyBhL3BcclxuICAgICAgICAgICAgcyA9IHMucmVwbGFjZShNRVJJRElFTV9SRSwgKG0wLCBtMSkgPT4gbTEudG9Mb2NhbGVMb3dlckNhc2UoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGV4dGVuZGVkU2V0dGluZ3MubWVyaWRpZW0gPT09ICdzaG9ydCcpIHsgLy8gYW0vcG1cclxuICAgICAgICAgICAgcyA9IHMucmVwbGFjZShNRVJJRElFTV9SRSwgKG0wLCBtMSkgPT4gYCR7bTEudG9Mb2NhbGVMb3dlckNhc2UoKX1tYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGV4dGVuZGVkU2V0dGluZ3MubWVyaWRpZW0gPT09ICdsb3dlcmNhc2UnKSB7IC8vIG90aGVyIG1lcmlkaWVtIHRyYW5zZm9ybWVycyBhbHJlYWR5IGNvbnZlcnRlZCB0byBsb3dlcmNhc2VcclxuICAgICAgICAgICAgcyA9IHMucmVwbGFjZShNRVJJRElFTV9SRSwgKG0wKSA9PiBtMC50b0xvY2FsZUxvd2VyQ2FzZSgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcyA9IHMucmVwbGFjZShNVUxUSV9TUEFDRV9SRSwgJyAnKTtcclxuICAgICAgICBzID0gcy50cmltKCk7XHJcbiAgICAgICAgcmV0dXJuIHM7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBpbmplY3RUem9TdHIocywgdHpvU3RyKSB7XHJcbiAgICAgICAgbGV0IHJlcGxhY2VkID0gZmFsc2U7XHJcbiAgICAgICAgcyA9IHMucmVwbGFjZShVVENfUkUsICgpID0+IHtcclxuICAgICAgICAgICAgcmVwbGFjZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICByZXR1cm4gdHpvU3RyO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIElFMTEgZG9lc24ndCBpbmNsdWRlIFVUQy9HTVQgaW4gdGhlIG9yaWdpbmFsIHN0cmluZywgc28gYXBwZW5kIHRvIGVuZFxyXG4gICAgICAgIGlmICghcmVwbGFjZWQpIHtcclxuICAgICAgICAgICAgcyArPSBgICR7dHpvU3RyfWA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZm9ybWF0V2Vla051bWJlcihudW0sIHdlZWtUZXh0LCB3ZWVrVGV4dExvbmcsIGxvY2FsZSwgZGlzcGxheSkge1xyXG4gICAgICAgIGxldCBwYXJ0cyA9IFtdO1xyXG4gICAgICAgIGlmIChkaXNwbGF5ID09PSAnbG9uZycpIHtcclxuICAgICAgICAgICAgcGFydHMucHVzaCh3ZWVrVGV4dExvbmcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChkaXNwbGF5ID09PSAnc2hvcnQnIHx8IGRpc3BsYXkgPT09ICduYXJyb3cnKSB7XHJcbiAgICAgICAgICAgIHBhcnRzLnB1c2god2Vla1RleHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZGlzcGxheSA9PT0gJ2xvbmcnIHx8IGRpc3BsYXkgPT09ICdzaG9ydCcpIHtcclxuICAgICAgICAgICAgcGFydHMucHVzaCgnICcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwYXJ0cy5wdXNoKGxvY2FsZS5zaW1wbGVOdW1iZXJGb3JtYXQuZm9ybWF0KG51bSkpO1xyXG4gICAgICAgIGlmIChsb2NhbGUub3B0aW9ucy5kaXJlY3Rpb24gPT09ICdydGwnKSB7IC8vIFRPRE86IHVzZSBjb250cm9sIGNoYXJhY3RlcnMgaW5zdGVhZD9cclxuICAgICAgICAgICAgcGFydHMucmV2ZXJzZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcGFydHMuam9pbignJyk7XHJcbiAgICB9XHJcbiAgICAvLyBSYW5nZSBGb3JtYXR0aW5nIFV0aWxzXHJcbiAgICAvLyAwID0gZXhhY3RseSB0aGUgc2FtZVxyXG4gICAgLy8gMSA9IGRpZmZlcmVudCBieSB0aW1lXHJcbiAgICAvLyBhbmQgYmlnZ2VyXHJcbiAgICBmdW5jdGlvbiBjb21wdXRlTWFya2VyRGlmZlNldmVyaXR5KGQwLCBkMSwgY2EpIHtcclxuICAgICAgICBpZiAoY2EuZ2V0TWFya2VyWWVhcihkMCkgIT09IGNhLmdldE1hcmtlclllYXIoZDEpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiA1O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY2EuZ2V0TWFya2VyTW9udGgoZDApICE9PSBjYS5nZXRNYXJrZXJNb250aChkMSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIDQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjYS5nZXRNYXJrZXJEYXkoZDApICE9PSBjYS5nZXRNYXJrZXJEYXkoZDEpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAyO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGltZUFzTXMoZDApICE9PSB0aW1lQXNNcyhkMSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gY29tcHV0ZVBhcnRpYWxGb3JtYXR0aW5nT3B0aW9ucyhvcHRpb25zLCBiaWdnZXN0VW5pdCkge1xyXG4gICAgICAgIGxldCBwYXJ0aWFsT3B0aW9ucyA9IHt9O1xyXG4gICAgICAgIGZvciAobGV0IG5hbWUgaW4gb3B0aW9ucykge1xyXG4gICAgICAgICAgICBpZiAoIShuYW1lIGluIFNUQU5EQVJEX0RBVEVfUFJPUF9TRVZFUklUSUVTKSB8fCAvLyBub3QgYSBkYXRlIHBhcnQgcHJvcCAobGlrZSB0aW1lWm9uZSlcclxuICAgICAgICAgICAgICAgIFNUQU5EQVJEX0RBVEVfUFJPUF9TRVZFUklUSUVTW25hbWVdIDw9IGJpZ2dlc3RVbml0KSB7XHJcbiAgICAgICAgICAgICAgICBwYXJ0aWFsT3B0aW9uc1tuYW1lXSA9IG9wdGlvbnNbbmFtZV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHBhcnRpYWxPcHRpb25zO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZmluZENvbW1vbkluc2VydGlvbihmdWxsMCwgcGFydGlhbDAsIGZ1bGwxLCBwYXJ0aWFsMSkge1xyXG4gICAgICAgIGxldCBpMCA9IDA7XHJcbiAgICAgICAgd2hpbGUgKGkwIDwgZnVsbDAubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGxldCBmb3VuZDAgPSBmdWxsMC5pbmRleE9mKHBhcnRpYWwwLCBpMCk7XHJcbiAgICAgICAgICAgIGlmIChmb3VuZDAgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgYmVmb3JlMCA9IGZ1bGwwLnN1YnN0cigwLCBmb3VuZDApO1xyXG4gICAgICAgICAgICBpMCA9IGZvdW5kMCArIHBhcnRpYWwwLmxlbmd0aDtcclxuICAgICAgICAgICAgbGV0IGFmdGVyMCA9IGZ1bGwwLnN1YnN0cihpMCk7XHJcbiAgICAgICAgICAgIGxldCBpMSA9IDA7XHJcbiAgICAgICAgICAgIHdoaWxlIChpMSA8IGZ1bGwxLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgbGV0IGZvdW5kMSA9IGZ1bGwxLmluZGV4T2YocGFydGlhbDEsIGkxKTtcclxuICAgICAgICAgICAgICAgIGlmIChmb3VuZDEgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBsZXQgYmVmb3JlMSA9IGZ1bGwxLnN1YnN0cigwLCBmb3VuZDEpO1xyXG4gICAgICAgICAgICAgICAgaTEgPSBmb3VuZDEgKyBwYXJ0aWFsMS5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBsZXQgYWZ0ZXIxID0gZnVsbDEuc3Vic3RyKGkxKTtcclxuICAgICAgICAgICAgICAgIGlmIChiZWZvcmUwID09PSBiZWZvcmUxICYmIGFmdGVyMCA9PT0gYWZ0ZXIxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYmVmb3JlOiBiZWZvcmUwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhZnRlcjogYWZ0ZXIwLFxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZXhwYW5kWm9uZWRNYXJrZXIoZGF0ZUluZm8sIGNhbGVuZGFyU3lzdGVtKSB7XHJcbiAgICAgICAgbGV0IGEgPSBjYWxlbmRhclN5c3RlbS5tYXJrZXJUb0FycmF5KGRhdGVJbmZvLm1hcmtlcik7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgbWFya2VyOiBkYXRlSW5mby5tYXJrZXIsXHJcbiAgICAgICAgICAgIHRpbWVab25lT2Zmc2V0OiBkYXRlSW5mby50aW1lWm9uZU9mZnNldCxcclxuICAgICAgICAgICAgYXJyYXk6IGEsXHJcbiAgICAgICAgICAgIHllYXI6IGFbMF0sXHJcbiAgICAgICAgICAgIG1vbnRoOiBhWzFdLFxyXG4gICAgICAgICAgICBkYXk6IGFbMl0sXHJcbiAgICAgICAgICAgIGhvdXI6IGFbM10sXHJcbiAgICAgICAgICAgIG1pbnV0ZTogYVs0XSxcclxuICAgICAgICAgICAgc2Vjb25kOiBhWzVdLFxyXG4gICAgICAgICAgICBtaWxsaXNlY29uZDogYVs2XSxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNyZWF0ZVZlcmJvc2VGb3JtYXR0aW5nQXJnKHN0YXJ0LCBlbmQsIGNvbnRleHQsIGJldHRlckRlZmF1bHRTZXBhcmF0b3IpIHtcclxuICAgICAgICBsZXQgc3RhcnRJbmZvID0gZXhwYW5kWm9uZWRNYXJrZXIoc3RhcnQsIGNvbnRleHQuY2FsZW5kYXJTeXN0ZW0pO1xyXG4gICAgICAgIGxldCBlbmRJbmZvID0gZW5kID8gZXhwYW5kWm9uZWRNYXJrZXIoZW5kLCBjb250ZXh0LmNhbGVuZGFyU3lzdGVtKSA6IG51bGw7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgZGF0ZTogc3RhcnRJbmZvLFxyXG4gICAgICAgICAgICBzdGFydDogc3RhcnRJbmZvLFxyXG4gICAgICAgICAgICBlbmQ6IGVuZEluZm8sXHJcbiAgICAgICAgICAgIHRpbWVab25lOiBjb250ZXh0LnRpbWVab25lLFxyXG4gICAgICAgICAgICBsb2NhbGVDb2RlczogY29udGV4dC5sb2NhbGUuY29kZXMsXHJcbiAgICAgICAgICAgIGRlZmF1bHRTZXBhcmF0b3I6IGJldHRlckRlZmF1bHRTZXBhcmF0b3IgfHwgY29udGV4dC5kZWZhdWx0U2VwYXJhdG9yLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgLypcclxuICAgIFRPRE86IGZpeCB0aGUgdGVybWlub2xvZ3kgb2YgXCJmb3JtYXR0ZXJcIiB2cyBcImZvcm1hdHRpbmcgZnVuY1wiXHJcbiAgICAqL1xyXG4gICAgLypcclxuICAgIEF0IHRoZSB0aW1lIG9mIGluc3RhbnRpYXRpb24sIHRoaXMgb2JqZWN0IGRvZXMgbm90IGtub3cgd2hpY2ggY21kLWZvcm1hdHRpbmcgc3lzdGVtIGl0IHdpbGwgdXNlLlxyXG4gICAgSXQgcmVjZWl2ZXMgdGhpcyBhdCB0aGUgdGltZSBvZiBmb3JtYXR0aW5nLCBhcyBhIHNldHRpbmcuXHJcbiAgICAqL1xyXG4gICAgY2xhc3MgQ21kRm9ybWF0dGVyIHtcclxuICAgICAgICBjb25zdHJ1Y3RvcihjbWRTdHIpIHtcclxuICAgICAgICAgICAgdGhpcy5jbWRTdHIgPSBjbWRTdHI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvcm1hdChkYXRlLCBjb250ZXh0LCBiZXR0ZXJEZWZhdWx0U2VwYXJhdG9yKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmNtZEZvcm1hdHRlcih0aGlzLmNtZFN0ciwgY3JlYXRlVmVyYm9zZUZvcm1hdHRpbmdBcmcoZGF0ZSwgbnVsbCwgY29udGV4dCwgYmV0dGVyRGVmYXVsdFNlcGFyYXRvcikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3JtYXRSYW5nZShzdGFydCwgZW5kLCBjb250ZXh0LCBiZXR0ZXJEZWZhdWx0U2VwYXJhdG9yKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmNtZEZvcm1hdHRlcih0aGlzLmNtZFN0ciwgY3JlYXRlVmVyYm9zZUZvcm1hdHRpbmdBcmcoc3RhcnQsIGVuZCwgY29udGV4dCwgYmV0dGVyRGVmYXVsdFNlcGFyYXRvcikpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBjbGFzcyBGdW5jRm9ybWF0dGVyIHtcclxuICAgICAgICBjb25zdHJ1Y3RvcihmdW5jKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZnVuYyA9IGZ1bmM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvcm1hdChkYXRlLCBjb250ZXh0LCBiZXR0ZXJEZWZhdWx0U2VwYXJhdG9yKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZ1bmMoY3JlYXRlVmVyYm9zZUZvcm1hdHRpbmdBcmcoZGF0ZSwgbnVsbCwgY29udGV4dCwgYmV0dGVyRGVmYXVsdFNlcGFyYXRvcikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3JtYXRSYW5nZShzdGFydCwgZW5kLCBjb250ZXh0LCBiZXR0ZXJEZWZhdWx0U2VwYXJhdG9yKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZ1bmMoY3JlYXRlVmVyYm9zZUZvcm1hdHRpbmdBcmcoc3RhcnQsIGVuZCwgY29udGV4dCwgYmV0dGVyRGVmYXVsdFNlcGFyYXRvcikpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjcmVhdGVGb3JtYXR0ZXIoaW5wdXQpIHtcclxuICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnb2JqZWN0JyAmJiBpbnB1dCkgeyAvLyBub24tbnVsbCBvYmplY3RcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBOYXRpdmVGb3JtYXR0ZXIoaW5wdXQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IENtZEZvcm1hdHRlcihpbnB1dCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBGdW5jRm9ybWF0dGVyKGlucHV0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gYmFzZSBvcHRpb25zXHJcbiAgICAvLyAtLS0tLS0tLS0tLS1cclxuICAgIGNvbnN0IEJBU0VfT1BUSU9OX1JFRklORVJTID0ge1xyXG4gICAgICAgIG5hdkxpbmtEYXlDbGljazogaWRlbnRpdHksXHJcbiAgICAgICAgbmF2TGlua1dlZWtDbGljazogaWRlbnRpdHksXHJcbiAgICAgICAgZHVyYXRpb246IGNyZWF0ZUR1cmF0aW9uLFxyXG4gICAgICAgIGJvb3RzdHJhcEZvbnRBd2Vzb21lOiBpZGVudGl0eSxcclxuICAgICAgICBidXR0b25JY29uczogaWRlbnRpdHksXHJcbiAgICAgICAgY3VzdG9tQnV0dG9uczogaWRlbnRpdHksXHJcbiAgICAgICAgZGVmYXVsdEFsbERheUV2ZW50RHVyYXRpb246IGNyZWF0ZUR1cmF0aW9uLFxyXG4gICAgICAgIGRlZmF1bHRUaW1lZEV2ZW50RHVyYXRpb246IGNyZWF0ZUR1cmF0aW9uLFxyXG4gICAgICAgIG5leHREYXlUaHJlc2hvbGQ6IGNyZWF0ZUR1cmF0aW9uLFxyXG4gICAgICAgIHNjcm9sbFRpbWU6IGNyZWF0ZUR1cmF0aW9uLFxyXG4gICAgICAgIHNjcm9sbFRpbWVSZXNldDogQm9vbGVhbixcclxuICAgICAgICBzbG90TWluVGltZTogY3JlYXRlRHVyYXRpb24sXHJcbiAgICAgICAgc2xvdE1heFRpbWU6IGNyZWF0ZUR1cmF0aW9uLFxyXG4gICAgICAgIGRheVBvcG92ZXJGb3JtYXQ6IGNyZWF0ZUZvcm1hdHRlcixcclxuICAgICAgICBzbG90RHVyYXRpb246IGNyZWF0ZUR1cmF0aW9uLFxyXG4gICAgICAgIHNuYXBEdXJhdGlvbjogY3JlYXRlRHVyYXRpb24sXHJcbiAgICAgICAgaGVhZGVyVG9vbGJhcjogaWRlbnRpdHksXHJcbiAgICAgICAgZm9vdGVyVG9vbGJhcjogaWRlbnRpdHksXHJcbiAgICAgICAgZGVmYXVsdFJhbmdlU2VwYXJhdG9yOiBTdHJpbmcsXHJcbiAgICAgICAgdGl0bGVSYW5nZVNlcGFyYXRvcjogU3RyaW5nLFxyXG4gICAgICAgIGZvcmNlRXZlbnREdXJhdGlvbjogQm9vbGVhbixcclxuICAgICAgICBkYXlIZWFkZXJzOiBCb29sZWFuLFxyXG4gICAgICAgIGRheUhlYWRlckZvcm1hdDogY3JlYXRlRm9ybWF0dGVyLFxyXG4gICAgICAgIGRheUhlYWRlckNsYXNzTmFtZXM6IGlkZW50aXR5LFxyXG4gICAgICAgIGRheUhlYWRlckNvbnRlbnQ6IGlkZW50aXR5LFxyXG4gICAgICAgIGRheUhlYWRlckRpZE1vdW50OiBpZGVudGl0eSxcclxuICAgICAgICBkYXlIZWFkZXJXaWxsVW5tb3VudDogaWRlbnRpdHksXHJcbiAgICAgICAgZGF5Q2VsbENsYXNzTmFtZXM6IGlkZW50aXR5LFxyXG4gICAgICAgIGRheUNlbGxDb250ZW50OiBpZGVudGl0eSxcclxuICAgICAgICBkYXlDZWxsRGlkTW91bnQ6IGlkZW50aXR5LFxyXG4gICAgICAgIGRheUNlbGxXaWxsVW5tb3VudDogaWRlbnRpdHksXHJcbiAgICAgICAgaW5pdGlhbFZpZXc6IFN0cmluZyxcclxuICAgICAgICBhc3BlY3RSYXRpbzogTnVtYmVyLFxyXG4gICAgICAgIHdlZWtlbmRzOiBCb29sZWFuLFxyXG4gICAgICAgIHdlZWtOdW1iZXJDYWxjdWxhdGlvbjogaWRlbnRpdHksXHJcbiAgICAgICAgd2Vla051bWJlcnM6IEJvb2xlYW4sXHJcbiAgICAgICAgd2Vla051bWJlckNsYXNzTmFtZXM6IGlkZW50aXR5LFxyXG4gICAgICAgIHdlZWtOdW1iZXJDb250ZW50OiBpZGVudGl0eSxcclxuICAgICAgICB3ZWVrTnVtYmVyRGlkTW91bnQ6IGlkZW50aXR5LFxyXG4gICAgICAgIHdlZWtOdW1iZXJXaWxsVW5tb3VudDogaWRlbnRpdHksXHJcbiAgICAgICAgZWRpdGFibGU6IEJvb2xlYW4sXHJcbiAgICAgICAgdmlld0NsYXNzTmFtZXM6IGlkZW50aXR5LFxyXG4gICAgICAgIHZpZXdEaWRNb3VudDogaWRlbnRpdHksXHJcbiAgICAgICAgdmlld1dpbGxVbm1vdW50OiBpZGVudGl0eSxcclxuICAgICAgICBub3dJbmRpY2F0b3I6IEJvb2xlYW4sXHJcbiAgICAgICAgbm93SW5kaWNhdG9yQ2xhc3NOYW1lczogaWRlbnRpdHksXHJcbiAgICAgICAgbm93SW5kaWNhdG9yQ29udGVudDogaWRlbnRpdHksXHJcbiAgICAgICAgbm93SW5kaWNhdG9yRGlkTW91bnQ6IGlkZW50aXR5LFxyXG4gICAgICAgIG5vd0luZGljYXRvcldpbGxVbm1vdW50OiBpZGVudGl0eSxcclxuICAgICAgICBzaG93Tm9uQ3VycmVudERhdGVzOiBCb29sZWFuLFxyXG4gICAgICAgIGxhenlGZXRjaGluZzogQm9vbGVhbixcclxuICAgICAgICBzdGFydFBhcmFtOiBTdHJpbmcsXHJcbiAgICAgICAgZW5kUGFyYW06IFN0cmluZyxcclxuICAgICAgICB0aW1lWm9uZVBhcmFtOiBTdHJpbmcsXHJcbiAgICAgICAgdGltZVpvbmU6IFN0cmluZyxcclxuICAgICAgICBsb2NhbGVzOiBpZGVudGl0eSxcclxuICAgICAgICBsb2NhbGU6IGlkZW50aXR5LFxyXG4gICAgICAgIHRoZW1lU3lzdGVtOiBTdHJpbmcsXHJcbiAgICAgICAgZHJhZ1JldmVydER1cmF0aW9uOiBOdW1iZXIsXHJcbiAgICAgICAgZHJhZ1Njcm9sbDogQm9vbGVhbixcclxuICAgICAgICBhbGxEYXlNYWludGFpbkR1cmF0aW9uOiBCb29sZWFuLFxyXG4gICAgICAgIHVuc2VsZWN0QXV0bzogQm9vbGVhbixcclxuICAgICAgICBkcm9wQWNjZXB0OiBpZGVudGl0eSxcclxuICAgICAgICBldmVudE9yZGVyOiBwYXJzZUZpZWxkU3BlY3MsXHJcbiAgICAgICAgZXZlbnRPcmRlclN0cmljdDogQm9vbGVhbixcclxuICAgICAgICBoYW5kbGVXaW5kb3dSZXNpemU6IEJvb2xlYW4sXHJcbiAgICAgICAgd2luZG93UmVzaXplRGVsYXk6IE51bWJlcixcclxuICAgICAgICBsb25nUHJlc3NEZWxheTogTnVtYmVyLFxyXG4gICAgICAgIGV2ZW50RHJhZ01pbkRpc3RhbmNlOiBOdW1iZXIsXHJcbiAgICAgICAgZXhwYW5kUm93czogQm9vbGVhbixcclxuICAgICAgICBoZWlnaHQ6IGlkZW50aXR5LFxyXG4gICAgICAgIGNvbnRlbnRIZWlnaHQ6IGlkZW50aXR5LFxyXG4gICAgICAgIGRpcmVjdGlvbjogU3RyaW5nLFxyXG4gICAgICAgIHdlZWtOdW1iZXJGb3JtYXQ6IGNyZWF0ZUZvcm1hdHRlcixcclxuICAgICAgICBldmVudFJlc2l6YWJsZUZyb21TdGFydDogQm9vbGVhbixcclxuICAgICAgICBkaXNwbGF5RXZlbnRUaW1lOiBCb29sZWFuLFxyXG4gICAgICAgIGRpc3BsYXlFdmVudEVuZDogQm9vbGVhbixcclxuICAgICAgICB3ZWVrVGV4dDogU3RyaW5nLFxyXG4gICAgICAgIHdlZWtUZXh0TG9uZzogU3RyaW5nLFxyXG4gICAgICAgIHByb2dyZXNzaXZlRXZlbnRSZW5kZXJpbmc6IEJvb2xlYW4sXHJcbiAgICAgICAgYnVzaW5lc3NIb3VyczogaWRlbnRpdHksXHJcbiAgICAgICAgaW5pdGlhbERhdGU6IGlkZW50aXR5LFxyXG4gICAgICAgIG5vdzogaWRlbnRpdHksXHJcbiAgICAgICAgZXZlbnREYXRhVHJhbnNmb3JtOiBpZGVudGl0eSxcclxuICAgICAgICBzdGlja3lIZWFkZXJEYXRlczogaWRlbnRpdHksXHJcbiAgICAgICAgc3RpY2t5Rm9vdGVyU2Nyb2xsYmFyOiBpZGVudGl0eSxcclxuICAgICAgICB2aWV3SGVpZ2h0OiBpZGVudGl0eSxcclxuICAgICAgICBkZWZhdWx0QWxsRGF5OiBCb29sZWFuLFxyXG4gICAgICAgIGV2ZW50U291cmNlRmFpbHVyZTogaWRlbnRpdHksXHJcbiAgICAgICAgZXZlbnRTb3VyY2VTdWNjZXNzOiBpZGVudGl0eSxcclxuICAgICAgICBldmVudERpc3BsYXk6IFN0cmluZyxcclxuICAgICAgICBldmVudFN0YXJ0RWRpdGFibGU6IEJvb2xlYW4sXHJcbiAgICAgICAgZXZlbnREdXJhdGlvbkVkaXRhYmxlOiBCb29sZWFuLFxyXG4gICAgICAgIGV2ZW50T3ZlcmxhcDogaWRlbnRpdHksXHJcbiAgICAgICAgZXZlbnRDb25zdHJhaW50OiBpZGVudGl0eSxcclxuICAgICAgICBldmVudEFsbG93OiBpZGVudGl0eSxcclxuICAgICAgICBldmVudEJhY2tncm91bmRDb2xvcjogU3RyaW5nLFxyXG4gICAgICAgIGV2ZW50Qm9yZGVyQ29sb3I6IFN0cmluZyxcclxuICAgICAgICBldmVudFRleHRDb2xvcjogU3RyaW5nLFxyXG4gICAgICAgIGV2ZW50Q29sb3I6IFN0cmluZyxcclxuICAgICAgICBldmVudENsYXNzTmFtZXM6IGlkZW50aXR5LFxyXG4gICAgICAgIGV2ZW50Q29udGVudDogaWRlbnRpdHksXHJcbiAgICAgICAgZXZlbnREaWRNb3VudDogaWRlbnRpdHksXHJcbiAgICAgICAgZXZlbnRXaWxsVW5tb3VudDogaWRlbnRpdHksXHJcbiAgICAgICAgc2VsZWN0Q29uc3RyYWludDogaWRlbnRpdHksXHJcbiAgICAgICAgc2VsZWN0T3ZlcmxhcDogaWRlbnRpdHksXHJcbiAgICAgICAgc2VsZWN0QWxsb3c6IGlkZW50aXR5LFxyXG4gICAgICAgIGRyb3BwYWJsZTogQm9vbGVhbixcclxuICAgICAgICB1bnNlbGVjdENhbmNlbDogU3RyaW5nLFxyXG4gICAgICAgIHNsb3RMYWJlbEZvcm1hdDogaWRlbnRpdHksXHJcbiAgICAgICAgc2xvdExhbmVDbGFzc05hbWVzOiBpZGVudGl0eSxcclxuICAgICAgICBzbG90TGFuZUNvbnRlbnQ6IGlkZW50aXR5LFxyXG4gICAgICAgIHNsb3RMYW5lRGlkTW91bnQ6IGlkZW50aXR5LFxyXG4gICAgICAgIHNsb3RMYW5lV2lsbFVubW91bnQ6IGlkZW50aXR5LFxyXG4gICAgICAgIHNsb3RMYWJlbENsYXNzTmFtZXM6IGlkZW50aXR5LFxyXG4gICAgICAgIHNsb3RMYWJlbENvbnRlbnQ6IGlkZW50aXR5LFxyXG4gICAgICAgIHNsb3RMYWJlbERpZE1vdW50OiBpZGVudGl0eSxcclxuICAgICAgICBzbG90TGFiZWxXaWxsVW5tb3VudDogaWRlbnRpdHksXHJcbiAgICAgICAgZGF5TWF4RXZlbnRzOiBpZGVudGl0eSxcclxuICAgICAgICBkYXlNYXhFdmVudFJvd3M6IGlkZW50aXR5LFxyXG4gICAgICAgIGRheU1pbldpZHRoOiBOdW1iZXIsXHJcbiAgICAgICAgc2xvdExhYmVsSW50ZXJ2YWw6IGNyZWF0ZUR1cmF0aW9uLFxyXG4gICAgICAgIGFsbERheVRleHQ6IFN0cmluZyxcclxuICAgICAgICBhbGxEYXlDbGFzc05hbWVzOiBpZGVudGl0eSxcclxuICAgICAgICBhbGxEYXlDb250ZW50OiBpZGVudGl0eSxcclxuICAgICAgICBhbGxEYXlEaWRNb3VudDogaWRlbnRpdHksXHJcbiAgICAgICAgYWxsRGF5V2lsbFVubW91bnQ6IGlkZW50aXR5LFxyXG4gICAgICAgIHNsb3RNaW5XaWR0aDogTnVtYmVyLFxyXG4gICAgICAgIG5hdkxpbmtzOiBCb29sZWFuLFxyXG4gICAgICAgIGV2ZW50VGltZUZvcm1hdDogY3JlYXRlRm9ybWF0dGVyLFxyXG4gICAgICAgIHJlcmVuZGVyRGVsYXk6IE51bWJlcixcclxuICAgICAgICBtb3JlTGlua1RleHQ6IGlkZW50aXR5LFxyXG4gICAgICAgIG1vcmVMaW5rSGludDogaWRlbnRpdHksXHJcbiAgICAgICAgc2VsZWN0TWluRGlzdGFuY2U6IE51bWJlcixcclxuICAgICAgICBzZWxlY3RhYmxlOiBCb29sZWFuLFxyXG4gICAgICAgIHNlbGVjdExvbmdQcmVzc0RlbGF5OiBOdW1iZXIsXHJcbiAgICAgICAgZXZlbnRMb25nUHJlc3NEZWxheTogTnVtYmVyLFxyXG4gICAgICAgIHNlbGVjdE1pcnJvcjogQm9vbGVhbixcclxuICAgICAgICBldmVudE1heFN0YWNrOiBOdW1iZXIsXHJcbiAgICAgICAgZXZlbnRNaW5IZWlnaHQ6IE51bWJlcixcclxuICAgICAgICBldmVudE1pbldpZHRoOiBOdW1iZXIsXHJcbiAgICAgICAgZXZlbnRTaG9ydEhlaWdodDogTnVtYmVyLFxyXG4gICAgICAgIHNsb3RFdmVudE92ZXJsYXA6IEJvb2xlYW4sXHJcbiAgICAgICAgcGx1Z2luczogaWRlbnRpdHksXHJcbiAgICAgICAgZmlyc3REYXk6IE51bWJlcixcclxuICAgICAgICBkYXlDb3VudDogTnVtYmVyLFxyXG4gICAgICAgIGRhdGVBbGlnbm1lbnQ6IFN0cmluZyxcclxuICAgICAgICBkYXRlSW5jcmVtZW50OiBjcmVhdGVEdXJhdGlvbixcclxuICAgICAgICBoaWRkZW5EYXlzOiBpZGVudGl0eSxcclxuICAgICAgICBmaXhlZFdlZWtDb3VudDogQm9vbGVhbixcclxuICAgICAgICB2YWxpZFJhbmdlOiBpZGVudGl0eSxcclxuICAgICAgICB2aXNpYmxlUmFuZ2U6IGlkZW50aXR5LFxyXG4gICAgICAgIHRpdGxlRm9ybWF0OiBpZGVudGl0eSxcclxuICAgICAgICBldmVudEludGVyYWN0aXZlOiBCb29sZWFuLFxyXG4gICAgICAgIC8vIG9ubHkgdXNlZCBieSBsaXN0LXZpZXcsIGJ1dCBsYW5ndWFnZXMgZGVmaW5lIHRoZSB2YWx1ZSwgc28gd2UgbmVlZCBpdCBpbiBiYXNlIG9wdGlvbnNcclxuICAgICAgICBub0V2ZW50c1RleHQ6IFN0cmluZyxcclxuICAgICAgICB2aWV3SGludDogaWRlbnRpdHksXHJcbiAgICAgICAgbmF2TGlua0hpbnQ6IGlkZW50aXR5LFxyXG4gICAgICAgIGNsb3NlSGludDogU3RyaW5nLFxyXG4gICAgICAgIHRpbWVIaW50OiBTdHJpbmcsXHJcbiAgICAgICAgZXZlbnRIaW50OiBTdHJpbmcsXHJcbiAgICAgICAgbW9yZUxpbmtDbGljazogaWRlbnRpdHksXHJcbiAgICAgICAgbW9yZUxpbmtDbGFzc05hbWVzOiBpZGVudGl0eSxcclxuICAgICAgICBtb3JlTGlua0NvbnRlbnQ6IGlkZW50aXR5LFxyXG4gICAgICAgIG1vcmVMaW5rRGlkTW91bnQ6IGlkZW50aXR5LFxyXG4gICAgICAgIG1vcmVMaW5rV2lsbFVubW91bnQ6IGlkZW50aXR5LFxyXG4gICAgICAgIG1vbnRoU3RhcnRGb3JtYXQ6IGNyZWF0ZUZvcm1hdHRlcixcclxuICAgICAgICAvLyBmb3IgY29ubmVjdG9yc1xyXG4gICAgICAgIC8vIChjYW4ndCBiZSBwYXJ0IG9mIHBsdWdpbiBzeXN0ZW0gYi9jIG11c3QgYmUgcHJvdmlkZWQgYXQgcnVudGltZSlcclxuICAgICAgICBoYW5kbGVDdXN0b21SZW5kZXJpbmc6IGlkZW50aXR5LFxyXG4gICAgICAgIGN1c3RvbVJlbmRlcmluZ01ldGFNYXA6IGlkZW50aXR5LFxyXG4gICAgICAgIGN1c3RvbVJlbmRlcmluZ1JlcGxhY2VzRWw6IEJvb2xlYW4sXHJcbiAgICB9O1xyXG4gICAgLy8gZG8gTk9UIGdpdmUgYSB0eXBlIGhlcmUuIG5lZWQgYHR5cGVvZiBCQVNFX09QVElPTl9ERUZBVUxUU2AgdG8gZ2l2ZSByZWFsIHJlc3VsdHMuXHJcbiAgICAvLyByYXcgdmFsdWVzLlxyXG4gICAgY29uc3QgQkFTRV9PUFRJT05fREVGQVVMVFMgPSB7XHJcbiAgICAgICAgZXZlbnREaXNwbGF5OiAnYXV0bycsXHJcbiAgICAgICAgZGVmYXVsdFJhbmdlU2VwYXJhdG9yOiAnIC0gJyxcclxuICAgICAgICB0aXRsZVJhbmdlU2VwYXJhdG9yOiAnIFxcdTIwMTMgJyxcclxuICAgICAgICBkZWZhdWx0VGltZWRFdmVudER1cmF0aW9uOiAnMDE6MDA6MDAnLFxyXG4gICAgICAgIGRlZmF1bHRBbGxEYXlFdmVudER1cmF0aW9uOiB7IGRheTogMSB9LFxyXG4gICAgICAgIGZvcmNlRXZlbnREdXJhdGlvbjogZmFsc2UsXHJcbiAgICAgICAgbmV4dERheVRocmVzaG9sZDogJzAwOjAwOjAwJyxcclxuICAgICAgICBkYXlIZWFkZXJzOiB0cnVlLFxyXG4gICAgICAgIGluaXRpYWxWaWV3OiAnJyxcclxuICAgICAgICBhc3BlY3RSYXRpbzogMS4zNSxcclxuICAgICAgICBoZWFkZXJUb29sYmFyOiB7XHJcbiAgICAgICAgICAgIHN0YXJ0OiAndGl0bGUnLFxyXG4gICAgICAgICAgICBjZW50ZXI6ICcnLFxyXG4gICAgICAgICAgICBlbmQ6ICd0b2RheSBwcmV2LG5leHQnLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgd2Vla2VuZHM6IHRydWUsXHJcbiAgICAgICAgd2Vla051bWJlcnM6IGZhbHNlLFxyXG4gICAgICAgIHdlZWtOdW1iZXJDYWxjdWxhdGlvbjogJ2xvY2FsJyxcclxuICAgICAgICBlZGl0YWJsZTogZmFsc2UsXHJcbiAgICAgICAgbm93SW5kaWNhdG9yOiBmYWxzZSxcclxuICAgICAgICBzY3JvbGxUaW1lOiAnMDY6MDA6MDAnLFxyXG4gICAgICAgIHNjcm9sbFRpbWVSZXNldDogdHJ1ZSxcclxuICAgICAgICBzbG90TWluVGltZTogJzAwOjAwOjAwJyxcclxuICAgICAgICBzbG90TWF4VGltZTogJzI0OjAwOjAwJyxcclxuICAgICAgICBzaG93Tm9uQ3VycmVudERhdGVzOiB0cnVlLFxyXG4gICAgICAgIGxhenlGZXRjaGluZzogdHJ1ZSxcclxuICAgICAgICBzdGFydFBhcmFtOiAnc3RhcnQnLFxyXG4gICAgICAgIGVuZFBhcmFtOiAnZW5kJyxcclxuICAgICAgICB0aW1lWm9uZVBhcmFtOiAndGltZVpvbmUnLFxyXG4gICAgICAgIHRpbWVab25lOiAnbG9jYWwnLFxyXG4gICAgICAgIGxvY2FsZXM6IFtdLFxyXG4gICAgICAgIGxvY2FsZTogJycsXHJcbiAgICAgICAgdGhlbWVTeXN0ZW06ICdzdGFuZGFyZCcsXHJcbiAgICAgICAgZHJhZ1JldmVydER1cmF0aW9uOiA1MDAsXHJcbiAgICAgICAgZHJhZ1Njcm9sbDogdHJ1ZSxcclxuICAgICAgICBhbGxEYXlNYWludGFpbkR1cmF0aW9uOiBmYWxzZSxcclxuICAgICAgICB1bnNlbGVjdEF1dG86IHRydWUsXHJcbiAgICAgICAgZHJvcEFjY2VwdDogJyonLFxyXG4gICAgICAgIGV2ZW50T3JkZXI6ICdzdGFydCwtZHVyYXRpb24sYWxsRGF5LHRpdGxlJyxcclxuICAgICAgICBkYXlQb3BvdmVyRm9ybWF0OiB7IG1vbnRoOiAnbG9uZycsIGRheTogJ251bWVyaWMnLCB5ZWFyOiAnbnVtZXJpYycgfSxcclxuICAgICAgICBoYW5kbGVXaW5kb3dSZXNpemU6IHRydWUsXHJcbiAgICAgICAgd2luZG93UmVzaXplRGVsYXk6IDEwMCxcclxuICAgICAgICBsb25nUHJlc3NEZWxheTogMTAwMCxcclxuICAgICAgICBldmVudERyYWdNaW5EaXN0YW5jZTogNSxcclxuICAgICAgICBleHBhbmRSb3dzOiBmYWxzZSxcclxuICAgICAgICBuYXZMaW5rczogZmFsc2UsXHJcbiAgICAgICAgc2VsZWN0YWJsZTogZmFsc2UsXHJcbiAgICAgICAgZXZlbnRNaW5IZWlnaHQ6IDE1LFxyXG4gICAgICAgIGV2ZW50TWluV2lkdGg6IDMwLFxyXG4gICAgICAgIGV2ZW50U2hvcnRIZWlnaHQ6IDMwLFxyXG4gICAgICAgIG1vbnRoU3RhcnRGb3JtYXQ6IHsgbW9udGg6ICdsb25nJywgZGF5OiAnbnVtZXJpYycgfSxcclxuICAgIH07XHJcbiAgICAvLyBjYWxlbmRhciBsaXN0ZW5lcnNcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgY29uc3QgQ0FMRU5EQVJfTElTVEVORVJfUkVGSU5FUlMgPSB7XHJcbiAgICAgICAgZGF0ZXNTZXQ6IGlkZW50aXR5LFxyXG4gICAgICAgIGV2ZW50c1NldDogaWRlbnRpdHksXHJcbiAgICAgICAgZXZlbnRBZGQ6IGlkZW50aXR5LFxyXG4gICAgICAgIGV2ZW50Q2hhbmdlOiBpZGVudGl0eSxcclxuICAgICAgICBldmVudFJlbW92ZTogaWRlbnRpdHksXHJcbiAgICAgICAgd2luZG93UmVzaXplOiBpZGVudGl0eSxcclxuICAgICAgICBldmVudENsaWNrOiBpZGVudGl0eSxcclxuICAgICAgICBldmVudE1vdXNlRW50ZXI6IGlkZW50aXR5LFxyXG4gICAgICAgIGV2ZW50TW91c2VMZWF2ZTogaWRlbnRpdHksXHJcbiAgICAgICAgc2VsZWN0OiBpZGVudGl0eSxcclxuICAgICAgICB1bnNlbGVjdDogaWRlbnRpdHksXHJcbiAgICAgICAgbG9hZGluZzogaWRlbnRpdHksXHJcbiAgICAgICAgLy8gaW50ZXJuYWxcclxuICAgICAgICBfdW5tb3VudDogaWRlbnRpdHksXHJcbiAgICAgICAgX2JlZm9yZXByaW50OiBpZGVudGl0eSxcclxuICAgICAgICBfYWZ0ZXJwcmludDogaWRlbnRpdHksXHJcbiAgICAgICAgX25vRXZlbnREcm9wOiBpZGVudGl0eSxcclxuICAgICAgICBfbm9FdmVudFJlc2l6ZTogaWRlbnRpdHksXHJcbiAgICAgICAgX3Jlc2l6ZTogaWRlbnRpdHksXHJcbiAgICAgICAgX3Njcm9sbFJlcXVlc3Q6IGlkZW50aXR5LFxyXG4gICAgfTtcclxuICAgIC8vIGNhbGVuZGFyLXNwZWNpZmljIG9wdGlvbnNcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIGNvbnN0IENBTEVOREFSX09QVElPTl9SRUZJTkVSUyA9IHtcclxuICAgICAgICBidXR0b25UZXh0OiBpZGVudGl0eSxcclxuICAgICAgICBidXR0b25IaW50czogaWRlbnRpdHksXHJcbiAgICAgICAgdmlld3M6IGlkZW50aXR5LFxyXG4gICAgICAgIHBsdWdpbnM6IGlkZW50aXR5LFxyXG4gICAgICAgIGluaXRpYWxFdmVudHM6IGlkZW50aXR5LFxyXG4gICAgICAgIGV2ZW50czogaWRlbnRpdHksXHJcbiAgICAgICAgZXZlbnRTb3VyY2VzOiBpZGVudGl0eSxcclxuICAgIH07XHJcbiAgICBjb25zdCBDT01QTEVYX09QVElPTl9DT01QQVJBVE9SUyA9IHtcclxuICAgICAgICBoZWFkZXJUb29sYmFyOiBpc01heWJlT2JqZWN0c0VxdWFsLFxyXG4gICAgICAgIGZvb3RlclRvb2xiYXI6IGlzTWF5YmVPYmplY3RzRXF1YWwsXHJcbiAgICAgICAgYnV0dG9uVGV4dDogaXNNYXliZU9iamVjdHNFcXVhbCxcclxuICAgICAgICBidXR0b25IaW50czogaXNNYXliZU9iamVjdHNFcXVhbCxcclxuICAgICAgICBidXR0b25JY29uczogaXNNYXliZU9iamVjdHNFcXVhbCxcclxuICAgICAgICBkYXRlSW5jcmVtZW50OiBpc01heWJlT2JqZWN0c0VxdWFsLFxyXG4gICAgICAgIHBsdWdpbnM6IGlzTWF5YmVBcnJheXNFcXVhbCxcclxuICAgICAgICBldmVudHM6IGlzTWF5YmVBcnJheXNFcXVhbCxcclxuICAgICAgICBldmVudFNvdXJjZXM6IGlzTWF5YmVBcnJheXNFcXVhbCxcclxuICAgICAgICBbJ3Jlc291cmNlcyddOiBpc01heWJlQXJyYXlzRXF1YWwsXHJcbiAgICB9O1xyXG4gICAgZnVuY3Rpb24gaXNNYXliZU9iamVjdHNFcXVhbChhLCBiKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBhID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgYiA9PT0gJ29iamVjdCcgJiYgYSAmJiBiKSB7IC8vIGJvdGggbm9uLW51bGwgb2JqZWN0c1xyXG4gICAgICAgICAgICByZXR1cm4gaXNQcm9wc0VxdWFsKGEsIGIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYSA9PT0gYjtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGlzTWF5YmVBcnJheXNFcXVhbChhLCBiKSB7XHJcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYSkgJiYgQXJyYXkuaXNBcnJheShiKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gaXNBcnJheXNFcXVhbChhLCBiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGEgPT09IGI7XHJcbiAgICB9XHJcbiAgICAvLyB2aWV3LXNwZWNpZmljIG9wdGlvbnNcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgY29uc3QgVklFV19PUFRJT05fUkVGSU5FUlMgPSB7XHJcbiAgICAgICAgdHlwZTogU3RyaW5nLFxyXG4gICAgICAgIGNvbXBvbmVudDogaWRlbnRpdHksXHJcbiAgICAgICAgYnV0dG9uVGV4dDogU3RyaW5nLFxyXG4gICAgICAgIGJ1dHRvblRleHRLZXk6IFN0cmluZyxcclxuICAgICAgICBkYXRlUHJvZmlsZUdlbmVyYXRvckNsYXNzOiBpZGVudGl0eSxcclxuICAgICAgICB1c2VzTWluTWF4VGltZTogQm9vbGVhbixcclxuICAgICAgICBjbGFzc05hbWVzOiBpZGVudGl0eSxcclxuICAgICAgICBjb250ZW50OiBpZGVudGl0eSxcclxuICAgICAgICBkaWRNb3VudDogaWRlbnRpdHksXHJcbiAgICAgICAgd2lsbFVubW91bnQ6IGlkZW50aXR5LFxyXG4gICAgfTtcclxuICAgIC8vIHV0aWwgZnVuY3NcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIGZ1bmN0aW9uIG1lcmdlUmF3T3B0aW9ucyhvcHRpb25TZXRzKSB7XHJcbiAgICAgICAgcmV0dXJuIG1lcmdlUHJvcHMob3B0aW9uU2V0cywgQ09NUExFWF9PUFRJT05fQ09NUEFSQVRPUlMpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gcmVmaW5lUHJvcHMoaW5wdXQsIHJlZmluZXJzKSB7XHJcbiAgICAgICAgbGV0IHJlZmluZWQgPSB7fTtcclxuICAgICAgICBsZXQgZXh0cmEgPSB7fTtcclxuICAgICAgICBmb3IgKGxldCBwcm9wTmFtZSBpbiByZWZpbmVycykge1xyXG4gICAgICAgICAgICBpZiAocHJvcE5hbWUgaW4gaW5wdXQpIHtcclxuICAgICAgICAgICAgICAgIHJlZmluZWRbcHJvcE5hbWVdID0gcmVmaW5lcnNbcHJvcE5hbWVdKGlucHV0W3Byb3BOYW1lXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChsZXQgcHJvcE5hbWUgaW4gaW5wdXQpIHtcclxuICAgICAgICAgICAgaWYgKCEocHJvcE5hbWUgaW4gcmVmaW5lcnMpKSB7XHJcbiAgICAgICAgICAgICAgICBleHRyYVtwcm9wTmFtZV0gPSBpbnB1dFtwcm9wTmFtZV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHsgcmVmaW5lZCwgZXh0cmEgfTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGlkZW50aXR5KHJhdykge1xyXG4gICAgICAgIHJldHVybiByYXc7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gY3JlYXRlRXZlbnRJbnN0YW5jZShkZWZJZCwgcmFuZ2UsIGZvcmNlZFN0YXJ0VHpvLCBmb3JjZWRFbmRUem8pIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBpbnN0YW5jZUlkOiBndWlkKCksXHJcbiAgICAgICAgICAgIGRlZklkLFxyXG4gICAgICAgICAgICByYW5nZSxcclxuICAgICAgICAgICAgZm9yY2VkU3RhcnRUem86IGZvcmNlZFN0YXJ0VHpvID09IG51bGwgPyBudWxsIDogZm9yY2VkU3RhcnRUem8sXHJcbiAgICAgICAgICAgIGZvcmNlZEVuZFR6bzogZm9yY2VkRW5kVHpvID09IG51bGwgPyBudWxsIDogZm9yY2VkRW5kVHpvLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcGFyc2VSZWN1cnJpbmcocmVmaW5lZCwgZGVmYXVsdEFsbERheSwgZGF0ZUVudiwgcmVjdXJyaW5nVHlwZXMpIHtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlY3VycmluZ1R5cGVzLmxlbmd0aDsgaSArPSAxKSB7XHJcbiAgICAgICAgICAgIGxldCBwYXJzZWQgPSByZWN1cnJpbmdUeXBlc1tpXS5wYXJzZShyZWZpbmVkLCBkYXRlRW52KTtcclxuICAgICAgICAgICAgaWYgKHBhcnNlZCkge1xyXG4gICAgICAgICAgICAgICAgbGV0IHsgYWxsRGF5IH0gPSByZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgaWYgKGFsbERheSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWxsRGF5ID0gZGVmYXVsdEFsbERheTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYWxsRGF5ID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWxsRGF5ID0gcGFyc2VkLmFsbERheUd1ZXNzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWxsRGF5ID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbERheSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICBhbGxEYXksXHJcbiAgICAgICAgICAgICAgICAgICAgZHVyYXRpb246IHBhcnNlZC5kdXJhdGlvbixcclxuICAgICAgICAgICAgICAgICAgICB0eXBlRGF0YTogcGFyc2VkLnR5cGVEYXRhLFxyXG4gICAgICAgICAgICAgICAgICAgIHR5cGVJZDogaSxcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBleHBhbmRSZWN1cnJpbmcoZXZlbnRTdG9yZSwgZnJhbWluZ1JhbmdlLCBjb250ZXh0KSB7XHJcbiAgICAgICAgbGV0IHsgZGF0ZUVudiwgcGx1Z2luSG9va3MsIG9wdGlvbnMgfSA9IGNvbnRleHQ7XHJcbiAgICAgICAgbGV0IHsgZGVmcywgaW5zdGFuY2VzIH0gPSBldmVudFN0b3JlO1xyXG4gICAgICAgIC8vIHJlbW92ZSBleGlzdGluZyByZWN1cnJpbmcgaW5zdGFuY2VzXHJcbiAgICAgICAgLy8gVE9ETzogYmFkLiBhbHdheXMgZXhwYW5kIGV2ZW50cyBhcyBhIHNlY29uZCBzdGVwXHJcbiAgICAgICAgaW5zdGFuY2VzID0gZmlsdGVySGFzaChpbnN0YW5jZXMsIChpbnN0YW5jZSkgPT4gIWRlZnNbaW5zdGFuY2UuZGVmSWRdLnJlY3VycmluZ0RlZik7XHJcbiAgICAgICAgZm9yIChsZXQgZGVmSWQgaW4gZGVmcykge1xyXG4gICAgICAgICAgICBsZXQgZGVmID0gZGVmc1tkZWZJZF07XHJcbiAgICAgICAgICAgIGlmIChkZWYucmVjdXJyaW5nRGVmKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgeyBkdXJhdGlvbiB9ID0gZGVmLnJlY3VycmluZ0RlZjtcclxuICAgICAgICAgICAgICAgIGlmICghZHVyYXRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbiA9IGRlZi5hbGxEYXkgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRlZmF1bHRBbGxEYXlFdmVudER1cmF0aW9uIDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kZWZhdWx0VGltZWRFdmVudER1cmF0aW9uO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbGV0IHN0YXJ0cyA9IGV4cGFuZFJlY3VycmluZ1JhbmdlcyhkZWYsIGR1cmF0aW9uLCBmcmFtaW5nUmFuZ2UsIGRhdGVFbnYsIHBsdWdpbkhvb2tzLnJlY3VycmluZ1R5cGVzKTtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IHN0YXJ0IG9mIHN0YXJ0cykge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBpbnN0YW5jZSA9IGNyZWF0ZUV2ZW50SW5zdGFuY2UoZGVmSWQsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogZGF0ZUVudi5hZGQoc3RhcnQsIGR1cmF0aW9uKSxcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZXNbaW5zdGFuY2UuaW5zdGFuY2VJZF0gPSBpbnN0YW5jZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4geyBkZWZzLCBpbnN0YW5jZXMgfTtcclxuICAgIH1cclxuICAgIC8qXHJcbiAgICBFdmVudCBNVVNUIGhhdmUgYSByZWN1cnJpbmdEZWZcclxuICAgICovXHJcbiAgICBmdW5jdGlvbiBleHBhbmRSZWN1cnJpbmdSYW5nZXMoZXZlbnREZWYsIGR1cmF0aW9uLCBmcmFtaW5nUmFuZ2UsIGRhdGVFbnYsIHJlY3VycmluZ1R5cGVzKSB7XHJcbiAgICAgICAgbGV0IHR5cGVEZWYgPSByZWN1cnJpbmdUeXBlc1tldmVudERlZi5yZWN1cnJpbmdEZWYudHlwZUlkXTtcclxuICAgICAgICBsZXQgbWFya2VycyA9IHR5cGVEZWYuZXhwYW5kKGV2ZW50RGVmLnJlY3VycmluZ0RlZi50eXBlRGF0YSwge1xyXG4gICAgICAgICAgICBzdGFydDogZGF0ZUVudi5zdWJ0cmFjdChmcmFtaW5nUmFuZ2Uuc3RhcnQsIGR1cmF0aW9uKSxcclxuICAgICAgICAgICAgZW5kOiBmcmFtaW5nUmFuZ2UuZW5kLFxyXG4gICAgICAgIH0sIGRhdGVFbnYpO1xyXG4gICAgICAgIC8vIHRoZSByZWN1cnJlbmNlIHBsdWdpbnMgZG9uJ3QgZ3VhcmFudGVlIHRoYXQgYWxsLWRheSBldmVudHMgYXJlIHN0YXJ0LW9mLWRheSwgc28gd2UgaGF2ZSB0b1xyXG4gICAgICAgIGlmIChldmVudERlZi5hbGxEYXkpIHtcclxuICAgICAgICAgICAgbWFya2VycyA9IG1hcmtlcnMubWFwKHN0YXJ0T2ZEYXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbWFya2VycztcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBwYXJzZUV2ZW50cyhyYXdFdmVudHMsIGV2ZW50U291cmNlLCBjb250ZXh0LCBhbGxvd09wZW5SYW5nZSwgZGVmSWRNYXAsIGluc3RhbmNlSWRNYXApIHtcclxuICAgICAgICBsZXQgZXZlbnRTdG9yZSA9IGNyZWF0ZUVtcHR5RXZlbnRTdG9yZSgpO1xyXG4gICAgICAgIGxldCBldmVudFJlZmluZXJzID0gYnVpbGRFdmVudFJlZmluZXJzKGNvbnRleHQpO1xyXG4gICAgICAgIGZvciAobGV0IHJhd0V2ZW50IG9mIHJhd0V2ZW50cykge1xyXG4gICAgICAgICAgICBsZXQgdHVwbGUgPSBwYXJzZUV2ZW50KHJhd0V2ZW50LCBldmVudFNvdXJjZSwgY29udGV4dCwgYWxsb3dPcGVuUmFuZ2UsIGV2ZW50UmVmaW5lcnMsIGRlZklkTWFwLCBpbnN0YW5jZUlkTWFwKTtcclxuICAgICAgICAgICAgaWYgKHR1cGxlKSB7XHJcbiAgICAgICAgICAgICAgICBldmVudFR1cGxlVG9TdG9yZSh0dXBsZSwgZXZlbnRTdG9yZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGV2ZW50U3RvcmU7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBldmVudFR1cGxlVG9TdG9yZSh0dXBsZSwgZXZlbnRTdG9yZSA9IGNyZWF0ZUVtcHR5RXZlbnRTdG9yZSgpKSB7XHJcbiAgICAgICAgZXZlbnRTdG9yZS5kZWZzW3R1cGxlLmRlZi5kZWZJZF0gPSB0dXBsZS5kZWY7XHJcbiAgICAgICAgaWYgKHR1cGxlLmluc3RhbmNlKSB7XHJcbiAgICAgICAgICAgIGV2ZW50U3RvcmUuaW5zdGFuY2VzW3R1cGxlLmluc3RhbmNlLmluc3RhbmNlSWRdID0gdHVwbGUuaW5zdGFuY2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBldmVudFN0b3JlO1xyXG4gICAgfVxyXG4gICAgLy8gcmV0cmlldmVzIGV2ZW50cyB0aGF0IGhhdmUgdGhlIHNhbWUgZ3JvdXBJZCBhcyB0aGUgaW5zdGFuY2Ugc3BlY2lmaWVkIGJ5IGBpbnN0YW5jZUlkYFxyXG4gICAgLy8gb3IgdGhleSBhcmUgdGhlIHNhbWUgYXMgdGhlIGluc3RhbmNlLlxyXG4gICAgLy8gd2h5IG1pZ2h0IGluc3RhbmNlSWQgbm90IGJlIGluIHRoZSBzdG9yZT8gYW4gZXZlbnQgZnJvbSBhbm90aGVyIGNhbGVuZGFyP1xyXG4gICAgZnVuY3Rpb24gZ2V0UmVsZXZhbnRFdmVudHMoZXZlbnRTdG9yZSwgaW5zdGFuY2VJZCkge1xyXG4gICAgICAgIGxldCBpbnN0YW5jZSA9IGV2ZW50U3RvcmUuaW5zdGFuY2VzW2luc3RhbmNlSWRdO1xyXG4gICAgICAgIGlmIChpbnN0YW5jZSkge1xyXG4gICAgICAgICAgICBsZXQgZGVmID0gZXZlbnRTdG9yZS5kZWZzW2luc3RhbmNlLmRlZklkXTtcclxuICAgICAgICAgICAgLy8gZ2V0IGV2ZW50cy9pbnN0YW5jZXMgd2l0aCBzYW1lIGdyb3VwXHJcbiAgICAgICAgICAgIGxldCBuZXdTdG9yZSA9IGZpbHRlckV2ZW50U3RvcmVEZWZzKGV2ZW50U3RvcmUsIChsb29rRGVmKSA9PiBpc0V2ZW50RGVmc0dyb3VwZWQoZGVmLCBsb29rRGVmKSk7XHJcbiAgICAgICAgICAgIC8vIGFkZCB0aGUgb3JpZ2luYWxcclxuICAgICAgICAgICAgLy8gVE9ETzogd2lzaCB3ZSBjb3VsZCB1c2UgZXZlbnRUdXBsZVRvU3RvcmUgb3Igc29tZXRoaW5nIGxpa2UgaXRcclxuICAgICAgICAgICAgbmV3U3RvcmUuZGVmc1tkZWYuZGVmSWRdID0gZGVmO1xyXG4gICAgICAgICAgICBuZXdTdG9yZS5pbnN0YW5jZXNbaW5zdGFuY2UuaW5zdGFuY2VJZF0gPSBpbnN0YW5jZTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ld1N0b3JlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY3JlYXRlRW1wdHlFdmVudFN0b3JlKCk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBpc0V2ZW50RGVmc0dyb3VwZWQoZGVmMCwgZGVmMSkge1xyXG4gICAgICAgIHJldHVybiBCb29sZWFuKGRlZjAuZ3JvdXBJZCAmJiBkZWYwLmdyb3VwSWQgPT09IGRlZjEuZ3JvdXBJZCk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBjcmVhdGVFbXB0eUV2ZW50U3RvcmUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHsgZGVmczoge30sIGluc3RhbmNlczoge30gfTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIG1lcmdlRXZlbnRTdG9yZXMoc3RvcmUwLCBzdG9yZTEpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBkZWZzOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHN0b3JlMC5kZWZzKSwgc3RvcmUxLmRlZnMpLFxyXG4gICAgICAgICAgICBpbnN0YW5jZXM6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc3RvcmUwLmluc3RhbmNlcyksIHN0b3JlMS5pbnN0YW5jZXMpLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBmaWx0ZXJFdmVudFN0b3JlRGVmcyhldmVudFN0b3JlLCBmaWx0ZXJGdW5jKSB7XHJcbiAgICAgICAgbGV0IGRlZnMgPSBmaWx0ZXJIYXNoKGV2ZW50U3RvcmUuZGVmcywgZmlsdGVyRnVuYyk7XHJcbiAgICAgICAgbGV0IGluc3RhbmNlcyA9IGZpbHRlckhhc2goZXZlbnRTdG9yZS5pbnN0YW5jZXMsIChpbnN0YW5jZSkgPT4gKGRlZnNbaW5zdGFuY2UuZGVmSWRdIC8vIHN0aWxsIGV4aXN0cz9cclxuICAgICAgICApKTtcclxuICAgICAgICByZXR1cm4geyBkZWZzLCBpbnN0YW5jZXMgfTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGV4Y2x1ZGVTdWJFdmVudFN0b3JlKG1hc3Rlciwgc3ViKSB7XHJcbiAgICAgICAgbGV0IHsgZGVmcywgaW5zdGFuY2VzIH0gPSBtYXN0ZXI7XHJcbiAgICAgICAgbGV0IGZpbHRlcmVkRGVmcyA9IHt9O1xyXG4gICAgICAgIGxldCBmaWx0ZXJlZEluc3RhbmNlcyA9IHt9O1xyXG4gICAgICAgIGZvciAobGV0IGRlZklkIGluIGRlZnMpIHtcclxuICAgICAgICAgICAgaWYgKCFzdWIuZGVmc1tkZWZJZF0pIHsgLy8gbm90IGV4cGxpY2l0bHkgZXhjbHVkZWRcclxuICAgICAgICAgICAgICAgIGZpbHRlcmVkRGVmc1tkZWZJZF0gPSBkZWZzW2RlZklkXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGxldCBpbnN0YW5jZUlkIGluIGluc3RhbmNlcykge1xyXG4gICAgICAgICAgICBpZiAoIXN1Yi5pbnN0YW5jZXNbaW5zdGFuY2VJZF0gJiYgLy8gbm90IGV4cGxpY2l0bHkgZXhjbHVkZWRcclxuICAgICAgICAgICAgICAgIGZpbHRlcmVkRGVmc1tpbnN0YW5jZXNbaW5zdGFuY2VJZF0uZGVmSWRdIC8vIGRlZiB3YXNuJ3QgZmlsdGVyZWQgYXdheVxyXG4gICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICAgIGZpbHRlcmVkSW5zdGFuY2VzW2luc3RhbmNlSWRdID0gaW5zdGFuY2VzW2luc3RhbmNlSWRdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGRlZnM6IGZpbHRlcmVkRGVmcyxcclxuICAgICAgICAgICAgaW5zdGFuY2VzOiBmaWx0ZXJlZEluc3RhbmNlcyxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZUNvbnN0cmFpbnQoaW5wdXQsIGNvbnRleHQpIHtcclxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlRXZlbnRzKGlucHV0LCBudWxsLCBjb250ZXh0LCB0cnVlKTsgLy8gYWxsb3dPcGVuUmFuZ2U9dHJ1ZVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnb2JqZWN0JyAmJiBpbnB1dCkgeyAvLyBub24tbnVsbCBvYmplY3RcclxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlRXZlbnRzKFtpbnB1dF0sIG51bGwsIGNvbnRleHQsIHRydWUpOyAvLyBhbGxvd09wZW5SYW5nZT10cnVlXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpbnB1dCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBTdHJpbmcoaW5wdXQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBwYXJzZUNsYXNzTmFtZXMocmF3KSB7XHJcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmF3KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gcmF3O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mIHJhdyA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJhdy5zcGxpdCgvXFxzKy8pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVE9ETzogYmV0dGVyIGNhbGxlZCBcIkV2ZW50U2V0dGluZ3NcIiBvciBcIkV2ZW50Q29uZmlnXCJcclxuICAgIC8vIFRPRE86IG1vdmUgdGhpcyBmaWxlIGludG8gc3RydWN0c1xyXG4gICAgLy8gVE9ETzogc2VwYXJhdGUgY29uc3RyYWludC9vdmVybGFwL2FsbG93LCBiZWNhdXNlIHNlbGVjdGlvbiB1c2VzIG9ubHkgdGhhdCwgbm90IG90aGVyIHByb3BzXHJcbiAgICBjb25zdCBFVkVOVF9VSV9SRUZJTkVSUyA9IHtcclxuICAgICAgICBkaXNwbGF5OiBTdHJpbmcsXHJcbiAgICAgICAgZWRpdGFibGU6IEJvb2xlYW4sXHJcbiAgICAgICAgc3RhcnRFZGl0YWJsZTogQm9vbGVhbixcclxuICAgICAgICBkdXJhdGlvbkVkaXRhYmxlOiBCb29sZWFuLFxyXG4gICAgICAgIGNvbnN0cmFpbnQ6IGlkZW50aXR5LFxyXG4gICAgICAgIG92ZXJsYXA6IGlkZW50aXR5LFxyXG4gICAgICAgIGFsbG93OiBpZGVudGl0eSxcclxuICAgICAgICBjbGFzc05hbWU6IHBhcnNlQ2xhc3NOYW1lcyxcclxuICAgICAgICBjbGFzc05hbWVzOiBwYXJzZUNsYXNzTmFtZXMsXHJcbiAgICAgICAgY29sb3I6IFN0cmluZyxcclxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFN0cmluZyxcclxuICAgICAgICBib3JkZXJDb2xvcjogU3RyaW5nLFxyXG4gICAgICAgIHRleHRDb2xvcjogU3RyaW5nLFxyXG4gICAgfTtcclxuICAgIGNvbnN0IEVNUFRZX0VWRU5UX1VJID0ge1xyXG4gICAgICAgIGRpc3BsYXk6IG51bGwsXHJcbiAgICAgICAgc3RhcnRFZGl0YWJsZTogbnVsbCxcclxuICAgICAgICBkdXJhdGlvbkVkaXRhYmxlOiBudWxsLFxyXG4gICAgICAgIGNvbnN0cmFpbnRzOiBbXSxcclxuICAgICAgICBvdmVybGFwOiBudWxsLFxyXG4gICAgICAgIGFsbG93czogW10sXHJcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiAnJyxcclxuICAgICAgICBib3JkZXJDb2xvcjogJycsXHJcbiAgICAgICAgdGV4dENvbG9yOiAnJyxcclxuICAgICAgICBjbGFzc05hbWVzOiBbXSxcclxuICAgIH07XHJcbiAgICBmdW5jdGlvbiBjcmVhdGVFdmVudFVpKHJlZmluZWQsIGNvbnRleHQpIHtcclxuICAgICAgICBsZXQgY29uc3RyYWludCA9IG5vcm1hbGl6ZUNvbnN0cmFpbnQocmVmaW5lZC5jb25zdHJhaW50LCBjb250ZXh0KTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBkaXNwbGF5OiByZWZpbmVkLmRpc3BsYXkgfHwgbnVsbCxcclxuICAgICAgICAgICAgc3RhcnRFZGl0YWJsZTogcmVmaW5lZC5zdGFydEVkaXRhYmxlICE9IG51bGwgPyByZWZpbmVkLnN0YXJ0RWRpdGFibGUgOiByZWZpbmVkLmVkaXRhYmxlLFxyXG4gICAgICAgICAgICBkdXJhdGlvbkVkaXRhYmxlOiByZWZpbmVkLmR1cmF0aW9uRWRpdGFibGUgIT0gbnVsbCA/IHJlZmluZWQuZHVyYXRpb25FZGl0YWJsZSA6IHJlZmluZWQuZWRpdGFibGUsXHJcbiAgICAgICAgICAgIGNvbnN0cmFpbnRzOiBjb25zdHJhaW50ICE9IG51bGwgPyBbY29uc3RyYWludF0gOiBbXSxcclxuICAgICAgICAgICAgb3ZlcmxhcDogcmVmaW5lZC5vdmVybGFwICE9IG51bGwgPyByZWZpbmVkLm92ZXJsYXAgOiBudWxsLFxyXG4gICAgICAgICAgICBhbGxvd3M6IHJlZmluZWQuYWxsb3cgIT0gbnVsbCA/IFtyZWZpbmVkLmFsbG93XSA6IFtdLFxyXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IHJlZmluZWQuYmFja2dyb3VuZENvbG9yIHx8IHJlZmluZWQuY29sb3IgfHwgJycsXHJcbiAgICAgICAgICAgIGJvcmRlckNvbG9yOiByZWZpbmVkLmJvcmRlckNvbG9yIHx8IHJlZmluZWQuY29sb3IgfHwgJycsXHJcbiAgICAgICAgICAgIHRleHRDb2xvcjogcmVmaW5lZC50ZXh0Q29sb3IgfHwgJycsXHJcbiAgICAgICAgICAgIGNsYXNzTmFtZXM6IChyZWZpbmVkLmNsYXNzTmFtZSB8fCBbXSkuY29uY2F0KHJlZmluZWQuY2xhc3NOYW1lcyB8fCBbXSksIC8vIGpvaW4gc2luZ3VsYXIgYW5kIHBsdXJhbFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICAvLyBUT0RPOiBwcmV2ZW50IGFnYWluc3QgcHJvYmxlbXMgd2l0aCA8MiBhcmdzIVxyXG4gICAgZnVuY3Rpb24gY29tYmluZUV2ZW50VWlzKHVpcykge1xyXG4gICAgICAgIHJldHVybiB1aXMucmVkdWNlKGNvbWJpbmVUd29FdmVudFVpcywgRU1QVFlfRVZFTlRfVUkpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gY29tYmluZVR3b0V2ZW50VWlzKGl0ZW0wLCBpdGVtMSkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGRpc3BsYXk6IGl0ZW0xLmRpc3BsYXkgIT0gbnVsbCA/IGl0ZW0xLmRpc3BsYXkgOiBpdGVtMC5kaXNwbGF5LFxyXG4gICAgICAgICAgICBzdGFydEVkaXRhYmxlOiBpdGVtMS5zdGFydEVkaXRhYmxlICE9IG51bGwgPyBpdGVtMS5zdGFydEVkaXRhYmxlIDogaXRlbTAuc3RhcnRFZGl0YWJsZSxcclxuICAgICAgICAgICAgZHVyYXRpb25FZGl0YWJsZTogaXRlbTEuZHVyYXRpb25FZGl0YWJsZSAhPSBudWxsID8gaXRlbTEuZHVyYXRpb25FZGl0YWJsZSA6IGl0ZW0wLmR1cmF0aW9uRWRpdGFibGUsXHJcbiAgICAgICAgICAgIGNvbnN0cmFpbnRzOiBpdGVtMC5jb25zdHJhaW50cy5jb25jYXQoaXRlbTEuY29uc3RyYWludHMpLFxyXG4gICAgICAgICAgICBvdmVybGFwOiB0eXBlb2YgaXRlbTEub3ZlcmxhcCA9PT0gJ2Jvb2xlYW4nID8gaXRlbTEub3ZlcmxhcCA6IGl0ZW0wLm92ZXJsYXAsXHJcbiAgICAgICAgICAgIGFsbG93czogaXRlbTAuYWxsb3dzLmNvbmNhdChpdGVtMS5hbGxvd3MpLFxyXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGl0ZW0xLmJhY2tncm91bmRDb2xvciB8fCBpdGVtMC5iYWNrZ3JvdW5kQ29sb3IsXHJcbiAgICAgICAgICAgIGJvcmRlckNvbG9yOiBpdGVtMS5ib3JkZXJDb2xvciB8fCBpdGVtMC5ib3JkZXJDb2xvcixcclxuICAgICAgICAgICAgdGV4dENvbG9yOiBpdGVtMS50ZXh0Q29sb3IgfHwgaXRlbTAudGV4dENvbG9yLFxyXG4gICAgICAgICAgICBjbGFzc05hbWVzOiBpdGVtMC5jbGFzc05hbWVzLmNvbmNhdChpdGVtMS5jbGFzc05hbWVzKSxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IEVWRU5UX05PTl9EQVRFX1JFRklORVJTID0ge1xyXG4gICAgICAgIGlkOiBTdHJpbmcsXHJcbiAgICAgICAgZ3JvdXBJZDogU3RyaW5nLFxyXG4gICAgICAgIHRpdGxlOiBTdHJpbmcsXHJcbiAgICAgICAgdXJsOiBTdHJpbmcsXHJcbiAgICAgICAgaW50ZXJhY3RpdmU6IEJvb2xlYW4sXHJcbiAgICB9O1xyXG4gICAgY29uc3QgRVZFTlRfREFURV9SRUZJTkVSUyA9IHtcclxuICAgICAgICBzdGFydDogaWRlbnRpdHksXHJcbiAgICAgICAgZW5kOiBpZGVudGl0eSxcclxuICAgICAgICBkYXRlOiBpZGVudGl0eSxcclxuICAgICAgICBhbGxEYXk6IEJvb2xlYW4sXHJcbiAgICB9O1xyXG4gICAgY29uc3QgRVZFTlRfUkVGSU5FUlMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgRVZFTlRfTk9OX0RBVEVfUkVGSU5FUlMpLCBFVkVOVF9EQVRFX1JFRklORVJTKSwgeyBleHRlbmRlZFByb3BzOiBpZGVudGl0eSB9KTtcclxuICAgIGZ1bmN0aW9uIHBhcnNlRXZlbnQocmF3LCBldmVudFNvdXJjZSwgY29udGV4dCwgYWxsb3dPcGVuUmFuZ2UsIHJlZmluZXJzID0gYnVpbGRFdmVudFJlZmluZXJzKGNvbnRleHQpLCBkZWZJZE1hcCwgaW5zdGFuY2VJZE1hcCkge1xyXG4gICAgICAgIGxldCB7IHJlZmluZWQsIGV4dHJhIH0gPSByZWZpbmVFdmVudERlZihyYXcsIGNvbnRleHQsIHJlZmluZXJzKTtcclxuICAgICAgICBsZXQgZGVmYXVsdEFsbERheSA9IGNvbXB1dGVJc0RlZmF1bHRBbGxEYXkoZXZlbnRTb3VyY2UsIGNvbnRleHQpO1xyXG4gICAgICAgIGxldCByZWN1cnJpbmdSZXMgPSBwYXJzZVJlY3VycmluZyhyZWZpbmVkLCBkZWZhdWx0QWxsRGF5LCBjb250ZXh0LmRhdGVFbnYsIGNvbnRleHQucGx1Z2luSG9va3MucmVjdXJyaW5nVHlwZXMpO1xyXG4gICAgICAgIGlmIChyZWN1cnJpbmdSZXMpIHtcclxuICAgICAgICAgICAgbGV0IGRlZiA9IHBhcnNlRXZlbnREZWYocmVmaW5lZCwgZXh0cmEsIGV2ZW50U291cmNlID8gZXZlbnRTb3VyY2Uuc291cmNlSWQgOiAnJywgcmVjdXJyaW5nUmVzLmFsbERheSwgQm9vbGVhbihyZWN1cnJpbmdSZXMuZHVyYXRpb24pLCBjb250ZXh0LCBkZWZJZE1hcCk7XHJcbiAgICAgICAgICAgIGRlZi5yZWN1cnJpbmdEZWYgPSB7XHJcbiAgICAgICAgICAgICAgICB0eXBlSWQ6IHJlY3VycmluZ1Jlcy50eXBlSWQsXHJcbiAgICAgICAgICAgICAgICB0eXBlRGF0YTogcmVjdXJyaW5nUmVzLnR5cGVEYXRhLFxyXG4gICAgICAgICAgICAgICAgZHVyYXRpb246IHJlY3VycmluZ1Jlcy5kdXJhdGlvbixcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIHsgZGVmLCBpbnN0YW5jZTogbnVsbCB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgc2luZ2xlUmVzID0gcGFyc2VTaW5nbGUocmVmaW5lZCwgZGVmYXVsdEFsbERheSwgY29udGV4dCwgYWxsb3dPcGVuUmFuZ2UpO1xyXG4gICAgICAgIGlmIChzaW5nbGVSZXMpIHtcclxuICAgICAgICAgICAgbGV0IGRlZiA9IHBhcnNlRXZlbnREZWYocmVmaW5lZCwgZXh0cmEsIGV2ZW50U291cmNlID8gZXZlbnRTb3VyY2Uuc291cmNlSWQgOiAnJywgc2luZ2xlUmVzLmFsbERheSwgc2luZ2xlUmVzLmhhc0VuZCwgY29udGV4dCwgZGVmSWRNYXApO1xyXG4gICAgICAgICAgICBsZXQgaW5zdGFuY2UgPSBjcmVhdGVFdmVudEluc3RhbmNlKGRlZi5kZWZJZCwgc2luZ2xlUmVzLnJhbmdlLCBzaW5nbGVSZXMuZm9yY2VkU3RhcnRUem8sIHNpbmdsZVJlcy5mb3JjZWRFbmRUem8pO1xyXG4gICAgICAgICAgICBpZiAoaW5zdGFuY2VJZE1hcCAmJiBkZWYucHVibGljSWQgJiYgaW5zdGFuY2VJZE1hcFtkZWYucHVibGljSWRdKSB7XHJcbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5pbnN0YW5jZUlkID0gaW5zdGFuY2VJZE1hcFtkZWYucHVibGljSWRdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB7IGRlZiwgaW5zdGFuY2UgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiByZWZpbmVFdmVudERlZihyYXcsIGNvbnRleHQsIHJlZmluZXJzID0gYnVpbGRFdmVudFJlZmluZXJzKGNvbnRleHQpKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlZmluZVByb3BzKHJhdywgcmVmaW5lcnMpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYnVpbGRFdmVudFJlZmluZXJzKGNvbnRleHQpIHtcclxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIEVWRU5UX1VJX1JFRklORVJTKSwgRVZFTlRfUkVGSU5FUlMpLCBjb250ZXh0LnBsdWdpbkhvb2tzLmV2ZW50UmVmaW5lcnMpO1xyXG4gICAgfVxyXG4gICAgLypcclxuICAgIFdpbGwgTk9UIHBvcHVsYXRlIGV4dGVuZGVkUHJvcHMgd2l0aCB0aGUgbGVmdG92ZXIgcHJvcGVydGllcy5cclxuICAgIFdpbGwgTk9UIHBvcHVsYXRlIGRhdGUtcmVsYXRlZCBwcm9wcy5cclxuICAgICovXHJcbiAgICBmdW5jdGlvbiBwYXJzZUV2ZW50RGVmKHJlZmluZWQsIGV4dHJhLCBzb3VyY2VJZCwgYWxsRGF5LCBoYXNFbmQsIGNvbnRleHQsIGRlZklkTWFwKSB7XHJcbiAgICAgICAgbGV0IGRlZiA9IHtcclxuICAgICAgICAgICAgdGl0bGU6IHJlZmluZWQudGl0bGUgfHwgJycsXHJcbiAgICAgICAgICAgIGdyb3VwSWQ6IHJlZmluZWQuZ3JvdXBJZCB8fCAnJyxcclxuICAgICAgICAgICAgcHVibGljSWQ6IHJlZmluZWQuaWQgfHwgJycsXHJcbiAgICAgICAgICAgIHVybDogcmVmaW5lZC51cmwgfHwgJycsXHJcbiAgICAgICAgICAgIHJlY3VycmluZ0RlZjogbnVsbCxcclxuICAgICAgICAgICAgZGVmSWQ6ICgoZGVmSWRNYXAgJiYgcmVmaW5lZC5pZCkgPyBkZWZJZE1hcFtyZWZpbmVkLmlkXSA6ICcnKSB8fCBndWlkKCksXHJcbiAgICAgICAgICAgIHNvdXJjZUlkLFxyXG4gICAgICAgICAgICBhbGxEYXksXHJcbiAgICAgICAgICAgIGhhc0VuZCxcclxuICAgICAgICAgICAgaW50ZXJhY3RpdmU6IHJlZmluZWQuaW50ZXJhY3RpdmUsXHJcbiAgICAgICAgICAgIHVpOiBjcmVhdGVFdmVudFVpKHJlZmluZWQsIGNvbnRleHQpLFxyXG4gICAgICAgICAgICBleHRlbmRlZFByb3BzOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIChyZWZpbmVkLmV4dGVuZGVkUHJvcHMgfHwge30pKSwgZXh0cmEpLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgZm9yIChsZXQgbWVtYmVyQWRkZXIgb2YgY29udGV4dC5wbHVnaW5Ib29rcy5ldmVudERlZk1lbWJlckFkZGVycykge1xyXG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKGRlZiwgbWVtYmVyQWRkZXIocmVmaW5lZCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBoZWxwIG91dCBFdmVudEltcGwgZnJvbSBoYXZpbmcgdXNlciBtb2RpZnkgcHJvcHNcclxuICAgICAgICBPYmplY3QuZnJlZXplKGRlZi51aS5jbGFzc05hbWVzKTtcclxuICAgICAgICBPYmplY3QuZnJlZXplKGRlZi5leHRlbmRlZFByb3BzKTtcclxuICAgICAgICByZXR1cm4gZGVmO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gcGFyc2VTaW5nbGUocmVmaW5lZCwgZGVmYXVsdEFsbERheSwgY29udGV4dCwgYWxsb3dPcGVuUmFuZ2UpIHtcclxuICAgICAgICBsZXQgeyBhbGxEYXkgfSA9IHJlZmluZWQ7XHJcbiAgICAgICAgbGV0IHN0YXJ0TWV0YTtcclxuICAgICAgICBsZXQgc3RhcnRNYXJrZXIgPSBudWxsO1xyXG4gICAgICAgIGxldCBoYXNFbmQgPSBmYWxzZTtcclxuICAgICAgICBsZXQgZW5kTWV0YTtcclxuICAgICAgICBsZXQgZW5kTWFya2VyID0gbnVsbDtcclxuICAgICAgICBsZXQgc3RhcnRJbnB1dCA9IHJlZmluZWQuc3RhcnQgIT0gbnVsbCA/IHJlZmluZWQuc3RhcnQgOiByZWZpbmVkLmRhdGU7XHJcbiAgICAgICAgc3RhcnRNZXRhID0gY29udGV4dC5kYXRlRW52LmNyZWF0ZU1hcmtlck1ldGEoc3RhcnRJbnB1dCk7XHJcbiAgICAgICAgaWYgKHN0YXJ0TWV0YSkge1xyXG4gICAgICAgICAgICBzdGFydE1hcmtlciA9IHN0YXJ0TWV0YS5tYXJrZXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKCFhbGxvd09wZW5SYW5nZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJlZmluZWQuZW5kICE9IG51bGwpIHtcclxuICAgICAgICAgICAgZW5kTWV0YSA9IGNvbnRleHQuZGF0ZUVudi5jcmVhdGVNYXJrZXJNZXRhKHJlZmluZWQuZW5kKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGFsbERheSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGlmIChkZWZhdWx0QWxsRGF5ICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGFsbERheSA9IGRlZmF1bHRBbGxEYXk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBmYWxsIGJhY2sgdG8gdGhlIGRhdGUgcHJvcHMgTEFTVFxyXG4gICAgICAgICAgICAgICAgYWxsRGF5ID0gKCFzdGFydE1ldGEgfHwgc3RhcnRNZXRhLmlzVGltZVVuc3BlY2lmaWVkKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICghZW5kTWV0YSB8fCBlbmRNZXRhLmlzVGltZVVuc3BlY2lmaWVkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYWxsRGF5ICYmIHN0YXJ0TWFya2VyKSB7XHJcbiAgICAgICAgICAgIHN0YXJ0TWFya2VyID0gc3RhcnRPZkRheShzdGFydE1hcmtlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChlbmRNZXRhKSB7XHJcbiAgICAgICAgICAgIGVuZE1hcmtlciA9IGVuZE1ldGEubWFya2VyO1xyXG4gICAgICAgICAgICBpZiAoYWxsRGF5KSB7XHJcbiAgICAgICAgICAgICAgICBlbmRNYXJrZXIgPSBzdGFydE9mRGF5KGVuZE1hcmtlcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHN0YXJ0TWFya2VyICYmIGVuZE1hcmtlciA8PSBzdGFydE1hcmtlcikge1xyXG4gICAgICAgICAgICAgICAgZW5kTWFya2VyID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZW5kTWFya2VyKSB7XHJcbiAgICAgICAgICAgIGhhc0VuZCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKCFhbGxvd09wZW5SYW5nZSkge1xyXG4gICAgICAgICAgICBoYXNFbmQgPSBjb250ZXh0Lm9wdGlvbnMuZm9yY2VFdmVudER1cmF0aW9uIHx8IGZhbHNlO1xyXG4gICAgICAgICAgICBlbmRNYXJrZXIgPSBjb250ZXh0LmRhdGVFbnYuYWRkKHN0YXJ0TWFya2VyLCBhbGxEYXkgP1xyXG4gICAgICAgICAgICAgICAgY29udGV4dC5vcHRpb25zLmRlZmF1bHRBbGxEYXlFdmVudER1cmF0aW9uIDpcclxuICAgICAgICAgICAgICAgIGNvbnRleHQub3B0aW9ucy5kZWZhdWx0VGltZWRFdmVudER1cmF0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgYWxsRGF5LFxyXG4gICAgICAgICAgICBoYXNFbmQsXHJcbiAgICAgICAgICAgIHJhbmdlOiB7IHN0YXJ0OiBzdGFydE1hcmtlciwgZW5kOiBlbmRNYXJrZXIgfSxcclxuICAgICAgICAgICAgZm9yY2VkU3RhcnRUem86IHN0YXJ0TWV0YSA/IHN0YXJ0TWV0YS5mb3JjZWRUem8gOiBudWxsLFxyXG4gICAgICAgICAgICBmb3JjZWRFbmRUem86IGVuZE1ldGEgPyBlbmRNZXRhLmZvcmNlZFR6byA6IG51bGwsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGNvbXB1dGVJc0RlZmF1bHRBbGxEYXkoZXZlbnRTb3VyY2UsIGNvbnRleHQpIHtcclxuICAgICAgICBsZXQgcmVzID0gbnVsbDtcclxuICAgICAgICBpZiAoZXZlbnRTb3VyY2UpIHtcclxuICAgICAgICAgICAgcmVzID0gZXZlbnRTb3VyY2UuZGVmYXVsdEFsbERheTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJlcyA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJlcyA9IGNvbnRleHQub3B0aW9ucy5kZWZhdWx0QWxsRGF5O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IERFRl9ERUZBVUxUUyA9IHtcclxuICAgICAgICBzdGFydFRpbWU6ICcwOTowMCcsXHJcbiAgICAgICAgZW5kVGltZTogJzE3OjAwJyxcclxuICAgICAgICBkYXlzT2ZXZWVrOiBbMSwgMiwgMywgNCwgNV0sXHJcbiAgICAgICAgZGlzcGxheTogJ2ludmVyc2UtYmFja2dyb3VuZCcsXHJcbiAgICAgICAgY2xhc3NOYW1lczogJ2ZjLW5vbi1idXNpbmVzcycsXHJcbiAgICAgICAgZ3JvdXBJZDogJ19idXNpbmVzc0hvdXJzJywgLy8gc28gbXVsdGlwbGUgZGVmcyBnZXQgZ3JvdXBlZFxyXG4gICAgfTtcclxuICAgIC8qXHJcbiAgICBUT0RPOiBwYXNzIGFyb3VuZCBhcyBFdmVudERlZkhhc2ghISFcclxuICAgICovXHJcbiAgICBmdW5jdGlvbiBwYXJzZUJ1c2luZXNzSG91cnMoaW5wdXQsIGNvbnRleHQpIHtcclxuICAgICAgICByZXR1cm4gcGFyc2VFdmVudHMocmVmaW5lSW5wdXRzKGlucHV0KSwgbnVsbCwgY29udGV4dCk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiByZWZpbmVJbnB1dHMoaW5wdXQpIHtcclxuICAgICAgICBsZXQgcmF3RGVmcztcclxuICAgICAgICBpZiAoaW5wdXQgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgcmF3RGVmcyA9IFt7fV07IC8vIHdpbGwgZ2V0IERFRl9ERUZBVUxUUyB2ZXJiYXRpbVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGlucHV0KSkge1xyXG4gICAgICAgICAgICAvLyBpZiBzcGVjaWZ5aW5nIGFuIGFycmF5LCBldmVyeSBzdWItZGVmaW5pdGlvbiBORUVEUyBhIGRheS1vZi13ZWVrXHJcbiAgICAgICAgICAgIHJhd0RlZnMgPSBpbnB1dC5maWx0ZXIoKHJhd0RlZikgPT4gcmF3RGVmLmRheXNPZldlZWspO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09ICdvYmplY3QnICYmIGlucHV0KSB7IC8vIG5vbi1udWxsIG9iamVjdFxyXG4gICAgICAgICAgICByYXdEZWZzID0gW2lucHV0XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7IC8vIGlzIHByb2JhYmx5IGZhbHNlXHJcbiAgICAgICAgICAgIHJhd0RlZnMgPSBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmF3RGVmcyA9IHJhd0RlZnMubWFwKChyYXdEZWYpID0+IChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIERFRl9ERUZBVUxUUyksIHJhd0RlZikpKTtcclxuICAgICAgICByZXR1cm4gcmF3RGVmcztcclxuICAgIH1cclxuXHJcbiAgICAvKiBEYXRlIHN0dWZmIHRoYXQgZG9lc24ndCBiZWxvbmcgaW4gZGF0ZWxpYiBjb3JlXHJcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgIC8vIGdpdmVuIGEgdGltZWQgcmFuZ2UsIGNvbXB1dGVzIGFuIGFsbC1kYXkgcmFuZ2UgdGhhdCBoYXMgdGhlIHNhbWUgZXhhY3QgZHVyYXRpb24sXHJcbiAgICAvLyBidXQgd2hvc2Ugc3RhcnQgdGltZSBpcyBhbGlnbmVkIHdpdGggdGhlIHN0YXJ0IG9mIHRoZSBkYXkuXHJcbiAgICBmdW5jdGlvbiBjb21wdXRlQWxpZ25lZERheVJhbmdlKHRpbWVkUmFuZ2UpIHtcclxuICAgICAgICBsZXQgZGF5Q250ID0gTWF0aC5mbG9vcihkaWZmRGF5cyh0aW1lZFJhbmdlLnN0YXJ0LCB0aW1lZFJhbmdlLmVuZCkpIHx8IDE7XHJcbiAgICAgICAgbGV0IHN0YXJ0ID0gc3RhcnRPZkRheSh0aW1lZFJhbmdlLnN0YXJ0KTtcclxuICAgICAgICBsZXQgZW5kID0gYWRkRGF5cyhzdGFydCwgZGF5Q250KTtcclxuICAgICAgICByZXR1cm4geyBzdGFydCwgZW5kIH07XHJcbiAgICB9XHJcbiAgICAvLyBnaXZlbiBhIHRpbWVkIHJhbmdlLCBjb21wdXRlcyBhbiBhbGwtZGF5IHJhbmdlIGJhc2VkIG9uIGhvdyBmb3IgdGhlIGVuZCBkYXRlIGJsZWVkcyBpbnRvIHRoZSBuZXh0IGRheVxyXG4gICAgLy8gVE9ETzogZ2l2ZSBuZXh0RGF5VGhyZXNob2xkIGEgZGVmYXVsdCBhcmdcclxuICAgIGZ1bmN0aW9uIGNvbXB1dGVWaXNpYmxlRGF5UmFuZ2UodGltZWRSYW5nZSwgbmV4dERheVRocmVzaG9sZCA9IGNyZWF0ZUR1cmF0aW9uKDApKSB7XHJcbiAgICAgICAgbGV0IHN0YXJ0RGF5ID0gbnVsbDtcclxuICAgICAgICBsZXQgZW5kRGF5ID0gbnVsbDtcclxuICAgICAgICBpZiAodGltZWRSYW5nZS5lbmQpIHtcclxuICAgICAgICAgICAgZW5kRGF5ID0gc3RhcnRPZkRheSh0aW1lZFJhbmdlLmVuZCk7XHJcbiAgICAgICAgICAgIGxldCBlbmRUaW1lTVMgPSB0aW1lZFJhbmdlLmVuZC52YWx1ZU9mKCkgLSBlbmREYXkudmFsdWVPZigpOyAvLyAjIG9mIG1pbGxpc2Vjb25kcyBpbnRvIGBlbmREYXlgXHJcbiAgICAgICAgICAgIC8vIElmIHRoZSBlbmQgdGltZSBpcyBhY3R1YWxseSBpbmNsdXNpdmVseSBwYXJ0IG9mIHRoZSBuZXh0IGRheSBhbmQgaXMgZXF1YWwgdG8gb3JcclxuICAgICAgICAgICAgLy8gYmV5b25kIHRoZSBuZXh0IGRheSB0aHJlc2hvbGQsIGFkanVzdCB0aGUgZW5kIHRvIGJlIHRoZSBleGNsdXNpdmUgZW5kIG9mIGBlbmREYXlgLlxyXG4gICAgICAgICAgICAvLyBPdGhlcndpc2UsIGxlYXZpbmcgaXQgYXMgaW5jbHVzaXZlIHdpbGwgY2F1c2UgaXQgdG8gZXhjbHVkZSBgZW5kRGF5YC5cclxuICAgICAgICAgICAgaWYgKGVuZFRpbWVNUyAmJiBlbmRUaW1lTVMgPj0gYXNSb3VnaE1zKG5leHREYXlUaHJlc2hvbGQpKSB7XHJcbiAgICAgICAgICAgICAgICBlbmREYXkgPSBhZGREYXlzKGVuZERheSwgMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRpbWVkUmFuZ2Uuc3RhcnQpIHtcclxuICAgICAgICAgICAgc3RhcnREYXkgPSBzdGFydE9mRGF5KHRpbWVkUmFuZ2Uuc3RhcnQpOyAvLyB0aGUgYmVnaW5uaW5nIG9mIHRoZSBkYXkgdGhlIHJhbmdlIHN0YXJ0c1xyXG4gICAgICAgICAgICAvLyBJZiBlbmQgaXMgd2l0aGluIGBzdGFydERheWAgYnV0IG5vdCBwYXN0IG5leHREYXlUaHJlc2hvbGQsIGFzc2lnbiB0aGUgZGVmYXVsdCBkdXJhdGlvbiBvZiBvbmUgZGF5LlxyXG4gICAgICAgICAgICBpZiAoZW5kRGF5ICYmIGVuZERheSA8PSBzdGFydERheSkge1xyXG4gICAgICAgICAgICAgICAgZW5kRGF5ID0gYWRkRGF5cyhzdGFydERheSwgMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHsgc3RhcnQ6IHN0YXJ0RGF5LCBlbmQ6IGVuZERheSB9O1xyXG4gICAgfVxyXG4gICAgLy8gc3BhbnMgZnJvbSBvbmUgZGF5IGludG8gYW5vdGhlcj9cclxuICAgIGZ1bmN0aW9uIGlzTXVsdGlEYXlSYW5nZShyYW5nZSkge1xyXG4gICAgICAgIGxldCB2aXNpYmxlUmFuZ2UgPSBjb21wdXRlVmlzaWJsZURheVJhbmdlKHJhbmdlKTtcclxuICAgICAgICByZXR1cm4gZGlmZkRheXModmlzaWJsZVJhbmdlLnN0YXJ0LCB2aXNpYmxlUmFuZ2UuZW5kKSA+IDE7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBkaWZmRGF0ZXMoZGF0ZTAsIGRhdGUxLCBkYXRlRW52LCBsYXJnZVVuaXQpIHtcclxuICAgICAgICBpZiAobGFyZ2VVbml0ID09PSAneWVhcicpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUR1cmF0aW9uKGRhdGVFbnYuZGlmZldob2xlWWVhcnMoZGF0ZTAsIGRhdGUxKSwgJ3llYXInKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxhcmdlVW5pdCA9PT0gJ21vbnRoJykge1xyXG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlRHVyYXRpb24oZGF0ZUVudi5kaWZmV2hvbGVNb250aHMoZGF0ZTAsIGRhdGUxKSwgJ21vbnRoJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkaWZmRGF5QW5kVGltZShkYXRlMCwgZGF0ZTEpOyAvLyByZXR1cm5zIGEgZHVyYXRpb25cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBwb2ludEluc2lkZVJlY3QocG9pbnQsIHJlY3QpIHtcclxuICAgICAgICByZXR1cm4gcG9pbnQubGVmdCA+PSByZWN0LmxlZnQgJiZcclxuICAgICAgICAgICAgcG9pbnQubGVmdCA8IHJlY3QucmlnaHQgJiZcclxuICAgICAgICAgICAgcG9pbnQudG9wID49IHJlY3QudG9wICYmXHJcbiAgICAgICAgICAgIHBvaW50LnRvcCA8IHJlY3QuYm90dG9tO1xyXG4gICAgfVxyXG4gICAgLy8gUmV0dXJucyBhIG5ldyByZWN0YW5nbGUgdGhhdCBpcyB0aGUgaW50ZXJzZWN0aW9uIG9mIHRoZSB0d28gcmVjdGFuZ2xlcy4gSWYgdGhleSBkb24ndCBpbnRlcnNlY3QsIHJldHVybnMgZmFsc2VcclxuICAgIGZ1bmN0aW9uIGludGVyc2VjdFJlY3RzKHJlY3QxLCByZWN0Mikge1xyXG4gICAgICAgIGxldCByZXMgPSB7XHJcbiAgICAgICAgICAgIGxlZnQ6IE1hdGgubWF4KHJlY3QxLmxlZnQsIHJlY3QyLmxlZnQpLFxyXG4gICAgICAgICAgICByaWdodDogTWF0aC5taW4ocmVjdDEucmlnaHQsIHJlY3QyLnJpZ2h0KSxcclxuICAgICAgICAgICAgdG9wOiBNYXRoLm1heChyZWN0MS50b3AsIHJlY3QyLnRvcCksXHJcbiAgICAgICAgICAgIGJvdHRvbTogTWF0aC5taW4ocmVjdDEuYm90dG9tLCByZWN0Mi5ib3R0b20pLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKHJlcy5sZWZ0IDwgcmVzLnJpZ2h0ICYmIHJlcy50b3AgPCByZXMuYm90dG9tKSB7XHJcbiAgICAgICAgICAgIHJldHVybiByZXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHRyYW5zbGF0ZVJlY3QocmVjdCwgZGVsdGFYLCBkZWx0YVkpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBsZWZ0OiByZWN0LmxlZnQgKyBkZWx0YVgsXHJcbiAgICAgICAgICAgIHJpZ2h0OiByZWN0LnJpZ2h0ICsgZGVsdGFYLFxyXG4gICAgICAgICAgICB0b3A6IHJlY3QudG9wICsgZGVsdGFZLFxyXG4gICAgICAgICAgICBib3R0b206IHJlY3QuYm90dG9tICsgZGVsdGFZLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICAvLyBSZXR1cm5zIGEgbmV3IHBvaW50IHRoYXQgd2lsbCBoYXZlIGJlZW4gbW92ZWQgdG8gcmVzaWRlIHdpdGhpbiB0aGUgZ2l2ZW4gcmVjdGFuZ2xlXHJcbiAgICBmdW5jdGlvbiBjb25zdHJhaW5Qb2ludChwb2ludCwgcmVjdCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGxlZnQ6IE1hdGgubWluKE1hdGgubWF4KHBvaW50LmxlZnQsIHJlY3QubGVmdCksIHJlY3QucmlnaHQpLFxyXG4gICAgICAgICAgICB0b3A6IE1hdGgubWluKE1hdGgubWF4KHBvaW50LnRvcCwgcmVjdC50b3ApLCByZWN0LmJvdHRvbSksXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIC8vIFJldHVybnMgYSBwb2ludCB0aGF0IGlzIHRoZSBjZW50ZXIgb2YgdGhlIGdpdmVuIHJlY3RhbmdsZVxyXG4gICAgZnVuY3Rpb24gZ2V0UmVjdENlbnRlcihyZWN0KSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgbGVmdDogKHJlY3QubGVmdCArIHJlY3QucmlnaHQpIC8gMixcclxuICAgICAgICAgICAgdG9wOiAocmVjdC50b3AgKyByZWN0LmJvdHRvbSkgLyAyLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICAvLyBTdWJ0cmFjdHMgcG9pbnQyJ3MgY29vcmRpbmF0ZXMgZnJvbSBwb2ludDEncyBjb29yZGluYXRlcywgcmV0dXJuaW5nIGEgZGVsdGFcclxuICAgIGZ1bmN0aW9uIGRpZmZQb2ludHMocG9pbnQxLCBwb2ludDIpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBsZWZ0OiBwb2ludDEubGVmdCAtIHBvaW50Mi5sZWZ0LFxyXG4gICAgICAgICAgICB0b3A6IHBvaW50MS50b3AgLSBwb2ludDIudG9wLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IGNhblZHcm93V2l0aGluQ2VsbDtcclxuICAgIGZ1bmN0aW9uIGdldENhblZHcm93V2l0aGluQ2VsbCgpIHtcclxuICAgICAgICBpZiAoY2FuVkdyb3dXaXRoaW5DZWxsID09IG51bGwpIHtcclxuICAgICAgICAgICAgY2FuVkdyb3dXaXRoaW5DZWxsID0gY29tcHV0ZUNhblZHcm93V2l0aGluQ2VsbCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY2FuVkdyb3dXaXRoaW5DZWxsO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gY29tcHV0ZUNhblZHcm93V2l0aGluQ2VsbCgpIHtcclxuICAgICAgICAvLyBmb3IgU1NSLCBiZWNhdXNlIHRoaXMgZnVuY3Rpb24gaXMgY2FsbCBpbW1lZGlhdGVseSBhdCB0b3AtbGV2ZWxcclxuICAgICAgICAvLyBUT0RPOiBqdXN0IG1ha2UgdGhpcyBsb2dpYyBleGVjdXRlIHRvcC1sZXZlbCwgaW1tZWRpYXRlbHksIGluc3RlYWQgb2YgZG9pbmcgbGF6aWx5XHJcbiAgICAgICAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgICAgIGVsLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcclxuICAgICAgICBlbC5zdHlsZS50b3AgPSAnMHB4JztcclxuICAgICAgICBlbC5zdHlsZS5sZWZ0ID0gJzBweCc7XHJcbiAgICAgICAgZWwuaW5uZXJIVE1MID0gJzx0YWJsZT48dHI+PHRkPjxkaXY+PC9kaXY+PC90ZD48L3RyPjwvdGFibGU+JztcclxuICAgICAgICBlbC5xdWVyeVNlbGVjdG9yKCd0YWJsZScpLnN0eWxlLmhlaWdodCA9ICcxMDBweCc7XHJcbiAgICAgICAgZWwucXVlcnlTZWxlY3RvcignZGl2Jykuc3R5bGUuaGVpZ2h0ID0gJzEwMCUnO1xyXG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZWwpO1xyXG4gICAgICAgIGxldCBkaXYgPSBlbC5xdWVyeVNlbGVjdG9yKCdkaXYnKTtcclxuICAgICAgICBsZXQgcG9zc2libGUgPSBkaXYub2Zmc2V0SGVpZ2h0ID4gMDtcclxuICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGVsKTtcclxuICAgICAgICByZXR1cm4gcG9zc2libGU7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgRU1QVFlfRVZFTlRfU1RPUkUgPSBjcmVhdGVFbXB0eUV2ZW50U3RvcmUoKTsgLy8gZm9yIHB1cmVjb21wb25lbnRzLiBUT0RPOiBrZWVwIGVsc2V3aGVyZVxyXG4gICAgY2xhc3MgU3BsaXR0ZXIge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgICAgICB0aGlzLmdldEtleXNGb3JFdmVudERlZnMgPSBtZW1vaXplKHRoaXMuX2dldEtleXNGb3JFdmVudERlZnMpO1xyXG4gICAgICAgICAgICB0aGlzLnNwbGl0RGF0ZVNlbGVjdGlvbiA9IG1lbW9pemUodGhpcy5fc3BsaXREYXRlU3Bhbik7XHJcbiAgICAgICAgICAgIHRoaXMuc3BsaXRFdmVudFN0b3JlID0gbWVtb2l6ZSh0aGlzLl9zcGxpdEV2ZW50U3RvcmUpO1xyXG4gICAgICAgICAgICB0aGlzLnNwbGl0SW5kaXZpZHVhbFVpID0gbWVtb2l6ZSh0aGlzLl9zcGxpdEluZGl2aWR1YWxVaSk7XHJcbiAgICAgICAgICAgIHRoaXMuc3BsaXRFdmVudERyYWcgPSBtZW1vaXplKHRoaXMuX3NwbGl0SW50ZXJhY3Rpb24pO1xyXG4gICAgICAgICAgICB0aGlzLnNwbGl0RXZlbnRSZXNpemUgPSBtZW1vaXplKHRoaXMuX3NwbGl0SW50ZXJhY3Rpb24pO1xyXG4gICAgICAgICAgICB0aGlzLmV2ZW50VWlCdWlsZGVycyA9IHt9OyAvLyBUT0RPOiB0eXBlc2NyaXB0IHByb3RlY3Rpb25cclxuICAgICAgICB9XHJcbiAgICAgICAgc3BsaXRQcm9wcyhwcm9wcykge1xyXG4gICAgICAgICAgICBsZXQga2V5SW5mb3MgPSB0aGlzLmdldEtleUluZm8ocHJvcHMpO1xyXG4gICAgICAgICAgICBsZXQgZGVmS2V5cyA9IHRoaXMuZ2V0S2V5c0ZvckV2ZW50RGVmcyhwcm9wcy5ldmVudFN0b3JlKTtcclxuICAgICAgICAgICAgbGV0IGRhdGVTZWxlY3Rpb25zID0gdGhpcy5zcGxpdERhdGVTZWxlY3Rpb24ocHJvcHMuZGF0ZVNlbGVjdGlvbik7XHJcbiAgICAgICAgICAgIGxldCBpbmRpdmlkdWFsVWkgPSB0aGlzLnNwbGl0SW5kaXZpZHVhbFVpKHByb3BzLmV2ZW50VWlCYXNlcywgZGVmS2V5cyk7IC8vIHRoZSBpbmRpdmlkdWFsICpiYXNlcypcclxuICAgICAgICAgICAgbGV0IGV2ZW50U3RvcmVzID0gdGhpcy5zcGxpdEV2ZW50U3RvcmUocHJvcHMuZXZlbnRTdG9yZSwgZGVmS2V5cyk7XHJcbiAgICAgICAgICAgIGxldCBldmVudERyYWdzID0gdGhpcy5zcGxpdEV2ZW50RHJhZyhwcm9wcy5ldmVudERyYWcpO1xyXG4gICAgICAgICAgICBsZXQgZXZlbnRSZXNpemVzID0gdGhpcy5zcGxpdEV2ZW50UmVzaXplKHByb3BzLmV2ZW50UmVzaXplKTtcclxuICAgICAgICAgICAgbGV0IHNwbGl0UHJvcHMgPSB7fTtcclxuICAgICAgICAgICAgdGhpcy5ldmVudFVpQnVpbGRlcnMgPSBtYXBIYXNoKGtleUluZm9zLCAoaW5mbywga2V5KSA9PiB0aGlzLmV2ZW50VWlCdWlsZGVyc1trZXldIHx8IG1lbW9pemUoYnVpbGRFdmVudFVpRm9yS2V5KSk7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGtleSBpbiBrZXlJbmZvcykge1xyXG4gICAgICAgICAgICAgICAgbGV0IGtleUluZm8gPSBrZXlJbmZvc1trZXldO1xyXG4gICAgICAgICAgICAgICAgbGV0IGV2ZW50U3RvcmUgPSBldmVudFN0b3Jlc1trZXldIHx8IEVNUFRZX0VWRU5UX1NUT1JFO1xyXG4gICAgICAgICAgICAgICAgbGV0IGJ1aWxkRXZlbnRVaSA9IHRoaXMuZXZlbnRVaUJ1aWxkZXJzW2tleV07XHJcbiAgICAgICAgICAgICAgICBzcGxpdFByb3BzW2tleV0gPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnVzaW5lc3NIb3Vyczoga2V5SW5mby5idXNpbmVzc0hvdXJzIHx8IHByb3BzLmJ1c2luZXNzSG91cnMsXHJcbiAgICAgICAgICAgICAgICAgICAgZGF0ZVNlbGVjdGlvbjogZGF0ZVNlbGVjdGlvbnNba2V5XSB8fCBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50U3RvcmUsXHJcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRVaUJhc2VzOiBidWlsZEV2ZW50VWkocHJvcHMuZXZlbnRVaUJhc2VzWycnXSwga2V5SW5mby51aSwgaW5kaXZpZHVhbFVpW2tleV0pLFxyXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50U2VsZWN0aW9uOiBldmVudFN0b3JlLmluc3RhbmNlc1twcm9wcy5ldmVudFNlbGVjdGlvbl0gPyBwcm9wcy5ldmVudFNlbGVjdGlvbiA6ICcnLFxyXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50RHJhZzogZXZlbnREcmFnc1trZXldIHx8IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRSZXNpemU6IGV2ZW50UmVzaXplc1trZXldIHx8IG51bGwsXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBzcGxpdFByb3BzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBfc3BsaXREYXRlU3BhbihkYXRlU3Bhbikge1xyXG4gICAgICAgICAgICBsZXQgZGF0ZVNwYW5zID0ge307XHJcbiAgICAgICAgICAgIGlmIChkYXRlU3Bhbikge1xyXG4gICAgICAgICAgICAgICAgbGV0IGtleXMgPSB0aGlzLmdldEtleXNGb3JEYXRlU3BhbihkYXRlU3Bhbik7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBrZXkgb2Yga2V5cykge1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGVTcGFuc1trZXldID0gZGF0ZVNwYW47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGRhdGVTcGFucztcclxuICAgICAgICB9XHJcbiAgICAgICAgX2dldEtleXNGb3JFdmVudERlZnMoZXZlbnRTdG9yZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbWFwSGFzaChldmVudFN0b3JlLmRlZnMsIChldmVudERlZikgPT4gdGhpcy5nZXRLZXlzRm9yRXZlbnREZWYoZXZlbnREZWYpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgX3NwbGl0RXZlbnRTdG9yZShldmVudFN0b3JlLCBkZWZLZXlzKSB7XHJcbiAgICAgICAgICAgIGxldCB7IGRlZnMsIGluc3RhbmNlcyB9ID0gZXZlbnRTdG9yZTtcclxuICAgICAgICAgICAgbGV0IHNwbGl0U3RvcmVzID0ge307XHJcbiAgICAgICAgICAgIGZvciAobGV0IGRlZklkIGluIGRlZnMpIHtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGtleSBvZiBkZWZLZXlzW2RlZklkXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghc3BsaXRTdG9yZXNba2V5XSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzcGxpdFN0b3Jlc1trZXldID0gY3JlYXRlRW1wdHlFdmVudFN0b3JlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHNwbGl0U3RvcmVzW2tleV0uZGVmc1tkZWZJZF0gPSBkZWZzW2RlZklkXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKGxldCBpbnN0YW5jZUlkIGluIGluc3RhbmNlcykge1xyXG4gICAgICAgICAgICAgICAgbGV0IGluc3RhbmNlID0gaW5zdGFuY2VzW2luc3RhbmNlSWRdO1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQga2V5IG9mIGRlZktleXNbaW5zdGFuY2UuZGVmSWRdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNwbGl0U3RvcmVzW2tleV0pIHsgLy8gbXVzdCBoYXZlIGFscmVhZHkgYmVlbiBjcmVhdGVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwbGl0U3RvcmVzW2tleV0uaW5zdGFuY2VzW2luc3RhbmNlSWRdID0gaW5zdGFuY2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBzcGxpdFN0b3JlcztcclxuICAgICAgICB9XHJcbiAgICAgICAgX3NwbGl0SW5kaXZpZHVhbFVpKGV2ZW50VWlCYXNlcywgZGVmS2V5cykge1xyXG4gICAgICAgICAgICBsZXQgc3BsaXRIYXNoZXMgPSB7fTtcclxuICAgICAgICAgICAgZm9yIChsZXQgZGVmSWQgaW4gZXZlbnRVaUJhc2VzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGVmSWQpIHsgLy8gbm90IHRoZSAnJyBrZXlcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBrZXkgb2YgZGVmS2V5c1tkZWZJZF0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzcGxpdEhhc2hlc1trZXldKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcGxpdEhhc2hlc1trZXldID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgc3BsaXRIYXNoZXNba2V5XVtkZWZJZF0gPSBldmVudFVpQmFzZXNbZGVmSWRdO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gc3BsaXRIYXNoZXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9zcGxpdEludGVyYWN0aW9uKGludGVyYWN0aW9uKSB7XHJcbiAgICAgICAgICAgIGxldCBzcGxpdFN0YXRlcyA9IHt9O1xyXG4gICAgICAgICAgICBpZiAoaW50ZXJhY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgIGxldCBhZmZlY3RlZFN0b3JlcyA9IHRoaXMuX3NwbGl0RXZlbnRTdG9yZShpbnRlcmFjdGlvbi5hZmZlY3RlZEV2ZW50cywgdGhpcy5fZ2V0S2V5c0ZvckV2ZW50RGVmcyhpbnRlcmFjdGlvbi5hZmZlY3RlZEV2ZW50cykpO1xyXG4gICAgICAgICAgICAgICAgLy8gY2FuJ3QgcmVseSBvbiBkZWZLZXlzIGJlY2F1c2UgZXZlbnQgZGF0YSBpcyBtdXRhdGVkXHJcbiAgICAgICAgICAgICAgICBsZXQgbXV0YXRlZEtleXNCeURlZklkID0gdGhpcy5fZ2V0S2V5c0ZvckV2ZW50RGVmcyhpbnRlcmFjdGlvbi5tdXRhdGVkRXZlbnRzKTtcclxuICAgICAgICAgICAgICAgIGxldCBtdXRhdGVkU3RvcmVzID0gdGhpcy5fc3BsaXRFdmVudFN0b3JlKGludGVyYWN0aW9uLm11dGF0ZWRFdmVudHMsIG11dGF0ZWRLZXlzQnlEZWZJZCk7XHJcbiAgICAgICAgICAgICAgICBsZXQgcG9wdWxhdGUgPSAoa2V5KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzcGxpdFN0YXRlc1trZXldKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwbGl0U3RhdGVzW2tleV0gPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZmZlY3RlZEV2ZW50czogYWZmZWN0ZWRTdG9yZXNba2V5XSB8fCBFTVBUWV9FVkVOVF9TVE9SRSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG11dGF0ZWRFdmVudHM6IG11dGF0ZWRTdG9yZXNba2V5XSB8fCBFTVBUWV9FVkVOVF9TVE9SRSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzRXZlbnQ6IGludGVyYWN0aW9uLmlzRXZlbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGtleSBpbiBhZmZlY3RlZFN0b3Jlcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHBvcHVsYXRlKGtleSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBrZXkgaW4gbXV0YXRlZFN0b3Jlcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHBvcHVsYXRlKGtleSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHNwbGl0U3RhdGVzO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGJ1aWxkRXZlbnRVaUZvcktleShhbGxVaSwgZXZlbnRVaUZvcktleSwgaW5kaXZpZHVhbFVpKSB7XHJcbiAgICAgICAgbGV0IGJhc2VQYXJ0cyA9IFtdO1xyXG4gICAgICAgIGlmIChhbGxVaSkge1xyXG4gICAgICAgICAgICBiYXNlUGFydHMucHVzaChhbGxVaSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChldmVudFVpRm9yS2V5KSB7XHJcbiAgICAgICAgICAgIGJhc2VQYXJ0cy5wdXNoKGV2ZW50VWlGb3JLZXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgc3R1ZmYgPSB7XHJcbiAgICAgICAgICAgICcnOiBjb21iaW5lRXZlbnRVaXMoYmFzZVBhcnRzKSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmIChpbmRpdmlkdWFsVWkpIHtcclxuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihzdHVmZiwgaW5kaXZpZHVhbFVpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHN0dWZmO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHBhcnNlUmFuZ2UoaW5wdXQsIGRhdGVFbnYpIHtcclxuICAgICAgICBsZXQgc3RhcnQgPSBudWxsO1xyXG4gICAgICAgIGxldCBlbmQgPSBudWxsO1xyXG4gICAgICAgIGlmIChpbnB1dC5zdGFydCkge1xyXG4gICAgICAgICAgICBzdGFydCA9IGRhdGVFbnYuY3JlYXRlTWFya2VyKGlucHV0LnN0YXJ0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlucHV0LmVuZCkge1xyXG4gICAgICAgICAgICBlbmQgPSBkYXRlRW52LmNyZWF0ZU1hcmtlcihpbnB1dC5lbmQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXN0YXJ0ICYmICFlbmQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzdGFydCAmJiBlbmQgJiYgZW5kIDwgc3RhcnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7IHN0YXJ0LCBlbmQgfTtcclxuICAgIH1cclxuICAgIC8vIFNJREUtRUZGRUNUOiB3aWxsIG11dGF0ZSByYW5nZXMuXHJcbiAgICAvLyBXaWxsIHJldHVybiBhIG5ldyBhcnJheSByZXN1bHQuXHJcbiAgICBmdW5jdGlvbiBpbnZlcnRSYW5nZXMocmFuZ2VzLCBjb25zdHJhaW50UmFuZ2UpIHtcclxuICAgICAgICBsZXQgaW52ZXJ0ZWRSYW5nZXMgPSBbXTtcclxuICAgICAgICBsZXQgeyBzdGFydCB9ID0gY29uc3RyYWludFJhbmdlOyAvLyB0aGUgZW5kIG9mIHRoZSBwcmV2aW91cyByYW5nZS4gdGhlIHN0YXJ0IG9mIHRoZSBuZXcgcmFuZ2VcclxuICAgICAgICBsZXQgaTtcclxuICAgICAgICBsZXQgZGF0ZVJhbmdlO1xyXG4gICAgICAgIC8vIHJhbmdlcyBuZWVkIHRvIGJlIGluIG9yZGVyLiByZXF1aXJlZCBmb3Igb3VyIGRhdGUtd2Fsa2luZyBhbGdvcml0aG1cclxuICAgICAgICByYW5nZXMuc29ydChjb21wYXJlUmFuZ2VzKTtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSArPSAxKSB7XHJcbiAgICAgICAgICAgIGRhdGVSYW5nZSA9IHJhbmdlc1tpXTtcclxuICAgICAgICAgICAgLy8gYWRkIHRoZSBzcGFuIG9mIHRpbWUgYmVmb3JlIHRoZSBldmVudCAoaWYgdGhlcmUgaXMgYW55KVxyXG4gICAgICAgICAgICBpZiAoZGF0ZVJhbmdlLnN0YXJ0ID4gc3RhcnQpIHsgLy8gY29tcGFyZSBtaWxsaXNlY29uZCB0aW1lIChza2lwIGFueSBhbWJpZyBsb2dpYylcclxuICAgICAgICAgICAgICAgIGludmVydGVkUmFuZ2VzLnB1c2goeyBzdGFydCwgZW5kOiBkYXRlUmFuZ2Uuc3RhcnQgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGRhdGVSYW5nZS5lbmQgPiBzdGFydCkge1xyXG4gICAgICAgICAgICAgICAgc3RhcnQgPSBkYXRlUmFuZ2UuZW5kO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGFkZCB0aGUgc3BhbiBvZiB0aW1lIGFmdGVyIHRoZSBsYXN0IGV2ZW50IChpZiB0aGVyZSBpcyBhbnkpXHJcbiAgICAgICAgaWYgKHN0YXJ0IDwgY29uc3RyYWludFJhbmdlLmVuZCkgeyAvLyBjb21wYXJlIG1pbGxpc2Vjb25kIHRpbWUgKHNraXAgYW55IGFtYmlnIGxvZ2ljKVxyXG4gICAgICAgICAgICBpbnZlcnRlZFJhbmdlcy5wdXNoKHsgc3RhcnQsIGVuZDogY29uc3RyYWludFJhbmdlLmVuZCB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGludmVydGVkUmFuZ2VzO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gY29tcGFyZVJhbmdlcyhyYW5nZTAsIHJhbmdlMSkge1xyXG4gICAgICAgIHJldHVybiByYW5nZTAuc3RhcnQudmFsdWVPZigpIC0gcmFuZ2UxLnN0YXJ0LnZhbHVlT2YoKTsgLy8gZWFybGllciByYW5nZXMgZ28gZmlyc3RcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGludGVyc2VjdFJhbmdlcyhyYW5nZTAsIHJhbmdlMSkge1xyXG4gICAgICAgIGxldCB7IHN0YXJ0LCBlbmQgfSA9IHJhbmdlMDtcclxuICAgICAgICBsZXQgbmV3UmFuZ2UgPSBudWxsO1xyXG4gICAgICAgIGlmIChyYW5nZTEuc3RhcnQgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgaWYgKHN0YXJ0ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBzdGFydCA9IHJhbmdlMS5zdGFydDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHN0YXJ0ID0gbmV3IERhdGUoTWF0aC5tYXgoc3RhcnQudmFsdWVPZigpLCByYW5nZTEuc3RhcnQudmFsdWVPZigpKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJhbmdlMS5lbmQgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICBpZiAoZW5kID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBlbmQgPSByYW5nZTEuZW5kO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZW5kID0gbmV3IERhdGUoTWF0aC5taW4oZW5kLnZhbHVlT2YoKSwgcmFuZ2UxLmVuZC52YWx1ZU9mKCkpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc3RhcnQgPT09IG51bGwgfHwgZW5kID09PSBudWxsIHx8IHN0YXJ0IDwgZW5kKSB7XHJcbiAgICAgICAgICAgIG5ld1JhbmdlID0geyBzdGFydCwgZW5kIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXdSYW5nZTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHJhbmdlc0VxdWFsKHJhbmdlMCwgcmFuZ2UxKSB7XHJcbiAgICAgICAgcmV0dXJuIChyYW5nZTAuc3RhcnQgPT09IG51bGwgPyBudWxsIDogcmFuZ2UwLnN0YXJ0LnZhbHVlT2YoKSkgPT09IChyYW5nZTEuc3RhcnQgPT09IG51bGwgPyBudWxsIDogcmFuZ2UxLnN0YXJ0LnZhbHVlT2YoKSkgJiZcclxuICAgICAgICAgICAgKHJhbmdlMC5lbmQgPT09IG51bGwgPyBudWxsIDogcmFuZ2UwLmVuZC52YWx1ZU9mKCkpID09PSAocmFuZ2UxLmVuZCA9PT0gbnVsbCA/IG51bGwgOiByYW5nZTEuZW5kLnZhbHVlT2YoKSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiByYW5nZXNJbnRlcnNlY3QocmFuZ2UwLCByYW5nZTEpIHtcclxuICAgICAgICByZXR1cm4gKHJhbmdlMC5lbmQgPT09IG51bGwgfHwgcmFuZ2UxLnN0YXJ0ID09PSBudWxsIHx8IHJhbmdlMC5lbmQgPiByYW5nZTEuc3RhcnQpICYmXHJcbiAgICAgICAgICAgIChyYW5nZTAuc3RhcnQgPT09IG51bGwgfHwgcmFuZ2UxLmVuZCA9PT0gbnVsbCB8fCByYW5nZTAuc3RhcnQgPCByYW5nZTEuZW5kKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHJhbmdlQ29udGFpbnNSYW5nZShvdXRlclJhbmdlLCBpbm5lclJhbmdlKSB7XHJcbiAgICAgICAgcmV0dXJuIChvdXRlclJhbmdlLnN0YXJ0ID09PSBudWxsIHx8IChpbm5lclJhbmdlLnN0YXJ0ICE9PSBudWxsICYmIGlubmVyUmFuZ2Uuc3RhcnQgPj0gb3V0ZXJSYW5nZS5zdGFydCkpICYmXHJcbiAgICAgICAgICAgIChvdXRlclJhbmdlLmVuZCA9PT0gbnVsbCB8fCAoaW5uZXJSYW5nZS5lbmQgIT09IG51bGwgJiYgaW5uZXJSYW5nZS5lbmQgPD0gb3V0ZXJSYW5nZS5lbmQpKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHJhbmdlQ29udGFpbnNNYXJrZXIocmFuZ2UsIGRhdGUpIHtcclxuICAgICAgICByZXR1cm4gKHJhbmdlLnN0YXJ0ID09PSBudWxsIHx8IGRhdGUgPj0gcmFuZ2Uuc3RhcnQpICYmXHJcbiAgICAgICAgICAgIChyYW5nZS5lbmQgPT09IG51bGwgfHwgZGF0ZSA8IHJhbmdlLmVuZCk7XHJcbiAgICB9XHJcbiAgICAvLyBJZiB0aGUgZ2l2ZW4gZGF0ZSBpcyBub3Qgd2l0aGluIHRoZSBnaXZlbiByYW5nZSwgbW92ZSBpdCBpbnNpZGUuXHJcbiAgICAvLyAoSWYgaXQncyBwYXN0IHRoZSBlbmQsIG1ha2UgaXQgb25lIG1pbGxpc2Vjb25kIGJlZm9yZSB0aGUgZW5kKS5cclxuICAgIGZ1bmN0aW9uIGNvbnN0cmFpbk1hcmtlclRvUmFuZ2UoZGF0ZSwgcmFuZ2UpIHtcclxuICAgICAgICBpZiAocmFuZ2Uuc3RhcnQgIT0gbnVsbCAmJiBkYXRlIDwgcmFuZ2Uuc3RhcnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJhbmdlLnN0YXJ0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocmFuZ2UuZW5kICE9IG51bGwgJiYgZGF0ZSA+PSByYW5nZS5lbmQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHJhbmdlLmVuZC52YWx1ZU9mKCkgLSAxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGRhdGU7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0RGF0ZU1ldGEoZGF0ZSwgdG9kYXlSYW5nZSwgbm93RGF0ZSwgZGF0ZVByb2ZpbGUpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBkb3c6IGRhdGUuZ2V0VVRDRGF5KCksXHJcbiAgICAgICAgICAgIGlzRGlzYWJsZWQ6IEJvb2xlYW4oZGF0ZVByb2ZpbGUgJiYgIXJhbmdlQ29udGFpbnNNYXJrZXIoZGF0ZVByb2ZpbGUuYWN0aXZlUmFuZ2UsIGRhdGUpKSxcclxuICAgICAgICAgICAgaXNPdGhlcjogQm9vbGVhbihkYXRlUHJvZmlsZSAmJiAhcmFuZ2VDb250YWluc01hcmtlcihkYXRlUHJvZmlsZS5jdXJyZW50UmFuZ2UsIGRhdGUpKSxcclxuICAgICAgICAgICAgaXNUb2RheTogQm9vbGVhbih0b2RheVJhbmdlICYmIHJhbmdlQ29udGFpbnNNYXJrZXIodG9kYXlSYW5nZSwgZGF0ZSkpLFxyXG4gICAgICAgICAgICBpc1Bhc3Q6IEJvb2xlYW4obm93RGF0ZSA/IChkYXRlIDwgbm93RGF0ZSkgOiB0b2RheVJhbmdlID8gKGRhdGUgPCB0b2RheVJhbmdlLnN0YXJ0KSA6IGZhbHNlKSxcclxuICAgICAgICAgICAgaXNGdXR1cmU6IEJvb2xlYW4obm93RGF0ZSA/IChkYXRlID4gbm93RGF0ZSkgOiB0b2RheVJhbmdlID8gKGRhdGUgPj0gdG9kYXlSYW5nZS5lbmQpIDogZmFsc2UpLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBnZXREYXlDbGFzc05hbWVzKG1ldGEsIHRoZW1lKSB7XHJcbiAgICAgICAgbGV0IGNsYXNzTmFtZXMgPSBbXHJcbiAgICAgICAgICAgICdmYy1kYXknLFxyXG4gICAgICAgICAgICBgZmMtZGF5LSR7REFZX0lEU1ttZXRhLmRvd119YCxcclxuICAgICAgICBdO1xyXG4gICAgICAgIGlmIChtZXRhLmlzRGlzYWJsZWQpIHtcclxuICAgICAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1kYXktZGlzYWJsZWQnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChtZXRhLmlzVG9kYXkpIHtcclxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtZGF5LXRvZGF5Jyk7XHJcbiAgICAgICAgICAgICAgICBjbGFzc05hbWVzLnB1c2godGhlbWUuZ2V0Q2xhc3MoJ3RvZGF5JykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChtZXRhLmlzUGFzdCkge1xyXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1kYXktcGFzdCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChtZXRhLmlzRnV0dXJlKSB7XHJcbiAgICAgICAgICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLWRheS1mdXR1cmUnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobWV0YS5pc090aGVyKSB7XHJcbiAgICAgICAgICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLWRheS1vdGhlcicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjbGFzc05hbWVzO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZ2V0U2xvdENsYXNzTmFtZXMobWV0YSwgdGhlbWUpIHtcclxuICAgICAgICBsZXQgY2xhc3NOYW1lcyA9IFtcclxuICAgICAgICAgICAgJ2ZjLXNsb3QnLFxyXG4gICAgICAgICAgICBgZmMtc2xvdC0ke0RBWV9JRFNbbWV0YS5kb3ddfWAsXHJcbiAgICAgICAgXTtcclxuICAgICAgICBpZiAobWV0YS5pc0Rpc2FibGVkKSB7XHJcbiAgICAgICAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtc2xvdC1kaXNhYmxlZCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKG1ldGEuaXNUb2RheSkge1xyXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1zbG90LXRvZGF5Jyk7XHJcbiAgICAgICAgICAgICAgICBjbGFzc05hbWVzLnB1c2godGhlbWUuZ2V0Q2xhc3MoJ3RvZGF5JykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChtZXRhLmlzUGFzdCkge1xyXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1zbG90LXBhc3QnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobWV0YS5pc0Z1dHVyZSkge1xyXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1zbG90LWZ1dHVyZScpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjbGFzc05hbWVzO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IERBWV9GT1JNQVQgPSBjcmVhdGVGb3JtYXR0ZXIoeyB5ZWFyOiAnbnVtZXJpYycsIG1vbnRoOiAnbG9uZycsIGRheTogJ251bWVyaWMnIH0pO1xyXG4gICAgY29uc3QgV0VFS19GT1JNQVQgPSBjcmVhdGVGb3JtYXR0ZXIoeyB3ZWVrOiAnbG9uZycgfSk7XHJcbiAgICBmdW5jdGlvbiBidWlsZE5hdkxpbmtBdHRycyhjb250ZXh0LCBkYXRlTWFya2VyLCB2aWV3VHlwZSA9ICdkYXknLCBpc1RhYmJhYmxlID0gdHJ1ZSkge1xyXG4gICAgICAgIGNvbnN0IHsgZGF0ZUVudiwgb3B0aW9ucywgY2FsZW5kYXJBcGkgfSA9IGNvbnRleHQ7XHJcbiAgICAgICAgbGV0IGRhdGVTdHIgPSBkYXRlRW52LmZvcm1hdChkYXRlTWFya2VyLCB2aWV3VHlwZSA9PT0gJ3dlZWsnID8gV0VFS19GT1JNQVQgOiBEQVlfRk9STUFUKTtcclxuICAgICAgICBpZiAob3B0aW9ucy5uYXZMaW5rcykge1xyXG4gICAgICAgICAgICBsZXQgem9uZWREYXRlID0gZGF0ZUVudi50b0RhdGUoZGF0ZU1hcmtlcik7XHJcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZUludGVyYWN0aW9uID0gKGV2KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBsZXQgY3VzdG9tQWN0aW9uID0gdmlld1R5cGUgPT09ICdkYXknID8gb3B0aW9ucy5uYXZMaW5rRGF5Q2xpY2sgOlxyXG4gICAgICAgICAgICAgICAgICAgIHZpZXdUeXBlID09PSAnd2VlaycgPyBvcHRpb25zLm5hdkxpbmtXZWVrQ2xpY2sgOiBudWxsO1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjdXN0b21BY3Rpb24gPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICAgICAgICBjdXN0b21BY3Rpb24uY2FsbChjYWxlbmRhckFwaSwgZGF0ZUVudi50b0RhdGUoZGF0ZU1hcmtlciksIGV2KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY3VzdG9tQWN0aW9uID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2aWV3VHlwZSA9IGN1c3RvbUFjdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY2FsZW5kYXJBcGkuem9vbVRvKGRhdGVNYXJrZXIsIHZpZXdUeXBlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oeyB0aXRsZTogZm9ybWF0V2l0aE9yZGluYWxzKG9wdGlvbnMubmF2TGlua0hpbnQsIFtkYXRlU3RyLCB6b25lZERhdGVdLCBkYXRlU3RyKSwgJ2RhdGEtbmF2bGluayc6ICcnIH0sIChpc1RhYmJhYmxlXHJcbiAgICAgICAgICAgICAgICA/IGNyZWF0ZUFyaWFDbGlja0F0dHJzKGhhbmRsZUludGVyYWN0aW9uKVxyXG4gICAgICAgICAgICAgICAgOiB7IG9uQ2xpY2s6IGhhbmRsZUludGVyYWN0aW9uIH0pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHsgJ2FyaWEtbGFiZWwnOiBkYXRlU3RyIH07XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IF9pc1J0bFNjcm9sbGJhck9uTGVmdCA9IG51bGw7XHJcbiAgICBmdW5jdGlvbiBnZXRJc1J0bFNjcm9sbGJhck9uTGVmdCgpIHtcclxuICAgICAgICBpZiAoX2lzUnRsU2Nyb2xsYmFyT25MZWZ0ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIF9pc1J0bFNjcm9sbGJhck9uTGVmdCA9IGNvbXB1dGVJc1J0bFNjcm9sbGJhck9uTGVmdCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gX2lzUnRsU2Nyb2xsYmFyT25MZWZ0O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gY29tcHV0ZUlzUnRsU2Nyb2xsYmFyT25MZWZ0KCkge1xyXG4gICAgICAgIGxldCBvdXRlckVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgYXBwbHlTdHlsZShvdXRlckVsLCB7XHJcbiAgICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxyXG4gICAgICAgICAgICB0b3A6IC0xMDAwLFxyXG4gICAgICAgICAgICBsZWZ0OiAwLFxyXG4gICAgICAgICAgICBib3JkZXI6IDAsXHJcbiAgICAgICAgICAgIHBhZGRpbmc6IDAsXHJcbiAgICAgICAgICAgIG92ZXJmbG93OiAnc2Nyb2xsJyxcclxuICAgICAgICAgICAgZGlyZWN0aW9uOiAncnRsJyxcclxuICAgICAgICB9KTtcclxuICAgICAgICBvdXRlckVsLmlubmVySFRNTCA9ICc8ZGl2PjwvZGl2Pic7XHJcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChvdXRlckVsKTtcclxuICAgICAgICBsZXQgaW5uZXJFbCA9IG91dGVyRWwuZmlyc3RDaGlsZDtcclxuICAgICAgICBsZXQgcmVzID0gaW5uZXJFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0ID4gb3V0ZXJFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0O1xyXG4gICAgICAgIHJlbW92ZUVsZW1lbnQob3V0ZXJFbCk7XHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgIH1cclxuXHJcbiAgICBsZXQgX3Njcm9sbGJhcldpZHRocztcclxuICAgIGZ1bmN0aW9uIGdldFNjcm9sbGJhcldpZHRocygpIHtcclxuICAgICAgICBpZiAoIV9zY3JvbGxiYXJXaWR0aHMpIHtcclxuICAgICAgICAgICAgX3Njcm9sbGJhcldpZHRocyA9IGNvbXB1dGVTY3JvbGxiYXJXaWR0aHMoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIF9zY3JvbGxiYXJXaWR0aHM7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBjb21wdXRlU2Nyb2xsYmFyV2lkdGhzKCkge1xyXG4gICAgICAgIGxldCBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgICAgIGVsLnN0eWxlLm92ZXJmbG93ID0gJ3Njcm9sbCc7XHJcbiAgICAgICAgZWwuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xyXG4gICAgICAgIGVsLnN0eWxlLnRvcCA9ICctOTk5OXB4JztcclxuICAgICAgICBlbC5zdHlsZS5sZWZ0ID0gJy05OTk5cHgnO1xyXG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZWwpO1xyXG4gICAgICAgIGxldCByZXMgPSBjb21wdXRlU2Nyb2xsYmFyV2lkdGhzRm9yRWwoZWwpO1xyXG4gICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoZWwpO1xyXG4gICAgICAgIHJldHVybiByZXM7XHJcbiAgICB9XHJcbiAgICAvLyBXQVJOSU5HOiB3aWxsIGluY2x1ZGUgYm9yZGVyXHJcbiAgICBmdW5jdGlvbiBjb21wdXRlU2Nyb2xsYmFyV2lkdGhzRm9yRWwoZWwpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB4OiBlbC5vZmZzZXRIZWlnaHQgLSBlbC5jbGllbnRIZWlnaHQsXHJcbiAgICAgICAgICAgIHk6IGVsLm9mZnNldFdpZHRoIC0gZWwuY2xpZW50V2lkdGgsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjb21wdXRlRWRnZXMoZWwsIGdldFBhZGRpbmcgPSBmYWxzZSkge1xyXG4gICAgICAgIGxldCBjb21wdXRlZFN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpO1xyXG4gICAgICAgIGxldCBib3JkZXJMZWZ0ID0gcGFyc2VJbnQoY29tcHV0ZWRTdHlsZS5ib3JkZXJMZWZ0V2lkdGgsIDEwKSB8fCAwO1xyXG4gICAgICAgIGxldCBib3JkZXJSaWdodCA9IHBhcnNlSW50KGNvbXB1dGVkU3R5bGUuYm9yZGVyUmlnaHRXaWR0aCwgMTApIHx8IDA7XHJcbiAgICAgICAgbGV0IGJvcmRlclRvcCA9IHBhcnNlSW50KGNvbXB1dGVkU3R5bGUuYm9yZGVyVG9wV2lkdGgsIDEwKSB8fCAwO1xyXG4gICAgICAgIGxldCBib3JkZXJCb3R0b20gPSBwYXJzZUludChjb21wdXRlZFN0eWxlLmJvcmRlckJvdHRvbVdpZHRoLCAxMCkgfHwgMDtcclxuICAgICAgICBsZXQgYmFkU2Nyb2xsYmFyV2lkdGhzID0gY29tcHV0ZVNjcm9sbGJhcldpZHRoc0ZvckVsKGVsKTsgLy8gaW5jbHVkZXMgYm9yZGVyIVxyXG4gICAgICAgIGxldCBzY3JvbGxiYXJMZWZ0UmlnaHQgPSBiYWRTY3JvbGxiYXJXaWR0aHMueSAtIGJvcmRlckxlZnQgLSBib3JkZXJSaWdodDtcclxuICAgICAgICBsZXQgc2Nyb2xsYmFyQm90dG9tID0gYmFkU2Nyb2xsYmFyV2lkdGhzLnggLSBib3JkZXJUb3AgLSBib3JkZXJCb3R0b207XHJcbiAgICAgICAgbGV0IHJlcyA9IHtcclxuICAgICAgICAgICAgYm9yZGVyTGVmdCxcclxuICAgICAgICAgICAgYm9yZGVyUmlnaHQsXHJcbiAgICAgICAgICAgIGJvcmRlclRvcCxcclxuICAgICAgICAgICAgYm9yZGVyQm90dG9tLFxyXG4gICAgICAgICAgICBzY3JvbGxiYXJCb3R0b20sXHJcbiAgICAgICAgICAgIHNjcm9sbGJhckxlZnQ6IDAsXHJcbiAgICAgICAgICAgIHNjcm9sbGJhclJpZ2h0OiAwLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKGdldElzUnRsU2Nyb2xsYmFyT25MZWZ0KCkgJiYgY29tcHV0ZWRTdHlsZS5kaXJlY3Rpb24gPT09ICdydGwnKSB7IC8vIGlzIHRoZSBzY3JvbGxiYXIgb24gdGhlIGxlZnQgc2lkZT9cclxuICAgICAgICAgICAgcmVzLnNjcm9sbGJhckxlZnQgPSBzY3JvbGxiYXJMZWZ0UmlnaHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXMuc2Nyb2xsYmFyUmlnaHQgPSBzY3JvbGxiYXJMZWZ0UmlnaHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChnZXRQYWRkaW5nKSB7XHJcbiAgICAgICAgICAgIHJlcy5wYWRkaW5nTGVmdCA9IHBhcnNlSW50KGNvbXB1dGVkU3R5bGUucGFkZGluZ0xlZnQsIDEwKSB8fCAwO1xyXG4gICAgICAgICAgICByZXMucGFkZGluZ1JpZ2h0ID0gcGFyc2VJbnQoY29tcHV0ZWRTdHlsZS5wYWRkaW5nUmlnaHQsIDEwKSB8fCAwO1xyXG4gICAgICAgICAgICByZXMucGFkZGluZ1RvcCA9IHBhcnNlSW50KGNvbXB1dGVkU3R5bGUucGFkZGluZ1RvcCwgMTApIHx8IDA7XHJcbiAgICAgICAgICAgIHJlcy5wYWRkaW5nQm90dG9tID0gcGFyc2VJbnQoY29tcHV0ZWRTdHlsZS5wYWRkaW5nQm90dG9tLCAxMCkgfHwgMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGNvbXB1dGVJbm5lclJlY3QoZWwsIGdvV2l0aGluUGFkZGluZyA9IGZhbHNlLCBkb0Zyb21XaW5kb3dWaWV3cG9ydCkge1xyXG4gICAgICAgIGxldCBvdXRlclJlY3QgPSBkb0Zyb21XaW5kb3dWaWV3cG9ydCA/IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIDogY29tcHV0ZVJlY3QoZWwpO1xyXG4gICAgICAgIGxldCBlZGdlcyA9IGNvbXB1dGVFZGdlcyhlbCwgZ29XaXRoaW5QYWRkaW5nKTtcclxuICAgICAgICBsZXQgcmVzID0ge1xyXG4gICAgICAgICAgICBsZWZ0OiBvdXRlclJlY3QubGVmdCArIGVkZ2VzLmJvcmRlckxlZnQgKyBlZGdlcy5zY3JvbGxiYXJMZWZ0LFxyXG4gICAgICAgICAgICByaWdodDogb3V0ZXJSZWN0LnJpZ2h0IC0gZWRnZXMuYm9yZGVyUmlnaHQgLSBlZGdlcy5zY3JvbGxiYXJSaWdodCxcclxuICAgICAgICAgICAgdG9wOiBvdXRlclJlY3QudG9wICsgZWRnZXMuYm9yZGVyVG9wLFxyXG4gICAgICAgICAgICBib3R0b206IG91dGVyUmVjdC5ib3R0b20gLSBlZGdlcy5ib3JkZXJCb3R0b20gLSBlZGdlcy5zY3JvbGxiYXJCb3R0b20sXHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAoZ29XaXRoaW5QYWRkaW5nKSB7XHJcbiAgICAgICAgICAgIHJlcy5sZWZ0ICs9IGVkZ2VzLnBhZGRpbmdMZWZ0O1xyXG4gICAgICAgICAgICByZXMucmlnaHQgLT0gZWRnZXMucGFkZGluZ1JpZ2h0O1xyXG4gICAgICAgICAgICByZXMudG9wICs9IGVkZ2VzLnBhZGRpbmdUb3A7XHJcbiAgICAgICAgICAgIHJlcy5ib3R0b20gLT0gZWRnZXMucGFkZGluZ0JvdHRvbTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGNvbXB1dGVSZWN0KGVsKSB7XHJcbiAgICAgICAgbGV0IHJlY3QgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBsZWZ0OiByZWN0LmxlZnQgKyB3aW5kb3cucGFnZVhPZmZzZXQsXHJcbiAgICAgICAgICAgIHRvcDogcmVjdC50b3AgKyB3aW5kb3cucGFnZVlPZmZzZXQsXHJcbiAgICAgICAgICAgIHJpZ2h0OiByZWN0LnJpZ2h0ICsgd2luZG93LnBhZ2VYT2Zmc2V0LFxyXG4gICAgICAgICAgICBib3R0b206IHJlY3QuYm90dG9tICsgd2luZG93LnBhZ2VZT2Zmc2V0LFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBjb21wdXRlQ2xpcHBlZENsaWVudFJlY3QoZWwpIHtcclxuICAgICAgICBsZXQgY2xpcHBpbmdQYXJlbnRzID0gZ2V0Q2xpcHBpbmdQYXJlbnRzKGVsKTtcclxuICAgICAgICBsZXQgcmVjdCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgICAgIGZvciAobGV0IGNsaXBwaW5nUGFyZW50IG9mIGNsaXBwaW5nUGFyZW50cykge1xyXG4gICAgICAgICAgICBsZXQgaW50ZXJzZWN0aW9uID0gaW50ZXJzZWN0UmVjdHMocmVjdCwgY2xpcHBpbmdQYXJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkpO1xyXG4gICAgICAgICAgICBpZiAoaW50ZXJzZWN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICByZWN0ID0gaW50ZXJzZWN0aW9uO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlY3Q7XHJcbiAgICB9XHJcbiAgICAvLyBkb2VzIG5vdCByZXR1cm4gd2luZG93XHJcbiAgICBmdW5jdGlvbiBnZXRDbGlwcGluZ1BhcmVudHMoZWwpIHtcclxuICAgICAgICBsZXQgcGFyZW50cyA9IFtdO1xyXG4gICAgICAgIHdoaWxlIChlbCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7IC8vIHdpbGwgc3RvcCB3aGVuIGdldHMgdG8gZG9jdW1lbnQgb3IgbnVsbFxyXG4gICAgICAgICAgICBsZXQgY29tcHV0ZWRTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsKTtcclxuICAgICAgICAgICAgaWYgKGNvbXB1dGVkU3R5bGUucG9zaXRpb24gPT09ICdmaXhlZCcpIHtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICgoLyhhdXRvfHNjcm9sbCkvKS50ZXN0KGNvbXB1dGVkU3R5bGUub3ZlcmZsb3cgKyBjb21wdXRlZFN0eWxlLm92ZXJmbG93WSArIGNvbXB1dGVkU3R5bGUub3ZlcmZsb3dYKSkge1xyXG4gICAgICAgICAgICAgICAgcGFyZW50cy5wdXNoKGVsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbCA9IGVsLnBhcmVudE5vZGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwYXJlbnRzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qXHJcbiAgICBnaXZlbiBhIGZ1bmN0aW9uIHRoYXQgcmVzb2x2ZXMgYSByZXN1bHQgYXN5bmNocm9ub3VzbHkuXHJcbiAgICB0aGUgZnVuY3Rpb24gY2FuIGVpdGhlciBjYWxsIHBhc3NlZC1pbiBzdWNjZXNzIGFuZCBmYWlsdXJlIGNhbGxiYWNrcyxcclxuICAgIG9yIGl0IGNhbiByZXR1cm4gYSBwcm9taXNlLlxyXG4gICAgaWYgeW91IG5lZWQgdG8gcGFzcyBhZGRpdGlvbmFsIHBhcmFtcyB0byBmdW5jLCBiaW5kIHRoZW0gZmlyc3QuXHJcbiAgICAqL1xyXG4gICAgZnVuY3Rpb24gdW5wcm9taXNpZnkoZnVuYywgbm9ybWFsaXplZFN1Y2Nlc3NDYWxsYmFjaywgbm9ybWFsaXplZEZhaWx1cmVDYWxsYmFjaykge1xyXG4gICAgICAgIC8vIGd1YXJkIGFnYWluc3Qgc3VjY2Vzcy9mYWlsdXJlIGNhbGxiYWNrcyBiZWluZyBjYWxsZWQgbW9yZSB0aGFuIG9uY2VcclxuICAgICAgICAvLyBhbmQgZ3VhcmQgYWdhaW5zdCBhIHByb21pc2UgQU5EIGNhbGxiYWNrIGJlaW5nIHVzZWQgdG9nZXRoZXIuXHJcbiAgICAgICAgbGV0IGlzUmVzb2x2ZWQgPSBmYWxzZTtcclxuICAgICAgICBsZXQgd3JhcHBlZFN1Y2Nlc3MgPSBmdW5jdGlvbiAocmVzKSB7XHJcbiAgICAgICAgICAgIGlmICghaXNSZXNvbHZlZCkge1xyXG4gICAgICAgICAgICAgICAgaXNSZXNvbHZlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBub3JtYWxpemVkU3VjY2Vzc0NhbGxiYWNrKHJlcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIGxldCB3cmFwcGVkRmFpbHVyZSA9IGZ1bmN0aW9uIChlcnJvcikge1xyXG4gICAgICAgICAgICBpZiAoIWlzUmVzb2x2ZWQpIHtcclxuICAgICAgICAgICAgICAgIGlzUmVzb2x2ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgbm9ybWFsaXplZEZhaWx1cmVDYWxsYmFjayhlcnJvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIGxldCByZXMgPSBmdW5jKHdyYXBwZWRTdWNjZXNzLCB3cmFwcGVkRmFpbHVyZSk7XHJcbiAgICAgICAgaWYgKHJlcyAmJiB0eXBlb2YgcmVzLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgcmVzLnRoZW4od3JhcHBlZFN1Y2Nlc3MsIHdyYXBwZWRGYWlsdXJlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY2xhc3MgRW1pdHRlciB7XHJcbiAgICAgICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlcnMgPSB7fTtcclxuICAgICAgICAgICAgdGhpcy50aGlzQ29udGV4dCA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNldFRoaXNDb250ZXh0KHRoaXNDb250ZXh0KSB7XHJcbiAgICAgICAgICAgIHRoaXMudGhpc0NvbnRleHQgPSB0aGlzQ29udGV4dDtcclxuICAgICAgICB9XHJcbiAgICAgICAgc2V0T3B0aW9ucyhvcHRpb25zKSB7XHJcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG9uKHR5cGUsIGhhbmRsZXIpIHtcclxuICAgICAgICAgICAgYWRkVG9IYXNoKHRoaXMuaGFuZGxlcnMsIHR5cGUsIGhhbmRsZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBvZmYodHlwZSwgaGFuZGxlcikge1xyXG4gICAgICAgICAgICByZW1vdmVGcm9tSGFzaCh0aGlzLmhhbmRsZXJzLCB0eXBlLCBoYW5kbGVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdHJpZ2dlcih0eXBlLCAuLi5hcmdzKSB7XHJcbiAgICAgICAgICAgIGxldCBhdHRhY2hlZEhhbmRsZXJzID0gdGhpcy5oYW5kbGVyc1t0eXBlXSB8fCBbXTtcclxuICAgICAgICAgICAgbGV0IG9wdGlvbkhhbmRsZXIgPSB0aGlzLm9wdGlvbnMgJiYgdGhpcy5vcHRpb25zW3R5cGVdO1xyXG4gICAgICAgICAgICBsZXQgaGFuZGxlcnMgPSBbXS5jb25jYXQob3B0aW9uSGFuZGxlciB8fCBbXSwgYXR0YWNoZWRIYW5kbGVycyk7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGhhbmRsZXIgb2YgaGFuZGxlcnMpIHtcclxuICAgICAgICAgICAgICAgIGhhbmRsZXIuYXBwbHkodGhpcy50aGlzQ29udGV4dCwgYXJncyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaGFzSGFuZGxlcnModHlwZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gQm9vbGVhbigodGhpcy5oYW5kbGVyc1t0eXBlXSAmJiB0aGlzLmhhbmRsZXJzW3R5cGVdLmxlbmd0aCkgfHxcclxuICAgICAgICAgICAgICAgICh0aGlzLm9wdGlvbnMgJiYgdGhpcy5vcHRpb25zW3R5cGVdKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYWRkVG9IYXNoKGhhc2gsIHR5cGUsIGhhbmRsZXIpIHtcclxuICAgICAgICAoaGFzaFt0eXBlXSB8fCAoaGFzaFt0eXBlXSA9IFtdKSlcclxuICAgICAgICAgICAgLnB1c2goaGFuZGxlcik7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiByZW1vdmVGcm9tSGFzaChoYXNoLCB0eXBlLCBoYW5kbGVyKSB7XHJcbiAgICAgICAgaWYgKGhhbmRsZXIpIHtcclxuICAgICAgICAgICAgaWYgKGhhc2hbdHlwZV0pIHtcclxuICAgICAgICAgICAgICAgIGhhc2hbdHlwZV0gPSBoYXNoW3R5cGVdLmZpbHRlcigoZnVuYykgPT4gZnVuYyAhPT0gaGFuZGxlcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGRlbGV0ZSBoYXNoW3R5cGVdOyAvLyByZW1vdmUgYWxsIGhhbmRsZXIgZnVuY3MgZm9yIHRoaXMgdHlwZVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKlxyXG4gICAgUmVjb3JkcyBvZmZzZXQgaW5mb3JtYXRpb24gZm9yIGEgc2V0IG9mIGVsZW1lbnRzLCByZWxhdGl2ZSB0byBhbiBvcmlnaW4gZWxlbWVudC5cclxuICAgIENhbiByZWNvcmQgdGhlIGxlZnQvcmlnaHQgT1IgdGhlIHRvcC9ib3R0b20gT1IgYm90aC5cclxuICAgIFByb3ZpZGVzIG1ldGhvZHMgZm9yIHF1ZXJ5aW5nIHRoZSBjYWNoZSBieSBwb3NpdGlvbi5cclxuICAgICovXHJcbiAgICBjbGFzcyBQb3NpdGlvbkNhY2hlIHtcclxuICAgICAgICBjb25zdHJ1Y3RvcihvcmlnaW5FbCwgZWxzLCBpc0hvcml6b250YWwsIGlzVmVydGljYWwpIHtcclxuICAgICAgICAgICAgdGhpcy5lbHMgPSBlbHM7XHJcbiAgICAgICAgICAgIGxldCBvcmlnaW5DbGllbnRSZWN0ID0gdGhpcy5vcmlnaW5DbGllbnRSZWN0ID0gb3JpZ2luRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7IC8vIHJlbGF0aXZlIHRvIHZpZXdwb3J0IHRvcC1sZWZ0XHJcbiAgICAgICAgICAgIGlmIChpc0hvcml6b250YWwpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYnVpbGRFbEhvcml6b250YWxzKG9yaWdpbkNsaWVudFJlY3QubGVmdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGlzVmVydGljYWwpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYnVpbGRFbFZlcnRpY2FscyhvcmlnaW5DbGllbnRSZWN0LnRvcCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gUG9wdWxhdGVzIHRoZSBsZWZ0L3JpZ2h0IGludGVybmFsIGNvb3JkaW5hdGUgYXJyYXlzXHJcbiAgICAgICAgYnVpbGRFbEhvcml6b250YWxzKG9yaWdpbkNsaWVudExlZnQpIHtcclxuICAgICAgICAgICAgbGV0IGxlZnRzID0gW107XHJcbiAgICAgICAgICAgIGxldCByaWdodHMgPSBbXTtcclxuICAgICAgICAgICAgZm9yIChsZXQgZWwgb2YgdGhpcy5lbHMpIHtcclxuICAgICAgICAgICAgICAgIGxldCByZWN0ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICAgICAgICAgICAgICBsZWZ0cy5wdXNoKHJlY3QubGVmdCAtIG9yaWdpbkNsaWVudExlZnQpO1xyXG4gICAgICAgICAgICAgICAgcmlnaHRzLnB1c2gocmVjdC5yaWdodCAtIG9yaWdpbkNsaWVudExlZnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMubGVmdHMgPSBsZWZ0cztcclxuICAgICAgICAgICAgdGhpcy5yaWdodHMgPSByaWdodHM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFBvcHVsYXRlcyB0aGUgdG9wL2JvdHRvbSBpbnRlcm5hbCBjb29yZGluYXRlIGFycmF5c1xyXG4gICAgICAgIGJ1aWxkRWxWZXJ0aWNhbHMob3JpZ2luQ2xpZW50VG9wKSB7XHJcbiAgICAgICAgICAgIGxldCB0b3BzID0gW107XHJcbiAgICAgICAgICAgIGxldCBib3R0b21zID0gW107XHJcbiAgICAgICAgICAgIGZvciAobGV0IGVsIG9mIHRoaXMuZWxzKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgcmVjdCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgICAgICAgICAgICAgdG9wcy5wdXNoKHJlY3QudG9wIC0gb3JpZ2luQ2xpZW50VG9wKTtcclxuICAgICAgICAgICAgICAgIGJvdHRvbXMucHVzaChyZWN0LmJvdHRvbSAtIG9yaWdpbkNsaWVudFRvcCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy50b3BzID0gdG9wcztcclxuICAgICAgICAgICAgdGhpcy5ib3R0b21zID0gYm90dG9tcztcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gR2l2ZW4gYSBsZWZ0IG9mZnNldCAoZnJvbSBkb2N1bWVudCBsZWZ0KSwgcmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGVsIHRoYXQgaXQgaG9yaXpvbnRhbGx5IGludGVyc2VjdHMuXHJcbiAgICAgICAgLy8gSWYgbm8gaW50ZXJzZWN0aW9uIGlzIG1hZGUsIHJldHVybnMgdW5kZWZpbmVkLlxyXG4gICAgICAgIGxlZnRUb0luZGV4KGxlZnRQb3NpdGlvbikge1xyXG4gICAgICAgICAgICBsZXQgeyBsZWZ0cywgcmlnaHRzIH0gPSB0aGlzO1xyXG4gICAgICAgICAgICBsZXQgbGVuID0gbGVmdHMubGVuZ3RoO1xyXG4gICAgICAgICAgICBsZXQgaTtcclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobGVmdFBvc2l0aW9uID49IGxlZnRzW2ldICYmIGxlZnRQb3NpdGlvbiA8IHJpZ2h0c1tpXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7IC8vIFRPRE86IGJldHRlclxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBHaXZlbiBhIHRvcCBvZmZzZXQgKGZyb20gZG9jdW1lbnQgdG9wKSwgcmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGVsIHRoYXQgaXQgdmVydGljYWxseSBpbnRlcnNlY3RzLlxyXG4gICAgICAgIC8vIElmIG5vIGludGVyc2VjdGlvbiBpcyBtYWRlLCByZXR1cm5zIHVuZGVmaW5lZC5cclxuICAgICAgICB0b3BUb0luZGV4KHRvcFBvc2l0aW9uKSB7XHJcbiAgICAgICAgICAgIGxldCB7IHRvcHMsIGJvdHRvbXMgfSA9IHRoaXM7XHJcbiAgICAgICAgICAgIGxldCBsZW4gPSB0b3BzLmxlbmd0aDtcclxuICAgICAgICAgICAgbGV0IGk7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRvcFBvc2l0aW9uID49IHRvcHNbaV0gJiYgdG9wUG9zaXRpb24gPCBib3R0b21zW2ldKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDsgLy8gVE9ETzogYmV0dGVyXHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEdldHMgdGhlIHdpZHRoIG9mIHRoZSBlbGVtZW50IGF0IHRoZSBnaXZlbiBpbmRleFxyXG4gICAgICAgIGdldFdpZHRoKGxlZnRJbmRleCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yaWdodHNbbGVmdEluZGV4XSAtIHRoaXMubGVmdHNbbGVmdEluZGV4XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gR2V0cyB0aGUgaGVpZ2h0IG9mIHRoZSBlbGVtZW50IGF0IHRoZSBnaXZlbiBpbmRleFxyXG4gICAgICAgIGdldEhlaWdodCh0b3BJbmRleCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ib3R0b21zW3RvcEluZGV4XSAtIHRoaXMudG9wc1t0b3BJbmRleF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNpbWlsYXJUbyhvdGhlckNhY2hlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzaW1pbGFyTnVtQXJyYXlzKHRoaXMudG9wcyB8fCBbXSwgb3RoZXJDYWNoZS50b3BzIHx8IFtdKSAmJlxyXG4gICAgICAgICAgICAgICAgc2ltaWxhck51bUFycmF5cyh0aGlzLmJvdHRvbXMgfHwgW10sIG90aGVyQ2FjaGUuYm90dG9tcyB8fCBbXSkgJiZcclxuICAgICAgICAgICAgICAgIHNpbWlsYXJOdW1BcnJheXModGhpcy5sZWZ0cyB8fCBbXSwgb3RoZXJDYWNoZS5sZWZ0cyB8fCBbXSkgJiZcclxuICAgICAgICAgICAgICAgIHNpbWlsYXJOdW1BcnJheXModGhpcy5yaWdodHMgfHwgW10sIG90aGVyQ2FjaGUucmlnaHRzIHx8IFtdKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBzaW1pbGFyTnVtQXJyYXlzKGEsIGIpIHtcclxuICAgICAgICBjb25zdCBsZW4gPSBhLmxlbmd0aDtcclxuICAgICAgICBpZiAobGVuICE9PSBiLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKE1hdGgucm91bmQoYVtpXSkgIT09IE1hdGgucm91bmQoYltpXSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKiBlc2xpbnQgbWF4LWNsYXNzZXMtcGVyLWZpbGU6IFwib2ZmXCIgKi9cclxuICAgIC8qXHJcbiAgICBBbiBvYmplY3QgZm9yIGdldHRpbmcvc2V0dGluZyBzY3JvbGwtcmVsYXRlZCBpbmZvcm1hdGlvbiBmb3IgYW4gZWxlbWVudC5cclxuICAgIEludGVybmFsbHksIHRoaXMgaXMgZG9uZSB2ZXJ5IGRpZmZlcmVudGx5IGZvciB3aW5kb3cgdmVyc3VzIERPTSBlbGVtZW50LFxyXG4gICAgc28gdGhpcyBvYmplY3Qgc2VydmVzIGFzIGEgY29tbW9uIGludGVyZmFjZS5cclxuICAgICovXHJcbiAgICBjbGFzcyBTY3JvbGxDb250cm9sbGVyIHtcclxuICAgICAgICBnZXRNYXhTY3JvbGxUb3AoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFNjcm9sbEhlaWdodCgpIC0gdGhpcy5nZXRDbGllbnRIZWlnaHQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZ2V0TWF4U2Nyb2xsTGVmdCgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U2Nyb2xsV2lkdGgoKSAtIHRoaXMuZ2V0Q2xpZW50V2lkdGgoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2FuU2Nyb2xsVmVydGljYWxseSgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TWF4U2Nyb2xsVG9wKCkgPiAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYW5TY3JvbGxIb3Jpem9udGFsbHkoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldE1heFNjcm9sbExlZnQoKSA+IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhblNjcm9sbFVwKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRTY3JvbGxUb3AoKSA+IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhblNjcm9sbERvd24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFNjcm9sbFRvcCgpIDwgdGhpcy5nZXRNYXhTY3JvbGxUb3AoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2FuU2Nyb2xsTGVmdCgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U2Nyb2xsTGVmdCgpID4gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2FuU2Nyb2xsUmlnaHQoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFNjcm9sbExlZnQoKSA8IHRoaXMuZ2V0TWF4U2Nyb2xsTGVmdCgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNsYXNzIEVsZW1lbnRTY3JvbGxDb250cm9sbGVyIGV4dGVuZHMgU2Nyb2xsQ29udHJvbGxlciB7XHJcbiAgICAgICAgY29uc3RydWN0b3IoZWwpIHtcclxuICAgICAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICAgICAgdGhpcy5lbCA9IGVsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBnZXRTY3JvbGxUb3AoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVsLnNjcm9sbFRvcDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZ2V0U2Nyb2xsTGVmdCgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWwuc2Nyb2xsTGVmdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgc2V0U2Nyb2xsVG9wKHRvcCkge1xyXG4gICAgICAgICAgICB0aGlzLmVsLnNjcm9sbFRvcCA9IHRvcDtcclxuICAgICAgICB9XHJcbiAgICAgICAgc2V0U2Nyb2xsTGVmdChsZWZ0KSB7XHJcbiAgICAgICAgICAgIHRoaXMuZWwuc2Nyb2xsTGVmdCA9IGxlZnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGdldFNjcm9sbFdpZHRoKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbC5zY3JvbGxXaWR0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZ2V0U2Nyb2xsSGVpZ2h0KCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbC5zY3JvbGxIZWlnaHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGdldENsaWVudEhlaWdodCgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWwuY2xpZW50SGVpZ2h0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBnZXRDbGllbnRXaWR0aCgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWwuY2xpZW50V2lkdGg7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY2xhc3MgV2luZG93U2Nyb2xsQ29udHJvbGxlciBleHRlbmRzIFNjcm9sbENvbnRyb2xsZXIge1xyXG4gICAgICAgIGdldFNjcm9sbFRvcCgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy5wYWdlWU9mZnNldDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZ2V0U2Nyb2xsTGVmdCgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy5wYWdlWE9mZnNldDtcclxuICAgICAgICB9XHJcbiAgICAgICAgc2V0U2Nyb2xsVG9wKG4pIHtcclxuICAgICAgICAgICAgd2luZG93LnNjcm9sbCh3aW5kb3cucGFnZVhPZmZzZXQsIG4pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzZXRTY3JvbGxMZWZ0KG4pIHtcclxuICAgICAgICAgICAgd2luZG93LnNjcm9sbChuLCB3aW5kb3cucGFnZVlPZmZzZXQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBnZXRTY3JvbGxXaWR0aCgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxXaWR0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZ2V0U2Nyb2xsSGVpZ2h0KCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbEhlaWdodDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZ2V0Q2xpZW50SGVpZ2h0KCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZ2V0Q2xpZW50V2lkdGgoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGg7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNsYXNzIFRoZW1lIHtcclxuICAgICAgICBjb25zdHJ1Y3RvcihjYWxlbmRhck9wdGlvbnMpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaWNvbk92ZXJyaWRlT3B0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldEljb25PdmVycmlkZShjYWxlbmRhck9wdGlvbnNbdGhpcy5pY29uT3ZlcnJpZGVPcHRpb25dKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBzZXRJY29uT3ZlcnJpZGUoaWNvbk92ZXJyaWRlSGFzaCkge1xyXG4gICAgICAgICAgICBsZXQgaWNvbkNsYXNzZXNDb3B5O1xyXG4gICAgICAgICAgICBsZXQgYnV0dG9uTmFtZTtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBpY29uT3ZlcnJpZGVIYXNoID09PSAnb2JqZWN0JyAmJiBpY29uT3ZlcnJpZGVIYXNoKSB7IC8vIG5vbi1udWxsIG9iamVjdFxyXG4gICAgICAgICAgICAgICAgaWNvbkNsYXNzZXNDb3B5ID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5pY29uQ2xhc3Nlcyk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGJ1dHRvbk5hbWUgaW4gaWNvbk92ZXJyaWRlSGFzaCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGljb25DbGFzc2VzQ29weVtidXR0b25OYW1lXSA9IHRoaXMuYXBwbHlJY29uT3ZlcnJpZGVQcmVmaXgoaWNvbk92ZXJyaWRlSGFzaFtidXR0b25OYW1lXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLmljb25DbGFzc2VzID0gaWNvbkNsYXNzZXNDb3B5O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGljb25PdmVycmlkZUhhc2ggPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmljb25DbGFzc2VzID0ge307XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgYXBwbHlJY29uT3ZlcnJpZGVQcmVmaXgoY2xhc3NOYW1lKSB7XHJcbiAgICAgICAgICAgIGxldCBwcmVmaXggPSB0aGlzLmljb25PdmVycmlkZVByZWZpeDtcclxuICAgICAgICAgICAgaWYgKHByZWZpeCAmJiBjbGFzc05hbWUuaW5kZXhPZihwcmVmaXgpICE9PSAwKSB7IC8vIGlmIG5vdCBhbHJlYWR5IHByZXNlbnRcclxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZSA9IHByZWZpeCArIGNsYXNzTmFtZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gY2xhc3NOYW1lO1xyXG4gICAgICAgIH1cclxuICAgICAgICBnZXRDbGFzcyhrZXkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xhc3Nlc1trZXldIHx8ICcnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBnZXRJY29uQ2xhc3MoYnV0dG9uTmFtZSwgaXNSdGwpIHtcclxuICAgICAgICAgICAgbGV0IGNsYXNzTmFtZTtcclxuICAgICAgICAgICAgaWYgKGlzUnRsICYmIHRoaXMucnRsSWNvbkNsYXNzZXMpIHtcclxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZSA9IHRoaXMucnRsSWNvbkNsYXNzZXNbYnV0dG9uTmFtZV0gfHwgdGhpcy5pY29uQ2xhc3Nlc1tidXR0b25OYW1lXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZSA9IHRoaXMuaWNvbkNsYXNzZXNbYnV0dG9uTmFtZV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGNsYXNzTmFtZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGAke3RoaXMuYmFzZUljb25DbGFzc30gJHtjbGFzc05hbWV9YDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gJyc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGdldEN1c3RvbUJ1dHRvbkljb25DbGFzcyhjdXN0b21CdXR0b25Qcm9wcykge1xyXG4gICAgICAgICAgICBsZXQgY2xhc3NOYW1lO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5pY29uT3ZlcnJpZGVDdXN0b21CdXR0b25PcHRpb24pIHtcclxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZSA9IGN1c3RvbUJ1dHRvblByb3BzW3RoaXMuaWNvbk92ZXJyaWRlQ3VzdG9tQnV0dG9uT3B0aW9uXTtcclxuICAgICAgICAgICAgICAgIGlmIChjbGFzc05hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYCR7dGhpcy5iYXNlSWNvbkNsYXNzfSAke3RoaXMuYXBwbHlJY29uT3ZlcnJpZGVQcmVmaXgoY2xhc3NOYW1lKX1gO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiAnJztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBUaGVtZS5wcm90b3R5cGUuY2xhc3NlcyA9IHt9O1xyXG4gICAgVGhlbWUucHJvdG90eXBlLmljb25DbGFzc2VzID0ge307XHJcbiAgICBUaGVtZS5wcm90b3R5cGUuYmFzZUljb25DbGFzcyA9ICcnO1xyXG4gICAgVGhlbWUucHJvdG90eXBlLmljb25PdmVycmlkZVByZWZpeCA9ICcnO1xyXG5cclxuICAgIC8qXHJcbiAgICBOT1RFOiB0aGlzIGNhbiBiZSBhIHB1YmxpYyBBUEksIGVzcGVjaWFsbHkgY3JlYXRlRWxlbWVudCBmb3IgaG9va3MuXHJcbiAgICBTZWUgZXhhbXBsZXMvdHlwZXNjcmlwdC1zY2hlZHVsZXIvc3JjL2luZGV4LnRzXHJcbiAgICAqL1xyXG4gICAgZnVuY3Rpb24gZmx1c2hTeW5jKHJ1bkJlZm9yZUZsdXNoKSB7XHJcbiAgICAgICAgcnVuQmVmb3JlRmx1c2goKTtcclxuICAgICAgICBsZXQgb2xkRGVib3VuY2VSZW5kZXJpbmcgPSBsJDEuZGVib3VuY2VSZW5kZXJpbmc7IC8vIG9yaWdcclxuICAgICAgICBsZXQgY2FsbGJhY2tRID0gW107XHJcbiAgICAgICAgZnVuY3Rpb24gZXhlY0NhbGxiYWNrU3luYyhjYWxsYmFjaykge1xyXG4gICAgICAgICAgICBjYWxsYmFja1EucHVzaChjYWxsYmFjayk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGwkMS5kZWJvdW5jZVJlbmRlcmluZyA9IGV4ZWNDYWxsYmFja1N5bmM7XHJcbiAgICAgICAgRCQxKHkoRmFrZUNvbXBvbmVudCwge30pLCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSk7XHJcbiAgICAgICAgd2hpbGUgKGNhbGxiYWNrUS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgY2FsbGJhY2tRLnNoaWZ0KCkoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbCQxLmRlYm91bmNlUmVuZGVyaW5nID0gb2xkRGVib3VuY2VSZW5kZXJpbmc7XHJcbiAgICB9XHJcbiAgICBjbGFzcyBGYWtlQ29tcG9uZW50IGV4dGVuZHMgeCQxIHtcclxuICAgICAgICByZW5kZXIoKSB7IHJldHVybiB5KCdkaXYnLCB7fSk7IH1cclxuICAgICAgICBjb21wb25lbnREaWRNb3VudCgpIHsgdGhpcy5zZXRTdGF0ZSh7fSk7IH1cclxuICAgIH1cclxuICAgIC8vIFRPRE86IHVzZSBwcmVhY3QvY29tcGF0IGluc3RlYWQ/XHJcbiAgICBmdW5jdGlvbiBjcmVhdGVDb250ZXh0KGRlZmF1bHRWYWx1ZSkge1xyXG4gICAgICAgIGxldCBDb250ZXh0VHlwZSA9IEckMShkZWZhdWx0VmFsdWUpO1xyXG4gICAgICAgIGxldCBvcmlnUHJvdmlkZXIgPSBDb250ZXh0VHlwZS5Qcm92aWRlcjtcclxuICAgICAgICBDb250ZXh0VHlwZS5Qcm92aWRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgbGV0IGlzTmV3ID0gIXRoaXMuZ2V0Q2hpbGRDb250ZXh0O1xyXG4gICAgICAgICAgICBsZXQgY2hpbGRyZW4gPSBvcmlnUHJvdmlkZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBwcmVmZXItcmVzdC1wYXJhbXNcclxuICAgICAgICAgICAgaWYgKGlzTmV3KSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgc3VicyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zaG91bGRDb21wb25lbnRVcGRhdGUgPSAoX3Byb3BzKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucHJvcHMudmFsdWUgIT09IF9wcm9wcy52YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJzLmZvckVhY2goKGMpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuY29udGV4dCA9IF9wcm9wcy52YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuZm9yY2VVcGRhdGUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3ViID0gKGMpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBzdWJzLnB1c2goYyk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IG9sZCA9IGMuY29tcG9uZW50V2lsbFVubW91bnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgYy5jb21wb25lbnRXaWxsVW5tb3VudCA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3Vicy5zcGxpY2Uoc3Vicy5pbmRleE9mKGMpLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb2xkICYmIG9sZC5jYWxsKGMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBjaGlsZHJlbjtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBDb250ZXh0VHlwZTtcclxuICAgIH1cclxuXHJcbiAgICBjbGFzcyBTY3JvbGxSZXNwb25kZXIge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yKGV4ZWNGdW5jLCBlbWl0dGVyLCBzY3JvbGxUaW1lLCBzY3JvbGxUaW1lUmVzZXQpIHtcclxuICAgICAgICAgICAgdGhpcy5leGVjRnVuYyA9IGV4ZWNGdW5jO1xyXG4gICAgICAgICAgICB0aGlzLmVtaXR0ZXIgPSBlbWl0dGVyO1xyXG4gICAgICAgICAgICB0aGlzLnNjcm9sbFRpbWUgPSBzY3JvbGxUaW1lO1xyXG4gICAgICAgICAgICB0aGlzLnNjcm9sbFRpbWVSZXNldCA9IHNjcm9sbFRpbWVSZXNldDtcclxuICAgICAgICAgICAgdGhpcy5oYW5kbGVTY3JvbGxSZXF1ZXN0ID0gKHJlcXVlc3QpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMucXVldWVkUmVxdWVzdCA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMucXVldWVkUmVxdWVzdCB8fCB7fSwgcmVxdWVzdCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRyYWluKCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGVtaXR0ZXIub24oJ19zY3JvbGxSZXF1ZXN0JywgdGhpcy5oYW5kbGVTY3JvbGxSZXF1ZXN0KTtcclxuICAgICAgICAgICAgdGhpcy5maXJlSW5pdGlhbFNjcm9sbCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkZXRhY2goKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZW1pdHRlci5vZmYoJ19zY3JvbGxSZXF1ZXN0JywgdGhpcy5oYW5kbGVTY3JvbGxSZXF1ZXN0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdXBkYXRlKGlzRGF0ZXNOZXcpIHtcclxuICAgICAgICAgICAgaWYgKGlzRGF0ZXNOZXcgJiYgdGhpcy5zY3JvbGxUaW1lUmVzZXQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZmlyZUluaXRpYWxTY3JvbGwoKTsgLy8gd2lsbCBkcmFpblxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kcmFpbigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZpcmVJbml0aWFsU2Nyb2xsKCkge1xyXG4gICAgICAgICAgICB0aGlzLmhhbmRsZVNjcm9sbFJlcXVlc3Qoe1xyXG4gICAgICAgICAgICAgICAgdGltZTogdGhpcy5zY3JvbGxUaW1lLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZHJhaW4oKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnF1ZXVlZFJlcXVlc3QgJiYgdGhpcy5leGVjRnVuYyh0aGlzLnF1ZXVlZFJlcXVlc3QpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnF1ZXVlZFJlcXVlc3QgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IFZpZXdDb250ZXh0VHlwZSA9IGNyZWF0ZUNvbnRleHQoe30pOyAvLyBmb3IgQ29tcG9uZW50c1xyXG4gICAgZnVuY3Rpb24gYnVpbGRWaWV3Q29udGV4dCh2aWV3U3BlYywgdmlld0FwaSwgdmlld09wdGlvbnMsIGRhdGVQcm9maWxlR2VuZXJhdG9yLCBkYXRlRW52LCB0aGVtZSwgcGx1Z2luSG9va3MsIGRpc3BhdGNoLCBnZXRDdXJyZW50RGF0YSwgZW1pdHRlciwgY2FsZW5kYXJBcGksIHJlZ2lzdGVySW50ZXJhY3RpdmVDb21wb25lbnQsIHVucmVnaXN0ZXJJbnRlcmFjdGl2ZUNvbXBvbmVudCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGRhdGVFbnYsXHJcbiAgICAgICAgICAgIG9wdGlvbnM6IHZpZXdPcHRpb25zLFxyXG4gICAgICAgICAgICBwbHVnaW5Ib29rcyxcclxuICAgICAgICAgICAgZW1pdHRlcixcclxuICAgICAgICAgICAgZGlzcGF0Y2gsXHJcbiAgICAgICAgICAgIGdldEN1cnJlbnREYXRhLFxyXG4gICAgICAgICAgICBjYWxlbmRhckFwaSxcclxuICAgICAgICAgICAgdmlld1NwZWMsXHJcbiAgICAgICAgICAgIHZpZXdBcGksXHJcbiAgICAgICAgICAgIGRhdGVQcm9maWxlR2VuZXJhdG9yLFxyXG4gICAgICAgICAgICB0aGVtZSxcclxuICAgICAgICAgICAgaXNSdGw6IHZpZXdPcHRpb25zLmRpcmVjdGlvbiA9PT0gJ3J0bCcsXHJcbiAgICAgICAgICAgIGFkZFJlc2l6ZUhhbmRsZXIoaGFuZGxlcikge1xyXG4gICAgICAgICAgICAgICAgZW1pdHRlci5vbignX3Jlc2l6ZScsIGhhbmRsZXIpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICByZW1vdmVSZXNpemVIYW5kbGVyKGhhbmRsZXIpIHtcclxuICAgICAgICAgICAgICAgIGVtaXR0ZXIub2ZmKCdfcmVzaXplJywgaGFuZGxlcik7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGNyZWF0ZVNjcm9sbFJlc3BvbmRlcihleGVjRnVuYykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTY3JvbGxSZXNwb25kZXIoZXhlY0Z1bmMsIGVtaXR0ZXIsIGNyZWF0ZUR1cmF0aW9uKHZpZXdPcHRpb25zLnNjcm9sbFRpbWUpLCB2aWV3T3B0aW9ucy5zY3JvbGxUaW1lUmVzZXQpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICByZWdpc3RlckludGVyYWN0aXZlQ29tcG9uZW50LFxyXG4gICAgICAgICAgICB1bnJlZ2lzdGVySW50ZXJhY3RpdmVDb21wb25lbnQsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICAvKiBlc2xpbnQgbWF4LWNsYXNzZXMtcGVyLWZpbGU6IG9mZiAqL1xyXG4gICAgY2xhc3MgUHVyZUNvbXBvbmVudCBleHRlbmRzIHgkMSB7XHJcbiAgICAgICAgc2hvdWxkQ29tcG9uZW50VXBkYXRlKG5leHRQcm9wcywgbmV4dFN0YXRlKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmRlYnVnKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coZ2V0VW5lcXVhbFByb3BzKG5leHRQcm9wcywgdGhpcy5wcm9wcyksIGdldFVuZXF1YWxQcm9wcyhuZXh0U3RhdGUsIHRoaXMuc3RhdGUpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gIWNvbXBhcmVPYmpzKHRoaXMucHJvcHMsIG5leHRQcm9wcywgdGhpcy5wcm9wRXF1YWxpdHkpIHx8XHJcbiAgICAgICAgICAgICAgICAhY29tcGFyZU9ianModGhpcy5zdGF0ZSwgbmV4dFN0YXRlLCB0aGlzLnN0YXRlRXF1YWxpdHkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBIQUNLIGZvciBmcmVha2luJyBSZWFjdCBTdHJpY3RNb2RlXHJcbiAgICAgICAgc2FmZVNldFN0YXRlKG5ld1N0YXRlKSB7XHJcbiAgICAgICAgICAgIGlmICghY29tcGFyZU9ianModGhpcy5zdGF0ZSwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLnN0YXRlKSwgbmV3U3RhdGUpLCB0aGlzLnN0YXRlRXF1YWxpdHkpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKG5ld1N0YXRlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIFB1cmVDb21wb25lbnQuYWRkUHJvcHNFcXVhbGl0eSA9IGFkZFByb3BzRXF1YWxpdHk7XHJcbiAgICBQdXJlQ29tcG9uZW50LmFkZFN0YXRlRXF1YWxpdHkgPSBhZGRTdGF0ZUVxdWFsaXR5O1xyXG4gICAgUHVyZUNvbXBvbmVudC5jb250ZXh0VHlwZSA9IFZpZXdDb250ZXh0VHlwZTtcclxuICAgIFB1cmVDb21wb25lbnQucHJvdG90eXBlLnByb3BFcXVhbGl0eSA9IHt9O1xyXG4gICAgUHVyZUNvbXBvbmVudC5wcm90b3R5cGUuc3RhdGVFcXVhbGl0eSA9IHt9O1xyXG4gICAgY2xhc3MgQmFzZUNvbXBvbmVudCBleHRlbmRzIFB1cmVDb21wb25lbnQge1xyXG4gICAgfVxyXG4gICAgQmFzZUNvbXBvbmVudC5jb250ZXh0VHlwZSA9IFZpZXdDb250ZXh0VHlwZTtcclxuICAgIGZ1bmN0aW9uIGFkZFByb3BzRXF1YWxpdHkocHJvcEVxdWFsaXR5KSB7XHJcbiAgICAgICAgbGV0IGhhc2ggPSBPYmplY3QuY3JlYXRlKHRoaXMucHJvdG90eXBlLnByb3BFcXVhbGl0eSk7XHJcbiAgICAgICAgT2JqZWN0LmFzc2lnbihoYXNoLCBwcm9wRXF1YWxpdHkpO1xyXG4gICAgICAgIHRoaXMucHJvdG90eXBlLnByb3BFcXVhbGl0eSA9IGhhc2g7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBhZGRTdGF0ZUVxdWFsaXR5KHN0YXRlRXF1YWxpdHkpIHtcclxuICAgICAgICBsZXQgaGFzaCA9IE9iamVjdC5jcmVhdGUodGhpcy5wcm90b3R5cGUuc3RhdGVFcXVhbGl0eSk7XHJcbiAgICAgICAgT2JqZWN0LmFzc2lnbihoYXNoLCBzdGF0ZUVxdWFsaXR5KTtcclxuICAgICAgICB0aGlzLnByb3RvdHlwZS5zdGF0ZUVxdWFsaXR5ID0gaGFzaDtcclxuICAgIH1cclxuICAgIC8vIHVzZSBvdGhlciBvbmVcclxuICAgIGZ1bmN0aW9uIHNldFJlZihyZWYsIGN1cnJlbnQpIHtcclxuICAgICAgICBpZiAodHlwZW9mIHJlZiA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICByZWYoY3VycmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHJlZikge1xyXG4gICAgICAgICAgICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMzAyOVxyXG4gICAgICAgICAgICByZWYuY3VycmVudCA9IGN1cnJlbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qXHJcbiAgICBhbiBJTlRFUkFDVEFCTEUgZGF0ZSBjb21wb25lbnRcclxuXHJcbiAgICBQVVJQT1NFUzpcclxuICAgIC0gaG9vayB1cCB0byBmZywgZmlsbCwgYW5kIG1pcnJvciByZW5kZXJlcnNcclxuICAgIC0gaW50ZXJmYWNlIGZvciBkcmFnZ2luZyBhbmQgaGl0c1xyXG4gICAgKi9cclxuICAgIGNsYXNzIERhdGVDb21wb25lbnQgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcclxuICAgICAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgdGhpcy51aWQgPSBndWlkKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEhpdCBTeXN0ZW1cclxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgICAgIHByZXBhcmVIaXRzKCkge1xyXG4gICAgICAgIH1cclxuICAgICAgICBxdWVyeUhpdChwb3NpdGlvbkxlZnQsIHBvc2l0aW9uVG9wLCBlbFdpZHRoLCBlbEhlaWdodCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDsgLy8gdGhpcyBzaG91bGQgYmUgYWJzdHJhY3RcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gUG9pbnRlciBJbnRlcmFjdGlvbiBVdGlsc1xyXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAgICAgaXNWYWxpZFNlZ0Rvd25FbChlbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gIXRoaXMucHJvcHMuZXZlbnREcmFnICYmIC8vIEhBQ0tcclxuICAgICAgICAgICAgICAgICF0aGlzLnByb3BzLmV2ZW50UmVzaXplICYmIC8vIEhBQ0tcclxuICAgICAgICAgICAgICAgICFlbGVtZW50Q2xvc2VzdChlbCwgJy5mYy1ldmVudC1taXJyb3InKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaXNWYWxpZERhdGVEb3duRWwoZWwpIHtcclxuICAgICAgICAgICAgcmV0dXJuICFlbGVtZW50Q2xvc2VzdChlbCwgJy5mYy1ldmVudDpub3QoLmZjLWJnLWV2ZW50KScpICYmXHJcbiAgICAgICAgICAgICAgICAhZWxlbWVudENsb3Nlc3QoZWwsICcuZmMtbW9yZS1saW5rJykgJiYgLy8gYSBcIm1vcmUuLlwiIGxpbmtcclxuICAgICAgICAgICAgICAgICFlbGVtZW50Q2xvc2VzdChlbCwgJ2FbZGF0YS1uYXZsaW5rXScpICYmIC8vIGEgY2xpY2thYmxlIG5hdiBsaW5rXHJcbiAgICAgICAgICAgICAgICAhZWxlbWVudENsb3Nlc3QoZWwsICcuZmMtcG9wb3ZlcicpOyAvLyBoYWNrXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHJlZHVjZUN1cnJlbnREYXRlKGN1cnJlbnREYXRlLCBhY3Rpb24pIHtcclxuICAgICAgICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgJ0NIQU5HRV9EQVRFJzpcclxuICAgICAgICAgICAgICAgIHJldHVybiBhY3Rpb24uZGF0ZU1hcmtlcjtcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHJldHVybiBjdXJyZW50RGF0ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBnZXRJbml0aWFsRGF0ZShvcHRpb25zLCBkYXRlRW52KSB7XHJcbiAgICAgICAgbGV0IGluaXRpYWxEYXRlSW5wdXQgPSBvcHRpb25zLmluaXRpYWxEYXRlO1xyXG4gICAgICAgIC8vIGNvbXB1dGUgdGhlIGluaXRpYWwgYW1iaWctdGltZXpvbmUgZGF0ZVxyXG4gICAgICAgIGlmIChpbml0aWFsRGF0ZUlucHV0ICE9IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGRhdGVFbnYuY3JlYXRlTWFya2VyKGluaXRpYWxEYXRlSW5wdXQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZ2V0Tm93KG9wdGlvbnMubm93LCBkYXRlRW52KTsgLy8gZ2V0Tm93IGFscmVhZHkgcmV0dXJucyB1bnpvbmVkXHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBnZXROb3cobm93SW5wdXQsIGRhdGVFbnYpIHtcclxuICAgICAgICBpZiAodHlwZW9mIG5vd0lucHV0ID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIG5vd0lucHV0ID0gbm93SW5wdXQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG5vd0lucHV0ID09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGRhdGVFbnYuY3JlYXRlTm93TWFya2VyKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkYXRlRW52LmNyZWF0ZU1hcmtlcihub3dJbnB1dCk7XHJcbiAgICB9XHJcblxyXG4gICAgY2xhc3MgRGF0ZVByb2ZpbGVHZW5lcmF0b3Ige1xyXG4gICAgICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJvcHMgPSBwcm9wcztcclxuICAgICAgICAgICAgdGhpcy5ub3dEYXRlID0gZ2V0Tm93KHByb3BzLm5vd0lucHV0LCBwcm9wcy5kYXRlRW52KTtcclxuICAgICAgICAgICAgdGhpcy5pbml0SGlkZGVuRGF5cygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKiBEYXRlIFJhbmdlIENvbXB1dGF0aW9uXHJcbiAgICAgICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgICAgICAvLyBCdWlsZHMgYSBzdHJ1Y3R1cmUgd2l0aCBpbmZvIGFib3V0IHdoYXQgdGhlIGRhdGVzL3JhbmdlcyB3aWxsIGJlIGZvciB0aGUgXCJwcmV2XCIgdmlldy5cclxuICAgICAgICBidWlsZFByZXYoY3VycmVudERhdGVQcm9maWxlLCBjdXJyZW50RGF0ZSwgZm9yY2VUb1ZhbGlkKSB7XHJcbiAgICAgICAgICAgIGxldCB7IGRhdGVFbnYgfSA9IHRoaXMucHJvcHM7XHJcbiAgICAgICAgICAgIGxldCBwcmV2RGF0ZSA9IGRhdGVFbnYuc3VidHJhY3QoZGF0ZUVudi5zdGFydE9mKGN1cnJlbnREYXRlLCBjdXJyZW50RGF0ZVByb2ZpbGUuY3VycmVudFJhbmdlVW5pdCksIC8vIGltcG9ydGFudCBmb3Igc3RhcnQtb2YtbW9udGhcclxuICAgICAgICAgICAgY3VycmVudERhdGVQcm9maWxlLmRhdGVJbmNyZW1lbnQpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5idWlsZChwcmV2RGF0ZSwgLTEsIGZvcmNlVG9WYWxpZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEJ1aWxkcyBhIHN0cnVjdHVyZSB3aXRoIGluZm8gYWJvdXQgd2hhdCB0aGUgZGF0ZXMvcmFuZ2VzIHdpbGwgYmUgZm9yIHRoZSBcIm5leHRcIiB2aWV3LlxyXG4gICAgICAgIGJ1aWxkTmV4dChjdXJyZW50RGF0ZVByb2ZpbGUsIGN1cnJlbnREYXRlLCBmb3JjZVRvVmFsaWQpIHtcclxuICAgICAgICAgICAgbGV0IHsgZGF0ZUVudiB9ID0gdGhpcy5wcm9wcztcclxuICAgICAgICAgICAgbGV0IG5leHREYXRlID0gZGF0ZUVudi5hZGQoZGF0ZUVudi5zdGFydE9mKGN1cnJlbnREYXRlLCBjdXJyZW50RGF0ZVByb2ZpbGUuY3VycmVudFJhbmdlVW5pdCksIC8vIGltcG9ydGFudCBmb3Igc3RhcnQtb2YtbW9udGhcclxuICAgICAgICAgICAgY3VycmVudERhdGVQcm9maWxlLmRhdGVJbmNyZW1lbnQpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5idWlsZChuZXh0RGF0ZSwgMSwgZm9yY2VUb1ZhbGlkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQnVpbGRzIGEgc3RydWN0dXJlIGhvbGRpbmcgZGF0ZXMvcmFuZ2VzIGZvciByZW5kZXJpbmcgYXJvdW5kIHRoZSBnaXZlbiBkYXRlLlxyXG4gICAgICAgIC8vIE9wdGlvbmFsIGRpcmVjdGlvbiBwYXJhbSBpbmRpY2F0ZXMgd2hldGhlciB0aGUgZGF0ZSBpcyBiZWluZyBpbmNyZW1lbnRlZC9kZWNyZW1lbnRlZFxyXG4gICAgICAgIC8vIGZyb20gaXRzIHByZXZpb3VzIHZhbHVlLiBkZWNyZW1lbnRlZCA9IC0xLCBpbmNyZW1lbnRlZCA9IDEgKGRlZmF1bHQpLlxyXG4gICAgICAgIGJ1aWxkKGN1cnJlbnREYXRlLCBkaXJlY3Rpb24sIGZvcmNlVG9WYWxpZCA9IHRydWUpIHtcclxuICAgICAgICAgICAgbGV0IHsgcHJvcHMgfSA9IHRoaXM7XHJcbiAgICAgICAgICAgIGxldCB2YWxpZFJhbmdlO1xyXG4gICAgICAgICAgICBsZXQgY3VycmVudEluZm87XHJcbiAgICAgICAgICAgIGxldCBpc1JhbmdlQWxsRGF5O1xyXG4gICAgICAgICAgICBsZXQgcmVuZGVyUmFuZ2U7XHJcbiAgICAgICAgICAgIGxldCBhY3RpdmVSYW5nZTtcclxuICAgICAgICAgICAgbGV0IGlzVmFsaWQ7XHJcbiAgICAgICAgICAgIHZhbGlkUmFuZ2UgPSB0aGlzLmJ1aWxkVmFsaWRSYW5nZSgpO1xyXG4gICAgICAgICAgICB2YWxpZFJhbmdlID0gdGhpcy50cmltSGlkZGVuRGF5cyh2YWxpZFJhbmdlKTtcclxuICAgICAgICAgICAgaWYgKGZvcmNlVG9WYWxpZCkge1xyXG4gICAgICAgICAgICAgICAgY3VycmVudERhdGUgPSBjb25zdHJhaW5NYXJrZXJUb1JhbmdlKGN1cnJlbnREYXRlLCB2YWxpZFJhbmdlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjdXJyZW50SW5mbyA9IHRoaXMuYnVpbGRDdXJyZW50UmFuZ2VJbmZvKGN1cnJlbnREYXRlLCBkaXJlY3Rpb24pO1xyXG4gICAgICAgICAgICBpc1JhbmdlQWxsRGF5ID0gL14oeWVhcnxtb250aHx3ZWVrfGRheSkkLy50ZXN0KGN1cnJlbnRJbmZvLnVuaXQpO1xyXG4gICAgICAgICAgICByZW5kZXJSYW5nZSA9IHRoaXMuYnVpbGRSZW5kZXJSYW5nZSh0aGlzLnRyaW1IaWRkZW5EYXlzKGN1cnJlbnRJbmZvLnJhbmdlKSwgY3VycmVudEluZm8udW5pdCwgaXNSYW5nZUFsbERheSk7XHJcbiAgICAgICAgICAgIHJlbmRlclJhbmdlID0gdGhpcy50cmltSGlkZGVuRGF5cyhyZW5kZXJSYW5nZSk7XHJcbiAgICAgICAgICAgIGFjdGl2ZVJhbmdlID0gcmVuZGVyUmFuZ2U7XHJcbiAgICAgICAgICAgIGlmICghcHJvcHMuc2hvd05vbkN1cnJlbnREYXRlcykge1xyXG4gICAgICAgICAgICAgICAgYWN0aXZlUmFuZ2UgPSBpbnRlcnNlY3RSYW5nZXMoYWN0aXZlUmFuZ2UsIGN1cnJlbnRJbmZvLnJhbmdlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBhY3RpdmVSYW5nZSA9IHRoaXMuYWRqdXN0QWN0aXZlUmFuZ2UoYWN0aXZlUmFuZ2UpO1xyXG4gICAgICAgICAgICBhY3RpdmVSYW5nZSA9IGludGVyc2VjdFJhbmdlcyhhY3RpdmVSYW5nZSwgdmFsaWRSYW5nZSk7IC8vIG1pZ2h0IHJldHVybiBudWxsXHJcbiAgICAgICAgICAgIC8vIGl0J3MgaW52YWxpZCBpZiB0aGUgb3JpZ2luYWxseSByZXF1ZXN0ZWQgZGF0ZSBpcyBub3QgY29udGFpbmVkLFxyXG4gICAgICAgICAgICAvLyBvciBpZiB0aGUgcmFuZ2UgaXMgY29tcGxldGVseSBvdXRzaWRlIG9mIHRoZSB2YWxpZCByYW5nZS5cclxuICAgICAgICAgICAgaXNWYWxpZCA9IHJhbmdlc0ludGVyc2VjdChjdXJyZW50SW5mby5yYW5nZSwgdmFsaWRSYW5nZSk7XHJcbiAgICAgICAgICAgIC8vIEhBQ0s6IGNvbnN0cmFpbiB0byByZW5kZXItcmFuZ2Ugc28gYGN1cnJlbnREYXRlYCBpcyBtb3JlIHVzZWZ1bCB0byB2aWV3IHJlbmRlcmluZ1xyXG4gICAgICAgICAgICBpZiAoIXJhbmdlQ29udGFpbnNNYXJrZXIocmVuZGVyUmFuZ2UsIGN1cnJlbnREYXRlKSkge1xyXG4gICAgICAgICAgICAgICAgY3VycmVudERhdGUgPSByZW5kZXJSYW5nZS5zdGFydDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgY3VycmVudERhdGUsXHJcbiAgICAgICAgICAgICAgICAvLyBjb25zdHJhaW50IGZvciB3aGVyZSBwcmV2L25leHQgb3BlcmF0aW9ucyBjYW4gZ28gYW5kIHdoZXJlIGV2ZW50cyBjYW4gYmUgZHJhZ2dlZC9yZXNpemVkIHRvLlxyXG4gICAgICAgICAgICAgICAgLy8gYW4gb2JqZWN0IHdpdGggb3B0aW9uYWwgc3RhcnQgYW5kIGVuZCBwcm9wZXJ0aWVzLlxyXG4gICAgICAgICAgICAgICAgdmFsaWRSYW5nZSxcclxuICAgICAgICAgICAgICAgIC8vIHJhbmdlIHRoZSB2aWV3IGlzIGZvcm1hbGx5IHJlc3BvbnNpYmxlIGZvci5cclxuICAgICAgICAgICAgICAgIC8vIGZvciBleGFtcGxlLCBhIG1vbnRoIHZpZXcgbWlnaHQgaGF2ZSAxc3QtMzFzdCwgZXhjbHVkaW5nIHBhZGRlZCBkYXRlc1xyXG4gICAgICAgICAgICAgICAgY3VycmVudFJhbmdlOiBjdXJyZW50SW5mby5yYW5nZSxcclxuICAgICAgICAgICAgICAgIC8vIG5hbWUgb2YgbGFyZ2VzdCB1bml0IGJlaW5nIGRpc3BsYXllZCwgbGlrZSBcIm1vbnRoXCIgb3IgXCJ3ZWVrXCJcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRSYW5nZVVuaXQ6IGN1cnJlbnRJbmZvLnVuaXQsXHJcbiAgICAgICAgICAgICAgICBpc1JhbmdlQWxsRGF5LFxyXG4gICAgICAgICAgICAgICAgLy8gZGF0ZXMgdGhhdCBkaXNwbGF5IGV2ZW50cyBhbmQgYWNjZXB0IGRyYWctbi1kcm9wXHJcbiAgICAgICAgICAgICAgICAvLyB3aWxsIGJlIGBudWxsYCBpZiBubyBkYXRlcyBhY2NlcHQgZXZlbnRzXHJcbiAgICAgICAgICAgICAgICBhY3RpdmVSYW5nZSxcclxuICAgICAgICAgICAgICAgIC8vIGRhdGUgcmFuZ2Ugd2l0aCBhIHJlbmRlcmVkIHNrZWxldG9uXHJcbiAgICAgICAgICAgICAgICAvLyBpbmNsdWRlcyBub3QtYWN0aXZlIGRheXMgdGhhdCBuZWVkIHNvbWUgc29ydCBvZiBET01cclxuICAgICAgICAgICAgICAgIHJlbmRlclJhbmdlLFxyXG4gICAgICAgICAgICAgICAgLy8gRHVyYXRpb24gb2JqZWN0IHRoYXQgZGVub3RlcyB0aGUgZmlyc3QgdmlzaWJsZSB0aW1lIG9mIGFueSBnaXZlbiBkYXlcclxuICAgICAgICAgICAgICAgIHNsb3RNaW5UaW1lOiBwcm9wcy5zbG90TWluVGltZSxcclxuICAgICAgICAgICAgICAgIC8vIER1cmF0aW9uIG9iamVjdCB0aGF0IGRlbm90ZXMgdGhlIGV4Y2x1c2l2ZSB2aXNpYmxlIGVuZCB0aW1lIG9mIGFueSBnaXZlbiBkYXlcclxuICAgICAgICAgICAgICAgIHNsb3RNYXhUaW1lOiBwcm9wcy5zbG90TWF4VGltZSxcclxuICAgICAgICAgICAgICAgIGlzVmFsaWQsXHJcbiAgICAgICAgICAgICAgICAvLyBob3cgZmFyIHRoZSBjdXJyZW50IGRhdGUgd2lsbCBtb3ZlIGZvciBhIHByZXYvbmV4dCBvcGVyYXRpb25cclxuICAgICAgICAgICAgICAgIGRhdGVJbmNyZW1lbnQ6IHRoaXMuYnVpbGREYXRlSW5jcmVtZW50KGN1cnJlbnRJbmZvLmR1cmF0aW9uKSxcclxuICAgICAgICAgICAgICAgIC8vIHBhc3MgYSBmYWxsYmFjayAobWlnaHQgYmUgbnVsbCkgXlxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBCdWlsZHMgYW4gb2JqZWN0IHdpdGggb3B0aW9uYWwgc3RhcnQvZW5kIHByb3BlcnRpZXMuXHJcbiAgICAgICAgLy8gSW5kaWNhdGVzIHRoZSBtaW5pbXVtL21heGltdW0gZGF0ZXMgdG8gZGlzcGxheS5cclxuICAgICAgICAvLyBub3QgcmVzcG9uc2libGUgZm9yIHRyaW1taW5nIGhpZGRlbiBkYXlzLlxyXG4gICAgICAgIGJ1aWxkVmFsaWRSYW5nZSgpIHtcclxuICAgICAgICAgICAgbGV0IGlucHV0ID0gdGhpcy5wcm9wcy52YWxpZFJhbmdlSW5wdXQ7XHJcbiAgICAgICAgICAgIGxldCBzaW1wbGVJbnB1dCA9IHR5cGVvZiBpbnB1dCA9PT0gJ2Z1bmN0aW9uJ1xyXG4gICAgICAgICAgICAgICAgPyBpbnB1dC5jYWxsKHRoaXMucHJvcHMuY2FsZW5kYXJBcGksIHRoaXMubm93RGF0ZSlcclxuICAgICAgICAgICAgICAgIDogaW5wdXQ7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlZmluZVJhbmdlKHNpbXBsZUlucHV0KSB8fFxyXG4gICAgICAgICAgICAgICAgeyBzdGFydDogbnVsbCwgZW5kOiBudWxsIH07IC8vIGNvbXBsZXRlbHkgb3Blbi1lbmRlZFxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBCdWlsZHMgYSBzdHJ1Y3R1cmUgd2l0aCBpbmZvIGFib3V0IHRoZSBcImN1cnJlbnRcIiByYW5nZSwgdGhlIHJhbmdlIHRoYXQgaXNcclxuICAgICAgICAvLyBoaWdobGlnaHRlZCBhcyBiZWluZyB0aGUgY3VycmVudCBtb250aCBmb3IgZXhhbXBsZS5cclxuICAgICAgICAvLyBTZWUgYnVpbGQoKSBmb3IgYSBkZXNjcmlwdGlvbiBvZiBgZGlyZWN0aW9uYC5cclxuICAgICAgICAvLyBHdWFyYW50ZWVkIHRvIGhhdmUgYHJhbmdlYCBhbmQgYHVuaXRgIHByb3BlcnRpZXMuIGBkdXJhdGlvbmAgaXMgb3B0aW9uYWwuXHJcbiAgICAgICAgYnVpbGRDdXJyZW50UmFuZ2VJbmZvKGRhdGUsIGRpcmVjdGlvbikge1xyXG4gICAgICAgICAgICBsZXQgeyBwcm9wcyB9ID0gdGhpcztcclxuICAgICAgICAgICAgbGV0IGR1cmF0aW9uID0gbnVsbDtcclxuICAgICAgICAgICAgbGV0IHVuaXQgPSBudWxsO1xyXG4gICAgICAgICAgICBsZXQgcmFuZ2UgPSBudWxsO1xyXG4gICAgICAgICAgICBsZXQgZGF5Q291bnQ7XHJcbiAgICAgICAgICAgIGlmIChwcm9wcy5kdXJhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgZHVyYXRpb24gPSBwcm9wcy5kdXJhdGlvbjtcclxuICAgICAgICAgICAgICAgIHVuaXQgPSBwcm9wcy5kdXJhdGlvblVuaXQ7XHJcbiAgICAgICAgICAgICAgICByYW5nZSA9IHRoaXMuYnVpbGRSYW5nZUZyb21EdXJhdGlvbihkYXRlLCBkaXJlY3Rpb24sIGR1cmF0aW9uLCB1bml0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICgoZGF5Q291bnQgPSB0aGlzLnByb3BzLmRheUNvdW50KSkge1xyXG4gICAgICAgICAgICAgICAgdW5pdCA9ICdkYXknO1xyXG4gICAgICAgICAgICAgICAgcmFuZ2UgPSB0aGlzLmJ1aWxkUmFuZ2VGcm9tRGF5Q291bnQoZGF0ZSwgZGlyZWN0aW9uLCBkYXlDb3VudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoKHJhbmdlID0gdGhpcy5idWlsZEN1c3RvbVZpc2libGVSYW5nZShkYXRlKSkpIHtcclxuICAgICAgICAgICAgICAgIHVuaXQgPSBwcm9wcy5kYXRlRW52LmdyZWF0ZXN0V2hvbGVVbml0KHJhbmdlLnN0YXJ0LCByYW5nZS5lbmQpLnVuaXQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBkdXJhdGlvbiA9IHRoaXMuZ2V0RmFsbGJhY2tEdXJhdGlvbigpO1xyXG4gICAgICAgICAgICAgICAgdW5pdCA9IGdyZWF0ZXN0RHVyYXRpb25EZW5vbWluYXRvcihkdXJhdGlvbikudW5pdDtcclxuICAgICAgICAgICAgICAgIHJhbmdlID0gdGhpcy5idWlsZFJhbmdlRnJvbUR1cmF0aW9uKGRhdGUsIGRpcmVjdGlvbiwgZHVyYXRpb24sIHVuaXQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB7IGR1cmF0aW9uLCB1bml0LCByYW5nZSB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBnZXRGYWxsYmFja0R1cmF0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlRHVyYXRpb24oeyBkYXk6IDEgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFJldHVybnMgYSBuZXcgYWN0aXZlUmFuZ2UgdG8gaGF2ZSB0aW1lIHZhbHVlcyAodW4tYW1iaWd1YXRlKVxyXG4gICAgICAgIC8vIHNsb3RNaW5UaW1lIG9yIHNsb3RNYXhUaW1lIGNhdXNlcyB0aGUgcmFuZ2UgdG8gZXhwYW5kLlxyXG4gICAgICAgIGFkanVzdEFjdGl2ZVJhbmdlKHJhbmdlKSB7XHJcbiAgICAgICAgICAgIGxldCB7IGRhdGVFbnYsIHVzZXNNaW5NYXhUaW1lLCBzbG90TWluVGltZSwgc2xvdE1heFRpbWUgfSA9IHRoaXMucHJvcHM7XHJcbiAgICAgICAgICAgIGxldCB7IHN0YXJ0LCBlbmQgfSA9IHJhbmdlO1xyXG4gICAgICAgICAgICBpZiAodXNlc01pbk1heFRpbWUpIHtcclxuICAgICAgICAgICAgICAgIC8vIGV4cGFuZCBhY3RpdmUgcmFuZ2UgaWYgc2xvdE1pblRpbWUgaXMgbmVnYXRpdmUgKHdoeSBub3Qgd2hlbiBwb3NpdGl2ZT8pXHJcbiAgICAgICAgICAgICAgICBpZiAoYXNSb3VnaERheXMoc2xvdE1pblRpbWUpIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gc3RhcnRPZkRheShzdGFydCk7IC8vIG5lY2Vzc2FyeT9cclxuICAgICAgICAgICAgICAgICAgICBzdGFydCA9IGRhdGVFbnYuYWRkKHN0YXJ0LCBzbG90TWluVGltZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBleHBhbmQgYWN0aXZlIHJhbmdlIGlmIHNsb3RNYXhUaW1lIGlzIGJleW9uZCBvbmUgZGF5ICh3aHkgbm90IHdoZW4gbmVnYXRpdmU/KVxyXG4gICAgICAgICAgICAgICAgaWYgKGFzUm91Z2hEYXlzKHNsb3RNYXhUaW1lKSA+IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICBlbmQgPSBzdGFydE9mRGF5KGVuZCk7IC8vIG5lY2Vzc2FyeT9cclxuICAgICAgICAgICAgICAgICAgICBlbmQgPSBhZGREYXlzKGVuZCwgLTEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGVuZCA9IGRhdGVFbnYuYWRkKGVuZCwgc2xvdE1heFRpbWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB7IHN0YXJ0LCBlbmQgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQnVpbGRzIHRoZSBcImN1cnJlbnRcIiByYW5nZSB3aGVuIGl0IGlzIHNwZWNpZmllZCBhcyBhbiBleHBsaWNpdCBkdXJhdGlvbi5cclxuICAgICAgICAvLyBgdW5pdGAgaXMgdGhlIGFscmVhZHktY29tcHV0ZWQgZ3JlYXRlc3REdXJhdGlvbkRlbm9taW5hdG9yIHVuaXQgb2YgZHVyYXRpb24uXHJcbiAgICAgICAgYnVpbGRSYW5nZUZyb21EdXJhdGlvbihkYXRlLCBkaXJlY3Rpb24sIGR1cmF0aW9uLCB1bml0KSB7XHJcbiAgICAgICAgICAgIGxldCB7IGRhdGVFbnYsIGRhdGVBbGlnbm1lbnQgfSA9IHRoaXMucHJvcHM7XHJcbiAgICAgICAgICAgIGxldCBzdGFydDtcclxuICAgICAgICAgICAgbGV0IGVuZDtcclxuICAgICAgICAgICAgbGV0IHJlcztcclxuICAgICAgICAgICAgLy8gY29tcHV0ZSB3aGF0IHRoZSBhbGlnbm1lbnQgc2hvdWxkIGJlXHJcbiAgICAgICAgICAgIGlmICghZGF0ZUFsaWdubWVudCkge1xyXG4gICAgICAgICAgICAgICAgbGV0IHsgZGF0ZUluY3JlbWVudCB9ID0gdGhpcy5wcm9wcztcclxuICAgICAgICAgICAgICAgIGlmIChkYXRlSW5jcmVtZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdXNlIHRoZSBzbWFsbGVyIG9mIHRoZSB0d28gdW5pdHNcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYXNSb3VnaE1zKGRhdGVJbmNyZW1lbnQpIDwgYXNSb3VnaE1zKGR1cmF0aW9uKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRlQWxpZ25tZW50ID0gZ3JlYXRlc3REdXJhdGlvbkRlbm9taW5hdG9yKGRhdGVJbmNyZW1lbnQpLnVuaXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRlQWxpZ25tZW50ID0gdW5pdDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBkYXRlQWxpZ25tZW50ID0gdW5pdDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBpZiB0aGUgdmlldyBkaXNwbGF5cyBhIHNpbmdsZSBkYXkgb3Igc21hbGxlclxyXG4gICAgICAgICAgICBpZiAoYXNSb3VnaERheXMoZHVyYXRpb24pIDw9IDEpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzSGlkZGVuRGF5KHN0YXJ0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gdGhpcy5za2lwSGlkZGVuRGF5cyhzdGFydCwgZGlyZWN0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICBzdGFydCA9IHN0YXJ0T2ZEYXkoc3RhcnQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGNvbXB1dGVSZXMoKSB7XHJcbiAgICAgICAgICAgICAgICBzdGFydCA9IGRhdGVFbnYuc3RhcnRPZihkYXRlLCBkYXRlQWxpZ25tZW50KTtcclxuICAgICAgICAgICAgICAgIGVuZCA9IGRhdGVFbnYuYWRkKHN0YXJ0LCBkdXJhdGlvbik7XHJcbiAgICAgICAgICAgICAgICByZXMgPSB7IHN0YXJ0LCBlbmQgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb21wdXRlUmVzKCk7XHJcbiAgICAgICAgICAgIC8vIGlmIHJhbmdlIGlzIGNvbXBsZXRlbHkgZW52ZWxvcGVkIGJ5IGhpZGRlbiBkYXlzLCBnbyBwYXN0IHRoZSBoaWRkZW4gZGF5c1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMudHJpbUhpZGRlbkRheXMocmVzKSkge1xyXG4gICAgICAgICAgICAgICAgZGF0ZSA9IHRoaXMuc2tpcEhpZGRlbkRheXMoZGF0ZSwgZGlyZWN0aW9uKTtcclxuICAgICAgICAgICAgICAgIGNvbXB1dGVSZXMoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBCdWlsZHMgdGhlIFwiY3VycmVudFwiIHJhbmdlIHdoZW4gYSBkYXlDb3VudCBpcyBzcGVjaWZpZWQuXHJcbiAgICAgICAgYnVpbGRSYW5nZUZyb21EYXlDb3VudChkYXRlLCBkaXJlY3Rpb24sIGRheUNvdW50KSB7XHJcbiAgICAgICAgICAgIGxldCB7IGRhdGVFbnYsIGRhdGVBbGlnbm1lbnQgfSA9IHRoaXMucHJvcHM7XHJcbiAgICAgICAgICAgIGxldCBydW5uaW5nQ291bnQgPSAwO1xyXG4gICAgICAgICAgICBsZXQgc3RhcnQgPSBkYXRlO1xyXG4gICAgICAgICAgICBsZXQgZW5kO1xyXG4gICAgICAgICAgICBpZiAoZGF0ZUFsaWdubWVudCkge1xyXG4gICAgICAgICAgICAgICAgc3RhcnQgPSBkYXRlRW52LnN0YXJ0T2Yoc3RhcnQsIGRhdGVBbGlnbm1lbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHN0YXJ0ID0gc3RhcnRPZkRheShzdGFydCk7XHJcbiAgICAgICAgICAgIHN0YXJ0ID0gdGhpcy5za2lwSGlkZGVuRGF5cyhzdGFydCwgZGlyZWN0aW9uKTtcclxuICAgICAgICAgICAgZW5kID0gc3RhcnQ7XHJcbiAgICAgICAgICAgIGRvIHtcclxuICAgICAgICAgICAgICAgIGVuZCA9IGFkZERheXMoZW5kLCAxKTtcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5pc0hpZGRlbkRheShlbmQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcnVubmluZ0NvdW50ICs9IDE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gd2hpbGUgKHJ1bm5pbmdDb3VudCA8IGRheUNvdW50KTtcclxuICAgICAgICAgICAgcmV0dXJuIHsgc3RhcnQsIGVuZCB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBCdWlsZHMgYSBub3JtYWxpemVkIHJhbmdlIG9iamVjdCBmb3IgdGhlIFwidmlzaWJsZVwiIHJhbmdlLFxyXG4gICAgICAgIC8vIHdoaWNoIGlzIGEgd2F5IHRvIGRlZmluZSB0aGUgY3VycmVudFJhbmdlIGFuZCBhY3RpdmVSYW5nZSBhdCB0aGUgc2FtZSB0aW1lLlxyXG4gICAgICAgIGJ1aWxkQ3VzdG9tVmlzaWJsZVJhbmdlKGRhdGUpIHtcclxuICAgICAgICAgICAgbGV0IHsgcHJvcHMgfSA9IHRoaXM7XHJcbiAgICAgICAgICAgIGxldCBpbnB1dCA9IHByb3BzLnZpc2libGVSYW5nZUlucHV0O1xyXG4gICAgICAgICAgICBsZXQgc2ltcGxlSW5wdXQgPSB0eXBlb2YgaW5wdXQgPT09ICdmdW5jdGlvbidcclxuICAgICAgICAgICAgICAgID8gaW5wdXQuY2FsbChwcm9wcy5jYWxlbmRhckFwaSwgcHJvcHMuZGF0ZUVudi50b0RhdGUoZGF0ZSkpXHJcbiAgICAgICAgICAgICAgICA6IGlucHV0O1xyXG4gICAgICAgICAgICBsZXQgcmFuZ2UgPSB0aGlzLnJlZmluZVJhbmdlKHNpbXBsZUlucHV0KTtcclxuICAgICAgICAgICAgaWYgKHJhbmdlICYmIChyYW5nZS5zdGFydCA9PSBudWxsIHx8IHJhbmdlLmVuZCA9PSBudWxsKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJhbmdlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBDb21wdXRlcyB0aGUgcmFuZ2UgdGhhdCB3aWxsIHJlcHJlc2VudCB0aGUgZWxlbWVudC9jZWxscyBmb3IgKnJlbmRlcmluZyosXHJcbiAgICAgICAgLy8gYnV0IHdoaWNoIG1heSBoYXZlIHZvaWRlZCBkYXlzL3RpbWVzLlxyXG4gICAgICAgIC8vIG5vdCByZXNwb25zaWJsZSBmb3IgdHJpbW1pbmcgaGlkZGVuIGRheXMuXHJcbiAgICAgICAgYnVpbGRSZW5kZXJSYW5nZShjdXJyZW50UmFuZ2UsIGN1cnJlbnRSYW5nZVVuaXQsIGlzUmFuZ2VBbGxEYXkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRSYW5nZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQ29tcHV0ZSB0aGUgZHVyYXRpb24gdmFsdWUgdGhhdCBzaG91bGQgYmUgYWRkZWQvc3Vic3RyYWN0ZWQgdG8gdGhlIGN1cnJlbnQgZGF0ZVxyXG4gICAgICAgIC8vIHdoZW4gYSBwcmV2L25leHQgb3BlcmF0aW9uIGhhcHBlbnMuXHJcbiAgICAgICAgYnVpbGREYXRlSW5jcmVtZW50KGZhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgIGxldCB7IGRhdGVJbmNyZW1lbnQgfSA9IHRoaXMucHJvcHM7XHJcbiAgICAgICAgICAgIGxldCBjdXN0b21BbGlnbm1lbnQ7XHJcbiAgICAgICAgICAgIGlmIChkYXRlSW5jcmVtZW50KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0ZUluY3JlbWVudDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoKGN1c3RvbUFsaWdubWVudCA9IHRoaXMucHJvcHMuZGF0ZUFsaWdubWVudCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVEdXJhdGlvbigxLCBjdXN0b21BbGlnbm1lbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChmYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbGxiYWNrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVEdXJhdGlvbih7IGRheXM6IDEgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlZmluZVJhbmdlKHJhbmdlSW5wdXQpIHtcclxuICAgICAgICAgICAgaWYgKHJhbmdlSW5wdXQpIHtcclxuICAgICAgICAgICAgICAgIGxldCByYW5nZSA9IHBhcnNlUmFuZ2UocmFuZ2VJbnB1dCwgdGhpcy5wcm9wcy5kYXRlRW52KTtcclxuICAgICAgICAgICAgICAgIGlmIChyYW5nZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlID0gY29tcHV0ZVZpc2libGVEYXlSYW5nZShyYW5nZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmFuZ2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qIEhpZGRlbiBEYXlzXHJcbiAgICAgICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgICAgICAvLyBJbml0aWFsaXplcyBpbnRlcm5hbCB2YXJpYWJsZXMgcmVsYXRlZCB0byBjYWxjdWxhdGluZyBoaWRkZW4gZGF5cy1vZi13ZWVrXHJcbiAgICAgICAgaW5pdEhpZGRlbkRheXMoKSB7XHJcbiAgICAgICAgICAgIGxldCBoaWRkZW5EYXlzID0gdGhpcy5wcm9wcy5oaWRkZW5EYXlzIHx8IFtdOyAvLyBhcnJheSBvZiBkYXktb2Ytd2VlayBpbmRpY2VzIHRoYXQgYXJlIGhpZGRlblxyXG4gICAgICAgICAgICBsZXQgaXNIaWRkZW5EYXlIYXNoID0gW107IC8vIGlzIHRoZSBkYXktb2Ytd2VlayBoaWRkZW4/IChoYXNoIHdpdGggZGF5LW9mLXdlZWstaW5kZXggLT4gYm9vbClcclxuICAgICAgICAgICAgbGV0IGRheUNudCA9IDA7XHJcbiAgICAgICAgICAgIGxldCBpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5wcm9wcy53ZWVrZW5kcyA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgIGhpZGRlbkRheXMucHVzaCgwLCA2KTsgLy8gMD1zdW5kYXksIDY9c2F0dXJkYXlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNzsgaSArPSAxKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIShpc0hpZGRlbkRheUhhc2hbaV0gPSBoaWRkZW5EYXlzLmluZGV4T2YoaSkgIT09IC0xKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRheUNudCArPSAxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghZGF5Q250KSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgaGlkZGVuRGF5cycpOyAvLyBhbGwgZGF5cyB3ZXJlIGhpZGRlbj8gYmFkLlxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuaXNIaWRkZW5EYXlIYXNoID0gaXNIaWRkZW5EYXlIYXNoO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBSZW1vdmUgZGF5cyBmcm9tIHRoZSBiZWdpbm5pbmcgYW5kIGVuZCBvZiB0aGUgcmFuZ2UgdGhhdCBhcmUgY29tcHV0ZWQgYXMgaGlkZGVuLlxyXG4gICAgICAgIC8vIElmIHRoZSB3aG9sZSByYW5nZSBpcyB0cmltbWVkIG9mZiwgcmV0dXJucyBudWxsXHJcbiAgICAgICAgdHJpbUhpZGRlbkRheXMocmFuZ2UpIHtcclxuICAgICAgICAgICAgbGV0IHsgc3RhcnQsIGVuZCB9ID0gcmFuZ2U7XHJcbiAgICAgICAgICAgIGlmIChzdGFydCkge1xyXG4gICAgICAgICAgICAgICAgc3RhcnQgPSB0aGlzLnNraXBIaWRkZW5EYXlzKHN0YXJ0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZW5kKSB7XHJcbiAgICAgICAgICAgICAgICBlbmQgPSB0aGlzLnNraXBIaWRkZW5EYXlzKGVuZCwgLTEsIHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChzdGFydCA9PSBudWxsIHx8IGVuZCA9PSBudWxsIHx8IHN0YXJ0IDwgZW5kKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4geyBzdGFydCwgZW5kIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIElzIHRoZSBjdXJyZW50IGRheSBoaWRkZW4/XHJcbiAgICAgICAgLy8gYGRheWAgaXMgYSBkYXktb2Ytd2VlayBpbmRleCAoMC02KSwgb3IgYSBEYXRlICh1c2VkIGZvciBVVEMpXHJcbiAgICAgICAgaXNIaWRkZW5EYXkoZGF5KSB7XHJcbiAgICAgICAgICAgIGlmIChkYXkgaW5zdGFuY2VvZiBEYXRlKSB7XHJcbiAgICAgICAgICAgICAgICBkYXkgPSBkYXkuZ2V0VVRDRGF5KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXNIaWRkZW5EYXlIYXNoW2RheV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEluY3JlbWVudGluZyB0aGUgY3VycmVudCBkYXkgdW50aWwgaXQgaXMgbm8gbG9uZ2VyIGEgaGlkZGVuIGRheSwgcmV0dXJuaW5nIGEgY29weS5cclxuICAgICAgICAvLyBET0VTIE5PVCBDT05TSURFUiB2YWxpZFJhbmdlIVxyXG4gICAgICAgIC8vIElmIHRoZSBpbml0aWFsIHZhbHVlIG9mIGBkYXRlYCBpcyBub3QgYSBoaWRkZW4gZGF5LCBkb24ndCBkbyBhbnl0aGluZy5cclxuICAgICAgICAvLyBQYXNzIGBpc0V4Y2x1c2l2ZWAgYXMgYHRydWVgIGlmIHlvdSBhcmUgZGVhbGluZyB3aXRoIGFuIGVuZCBkYXRlLlxyXG4gICAgICAgIC8vIGBpbmNgIGRlZmF1bHRzIHRvIGAxYCAoaW5jcmVtZW50IG9uZSBkYXkgZm9yd2FyZCBlYWNoIHRpbWUpXHJcbiAgICAgICAgc2tpcEhpZGRlbkRheXMoZGF0ZSwgaW5jID0gMSwgaXNFeGNsdXNpdmUgPSBmYWxzZSkge1xyXG4gICAgICAgICAgICB3aGlsZSAodGhpcy5pc0hpZGRlbkRheUhhc2hbKGRhdGUuZ2V0VVRDRGF5KCkgKyAoaXNFeGNsdXNpdmUgPyBpbmMgOiAwKSArIDcpICUgN10pIHtcclxuICAgICAgICAgICAgICAgIGRhdGUgPSBhZGREYXlzKGRhdGUsIGluYyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGRhdGU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHRyaWdnZXJEYXRlU2VsZWN0KHNlbGVjdGlvbiwgcGV2LCBjb250ZXh0KSB7XHJcbiAgICAgICAgY29udGV4dC5lbWl0dGVyLnRyaWdnZXIoJ3NlbGVjdCcsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgYnVpbGREYXRlU3BhbkFwaVdpdGhDb250ZXh0KHNlbGVjdGlvbiwgY29udGV4dCkpLCB7IGpzRXZlbnQ6IHBldiA/IHBldi5vcmlnRXZlbnQgOiBudWxsLCB2aWV3OiBjb250ZXh0LnZpZXdBcGkgfHwgY29udGV4dC5jYWxlbmRhckFwaS52aWV3IH0pKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHRyaWdnZXJEYXRlVW5zZWxlY3QocGV2LCBjb250ZXh0KSB7XHJcbiAgICAgICAgY29udGV4dC5lbWl0dGVyLnRyaWdnZXIoJ3Vuc2VsZWN0Jywge1xyXG4gICAgICAgICAgICBqc0V2ZW50OiBwZXYgPyBwZXYub3JpZ0V2ZW50IDogbnVsbCxcclxuICAgICAgICAgICAgdmlldzogY29udGV4dC52aWV3QXBpIHx8IGNvbnRleHQuY2FsZW5kYXJBcGkudmlldyxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGJ1aWxkRGF0ZVNwYW5BcGlXaXRoQ29udGV4dChkYXRlU3BhbiwgY29udGV4dCkge1xyXG4gICAgICAgIGxldCBwcm9wcyA9IHt9O1xyXG4gICAgICAgIGZvciAobGV0IHRyYW5zZm9ybSBvZiBjb250ZXh0LnBsdWdpbkhvb2tzLmRhdGVTcGFuVHJhbnNmb3Jtcykge1xyXG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHByb3BzLCB0cmFuc2Zvcm0oZGF0ZVNwYW4sIGNvbnRleHQpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgT2JqZWN0LmFzc2lnbihwcm9wcywgYnVpbGREYXRlU3BhbkFwaShkYXRlU3BhbiwgY29udGV4dC5kYXRlRW52KSk7XHJcbiAgICAgICAgcmV0dXJuIHByb3BzO1xyXG4gICAgfVxyXG4gICAgLy8gR2l2ZW4gYW4gZXZlbnQncyBhbGxEYXkgc3RhdHVzIGFuZCBzdGFydCBkYXRlLCByZXR1cm4gd2hhdCBpdHMgZmFsbGJhY2sgZW5kIGRhdGUgc2hvdWxkIGJlLlxyXG4gICAgLy8gVE9ETzogcmVuYW1lIHRvIGNvbXB1dGVEZWZhdWx0RXZlbnRFbmRcclxuICAgIGZ1bmN0aW9uIGdldERlZmF1bHRFdmVudEVuZChhbGxEYXksIG1hcmtlciwgY29udGV4dCkge1xyXG4gICAgICAgIGxldCB7IGRhdGVFbnYsIG9wdGlvbnMgfSA9IGNvbnRleHQ7XHJcbiAgICAgICAgbGV0IGVuZCA9IG1hcmtlcjtcclxuICAgICAgICBpZiAoYWxsRGF5KSB7XHJcbiAgICAgICAgICAgIGVuZCA9IHN0YXJ0T2ZEYXkoZW5kKTtcclxuICAgICAgICAgICAgZW5kID0gZGF0ZUVudi5hZGQoZW5kLCBvcHRpb25zLmRlZmF1bHRBbGxEYXlFdmVudER1cmF0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGVuZCA9IGRhdGVFbnYuYWRkKGVuZCwgb3B0aW9ucy5kZWZhdWx0VGltZWRFdmVudER1cmF0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGVuZDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBhcHBsaWVzIHRoZSBtdXRhdGlvbiB0byBBTEwgZGVmcy9pbnN0YW5jZXMgd2l0aGluIHRoZSBldmVudCBzdG9yZVxyXG4gICAgZnVuY3Rpb24gYXBwbHlNdXRhdGlvblRvRXZlbnRTdG9yZShldmVudFN0b3JlLCBldmVudENvbmZpZ0Jhc2UsIG11dGF0aW9uLCBjb250ZXh0KSB7XHJcbiAgICAgICAgbGV0IGV2ZW50Q29uZmlncyA9IGNvbXBpbGVFdmVudFVpcyhldmVudFN0b3JlLmRlZnMsIGV2ZW50Q29uZmlnQmFzZSk7XHJcbiAgICAgICAgbGV0IGRlc3QgPSBjcmVhdGVFbXB0eUV2ZW50U3RvcmUoKTtcclxuICAgICAgICBmb3IgKGxldCBkZWZJZCBpbiBldmVudFN0b3JlLmRlZnMpIHtcclxuICAgICAgICAgICAgbGV0IGRlZiA9IGV2ZW50U3RvcmUuZGVmc1tkZWZJZF07XHJcbiAgICAgICAgICAgIGRlc3QuZGVmc1tkZWZJZF0gPSBhcHBseU11dGF0aW9uVG9FdmVudERlZihkZWYsIGV2ZW50Q29uZmlnc1tkZWZJZF0sIG11dGF0aW9uLCBjb250ZXh0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChsZXQgaW5zdGFuY2VJZCBpbiBldmVudFN0b3JlLmluc3RhbmNlcykge1xyXG4gICAgICAgICAgICBsZXQgaW5zdGFuY2UgPSBldmVudFN0b3JlLmluc3RhbmNlc1tpbnN0YW5jZUlkXTtcclxuICAgICAgICAgICAgbGV0IGRlZiA9IGRlc3QuZGVmc1tpbnN0YW5jZS5kZWZJZF07IC8vIGltcG9ydGFudCB0byBncmFiIHRoZSBuZXdseSBtb2RpZmllZCBkZWZcclxuICAgICAgICAgICAgZGVzdC5pbnN0YW5jZXNbaW5zdGFuY2VJZF0gPSBhcHBseU11dGF0aW9uVG9FdmVudEluc3RhbmNlKGluc3RhbmNlLCBkZWYsIGV2ZW50Q29uZmlnc1tpbnN0YW5jZS5kZWZJZF0sIG11dGF0aW9uLCBjb250ZXh0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGRlc3Q7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBhcHBseU11dGF0aW9uVG9FdmVudERlZihldmVudERlZiwgZXZlbnRDb25maWcsIG11dGF0aW9uLCBjb250ZXh0KSB7XHJcbiAgICAgICAgbGV0IHN0YW5kYXJkUHJvcHMgPSBtdXRhdGlvbi5zdGFuZGFyZFByb3BzIHx8IHt9O1xyXG4gICAgICAgIC8vIGlmIGhhc0VuZCBoYXMgbm90IGJlZW4gc3BlY2lmaWVkLCBndWVzcyBhIGdvb2QgdmFsdWUgYmFzZWQgb24gZGVsdGFzLlxyXG4gICAgICAgIC8vIGlmIGR1cmF0aW9uIHdpbGwgY2hhbmdlLCB0aGVyZSdzIG5vIHdheSB0aGUgZGVmYXVsdCBkdXJhdGlvbiB3aWxsIHBlcnNpc3QsXHJcbiAgICAgICAgLy8gYW5kIHRodXMsIHdlIG5lZWQgdG8gbWFyayB0aGUgZXZlbnQgYXMgaGF2aW5nIGEgcmVhbCBlbmRcclxuICAgICAgICBpZiAoc3RhbmRhcmRQcm9wcy5oYXNFbmQgPT0gbnVsbCAmJlxyXG4gICAgICAgICAgICBldmVudENvbmZpZy5kdXJhdGlvbkVkaXRhYmxlICYmXHJcbiAgICAgICAgICAgIChtdXRhdGlvbi5zdGFydERlbHRhIHx8IG11dGF0aW9uLmVuZERlbHRhKSkge1xyXG4gICAgICAgICAgICBzdGFuZGFyZFByb3BzLmhhc0VuZCA9IHRydWU7IC8vIFRPRE86IGlzIHRoaXMgbXV0YXRpb24gb2theT9cclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGNvcHkgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZXZlbnREZWYpLCBzdGFuZGFyZFByb3BzKSwgeyB1aTogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBldmVudERlZi51aSksIHN0YW5kYXJkUHJvcHMudWkpIH0pO1xyXG4gICAgICAgIGlmIChtdXRhdGlvbi5leHRlbmRlZFByb3BzKSB7XHJcbiAgICAgICAgICAgIGNvcHkuZXh0ZW5kZWRQcm9wcyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY29weS5leHRlbmRlZFByb3BzKSwgbXV0YXRpb24uZXh0ZW5kZWRQcm9wcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAobGV0IGFwcGxpZXIgb2YgY29udGV4dC5wbHVnaW5Ib29rcy5ldmVudERlZk11dGF0aW9uQXBwbGllcnMpIHtcclxuICAgICAgICAgICAgYXBwbGllcihjb3B5LCBtdXRhdGlvbiwgY29udGV4dCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghY29weS5oYXNFbmQgJiYgY29udGV4dC5vcHRpb25zLmZvcmNlRXZlbnREdXJhdGlvbikge1xyXG4gICAgICAgICAgICBjb3B5Lmhhc0VuZCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjb3B5O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYXBwbHlNdXRhdGlvblRvRXZlbnRJbnN0YW5jZShldmVudEluc3RhbmNlLCBldmVudERlZiwgLy8gbXVzdCBmaXJzdCBiZSBtb2RpZmllZCBieSBhcHBseU11dGF0aW9uVG9FdmVudERlZlxyXG4gICAgZXZlbnRDb25maWcsIG11dGF0aW9uLCBjb250ZXh0KSB7XHJcbiAgICAgICAgbGV0IHsgZGF0ZUVudiB9ID0gY29udGV4dDtcclxuICAgICAgICBsZXQgZm9yY2VBbGxEYXkgPSBtdXRhdGlvbi5zdGFuZGFyZFByb3BzICYmIG11dGF0aW9uLnN0YW5kYXJkUHJvcHMuYWxsRGF5ID09PSB0cnVlO1xyXG4gICAgICAgIGxldCBjbGVhckVuZCA9IG11dGF0aW9uLnN0YW5kYXJkUHJvcHMgJiYgbXV0YXRpb24uc3RhbmRhcmRQcm9wcy5oYXNFbmQgPT09IGZhbHNlO1xyXG4gICAgICAgIGxldCBjb3B5ID0gT2JqZWN0LmFzc2lnbih7fSwgZXZlbnRJbnN0YW5jZSk7XHJcbiAgICAgICAgaWYgKGZvcmNlQWxsRGF5KSB7XHJcbiAgICAgICAgICAgIGNvcHkucmFuZ2UgPSBjb21wdXRlQWxpZ25lZERheVJhbmdlKGNvcHkucmFuZ2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobXV0YXRpb24uZGF0ZXNEZWx0YSAmJiBldmVudENvbmZpZy5zdGFydEVkaXRhYmxlKSB7XHJcbiAgICAgICAgICAgIGNvcHkucmFuZ2UgPSB7XHJcbiAgICAgICAgICAgICAgICBzdGFydDogZGF0ZUVudi5hZGQoY29weS5yYW5nZS5zdGFydCwgbXV0YXRpb24uZGF0ZXNEZWx0YSksXHJcbiAgICAgICAgICAgICAgICBlbmQ6IGRhdGVFbnYuYWRkKGNvcHkucmFuZ2UuZW5kLCBtdXRhdGlvbi5kYXRlc0RlbHRhKSxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG11dGF0aW9uLnN0YXJ0RGVsdGEgJiYgZXZlbnRDb25maWcuZHVyYXRpb25FZGl0YWJsZSkge1xyXG4gICAgICAgICAgICBjb3B5LnJhbmdlID0ge1xyXG4gICAgICAgICAgICAgICAgc3RhcnQ6IGRhdGVFbnYuYWRkKGNvcHkucmFuZ2Uuc3RhcnQsIG11dGF0aW9uLnN0YXJ0RGVsdGEpLFxyXG4gICAgICAgICAgICAgICAgZW5kOiBjb3B5LnJhbmdlLmVuZCxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG11dGF0aW9uLmVuZERlbHRhICYmIGV2ZW50Q29uZmlnLmR1cmF0aW9uRWRpdGFibGUpIHtcclxuICAgICAgICAgICAgY29weS5yYW5nZSA9IHtcclxuICAgICAgICAgICAgICAgIHN0YXJ0OiBjb3B5LnJhbmdlLnN0YXJ0LFxyXG4gICAgICAgICAgICAgICAgZW5kOiBkYXRlRW52LmFkZChjb3B5LnJhbmdlLmVuZCwgbXV0YXRpb24uZW5kRGVsdGEpLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY2xlYXJFbmQpIHtcclxuICAgICAgICAgICAgY29weS5yYW5nZSA9IHtcclxuICAgICAgICAgICAgICAgIHN0YXJ0OiBjb3B5LnJhbmdlLnN0YXJ0LFxyXG4gICAgICAgICAgICAgICAgZW5kOiBnZXREZWZhdWx0RXZlbnRFbmQoZXZlbnREZWYuYWxsRGF5LCBjb3B5LnJhbmdlLnN0YXJ0LCBjb250ZXh0KSxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gaW4gY2FzZSBldmVudCB3YXMgYWxsLWRheSBidXQgdGhlIHN1cHBsaWVkIGRlbHRhcyB3ZXJlIG5vdFxyXG4gICAgICAgIC8vIGJldHRlciB1dGlsIGZvciB0aGlzP1xyXG4gICAgICAgIGlmIChldmVudERlZi5hbGxEYXkpIHtcclxuICAgICAgICAgICAgY29weS5yYW5nZSA9IHtcclxuICAgICAgICAgICAgICAgIHN0YXJ0OiBzdGFydE9mRGF5KGNvcHkucmFuZ2Uuc3RhcnQpLFxyXG4gICAgICAgICAgICAgICAgZW5kOiBzdGFydE9mRGF5KGNvcHkucmFuZ2UuZW5kKSxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gaGFuZGxlIGludmFsaWQgZHVyYXRpb25zXHJcbiAgICAgICAgaWYgKGNvcHkucmFuZ2UuZW5kIDwgY29weS5yYW5nZS5zdGFydCkge1xyXG4gICAgICAgICAgICBjb3B5LnJhbmdlLmVuZCA9IGdldERlZmF1bHRFdmVudEVuZChldmVudERlZi5hbGxEYXksIGNvcHkucmFuZ2Uuc3RhcnQsIGNvbnRleHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY29weTtcclxuICAgIH1cclxuXHJcbiAgICBjbGFzcyBFdmVudFNvdXJjZUltcGwge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yKGNvbnRleHQsIGludGVybmFsRXZlbnRTb3VyY2UpIHtcclxuICAgICAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcclxuICAgICAgICAgICAgdGhpcy5pbnRlcm5hbEV2ZW50U291cmNlID0gaW50ZXJuYWxFdmVudFNvdXJjZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVtb3ZlKCkge1xyXG4gICAgICAgICAgICB0aGlzLmNvbnRleHQuZGlzcGF0Y2goe1xyXG4gICAgICAgICAgICAgICAgdHlwZTogJ1JFTU9WRV9FVkVOVF9TT1VSQ0UnLFxyXG4gICAgICAgICAgICAgICAgc291cmNlSWQ6IHRoaXMuaW50ZXJuYWxFdmVudFNvdXJjZS5zb3VyY2VJZCxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlZmV0Y2goKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5kaXNwYXRjaCh7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiAnRkVUQ0hfRVZFTlRfU09VUkNFUycsXHJcbiAgICAgICAgICAgICAgICBzb3VyY2VJZHM6IFt0aGlzLmludGVybmFsRXZlbnRTb3VyY2Uuc291cmNlSWRdLFxyXG4gICAgICAgICAgICAgICAgaXNSZWZldGNoOiB0cnVlLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZ2V0IGlkKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbEV2ZW50U291cmNlLnB1YmxpY0lkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBnZXQgdXJsKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbEV2ZW50U291cmNlLm1ldGEudXJsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBnZXQgZm9ybWF0KCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbEV2ZW50U291cmNlLm1ldGEuZm9ybWF0OyAvLyBUT0RPOiBiYWQuIG5vdCBndWFyYW50ZWVkXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNsYXNzIEV2ZW50SW1wbCB7XHJcbiAgICAgICAgLy8gaW5zdGFuY2Ugd2lsbCBiZSBudWxsIGlmIGV4cHJlc3NpbmcgYSByZWN1cnJpbmcgZXZlbnQgdGhhdCBoYXMgbm8gY3VycmVudCBpbnN0YW5jZXMsXHJcbiAgICAgICAgLy8gT1IgaWYgdHJ5aW5nIHRvIHZhbGlkYXRlIGFuIGluY29taW5nIGV4dGVybmFsIGV2ZW50IHRoYXQgaGFzIG5vIGRhdGVzIGFzc2lnbmVkXHJcbiAgICAgICAgY29uc3RydWN0b3IoY29udGV4dCwgZGVmLCBpbnN0YW5jZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcclxuICAgICAgICAgICAgdGhpcy5fZGVmID0gZGVmO1xyXG4gICAgICAgICAgICB0aGlzLl9pbnN0YW5jZSA9IGluc3RhbmNlIHx8IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgVE9ETzogbWFrZSBldmVudCBzdHJ1Y3QgbW9yZSByZXNwb25zaWJsZSBmb3IgdGhpc1xyXG4gICAgICAgICovXHJcbiAgICAgICAgc2V0UHJvcChuYW1lLCB2YWwpIHtcclxuICAgICAgICAgICAgaWYgKG5hbWUgaW4gRVZFTlRfREFURV9SRUZJTkVSUykge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdDb3VsZCBub3Qgc2V0IGRhdGUtcmVsYXRlZCBwcm9wIFxcJ25hbWVcXCcuIFVzZSBvbmUgb2YgdGhlIGRhdGUtcmVsYXRlZCBtZXRob2RzIGluc3RlYWQuJyk7XHJcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBtYWtlIHByb3BlciBhbGlhc2luZyBzeXN0ZW0/XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAobmFtZSA9PT0gJ2lkJykge1xyXG4gICAgICAgICAgICAgICAgdmFsID0gRVZFTlRfTk9OX0RBVEVfUkVGSU5FUlNbbmFtZV0odmFsKTtcclxuICAgICAgICAgICAgICAgIHRoaXMubXV0YXRlKHtcclxuICAgICAgICAgICAgICAgICAgICBzdGFuZGFyZFByb3BzOiB7IHB1YmxpY0lkOiB2YWwgfSwgLy8gaGFyZGNvZGVkIGludGVybmFsIG5hbWVcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKG5hbWUgaW4gRVZFTlRfTk9OX0RBVEVfUkVGSU5FUlMpIHtcclxuICAgICAgICAgICAgICAgIHZhbCA9IEVWRU5UX05PTl9EQVRFX1JFRklORVJTW25hbWVdKHZhbCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm11dGF0ZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhbmRhcmRQcm9wczogeyBbbmFtZV06IHZhbCB9LFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAobmFtZSBpbiBFVkVOVF9VSV9SRUZJTkVSUykge1xyXG4gICAgICAgICAgICAgICAgbGV0IHVpID0gRVZFTlRfVUlfUkVGSU5FUlNbbmFtZV0odmFsKTtcclxuICAgICAgICAgICAgICAgIGlmIChuYW1lID09PSAnY29sb3InKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdWkgPSB7IGJhY2tncm91bmRDb2xvcjogdmFsLCBib3JkZXJDb2xvcjogdmFsIH07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChuYW1lID09PSAnZWRpdGFibGUnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdWkgPSB7IHN0YXJ0RWRpdGFibGU6IHZhbCwgZHVyYXRpb25FZGl0YWJsZTogdmFsIH07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB1aSA9IHsgW25hbWVdOiB2YWwgfTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMubXV0YXRlKHtcclxuICAgICAgICAgICAgICAgICAgICBzdGFuZGFyZFByb3BzOiB7IHVpIH0sXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgQ291bGQgbm90IHNldCBwcm9wICcke25hbWV9Jy4gVXNlIHNldEV4dGVuZGVkUHJvcCBpbnN0ZWFkLmApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNldEV4dGVuZGVkUHJvcChuYW1lLCB2YWwpIHtcclxuICAgICAgICAgICAgdGhpcy5tdXRhdGUoe1xyXG4gICAgICAgICAgICAgICAgZXh0ZW5kZWRQcm9wczogeyBbbmFtZV06IHZhbCB9LFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc2V0U3RhcnQoc3RhcnRJbnB1dCwgb3B0aW9ucyA9IHt9KSB7XHJcbiAgICAgICAgICAgIGxldCB7IGRhdGVFbnYgfSA9IHRoaXMuX2NvbnRleHQ7XHJcbiAgICAgICAgICAgIGxldCBzdGFydCA9IGRhdGVFbnYuY3JlYXRlTWFya2VyKHN0YXJ0SW5wdXQpO1xyXG4gICAgICAgICAgICBpZiAoc3RhcnQgJiYgdGhpcy5faW5zdGFuY2UpIHsgLy8gVE9ETzogd2FybmluZyBpZiBwYXJzZWQgYmFkXHJcbiAgICAgICAgICAgICAgICBsZXQgaW5zdGFuY2VSYW5nZSA9IHRoaXMuX2luc3RhbmNlLnJhbmdlO1xyXG4gICAgICAgICAgICAgICAgbGV0IHN0YXJ0RGVsdGEgPSBkaWZmRGF0ZXMoaW5zdGFuY2VSYW5nZS5zdGFydCwgc3RhcnQsIGRhdGVFbnYsIG9wdGlvbnMuZ3JhbnVsYXJpdHkpOyAvLyB3aGF0IGlmIHBhcnNlZCBiYWQhP1xyXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMubWFpbnRhaW5EdXJhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubXV0YXRlKHsgZGF0ZXNEZWx0YTogc3RhcnREZWx0YSB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubXV0YXRlKHsgc3RhcnREZWx0YSB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBzZXRFbmQoZW5kSW5wdXQsIG9wdGlvbnMgPSB7fSkge1xyXG4gICAgICAgICAgICBsZXQgeyBkYXRlRW52IH0gPSB0aGlzLl9jb250ZXh0O1xyXG4gICAgICAgICAgICBsZXQgZW5kO1xyXG4gICAgICAgICAgICBpZiAoZW5kSW5wdXQgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgZW5kID0gZGF0ZUVudi5jcmVhdGVNYXJrZXIoZW5kSW5wdXQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFlbmQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47IC8vIFRPRE86IHdhcm5pbmcgaWYgcGFyc2VkIGJhZFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9pbnN0YW5jZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVuZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBlbmREZWx0YSA9IGRpZmZEYXRlcyh0aGlzLl9pbnN0YW5jZS5yYW5nZS5lbmQsIGVuZCwgZGF0ZUVudiwgb3B0aW9ucy5ncmFudWxhcml0eSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tdXRhdGUoeyBlbmREZWx0YSB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubXV0YXRlKHsgc3RhbmRhcmRQcm9wczogeyBoYXNFbmQ6IGZhbHNlIH0gfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgc2V0RGF0ZXMoc3RhcnRJbnB1dCwgZW5kSW5wdXQsIG9wdGlvbnMgPSB7fSkge1xyXG4gICAgICAgICAgICBsZXQgeyBkYXRlRW52IH0gPSB0aGlzLl9jb250ZXh0O1xyXG4gICAgICAgICAgICBsZXQgc3RhbmRhcmRQcm9wcyA9IHsgYWxsRGF5OiBvcHRpb25zLmFsbERheSB9O1xyXG4gICAgICAgICAgICBsZXQgc3RhcnQgPSBkYXRlRW52LmNyZWF0ZU1hcmtlcihzdGFydElucHV0KTtcclxuICAgICAgICAgICAgbGV0IGVuZDtcclxuICAgICAgICAgICAgaWYgKCFzdGFydCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBUT0RPOiB3YXJuaW5nIGlmIHBhcnNlZCBiYWRcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZW5kSW5wdXQgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgZW5kID0gZGF0ZUVudi5jcmVhdGVNYXJrZXIoZW5kSW5wdXQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFlbmQpIHsgLy8gVE9ETzogd2FybmluZyBpZiBwYXJzZWQgYmFkXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9pbnN0YW5jZSkge1xyXG4gICAgICAgICAgICAgICAgbGV0IGluc3RhbmNlUmFuZ2UgPSB0aGlzLl9pbnN0YW5jZS5yYW5nZTtcclxuICAgICAgICAgICAgICAgIC8vIHdoZW4gY29tcHV0aW5nIHRoZSBkaWZmIGZvciBhbiBldmVudCBiZWluZyBjb252ZXJ0ZWQgdG8gYWxsLWRheSxcclxuICAgICAgICAgICAgICAgIC8vIGNvbXB1dGUgZGlmZiBvZmYgb2YgdGhlIGFsbC1kYXkgdmFsdWVzIHRoZSB3YXkgZXZlbnQtbXV0YXRpb24gZG9lcy5cclxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmFsbERheSA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlUmFuZ2UgPSBjb21wdXRlQWxpZ25lZERheVJhbmdlKGluc3RhbmNlUmFuZ2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbGV0IHN0YXJ0RGVsdGEgPSBkaWZmRGF0ZXMoaW5zdGFuY2VSYW5nZS5zdGFydCwgc3RhcnQsIGRhdGVFbnYsIG9wdGlvbnMuZ3JhbnVsYXJpdHkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGVuZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBlbmREZWx0YSA9IGRpZmZEYXRlcyhpbnN0YW5jZVJhbmdlLmVuZCwgZW5kLCBkYXRlRW52LCBvcHRpb25zLmdyYW51bGFyaXR5KTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZHVyYXRpb25zRXF1YWwoc3RhcnREZWx0YSwgZW5kRGVsdGEpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubXV0YXRlKHsgZGF0ZXNEZWx0YTogc3RhcnREZWx0YSwgc3RhbmRhcmRQcm9wcyB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubXV0YXRlKHsgc3RhcnREZWx0YSwgZW5kRGVsdGEsIHN0YW5kYXJkUHJvcHMgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7IC8vIG1lYW5zIFwiY2xlYXIgdGhlIGVuZFwiXHJcbiAgICAgICAgICAgICAgICAgICAgc3RhbmRhcmRQcm9wcy5oYXNFbmQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm11dGF0ZSh7IGRhdGVzRGVsdGE6IHN0YXJ0RGVsdGEsIHN0YW5kYXJkUHJvcHMgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgbW92ZVN0YXJ0KGRlbHRhSW5wdXQpIHtcclxuICAgICAgICAgICAgbGV0IGRlbHRhID0gY3JlYXRlRHVyYXRpb24oZGVsdGFJbnB1dCk7XHJcbiAgICAgICAgICAgIGlmIChkZWx0YSkgeyAvLyBUT0RPOiB3YXJuaW5nIGlmIHBhcnNlZCBiYWRcclxuICAgICAgICAgICAgICAgIHRoaXMubXV0YXRlKHsgc3RhcnREZWx0YTogZGVsdGEgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgbW92ZUVuZChkZWx0YUlucHV0KSB7XHJcbiAgICAgICAgICAgIGxldCBkZWx0YSA9IGNyZWF0ZUR1cmF0aW9uKGRlbHRhSW5wdXQpO1xyXG4gICAgICAgICAgICBpZiAoZGVsdGEpIHsgLy8gVE9ETzogd2FybmluZyBpZiBwYXJzZWQgYmFkXHJcbiAgICAgICAgICAgICAgICB0aGlzLm11dGF0ZSh7IGVuZERlbHRhOiBkZWx0YSB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBtb3ZlRGF0ZXMoZGVsdGFJbnB1dCkge1xyXG4gICAgICAgICAgICBsZXQgZGVsdGEgPSBjcmVhdGVEdXJhdGlvbihkZWx0YUlucHV0KTtcclxuICAgICAgICAgICAgaWYgKGRlbHRhKSB7IC8vIFRPRE86IHdhcm5pbmcgaWYgcGFyc2VkIGJhZFxyXG4gICAgICAgICAgICAgICAgdGhpcy5tdXRhdGUoeyBkYXRlc0RlbHRhOiBkZWx0YSB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBzZXRBbGxEYXkoYWxsRGF5LCBvcHRpb25zID0ge30pIHtcclxuICAgICAgICAgICAgbGV0IHN0YW5kYXJkUHJvcHMgPSB7IGFsbERheSB9O1xyXG4gICAgICAgICAgICBsZXQgeyBtYWludGFpbkR1cmF0aW9uIH0gPSBvcHRpb25zO1xyXG4gICAgICAgICAgICBpZiAobWFpbnRhaW5EdXJhdGlvbiA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBtYWludGFpbkR1cmF0aW9uID0gdGhpcy5fY29udGV4dC5vcHRpb25zLmFsbERheU1haW50YWluRHVyYXRpb247XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuX2RlZi5hbGxEYXkgIT09IGFsbERheSkge1xyXG4gICAgICAgICAgICAgICAgc3RhbmRhcmRQcm9wcy5oYXNFbmQgPSBtYWludGFpbkR1cmF0aW9uO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMubXV0YXRlKHsgc3RhbmRhcmRQcm9wcyB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9ybWF0UmFuZ2UoZm9ybWF0SW5wdXQpIHtcclxuICAgICAgICAgICAgbGV0IHsgZGF0ZUVudiB9ID0gdGhpcy5fY29udGV4dDtcclxuICAgICAgICAgICAgbGV0IGluc3RhbmNlID0gdGhpcy5faW5zdGFuY2U7XHJcbiAgICAgICAgICAgIGxldCBmb3JtYXR0ZXIgPSBjcmVhdGVGb3JtYXR0ZXIoZm9ybWF0SW5wdXQpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fZGVmLmhhc0VuZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGVFbnYuZm9ybWF0UmFuZ2UoaW5zdGFuY2UucmFuZ2Uuc3RhcnQsIGluc3RhbmNlLnJhbmdlLmVuZCwgZm9ybWF0dGVyLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yY2VkU3RhcnRUem86IGluc3RhbmNlLmZvcmNlZFN0YXJ0VHpvLFxyXG4gICAgICAgICAgICAgICAgICAgIGZvcmNlZEVuZFR6bzogaW5zdGFuY2UuZm9yY2VkRW5kVHpvLFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGRhdGVFbnYuZm9ybWF0KGluc3RhbmNlLnJhbmdlLnN0YXJ0LCBmb3JtYXR0ZXIsIHtcclxuICAgICAgICAgICAgICAgIGZvcmNlZFR6bzogaW5zdGFuY2UuZm9yY2VkU3RhcnRUem8sXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBtdXRhdGUobXV0YXRpb24pIHtcclxuICAgICAgICAgICAgbGV0IGluc3RhbmNlID0gdGhpcy5faW5zdGFuY2U7XHJcbiAgICAgICAgICAgIGlmIChpbnN0YW5jZSkge1xyXG4gICAgICAgICAgICAgICAgbGV0IGRlZiA9IHRoaXMuX2RlZjtcclxuICAgICAgICAgICAgICAgIGxldCBjb250ZXh0ID0gdGhpcy5fY29udGV4dDtcclxuICAgICAgICAgICAgICAgIGxldCB7IGV2ZW50U3RvcmUgfSA9IGNvbnRleHQuZ2V0Q3VycmVudERhdGEoKTtcclxuICAgICAgICAgICAgICAgIGxldCByZWxldmFudEV2ZW50cyA9IGdldFJlbGV2YW50RXZlbnRzKGV2ZW50U3RvcmUsIGluc3RhbmNlLmluc3RhbmNlSWQpO1xyXG4gICAgICAgICAgICAgICAgbGV0IGV2ZW50Q29uZmlnQmFzZSA9IHtcclxuICAgICAgICAgICAgICAgICAgICAnJzoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5OiAnJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRFZGl0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZHVyYXRpb25FZGl0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3RyYWludHM6IFtdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvdmVybGFwOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxvd3M6IFtdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICcnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBib3JkZXJDb2xvcjogJycsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHRDb2xvcjogJycsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZXM6IFtdLFxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgcmVsZXZhbnRFdmVudHMgPSBhcHBseU11dGF0aW9uVG9FdmVudFN0b3JlKHJlbGV2YW50RXZlbnRzLCBldmVudENvbmZpZ0Jhc2UsIG11dGF0aW9uLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgICAgIGxldCBvbGRFdmVudCA9IG5ldyBFdmVudEltcGwoY29udGV4dCwgZGVmLCBpbnN0YW5jZSk7IC8vIHNuYXBzaG90XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9kZWYgPSByZWxldmFudEV2ZW50cy5kZWZzW2RlZi5kZWZJZF07XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9pbnN0YW5jZSA9IHJlbGV2YW50RXZlbnRzLmluc3RhbmNlc1tpbnN0YW5jZS5pbnN0YW5jZUlkXTtcclxuICAgICAgICAgICAgICAgIGNvbnRleHQuZGlzcGF0Y2goe1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdNRVJHRV9FVkVOVFMnLFxyXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50U3RvcmU6IHJlbGV2YW50RXZlbnRzLFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LmVtaXR0ZXIudHJpZ2dlcignZXZlbnRDaGFuZ2UnLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgb2xkRXZlbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IHRoaXMsXHJcbiAgICAgICAgICAgICAgICAgICAgcmVsYXRlZEV2ZW50czogYnVpbGRFdmVudEFwaXMocmVsZXZhbnRFdmVudHMsIGNvbnRleHQsIGluc3RhbmNlKSxcclxuICAgICAgICAgICAgICAgICAgICByZXZlcnQoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQuZGlzcGF0Y2goe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ1JFU0VUX0VWRU5UUycsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudFN0b3JlLCAvLyB0aGUgT1JJR0lOQUwgc3RvcmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlbW92ZSgpIHtcclxuICAgICAgICAgICAgbGV0IGNvbnRleHQgPSB0aGlzLl9jb250ZXh0O1xyXG4gICAgICAgICAgICBsZXQgYXNTdG9yZSA9IGV2ZW50QXBpVG9TdG9yZSh0aGlzKTtcclxuICAgICAgICAgICAgY29udGV4dC5kaXNwYXRjaCh7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiAnUkVNT1ZFX0VWRU5UUycsXHJcbiAgICAgICAgICAgICAgICBldmVudFN0b3JlOiBhc1N0b3JlLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgY29udGV4dC5lbWl0dGVyLnRyaWdnZXIoJ2V2ZW50UmVtb3ZlJywge1xyXG4gICAgICAgICAgICAgICAgZXZlbnQ6IHRoaXMsXHJcbiAgICAgICAgICAgICAgICByZWxhdGVkRXZlbnRzOiBbXSxcclxuICAgICAgICAgICAgICAgIHJldmVydCgpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmRpc3BhdGNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ01FUkdFX0VWRU5UUycsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50U3RvcmU6IGFzU3RvcmUsXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZ2V0IHNvdXJjZSgpIHtcclxuICAgICAgICAgICAgbGV0IHsgc291cmNlSWQgfSA9IHRoaXMuX2RlZjtcclxuICAgICAgICAgICAgaWYgKHNvdXJjZUlkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEV2ZW50U291cmNlSW1wbCh0aGlzLl9jb250ZXh0LCB0aGlzLl9jb250ZXh0LmdldEN1cnJlbnREYXRhKCkuZXZlbnRTb3VyY2VzW3NvdXJjZUlkXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGdldCBzdGFydCgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2luc3RhbmNlID9cclxuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuZGF0ZUVudi50b0RhdGUodGhpcy5faW5zdGFuY2UucmFuZ2Uuc3RhcnQpIDpcclxuICAgICAgICAgICAgICAgIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGdldCBlbmQoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5faW5zdGFuY2UgJiYgdGhpcy5fZGVmLmhhc0VuZCkgP1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY29udGV4dC5kYXRlRW52LnRvRGF0ZSh0aGlzLl9pbnN0YW5jZS5yYW5nZS5lbmQpIDpcclxuICAgICAgICAgICAgICAgIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGdldCBzdGFydFN0cigpIHtcclxuICAgICAgICAgICAgbGV0IGluc3RhbmNlID0gdGhpcy5faW5zdGFuY2U7XHJcbiAgICAgICAgICAgIGlmIChpbnN0YW5jZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRleHQuZGF0ZUVudi5mb3JtYXRJc28oaW5zdGFuY2UucmFuZ2Uuc3RhcnQsIHtcclxuICAgICAgICAgICAgICAgICAgICBvbWl0VGltZTogdGhpcy5fZGVmLmFsbERheSxcclxuICAgICAgICAgICAgICAgICAgICBmb3JjZWRUem86IGluc3RhbmNlLmZvcmNlZFN0YXJ0VHpvLFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBnZXQgZW5kU3RyKCkge1xyXG4gICAgICAgICAgICBsZXQgaW5zdGFuY2UgPSB0aGlzLl9pbnN0YW5jZTtcclxuICAgICAgICAgICAgaWYgKGluc3RhbmNlICYmIHRoaXMuX2RlZi5oYXNFbmQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb250ZXh0LmRhdGVFbnYuZm9ybWF0SXNvKGluc3RhbmNlLnJhbmdlLmVuZCwge1xyXG4gICAgICAgICAgICAgICAgICAgIG9taXRUaW1lOiB0aGlzLl9kZWYuYWxsRGF5LFxyXG4gICAgICAgICAgICAgICAgICAgIGZvcmNlZFR6bzogaW5zdGFuY2UuZm9yY2VkRW5kVHpvLFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBjb21wdXRhYmxlIHByb3BzIHRoYXQgYWxsIGFjY2VzcyB0aGUgZGVmXHJcbiAgICAgICAgLy8gVE9ETzogZmluZCBhIFR5cGVTY3JpcHQtY29tcGF0aWJsZSB3YXkgdG8gZG8gdGhpcyBhdCBzY2FsZVxyXG4gICAgICAgIGdldCBpZCgpIHsgcmV0dXJuIHRoaXMuX2RlZi5wdWJsaWNJZDsgfVxyXG4gICAgICAgIGdldCBncm91cElkKCkgeyByZXR1cm4gdGhpcy5fZGVmLmdyb3VwSWQ7IH1cclxuICAgICAgICBnZXQgYWxsRGF5KCkgeyByZXR1cm4gdGhpcy5fZGVmLmFsbERheTsgfVxyXG4gICAgICAgIGdldCB0aXRsZSgpIHsgcmV0dXJuIHRoaXMuX2RlZi50aXRsZTsgfVxyXG4gICAgICAgIGdldCB1cmwoKSB7IHJldHVybiB0aGlzLl9kZWYudXJsOyB9XHJcbiAgICAgICAgZ2V0IGRpc3BsYXkoKSB7IHJldHVybiB0aGlzLl9kZWYudWkuZGlzcGxheSB8fCAnYXV0byc7IH0gLy8gYmFkLiBqdXN0IG5vcm1hbGl6ZSB0aGUgdHlwZSBlYXJsaWVyXHJcbiAgICAgICAgZ2V0IHN0YXJ0RWRpdGFibGUoKSB7IHJldHVybiB0aGlzLl9kZWYudWkuc3RhcnRFZGl0YWJsZTsgfVxyXG4gICAgICAgIGdldCBkdXJhdGlvbkVkaXRhYmxlKCkgeyByZXR1cm4gdGhpcy5fZGVmLnVpLmR1cmF0aW9uRWRpdGFibGU7IH1cclxuICAgICAgICBnZXQgY29uc3RyYWludCgpIHsgcmV0dXJuIHRoaXMuX2RlZi51aS5jb25zdHJhaW50c1swXSB8fCBudWxsOyB9XHJcbiAgICAgICAgZ2V0IG92ZXJsYXAoKSB7IHJldHVybiB0aGlzLl9kZWYudWkub3ZlcmxhcDsgfVxyXG4gICAgICAgIGdldCBhbGxvdygpIHsgcmV0dXJuIHRoaXMuX2RlZi51aS5hbGxvd3NbMF0gfHwgbnVsbDsgfVxyXG4gICAgICAgIGdldCBiYWNrZ3JvdW5kQ29sb3IoKSB7IHJldHVybiB0aGlzLl9kZWYudWkuYmFja2dyb3VuZENvbG9yOyB9XHJcbiAgICAgICAgZ2V0IGJvcmRlckNvbG9yKCkgeyByZXR1cm4gdGhpcy5fZGVmLnVpLmJvcmRlckNvbG9yOyB9XHJcbiAgICAgICAgZ2V0IHRleHRDb2xvcigpIHsgcmV0dXJuIHRoaXMuX2RlZi51aS50ZXh0Q29sb3I7IH1cclxuICAgICAgICAvLyBOT1RFOiB1c2VyIGNhbid0IG1vZGlmeSB0aGVzZSBiZWNhdXNlIE9iamVjdC5mcmVlemUgd2FzIGNhbGxlZCBpbiBldmVudC1kZWYgcGFyc2luZ1xyXG4gICAgICAgIGdldCBjbGFzc05hbWVzKCkgeyByZXR1cm4gdGhpcy5fZGVmLnVpLmNsYXNzTmFtZXM7IH1cclxuICAgICAgICBnZXQgZXh0ZW5kZWRQcm9wcygpIHsgcmV0dXJuIHRoaXMuX2RlZi5leHRlbmRlZFByb3BzOyB9XHJcbiAgICAgICAgdG9QbGFpbk9iamVjdChzZXR0aW5ncyA9IHt9KSB7XHJcbiAgICAgICAgICAgIGxldCBkZWYgPSB0aGlzLl9kZWY7XHJcbiAgICAgICAgICAgIGxldCB7IHVpIH0gPSBkZWY7XHJcbiAgICAgICAgICAgIGxldCB7IHN0YXJ0U3RyLCBlbmRTdHIgfSA9IHRoaXM7XHJcbiAgICAgICAgICAgIGxldCByZXMgPSB7XHJcbiAgICAgICAgICAgICAgICBhbGxEYXk6IGRlZi5hbGxEYXksXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGlmIChkZWYudGl0bGUpIHtcclxuICAgICAgICAgICAgICAgIHJlcy50aXRsZSA9IGRlZi50aXRsZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoc3RhcnRTdHIpIHtcclxuICAgICAgICAgICAgICAgIHJlcy5zdGFydCA9IHN0YXJ0U3RyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChlbmRTdHIpIHtcclxuICAgICAgICAgICAgICAgIHJlcy5lbmQgPSBlbmRTdHI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGRlZi5wdWJsaWNJZCkge1xyXG4gICAgICAgICAgICAgICAgcmVzLmlkID0gZGVmLnB1YmxpY0lkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChkZWYuZ3JvdXBJZCkge1xyXG4gICAgICAgICAgICAgICAgcmVzLmdyb3VwSWQgPSBkZWYuZ3JvdXBJZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZGVmLnVybCkge1xyXG4gICAgICAgICAgICAgICAgcmVzLnVybCA9IGRlZi51cmw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHVpLmRpc3BsYXkgJiYgdWkuZGlzcGxheSAhPT0gJ2F1dG8nKSB7XHJcbiAgICAgICAgICAgICAgICByZXMuZGlzcGxheSA9IHVpLmRpc3BsYXk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gVE9ETzogd2hhdCBhYm91dCByZWN1cnJpbmctZXZlbnQgcHJvcGVydGllcz8/P1xyXG4gICAgICAgICAgICAvLyBUT0RPOiBpbmNsdWRlIHN0YXJ0RWRpdGFibGUvZHVyYXRpb25FZGl0YWJsZS9jb25zdHJhaW50L292ZXJsYXAvYWxsb3dcclxuICAgICAgICAgICAgaWYgKHNldHRpbmdzLmNvbGxhcHNlQ29sb3IgJiYgdWkuYmFja2dyb3VuZENvbG9yICYmIHVpLmJhY2tncm91bmRDb2xvciA9PT0gdWkuYm9yZGVyQ29sb3IpIHtcclxuICAgICAgICAgICAgICAgIHJlcy5jb2xvciA9IHVpLmJhY2tncm91bmRDb2xvcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmICh1aS5iYWNrZ3JvdW5kQ29sb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXMuYmFja2dyb3VuZENvbG9yID0gdWkuYmFja2dyb3VuZENvbG9yO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHVpLmJvcmRlckNvbG9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzLmJvcmRlckNvbG9yID0gdWkuYm9yZGVyQ29sb3I7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHVpLnRleHRDb2xvcikge1xyXG4gICAgICAgICAgICAgICAgcmVzLnRleHRDb2xvciA9IHVpLnRleHRDb2xvcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodWkuY2xhc3NOYW1lcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHJlcy5jbGFzc05hbWVzID0gdWkuY2xhc3NOYW1lcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMoZGVmLmV4dGVuZGVkUHJvcHMpLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLmNvbGxhcHNlRXh0ZW5kZWRQcm9wcykge1xyXG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ocmVzLCBkZWYuZXh0ZW5kZWRQcm9wcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXMuZXh0ZW5kZWRQcm9wcyA9IGRlZi5leHRlbmRlZFByb3BzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRvSlNPTigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9QbGFpbk9iamVjdCgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGV2ZW50QXBpVG9TdG9yZShldmVudEFwaSkge1xyXG4gICAgICAgIGxldCBkZWYgPSBldmVudEFwaS5fZGVmO1xyXG4gICAgICAgIGxldCBpbnN0YW5jZSA9IGV2ZW50QXBpLl9pbnN0YW5jZTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBkZWZzOiB7IFtkZWYuZGVmSWRdOiBkZWYgfSxcclxuICAgICAgICAgICAgaW5zdGFuY2VzOiBpbnN0YW5jZVxyXG4gICAgICAgICAgICAgICAgPyB7IFtpbnN0YW5jZS5pbnN0YW5jZUlkXTogaW5zdGFuY2UgfVxyXG4gICAgICAgICAgICAgICAgOiB7fSxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYnVpbGRFdmVudEFwaXMoZXZlbnRTdG9yZSwgY29udGV4dCwgZXhjbHVkZUluc3RhbmNlKSB7XHJcbiAgICAgICAgbGV0IHsgZGVmcywgaW5zdGFuY2VzIH0gPSBldmVudFN0b3JlO1xyXG4gICAgICAgIGxldCBldmVudEFwaXMgPSBbXTtcclxuICAgICAgICBsZXQgZXhjbHVkZUluc3RhbmNlSWQgPSBleGNsdWRlSW5zdGFuY2UgPyBleGNsdWRlSW5zdGFuY2UuaW5zdGFuY2VJZCA6ICcnO1xyXG4gICAgICAgIGZvciAobGV0IGlkIGluIGluc3RhbmNlcykge1xyXG4gICAgICAgICAgICBsZXQgaW5zdGFuY2UgPSBpbnN0YW5jZXNbaWRdO1xyXG4gICAgICAgICAgICBsZXQgZGVmID0gZGVmc1tpbnN0YW5jZS5kZWZJZF07XHJcbiAgICAgICAgICAgIGlmIChpbnN0YW5jZS5pbnN0YW5jZUlkICE9PSBleGNsdWRlSW5zdGFuY2VJZCkge1xyXG4gICAgICAgICAgICAgICAgZXZlbnRBcGlzLnB1c2gobmV3IEV2ZW50SW1wbChjb250ZXh0LCBkZWYsIGluc3RhbmNlKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGV2ZW50QXBpcztcclxuICAgIH1cclxuXHJcbiAgICAvKlxyXG4gICAgU3BlY2lmeWluZyBuZXh0RGF5VGhyZXNob2xkIHNpZ25hbHMgdGhhdCBhbGwtZGF5IHJhbmdlcyBzaG91bGQgYmUgc2xpY2VkLlxyXG4gICAgKi9cclxuICAgIGZ1bmN0aW9uIHNsaWNlRXZlbnRTdG9yZShldmVudFN0b3JlLCBldmVudFVpQmFzZXMsIGZyYW1pbmdSYW5nZSwgbmV4dERheVRocmVzaG9sZCkge1xyXG4gICAgICAgIGxldCBpbnZlcnNlQmdCeUdyb3VwSWQgPSB7fTtcclxuICAgICAgICBsZXQgaW52ZXJzZUJnQnlEZWZJZCA9IHt9O1xyXG4gICAgICAgIGxldCBkZWZCeUdyb3VwSWQgPSB7fTtcclxuICAgICAgICBsZXQgYmdSYW5nZXMgPSBbXTtcclxuICAgICAgICBsZXQgZmdSYW5nZXMgPSBbXTtcclxuICAgICAgICBsZXQgZXZlbnRVaXMgPSBjb21waWxlRXZlbnRVaXMoZXZlbnRTdG9yZS5kZWZzLCBldmVudFVpQmFzZXMpO1xyXG4gICAgICAgIGZvciAobGV0IGRlZklkIGluIGV2ZW50U3RvcmUuZGVmcykge1xyXG4gICAgICAgICAgICBsZXQgZGVmID0gZXZlbnRTdG9yZS5kZWZzW2RlZklkXTtcclxuICAgICAgICAgICAgbGV0IHVpID0gZXZlbnRVaXNbZGVmLmRlZklkXTtcclxuICAgICAgICAgICAgaWYgKHVpLmRpc3BsYXkgPT09ICdpbnZlcnNlLWJhY2tncm91bmQnKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGVmLmdyb3VwSWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBpbnZlcnNlQmdCeUdyb3VwSWRbZGVmLmdyb3VwSWRdID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkZWZCeUdyb3VwSWRbZGVmLmdyb3VwSWRdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZkJ5R3JvdXBJZFtkZWYuZ3JvdXBJZF0gPSBkZWY7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW52ZXJzZUJnQnlEZWZJZFtkZWZJZF0gPSBbXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGxldCBpbnN0YW5jZUlkIGluIGV2ZW50U3RvcmUuaW5zdGFuY2VzKSB7XHJcbiAgICAgICAgICAgIGxldCBpbnN0YW5jZSA9IGV2ZW50U3RvcmUuaW5zdGFuY2VzW2luc3RhbmNlSWRdO1xyXG4gICAgICAgICAgICBsZXQgZGVmID0gZXZlbnRTdG9yZS5kZWZzW2luc3RhbmNlLmRlZklkXTtcclxuICAgICAgICAgICAgbGV0IHVpID0gZXZlbnRVaXNbZGVmLmRlZklkXTtcclxuICAgICAgICAgICAgbGV0IG9yaWdSYW5nZSA9IGluc3RhbmNlLnJhbmdlO1xyXG4gICAgICAgICAgICBsZXQgbm9ybWFsUmFuZ2UgPSAoIWRlZi5hbGxEYXkgJiYgbmV4dERheVRocmVzaG9sZCkgP1xyXG4gICAgICAgICAgICAgICAgY29tcHV0ZVZpc2libGVEYXlSYW5nZShvcmlnUmFuZ2UsIG5leHREYXlUaHJlc2hvbGQpIDpcclxuICAgICAgICAgICAgICAgIG9yaWdSYW5nZTtcclxuICAgICAgICAgICAgbGV0IHNsaWNlZFJhbmdlID0gaW50ZXJzZWN0UmFuZ2VzKG5vcm1hbFJhbmdlLCBmcmFtaW5nUmFuZ2UpO1xyXG4gICAgICAgICAgICBpZiAoc2xpY2VkUmFuZ2UpIHtcclxuICAgICAgICAgICAgICAgIGlmICh1aS5kaXNwbGF5ID09PSAnaW52ZXJzZS1iYWNrZ3JvdW5kJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkZWYuZ3JvdXBJZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnZlcnNlQmdCeUdyb3VwSWRbZGVmLmdyb3VwSWRdLnB1c2goc2xpY2VkUmFuZ2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW52ZXJzZUJnQnlEZWZJZFtpbnN0YW5jZS5kZWZJZF0ucHVzaChzbGljZWRSYW5nZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodWkuZGlzcGxheSAhPT0gJ25vbmUnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgKHVpLmRpc3BsYXkgPT09ICdiYWNrZ3JvdW5kJyA/IGJnUmFuZ2VzIDogZmdSYW5nZXMpLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWYsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IHNsaWNlZFJhbmdlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpc1N0YXJ0OiBub3JtYWxSYW5nZS5zdGFydCAmJiBub3JtYWxSYW5nZS5zdGFydC52YWx1ZU9mKCkgPT09IHNsaWNlZFJhbmdlLnN0YXJ0LnZhbHVlT2YoKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXNFbmQ6IG5vcm1hbFJhbmdlLmVuZCAmJiBub3JtYWxSYW5nZS5lbmQudmFsdWVPZigpID09PSBzbGljZWRSYW5nZS5lbmQudmFsdWVPZigpLFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAobGV0IGdyb3VwSWQgaW4gaW52ZXJzZUJnQnlHcm91cElkKSB7IC8vIEJZIEdST1VQXHJcbiAgICAgICAgICAgIGxldCByYW5nZXMgPSBpbnZlcnNlQmdCeUdyb3VwSWRbZ3JvdXBJZF07XHJcbiAgICAgICAgICAgIGxldCBpbnZlcnRlZFJhbmdlcyA9IGludmVydFJhbmdlcyhyYW5nZXMsIGZyYW1pbmdSYW5nZSk7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGludmVydGVkUmFuZ2Ugb2YgaW52ZXJ0ZWRSYW5nZXMpIHtcclxuICAgICAgICAgICAgICAgIGxldCBkZWYgPSBkZWZCeUdyb3VwSWRbZ3JvdXBJZF07XHJcbiAgICAgICAgICAgICAgICBsZXQgdWkgPSBldmVudFVpc1tkZWYuZGVmSWRdO1xyXG4gICAgICAgICAgICAgICAgYmdSYW5nZXMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVmLFxyXG4gICAgICAgICAgICAgICAgICAgIHVpLFxyXG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlOiBpbnZlcnRlZFJhbmdlLFxyXG4gICAgICAgICAgICAgICAgICAgIGlzU3RhcnQ6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgIGlzRW5kOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAobGV0IGRlZklkIGluIGludmVyc2VCZ0J5RGVmSWQpIHtcclxuICAgICAgICAgICAgbGV0IHJhbmdlcyA9IGludmVyc2VCZ0J5RGVmSWRbZGVmSWRdO1xyXG4gICAgICAgICAgICBsZXQgaW52ZXJ0ZWRSYW5nZXMgPSBpbnZlcnRSYW5nZXMocmFuZ2VzLCBmcmFtaW5nUmFuZ2UpO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpbnZlcnRlZFJhbmdlIG9mIGludmVydGVkUmFuZ2VzKSB7XHJcbiAgICAgICAgICAgICAgICBiZ1Jhbmdlcy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICBkZWY6IGV2ZW50U3RvcmUuZGVmc1tkZWZJZF0sXHJcbiAgICAgICAgICAgICAgICAgICAgdWk6IGV2ZW50VWlzW2RlZklkXSxcclxuICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZTogbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICByYW5nZTogaW52ZXJ0ZWRSYW5nZSxcclxuICAgICAgICAgICAgICAgICAgICBpc1N0YXJ0OiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICBpc0VuZDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4geyBiZzogYmdSYW5nZXMsIGZnOiBmZ1JhbmdlcyB9O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gaGFzQmdSZW5kZXJpbmcoZGVmKSB7XHJcbiAgICAgICAgcmV0dXJuIGRlZi51aS5kaXNwbGF5ID09PSAnYmFja2dyb3VuZCcgfHwgZGVmLnVpLmRpc3BsYXkgPT09ICdpbnZlcnNlLWJhY2tncm91bmQnO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gc2V0RWxTZWcoZWwsIHNlZykge1xyXG4gICAgICAgIGVsLmZjU2VnID0gc2VnO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZ2V0RWxTZWcoZWwpIHtcclxuICAgICAgICByZXR1cm4gZWwuZmNTZWcgfHxcclxuICAgICAgICAgICAgZWwucGFyZW50Tm9kZS5mY1NlZyB8fCAvLyBmb3IgdGhlIGhhcm5lc3NcclxuICAgICAgICAgICAgbnVsbDtcclxuICAgIH1cclxuICAgIC8vIGV2ZW50IHVpIGNvbXB1dGF0aW9uXHJcbiAgICBmdW5jdGlvbiBjb21waWxlRXZlbnRVaXMoZXZlbnREZWZzLCBldmVudFVpQmFzZXMpIHtcclxuICAgICAgICByZXR1cm4gbWFwSGFzaChldmVudERlZnMsIChldmVudERlZikgPT4gY29tcGlsZUV2ZW50VWkoZXZlbnREZWYsIGV2ZW50VWlCYXNlcykpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gY29tcGlsZUV2ZW50VWkoZXZlbnREZWYsIGV2ZW50VWlCYXNlcykge1xyXG4gICAgICAgIGxldCB1aXMgPSBbXTtcclxuICAgICAgICBpZiAoZXZlbnRVaUJhc2VzWycnXSkge1xyXG4gICAgICAgICAgICB1aXMucHVzaChldmVudFVpQmFzZXNbJyddKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGV2ZW50VWlCYXNlc1tldmVudERlZi5kZWZJZF0pIHtcclxuICAgICAgICAgICAgdWlzLnB1c2goZXZlbnRVaUJhc2VzW2V2ZW50RGVmLmRlZklkXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHVpcy5wdXNoKGV2ZW50RGVmLnVpKTtcclxuICAgICAgICByZXR1cm4gY29tYmluZUV2ZW50VWlzKHVpcyk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBzb3J0RXZlbnRTZWdzKHNlZ3MsIGV2ZW50T3JkZXJTcGVjcykge1xyXG4gICAgICAgIGxldCBvYmpzID0gc2Vncy5tYXAoYnVpbGRTZWdDb21wYXJlT2JqKTtcclxuICAgICAgICBvYmpzLnNvcnQoKG9iajAsIG9iajEpID0+IGNvbXBhcmVCeUZpZWxkU3BlY3Mob2JqMCwgb2JqMSwgZXZlbnRPcmRlclNwZWNzKSk7XHJcbiAgICAgICAgcmV0dXJuIG9ianMubWFwKChjKSA9PiBjLl9zZWcpO1xyXG4gICAgfVxyXG4gICAgLy8gcmV0dXJucyBhIG9iamVjdCB3aXRoIGFsbCBwcmltaXRpdmUgcHJvcHMgdGhhdCBjYW4gYmUgY29tcGFyZWRcclxuICAgIGZ1bmN0aW9uIGJ1aWxkU2VnQ29tcGFyZU9iaihzZWcpIHtcclxuICAgICAgICBsZXQgeyBldmVudFJhbmdlIH0gPSBzZWc7XHJcbiAgICAgICAgbGV0IGV2ZW50RGVmID0gZXZlbnRSYW5nZS5kZWY7XHJcbiAgICAgICAgbGV0IHJhbmdlID0gZXZlbnRSYW5nZS5pbnN0YW5jZSA/IGV2ZW50UmFuZ2UuaW5zdGFuY2UucmFuZ2UgOiBldmVudFJhbmdlLnJhbmdlO1xyXG4gICAgICAgIGxldCBzdGFydCA9IHJhbmdlLnN0YXJ0ID8gcmFuZ2Uuc3RhcnQudmFsdWVPZigpIDogMDsgLy8gVE9ETzogYmV0dGVyIHN1cHBvcnQgZm9yIG9wZW4tcmFuZ2UgZXZlbnRzXHJcbiAgICAgICAgbGV0IGVuZCA9IHJhbmdlLmVuZCA/IHJhbmdlLmVuZC52YWx1ZU9mKCkgOiAwOyAvLyBcIlxyXG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZXZlbnREZWYuZXh0ZW5kZWRQcm9wcyksIGV2ZW50RGVmKSwgeyBpZDogZXZlbnREZWYucHVibGljSWQsIHN0YXJ0LFxyXG4gICAgICAgICAgICBlbmQsIGR1cmF0aW9uOiBlbmQgLSBzdGFydCwgYWxsRGF5OiBOdW1iZXIoZXZlbnREZWYuYWxsRGF5KSwgX3NlZzogc2VnIH0pO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gY29tcHV0ZVNlZ0RyYWdnYWJsZShzZWcsIGNvbnRleHQpIHtcclxuICAgICAgICBsZXQgeyBwbHVnaW5Ib29rcyB9ID0gY29udGV4dDtcclxuICAgICAgICBsZXQgdHJhbnNmb3JtZXJzID0gcGx1Z2luSG9va3MuaXNEcmFnZ2FibGVUcmFuc2Zvcm1lcnM7XHJcbiAgICAgICAgbGV0IHsgZGVmLCB1aSB9ID0gc2VnLmV2ZW50UmFuZ2U7XHJcbiAgICAgICAgbGV0IHZhbCA9IHVpLnN0YXJ0RWRpdGFibGU7XHJcbiAgICAgICAgZm9yIChsZXQgdHJhbnNmb3JtZXIgb2YgdHJhbnNmb3JtZXJzKSB7XHJcbiAgICAgICAgICAgIHZhbCA9IHRyYW5zZm9ybWVyKHZhbCwgZGVmLCB1aSwgY29udGV4dCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB2YWw7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBjb21wdXRlU2VnU3RhcnRSZXNpemFibGUoc2VnLCBjb250ZXh0KSB7XHJcbiAgICAgICAgcmV0dXJuIHNlZy5pc1N0YXJ0ICYmIHNlZy5ldmVudFJhbmdlLnVpLmR1cmF0aW9uRWRpdGFibGUgJiYgY29udGV4dC5vcHRpb25zLmV2ZW50UmVzaXphYmxlRnJvbVN0YXJ0O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gY29tcHV0ZVNlZ0VuZFJlc2l6YWJsZShzZWcsIGNvbnRleHQpIHtcclxuICAgICAgICByZXR1cm4gc2VnLmlzRW5kICYmIHNlZy5ldmVudFJhbmdlLnVpLmR1cmF0aW9uRWRpdGFibGU7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBidWlsZFNlZ1RpbWVUZXh0KHNlZywgdGltZUZvcm1hdCwgY29udGV4dCwgZGVmYXVsdERpc3BsYXlFdmVudFRpbWUsIC8vIGRlZmF1bHRzIHRvIHRydWVcclxuICAgIGRlZmF1bHREaXNwbGF5RXZlbnRFbmQsIC8vIGRlZmF1bHRzIHRvIHRydWVcclxuICAgIHN0YXJ0T3ZlcnJpZGUsIGVuZE92ZXJyaWRlKSB7XHJcbiAgICAgICAgbGV0IHsgZGF0ZUVudiwgb3B0aW9ucyB9ID0gY29udGV4dDtcclxuICAgICAgICBsZXQgeyBkaXNwbGF5RXZlbnRUaW1lLCBkaXNwbGF5RXZlbnRFbmQgfSA9IG9wdGlvbnM7XHJcbiAgICAgICAgbGV0IGV2ZW50RGVmID0gc2VnLmV2ZW50UmFuZ2UuZGVmO1xyXG4gICAgICAgIGxldCBldmVudEluc3RhbmNlID0gc2VnLmV2ZW50UmFuZ2UuaW5zdGFuY2U7XHJcbiAgICAgICAgaWYgKGRpc3BsYXlFdmVudFRpbWUgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBkaXNwbGF5RXZlbnRUaW1lID0gZGVmYXVsdERpc3BsYXlFdmVudFRpbWUgIT09IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZGlzcGxheUV2ZW50RW5kID09IG51bGwpIHtcclxuICAgICAgICAgICAgZGlzcGxheUV2ZW50RW5kID0gZGVmYXVsdERpc3BsYXlFdmVudEVuZCAhPT0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCB3aG9sZUV2ZW50U3RhcnQgPSBldmVudEluc3RhbmNlLnJhbmdlLnN0YXJ0O1xyXG4gICAgICAgIGxldCB3aG9sZUV2ZW50RW5kID0gZXZlbnRJbnN0YW5jZS5yYW5nZS5lbmQ7XHJcbiAgICAgICAgbGV0IHNlZ1N0YXJ0ID0gc3RhcnRPdmVycmlkZSB8fCBzZWcuc3RhcnQgfHwgc2VnLmV2ZW50UmFuZ2UucmFuZ2Uuc3RhcnQ7XHJcbiAgICAgICAgbGV0IHNlZ0VuZCA9IGVuZE92ZXJyaWRlIHx8IHNlZy5lbmQgfHwgc2VnLmV2ZW50UmFuZ2UucmFuZ2UuZW5kO1xyXG4gICAgICAgIGxldCBpc1N0YXJ0RGF5ID0gc3RhcnRPZkRheSh3aG9sZUV2ZW50U3RhcnQpLnZhbHVlT2YoKSA9PT0gc3RhcnRPZkRheShzZWdTdGFydCkudmFsdWVPZigpO1xyXG4gICAgICAgIGxldCBpc0VuZERheSA9IHN0YXJ0T2ZEYXkoYWRkTXMod2hvbGVFdmVudEVuZCwgLTEpKS52YWx1ZU9mKCkgPT09IHN0YXJ0T2ZEYXkoYWRkTXMoc2VnRW5kLCAtMSkpLnZhbHVlT2YoKTtcclxuICAgICAgICBpZiAoZGlzcGxheUV2ZW50VGltZSAmJiAhZXZlbnREZWYuYWxsRGF5ICYmIChpc1N0YXJ0RGF5IHx8IGlzRW5kRGF5KSkge1xyXG4gICAgICAgICAgICBzZWdTdGFydCA9IGlzU3RhcnREYXkgPyB3aG9sZUV2ZW50U3RhcnQgOiBzZWdTdGFydDtcclxuICAgICAgICAgICAgc2VnRW5kID0gaXNFbmREYXkgPyB3aG9sZUV2ZW50RW5kIDogc2VnRW5kO1xyXG4gICAgICAgICAgICBpZiAoZGlzcGxheUV2ZW50RW5kICYmIGV2ZW50RGVmLmhhc0VuZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGVFbnYuZm9ybWF0UmFuZ2Uoc2VnU3RhcnQsIHNlZ0VuZCwgdGltZUZvcm1hdCwge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvcmNlZFN0YXJ0VHpvOiBzdGFydE92ZXJyaWRlID8gbnVsbCA6IGV2ZW50SW5zdGFuY2UuZm9yY2VkU3RhcnRUem8sXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yY2VkRW5kVHpvOiBlbmRPdmVycmlkZSA/IG51bGwgOiBldmVudEluc3RhbmNlLmZvcmNlZEVuZFR6byxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBkYXRlRW52LmZvcm1hdChzZWdTdGFydCwgdGltZUZvcm1hdCwge1xyXG4gICAgICAgICAgICAgICAgZm9yY2VkVHpvOiBzdGFydE92ZXJyaWRlID8gbnVsbCA6IGV2ZW50SW5zdGFuY2UuZm9yY2VkU3RhcnRUem8sIC8vIG5vb29vbywgc2FtZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZ2V0U2VnTWV0YShzZWcsIHRvZGF5UmFuZ2UsIG5vd0RhdGUpIHtcclxuICAgICAgICBsZXQgc2VnUmFuZ2UgPSBzZWcuZXZlbnRSYW5nZS5yYW5nZTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBpc1Bhc3Q6IHNlZ1JhbmdlLmVuZCA8IChub3dEYXRlIHx8IHRvZGF5UmFuZ2Uuc3RhcnQpLFxyXG4gICAgICAgICAgICBpc0Z1dHVyZTogc2VnUmFuZ2Uuc3RhcnQgPj0gKG5vd0RhdGUgfHwgdG9kYXlSYW5nZS5lbmQpLFxyXG4gICAgICAgICAgICBpc1RvZGF5OiB0b2RheVJhbmdlICYmIHJhbmdlQ29udGFpbnNNYXJrZXIodG9kYXlSYW5nZSwgc2VnUmFuZ2Uuc3RhcnQpLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBnZXRFdmVudENsYXNzTmFtZXMocHJvcHMpIHtcclxuICAgICAgICBsZXQgY2xhc3NOYW1lcyA9IFsnZmMtZXZlbnQnXTtcclxuICAgICAgICBpZiAocHJvcHMuaXNNaXJyb3IpIHtcclxuICAgICAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1ldmVudC1taXJyb3InKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHByb3BzLmlzRHJhZ2dhYmxlKSB7XHJcbiAgICAgICAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtZXZlbnQtZHJhZ2dhYmxlJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwcm9wcy5pc1N0YXJ0UmVzaXphYmxlIHx8IHByb3BzLmlzRW5kUmVzaXphYmxlKSB7XHJcbiAgICAgICAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtZXZlbnQtcmVzaXphYmxlJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwcm9wcy5pc0RyYWdnaW5nKSB7XHJcbiAgICAgICAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtZXZlbnQtZHJhZ2dpbmcnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHByb3BzLmlzUmVzaXppbmcpIHtcclxuICAgICAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1ldmVudC1yZXNpemluZycpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocHJvcHMuaXNTZWxlY3RlZCkge1xyXG4gICAgICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLWV2ZW50LXNlbGVjdGVkJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwcm9wcy5pc1N0YXJ0KSB7XHJcbiAgICAgICAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtZXZlbnQtc3RhcnQnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHByb3BzLmlzRW5kKSB7XHJcbiAgICAgICAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtZXZlbnQtZW5kJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwcm9wcy5pc1Bhc3QpIHtcclxuICAgICAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1ldmVudC1wYXN0Jyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwcm9wcy5pc1RvZGF5KSB7XHJcbiAgICAgICAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtZXZlbnQtdG9kYXknKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHByb3BzLmlzRnV0dXJlKSB7XHJcbiAgICAgICAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtZXZlbnQtZnV0dXJlJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjbGFzc05hbWVzO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYnVpbGRFdmVudFJhbmdlS2V5KGV2ZW50UmFuZ2UpIHtcclxuICAgICAgICByZXR1cm4gZXZlbnRSYW5nZS5pbnN0YW5jZVxyXG4gICAgICAgICAgICA/IGV2ZW50UmFuZ2UuaW5zdGFuY2UuaW5zdGFuY2VJZFxyXG4gICAgICAgICAgICA6IGAke2V2ZW50UmFuZ2UuZGVmLmRlZklkfToke2V2ZW50UmFuZ2UucmFuZ2Uuc3RhcnQudG9JU09TdHJpbmcoKX1gO1xyXG4gICAgICAgIC8vIGludmVyc2UtYmFja2dyb3VuZCBldmVudHMgZG9uJ3QgaGF2ZSBzcGVjaWZpYyBpbnN0YW5jZXMuIFRPRE86IGJldHRlciBzb2x1dGlvblxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZ2V0U2VnQW5jaG9yQXR0cnMoc2VnLCBjb250ZXh0KSB7XHJcbiAgICAgICAgbGV0IHsgZGVmLCBpbnN0YW5jZSB9ID0gc2VnLmV2ZW50UmFuZ2U7XHJcbiAgICAgICAgbGV0IHsgdXJsIH0gPSBkZWY7XHJcbiAgICAgICAgaWYgKHVybCkge1xyXG4gICAgICAgICAgICByZXR1cm4geyBocmVmOiB1cmwgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHsgZW1pdHRlciwgb3B0aW9ucyB9ID0gY29udGV4dDtcclxuICAgICAgICBsZXQgeyBldmVudEludGVyYWN0aXZlIH0gPSBvcHRpb25zO1xyXG4gICAgICAgIGlmIChldmVudEludGVyYWN0aXZlID09IG51bGwpIHtcclxuICAgICAgICAgICAgZXZlbnRJbnRlcmFjdGl2ZSA9IGRlZi5pbnRlcmFjdGl2ZTtcclxuICAgICAgICAgICAgaWYgKGV2ZW50SW50ZXJhY3RpdmUgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgZXZlbnRJbnRlcmFjdGl2ZSA9IEJvb2xlYW4oZW1pdHRlci5oYXNIYW5kbGVycygnZXZlbnRDbGljaycpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBtb2NrIHdoYXQgaGFwcGVucyBpbiBFdmVudENsaWNraW5nXHJcbiAgICAgICAgaWYgKGV2ZW50SW50ZXJhY3RpdmUpIHtcclxuICAgICAgICAgICAgLy8gb25seSBhdHRhY2gga2V5Ym9hcmQtcmVsYXRlZCBoYW5kbGVycyBiZWNhdXNlIGNsaWNrIGhhbmRsZXIgaXMgYWxyZWFkeSBkb25lIGluIEV2ZW50Q2xpY2tpbmdcclxuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUFyaWFLZXlib2FyZEF0dHJzKChldikgPT4ge1xyXG4gICAgICAgICAgICAgICAgZW1pdHRlci50cmlnZ2VyKCdldmVudENsaWNrJywge1xyXG4gICAgICAgICAgICAgICAgICAgIGVsOiBldi50YXJnZXQsXHJcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IG5ldyBFdmVudEltcGwoY29udGV4dCwgZGVmLCBpbnN0YW5jZSksXHJcbiAgICAgICAgICAgICAgICAgICAganNFdmVudDogZXYsXHJcbiAgICAgICAgICAgICAgICAgICAgdmlldzogY29udGV4dC52aWV3QXBpLFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4ge307XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgU1RBTkRBUkRfUFJPUFMgPSB7XHJcbiAgICAgICAgc3RhcnQ6IGlkZW50aXR5LFxyXG4gICAgICAgIGVuZDogaWRlbnRpdHksXHJcbiAgICAgICAgYWxsRGF5OiBCb29sZWFuLFxyXG4gICAgfTtcclxuICAgIGZ1bmN0aW9uIHBhcnNlRGF0ZVNwYW4ocmF3LCBkYXRlRW52LCBkZWZhdWx0RHVyYXRpb24pIHtcclxuICAgICAgICBsZXQgc3BhbiA9IHBhcnNlT3BlbkRhdGVTcGFuKHJhdywgZGF0ZUVudik7XHJcbiAgICAgICAgbGV0IHsgcmFuZ2UgfSA9IHNwYW47XHJcbiAgICAgICAgaWYgKCFyYW5nZS5zdGFydCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFyYW5nZS5lbmQpIHtcclxuICAgICAgICAgICAgaWYgKGRlZmF1bHREdXJhdGlvbiA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByYW5nZS5lbmQgPSBkYXRlRW52LmFkZChyYW5nZS5zdGFydCwgZGVmYXVsdER1cmF0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHNwYW47XHJcbiAgICB9XHJcbiAgICAvKlxyXG4gICAgVE9ETzogc29tZWhvdyBjb21iaW5lIHdpdGggcGFyc2VSYW5nZT9cclxuICAgIFdpbGwgcmV0dXJuIG51bGwgaWYgdGhlIHN0YXJ0L2VuZCBwcm9wcyB3ZXJlIHByZXNlbnQgYnV0IHBhcnNlZCBpbnZhbGlkbHkuXHJcbiAgICAqL1xyXG4gICAgZnVuY3Rpb24gcGFyc2VPcGVuRGF0ZVNwYW4ocmF3LCBkYXRlRW52KSB7XHJcbiAgICAgICAgbGV0IHsgcmVmaW5lZDogc3RhbmRhcmRQcm9wcywgZXh0cmEgfSA9IHJlZmluZVByb3BzKHJhdywgU1RBTkRBUkRfUFJPUFMpO1xyXG4gICAgICAgIGxldCBzdGFydE1ldGEgPSBzdGFuZGFyZFByb3BzLnN0YXJ0ID8gZGF0ZUVudi5jcmVhdGVNYXJrZXJNZXRhKHN0YW5kYXJkUHJvcHMuc3RhcnQpIDogbnVsbDtcclxuICAgICAgICBsZXQgZW5kTWV0YSA9IHN0YW5kYXJkUHJvcHMuZW5kID8gZGF0ZUVudi5jcmVhdGVNYXJrZXJNZXRhKHN0YW5kYXJkUHJvcHMuZW5kKSA6IG51bGw7XHJcbiAgICAgICAgbGV0IHsgYWxsRGF5IH0gPSBzdGFuZGFyZFByb3BzO1xyXG4gICAgICAgIGlmIChhbGxEYXkgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBhbGxEYXkgPSAoc3RhcnRNZXRhICYmIHN0YXJ0TWV0YS5pc1RpbWVVbnNwZWNpZmllZCkgJiZcclxuICAgICAgICAgICAgICAgICghZW5kTWV0YSB8fCBlbmRNZXRhLmlzVGltZVVuc3BlY2lmaWVkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oeyByYW5nZToge1xyXG4gICAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0TWV0YSA/IHN0YXJ0TWV0YS5tYXJrZXIgOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgZW5kOiBlbmRNZXRhID8gZW5kTWV0YS5tYXJrZXIgOiBudWxsLFxyXG4gICAgICAgICAgICB9LCBhbGxEYXkgfSwgZXh0cmEpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gaXNEYXRlU3BhbnNFcXVhbChzcGFuMCwgc3BhbjEpIHtcclxuICAgICAgICByZXR1cm4gcmFuZ2VzRXF1YWwoc3BhbjAucmFuZ2UsIHNwYW4xLnJhbmdlKSAmJlxyXG4gICAgICAgICAgICBzcGFuMC5hbGxEYXkgPT09IHNwYW4xLmFsbERheSAmJlxyXG4gICAgICAgICAgICBpc1NwYW5Qcm9wc0VxdWFsKHNwYW4wLCBzcGFuMSk7XHJcbiAgICB9XHJcbiAgICAvLyB0aGUgTk9OLURBVEUtUkVMQVRFRCBwcm9wc1xyXG4gICAgZnVuY3Rpb24gaXNTcGFuUHJvcHNFcXVhbChzcGFuMCwgc3BhbjEpIHtcclxuICAgICAgICBmb3IgKGxldCBwcm9wTmFtZSBpbiBzcGFuMSkge1xyXG4gICAgICAgICAgICBpZiAocHJvcE5hbWUgIT09ICdyYW5nZScgJiYgcHJvcE5hbWUgIT09ICdhbGxEYXknKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3BhbjBbcHJvcE5hbWVdICE9PSBzcGFuMVtwcm9wTmFtZV0pIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gYXJlIHRoZXJlIGFueSBwcm9wcyB0aGF0IHNwYW4wIGhhcyB0aGF0IHNwYW4xIERPRVNOJ1QgaGF2ZT9cclxuICAgICAgICAvLyBib3RoIGhhdmUgcmFuZ2UvYWxsRGF5LCBzbyBubyBuZWVkIHRvIHNwZWNpYWwtY2FzZS5cclxuICAgICAgICBmb3IgKGxldCBwcm9wTmFtZSBpbiBzcGFuMCkge1xyXG4gICAgICAgICAgICBpZiAoIShwcm9wTmFtZSBpbiBzcGFuMSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGJ1aWxkRGF0ZVNwYW5BcGkoc3BhbiwgZGF0ZUVudikge1xyXG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGJ1aWxkUmFuZ2VBcGkoc3Bhbi5yYW5nZSwgZGF0ZUVudiwgc3Bhbi5hbGxEYXkpKSwgeyBhbGxEYXk6IHNwYW4uYWxsRGF5IH0pO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYnVpbGRSYW5nZUFwaVdpdGhUaW1lWm9uZShyYW5nZSwgZGF0ZUVudiwgb21pdFRpbWUpIHtcclxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBidWlsZFJhbmdlQXBpKHJhbmdlLCBkYXRlRW52LCBvbWl0VGltZSkpLCB7IHRpbWVab25lOiBkYXRlRW52LnRpbWVab25lIH0pO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYnVpbGRSYW5nZUFwaShyYW5nZSwgZGF0ZUVudiwgb21pdFRpbWUpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBzdGFydDogZGF0ZUVudi50b0RhdGUocmFuZ2Uuc3RhcnQpLFxyXG4gICAgICAgICAgICBlbmQ6IGRhdGVFbnYudG9EYXRlKHJhbmdlLmVuZCksXHJcbiAgICAgICAgICAgIHN0YXJ0U3RyOiBkYXRlRW52LmZvcm1hdElzbyhyYW5nZS5zdGFydCwgeyBvbWl0VGltZSB9KSxcclxuICAgICAgICAgICAgZW5kU3RyOiBkYXRlRW52LmZvcm1hdElzbyhyYW5nZS5lbmQsIHsgb21pdFRpbWUgfSksXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGZhYnJpY2F0ZUV2ZW50UmFuZ2UoZGF0ZVNwYW4sIGV2ZW50VWlCYXNlcywgY29udGV4dCkge1xyXG4gICAgICAgIGxldCByZXMgPSByZWZpbmVFdmVudERlZih7IGVkaXRhYmxlOiBmYWxzZSB9LCBjb250ZXh0KTtcclxuICAgICAgICBsZXQgZGVmID0gcGFyc2VFdmVudERlZihyZXMucmVmaW5lZCwgcmVzLmV4dHJhLCAnJywgLy8gc291cmNlSWRcclxuICAgICAgICBkYXRlU3Bhbi5hbGxEYXksIHRydWUsIC8vIGhhc0VuZFxyXG4gICAgICAgIGNvbnRleHQpO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGRlZixcclxuICAgICAgICAgICAgdWk6IGNvbXBpbGVFdmVudFVpKGRlZiwgZXZlbnRVaUJhc2VzKSxcclxuICAgICAgICAgICAgaW5zdGFuY2U6IGNyZWF0ZUV2ZW50SW5zdGFuY2UoZGVmLmRlZklkLCBkYXRlU3Bhbi5yYW5nZSksXHJcbiAgICAgICAgICAgIHJhbmdlOiBkYXRlU3Bhbi5yYW5nZSxcclxuICAgICAgICAgICAgaXNTdGFydDogdHJ1ZSxcclxuICAgICAgICAgICAgaXNFbmQ6IHRydWUsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBsZXQgY2FsZW5kYXJTeXN0ZW1DbGFzc01hcCA9IHt9O1xyXG4gICAgZnVuY3Rpb24gcmVnaXN0ZXJDYWxlbmRhclN5c3RlbShuYW1lLCB0aGVDbGFzcykge1xyXG4gICAgICAgIGNhbGVuZGFyU3lzdGVtQ2xhc3NNYXBbbmFtZV0gPSB0aGVDbGFzcztcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGNyZWF0ZUNhbGVuZGFyU3lzdGVtKG5hbWUpIHtcclxuICAgICAgICByZXR1cm4gbmV3IGNhbGVuZGFyU3lzdGVtQ2xhc3NNYXBbbmFtZV0oKTtcclxuICAgIH1cclxuICAgIGNsYXNzIEdyZWdvcmlhbkNhbGVuZGFyU3lzdGVtIHtcclxuICAgICAgICBnZXRNYXJrZXJZZWFyKGQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGQuZ2V0VVRDRnVsbFllYXIoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZ2V0TWFya2VyTW9udGgoZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZC5nZXRVVENNb250aCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBnZXRNYXJrZXJEYXkoZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZC5nZXRVVENEYXRlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGFycmF5VG9NYXJrZXIoYXJyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhcnJheVRvVXRjRGF0ZShhcnIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBtYXJrZXJUb0FycmF5KG1hcmtlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gZGF0ZVRvVXRjQXJyYXkobWFya2VyKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZWdpc3RlckNhbGVuZGFyU3lzdGVtKCdncmVnb3J5JywgR3JlZ29yaWFuQ2FsZW5kYXJTeXN0ZW0pO1xyXG5cclxuICAgIGNvbnN0IElTT19SRSA9IC9eXFxzKihcXGR7NH0pKC0/KFxcZHsyfSkoLT8oXFxkezJ9KShbVCBdKFxcZHsyfSk6PyhcXGR7Mn0pKDo/KFxcZHsyfSkoXFwuKFxcZCspKT8pPyhafCgoWy0rXSkoXFxkezJ9KSg6PyhcXGR7Mn0pKT8pKT8pPyk/KT8kLztcclxuICAgIGZ1bmN0aW9uIHBhcnNlKHN0cikge1xyXG4gICAgICAgIGxldCBtID0gSVNPX1JFLmV4ZWMoc3RyKTtcclxuICAgICAgICBpZiAobSkge1xyXG4gICAgICAgICAgICBsZXQgbWFya2VyID0gbmV3IERhdGUoRGF0ZS5VVEMoTnVtYmVyKG1bMV0pLCBtWzNdID8gTnVtYmVyKG1bM10pIC0gMSA6IDAsIE51bWJlcihtWzVdIHx8IDEpLCBOdW1iZXIobVs3XSB8fCAwKSwgTnVtYmVyKG1bOF0gfHwgMCksIE51bWJlcihtWzEwXSB8fCAwKSwgbVsxMl0gPyBOdW1iZXIoYDAuJHttWzEyXX1gKSAqIDEwMDAgOiAwKSk7XHJcbiAgICAgICAgICAgIGlmIChpc1ZhbGlkRGF0ZShtYXJrZXIpKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgdGltZVpvbmVPZmZzZXQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgaWYgKG1bMTNdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGltZVpvbmVPZmZzZXQgPSAobVsxNV0gPT09ICctJyA/IC0xIDogMSkgKiAoTnVtYmVyKG1bMTZdIHx8IDApICogNjAgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBOdW1iZXIobVsxOF0gfHwgMCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICBtYXJrZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgaXNUaW1lVW5zcGVjaWZpZWQ6ICFtWzZdLFxyXG4gICAgICAgICAgICAgICAgICAgIHRpbWVab25lT2Zmc2V0LFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBjbGFzcyBEYXRlRW52IHtcclxuICAgICAgICBjb25zdHJ1Y3RvcihzZXR0aW5ncykge1xyXG4gICAgICAgICAgICBsZXQgdGltZVpvbmUgPSB0aGlzLnRpbWVab25lID0gc2V0dGluZ3MudGltZVpvbmU7XHJcbiAgICAgICAgICAgIGxldCBpc05hbWVkVGltZVpvbmUgPSB0aW1lWm9uZSAhPT0gJ2xvY2FsJyAmJiB0aW1lWm9uZSAhPT0gJ1VUQyc7XHJcbiAgICAgICAgICAgIGlmIChzZXR0aW5ncy5uYW1lZFRpbWVab25lSW1wbCAmJiBpc05hbWVkVGltZVpvbmUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubmFtZWRUaW1lWm9uZUltcGwgPSBuZXcgc2V0dGluZ3MubmFtZWRUaW1lWm9uZUltcGwodGltZVpvbmUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuY2FuQ29tcHV0ZU9mZnNldCA9IEJvb2xlYW4oIWlzTmFtZWRUaW1lWm9uZSB8fCB0aGlzLm5hbWVkVGltZVpvbmVJbXBsKTtcclxuICAgICAgICAgICAgdGhpcy5jYWxlbmRhclN5c3RlbSA9IGNyZWF0ZUNhbGVuZGFyU3lzdGVtKHNldHRpbmdzLmNhbGVuZGFyU3lzdGVtKTtcclxuICAgICAgICAgICAgdGhpcy5sb2NhbGUgPSBzZXR0aW5ncy5sb2NhbGU7XHJcbiAgICAgICAgICAgIHRoaXMud2Vla0RvdyA9IHNldHRpbmdzLmxvY2FsZS53ZWVrLmRvdztcclxuICAgICAgICAgICAgdGhpcy53ZWVrRG95ID0gc2V0dGluZ3MubG9jYWxlLndlZWsuZG95O1xyXG4gICAgICAgICAgICBpZiAoc2V0dGluZ3Mud2Vla051bWJlckNhbGN1bGF0aW9uID09PSAnSVNPJykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy53ZWVrRG93ID0gMTtcclxuICAgICAgICAgICAgICAgIHRoaXMud2Vla0RveSA9IDQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBzZXR0aW5ncy5maXJzdERheSA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMud2Vla0RvdyA9IHNldHRpbmdzLmZpcnN0RGF5O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2V0dGluZ3Mud2Vla051bWJlckNhbGN1bGF0aW9uID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLndlZWtOdW1iZXJGdW5jID0gc2V0dGluZ3Mud2Vla051bWJlckNhbGN1bGF0aW9uO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMud2Vla1RleHQgPSBzZXR0aW5ncy53ZWVrVGV4dCAhPSBudWxsID8gc2V0dGluZ3Mud2Vla1RleHQgOiBzZXR0aW5ncy5sb2NhbGUub3B0aW9ucy53ZWVrVGV4dDtcclxuICAgICAgICAgICAgdGhpcy53ZWVrVGV4dExvbmcgPSAoc2V0dGluZ3Mud2Vla1RleHRMb25nICE9IG51bGwgPyBzZXR0aW5ncy53ZWVrVGV4dExvbmcgOiBzZXR0aW5ncy5sb2NhbGUub3B0aW9ucy53ZWVrVGV4dExvbmcpIHx8IHRoaXMud2Vla1RleHQ7XHJcbiAgICAgICAgICAgIHRoaXMuY21kRm9ybWF0dGVyID0gc2V0dGluZ3MuY21kRm9ybWF0dGVyO1xyXG4gICAgICAgICAgICB0aGlzLmRlZmF1bHRTZXBhcmF0b3IgPSBzZXR0aW5ncy5kZWZhdWx0U2VwYXJhdG9yO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBDcmVhdGluZyAvIFBhcnNpbmdcclxuICAgICAgICBjcmVhdGVNYXJrZXIoaW5wdXQpIHtcclxuICAgICAgICAgICAgbGV0IG1ldGEgPSB0aGlzLmNyZWF0ZU1hcmtlck1ldGEoaW5wdXQpO1xyXG4gICAgICAgICAgICBpZiAobWV0YSA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG1ldGEubWFya2VyO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjcmVhdGVOb3dNYXJrZXIoKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNhbkNvbXB1dGVPZmZzZXQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRpbWVzdGFtcFRvTWFya2VyKG5ldyBEYXRlKCkudmFsdWVPZigpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBpZiB3ZSBjYW4ndCBjb21wdXRlIHRoZSBjdXJyZW50IGRhdGUgdmFsIGZvciBhIHRpbWV6b25lLFxyXG4gICAgICAgICAgICAvLyBiZXR0ZXIgdG8gZ2l2ZSB0aGUgY3VycmVudCBsb2NhbCBkYXRlIHZhbHMgdGhhbiBVVENcclxuICAgICAgICAgICAgcmV0dXJuIGFycmF5VG9VdGNEYXRlKGRhdGVUb0xvY2FsQXJyYXkobmV3IERhdGUoKSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjcmVhdGVNYXJrZXJNZXRhKGlucHV0KSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZShpbnB1dCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IG1hcmtlciA9IG51bGw7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgICAgICBtYXJrZXIgPSB0aGlzLnRpbWVzdGFtcFRvTWFya2VyKGlucHV0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChpbnB1dCBpbnN0YW5jZW9mIERhdGUpIHtcclxuICAgICAgICAgICAgICAgIGlucHV0ID0gaW5wdXQudmFsdWVPZigpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc05hTihpbnB1dCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBtYXJrZXIgPSB0aGlzLnRpbWVzdGFtcFRvTWFya2VyKGlucHV0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGlucHV0KSkge1xyXG4gICAgICAgICAgICAgICAgbWFya2VyID0gYXJyYXlUb1V0Y0RhdGUoaW5wdXQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChtYXJrZXIgPT09IG51bGwgfHwgIWlzVmFsaWREYXRlKG1hcmtlcikpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB7IG1hcmtlciwgaXNUaW1lVW5zcGVjaWZpZWQ6IGZhbHNlLCBmb3JjZWRUem86IG51bGwgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcGFyc2Uocykge1xyXG4gICAgICAgICAgICBsZXQgcGFydHMgPSBwYXJzZShzKTtcclxuICAgICAgICAgICAgaWYgKHBhcnRzID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgeyBtYXJrZXIgfSA9IHBhcnRzO1xyXG4gICAgICAgICAgICBsZXQgZm9yY2VkVHpvID0gbnVsbDtcclxuICAgICAgICAgICAgaWYgKHBhcnRzLnRpbWVab25lT2Zmc2V0ICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jYW5Db21wdXRlT2Zmc2V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWFya2VyID0gdGhpcy50aW1lc3RhbXBUb01hcmtlcihtYXJrZXIudmFsdWVPZigpIC0gcGFydHMudGltZVpvbmVPZmZzZXQgKiA2MCAqIDEwMDApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yY2VkVHpvID0gcGFydHMudGltZVpvbmVPZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHsgbWFya2VyLCBpc1RpbWVVbnNwZWNpZmllZDogcGFydHMuaXNUaW1lVW5zcGVjaWZpZWQsIGZvcmNlZFR6byB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBBY2Nlc3NvcnNcclxuICAgICAgICBnZXRZZWFyKG1hcmtlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJZZWFyKG1hcmtlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGdldE1vbnRoKG1hcmtlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJNb250aChtYXJrZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBnZXREYXkobWFya2VyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNhbGVuZGFyU3lzdGVtLmdldE1hcmtlckRheShtYXJrZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBBZGRpbmcgLyBTdWJ0cmFjdGluZ1xyXG4gICAgICAgIGFkZChtYXJrZXIsIGR1cikge1xyXG4gICAgICAgICAgICBsZXQgYSA9IHRoaXMuY2FsZW5kYXJTeXN0ZW0ubWFya2VyVG9BcnJheShtYXJrZXIpO1xyXG4gICAgICAgICAgICBhWzBdICs9IGR1ci55ZWFycztcclxuICAgICAgICAgICAgYVsxXSArPSBkdXIubW9udGhzO1xyXG4gICAgICAgICAgICBhWzJdICs9IGR1ci5kYXlzO1xyXG4gICAgICAgICAgICBhWzZdICs9IGR1ci5taWxsaXNlY29uZHM7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNhbGVuZGFyU3lzdGVtLmFycmF5VG9NYXJrZXIoYSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN1YnRyYWN0KG1hcmtlciwgZHVyKSB7XHJcbiAgICAgICAgICAgIGxldCBhID0gdGhpcy5jYWxlbmRhclN5c3RlbS5tYXJrZXJUb0FycmF5KG1hcmtlcik7XHJcbiAgICAgICAgICAgIGFbMF0gLT0gZHVyLnllYXJzO1xyXG4gICAgICAgICAgICBhWzFdIC09IGR1ci5tb250aHM7XHJcbiAgICAgICAgICAgIGFbMl0gLT0gZHVyLmRheXM7XHJcbiAgICAgICAgICAgIGFbNl0gLT0gZHVyLm1pbGxpc2Vjb25kcztcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2FsZW5kYXJTeXN0ZW0uYXJyYXlUb01hcmtlcihhKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYWRkWWVhcnMobWFya2VyLCBuKSB7XHJcbiAgICAgICAgICAgIGxldCBhID0gdGhpcy5jYWxlbmRhclN5c3RlbS5tYXJrZXJUb0FycmF5KG1hcmtlcik7XHJcbiAgICAgICAgICAgIGFbMF0gKz0gbjtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2FsZW5kYXJTeXN0ZW0uYXJyYXlUb01hcmtlcihhKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYWRkTW9udGhzKG1hcmtlciwgbikge1xyXG4gICAgICAgICAgICBsZXQgYSA9IHRoaXMuY2FsZW5kYXJTeXN0ZW0ubWFya2VyVG9BcnJheShtYXJrZXIpO1xyXG4gICAgICAgICAgICBhWzFdICs9IG47XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNhbGVuZGFyU3lzdGVtLmFycmF5VG9NYXJrZXIoYSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIERpZmZpbmcgV2hvbGUgVW5pdHNcclxuICAgICAgICBkaWZmV2hvbGVZZWFycyhtMCwgbTEpIHtcclxuICAgICAgICAgICAgbGV0IHsgY2FsZW5kYXJTeXN0ZW0gfSA9IHRoaXM7XHJcbiAgICAgICAgICAgIGlmICh0aW1lQXNNcyhtMCkgPT09IHRpbWVBc01zKG0xKSAmJlxyXG4gICAgICAgICAgICAgICAgY2FsZW5kYXJTeXN0ZW0uZ2V0TWFya2VyRGF5KG0wKSA9PT0gY2FsZW5kYXJTeXN0ZW0uZ2V0TWFya2VyRGF5KG0xKSAmJlxyXG4gICAgICAgICAgICAgICAgY2FsZW5kYXJTeXN0ZW0uZ2V0TWFya2VyTW9udGgobTApID09PSBjYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJNb250aChtMSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJZZWFyKG0xKSAtIGNhbGVuZGFyU3lzdGVtLmdldE1hcmtlclllYXIobTApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkaWZmV2hvbGVNb250aHMobTAsIG0xKSB7XHJcbiAgICAgICAgICAgIGxldCB7IGNhbGVuZGFyU3lzdGVtIH0gPSB0aGlzO1xyXG4gICAgICAgICAgICBpZiAodGltZUFzTXMobTApID09PSB0aW1lQXNNcyhtMSkgJiZcclxuICAgICAgICAgICAgICAgIGNhbGVuZGFyU3lzdGVtLmdldE1hcmtlckRheShtMCkgPT09IGNhbGVuZGFyU3lzdGVtLmdldE1hcmtlckRheShtMSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAoY2FsZW5kYXJTeXN0ZW0uZ2V0TWFya2VyTW9udGgobTEpIC0gY2FsZW5kYXJTeXN0ZW0uZ2V0TWFya2VyTW9udGgobTApKSArXHJcbiAgICAgICAgICAgICAgICAgICAgKGNhbGVuZGFyU3lzdGVtLmdldE1hcmtlclllYXIobTEpIC0gY2FsZW5kYXJTeXN0ZW0uZ2V0TWFya2VyWWVhcihtMCkpICogMTI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFJhbmdlIC8gRHVyYXRpb25cclxuICAgICAgICBncmVhdGVzdFdob2xlVW5pdChtMCwgbTEpIHtcclxuICAgICAgICAgICAgbGV0IG4gPSB0aGlzLmRpZmZXaG9sZVllYXJzKG0wLCBtMSk7XHJcbiAgICAgICAgICAgIGlmIChuICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4geyB1bml0OiAneWVhcicsIHZhbHVlOiBuIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbiA9IHRoaXMuZGlmZldob2xlTW9udGhzKG0wLCBtMSk7XHJcbiAgICAgICAgICAgIGlmIChuICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4geyB1bml0OiAnbW9udGgnLCB2YWx1ZTogbiB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG4gPSBkaWZmV2hvbGVXZWVrcyhtMCwgbTEpO1xyXG4gICAgICAgICAgICBpZiAobiAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdW5pdDogJ3dlZWsnLCB2YWx1ZTogbiB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG4gPSBkaWZmV2hvbGVEYXlzKG0wLCBtMSk7XHJcbiAgICAgICAgICAgIGlmIChuICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4geyB1bml0OiAnZGF5JywgdmFsdWU6IG4gfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBuID0gZGlmZkhvdXJzKG0wLCBtMSk7XHJcbiAgICAgICAgICAgIGlmIChpc0ludChuKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdW5pdDogJ2hvdXInLCB2YWx1ZTogbiB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG4gPSBkaWZmTWludXRlcyhtMCwgbTEpO1xyXG4gICAgICAgICAgICBpZiAoaXNJbnQobikpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7IHVuaXQ6ICdtaW51dGUnLCB2YWx1ZTogbiB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG4gPSBkaWZmU2Vjb25kcyhtMCwgbTEpO1xyXG4gICAgICAgICAgICBpZiAoaXNJbnQobikpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7IHVuaXQ6ICdzZWNvbmQnLCB2YWx1ZTogbiB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB7IHVuaXQ6ICdtaWxsaXNlY29uZCcsIHZhbHVlOiBtMS52YWx1ZU9mKCkgLSBtMC52YWx1ZU9mKCkgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY291bnREdXJhdGlvbnNCZXR3ZWVuKG0wLCBtMSwgZCkge1xyXG4gICAgICAgICAgICAvLyBUT0RPOiBjYW4gdXNlIGdyZWF0ZXN0V2hvbGVVbml0XHJcbiAgICAgICAgICAgIGxldCBkaWZmO1xyXG4gICAgICAgICAgICBpZiAoZC55ZWFycykge1xyXG4gICAgICAgICAgICAgICAgZGlmZiA9IHRoaXMuZGlmZldob2xlWWVhcnMobTAsIG0xKTtcclxuICAgICAgICAgICAgICAgIGlmIChkaWZmICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRpZmYgLyBhc1JvdWdoWWVhcnMoZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGQubW9udGhzKSB7XHJcbiAgICAgICAgICAgICAgICBkaWZmID0gdGhpcy5kaWZmV2hvbGVNb250aHMobTAsIG0xKTtcclxuICAgICAgICAgICAgICAgIGlmIChkaWZmICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRpZmYgLyBhc1JvdWdoTW9udGhzKGQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChkLmRheXMpIHtcclxuICAgICAgICAgICAgICAgIGRpZmYgPSBkaWZmV2hvbGVEYXlzKG0wLCBtMSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGlmZiAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkaWZmIC8gYXNSb3VnaERheXMoZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIChtMS52YWx1ZU9mKCkgLSBtMC52YWx1ZU9mKCkpIC8gYXNSb3VnaE1zKGQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBTdGFydC1PZlxyXG4gICAgICAgIC8vIHRoZXNlIERPTidUIHJldHVybiB6b25lZC1kYXRlcy4gb25seSBVVEMgc3RhcnQtb2YgZGF0ZXNcclxuICAgICAgICBzdGFydE9mKG0sIHVuaXQpIHtcclxuICAgICAgICAgICAgaWYgKHVuaXQgPT09ICd5ZWFyJykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnRPZlllYXIobSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHVuaXQgPT09ICdtb250aCcpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YXJ0T2ZNb250aChtKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodW5pdCA9PT0gJ3dlZWsnKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zdGFydE9mV2VlayhtKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodW5pdCA9PT0gJ2RheScpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzdGFydE9mRGF5KG0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh1bml0ID09PSAnaG91cicpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzdGFydE9mSG91cihtKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodW5pdCA9PT0gJ21pbnV0ZScpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzdGFydE9mTWludXRlKG0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh1bml0ID09PSAnc2Vjb25kJykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXJ0T2ZTZWNvbmQobSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN0YXJ0T2ZZZWFyKG0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2FsZW5kYXJTeXN0ZW0uYXJyYXlUb01hcmtlcihbXHJcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGVuZGFyU3lzdGVtLmdldE1hcmtlclllYXIobSksXHJcbiAgICAgICAgICAgIF0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzdGFydE9mTW9udGgobSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jYWxlbmRhclN5c3RlbS5hcnJheVRvTWFya2VyKFtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2FsZW5kYXJTeXN0ZW0uZ2V0TWFya2VyWWVhcihtKSxcclxuICAgICAgICAgICAgICAgIHRoaXMuY2FsZW5kYXJTeXN0ZW0uZ2V0TWFya2VyTW9udGgobSksXHJcbiAgICAgICAgICAgIF0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzdGFydE9mV2VlayhtKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNhbGVuZGFyU3lzdGVtLmFycmF5VG9NYXJrZXIoW1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJZZWFyKG0pLFxyXG4gICAgICAgICAgICAgICAgdGhpcy5jYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJNb250aChtKSxcclxuICAgICAgICAgICAgICAgIG0uZ2V0VVRDRGF0ZSgpIC0gKChtLmdldFVUQ0RheSgpIC0gdGhpcy53ZWVrRG93ICsgNykgJSA3KSxcclxuICAgICAgICAgICAgXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFdlZWsgTnVtYmVyXHJcbiAgICAgICAgY29tcHV0ZVdlZWtOdW1iZXIobWFya2VyKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLndlZWtOdW1iZXJGdW5jKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy53ZWVrTnVtYmVyRnVuYyh0aGlzLnRvRGF0ZShtYXJrZXIpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gd2Vla09mWWVhcihtYXJrZXIsIHRoaXMud2Vla0RvdywgdGhpcy53ZWVrRG95KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVE9ETzogY2hva2Ugb24gdGltZVpvbmVOYW1lOiBsb25nXHJcbiAgICAgICAgZm9ybWF0KG1hcmtlciwgZm9ybWF0dGVyLCBkYXRlT3B0aW9ucyA9IHt9KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmb3JtYXR0ZXIuZm9ybWF0KHtcclxuICAgICAgICAgICAgICAgIG1hcmtlcixcclxuICAgICAgICAgICAgICAgIHRpbWVab25lT2Zmc2V0OiBkYXRlT3B0aW9ucy5mb3JjZWRUem8gIT0gbnVsbCA/XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0ZU9wdGlvbnMuZm9yY2VkVHpvIDpcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9mZnNldEZvck1hcmtlcihtYXJrZXIpLFxyXG4gICAgICAgICAgICB9LCB0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9ybWF0UmFuZ2Uoc3RhcnQsIGVuZCwgZm9ybWF0dGVyLCBkYXRlT3B0aW9ucyA9IHt9KSB7XHJcbiAgICAgICAgICAgIGlmIChkYXRlT3B0aW9ucy5pc0VuZEV4Y2x1c2l2ZSkge1xyXG4gICAgICAgICAgICAgICAgZW5kID0gYWRkTXMoZW5kLCAtMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdHRlci5mb3JtYXRSYW5nZSh7XHJcbiAgICAgICAgICAgICAgICBtYXJrZXI6IHN0YXJ0LFxyXG4gICAgICAgICAgICAgICAgdGltZVpvbmVPZmZzZXQ6IGRhdGVPcHRpb25zLmZvcmNlZFN0YXJ0VHpvICE9IG51bGwgP1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGVPcHRpb25zLmZvcmNlZFN0YXJ0VHpvIDpcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9mZnNldEZvck1hcmtlcihzdGFydCksXHJcbiAgICAgICAgICAgIH0sIHtcclxuICAgICAgICAgICAgICAgIG1hcmtlcjogZW5kLFxyXG4gICAgICAgICAgICAgICAgdGltZVpvbmVPZmZzZXQ6IGRhdGVPcHRpb25zLmZvcmNlZEVuZFR6byAhPSBudWxsID9cclxuICAgICAgICAgICAgICAgICAgICBkYXRlT3B0aW9ucy5mb3JjZWRFbmRUem8gOlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub2Zmc2V0Rm9yTWFya2VyKGVuZCksXHJcbiAgICAgICAgICAgIH0sIHRoaXMsIGRhdGVPcHRpb25zLmRlZmF1bHRTZXBhcmF0b3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKlxyXG4gICAgICAgIERVTUI6IHRoZSBvbWl0VGltZSBhcmcgaXMgZHVtYi4gaWYgd2Ugb21pdCB0aGUgdGltZSwgd2Ugd2FudCB0byBvbWl0IHRoZSB0aW1lem9uZSBvZmZzZXQuIGFuZCBpZiB3ZSBkbyB0aGF0LFxyXG4gICAgICAgIG1pZ2h0IGFzIHdlbGwgdXNlIGJ1aWxkSXNvU3RyaW5nIG9yIHNvbWUgb3RoZXIgdXRpbCBkaXJlY3RseVxyXG4gICAgICAgICovXHJcbiAgICAgICAgZm9ybWF0SXNvKG1hcmtlciwgZXh0cmFPcHRpb25zID0ge30pIHtcclxuICAgICAgICAgICAgbGV0IHRpbWVab25lT2Zmc2V0ID0gbnVsbDtcclxuICAgICAgICAgICAgaWYgKCFleHRyYU9wdGlvbnMub21pdFRpbWVab25lT2Zmc2V0KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXh0cmFPcHRpb25zLmZvcmNlZFR6byAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGltZVpvbmVPZmZzZXQgPSBleHRyYU9wdGlvbnMuZm9yY2VkVHpvO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGltZVpvbmVPZmZzZXQgPSB0aGlzLm9mZnNldEZvck1hcmtlcihtYXJrZXIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBidWlsZElzb1N0cmluZyhtYXJrZXIsIHRpbWVab25lT2Zmc2V0LCBleHRyYU9wdGlvbnMub21pdFRpbWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBUaW1lWm9uZVxyXG4gICAgICAgIHRpbWVzdGFtcFRvTWFya2VyKG1zKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnRpbWVab25lID09PSAnbG9jYWwnKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJyYXlUb1V0Y0RhdGUoZGF0ZVRvTG9jYWxBcnJheShuZXcgRGF0ZShtcykpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy50aW1lWm9uZSA9PT0gJ1VUQycgfHwgIXRoaXMubmFtZWRUaW1lWm9uZUltcGwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZShtcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGFycmF5VG9VdGNEYXRlKHRoaXMubmFtZWRUaW1lWm9uZUltcGwudGltZXN0YW1wVG9BcnJheShtcykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBvZmZzZXRGb3JNYXJrZXIobSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy50aW1lWm9uZSA9PT0gJ2xvY2FsJykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIC1hcnJheVRvTG9jYWxEYXRlKGRhdGVUb1V0Y0FycmF5KG0pKS5nZXRUaW1lem9uZU9mZnNldCgpOyAvLyBjb252ZXJ0IFwiaW52ZXJzZVwiIG9mZnNldCB0byBcIm5vcm1hbFwiIG9mZnNldFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnRpbWVab25lID09PSAnVVRDJykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMubmFtZWRUaW1lWm9uZUltcGwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm5hbWVkVGltZVpvbmVJbXBsLm9mZnNldEZvckFycmF5KGRhdGVUb1V0Y0FycmF5KG0pKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQ29udmVyc2lvblxyXG4gICAgICAgIHRvRGF0ZShtLCBmb3JjZWRUem8pIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMudGltZVpvbmUgPT09ICdsb2NhbCcpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhcnJheVRvTG9jYWxEYXRlKGRhdGVUb1V0Y0FycmF5KG0pKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy50aW1lWm9uZSA9PT0gJ1VUQycpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZShtLnZhbHVlT2YoKSk7IC8vIG1ha2Ugc3VyZSBpdCdzIGEgY29weVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5uYW1lZFRpbWVab25lSW1wbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKG0udmFsdWVPZigpIC0gKGZvcmNlZFR6byB8fCAwKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKG0udmFsdWVPZigpIC1cclxuICAgICAgICAgICAgICAgIHRoaXMubmFtZWRUaW1lWm9uZUltcGwub2Zmc2V0Rm9yQXJyYXkoZGF0ZVRvVXRjQXJyYXkobSkpICogMTAwMCAqIDYwKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY2xhc3MgTmFtZWRUaW1lWm9uZUltcGwge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yKHRpbWVab25lTmFtZSkge1xyXG4gICAgICAgICAgICB0aGlzLnRpbWVab25lTmFtZSA9IHRpbWVab25lTmFtZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY2xhc3MgU2VnSGllcmFyY2h5IHtcclxuICAgICAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICAgICAgLy8gc2V0dGluZ3NcclxuICAgICAgICAgICAgdGhpcy5zdHJpY3RPcmRlciA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLmFsbG93UmVzbGljaW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMubWF4Q29vcmQgPSAtMTsgLy8gLTEgbWVhbnMgbm8gbWF4XHJcbiAgICAgICAgICAgIHRoaXMubWF4U3RhY2tDbnQgPSAtMTsgLy8gLTEgbWVhbnMgbm8gbWF4XHJcbiAgICAgICAgICAgIHRoaXMubGV2ZWxDb29yZHMgPSBbXTsgLy8gb3JkZXJlZFxyXG4gICAgICAgICAgICB0aGlzLmVudHJpZXNCeUxldmVsID0gW107IC8vIHBhcmFsbGVsIHdpdGggbGV2ZWxDb29yZHNcclxuICAgICAgICAgICAgdGhpcy5zdGFja0NudHMgPSB7fTsgLy8gVE9ETzogdXNlIGJldHRlciB0ZWNobmlxdWUhP1xyXG4gICAgICAgIH1cclxuICAgICAgICBhZGRTZWdzKGlucHV0cykge1xyXG4gICAgICAgICAgICBsZXQgaGlkZGVuRW50cmllcyA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpbnB1dCBvZiBpbnB1dHMpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaW5zZXJ0RW50cnkoaW5wdXQsIGhpZGRlbkVudHJpZXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBoaWRkZW5FbnRyaWVzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpbnNlcnRFbnRyeShlbnRyeSwgaGlkZGVuRW50cmllcykge1xyXG4gICAgICAgICAgICBsZXQgaW5zZXJ0aW9uID0gdGhpcy5maW5kSW5zZXJ0aW9uKGVudHJ5KTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaXNJbnNlcnRpb25WYWxpZChpbnNlcnRpb24sIGVudHJ5KSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbnNlcnRFbnRyeUF0KGVudHJ5LCBpbnNlcnRpb24pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlSW52YWxpZEluc2VydGlvbihpbnNlcnRpb24sIGVudHJ5LCBoaWRkZW5FbnRyaWVzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaXNJbnNlcnRpb25WYWxpZChpbnNlcnRpb24sIGVudHJ5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5tYXhDb29yZCA9PT0gLTEgfHwgaW5zZXJ0aW9uLmxldmVsQ29vcmQgKyBlbnRyeS50aGlja25lc3MgPD0gdGhpcy5tYXhDb29yZCkgJiZcclxuICAgICAgICAgICAgICAgICh0aGlzLm1heFN0YWNrQ250ID09PSAtMSB8fCBpbnNlcnRpb24uc3RhY2tDbnQgPCB0aGlzLm1heFN0YWNrQ250KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gcmV0dXJucyBudW1iZXIgb2YgbmV3IGVudHJpZXMgaW5zZXJ0ZWRcclxuICAgICAgICBoYW5kbGVJbnZhbGlkSW5zZXJ0aW9uKGluc2VydGlvbiwgZW50cnksIGhpZGRlbkVudHJpZXMpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuYWxsb3dSZXNsaWNpbmcgJiYgaW5zZXJ0aW9uLnRvdWNoaW5nRW50cnkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNwbGl0RW50cnkoZW50cnksIGluc2VydGlvbi50b3VjaGluZ0VudHJ5LCBoaWRkZW5FbnRyaWVzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBoaWRkZW5FbnRyaWVzLnB1c2goZW50cnkpO1xyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgc3BsaXRFbnRyeShlbnRyeSwgYmFycmllciwgaGlkZGVuRW50cmllcykge1xyXG4gICAgICAgICAgICBsZXQgcGFydENudCA9IDA7XHJcbiAgICAgICAgICAgIGxldCBzcGxpdEhpZGRlbkVudHJpZXMgPSBbXTtcclxuICAgICAgICAgICAgbGV0IGVudHJ5U3BhbiA9IGVudHJ5LnNwYW47XHJcbiAgICAgICAgICAgIGxldCBiYXJyaWVyU3BhbiA9IGJhcnJpZXIuc3BhbjtcclxuICAgICAgICAgICAgaWYgKGVudHJ5U3Bhbi5zdGFydCA8IGJhcnJpZXJTcGFuLnN0YXJ0KSB7XHJcbiAgICAgICAgICAgICAgICBwYXJ0Q250ICs9IHRoaXMuaW5zZXJ0RW50cnkoe1xyXG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiBlbnRyeS5pbmRleCxcclxuICAgICAgICAgICAgICAgICAgICB0aGlja25lc3M6IGVudHJ5LnRoaWNrbmVzcyxcclxuICAgICAgICAgICAgICAgICAgICBzcGFuOiB7IHN0YXJ0OiBlbnRyeVNwYW4uc3RhcnQsIGVuZDogYmFycmllclNwYW4uc3RhcnQgfSxcclxuICAgICAgICAgICAgICAgIH0sIHNwbGl0SGlkZGVuRW50cmllcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGVudHJ5U3Bhbi5lbmQgPiBiYXJyaWVyU3Bhbi5lbmQpIHtcclxuICAgICAgICAgICAgICAgIHBhcnRDbnQgKz0gdGhpcy5pbnNlcnRFbnRyeSh7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGVudHJ5LmluZGV4LFxyXG4gICAgICAgICAgICAgICAgICAgIHRoaWNrbmVzczogZW50cnkudGhpY2tuZXNzLFxyXG4gICAgICAgICAgICAgICAgICAgIHNwYW46IHsgc3RhcnQ6IGJhcnJpZXJTcGFuLmVuZCwgZW5kOiBlbnRyeVNwYW4uZW5kIH0sXHJcbiAgICAgICAgICAgICAgICB9LCBzcGxpdEhpZGRlbkVudHJpZXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChwYXJ0Q250KSB7XHJcbiAgICAgICAgICAgICAgICBoaWRkZW5FbnRyaWVzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiBlbnRyeS5pbmRleCxcclxuICAgICAgICAgICAgICAgICAgICB0aGlja25lc3M6IGVudHJ5LnRoaWNrbmVzcyxcclxuICAgICAgICAgICAgICAgICAgICBzcGFuOiBpbnRlcnNlY3RTcGFucyhiYXJyaWVyU3BhbiwgZW50cnlTcGFuKSwgLy8gZ3VhcmFudGVlZCB0byBpbnRlcnNlY3RcclxuICAgICAgICAgICAgICAgIH0sIC4uLnNwbGl0SGlkZGVuRW50cmllcyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFydENudDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBoaWRkZW5FbnRyaWVzLnB1c2goZW50cnkpO1xyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaW5zZXJ0RW50cnlBdChlbnRyeSwgaW5zZXJ0aW9uKSB7XHJcbiAgICAgICAgICAgIGxldCB7IGVudHJpZXNCeUxldmVsLCBsZXZlbENvb3JkcyB9ID0gdGhpcztcclxuICAgICAgICAgICAgaWYgKGluc2VydGlvbi5sYXRlcmFsID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgLy8gY3JlYXRlIGEgbmV3IGxldmVsXHJcbiAgICAgICAgICAgICAgICBpbnNlcnRBdChsZXZlbENvb3JkcywgaW5zZXJ0aW9uLmxldmVsLCBpbnNlcnRpb24ubGV2ZWxDb29yZCk7XHJcbiAgICAgICAgICAgICAgICBpbnNlcnRBdChlbnRyaWVzQnlMZXZlbCwgaW5zZXJ0aW9uLmxldmVsLCBbZW50cnldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIGluc2VydCBpbnRvIGV4aXN0aW5nIGxldmVsXHJcbiAgICAgICAgICAgICAgICBpbnNlcnRBdChlbnRyaWVzQnlMZXZlbFtpbnNlcnRpb24ubGV2ZWxdLCBpbnNlcnRpb24ubGF0ZXJhbCwgZW50cnkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuc3RhY2tDbnRzW2J1aWxkRW50cnlLZXkoZW50cnkpXSA9IGluc2VydGlvbi5zdGFja0NudDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZmluZEluc2VydGlvbihuZXdFbnRyeSkge1xyXG4gICAgICAgICAgICBsZXQgeyBsZXZlbENvb3JkcywgZW50cmllc0J5TGV2ZWwsIHN0cmljdE9yZGVyLCBzdGFja0NudHMgfSA9IHRoaXM7XHJcbiAgICAgICAgICAgIGxldCBsZXZlbENudCA9IGxldmVsQ29vcmRzLmxlbmd0aDtcclxuICAgICAgICAgICAgbGV0IGNhbmRpZGF0ZUNvb3JkID0gMDtcclxuICAgICAgICAgICAgbGV0IHRvdWNoaW5nTGV2ZWwgPSAtMTtcclxuICAgICAgICAgICAgbGV0IHRvdWNoaW5nTGF0ZXJhbCA9IC0xO1xyXG4gICAgICAgICAgICBsZXQgdG91Y2hpbmdFbnRyeSA9IG51bGw7XHJcbiAgICAgICAgICAgIGxldCBzdGFja0NudCA9IDA7XHJcbiAgICAgICAgICAgIGZvciAobGV0IHRyYWNraW5nTGV2ZWwgPSAwOyB0cmFja2luZ0xldmVsIDwgbGV2ZWxDbnQ7IHRyYWNraW5nTGV2ZWwgKz0gMSkge1xyXG4gICAgICAgICAgICAgICAgbGV0IHRyYWNraW5nQ29vcmQgPSBsZXZlbENvb3Jkc1t0cmFja2luZ0xldmVsXTtcclxuICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBjdXJyZW50IGxldmVsIGlzIHBhc3QgdGhlIHBsYWNlZCBlbnRyeSwgd2UgaGF2ZSBmb3VuZCBhIGdvb2QgZW1wdHkgc3BhY2UgYW5kIGNhbiBzdG9wLlxyXG4gICAgICAgICAgICAgICAgLy8gaWYgc3RyaWN0T3JkZXIsIGtlZXAgZmluZGluZyBtb3JlIGxhdGVyYWwgaW50ZXJzZWN0aW9ucy5cclxuICAgICAgICAgICAgICAgIGlmICghc3RyaWN0T3JkZXIgJiYgdHJhY2tpbmdDb29yZCA+PSBjYW5kaWRhdGVDb29yZCArIG5ld0VudHJ5LnRoaWNrbmVzcykge1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbGV0IHRyYWNraW5nRW50cmllcyA9IGVudHJpZXNCeUxldmVsW3RyYWNraW5nTGV2ZWxdO1xyXG4gICAgICAgICAgICAgICAgbGV0IHRyYWNraW5nRW50cnk7XHJcbiAgICAgICAgICAgICAgICBsZXQgc2VhcmNoUmVzID0gYmluYXJ5U2VhcmNoKHRyYWNraW5nRW50cmllcywgbmV3RW50cnkuc3Bhbi5zdGFydCwgZ2V0RW50cnlTcGFuRW5kKTsgLy8gZmluZCBmaXJzdCBlbnRyeSBhZnRlciBuZXdFbnRyeSdzIGVuZFxyXG4gICAgICAgICAgICAgICAgbGV0IGxhdGVyYWxJbmRleCA9IHNlYXJjaFJlc1swXSArIHNlYXJjaFJlc1sxXTsgLy8gaWYgZXhhY3QgbWF0Y2ggKHdoaWNoIGRvZXNuJ3QgY29sbGlkZSksIGdvIHRvIG5leHQgb25lXHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoIC8vIGxvb3AgdGhyb3VnaCBlbnRyaWVzIHRoYXQgaG9yaXpvbnRhbGx5IGludGVyc2VjdFxyXG4gICAgICAgICAgICAgICAgKHRyYWNraW5nRW50cnkgPSB0cmFja2luZ0VudHJpZXNbbGF0ZXJhbEluZGV4XSkgJiYgLy8gYnV0IG5vdCBwYXN0IHRoZSB3aG9sZSBlbnRyeSBsaXN0XHJcbiAgICAgICAgICAgICAgICAgICAgdHJhY2tpbmdFbnRyeS5zcGFuLnN0YXJ0IDwgbmV3RW50cnkuc3Bhbi5lbmQgLy8gYW5kIG5vdCBlbnRpcmVseSBwYXN0IG5ld0VudHJ5XHJcbiAgICAgICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgdHJhY2tpbmdFbnRyeUJvdHRvbSA9IHRyYWNraW5nQ29vcmQgKyB0cmFja2luZ0VudHJ5LnRoaWNrbmVzcztcclxuICAgICAgICAgICAgICAgICAgICAvLyBpbnRlcnNlY3RzIGludG8gdGhlIHRvcCBvZiB0aGUgY2FuZGlkYXRlP1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0cmFja2luZ0VudHJ5Qm90dG9tID4gY2FuZGlkYXRlQ29vcmQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FuZGlkYXRlQ29vcmQgPSB0cmFja2luZ0VudHJ5Qm90dG9tO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3VjaGluZ0VudHJ5ID0gdHJhY2tpbmdFbnRyeTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdG91Y2hpbmdMZXZlbCA9IHRyYWNraW5nTGV2ZWw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvdWNoaW5nTGF0ZXJhbCA9IGxhdGVyYWxJbmRleDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYnV0dHMgdXAgYWdhaW5zdCB0b3Agb2YgY2FuZGlkYXRlPyAod2lsbCBoYXBwZW4gaWYganVzdCBpbnRlcnNlY3RlZCBhcyB3ZWxsKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0cmFja2luZ0VudHJ5Qm90dG9tID09PSBjYW5kaWRhdGVDb29yZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhY2N1bXVsYXRlIHRoZSBoaWdoZXN0IHBvc3NpYmxlIHN0YWNrQ250IG9mIHRoZSB0cmFja2luZ0VudHJpZXMgdGhhdCBidXR0IHVwXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrQ250ID0gTWF0aC5tYXgoc3RhY2tDbnQsIHN0YWNrQ250c1tidWlsZEVudHJ5S2V5KHRyYWNraW5nRW50cnkpXSArIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBsYXRlcmFsSW5kZXggKz0gMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyB0aGUgZGVzdGluYXRpb24gbGV2ZWwgd2lsbCBiZSBhZnRlciB0b3VjaGluZ0VudHJ5J3MgbGV2ZWwuIGZpbmQgaXRcclxuICAgICAgICAgICAgbGV0IGRlc3RMZXZlbCA9IDA7XHJcbiAgICAgICAgICAgIGlmICh0b3VjaGluZ0VudHJ5KSB7XHJcbiAgICAgICAgICAgICAgICBkZXN0TGV2ZWwgPSB0b3VjaGluZ0xldmVsICsgMTtcclxuICAgICAgICAgICAgICAgIHdoaWxlIChkZXN0TGV2ZWwgPCBsZXZlbENudCAmJiBsZXZlbENvb3Jkc1tkZXN0TGV2ZWxdIDwgY2FuZGlkYXRlQ29vcmQpIHtcclxuICAgICAgICAgICAgICAgICAgICBkZXN0TGV2ZWwgKz0gMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBpZiBhZGRpbmcgdG8gYW4gZXhpc3RpbmcgbGV2ZWwsIGZpbmQgd2hlcmUgdG8gaW5zZXJ0XHJcbiAgICAgICAgICAgIGxldCBkZXN0TGF0ZXJhbCA9IC0xO1xyXG4gICAgICAgICAgICBpZiAoZGVzdExldmVsIDwgbGV2ZWxDbnQgJiYgbGV2ZWxDb29yZHNbZGVzdExldmVsXSA9PT0gY2FuZGlkYXRlQ29vcmQpIHtcclxuICAgICAgICAgICAgICAgIGRlc3RMYXRlcmFsID0gYmluYXJ5U2VhcmNoKGVudHJpZXNCeUxldmVsW2Rlc3RMZXZlbF0sIG5ld0VudHJ5LnNwYW4uZW5kLCBnZXRFbnRyeVNwYW5FbmQpWzBdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICB0b3VjaGluZ0xldmVsLFxyXG4gICAgICAgICAgICAgICAgdG91Y2hpbmdMYXRlcmFsLFxyXG4gICAgICAgICAgICAgICAgdG91Y2hpbmdFbnRyeSxcclxuICAgICAgICAgICAgICAgIHN0YWNrQ250LFxyXG4gICAgICAgICAgICAgICAgbGV2ZWxDb29yZDogY2FuZGlkYXRlQ29vcmQsXHJcbiAgICAgICAgICAgICAgICBsZXZlbDogZGVzdExldmVsLFxyXG4gICAgICAgICAgICAgICAgbGF0ZXJhbDogZGVzdExhdGVyYWwsXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHNvcnRlZCBieSBsZXZlbENvb3JkIChsb3dlc3QgdG8gaGlnaGVzdClcclxuICAgICAgICB0b1JlY3RzKCkge1xyXG4gICAgICAgICAgICBsZXQgeyBlbnRyaWVzQnlMZXZlbCwgbGV2ZWxDb29yZHMgfSA9IHRoaXM7XHJcbiAgICAgICAgICAgIGxldCBsZXZlbENudCA9IGVudHJpZXNCeUxldmVsLmxlbmd0aDtcclxuICAgICAgICAgICAgbGV0IHJlY3RzID0gW107XHJcbiAgICAgICAgICAgIGZvciAobGV0IGxldmVsID0gMDsgbGV2ZWwgPCBsZXZlbENudDsgbGV2ZWwgKz0gMSkge1xyXG4gICAgICAgICAgICAgICAgbGV0IGVudHJpZXMgPSBlbnRyaWVzQnlMZXZlbFtsZXZlbF07XHJcbiAgICAgICAgICAgICAgICBsZXQgbGV2ZWxDb29yZCA9IGxldmVsQ29vcmRzW2xldmVsXTtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGVudHJ5IG9mIGVudHJpZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICByZWN0cy5wdXNoKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZW50cnkpLCB7IGxldmVsQ29vcmQgfSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZWN0cztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBnZXRFbnRyeVNwYW5FbmQoZW50cnkpIHtcclxuICAgICAgICByZXR1cm4gZW50cnkuc3Bhbi5lbmQ7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBidWlsZEVudHJ5S2V5KGVudHJ5KSB7XHJcbiAgICAgICAgcmV0dXJuIGVudHJ5LmluZGV4ICsgJzonICsgZW50cnkuc3Bhbi5zdGFydDtcclxuICAgIH1cclxuICAgIC8vIHJldHVybnMgZ3JvdXBzIHdpdGggZW50cmllcyBzb3J0ZWQgYnkgaW5wdXQgb3JkZXJcclxuICAgIGZ1bmN0aW9uIGdyb3VwSW50ZXJzZWN0aW5nRW50cmllcyhlbnRyaWVzKSB7XHJcbiAgICAgICAgbGV0IG1lcmdlcyA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IGVudHJ5IG9mIGVudHJpZXMpIHtcclxuICAgICAgICAgICAgbGV0IGZpbHRlcmVkTWVyZ2VzID0gW107XHJcbiAgICAgICAgICAgIGxldCBodW5ncnlNZXJnZSA9IHtcclxuICAgICAgICAgICAgICAgIHNwYW46IGVudHJ5LnNwYW4sXHJcbiAgICAgICAgICAgICAgICBlbnRyaWVzOiBbZW50cnldLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBmb3IgKGxldCBtZXJnZSBvZiBtZXJnZXMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpbnRlcnNlY3RTcGFucyhtZXJnZS5zcGFuLCBodW5ncnlNZXJnZS5zcGFuKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGh1bmdyeU1lcmdlID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbnRyaWVzOiBtZXJnZS5lbnRyaWVzLmNvbmNhdChodW5ncnlNZXJnZS5lbnRyaWVzKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3Bhbjogam9pblNwYW5zKG1lcmdlLnNwYW4sIGh1bmdyeU1lcmdlLnNwYW4pLFxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXJlZE1lcmdlcy5wdXNoKG1lcmdlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmaWx0ZXJlZE1lcmdlcy5wdXNoKGh1bmdyeU1lcmdlKTtcclxuICAgICAgICAgICAgbWVyZ2VzID0gZmlsdGVyZWRNZXJnZXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBtZXJnZXM7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBqb2luU3BhbnMoc3BhbjAsIHNwYW4xKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgc3RhcnQ6IE1hdGgubWluKHNwYW4wLnN0YXJ0LCBzcGFuMS5zdGFydCksXHJcbiAgICAgICAgICAgIGVuZDogTWF0aC5tYXgoc3BhbjAuZW5kLCBzcGFuMS5lbmQpLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBpbnRlcnNlY3RTcGFucyhzcGFuMCwgc3BhbjEpIHtcclxuICAgICAgICBsZXQgc3RhcnQgPSBNYXRoLm1heChzcGFuMC5zdGFydCwgc3BhbjEuc3RhcnQpO1xyXG4gICAgICAgIGxldCBlbmQgPSBNYXRoLm1pbihzcGFuMC5lbmQsIHNwYW4xLmVuZCk7XHJcbiAgICAgICAgaWYgKHN0YXJ0IDwgZW5kKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7IHN0YXJ0LCBlbmQgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICAvLyBnZW5lcmFsIHV0aWxcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgZnVuY3Rpb24gaW5zZXJ0QXQoYXJyLCBpbmRleCwgaXRlbSkge1xyXG4gICAgICAgIGFyci5zcGxpY2UoaW5kZXgsIDAsIGl0ZW0pO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYmluYXJ5U2VhcmNoKGEsIHNlYXJjaFZhbCwgZ2V0SXRlbVZhbCkge1xyXG4gICAgICAgIGxldCBzdGFydEluZGV4ID0gMDtcclxuICAgICAgICBsZXQgZW5kSW5kZXggPSBhLmxlbmd0aDsgLy8gZXhjbHVzaXZlXHJcbiAgICAgICAgaWYgKCFlbmRJbmRleCB8fCBzZWFyY2hWYWwgPCBnZXRJdGVtVmFsKGFbc3RhcnRJbmRleF0pKSB7IC8vIG5vIGl0ZW1zIE9SIGJlZm9yZSBmaXJzdCBpdGVtXHJcbiAgICAgICAgICAgIHJldHVybiBbMCwgMF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzZWFyY2hWYWwgPiBnZXRJdGVtVmFsKGFbZW5kSW5kZXggLSAxXSkpIHsgLy8gYWZ0ZXIgbGFzdCBpdGVtXHJcbiAgICAgICAgICAgIHJldHVybiBbZW5kSW5kZXgsIDBdO1xyXG4gICAgICAgIH1cclxuICAgICAgICB3aGlsZSAoc3RhcnRJbmRleCA8IGVuZEluZGV4KSB7XHJcbiAgICAgICAgICAgIGxldCBtaWRkbGVJbmRleCA9IE1hdGguZmxvb3Ioc3RhcnRJbmRleCArIChlbmRJbmRleCAtIHN0YXJ0SW5kZXgpIC8gMik7XHJcbiAgICAgICAgICAgIGxldCBtaWRkbGVWYWwgPSBnZXRJdGVtVmFsKGFbbWlkZGxlSW5kZXhdKTtcclxuICAgICAgICAgICAgaWYgKHNlYXJjaFZhbCA8IG1pZGRsZVZhbCkge1xyXG4gICAgICAgICAgICAgICAgZW5kSW5kZXggPSBtaWRkbGVJbmRleDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChzZWFyY2hWYWwgPiBtaWRkbGVWYWwpIHtcclxuICAgICAgICAgICAgICAgIHN0YXJ0SW5kZXggPSBtaWRkbGVJbmRleCArIDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7IC8vIGVxdWFsIVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFttaWRkbGVJbmRleCwgMV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFtzdGFydEluZGV4LCAwXTtcclxuICAgIH1cclxuXHJcbiAgICBjbGFzcyBJbnRlcmFjdGlvbiB7XHJcbiAgICAgICAgY29uc3RydWN0b3Ioc2V0dGluZ3MpIHtcclxuICAgICAgICAgICAgdGhpcy5jb21wb25lbnQgPSBzZXR0aW5ncy5jb21wb25lbnQ7XHJcbiAgICAgICAgICAgIHRoaXMuaXNIaXRDb21ib0FsbG93ZWQgPSBzZXR0aW5ncy5pc0hpdENvbWJvQWxsb3dlZCB8fCBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkZXN0cm95KCkge1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHBhcnNlSW50ZXJhY3Rpb25TZXR0aW5ncyhjb21wb25lbnQsIGlucHV0KSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgY29tcG9uZW50LFxyXG4gICAgICAgICAgICBlbDogaW5wdXQuZWwsXHJcbiAgICAgICAgICAgIHVzZUV2ZW50Q2VudGVyOiBpbnB1dC51c2VFdmVudENlbnRlciAhPSBudWxsID8gaW5wdXQudXNlRXZlbnRDZW50ZXIgOiB0cnVlLFxyXG4gICAgICAgICAgICBpc0hpdENvbWJvQWxsb3dlZDogaW5wdXQuaXNIaXRDb21ib0FsbG93ZWQgfHwgbnVsbCxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gaW50ZXJhY3Rpb25TZXR0aW5nc1RvU3RvcmUoc2V0dGluZ3MpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBbc2V0dGluZ3MuY29tcG9uZW50LnVpZF06IHNldHRpbmdzLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICAvLyBnbG9iYWwgc3RhdGVcclxuICAgIGNvbnN0IGludGVyYWN0aW9uU2V0dGluZ3NTdG9yZSA9IHt9O1xyXG5cclxuICAgIC8qXHJcbiAgICBBbiBhYnN0cmFjdGlvbiBmb3IgYSBkcmFnZ2luZyBpbnRlcmFjdGlvbiBvcmlnaW5hdGluZyBvbiBhbiBldmVudC5cclxuICAgIERvZXMgaGlnaGVyLWxldmVsIHRoaW5ncyB0aGFuIFBvaW50ZXJEcmFnZ2VyLCBzdWNoIGFzIHBvc3NpYmx5OlxyXG4gICAgLSBhIFwibWlycm9yXCIgdGhhdCBtb3ZlcyB3aXRoIHRoZSBwb2ludGVyXHJcbiAgICAtIGEgbWluaW11bSBudW1iZXIgb2YgcGl4ZWxzIG9yIG90aGVyIGNyaXRlcmlhIGZvciBhIHRydWUgZHJhZyB0byBiZWdpblxyXG5cclxuICAgIHN1YmNsYXNzZXMgbXVzdCBlbWl0OlxyXG4gICAgLSBwb2ludGVyZG93blxyXG4gICAgLSBkcmFnc3RhcnRcclxuICAgIC0gZHJhZ21vdmVcclxuICAgIC0gcG9pbnRlcnVwXHJcbiAgICAtIGRyYWdlbmRcclxuICAgICovXHJcbiAgICBjbGFzcyBFbGVtZW50RHJhZ2dpbmcge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yKGVsLCBzZWxlY3Rvcikge1xyXG4gICAgICAgICAgICB0aGlzLmVtaXR0ZXIgPSBuZXcgRW1pdHRlcigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkZXN0cm95KCkge1xyXG4gICAgICAgIH1cclxuICAgICAgICBzZXRNaXJyb3JJc1Zpc2libGUoYm9vbCkge1xyXG4gICAgICAgICAgICAvLyBvcHRpb25hbCBpZiBzdWJjbGFzcyBkb2Vzbid0IHdhbnQgdG8gc3VwcG9ydCBhIG1pcnJvclxyXG4gICAgICAgIH1cclxuICAgICAgICBzZXRNaXJyb3JOZWVkc1JldmVydChib29sKSB7XHJcbiAgICAgICAgICAgIC8vIG9wdGlvbmFsIGlmIHN1YmNsYXNzIGRvZXNuJ3Qgd2FudCB0byBzdXBwb3J0IGEgbWlycm9yXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNldEF1dG9TY3JvbGxFbmFibGVkKGJvb2wpIHtcclxuICAgICAgICAgICAgLy8gb3B0aW9uYWxcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVE9ETzogZ2V0IHJpZCBvZiB0aGlzIGluIGZhdm9yIG9mIG9wdGlvbnMgc3lzdGVtLFxyXG4gICAgLy8gdGhvIGl0J3MgcmVhbGx5IGVhc3kgdG8gYWNjZXNzIHRoaXMgZ2xvYmFsbHkgcmF0aGVyIHRoYW4gcGFzcyB0aHJ1IG9wdGlvbnMuXHJcbiAgICBjb25zdCBjb25maWcgPSB7fTtcclxuXHJcbiAgICAvKlxyXG4gICAgSW5mb3JtYXRpb24gYWJvdXQgd2hhdCB3aWxsIGhhcHBlbiB3aGVuIGFuIGV4dGVybmFsIGVsZW1lbnQgaXMgZHJhZ2dlZC1hbmQtZHJvcHBlZFxyXG4gICAgb250byBhIGNhbGVuZGFyLiBDb250YWlucyBpbmZvcm1hdGlvbiBmb3IgY3JlYXRpbmcgYW4gZXZlbnQuXHJcbiAgICAqL1xyXG4gICAgY29uc3QgRFJBR19NRVRBX1JFRklORVJTID0ge1xyXG4gICAgICAgIHN0YXJ0VGltZTogY3JlYXRlRHVyYXRpb24sXHJcbiAgICAgICAgZHVyYXRpb246IGNyZWF0ZUR1cmF0aW9uLFxyXG4gICAgICAgIGNyZWF0ZTogQm9vbGVhbixcclxuICAgICAgICBzb3VyY2VJZDogU3RyaW5nLFxyXG4gICAgfTtcclxuICAgIGZ1bmN0aW9uIHBhcnNlRHJhZ01ldGEocmF3KSB7XHJcbiAgICAgICAgbGV0IHsgcmVmaW5lZCwgZXh0cmEgfSA9IHJlZmluZVByb3BzKHJhdywgRFJBR19NRVRBX1JFRklORVJTKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBzdGFydFRpbWU6IHJlZmluZWQuc3RhcnRUaW1lIHx8IG51bGwsXHJcbiAgICAgICAgICAgIGR1cmF0aW9uOiByZWZpbmVkLmR1cmF0aW9uIHx8IG51bGwsXHJcbiAgICAgICAgICAgIGNyZWF0ZTogcmVmaW5lZC5jcmVhdGUgIT0gbnVsbCA/IHJlZmluZWQuY3JlYXRlIDogdHJ1ZSxcclxuICAgICAgICAgICAgc291cmNlSWQ6IHJlZmluZWQuc291cmNlSWQsXHJcbiAgICAgICAgICAgIGxlZnRvdmVyUHJvcHM6IGV4dHJhLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgY2xhc3MgQ2FsZW5kYXJSb290IGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XHJcbiAgICAgICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSB7XHJcbiAgICAgICAgICAgICAgICBmb3JQcmludDogZmFsc2UsXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlQmVmb3JlUHJpbnQgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKHsgZm9yUHJpbnQ6IHRydWUgfSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlQWZ0ZXJQcmludCA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoeyBmb3JQcmludDogZmFsc2UgfSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlbmRlcigpIHtcclxuICAgICAgICAgICAgbGV0IHsgcHJvcHMgfSA9IHRoaXM7XHJcbiAgICAgICAgICAgIGxldCB7IG9wdGlvbnMgfSA9IHByb3BzO1xyXG4gICAgICAgICAgICBsZXQgeyBmb3JQcmludCB9ID0gdGhpcy5zdGF0ZTtcclxuICAgICAgICAgICAgbGV0IGlzSGVpZ2h0QXV0byA9IGZvclByaW50IHx8IG9wdGlvbnMuaGVpZ2h0ID09PSAnYXV0bycgfHwgb3B0aW9ucy5jb250ZW50SGVpZ2h0ID09PSAnYXV0byc7XHJcbiAgICAgICAgICAgIGxldCBoZWlnaHQgPSAoIWlzSGVpZ2h0QXV0byAmJiBvcHRpb25zLmhlaWdodCAhPSBudWxsKSA/IG9wdGlvbnMuaGVpZ2h0IDogJyc7XHJcbiAgICAgICAgICAgIGxldCBjbGFzc05hbWVzID0gW1xyXG4gICAgICAgICAgICAgICAgJ2ZjJyxcclxuICAgICAgICAgICAgICAgIGZvclByaW50ID8gJ2ZjLW1lZGlhLXByaW50JyA6ICdmYy1tZWRpYS1zY3JlZW4nLFxyXG4gICAgICAgICAgICAgICAgYGZjLWRpcmVjdGlvbi0ke29wdGlvbnMuZGlyZWN0aW9ufWAsXHJcbiAgICAgICAgICAgICAgICBwcm9wcy50aGVtZS5nZXRDbGFzcygncm9vdCcpLFxyXG4gICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICBpZiAoIWdldENhblZHcm93V2l0aGluQ2VsbCgpKSB7XHJcbiAgICAgICAgICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLWxpcXVpZC1oYWNrJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHByb3BzLmNoaWxkcmVuKGNsYXNzTmFtZXMsIGhlaWdodCwgaXNIZWlnaHRBdXRvLCBmb3JQcmludCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xyXG4gICAgICAgICAgICBsZXQgeyBlbWl0dGVyIH0gPSB0aGlzLnByb3BzO1xyXG4gICAgICAgICAgICBlbWl0dGVyLm9uKCdfYmVmb3JlcHJpbnQnLCB0aGlzLmhhbmRsZUJlZm9yZVByaW50KTtcclxuICAgICAgICAgICAgZW1pdHRlci5vbignX2FmdGVycHJpbnQnLCB0aGlzLmhhbmRsZUFmdGVyUHJpbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcclxuICAgICAgICAgICAgbGV0IHsgZW1pdHRlciB9ID0gdGhpcy5wcm9wcztcclxuICAgICAgICAgICAgZW1pdHRlci5vZmYoJ19iZWZvcmVwcmludCcsIHRoaXMuaGFuZGxlQmVmb3JlUHJpbnQpO1xyXG4gICAgICAgICAgICBlbWl0dGVyLm9mZignX2FmdGVycHJpbnQnLCB0aGlzLmhhbmRsZUFmdGVyUHJpbnQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBDb21wdXRlcyBhIGRlZmF1bHQgY29sdW1uIGhlYWRlciBmb3JtYXR0aW5nIHN0cmluZyBpZiBgY29sRm9ybWF0YCBpcyBub3QgZXhwbGljaXRseSBkZWZpbmVkXHJcbiAgICBmdW5jdGlvbiBjb21wdXRlRmFsbGJhY2tIZWFkZXJGb3JtYXQoZGF0ZXNSZXBEaXN0aW5jdERheXMsIGRheUNudCkge1xyXG4gICAgICAgIC8vIGlmIG1vcmUgdGhhbiBvbmUgd2VlayByb3csIG9yIGlmIHRoZXJlIGFyZSBhIGxvdCBvZiBjb2x1bW5zIHdpdGggbm90IG11Y2ggc3BhY2UsXHJcbiAgICAgICAgLy8gcHV0IGp1c3QgdGhlIGRheSBudW1iZXJzIHdpbGwgYmUgaW4gZWFjaCBjZWxsXHJcbiAgICAgICAgaWYgKCFkYXRlc1JlcERpc3RpbmN0RGF5cyB8fCBkYXlDbnQgPiAxMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlRm9ybWF0dGVyKHsgd2Vla2RheTogJ3Nob3J0JyB9KTsgLy8gXCJTYXRcIlxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZGF5Q250ID4gMSkge1xyXG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlRm9ybWF0dGVyKHsgd2Vla2RheTogJ3Nob3J0JywgbW9udGg6ICdudW1lcmljJywgZGF5OiAnbnVtZXJpYycsIG9taXRDb21tYXM6IHRydWUgfSk7IC8vIFwiU2F0IDExLzEyXCJcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUZvcm1hdHRlcih7IHdlZWtkYXk6ICdsb25nJyB9KTsgLy8gXCJTYXR1cmRheVwiXHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgQ0xBU1NfTkFNRSA9ICdmYy1jb2wtaGVhZGVyLWNlbGwnOyAvLyBkbyB0aGUgY3VzaGlvbiB0b28/IG5vXHJcbiAgICBmdW5jdGlvbiByZW5kZXJJbm5lciQxKHJlbmRlclByb3BzKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlbmRlclByb3BzLnRleHQ7XHJcbiAgICB9XHJcblxyXG4gICAgY2xhc3MgQ29udGVudEluamVjdG9yIGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XHJcbiAgICAgICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgIHRoaXMuaWQgPSBndWlkKCk7XHJcbiAgICAgICAgICAgIHRoaXMucXVldWVkRG9tTm9kZXMgPSBbXTtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50RG9tTm9kZXMgPSBbXTtcclxuICAgICAgICAgICAgdGhpcy5oYW5kbGVFbCA9IChlbCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucHJvcHMuZWxSZWYpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZXRSZWYodGhpcy5wcm9wcy5lbFJlZiwgZWwpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZW5kZXIoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgcHJvcHMsIGNvbnRleHQgfSA9IHRoaXM7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgb3B0aW9ucyB9ID0gY29udGV4dDtcclxuICAgICAgICAgICAgY29uc3QgeyBjdXN0b21HZW5lcmF0b3IsIGRlZmF1bHRHZW5lcmF0b3IsIHJlbmRlclByb3BzIH0gPSBwcm9wcztcclxuICAgICAgICAgICAgY29uc3QgYXR0cnMgPSBidWlsZEVsQXR0cnMocHJvcHMpO1xyXG4gICAgICAgICAgICBsZXQgdXNlRGVmYXVsdCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBsZXQgaW5uZXJDb250ZW50O1xyXG4gICAgICAgICAgICBsZXQgcXVldWVkRG9tTm9kZXMgPSBbXTtcclxuICAgICAgICAgICAgbGV0IGN1cnJlbnRHZW5lcmF0b3JNZXRhO1xyXG4gICAgICAgICAgICBpZiAoY3VzdG9tR2VuZXJhdG9yICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGN1c3RvbUdlbmVyYXRvclJlcyA9IHR5cGVvZiBjdXN0b21HZW5lcmF0b3IgPT09ICdmdW5jdGlvbicgP1xyXG4gICAgICAgICAgICAgICAgICAgIGN1c3RvbUdlbmVyYXRvcihyZW5kZXJQcm9wcywgeSkgOlxyXG4gICAgICAgICAgICAgICAgICAgIGN1c3RvbUdlbmVyYXRvcjtcclxuICAgICAgICAgICAgICAgIGlmIChjdXN0b21HZW5lcmF0b3JSZXMgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgICAgICB1c2VEZWZhdWx0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlzT2JqZWN0ID0gY3VzdG9tR2VuZXJhdG9yUmVzICYmIHR5cGVvZiBjdXN0b21HZW5lcmF0b3JSZXMgPT09ICdvYmplY3QnOyAvLyBub24tbnVsbFxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc09iamVjdCAmJiAoJ2h0bWwnIGluIGN1c3RvbUdlbmVyYXRvclJlcykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cnMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgPSB7IF9faHRtbDogY3VzdG9tR2VuZXJhdG9yUmVzLmh0bWwgfTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNPYmplY3QgJiYgKCdkb21Ob2RlcycgaW4gY3VzdG9tR2VuZXJhdG9yUmVzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBxdWV1ZWREb21Ob2RlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGN1c3RvbUdlbmVyYXRvclJlcy5kb21Ob2Rlcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFpc09iamVjdCAmJiB0eXBlb2YgY3VzdG9tR2VuZXJhdG9yUmVzICE9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHByaW1pdGl2ZSB2YWx1ZSAobGlrZSBzdHJpbmcgb3IgbnVtYmVyKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbm5lckNvbnRlbnQgPSBjdXN0b21HZW5lcmF0b3JSZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhbiBleG90aWMgb2JqZWN0IGZvciBoYW5kbGVDdXN0b21SZW5kZXJpbmdcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEdlbmVyYXRvck1ldGEgPSBjdXN0b21HZW5lcmF0b3JSZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdXNlRGVmYXVsdCA9ICFoYXNDdXN0b21SZW5kZXJpbmdIYW5kbGVyKHByb3BzLmdlbmVyYXRvck5hbWUsIG9wdGlvbnMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh1c2VEZWZhdWx0ICYmIGRlZmF1bHRHZW5lcmF0b3IpIHtcclxuICAgICAgICAgICAgICAgIGlubmVyQ29udGVudCA9IGRlZmF1bHRHZW5lcmF0b3IocmVuZGVyUHJvcHMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMucXVldWVkRG9tTm9kZXMgPSBxdWV1ZWREb21Ob2RlcztcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50R2VuZXJhdG9yTWV0YSA9IGN1cnJlbnRHZW5lcmF0b3JNZXRhO1xyXG4gICAgICAgICAgICByZXR1cm4geShwcm9wcy5lbFRhZywgYXR0cnMsIGlubmVyQ29udGVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xyXG4gICAgICAgICAgICB0aGlzLmFwcGx5UXVldWV1ZERvbU5vZGVzKCk7XHJcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlckN1c3RvbVJlbmRlcmluZyh0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29tcG9uZW50RGlkVXBkYXRlKCkge1xyXG4gICAgICAgICAgICB0aGlzLmFwcGx5UXVldWV1ZERvbU5vZGVzKCk7XHJcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlckN1c3RvbVJlbmRlcmluZyh0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XHJcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlckN1c3RvbVJlbmRlcmluZyhmYWxzZSk7IC8vIFRPRE86IGRpZmZlcmVudCBBUEkgZm9yIHJlbW92YWw/XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRyaWdnZXJDdXN0b21SZW5kZXJpbmcoaXNBY3RpdmUpIHtcclxuICAgICAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgICAgICBjb25zdCB7IHByb3BzLCBjb250ZXh0IH0gPSB0aGlzO1xyXG4gICAgICAgICAgICBjb25zdCB7IGhhbmRsZUN1c3RvbVJlbmRlcmluZywgY3VzdG9tUmVuZGVyaW5nTWV0YU1hcCB9ID0gY29udGV4dC5vcHRpb25zO1xyXG4gICAgICAgICAgICBpZiAoaGFuZGxlQ3VzdG9tUmVuZGVyaW5nKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBnZW5lcmF0b3JNZXRhID0gKF9hID0gdGhpcy5jdXJyZW50R2VuZXJhdG9yTWV0YSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogY3VzdG9tUmVuZGVyaW5nTWV0YU1hcCA9PT0gbnVsbCB8fCBjdXN0b21SZW5kZXJpbmdNZXRhTWFwID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdXN0b21SZW5kZXJpbmdNZXRhTWFwW3Byb3BzLmdlbmVyYXRvck5hbWVdO1xyXG4gICAgICAgICAgICAgICAgaWYgKGdlbmVyYXRvck1ldGEpIHtcclxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVDdXN0b21SZW5kZXJpbmcoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgaWQ6IHRoaXMuaWQsIGlzQWN0aXZlLCBjb250YWluZXJFbDogdGhpcy5iYXNlLCByZXBvcnROZXdDb250YWluZXJFbDogdGhpcy5oYW5kbGVFbCwgLy8gZm9yIGN1c3RvbVJlbmRlcmluZ1JlcGxhY2VzRWxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdG9yTWV0YSB9LCBwcm9wcyksIHsgZWxDbGFzc2VzOiAocHJvcHMuZWxDbGFzc2VzIHx8IFtdKS5maWx0ZXIoaXNUcnV0aHkpIH0pKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBhcHBseVF1ZXVldWREb21Ob2RlcygpIHtcclxuICAgICAgICAgICAgY29uc3QgeyBxdWV1ZWREb21Ob2RlcywgY3VycmVudERvbU5vZGVzIH0gPSB0aGlzO1xyXG4gICAgICAgICAgICBjb25zdCBlbCA9IHRoaXMuYmFzZTtcclxuICAgICAgICAgICAgaWYgKCFpc0FycmF5c0VxdWFsKHF1ZXVlZERvbU5vZGVzLCBjdXJyZW50RG9tTm9kZXMpKSB7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50RG9tTm9kZXMuZm9yRWFjaChyZW1vdmVFbGVtZW50KTtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IG5ld05vZGUgb2YgcXVldWVkRG9tTm9kZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICBlbC5hcHBlbmRDaGlsZChuZXdOb2RlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudERvbU5vZGVzID0gcXVldWVkRG9tTm9kZXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBDb250ZW50SW5qZWN0b3IuYWRkUHJvcHNFcXVhbGl0eSh7XHJcbiAgICAgICAgZWxDbGFzc2VzOiBpc0FycmF5c0VxdWFsLFxyXG4gICAgICAgIGVsU3R5bGU6IGlzUHJvcHNFcXVhbCxcclxuICAgICAgICBlbEF0dHJzOiBpc05vbkhhbmRsZXJQcm9wc0VxdWFsLFxyXG4gICAgICAgIHJlbmRlclByb3BzOiBpc1Byb3BzRXF1YWwsXHJcbiAgICB9KTtcclxuICAgIC8vIFV0aWxcclxuICAgIC8qXHJcbiAgICBEb2VzIFVJLWZyYW1ld29yayBwcm92aWRlIGN1c3RvbSB3YXkgb2YgcmVuZGVyaW5nP1xyXG4gICAgKi9cclxuICAgIGZ1bmN0aW9uIGhhc0N1c3RvbVJlbmRlcmluZ0hhbmRsZXIoZ2VuZXJhdG9yTmFtZSwgb3B0aW9ucykge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICByZXR1cm4gQm9vbGVhbihvcHRpb25zLmhhbmRsZUN1c3RvbVJlbmRlcmluZyAmJlxyXG4gICAgICAgICAgICBnZW5lcmF0b3JOYW1lICYmXHJcbiAgICAgICAgICAgICgoX2EgPSBvcHRpb25zLmN1c3RvbVJlbmRlcmluZ01ldGFNYXApID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVtnZW5lcmF0b3JOYW1lXSkpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYnVpbGRFbEF0dHJzKHByb3BzLCBleHRyYUNsYXNzTmFtZXMpIHtcclxuICAgICAgICBjb25zdCBhdHRycyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcHJvcHMuZWxBdHRycyksIHsgcmVmOiBwcm9wcy5lbFJlZiB9KTtcclxuICAgICAgICBpZiAocHJvcHMuZWxDbGFzc2VzIHx8IGV4dHJhQ2xhc3NOYW1lcykge1xyXG4gICAgICAgICAgICBhdHRycy5jbGFzc05hbWUgPSAocHJvcHMuZWxDbGFzc2VzIHx8IFtdKVxyXG4gICAgICAgICAgICAgICAgLmNvbmNhdChleHRyYUNsYXNzTmFtZXMgfHwgW10pXHJcbiAgICAgICAgICAgICAgICAuY29uY2F0KGF0dHJzLmNsYXNzTmFtZSB8fCBbXSlcclxuICAgICAgICAgICAgICAgIC5maWx0ZXIoQm9vbGVhbilcclxuICAgICAgICAgICAgICAgIC5qb2luKCcgJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwcm9wcy5lbFN0eWxlKSB7XHJcbiAgICAgICAgICAgIGF0dHJzLnN0eWxlID0gcHJvcHMuZWxTdHlsZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGF0dHJzO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gaXNUcnV0aHkodmFsKSB7XHJcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4odmFsKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBSZW5kZXJJZCA9IGNyZWF0ZUNvbnRleHQoMCk7XHJcblxyXG4gICAgY2xhc3MgQ29udGVudENvbnRhaW5lciBleHRlbmRzIHgkMSB7XHJcbiAgICAgICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgIHRoaXMuSW5uZXJDb250ZW50ID0gSW5uZXJDb250ZW50SW5qZWN0b3IuYmluZCh1bmRlZmluZWQsIHRoaXMpO1xyXG4gICAgICAgICAgICB0aGlzLmhhbmRsZVJvb3RFbCA9IChlbCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yb290RWwgPSBlbDtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnByb3BzLmVsUmVmKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0UmVmKHRoaXMucHJvcHMuZWxSZWYsIGVsKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVuZGVyKCkge1xyXG4gICAgICAgICAgICBjb25zdCB7IHByb3BzIH0gPSB0aGlzO1xyXG4gICAgICAgICAgICBjb25zdCBnZW5lcmF0ZWRDbGFzc05hbWVzID0gZ2VuZXJhdGVDbGFzc05hbWVzKHByb3BzLmNsYXNzTmFtZUdlbmVyYXRvciwgcHJvcHMucmVuZGVyUHJvcHMpO1xyXG4gICAgICAgICAgICBpZiAocHJvcHMuY2hpbGRyZW4pIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGVsQXR0cnMgPSBidWlsZEVsQXR0cnMocHJvcHMsIGdlbmVyYXRlZENsYXNzTmFtZXMpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbih0aGlzLklubmVyQ29udGVudCwgcHJvcHMucmVuZGVyUHJvcHMsIGVsQXR0cnMpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHByb3BzLmVsVGFnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHkocHJvcHMuZWxUYWcsIGVsQXR0cnMsIGNoaWxkcmVuKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZHJlbjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB5KChDb250ZW50SW5qZWN0b3IpLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHByb3BzKSwgeyBlbFJlZjogdGhpcy5oYW5kbGVSb290RWwsIGVsVGFnOiBwcm9wcy5lbFRhZyB8fCAnZGl2JywgZWxDbGFzc2VzOiAocHJvcHMuZWxDbGFzc2VzIHx8IFtdKS5jb25jYXQoZ2VuZXJhdGVkQ2xhc3NOYW1lcyksIHJlbmRlcklkOiB0aGlzLmNvbnRleHQgfSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xyXG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgICAgICAoX2IgPSAoX2EgPSB0aGlzLnByb3BzKS5kaWRNb3VudCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5wcm9wcy5yZW5kZXJQcm9wcyksIHsgZWw6IHRoaXMucm9vdEVsIHx8IHRoaXMuYmFzZSB9KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xyXG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgICAgICAoX2IgPSAoX2EgPSB0aGlzLnByb3BzKS53aWxsVW5tb3VudCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5wcm9wcy5yZW5kZXJQcm9wcyksIHsgZWw6IHRoaXMucm9vdEVsIHx8IHRoaXMuYmFzZSB9KSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgQ29udGVudENvbnRhaW5lci5jb250ZXh0VHlwZSA9IFJlbmRlcklkO1xyXG4gICAgZnVuY3Rpb24gSW5uZXJDb250ZW50SW5qZWN0b3IoY29udGFpbmVyQ29tcG9uZW50LCBwcm9wcykge1xyXG4gICAgICAgIGNvbnN0IHBhcmVudFByb3BzID0gY29udGFpbmVyQ29tcG9uZW50LnByb3BzO1xyXG4gICAgICAgIHJldHVybiB5KChDb250ZW50SW5qZWN0b3IpLCBPYmplY3QuYXNzaWduKHsgcmVuZGVyUHJvcHM6IHBhcmVudFByb3BzLnJlbmRlclByb3BzLCBnZW5lcmF0b3JOYW1lOiBwYXJlbnRQcm9wcy5nZW5lcmF0b3JOYW1lLCBjdXN0b21HZW5lcmF0b3I6IHBhcmVudFByb3BzLmN1c3RvbUdlbmVyYXRvciwgZGVmYXVsdEdlbmVyYXRvcjogcGFyZW50UHJvcHMuZGVmYXVsdEdlbmVyYXRvciwgcmVuZGVySWQ6IGNvbnRhaW5lckNvbXBvbmVudC5jb250ZXh0IH0sIHByb3BzKSk7XHJcbiAgICB9XHJcbiAgICAvLyBVdGlsc1xyXG4gICAgZnVuY3Rpb24gZ2VuZXJhdGVDbGFzc05hbWVzKGNsYXNzTmFtZUdlbmVyYXRvciwgcmVuZGVyUHJvcHMpIHtcclxuICAgICAgICBjb25zdCBjbGFzc05hbWVzID0gdHlwZW9mIGNsYXNzTmFtZUdlbmVyYXRvciA9PT0gJ2Z1bmN0aW9uJyA/XHJcbiAgICAgICAgICAgIGNsYXNzTmFtZUdlbmVyYXRvcihyZW5kZXJQcm9wcykgOlxyXG4gICAgICAgICAgICBjbGFzc05hbWVHZW5lcmF0b3IgfHwgW107XHJcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBjbGFzc05hbWVzID09PSAnc3RyaW5nJyA/IFtjbGFzc05hbWVzXSA6IGNsYXNzTmFtZXM7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQkFEIG5hbWUgZm9yIHRoaXMgY2xhc3Mgbm93LiB1c2VkIGluIHRoZSBIZWFkZXJcclxuICAgIGNsYXNzIFRhYmxlRGF0ZUNlbGwgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcclxuICAgICAgICByZW5kZXIoKSB7XHJcbiAgICAgICAgICAgIGxldCB7IGRhdGVFbnYsIG9wdGlvbnMsIHRoZW1lLCB2aWV3QXBpIH0gPSB0aGlzLmNvbnRleHQ7XHJcbiAgICAgICAgICAgIGxldCB7IHByb3BzIH0gPSB0aGlzO1xyXG4gICAgICAgICAgICBsZXQgeyBkYXRlLCBkYXRlUHJvZmlsZSB9ID0gcHJvcHM7XHJcbiAgICAgICAgICAgIGxldCBkYXlNZXRhID0gZ2V0RGF0ZU1ldGEoZGF0ZSwgcHJvcHMudG9kYXlSYW5nZSwgbnVsbCwgZGF0ZVByb2ZpbGUpO1xyXG4gICAgICAgICAgICBsZXQgY2xhc3NOYW1lcyA9IFtDTEFTU19OQU1FXS5jb25jYXQoZ2V0RGF5Q2xhc3NOYW1lcyhkYXlNZXRhLCB0aGVtZSkpO1xyXG4gICAgICAgICAgICBsZXQgdGV4dCA9IGRhdGVFbnYuZm9ybWF0KGRhdGUsIHByb3BzLmRheUhlYWRlckZvcm1hdCk7XHJcbiAgICAgICAgICAgIC8vIGlmIGNvbENudCBpcyAxLCB3ZSBhcmUgYWxyZWFkeSBpbiBhIGRheS12aWV3IGFuZCBkb24ndCBuZWVkIGEgbmF2bGlua1xyXG4gICAgICAgICAgICBsZXQgbmF2TGlua0F0dHJzID0gKCFkYXlNZXRhLmlzRGlzYWJsZWQgJiYgcHJvcHMuY29sQ250ID4gMSlcclxuICAgICAgICAgICAgICAgID8gYnVpbGROYXZMaW5rQXR0cnModGhpcy5jb250ZXh0LCBkYXRlKVxyXG4gICAgICAgICAgICAgICAgOiB7fTtcclxuICAgICAgICAgICAgbGV0IHJlbmRlclByb3BzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyBkYXRlOiBkYXRlRW52LnRvRGF0ZShkYXRlKSwgdmlldzogdmlld0FwaSB9LCBwcm9wcy5leHRyYVJlbmRlclByb3BzKSwgeyB0ZXh0IH0pLCBkYXlNZXRhKTtcclxuICAgICAgICAgICAgcmV0dXJuICh5KENvbnRlbnRDb250YWluZXIsIHsgZWxUYWc6IFwidGhcIiwgZWxDbGFzc2VzOiBjbGFzc05hbWVzLCBlbEF0dHJzOiBPYmplY3QuYXNzaWduKHsgcm9sZTogJ2NvbHVtbmhlYWRlcicsIGNvbFNwYW46IHByb3BzLmNvbFNwYW4sICdkYXRhLWRhdGUnOiAhZGF5TWV0YS5pc0Rpc2FibGVkID8gZm9ybWF0RGF5U3RyaW5nKGRhdGUpIDogdW5kZWZpbmVkIH0sIHByb3BzLmV4dHJhRGF0YUF0dHJzKSwgcmVuZGVyUHJvcHM6IHJlbmRlclByb3BzLCBnZW5lcmF0b3JOYW1lOiBcImRheUhlYWRlckNvbnRlbnRcIiwgY3VzdG9tR2VuZXJhdG9yOiBvcHRpb25zLmRheUhlYWRlckNvbnRlbnQsIGRlZmF1bHRHZW5lcmF0b3I6IHJlbmRlcklubmVyJDEsIGNsYXNzTmFtZUdlbmVyYXRvcjogb3B0aW9ucy5kYXlIZWFkZXJDbGFzc05hbWVzLCBkaWRNb3VudDogb3B0aW9ucy5kYXlIZWFkZXJEaWRNb3VudCwgd2lsbFVubW91bnQ6IG9wdGlvbnMuZGF5SGVhZGVyV2lsbFVubW91bnQgfSwgKElubmVyQ29udGFpbmVyKSA9PiAoeShcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy1zY3JvbGxncmlkLXN5bmMtaW5uZXJcIiB9LCAhZGF5TWV0YS5pc0Rpc2FibGVkICYmICh5KElubmVyQ29udGFpbmVyLCB7IGVsVGFnOiBcImFcIiwgZWxBdHRyczogbmF2TGlua0F0dHJzLCBlbENsYXNzZXM6IFtcclxuICAgICAgICAgICAgICAgICAgICAnZmMtY29sLWhlYWRlci1jZWxsLWN1c2hpb24nLFxyXG4gICAgICAgICAgICAgICAgICAgIHByb3BzLmlzU3RpY2t5ICYmICdmYy1zdGlja3knLFxyXG4gICAgICAgICAgICAgICAgXSB9KSkpKSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBXRUVLREFZX0ZPUk1BVCA9IGNyZWF0ZUZvcm1hdHRlcih7IHdlZWtkYXk6ICdsb25nJyB9KTtcclxuICAgIGNsYXNzIFRhYmxlRG93Q2VsbCBleHRlbmRzIEJhc2VDb21wb25lbnQge1xyXG4gICAgICAgIHJlbmRlcigpIHtcclxuICAgICAgICAgICAgbGV0IHsgcHJvcHMgfSA9IHRoaXM7XHJcbiAgICAgICAgICAgIGxldCB7IGRhdGVFbnYsIHRoZW1lLCB2aWV3QXBpLCBvcHRpb25zIH0gPSB0aGlzLmNvbnRleHQ7XHJcbiAgICAgICAgICAgIGxldCBkYXRlID0gYWRkRGF5cyhuZXcgRGF0ZSgyNTkyMDAwMDApLCBwcm9wcy5kb3cpOyAvLyBzdGFydCB3aXRoIFN1biwgMDQgSmFuIDE5NzAgMDA6MDA6MDAgR01UXHJcbiAgICAgICAgICAgIGxldCBkYXRlTWV0YSA9IHtcclxuICAgICAgICAgICAgICAgIGRvdzogcHJvcHMuZG93LFxyXG4gICAgICAgICAgICAgICAgaXNEaXNhYmxlZDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBpc0Z1dHVyZTogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBpc1Bhc3Q6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgaXNUb2RheTogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBpc090aGVyOiBmYWxzZSxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgbGV0IHRleHQgPSBkYXRlRW52LmZvcm1hdChkYXRlLCBwcm9wcy5kYXlIZWFkZXJGb3JtYXQpO1xyXG4gICAgICAgICAgICBsZXQgcmVuZGVyUHJvcHMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgLy8gVE9ETzogbWFrZSB0aGlzIHB1YmxpYz9cclxuICAgICAgICAgICAgICAgIGRhdGUgfSwgZGF0ZU1ldGEpLCB7IHZpZXc6IHZpZXdBcGkgfSksIHByb3BzLmV4dHJhUmVuZGVyUHJvcHMpLCB7IHRleHQgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiAoeShDb250ZW50Q29udGFpbmVyLCB7IGVsVGFnOiBcInRoXCIsIGVsQ2xhc3NlczogW1xyXG4gICAgICAgICAgICAgICAgICAgIENMQVNTX05BTUUsXHJcbiAgICAgICAgICAgICAgICAgICAgLi4uZ2V0RGF5Q2xhc3NOYW1lcyhkYXRlTWV0YSwgdGhlbWUpLFxyXG4gICAgICAgICAgICAgICAgICAgIC4uLihwcm9wcy5leHRyYUNsYXNzTmFtZXMgfHwgW10pLFxyXG4gICAgICAgICAgICAgICAgXSwgZWxBdHRyczogT2JqZWN0LmFzc2lnbih7IHJvbGU6ICdjb2x1bW5oZWFkZXInLCBjb2xTcGFuOiBwcm9wcy5jb2xTcGFuIH0sIHByb3BzLmV4dHJhRGF0YUF0dHJzKSwgcmVuZGVyUHJvcHM6IHJlbmRlclByb3BzLCBnZW5lcmF0b3JOYW1lOiBcImRheUhlYWRlckNvbnRlbnRcIiwgY3VzdG9tR2VuZXJhdG9yOiBvcHRpb25zLmRheUhlYWRlckNvbnRlbnQsIGRlZmF1bHRHZW5lcmF0b3I6IHJlbmRlcklubmVyJDEsIGNsYXNzTmFtZUdlbmVyYXRvcjogb3B0aW9ucy5kYXlIZWFkZXJDbGFzc05hbWVzLCBkaWRNb3VudDogb3B0aW9ucy5kYXlIZWFkZXJEaWRNb3VudCwgd2lsbFVubW91bnQ6IG9wdGlvbnMuZGF5SGVhZGVyV2lsbFVubW91bnQgfSwgKElubmVyQ29udGVudCkgPT4gKHkoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtc2Nyb2xsZ3JpZC1zeW5jLWlubmVyXCIgfSxcclxuICAgICAgICAgICAgICAgIHkoSW5uZXJDb250ZW50LCB7IGVsVGFnOiBcImFcIiwgZWxDbGFzc2VzOiBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdmYy1jb2wtaGVhZGVyLWNlbGwtY3VzaGlvbicsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzLmlzU3RpY2t5ICYmICdmYy1zdGlja3knLFxyXG4gICAgICAgICAgICAgICAgICAgIF0sIGVsQXR0cnM6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ2FyaWEtbGFiZWwnOiBkYXRlRW52LmZvcm1hdChkYXRlLCBXRUVLREFZX0ZPUk1BVCksXHJcbiAgICAgICAgICAgICAgICAgICAgfSB9KSkpKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNsYXNzIE5vd1RpbWVyIGV4dGVuZHMgeCQxIHtcclxuICAgICAgICBjb25zdHJ1Y3Rvcihwcm9wcywgY29udGV4dCkge1xyXG4gICAgICAgICAgICBzdXBlcihwcm9wcywgY29udGV4dCk7XHJcbiAgICAgICAgICAgIHRoaXMuaW5pdGlhbE5vd0RhdGUgPSBnZXROb3coY29udGV4dC5vcHRpb25zLm5vdywgY29udGV4dC5kYXRlRW52KTtcclxuICAgICAgICAgICAgdGhpcy5pbml0aWFsTm93UXVlcmllZE1zID0gbmV3IERhdGUoKS52YWx1ZU9mKCk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSB0aGlzLmNvbXB1dGVUaW1pbmcoKS5jdXJyZW50U3RhdGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlbmRlcigpIHtcclxuICAgICAgICAgICAgbGV0IHsgcHJvcHMsIHN0YXRlIH0gPSB0aGlzO1xyXG4gICAgICAgICAgICByZXR1cm4gcHJvcHMuY2hpbGRyZW4oc3RhdGUubm93RGF0ZSwgc3RhdGUudG9kYXlSYW5nZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xyXG4gICAgICAgICAgICB0aGlzLnNldFRpbWVvdXQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcykge1xyXG4gICAgICAgICAgICBpZiAocHJldlByb3BzLnVuaXQgIT09IHRoaXMucHJvcHMudW5pdCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhclRpbWVvdXQoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0VGltZW91dCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xyXG4gICAgICAgICAgICB0aGlzLmNsZWFyVGltZW91dCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb21wdXRlVGltaW5nKCkge1xyXG4gICAgICAgICAgICBsZXQgeyBwcm9wcywgY29udGV4dCB9ID0gdGhpcztcclxuICAgICAgICAgICAgbGV0IHVucm91bmRlZE5vdyA9IGFkZE1zKHRoaXMuaW5pdGlhbE5vd0RhdGUsIG5ldyBEYXRlKCkudmFsdWVPZigpIC0gdGhpcy5pbml0aWFsTm93UXVlcmllZE1zKTtcclxuICAgICAgICAgICAgbGV0IGN1cnJlbnRVbml0U3RhcnQgPSBjb250ZXh0LmRhdGVFbnYuc3RhcnRPZih1bnJvdW5kZWROb3csIHByb3BzLnVuaXQpO1xyXG4gICAgICAgICAgICBsZXQgbmV4dFVuaXRTdGFydCA9IGNvbnRleHQuZGF0ZUVudi5hZGQoY3VycmVudFVuaXRTdGFydCwgY3JlYXRlRHVyYXRpb24oMSwgcHJvcHMudW5pdCkpO1xyXG4gICAgICAgICAgICBsZXQgd2FpdE1zID0gbmV4dFVuaXRTdGFydC52YWx1ZU9mKCkgLSB1bnJvdW5kZWROb3cudmFsdWVPZigpO1xyXG4gICAgICAgICAgICAvLyB0aGVyZSBpcyBhIG1heCBzZXRUaW1lb3V0IG1zIHZhbHVlIChodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzQ2ODY1MC85NjM0MilcclxuICAgICAgICAgICAgLy8gZW5zdXJlIG5vIGxvbmdlciB0aGFuIGEgZGF5XHJcbiAgICAgICAgICAgIHdhaXRNcyA9IE1hdGgubWluKDEwMDAgKiA2MCAqIDYwICogMjQsIHdhaXRNcyk7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50U3RhdGU6IHsgbm93RGF0ZTogY3VycmVudFVuaXRTdGFydCwgdG9kYXlSYW5nZTogYnVpbGREYXlSYW5nZShjdXJyZW50VW5pdFN0YXJ0KSB9LFxyXG4gICAgICAgICAgICAgICAgbmV4dFN0YXRlOiB7IG5vd0RhdGU6IG5leHRVbml0U3RhcnQsIHRvZGF5UmFuZ2U6IGJ1aWxkRGF5UmFuZ2UobmV4dFVuaXRTdGFydCkgfSxcclxuICAgICAgICAgICAgICAgIHdhaXRNcyxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc2V0VGltZW91dCgpIHtcclxuICAgICAgICAgICAgbGV0IHsgbmV4dFN0YXRlLCB3YWl0TXMgfSA9IHRoaXMuY29tcHV0ZVRpbWluZygpO1xyXG4gICAgICAgICAgICB0aGlzLnRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZShuZXh0U3RhdGUsICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFRpbWVvdXQoKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9LCB3YWl0TXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjbGVhclRpbWVvdXQoKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnRpbWVvdXRJZCkge1xyXG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dElkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIE5vd1RpbWVyLmNvbnRleHRUeXBlID0gVmlld0NvbnRleHRUeXBlO1xyXG4gICAgZnVuY3Rpb24gYnVpbGREYXlSYW5nZShkYXRlKSB7XHJcbiAgICAgICAgbGV0IHN0YXJ0ID0gc3RhcnRPZkRheShkYXRlKTtcclxuICAgICAgICBsZXQgZW5kID0gYWRkRGF5cyhzdGFydCwgMSk7XHJcbiAgICAgICAgcmV0dXJuIHsgc3RhcnQsIGVuZCB9O1xyXG4gICAgfVxyXG5cclxuICAgIGNsYXNzIERheUhlYWRlciBleHRlbmRzIEJhc2VDb21wb25lbnQge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgICAgICB0aGlzLmNyZWF0ZURheUhlYWRlckZvcm1hdHRlciA9IG1lbW9pemUoY3JlYXRlRGF5SGVhZGVyRm9ybWF0dGVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVuZGVyKCkge1xyXG4gICAgICAgICAgICBsZXQgeyBjb250ZXh0IH0gPSB0aGlzO1xyXG4gICAgICAgICAgICBsZXQgeyBkYXRlcywgZGF0ZVByb2ZpbGUsIGRhdGVzUmVwRGlzdGluY3REYXlzLCByZW5kZXJJbnRybyB9ID0gdGhpcy5wcm9wcztcclxuICAgICAgICAgICAgbGV0IGRheUhlYWRlckZvcm1hdCA9IHRoaXMuY3JlYXRlRGF5SGVhZGVyRm9ybWF0dGVyKGNvbnRleHQub3B0aW9ucy5kYXlIZWFkZXJGb3JtYXQsIGRhdGVzUmVwRGlzdGluY3REYXlzLCBkYXRlcy5sZW5ndGgpO1xyXG4gICAgICAgICAgICByZXR1cm4gKHkoTm93VGltZXIsIHsgdW5pdDogXCJkYXlcIiB9LCAobm93RGF0ZSwgdG9kYXlSYW5nZSkgPT4gKHkoXCJ0clwiLCB7IHJvbGU6IFwicm93XCIgfSxcclxuICAgICAgICAgICAgICAgIHJlbmRlckludHJvICYmIHJlbmRlckludHJvKCdkYXknKSxcclxuICAgICAgICAgICAgICAgIGRhdGVzLm1hcCgoZGF0ZSkgPT4gKGRhdGVzUmVwRGlzdGluY3REYXlzID8gKHkoVGFibGVEYXRlQ2VsbCwgeyBrZXk6IGRhdGUudG9JU09TdHJpbmcoKSwgZGF0ZTogZGF0ZSwgZGF0ZVByb2ZpbGU6IGRhdGVQcm9maWxlLCB0b2RheVJhbmdlOiB0b2RheVJhbmdlLCBjb2xDbnQ6IGRhdGVzLmxlbmd0aCwgZGF5SGVhZGVyRm9ybWF0OiBkYXlIZWFkZXJGb3JtYXQgfSkpIDogKHkoVGFibGVEb3dDZWxsLCB7IGtleTogZGF0ZS5nZXRVVENEYXkoKSwgZG93OiBkYXRlLmdldFVUQ0RheSgpLCBkYXlIZWFkZXJGb3JtYXQ6IGRheUhlYWRlckZvcm1hdCB9KSkpKSkpKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gY3JlYXRlRGF5SGVhZGVyRm9ybWF0dGVyKGV4cGxpY2l0Rm9ybWF0LCBkYXRlc1JlcERpc3RpbmN0RGF5cywgZGF0ZUNudCkge1xyXG4gICAgICAgIHJldHVybiBleHBsaWNpdEZvcm1hdCB8fCBjb21wdXRlRmFsbGJhY2tIZWFkZXJGb3JtYXQoZGF0ZXNSZXBEaXN0aW5jdERheXMsIGRhdGVDbnQpO1xyXG4gICAgfVxyXG5cclxuICAgIGNsYXNzIERheVNlcmllc01vZGVsIHtcclxuICAgICAgICBjb25zdHJ1Y3RvcihyYW5nZSwgZGF0ZVByb2ZpbGVHZW5lcmF0b3IpIHtcclxuICAgICAgICAgICAgbGV0IGRhdGUgPSByYW5nZS5zdGFydDtcclxuICAgICAgICAgICAgbGV0IHsgZW5kIH0gPSByYW5nZTtcclxuICAgICAgICAgICAgbGV0IGluZGljZXMgPSBbXTtcclxuICAgICAgICAgICAgbGV0IGRhdGVzID0gW107XHJcbiAgICAgICAgICAgIGxldCBkYXlJbmRleCA9IC0xO1xyXG4gICAgICAgICAgICB3aGlsZSAoZGF0ZSA8IGVuZCkgeyAvLyBsb29wIGVhY2ggZGF5IGZyb20gc3RhcnQgdG8gZW5kXHJcbiAgICAgICAgICAgICAgICBpZiAoZGF0ZVByb2ZpbGVHZW5lcmF0b3IuaXNIaWRkZW5EYXkoZGF0ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpbmRpY2VzLnB1c2goZGF5SW5kZXggKyAwLjUpOyAvLyBtYXJrIHRoYXQgaXQncyBiZXR3ZWVuIGluZGljZXNcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGRheUluZGV4ICs9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5kaWNlcy5wdXNoKGRheUluZGV4KTtcclxuICAgICAgICAgICAgICAgICAgICBkYXRlcy5wdXNoKGRhdGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZGF0ZSA9IGFkZERheXMoZGF0ZSwgMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5kYXRlcyA9IGRhdGVzO1xyXG4gICAgICAgICAgICB0aGlzLmluZGljZXMgPSBpbmRpY2VzO1xyXG4gICAgICAgICAgICB0aGlzLmNudCA9IGRhdGVzLmxlbmd0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgc2xpY2VSYW5nZShyYW5nZSkge1xyXG4gICAgICAgICAgICBsZXQgZmlyc3RJbmRleCA9IHRoaXMuZ2V0RGF0ZURheUluZGV4KHJhbmdlLnN0YXJ0KTsgLy8gaW5jbHVzaXZlIGZpcnN0IGluZGV4XHJcbiAgICAgICAgICAgIGxldCBsYXN0SW5kZXggPSB0aGlzLmdldERhdGVEYXlJbmRleChhZGREYXlzKHJhbmdlLmVuZCwgLTEpKTsgLy8gaW5jbHVzaXZlIGxhc3QgaW5kZXhcclxuICAgICAgICAgICAgbGV0IGNsaXBwZWRGaXJzdEluZGV4ID0gTWF0aC5tYXgoMCwgZmlyc3RJbmRleCk7XHJcbiAgICAgICAgICAgIGxldCBjbGlwcGVkTGFzdEluZGV4ID0gTWF0aC5taW4odGhpcy5jbnQgLSAxLCBsYXN0SW5kZXgpO1xyXG4gICAgICAgICAgICAvLyBkZWFsIHdpdGggaW4tYmV0d2VlbiBpbmRpY2VzXHJcbiAgICAgICAgICAgIGNsaXBwZWRGaXJzdEluZGV4ID0gTWF0aC5jZWlsKGNsaXBwZWRGaXJzdEluZGV4KTsgLy8gaW4tYmV0d2VlbiBzdGFydHMgcm91bmQgdG8gbmV4dCBjZWxsXHJcbiAgICAgICAgICAgIGNsaXBwZWRMYXN0SW5kZXggPSBNYXRoLmZsb29yKGNsaXBwZWRMYXN0SW5kZXgpOyAvLyBpbi1iZXR3ZWVuIGVuZHMgcm91bmQgdG8gcHJldiBjZWxsXHJcbiAgICAgICAgICAgIGlmIChjbGlwcGVkRmlyc3RJbmRleCA8PSBjbGlwcGVkTGFzdEluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGZpcnN0SW5kZXg6IGNsaXBwZWRGaXJzdEluZGV4LFxyXG4gICAgICAgICAgICAgICAgICAgIGxhc3RJbmRleDogY2xpcHBlZExhc3RJbmRleCxcclxuICAgICAgICAgICAgICAgICAgICBpc1N0YXJ0OiBmaXJzdEluZGV4ID09PSBjbGlwcGVkRmlyc3RJbmRleCxcclxuICAgICAgICAgICAgICAgICAgICBpc0VuZDogbGFzdEluZGV4ID09PSBjbGlwcGVkTGFzdEluZGV4LFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gR2l2ZW4gYSBkYXRlLCByZXR1cm5zIGl0cyBjaHJvbm9sb2NpYWwgY2VsbC1pbmRleCBmcm9tIHRoZSBmaXJzdCBjZWxsIG9mIHRoZSBncmlkLlxyXG4gICAgICAgIC8vIElmIHRoZSBkYXRlIGxpZXMgYmV0d2VlbiBjZWxscyAoYmVjYXVzZSBvZiBoaWRkZW5EYXlzKSwgcmV0dXJucyBhIGZsb2F0aW5nLXBvaW50IHZhbHVlIGJldHdlZW4gb2Zmc2V0cy5cclxuICAgICAgICAvLyBJZiBiZWZvcmUgdGhlIGZpcnN0IG9mZnNldCwgcmV0dXJucyBhIG5lZ2F0aXZlIG51bWJlci5cclxuICAgICAgICAvLyBJZiBhZnRlciB0aGUgbGFzdCBvZmZzZXQsIHJldHVybnMgYW4gb2Zmc2V0IHBhc3QgdGhlIGxhc3QgY2VsbCBvZmZzZXQuXHJcbiAgICAgICAgLy8gT25seSB3b3JrcyBmb3IgKnN0YXJ0KiBkYXRlcyBvZiBjZWxscy4gV2lsbCBub3Qgd29yayBmb3IgZXhjbHVzaXZlIGVuZCBkYXRlcyBmb3IgY2VsbHMuXHJcbiAgICAgICAgZ2V0RGF0ZURheUluZGV4KGRhdGUpIHtcclxuICAgICAgICAgICAgbGV0IHsgaW5kaWNlcyB9ID0gdGhpcztcclxuICAgICAgICAgICAgbGV0IGRheU9mZnNldCA9IE1hdGguZmxvb3IoZGlmZkRheXModGhpcy5kYXRlc1swXSwgZGF0ZSkpO1xyXG4gICAgICAgICAgICBpZiAoZGF5T2Zmc2V0IDwgMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGluZGljZXNbMF0gLSAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChkYXlPZmZzZXQgPj0gaW5kaWNlcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpbmRpY2VzW2luZGljZXMubGVuZ3RoIC0gMV0gKyAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBpbmRpY2VzW2RheU9mZnNldF07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNsYXNzIERheVRhYmxlTW9kZWwge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yKGRheVNlcmllcywgYnJlYWtPbldlZWtzKSB7XHJcbiAgICAgICAgICAgIGxldCB7IGRhdGVzIH0gPSBkYXlTZXJpZXM7XHJcbiAgICAgICAgICAgIGxldCBkYXlzUGVyUm93O1xyXG4gICAgICAgICAgICBsZXQgZmlyc3REYXk7XHJcbiAgICAgICAgICAgIGxldCByb3dDbnQ7XHJcbiAgICAgICAgICAgIGlmIChicmVha09uV2Vla3MpIHtcclxuICAgICAgICAgICAgICAgIC8vIGNvdW50IGNvbHVtbnMgdW50aWwgdGhlIGRheS1vZi13ZWVrIHJlcGVhdHNcclxuICAgICAgICAgICAgICAgIGZpcnN0RGF5ID0gZGF0ZXNbMF0uZ2V0VVRDRGF5KCk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGRheXNQZXJSb3cgPSAxOyBkYXlzUGVyUm93IDwgZGF0ZXMubGVuZ3RoOyBkYXlzUGVyUm93ICs9IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0ZXNbZGF5c1BlclJvd10uZ2V0VVRDRGF5KCkgPT09IGZpcnN0RGF5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJvd0NudCA9IE1hdGguY2VpbChkYXRlcy5sZW5ndGggLyBkYXlzUGVyUm93KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJvd0NudCA9IDE7XHJcbiAgICAgICAgICAgICAgICBkYXlzUGVyUm93ID0gZGF0ZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMucm93Q250ID0gcm93Q250O1xyXG4gICAgICAgICAgICB0aGlzLmNvbENudCA9IGRheXNQZXJSb3c7XHJcbiAgICAgICAgICAgIHRoaXMuZGF5U2VyaWVzID0gZGF5U2VyaWVzO1xyXG4gICAgICAgICAgICB0aGlzLmNlbGxzID0gdGhpcy5idWlsZENlbGxzKCk7XHJcbiAgICAgICAgICAgIHRoaXMuaGVhZGVyRGF0ZXMgPSB0aGlzLmJ1aWxkSGVhZGVyRGF0ZXMoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYnVpbGRDZWxscygpIHtcclxuICAgICAgICAgICAgbGV0IHJvd3MgPSBbXTtcclxuICAgICAgICAgICAgZm9yIChsZXQgcm93ID0gMDsgcm93IDwgdGhpcy5yb3dDbnQ7IHJvdyArPSAxKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgY2VsbHMgPSBbXTtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGNvbCA9IDA7IGNvbCA8IHRoaXMuY29sQ250OyBjb2wgKz0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNlbGxzLnB1c2godGhpcy5idWlsZENlbGwocm93LCBjb2wpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJvd3MucHVzaChjZWxscyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJvd3M7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJ1aWxkQ2VsbChyb3csIGNvbCkge1xyXG4gICAgICAgICAgICBsZXQgZGF0ZSA9IHRoaXMuZGF5U2VyaWVzLmRhdGVzW3JvdyAqIHRoaXMuY29sQ250ICsgY29sXTtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGtleTogZGF0ZS50b0lTT1N0cmluZygpLFxyXG4gICAgICAgICAgICAgICAgZGF0ZSxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYnVpbGRIZWFkZXJEYXRlcygpIHtcclxuICAgICAgICAgICAgbGV0IGRhdGVzID0gW107XHJcbiAgICAgICAgICAgIGZvciAobGV0IGNvbCA9IDA7IGNvbCA8IHRoaXMuY29sQ250OyBjb2wgKz0gMSkge1xyXG4gICAgICAgICAgICAgICAgZGF0ZXMucHVzaCh0aGlzLmNlbGxzWzBdW2NvbF0uZGF0ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGRhdGVzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzbGljZVJhbmdlKHJhbmdlKSB7XHJcbiAgICAgICAgICAgIGxldCB7IGNvbENudCB9ID0gdGhpcztcclxuICAgICAgICAgICAgbGV0IHNlcmllc1NlZyA9IHRoaXMuZGF5U2VyaWVzLnNsaWNlUmFuZ2UocmFuZ2UpO1xyXG4gICAgICAgICAgICBsZXQgc2VncyA9IFtdO1xyXG4gICAgICAgICAgICBpZiAoc2VyaWVzU2VnKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgeyBmaXJzdEluZGV4LCBsYXN0SW5kZXggfSA9IHNlcmllc1NlZztcclxuICAgICAgICAgICAgICAgIGxldCBpbmRleCA9IGZpcnN0SW5kZXg7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoaW5kZXggPD0gbGFzdEluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJvdyA9IE1hdGguZmxvb3IoaW5kZXggLyBjb2xDbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBuZXh0SW5kZXggPSBNYXRoLm1pbigocm93ICsgMSkgKiBjb2xDbnQsIGxhc3RJbmRleCArIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNlZ3MucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3RDb2w6IGluZGV4ICUgY29sQ250LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0Q29sOiAobmV4dEluZGV4IC0gMSkgJSBjb2xDbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzU3RhcnQ6IHNlcmllc1NlZy5pc1N0YXJ0ICYmIGluZGV4ID09PSBmaXJzdEluZGV4LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0VuZDogc2VyaWVzU2VnLmlzRW5kICYmIChuZXh0SW5kZXggLSAxKSA9PT0gbGFzdEluZGV4LFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gbmV4dEluZGV4O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBzZWdzO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBjbGFzcyBTbGljZXIge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgICAgICB0aGlzLnNsaWNlQnVzaW5lc3NIb3VycyA9IG1lbW9pemUodGhpcy5fc2xpY2VCdXNpbmVzc0hvdXJzKTtcclxuICAgICAgICAgICAgdGhpcy5zbGljZURhdGVTZWxlY3Rpb24gPSBtZW1vaXplKHRoaXMuX3NsaWNlRGF0ZVNwYW4pO1xyXG4gICAgICAgICAgICB0aGlzLnNsaWNlRXZlbnRTdG9yZSA9IG1lbW9pemUodGhpcy5fc2xpY2VFdmVudFN0b3JlKTtcclxuICAgICAgICAgICAgdGhpcy5zbGljZUV2ZW50RHJhZyA9IG1lbW9pemUodGhpcy5fc2xpY2VJbnRlcmFjdGlvbik7XHJcbiAgICAgICAgICAgIHRoaXMuc2xpY2VFdmVudFJlc2l6ZSA9IG1lbW9pemUodGhpcy5fc2xpY2VJbnRlcmFjdGlvbik7XHJcbiAgICAgICAgICAgIHRoaXMuZm9yY2VEYXlJZkxpc3RJdGVtID0gZmFsc2U7IC8vIGhhY2tcclxuICAgICAgICB9XHJcbiAgICAgICAgc2xpY2VQcm9wcyhwcm9wcywgZGF0ZVByb2ZpbGUsIG5leHREYXlUaHJlc2hvbGQsIGNvbnRleHQsIC4uLmV4dHJhQXJncykge1xyXG4gICAgICAgICAgICBsZXQgeyBldmVudFVpQmFzZXMgfSA9IHByb3BzO1xyXG4gICAgICAgICAgICBsZXQgZXZlbnRTZWdzID0gdGhpcy5zbGljZUV2ZW50U3RvcmUocHJvcHMuZXZlbnRTdG9yZSwgZXZlbnRVaUJhc2VzLCBkYXRlUHJvZmlsZSwgbmV4dERheVRocmVzaG9sZCwgLi4uZXh0cmFBcmdzKTtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGRhdGVTZWxlY3Rpb25TZWdzOiB0aGlzLnNsaWNlRGF0ZVNlbGVjdGlvbihwcm9wcy5kYXRlU2VsZWN0aW9uLCBkYXRlUHJvZmlsZSwgbmV4dERheVRocmVzaG9sZCwgZXZlbnRVaUJhc2VzLCBjb250ZXh0LCAuLi5leHRyYUFyZ3MpLFxyXG4gICAgICAgICAgICAgICAgYnVzaW5lc3NIb3VyU2VnczogdGhpcy5zbGljZUJ1c2luZXNzSG91cnMocHJvcHMuYnVzaW5lc3NIb3VycywgZGF0ZVByb2ZpbGUsIG5leHREYXlUaHJlc2hvbGQsIGNvbnRleHQsIC4uLmV4dHJhQXJncyksXHJcbiAgICAgICAgICAgICAgICBmZ0V2ZW50U2VnczogZXZlbnRTZWdzLmZnLFxyXG4gICAgICAgICAgICAgICAgYmdFdmVudFNlZ3M6IGV2ZW50U2Vncy5iZyxcclxuICAgICAgICAgICAgICAgIGV2ZW50RHJhZzogdGhpcy5zbGljZUV2ZW50RHJhZyhwcm9wcy5ldmVudERyYWcsIGV2ZW50VWlCYXNlcywgZGF0ZVByb2ZpbGUsIG5leHREYXlUaHJlc2hvbGQsIC4uLmV4dHJhQXJncyksXHJcbiAgICAgICAgICAgICAgICBldmVudFJlc2l6ZTogdGhpcy5zbGljZUV2ZW50UmVzaXplKHByb3BzLmV2ZW50UmVzaXplLCBldmVudFVpQmFzZXMsIGRhdGVQcm9maWxlLCBuZXh0RGF5VGhyZXNob2xkLCAuLi5leHRyYUFyZ3MpLFxyXG4gICAgICAgICAgICAgICAgZXZlbnRTZWxlY3Rpb246IHByb3BzLmV2ZW50U2VsZWN0aW9uLFxyXG4gICAgICAgICAgICB9OyAvLyBUT0RPOiBnaXZlIGludGVyYWN0aW9uU2Vncz9cclxuICAgICAgICB9XHJcbiAgICAgICAgc2xpY2VOb3dEYXRlKC8vIGRvZXMgbm90IG1lbW9pemVcclxuICAgICAgICBkYXRlLCBkYXRlUHJvZmlsZSwgbmV4dERheVRocmVzaG9sZCwgY29udGV4dCwgLi4uZXh0cmFBcmdzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zbGljZURhdGVTcGFuKHsgcmFuZ2U6IHsgc3RhcnQ6IGRhdGUsIGVuZDogYWRkTXMoZGF0ZSwgMSkgfSwgYWxsRGF5OiBmYWxzZSB9LCAvLyBhZGQgMSBtcywgcHJvdGVjdCBhZ2FpbnN0IG51bGwgcmFuZ2VcclxuICAgICAgICAgICAgZGF0ZVByb2ZpbGUsIG5leHREYXlUaHJlc2hvbGQsIHt9LCBjb250ZXh0LCAuLi5leHRyYUFyZ3MpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBfc2xpY2VCdXNpbmVzc0hvdXJzKGJ1c2luZXNzSG91cnMsIGRhdGVQcm9maWxlLCBuZXh0RGF5VGhyZXNob2xkLCBjb250ZXh0LCAuLi5leHRyYUFyZ3MpIHtcclxuICAgICAgICAgICAgaWYgKCFidXNpbmVzc0hvdXJzKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NsaWNlRXZlbnRTdG9yZShleHBhbmRSZWN1cnJpbmcoYnVzaW5lc3NIb3VycywgY29tcHV0ZUFjdGl2ZVJhbmdlKGRhdGVQcm9maWxlLCBCb29sZWFuKG5leHREYXlUaHJlc2hvbGQpKSwgY29udGV4dCksIHt9LCBkYXRlUHJvZmlsZSwgbmV4dERheVRocmVzaG9sZCwgLi4uZXh0cmFBcmdzKS5iZztcclxuICAgICAgICB9XHJcbiAgICAgICAgX3NsaWNlRXZlbnRTdG9yZShldmVudFN0b3JlLCBldmVudFVpQmFzZXMsIGRhdGVQcm9maWxlLCBuZXh0RGF5VGhyZXNob2xkLCAuLi5leHRyYUFyZ3MpIHtcclxuICAgICAgICAgICAgaWYgKGV2ZW50U3RvcmUpIHtcclxuICAgICAgICAgICAgICAgIGxldCByYW5nZVJlcyA9IHNsaWNlRXZlbnRTdG9yZShldmVudFN0b3JlLCBldmVudFVpQmFzZXMsIGNvbXB1dGVBY3RpdmVSYW5nZShkYXRlUHJvZmlsZSwgQm9vbGVhbihuZXh0RGF5VGhyZXNob2xkKSksIG5leHREYXlUaHJlc2hvbGQpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICBiZzogdGhpcy5zbGljZUV2ZW50UmFuZ2VzKHJhbmdlUmVzLmJnLCBleHRyYUFyZ3MpLFxyXG4gICAgICAgICAgICAgICAgICAgIGZnOiB0aGlzLnNsaWNlRXZlbnRSYW5nZXMocmFuZ2VSZXMuZmcsIGV4dHJhQXJncyksXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB7IGJnOiBbXSwgZmc6IFtdIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9zbGljZUludGVyYWN0aW9uKGludGVyYWN0aW9uLCBldmVudFVpQmFzZXMsIGRhdGVQcm9maWxlLCBuZXh0RGF5VGhyZXNob2xkLCAuLi5leHRyYUFyZ3MpIHtcclxuICAgICAgICAgICAgaWYgKCFpbnRlcmFjdGlvbikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IHJhbmdlUmVzID0gc2xpY2VFdmVudFN0b3JlKGludGVyYWN0aW9uLm11dGF0ZWRFdmVudHMsIGV2ZW50VWlCYXNlcywgY29tcHV0ZUFjdGl2ZVJhbmdlKGRhdGVQcm9maWxlLCBCb29sZWFuKG5leHREYXlUaHJlc2hvbGQpKSwgbmV4dERheVRocmVzaG9sZCk7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBzZWdzOiB0aGlzLnNsaWNlRXZlbnRSYW5nZXMocmFuZ2VSZXMuZmcsIGV4dHJhQXJncyksXHJcbiAgICAgICAgICAgICAgICBhZmZlY3RlZEluc3RhbmNlczogaW50ZXJhY3Rpb24uYWZmZWN0ZWRFdmVudHMuaW5zdGFuY2VzLFxyXG4gICAgICAgICAgICAgICAgaXNFdmVudDogaW50ZXJhY3Rpb24uaXNFdmVudCxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgX3NsaWNlRGF0ZVNwYW4oZGF0ZVNwYW4sIGRhdGVQcm9maWxlLCBuZXh0RGF5VGhyZXNob2xkLCBldmVudFVpQmFzZXMsIGNvbnRleHQsIC4uLmV4dHJhQXJncykge1xyXG4gICAgICAgICAgICBpZiAoIWRhdGVTcGFuKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IGFjdGl2ZVJhbmdlID0gY29tcHV0ZUFjdGl2ZVJhbmdlKGRhdGVQcm9maWxlLCBCb29sZWFuKG5leHREYXlUaHJlc2hvbGQpKTtcclxuICAgICAgICAgICAgbGV0IGFjdGl2ZURhdGVTcGFuUmFuZ2UgPSBpbnRlcnNlY3RSYW5nZXMoZGF0ZVNwYW4ucmFuZ2UsIGFjdGl2ZVJhbmdlKTtcclxuICAgICAgICAgICAgaWYgKGFjdGl2ZURhdGVTcGFuUmFuZ2UpIHtcclxuICAgICAgICAgICAgICAgIGRhdGVTcGFuID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkYXRlU3BhbiksIHsgcmFuZ2U6IGFjdGl2ZURhdGVTcGFuUmFuZ2UgfSk7XHJcbiAgICAgICAgICAgICAgICBsZXQgZXZlbnRSYW5nZSA9IGZhYnJpY2F0ZUV2ZW50UmFuZ2UoZGF0ZVNwYW4sIGV2ZW50VWlCYXNlcywgY29udGV4dCk7XHJcbiAgICAgICAgICAgICAgICBsZXQgc2VncyA9IHRoaXMuc2xpY2VSYW5nZShkYXRlU3Bhbi5yYW5nZSwgLi4uZXh0cmFBcmdzKTtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IHNlZyBvZiBzZWdzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VnLmV2ZW50UmFuZ2UgPSBldmVudFJhbmdlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlZ3M7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKlxyXG4gICAgICAgIFwiY29tcGxldGVcIiBzZWcgbWVhbnMgaXQgaGFzIGNvbXBvbmVudCBhbmQgZXZlbnRSYW5nZVxyXG4gICAgICAgICovXHJcbiAgICAgICAgc2xpY2VFdmVudFJhbmdlcyhldmVudFJhbmdlcywgZXh0cmFBcmdzKSB7XHJcbiAgICAgICAgICAgIGxldCBzZWdzID0gW107XHJcbiAgICAgICAgICAgIGZvciAobGV0IGV2ZW50UmFuZ2Ugb2YgZXZlbnRSYW5nZXMpIHtcclxuICAgICAgICAgICAgICAgIHNlZ3MucHVzaCguLi50aGlzLnNsaWNlRXZlbnRSYW5nZShldmVudFJhbmdlLCBleHRyYUFyZ3MpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gc2VncztcclxuICAgICAgICB9XHJcbiAgICAgICAgLypcclxuICAgICAgICBcImNvbXBsZXRlXCIgc2VnIG1lYW5zIGl0IGhhcyBjb21wb25lbnQgYW5kIGV2ZW50UmFuZ2VcclxuICAgICAgICAqL1xyXG4gICAgICAgIHNsaWNlRXZlbnRSYW5nZShldmVudFJhbmdlLCBleHRyYUFyZ3MpIHtcclxuICAgICAgICAgICAgbGV0IGRhdGVSYW5nZSA9IGV2ZW50UmFuZ2UucmFuZ2U7XHJcbiAgICAgICAgICAgIC8vIGhhY2sgdG8gbWFrZSBtdWx0aS1kYXkgZXZlbnRzIHRoYXQgYXJlIGJlaW5nIGZvcmNlLWRpc3BsYXllZCBhcyBsaXN0LWl0ZW1zIHRvIHRha2UgdXAgb25seSBvbmUgZGF5XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmZvcmNlRGF5SWZMaXN0SXRlbSAmJiBldmVudFJhbmdlLnVpLmRpc3BsYXkgPT09ICdsaXN0LWl0ZW0nKSB7XHJcbiAgICAgICAgICAgICAgICBkYXRlUmFuZ2UgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IGRhdGVSYW5nZS5zdGFydCxcclxuICAgICAgICAgICAgICAgICAgICBlbmQ6IGFkZERheXMoZGF0ZVJhbmdlLnN0YXJ0LCAxKSxcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IHNlZ3MgPSB0aGlzLnNsaWNlUmFuZ2UoZGF0ZVJhbmdlLCAuLi5leHRyYUFyZ3MpO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBzZWcgb2Ygc2Vncykge1xyXG4gICAgICAgICAgICAgICAgc2VnLmV2ZW50UmFuZ2UgPSBldmVudFJhbmdlO1xyXG4gICAgICAgICAgICAgICAgc2VnLmlzU3RhcnQgPSBldmVudFJhbmdlLmlzU3RhcnQgJiYgc2VnLmlzU3RhcnQ7XHJcbiAgICAgICAgICAgICAgICBzZWcuaXNFbmQgPSBldmVudFJhbmdlLmlzRW5kICYmIHNlZy5pc0VuZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gc2VncztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKlxyXG4gICAgZm9yIGluY29ycG9yYXRpbmcgc2xvdE1pblRpbWUvc2xvdE1heFRpbWUgaWYgYXBwcm9wcmlhdGVcclxuICAgIFRPRE86IHNob3VsZCBiZSBwYXJ0IG9mIERhdGVQcm9maWxlIVxyXG4gICAgVGltZWxpbmVEYXRlUHJvZmlsZSBhbHJlYWR5IGRvZXMgdGhpcyBidHdcclxuICAgICovXHJcbiAgICBmdW5jdGlvbiBjb21wdXRlQWN0aXZlUmFuZ2UoZGF0ZVByb2ZpbGUsIGlzQ29tcG9uZW50QWxsRGF5KSB7XHJcbiAgICAgICAgbGV0IHJhbmdlID0gZGF0ZVByb2ZpbGUuYWN0aXZlUmFuZ2U7XHJcbiAgICAgICAgaWYgKGlzQ29tcG9uZW50QWxsRGF5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiByYW5nZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgc3RhcnQ6IGFkZE1zKHJhbmdlLnN0YXJ0LCBkYXRlUHJvZmlsZS5zbG90TWluVGltZS5taWxsaXNlY29uZHMpLFxyXG4gICAgICAgICAgICBlbmQ6IGFkZE1zKHJhbmdlLmVuZCwgZGF0ZVByb2ZpbGUuc2xvdE1heFRpbWUubWlsbGlzZWNvbmRzIC0gODY0ZTUpLCAvLyA4NjRlNSA9IG1zIGluIGEgZGF5XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiByZWR1Y2VFdmVudFN0b3JlKGV2ZW50U3RvcmUsIGFjdGlvbiwgZXZlbnRTb3VyY2VzLCBkYXRlUHJvZmlsZSwgY29udGV4dCkge1xyXG4gICAgICAgIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcclxuICAgICAgICAgICAgY2FzZSAnUkVDRUlWRV9FVkVOVFMnOiAvLyByYXdcclxuICAgICAgICAgICAgICAgIHJldHVybiByZWNlaXZlUmF3RXZlbnRzKGV2ZW50U3RvcmUsIGV2ZW50U291cmNlc1thY3Rpb24uc291cmNlSWRdLCBhY3Rpb24uZmV0Y2hJZCwgYWN0aW9uLmZldGNoUmFuZ2UsIGFjdGlvbi5yYXdFdmVudHMsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICBjYXNlICdSRVNFVF9SQVdfRVZFTlRTJzpcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXNldFJhd0V2ZW50cyhldmVudFN0b3JlLCBldmVudFNvdXJjZXNbYWN0aW9uLnNvdXJjZUlkXSwgYWN0aW9uLnJhd0V2ZW50cywgZGF0ZVByb2ZpbGUuYWN0aXZlUmFuZ2UsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICBjYXNlICdBRERfRVZFTlRTJzogLy8gYWxyZWFkeSBwYXJzZWQsIGJ1dCBub3QgZXhwYW5kZWRcclxuICAgICAgICAgICAgICAgIHJldHVybiBhZGRFdmVudChldmVudFN0b3JlLCBhY3Rpb24uZXZlbnRTdG9yZSwgLy8gbmV3IG9uZXNcclxuICAgICAgICAgICAgICAgIGRhdGVQcm9maWxlID8gZGF0ZVByb2ZpbGUuYWN0aXZlUmFuZ2UgOiBudWxsLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgY2FzZSAnUkVTRVRfRVZFTlRTJzpcclxuICAgICAgICAgICAgICAgIHJldHVybiBhY3Rpb24uZXZlbnRTdG9yZTtcclxuICAgICAgICAgICAgY2FzZSAnTUVSR0VfRVZFTlRTJzogLy8gYWxyZWFkeSBwYXJzZWQgYW5kIGV4cGFuZGVkXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbWVyZ2VFdmVudFN0b3JlcyhldmVudFN0b3JlLCBhY3Rpb24uZXZlbnRTdG9yZSk7XHJcbiAgICAgICAgICAgIGNhc2UgJ1BSRVYnOiAvLyBUT0RPOiBob3cgZG8gd2UgdHJhY2sgYWxsIGFjdGlvbnMgdGhhdCBhZmZlY3QgZGF0ZVByb2ZpbGUgOihcclxuICAgICAgICAgICAgY2FzZSAnTkVYVCc6XHJcbiAgICAgICAgICAgIGNhc2UgJ0NIQU5HRV9EQVRFJzpcclxuICAgICAgICAgICAgY2FzZSAnQ0hBTkdFX1ZJRVdfVFlQRSc6XHJcbiAgICAgICAgICAgICAgICBpZiAoZGF0ZVByb2ZpbGUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXhwYW5kUmVjdXJyaW5nKGV2ZW50U3RvcmUsIGRhdGVQcm9maWxlLmFjdGl2ZVJhbmdlLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBldmVudFN0b3JlO1xyXG4gICAgICAgICAgICBjYXNlICdSRU1PVkVfRVZFTlRTJzpcclxuICAgICAgICAgICAgICAgIHJldHVybiBleGNsdWRlU3ViRXZlbnRTdG9yZShldmVudFN0b3JlLCBhY3Rpb24uZXZlbnRTdG9yZSk7XHJcbiAgICAgICAgICAgIGNhc2UgJ1JFTU9WRV9FVkVOVF9TT1VSQ0UnOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4Y2x1ZGVFdmVudHNCeVNvdXJjZUlkKGV2ZW50U3RvcmUsIGFjdGlvbi5zb3VyY2VJZCk7XHJcbiAgICAgICAgICAgIGNhc2UgJ1JFTU9WRV9BTExfRVZFTlRfU09VUkNFUyc6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmlsdGVyRXZlbnRTdG9yZURlZnMoZXZlbnRTdG9yZSwgKGV2ZW50RGVmKSA9PiAoIWV2ZW50RGVmLnNvdXJjZUlkIC8vIG9ubHkga2VlcCBldmVudHMgd2l0aCBubyBzb3VyY2UgaWRcclxuICAgICAgICAgICAgICAgICkpO1xyXG4gICAgICAgICAgICBjYXNlICdSRU1PVkVfQUxMX0VWRU5UUyc6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlRW1wdHlFdmVudFN0b3JlKCk7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZXZlbnRTdG9yZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiByZWNlaXZlUmF3RXZlbnRzKGV2ZW50U3RvcmUsIGV2ZW50U291cmNlLCBmZXRjaElkLCBmZXRjaFJhbmdlLCByYXdFdmVudHMsIGNvbnRleHQpIHtcclxuICAgICAgICBpZiAoZXZlbnRTb3VyY2UgJiYgLy8gbm90IGFscmVhZHkgcmVtb3ZlZFxyXG4gICAgICAgICAgICBmZXRjaElkID09PSBldmVudFNvdXJjZS5sYXRlc3RGZXRjaElkIC8vIFRPRE86IHdpc2ggdGhpcyBsb2dpYyB3YXMgYWx3YXlzIGluIGV2ZW50LXNvdXJjZXNcclxuICAgICAgICApIHtcclxuICAgICAgICAgICAgbGV0IHN1YnNldCA9IHBhcnNlRXZlbnRzKHRyYW5zZm9ybVJhd0V2ZW50cyhyYXdFdmVudHMsIGV2ZW50U291cmNlLCBjb250ZXh0KSwgZXZlbnRTb3VyY2UsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICBpZiAoZmV0Y2hSYW5nZSkge1xyXG4gICAgICAgICAgICAgICAgc3Vic2V0ID0gZXhwYW5kUmVjdXJyaW5nKHN1YnNldCwgZmV0Y2hSYW5nZSwgY29udGV4dCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG1lcmdlRXZlbnRTdG9yZXMoZXhjbHVkZUV2ZW50c0J5U291cmNlSWQoZXZlbnRTdG9yZSwgZXZlbnRTb3VyY2Uuc291cmNlSWQpLCBzdWJzZXQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZXZlbnRTdG9yZTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHJlc2V0UmF3RXZlbnRzKGV4aXN0aW5nRXZlbnRTdG9yZSwgZXZlbnRTb3VyY2UsIHJhd0V2ZW50cywgYWN0aXZlUmFuZ2UsIGNvbnRleHQpIHtcclxuICAgICAgICBjb25zdCB7IGRlZklkTWFwLCBpbnN0YW5jZUlkTWFwIH0gPSBidWlsZFB1YmxpY0lkTWFwcyhleGlzdGluZ0V2ZW50U3RvcmUpO1xyXG4gICAgICAgIGxldCBuZXdFdmVudFN0b3JlID0gcGFyc2VFdmVudHModHJhbnNmb3JtUmF3RXZlbnRzKHJhd0V2ZW50cywgZXZlbnRTb3VyY2UsIGNvbnRleHQpLCBldmVudFNvdXJjZSwgY29udGV4dCwgZmFsc2UsIGRlZklkTWFwLCBpbnN0YW5jZUlkTWFwKTtcclxuICAgICAgICByZXR1cm4gZXhwYW5kUmVjdXJyaW5nKG5ld0V2ZW50U3RvcmUsIGFjdGl2ZVJhbmdlLCBjb250ZXh0KTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHRyYW5zZm9ybVJhd0V2ZW50cyhyYXdFdmVudHMsIGV2ZW50U291cmNlLCBjb250ZXh0KSB7XHJcbiAgICAgICAgbGV0IGNhbEVhY2hUcmFuc2Zvcm0gPSBjb250ZXh0Lm9wdGlvbnMuZXZlbnREYXRhVHJhbnNmb3JtO1xyXG4gICAgICAgIGxldCBzb3VyY2VFYWNoVHJhbnNmb3JtID0gZXZlbnRTb3VyY2UgPyBldmVudFNvdXJjZS5ldmVudERhdGFUcmFuc2Zvcm0gOiBudWxsO1xyXG4gICAgICAgIGlmIChzb3VyY2VFYWNoVHJhbnNmb3JtKSB7XHJcbiAgICAgICAgICAgIHJhd0V2ZW50cyA9IHRyYW5zZm9ybUVhY2hSYXdFdmVudChyYXdFdmVudHMsIHNvdXJjZUVhY2hUcmFuc2Zvcm0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY2FsRWFjaFRyYW5zZm9ybSkge1xyXG4gICAgICAgICAgICByYXdFdmVudHMgPSB0cmFuc2Zvcm1FYWNoUmF3RXZlbnQocmF3RXZlbnRzLCBjYWxFYWNoVHJhbnNmb3JtKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJhd0V2ZW50cztcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHRyYW5zZm9ybUVhY2hSYXdFdmVudChyYXdFdmVudHMsIGZ1bmMpIHtcclxuICAgICAgICBsZXQgcmVmaW5lZEV2ZW50cztcclxuICAgICAgICBpZiAoIWZ1bmMpIHtcclxuICAgICAgICAgICAgcmVmaW5lZEV2ZW50cyA9IHJhd0V2ZW50cztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJlZmluZWRFdmVudHMgPSBbXTtcclxuICAgICAgICAgICAgZm9yIChsZXQgcmF3RXZlbnQgb2YgcmF3RXZlbnRzKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgcmVmaW5lZEV2ZW50ID0gZnVuYyhyYXdFdmVudCk7XHJcbiAgICAgICAgICAgICAgICBpZiAocmVmaW5lZEV2ZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVmaW5lZEV2ZW50cy5wdXNoKHJlZmluZWRFdmVudCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyZWZpbmVkRXZlbnQgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlZmluZWRFdmVudHMucHVzaChyYXdFdmVudCk7XHJcbiAgICAgICAgICAgICAgICB9IC8vIGlmIGEgZGlmZmVyZW50IGZhbHN5IHZhbHVlLCBkbyBub3RoaW5nXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlZmluZWRFdmVudHM7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBhZGRFdmVudChldmVudFN0b3JlLCBzdWJzZXQsIGV4cGFuZFJhbmdlLCBjb250ZXh0KSB7XHJcbiAgICAgICAgaWYgKGV4cGFuZFJhbmdlKSB7XHJcbiAgICAgICAgICAgIHN1YnNldCA9IGV4cGFuZFJlY3VycmluZyhzdWJzZXQsIGV4cGFuZFJhbmdlLCBjb250ZXh0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG1lcmdlRXZlbnRTdG9yZXMoZXZlbnRTdG9yZSwgc3Vic2V0KTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHJlem9uZUV2ZW50U3RvcmVEYXRlcyhldmVudFN0b3JlLCBvbGREYXRlRW52LCBuZXdEYXRlRW52KSB7XHJcbiAgICAgICAgbGV0IHsgZGVmcyB9ID0gZXZlbnRTdG9yZTtcclxuICAgICAgICBsZXQgaW5zdGFuY2VzID0gbWFwSGFzaChldmVudFN0b3JlLmluc3RhbmNlcywgKGluc3RhbmNlKSA9PiB7XHJcbiAgICAgICAgICAgIGxldCBkZWYgPSBkZWZzW2luc3RhbmNlLmRlZklkXTtcclxuICAgICAgICAgICAgaWYgKGRlZi5hbGxEYXkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpbnN0YW5jZTsgLy8gaXNuJ3QgZGVwZW5kZW50IG9uIHRpbWV6b25lXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgaW5zdGFuY2UpLCB7IHJhbmdlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IG5ld0RhdGVFbnYuY3JlYXRlTWFya2VyKG9sZERhdGVFbnYudG9EYXRlKGluc3RhbmNlLnJhbmdlLnN0YXJ0LCBpbnN0YW5jZS5mb3JjZWRTdGFydFR6bykpLFxyXG4gICAgICAgICAgICAgICAgICAgIGVuZDogbmV3RGF0ZUVudi5jcmVhdGVNYXJrZXIob2xkRGF0ZUVudi50b0RhdGUoaW5zdGFuY2UucmFuZ2UuZW5kLCBpbnN0YW5jZS5mb3JjZWRFbmRUem8pKSxcclxuICAgICAgICAgICAgICAgIH0sIGZvcmNlZFN0YXJ0VHpvOiBuZXdEYXRlRW52LmNhbkNvbXB1dGVPZmZzZXQgPyBudWxsIDogaW5zdGFuY2UuZm9yY2VkU3RhcnRUem8sIGZvcmNlZEVuZFR6bzogbmV3RGF0ZUVudi5jYW5Db21wdXRlT2Zmc2V0ID8gbnVsbCA6IGluc3RhbmNlLmZvcmNlZEVuZFR6byB9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4geyBkZWZzLCBpbnN0YW5jZXMgfTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGV4Y2x1ZGVFdmVudHNCeVNvdXJjZUlkKGV2ZW50U3RvcmUsIHNvdXJjZUlkKSB7XHJcbiAgICAgICAgcmV0dXJuIGZpbHRlckV2ZW50U3RvcmVEZWZzKGV2ZW50U3RvcmUsIChldmVudERlZikgPT4gZXZlbnREZWYuc291cmNlSWQgIT09IHNvdXJjZUlkKTtcclxuICAgIH1cclxuICAgIC8vIFFVRVNUSU9OOiB3aHkgbm90IGp1c3QgcmV0dXJuIGluc3RhbmNlcz8gZG8gYSBnZW5lcmFsIG9iamVjdC1wcm9wZXJ0eS1leGNsdXNpb24gdXRpbFxyXG4gICAgZnVuY3Rpb24gZXhjbHVkZUluc3RhbmNlcyhldmVudFN0b3JlLCByZW1vdmFscykge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGRlZnM6IGV2ZW50U3RvcmUuZGVmcyxcclxuICAgICAgICAgICAgaW5zdGFuY2VzOiBmaWx0ZXJIYXNoKGV2ZW50U3RvcmUuaW5zdGFuY2VzLCAoaW5zdGFuY2UpID0+ICFyZW1vdmFsc1tpbnN0YW5jZS5pbnN0YW5jZUlkXSksXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGJ1aWxkUHVibGljSWRNYXBzKGV2ZW50U3RvcmUpIHtcclxuICAgICAgICBjb25zdCB7IGRlZnMsIGluc3RhbmNlcyB9ID0gZXZlbnRTdG9yZTtcclxuICAgICAgICBjb25zdCBkZWZJZE1hcCA9IHt9O1xyXG4gICAgICAgIGNvbnN0IGluc3RhbmNlSWRNYXAgPSB7fTtcclxuICAgICAgICBmb3IgKGxldCBkZWZJZCBpbiBkZWZzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRlZiA9IGRlZnNbZGVmSWRdO1xyXG4gICAgICAgICAgICBjb25zdCB7IHB1YmxpY0lkIH0gPSBkZWY7XHJcbiAgICAgICAgICAgIGlmIChwdWJsaWNJZCkge1xyXG4gICAgICAgICAgICAgICAgZGVmSWRNYXBbcHVibGljSWRdID0gZGVmSWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChsZXQgaW5zdGFuY2VJZCBpbiBpbnN0YW5jZXMpIHtcclxuICAgICAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBpbnN0YW5jZXNbaW5zdGFuY2VJZF07XHJcbiAgICAgICAgICAgIGNvbnN0IGRlZiA9IGRlZnNbaW5zdGFuY2UuZGVmSWRdO1xyXG4gICAgICAgICAgICBjb25zdCB7IHB1YmxpY0lkIH0gPSBkZWY7XHJcbiAgICAgICAgICAgIGlmIChwdWJsaWNJZCkge1xyXG4gICAgICAgICAgICAgICAgaW5zdGFuY2VJZE1hcFtwdWJsaWNJZF0gPSBpbnN0YW5jZUlkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7IGRlZklkTWFwLCBpbnN0YW5jZUlkTWFwIH07XHJcbiAgICB9XHJcblxyXG4gICAgLy8gaGlnaC1sZXZlbCBzZWdtZW50aW5nLWF3YXJlIHRlc3RlciBmdW5jdGlvbnNcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgZnVuY3Rpb24gaXNJbnRlcmFjdGlvblZhbGlkKGludGVyYWN0aW9uLCBkYXRlUHJvZmlsZSwgY29udGV4dCkge1xyXG4gICAgICAgIGxldCB7IGluc3RhbmNlcyB9ID0gaW50ZXJhY3Rpb24ubXV0YXRlZEV2ZW50cztcclxuICAgICAgICBmb3IgKGxldCBpbnN0YW5jZUlkIGluIGluc3RhbmNlcykge1xyXG4gICAgICAgICAgICBpZiAoIXJhbmdlQ29udGFpbnNSYW5nZShkYXRlUHJvZmlsZS52YWxpZFJhbmdlLCBpbnN0YW5jZXNbaW5zdGFuY2VJZF0ucmFuZ2UpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGlzTmV3UHJvcHNWYWxpZCh7IGV2ZW50RHJhZzogaW50ZXJhY3Rpb24gfSwgY29udGV4dCk7IC8vIEhBQ0s6IHRoZSBldmVudERyYWcgcHJvcHMgaXMgdXNlZCBmb3IgQUxMIGludGVyYWN0aW9uc1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gaXNEYXRlU2VsZWN0aW9uVmFsaWQoZGF0ZVNlbGVjdGlvbiwgZGF0ZVByb2ZpbGUsIGNvbnRleHQpIHtcclxuICAgICAgICBpZiAoIXJhbmdlQ29udGFpbnNSYW5nZShkYXRlUHJvZmlsZS52YWxpZFJhbmdlLCBkYXRlU2VsZWN0aW9uLnJhbmdlKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBpc05ld1Byb3BzVmFsaWQoeyBkYXRlU2VsZWN0aW9uIH0sIGNvbnRleHQpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gaXNOZXdQcm9wc1ZhbGlkKG5ld1Byb3BzLCBjb250ZXh0KSB7XHJcbiAgICAgICAgbGV0IGNhbGVuZGFyU3RhdGUgPSBjb250ZXh0LmdldEN1cnJlbnREYXRhKCk7XHJcbiAgICAgICAgbGV0IHByb3BzID0gT2JqZWN0LmFzc2lnbih7IGJ1c2luZXNzSG91cnM6IGNhbGVuZGFyU3RhdGUuYnVzaW5lc3NIb3VycywgZGF0ZVNlbGVjdGlvbjogJycsIGV2ZW50U3RvcmU6IGNhbGVuZGFyU3RhdGUuZXZlbnRTdG9yZSwgZXZlbnRVaUJhc2VzOiBjYWxlbmRhclN0YXRlLmV2ZW50VWlCYXNlcywgZXZlbnRTZWxlY3Rpb246ICcnLCBldmVudERyYWc6IG51bGwsIGV2ZW50UmVzaXplOiBudWxsIH0sIG5ld1Byb3BzKTtcclxuICAgICAgICByZXR1cm4gKGNvbnRleHQucGx1Z2luSG9va3MuaXNQcm9wc1ZhbGlkIHx8IGlzUHJvcHNWYWxpZCkocHJvcHMsIGNvbnRleHQpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gaXNQcm9wc1ZhbGlkKHN0YXRlLCBjb250ZXh0LCBkYXRlU3Bhbk1ldGEgPSB7fSwgZmlsdGVyQ29uZmlnKSB7XHJcbiAgICAgICAgaWYgKHN0YXRlLmV2ZW50RHJhZyAmJiAhaXNJbnRlcmFjdGlvblByb3BzVmFsaWQoc3RhdGUsIGNvbnRleHQsIGRhdGVTcGFuTWV0YSwgZmlsdGVyQ29uZmlnKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzdGF0ZS5kYXRlU2VsZWN0aW9uICYmICFpc0RhdGVTZWxlY3Rpb25Qcm9wc1ZhbGlkKHN0YXRlLCBjb250ZXh0LCBkYXRlU3Bhbk1ldGEsIGZpbHRlckNvbmZpZykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIC8vIE1vdmluZyBFdmVudCBWYWxpZGF0aW9uXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIGZ1bmN0aW9uIGlzSW50ZXJhY3Rpb25Qcm9wc1ZhbGlkKHN0YXRlLCBjb250ZXh0LCBkYXRlU3Bhbk1ldGEsIGZpbHRlckNvbmZpZykge1xyXG4gICAgICAgIGxldCBjdXJyZW50U3RhdGUgPSBjb250ZXh0LmdldEN1cnJlbnREYXRhKCk7XHJcbiAgICAgICAgbGV0IGludGVyYWN0aW9uID0gc3RhdGUuZXZlbnREcmFnOyAvLyBIQUNLOiB0aGUgZXZlbnREcmFnIHByb3BzIGlzIHVzZWQgZm9yIEFMTCBpbnRlcmFjdGlvbnNcclxuICAgICAgICBsZXQgc3ViamVjdEV2ZW50U3RvcmUgPSBpbnRlcmFjdGlvbi5tdXRhdGVkRXZlbnRzO1xyXG4gICAgICAgIGxldCBzdWJqZWN0RGVmcyA9IHN1YmplY3RFdmVudFN0b3JlLmRlZnM7XHJcbiAgICAgICAgbGV0IHN1YmplY3RJbnN0YW5jZXMgPSBzdWJqZWN0RXZlbnRTdG9yZS5pbnN0YW5jZXM7XHJcbiAgICAgICAgbGV0IHN1YmplY3RDb25maWdzID0gY29tcGlsZUV2ZW50VWlzKHN1YmplY3REZWZzLCBpbnRlcmFjdGlvbi5pc0V2ZW50ID9cclxuICAgICAgICAgICAgc3RhdGUuZXZlbnRVaUJhc2VzIDpcclxuICAgICAgICAgICAgeyAnJzogY3VycmVudFN0YXRlLnNlbGVjdGlvbkNvbmZpZyB9KTtcclxuICAgICAgICBpZiAoZmlsdGVyQ29uZmlnKSB7XHJcbiAgICAgICAgICAgIHN1YmplY3RDb25maWdzID0gbWFwSGFzaChzdWJqZWN0Q29uZmlncywgZmlsdGVyQ29uZmlnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gZXhjbHVkZSB0aGUgc3ViamVjdCBldmVudHMuIFRPRE86IGV4Y2x1ZGUgZGVmcyB0b28/XHJcbiAgICAgICAgbGV0IG90aGVyRXZlbnRTdG9yZSA9IGV4Y2x1ZGVJbnN0YW5jZXMoc3RhdGUuZXZlbnRTdG9yZSwgaW50ZXJhY3Rpb24uYWZmZWN0ZWRFdmVudHMuaW5zdGFuY2VzKTtcclxuICAgICAgICBsZXQgb3RoZXJEZWZzID0gb3RoZXJFdmVudFN0b3JlLmRlZnM7XHJcbiAgICAgICAgbGV0IG90aGVySW5zdGFuY2VzID0gb3RoZXJFdmVudFN0b3JlLmluc3RhbmNlcztcclxuICAgICAgICBsZXQgb3RoZXJDb25maWdzID0gY29tcGlsZUV2ZW50VWlzKG90aGVyRGVmcywgc3RhdGUuZXZlbnRVaUJhc2VzKTtcclxuICAgICAgICBmb3IgKGxldCBzdWJqZWN0SW5zdGFuY2VJZCBpbiBzdWJqZWN0SW5zdGFuY2VzKSB7XHJcbiAgICAgICAgICAgIGxldCBzdWJqZWN0SW5zdGFuY2UgPSBzdWJqZWN0SW5zdGFuY2VzW3N1YmplY3RJbnN0YW5jZUlkXTtcclxuICAgICAgICAgICAgbGV0IHN1YmplY3RSYW5nZSA9IHN1YmplY3RJbnN0YW5jZS5yYW5nZTtcclxuICAgICAgICAgICAgbGV0IHN1YmplY3RDb25maWcgPSBzdWJqZWN0Q29uZmlnc1tzdWJqZWN0SW5zdGFuY2UuZGVmSWRdO1xyXG4gICAgICAgICAgICBsZXQgc3ViamVjdERlZiA9IHN1YmplY3REZWZzW3N1YmplY3RJbnN0YW5jZS5kZWZJZF07XHJcbiAgICAgICAgICAgIC8vIGNvbnN0cmFpbnRcclxuICAgICAgICAgICAgaWYgKCFhbGxDb25zdHJhaW50c1Bhc3Moc3ViamVjdENvbmZpZy5jb25zdHJhaW50cywgc3ViamVjdFJhbmdlLCBvdGhlckV2ZW50U3RvcmUsIHN0YXRlLmJ1c2luZXNzSG91cnMsIGNvbnRleHQpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gb3ZlcmxhcFxyXG4gICAgICAgICAgICBsZXQgeyBldmVudE92ZXJsYXAgfSA9IGNvbnRleHQub3B0aW9ucztcclxuICAgICAgICAgICAgbGV0IGV2ZW50T3ZlcmxhcEZ1bmMgPSB0eXBlb2YgZXZlbnRPdmVybGFwID09PSAnZnVuY3Rpb24nID8gZXZlbnRPdmVybGFwIDogbnVsbDtcclxuICAgICAgICAgICAgZm9yIChsZXQgb3RoZXJJbnN0YW5jZUlkIGluIG90aGVySW5zdGFuY2VzKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgb3RoZXJJbnN0YW5jZSA9IG90aGVySW5zdGFuY2VzW290aGVySW5zdGFuY2VJZF07XHJcbiAgICAgICAgICAgICAgICAvLyBpbnRlcnNlY3QhIGV2YWx1YXRlXHJcbiAgICAgICAgICAgICAgICBpZiAocmFuZ2VzSW50ZXJzZWN0KHN1YmplY3RSYW5nZSwgb3RoZXJJbnN0YW5jZS5yYW5nZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgb3RoZXJPdmVybGFwID0gb3RoZXJDb25maWdzW290aGVySW5zdGFuY2UuZGVmSWRdLm92ZXJsYXA7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gY29uc2lkZXIgdGhlIG90aGVyIGV2ZW50J3Mgb3ZlcmxhcC4gb25seSBkbyB0aGlzIGlmIHRoZSBzdWJqZWN0IGV2ZW50IGlzIGEgXCJyZWFsXCIgZXZlbnRcclxuICAgICAgICAgICAgICAgICAgICBpZiAob3RoZXJPdmVybGFwID09PSBmYWxzZSAmJiBpbnRlcmFjdGlvbi5pc0V2ZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN1YmplY3RDb25maWcub3ZlcmxhcCA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnRPdmVybGFwRnVuYyAmJiAhZXZlbnRPdmVybGFwRnVuYyhuZXcgRXZlbnRJbXBsKGNvbnRleHQsIG90aGVyRGVmc1tvdGhlckluc3RhbmNlLmRlZklkXSwgb3RoZXJJbnN0YW5jZSksIC8vIHN0aWxsIGV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3IEV2ZW50SW1wbChjb250ZXh0LCBzdWJqZWN0RGVmLCBzdWJqZWN0SW5zdGFuY2UpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGFsbG93IChhIGZ1bmN0aW9uKVxyXG4gICAgICAgICAgICBsZXQgY2FsZW5kYXJFdmVudFN0b3JlID0gY3VycmVudFN0YXRlLmV2ZW50U3RvcmU7IC8vIG5lZWQgZ2xvYmFsLXRvLWNhbGVuZGFyLCBub3QgbG9jYWwgdG8gY29tcG9uZW50IChzcGxpdHRhYmxlKXN0YXRlXHJcbiAgICAgICAgICAgIGZvciAobGV0IHN1YmplY3RBbGxvdyBvZiBzdWJqZWN0Q29uZmlnLmFsbG93cykge1xyXG4gICAgICAgICAgICAgICAgbGV0IHN1YmplY3REYXRlU3BhbiA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZGF0ZVNwYW5NZXRhKSwgeyByYW5nZTogc3ViamVjdEluc3RhbmNlLnJhbmdlLCBhbGxEYXk6IHN1YmplY3REZWYuYWxsRGF5IH0pO1xyXG4gICAgICAgICAgICAgICAgbGV0IG9yaWdEZWYgPSBjYWxlbmRhckV2ZW50U3RvcmUuZGVmc1tzdWJqZWN0RGVmLmRlZklkXTtcclxuICAgICAgICAgICAgICAgIGxldCBvcmlnSW5zdGFuY2UgPSBjYWxlbmRhckV2ZW50U3RvcmUuaW5zdGFuY2VzW3N1YmplY3RJbnN0YW5jZUlkXTtcclxuICAgICAgICAgICAgICAgIGxldCBldmVudEFwaTtcclxuICAgICAgICAgICAgICAgIGlmIChvcmlnRGVmKSB7IC8vIHdhcyBwcmV2aW91c2x5IGluIHRoZSBjYWxlbmRhclxyXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50QXBpID0gbmV3IEV2ZW50SW1wbChjb250ZXh0LCBvcmlnRGVmLCBvcmlnSW5zdGFuY2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7IC8vIHdhcyBhbiBleHRlcm5hbCBldmVudFxyXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50QXBpID0gbmV3IEV2ZW50SW1wbChjb250ZXh0LCBzdWJqZWN0RGVmKTsgLy8gbm8gaW5zdGFuY2UsIGJlY2F1c2UgaGFkIG5vIGRhdGVzXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoIXN1YmplY3RBbGxvdyhidWlsZERhdGVTcGFuQXBpV2l0aENvbnRleHQoc3ViamVjdERhdGVTcGFuLCBjb250ZXh0KSwgZXZlbnRBcGkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgLy8gRGF0ZSBTZWxlY3Rpb24gVmFsaWRhdGlvblxyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICBmdW5jdGlvbiBpc0RhdGVTZWxlY3Rpb25Qcm9wc1ZhbGlkKHN0YXRlLCBjb250ZXh0LCBkYXRlU3Bhbk1ldGEsIGZpbHRlckNvbmZpZykge1xyXG4gICAgICAgIGxldCByZWxldmFudEV2ZW50U3RvcmUgPSBzdGF0ZS5ldmVudFN0b3JlO1xyXG4gICAgICAgIGxldCByZWxldmFudERlZnMgPSByZWxldmFudEV2ZW50U3RvcmUuZGVmcztcclxuICAgICAgICBsZXQgcmVsZXZhbnRJbnN0YW5jZXMgPSByZWxldmFudEV2ZW50U3RvcmUuaW5zdGFuY2VzO1xyXG4gICAgICAgIGxldCBzZWxlY3Rpb24gPSBzdGF0ZS5kYXRlU2VsZWN0aW9uO1xyXG4gICAgICAgIGxldCBzZWxlY3Rpb25SYW5nZSA9IHNlbGVjdGlvbi5yYW5nZTtcclxuICAgICAgICBsZXQgeyBzZWxlY3Rpb25Db25maWcgfSA9IGNvbnRleHQuZ2V0Q3VycmVudERhdGEoKTtcclxuICAgICAgICBpZiAoZmlsdGVyQ29uZmlnKSB7XHJcbiAgICAgICAgICAgIHNlbGVjdGlvbkNvbmZpZyA9IGZpbHRlckNvbmZpZyhzZWxlY3Rpb25Db25maWcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBjb25zdHJhaW50XHJcbiAgICAgICAgaWYgKCFhbGxDb25zdHJhaW50c1Bhc3Moc2VsZWN0aW9uQ29uZmlnLmNvbnN0cmFpbnRzLCBzZWxlY3Rpb25SYW5nZSwgcmVsZXZhbnRFdmVudFN0b3JlLCBzdGF0ZS5idXNpbmVzc0hvdXJzLCBjb250ZXh0KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIG92ZXJsYXBcclxuICAgICAgICBsZXQgeyBzZWxlY3RPdmVybGFwIH0gPSBjb250ZXh0Lm9wdGlvbnM7XHJcbiAgICAgICAgbGV0IHNlbGVjdE92ZXJsYXBGdW5jID0gdHlwZW9mIHNlbGVjdE92ZXJsYXAgPT09ICdmdW5jdGlvbicgPyBzZWxlY3RPdmVybGFwIDogbnVsbDtcclxuICAgICAgICBmb3IgKGxldCByZWxldmFudEluc3RhbmNlSWQgaW4gcmVsZXZhbnRJbnN0YW5jZXMpIHtcclxuICAgICAgICAgICAgbGV0IHJlbGV2YW50SW5zdGFuY2UgPSByZWxldmFudEluc3RhbmNlc1tyZWxldmFudEluc3RhbmNlSWRdO1xyXG4gICAgICAgICAgICAvLyBpbnRlcnNlY3QhIGV2YWx1YXRlXHJcbiAgICAgICAgICAgIGlmIChyYW5nZXNJbnRlcnNlY3Qoc2VsZWN0aW9uUmFuZ2UsIHJlbGV2YW50SW5zdGFuY2UucmFuZ2UpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2VsZWN0aW9uQ29uZmlnLm92ZXJsYXAgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdE92ZXJsYXBGdW5jICYmICFzZWxlY3RPdmVybGFwRnVuYyhuZXcgRXZlbnRJbXBsKGNvbnRleHQsIHJlbGV2YW50RGVmc1tyZWxldmFudEluc3RhbmNlLmRlZklkXSwgcmVsZXZhbnRJbnN0YW5jZSksIG51bGwpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGFsbG93IChhIGZ1bmN0aW9uKVxyXG4gICAgICAgIGZvciAobGV0IHNlbGVjdGlvbkFsbG93IG9mIHNlbGVjdGlvbkNvbmZpZy5hbGxvd3MpIHtcclxuICAgICAgICAgICAgbGV0IGZ1bGxEYXRlU3BhbiA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZGF0ZVNwYW5NZXRhKSwgc2VsZWN0aW9uKTtcclxuICAgICAgICAgICAgaWYgKCFzZWxlY3Rpb25BbGxvdyhidWlsZERhdGVTcGFuQXBpV2l0aENvbnRleHQoZnVsbERhdGVTcGFuLCBjb250ZXh0KSwgbnVsbCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIC8vIENvbnN0cmFpbnQgVXRpbHNcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgZnVuY3Rpb24gYWxsQ29uc3RyYWludHNQYXNzKGNvbnN0cmFpbnRzLCBzdWJqZWN0UmFuZ2UsIG90aGVyRXZlbnRTdG9yZSwgYnVzaW5lc3NIb3Vyc1VuZXhwYW5kZWQsIGNvbnRleHQpIHtcclxuICAgICAgICBmb3IgKGxldCBjb25zdHJhaW50IG9mIGNvbnN0cmFpbnRzKSB7XHJcbiAgICAgICAgICAgIGlmICghYW55UmFuZ2VzQ29udGFpblJhbmdlKGNvbnN0cmFpbnRUb1Jhbmdlcyhjb25zdHJhaW50LCBzdWJqZWN0UmFuZ2UsIG90aGVyRXZlbnRTdG9yZSwgYnVzaW5lc3NIb3Vyc1VuZXhwYW5kZWQsIGNvbnRleHQpLCBzdWJqZWN0UmFuZ2UpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBjb25zdHJhaW50VG9SYW5nZXMoY29uc3RyYWludCwgc3ViamVjdFJhbmdlLCAvLyBmb3IgZXhwYW5kaW5nIGEgcmVjdXJyaW5nIGNvbnN0cmFpbnQsIG9yIGV4cGFuZGluZyBidXNpbmVzcyBob3Vyc1xyXG4gICAgb3RoZXJFdmVudFN0b3JlLCAvLyBmb3IgaWYgY29uc3RyYWludCBpcyBhbiBldmVuIGdyb3VwIElEXHJcbiAgICBidXNpbmVzc0hvdXJzVW5leHBhbmRlZCwgLy8gZm9yIGlmIGNvbnN0cmFpbnQgaXMgJ2J1c2luZXNzSG91cnMnXHJcbiAgICBjb250ZXh0KSB7XHJcbiAgICAgICAgaWYgKGNvbnN0cmFpbnQgPT09ICdidXNpbmVzc0hvdXJzJykge1xyXG4gICAgICAgICAgICByZXR1cm4gZXZlbnRTdG9yZVRvUmFuZ2VzKGV4cGFuZFJlY3VycmluZyhidXNpbmVzc0hvdXJzVW5leHBhbmRlZCwgc3ViamVjdFJhbmdlLCBjb250ZXh0KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlb2YgY29uc3RyYWludCA9PT0gJ3N0cmluZycpIHsgLy8gYW4gZ3JvdXAgSURcclxuICAgICAgICAgICAgcmV0dXJuIGV2ZW50U3RvcmVUb1JhbmdlcyhmaWx0ZXJFdmVudFN0b3JlRGVmcyhvdGhlckV2ZW50U3RvcmUsIChldmVudERlZikgPT4gZXZlbnREZWYuZ3JvdXBJZCA9PT0gY29uc3RyYWludCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mIGNvbnN0cmFpbnQgPT09ICdvYmplY3QnICYmIGNvbnN0cmFpbnQpIHsgLy8gbm9uLW51bGwgb2JqZWN0XHJcbiAgICAgICAgICAgIHJldHVybiBldmVudFN0b3JlVG9SYW5nZXMoZXhwYW5kUmVjdXJyaW5nKGNvbnN0cmFpbnQsIHN1YmplY3RSYW5nZSwgY29udGV4dCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gW107IC8vIGlmIGl0J3MgZmFsc2VcclxuICAgIH1cclxuICAgIC8vIFRPRE86IG1vdmUgdG8gZXZlbnQtc3RvcmUgZmlsZT9cclxuICAgIGZ1bmN0aW9uIGV2ZW50U3RvcmVUb1JhbmdlcyhldmVudFN0b3JlKSB7XHJcbiAgICAgICAgbGV0IHsgaW5zdGFuY2VzIH0gPSBldmVudFN0b3JlO1xyXG4gICAgICAgIGxldCByYW5nZXMgPSBbXTtcclxuICAgICAgICBmb3IgKGxldCBpbnN0YW5jZUlkIGluIGluc3RhbmNlcykge1xyXG4gICAgICAgICAgICByYW5nZXMucHVzaChpbnN0YW5jZXNbaW5zdGFuY2VJZF0ucmFuZ2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmFuZ2VzO1xyXG4gICAgfVxyXG4gICAgLy8gVE9ETzogbW92ZSB0byBnZW9tIGZpbGU/XHJcbiAgICBmdW5jdGlvbiBhbnlSYW5nZXNDb250YWluUmFuZ2Uob3V0ZXJSYW5nZXMsIGlubmVyUmFuZ2UpIHtcclxuICAgICAgICBmb3IgKGxldCBvdXRlclJhbmdlIG9mIG91dGVyUmFuZ2VzKSB7XHJcbiAgICAgICAgICAgIGlmIChyYW5nZUNvbnRhaW5zUmFuZ2Uob3V0ZXJSYW5nZSwgaW5uZXJSYW5nZSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBjbGFzcyBKc29uUmVxdWVzdEVycm9yIGV4dGVuZHMgRXJyb3Ige1xyXG4gICAgICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHJlc3BvbnNlKSB7XHJcbiAgICAgICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xyXG4gICAgICAgICAgICB0aGlzLnJlc3BvbnNlID0gcmVzcG9uc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gcmVxdWVzdEpzb24obWV0aG9kLCB1cmwsIHBhcmFtcykge1xyXG4gICAgICAgIG1ldGhvZCA9IG1ldGhvZC50b1VwcGVyQ2FzZSgpO1xyXG4gICAgICAgIGNvbnN0IGZldGNoT3B0aW9ucyA9IHtcclxuICAgICAgICAgICAgbWV0aG9kLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gJ0dFVCcpIHtcclxuICAgICAgICAgICAgdXJsICs9ICh1cmwuaW5kZXhPZignPycpID09PSAtMSA/ICc/JyA6ICcmJykgK1xyXG4gICAgICAgICAgICAgICAgbmV3IFVSTFNlYXJjaFBhcmFtcyhwYXJhbXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZmV0Y2hPcHRpb25zLmJvZHkgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHBhcmFtcyk7XHJcbiAgICAgICAgICAgIGZldGNoT3B0aW9ucy5oZWFkZXJzID0ge1xyXG4gICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmV0Y2godXJsLCBmZXRjaE9wdGlvbnMpLnRoZW4oKGZldGNoUmVzKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChmZXRjaFJlcy5vaykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZldGNoUmVzLmpzb24oKS50aGVuKChwYXJzZWRSZXNwb25zZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbcGFyc2VkUmVzcG9uc2UsIGZldGNoUmVzXTtcclxuICAgICAgICAgICAgICAgIH0sICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSnNvblJlcXVlc3RFcnJvcignRmFpbHVyZSBwYXJzaW5nIEpTT04nLCBmZXRjaFJlcyk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBKc29uUmVxdWVzdEVycm9yKCdSZXF1ZXN0IGZhaWxlZCcsIGZldGNoUmVzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGNsYXNzIERlbGF5ZWRSdW5uZXIge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yKGRyYWluZWRPcHRpb24pIHtcclxuICAgICAgICAgICAgdGhpcy5kcmFpbmVkT3B0aW9uID0gZHJhaW5lZE9wdGlvbjtcclxuICAgICAgICAgICAgdGhpcy5pc1J1bm5pbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5pc0RpcnR5ID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMucGF1c2VEZXB0aHMgPSB7fTtcclxuICAgICAgICAgICAgdGhpcy50aW1lb3V0SWQgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXF1ZXN0KGRlbGF5KSB7XHJcbiAgICAgICAgICAgIHRoaXMuaXNEaXJ0eSA9IHRydWU7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5pc1BhdXNlZCgpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNsZWFyVGltZW91dCgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGRlbGF5ID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyeURyYWluKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRpbWVvdXRJZCA9IHNldFRpbWVvdXQoLy8gTk9UIE9QVElNQUwhIFRPRE86IGxvb2sgYXQgZGVib3VuY2VcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyeURyYWluLmJpbmQodGhpcyksIGRlbGF5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBwYXVzZShzY29wZSA9ICcnKSB7XHJcbiAgICAgICAgICAgIGxldCB7IHBhdXNlRGVwdGhzIH0gPSB0aGlzO1xyXG4gICAgICAgICAgICBwYXVzZURlcHRoc1tzY29wZV0gPSAocGF1c2VEZXB0aHNbc2NvcGVdIHx8IDApICsgMTtcclxuICAgICAgICAgICAgdGhpcy5jbGVhclRpbWVvdXQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVzdW1lKHNjb3BlID0gJycsIGZvcmNlKSB7XHJcbiAgICAgICAgICAgIGxldCB7IHBhdXNlRGVwdGhzIH0gPSB0aGlzO1xyXG4gICAgICAgICAgICBpZiAoc2NvcGUgaW4gcGF1c2VEZXB0aHMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChmb3JjZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBwYXVzZURlcHRoc1tzY29wZV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBwYXVzZURlcHRoc1tzY29wZV0gLT0gMTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgZGVwdGggPSBwYXVzZURlcHRoc1tzY29wZV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlcHRoIDw9IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHBhdXNlRGVwdGhzW3Njb3BlXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRyeURyYWluKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaXNQYXVzZWQoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLnBhdXNlRGVwdGhzKS5sZW5ndGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRyeURyYWluKCkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNSdW5uaW5nICYmICF0aGlzLmlzUGF1c2VkKCkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaXNSdW5uaW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHdoaWxlICh0aGlzLmlzRGlydHkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmlzRGlydHkgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYWluZWQoKTsgLy8gbWlnaHQgc2V0IGlzRGlydHkgdG8gdHJ1ZSBhZ2FpblxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5pc1J1bm5pbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjbGVhcigpIHtcclxuICAgICAgICAgICAgdGhpcy5jbGVhclRpbWVvdXQoKTtcclxuICAgICAgICAgICAgdGhpcy5pc0RpcnR5ID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMucGF1c2VEZXB0aHMgPSB7fTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2xlYXJUaW1lb3V0KCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy50aW1lb3V0SWQpIHtcclxuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXRJZCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRpbWVvdXRJZCA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZHJhaW5lZCgpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuZHJhaW5lZE9wdGlvbikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kcmFpbmVkT3B0aW9uKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgVklTSUJMRV9ISURERU5fUkUgPSAvXih2aXNpYmxlfGhpZGRlbikkLztcclxuICAgIGNsYXNzIFNjcm9sbGVyIGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XHJcbiAgICAgICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlRWwgPSAoZWwpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZWwgPSBlbDtcclxuICAgICAgICAgICAgICAgIHNldFJlZih0aGlzLnByb3BzLmVsUmVmLCBlbCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlbmRlcigpIHtcclxuICAgICAgICAgICAgbGV0IHsgcHJvcHMgfSA9IHRoaXM7XHJcbiAgICAgICAgICAgIGxldCB7IGxpcXVpZCwgbGlxdWlkSXNBYnNvbHV0ZSB9ID0gcHJvcHM7XHJcbiAgICAgICAgICAgIGxldCBpc0Fic29sdXRlID0gbGlxdWlkICYmIGxpcXVpZElzQWJzb2x1dGU7XHJcbiAgICAgICAgICAgIGxldCBjbGFzc05hbWUgPSBbJ2ZjLXNjcm9sbGVyJ107XHJcbiAgICAgICAgICAgIGlmIChsaXF1aWQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChsaXF1aWRJc0Fic29sdXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lLnB1c2goJ2ZjLXNjcm9sbGVyLWxpcXVpZC1hYnNvbHV0ZScpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lLnB1c2goJ2ZjLXNjcm9sbGVyLWxpcXVpZCcpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiAoeShcImRpdlwiLCB7IHJlZjogdGhpcy5oYW5kbGVFbCwgY2xhc3NOYW1lOiBjbGFzc05hbWUuam9pbignICcpLCBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgICAgIG92ZXJmbG93WDogcHJvcHMub3ZlcmZsb3dYLFxyXG4gICAgICAgICAgICAgICAgICAgIG92ZXJmbG93WTogcHJvcHMub3ZlcmZsb3dZLFxyXG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6IChpc0Fic29sdXRlICYmIC0ocHJvcHMub3ZlcmNvbWVMZWZ0IHx8IDApKSB8fCAnJyxcclxuICAgICAgICAgICAgICAgICAgICByaWdodDogKGlzQWJzb2x1dGUgJiYgLShwcm9wcy5vdmVyY29tZVJpZ2h0IHx8IDApKSB8fCAnJyxcclxuICAgICAgICAgICAgICAgICAgICBib3R0b206IChpc0Fic29sdXRlICYmIC0ocHJvcHMub3ZlcmNvbWVCb3R0b20gfHwgMCkpIHx8ICcnLFxyXG4gICAgICAgICAgICAgICAgICAgIG1hcmdpbkxlZnQ6ICghaXNBYnNvbHV0ZSAmJiAtKHByb3BzLm92ZXJjb21lTGVmdCB8fCAwKSkgfHwgJycsXHJcbiAgICAgICAgICAgICAgICAgICAgbWFyZ2luUmlnaHQ6ICghaXNBYnNvbHV0ZSAmJiAtKHByb3BzLm92ZXJjb21lUmlnaHQgfHwgMCkpIHx8ICcnLFxyXG4gICAgICAgICAgICAgICAgICAgIG1hcmdpbkJvdHRvbTogKCFpc0Fic29sdXRlICYmIC0ocHJvcHMub3ZlcmNvbWVCb3R0b20gfHwgMCkpIHx8ICcnLFxyXG4gICAgICAgICAgICAgICAgICAgIG1heEhlaWdodDogcHJvcHMubWF4SGVpZ2h0IHx8ICcnLFxyXG4gICAgICAgICAgICAgICAgfSB9LCBwcm9wcy5jaGlsZHJlbikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBuZWVkc1hTY3JvbGxpbmcoKSB7XHJcbiAgICAgICAgICAgIGlmIChWSVNJQkxFX0hJRERFTl9SRS50ZXN0KHRoaXMucHJvcHMub3ZlcmZsb3dYKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHRlc3Rpbmcgc2Nyb2xsV2lkdGg+Y2xpZW50V2lkdGggaXMgdW5yZWxpYWJsZSBjcm9zcy1icm93c2VyIHdoZW4gcGl4ZWwgaGVpZ2h0cyBhcmVuJ3QgaW50ZWdlcnMuXHJcbiAgICAgICAgICAgIC8vIG11Y2ggbW9yZSByZWxpYWJsZSB0byBzZWUgaWYgY2hpbGRyZW4gYXJlIHRhbGxlciB0aGFuIHRoZSBzY3JvbGxlciwgZXZlbiB0aG8gZG9lc24ndCBhY2NvdW50IGZvclxyXG4gICAgICAgICAgICAvLyBpbm5lci1jaGlsZCBtYXJnaW5zIGFuZCBhYnNvbHV0ZSBwb3NpdGlvbmluZ1xyXG4gICAgICAgICAgICBsZXQgeyBlbCB9ID0gdGhpcztcclxuICAgICAgICAgICAgbGV0IHJlYWxDbGllbnRXaWR0aCA9IHRoaXMuZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggLSB0aGlzLmdldFlTY3JvbGxiYXJXaWR0aCgpO1xyXG4gICAgICAgICAgICBsZXQgeyBjaGlsZHJlbiB9ID0gZWw7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpICs9IDEpIHtcclxuICAgICAgICAgICAgICAgIGxldCBjaGlsZEVsID0gY2hpbGRyZW5baV07XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGRFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCA+IHJlYWxDbGllbnRXaWR0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbmVlZHNZU2Nyb2xsaW5nKCkge1xyXG4gICAgICAgICAgICBpZiAoVklTSUJMRV9ISURERU5fUkUudGVzdCh0aGlzLnByb3BzLm92ZXJmbG93WSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyB0ZXN0aW5nIHNjcm9sbEhlaWdodD5jbGllbnRIZWlnaHQgaXMgdW5yZWxpYWJsZSBjcm9zcy1icm93c2VyIHdoZW4gcGl4ZWwgaGVpZ2h0cyBhcmVuJ3QgaW50ZWdlcnMuXHJcbiAgICAgICAgICAgIC8vIG11Y2ggbW9yZSByZWxpYWJsZSB0byBzZWUgaWYgY2hpbGRyZW4gYXJlIHRhbGxlciB0aGFuIHRoZSBzY3JvbGxlciwgZXZlbiB0aG8gZG9lc24ndCBhY2NvdW50IGZvclxyXG4gICAgICAgICAgICAvLyBpbm5lci1jaGlsZCBtYXJnaW5zIGFuZCBhYnNvbHV0ZSBwb3NpdGlvbmluZ1xyXG4gICAgICAgICAgICBsZXQgeyBlbCB9ID0gdGhpcztcclxuICAgICAgICAgICAgbGV0IHJlYWxDbGllbnRIZWlnaHQgPSB0aGlzLmVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodCAtIHRoaXMuZ2V0WFNjcm9sbGJhcldpZHRoKCk7XHJcbiAgICAgICAgICAgIGxldCB7IGNoaWxkcmVuIH0gPSBlbDtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkgKz0gMSkge1xyXG4gICAgICAgICAgICAgICAgbGV0IGNoaWxkRWwgPSBjaGlsZHJlbltpXTtcclxuICAgICAgICAgICAgICAgIGlmIChjaGlsZEVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodCA+IHJlYWxDbGllbnRIZWlnaHQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGdldFhTY3JvbGxiYXJXaWR0aCgpIHtcclxuICAgICAgICAgICAgaWYgKFZJU0lCTEVfSElEREVOX1JFLnRlc3QodGhpcy5wcm9wcy5vdmVyZmxvd1gpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbC5vZmZzZXRIZWlnaHQgLSB0aGlzLmVsLmNsaWVudEhlaWdodDsgLy8gb25seSB3b3JrcyBiZWNhdXNlIHdlIGd1YXJhbnRlZSBubyBib3JkZXJzLiBUT0RPOiBhZGQgdG8gQ1NTIHdpdGggaW1wb3J0YW50P1xyXG4gICAgICAgIH1cclxuICAgICAgICBnZXRZU2Nyb2xsYmFyV2lkdGgoKSB7XHJcbiAgICAgICAgICAgIGlmIChWSVNJQkxFX0hJRERFTl9SRS50ZXN0KHRoaXMucHJvcHMub3ZlcmZsb3dZKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWwub2Zmc2V0V2lkdGggLSB0aGlzLmVsLmNsaWVudFdpZHRoOyAvLyBvbmx5IHdvcmtzIGJlY2F1c2Ugd2UgZ3VhcmFudGVlIG5vIGJvcmRlcnMuIFRPRE86IGFkZCB0byBDU1Mgd2l0aCBpbXBvcnRhbnQ/XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qXHJcbiAgICBUT0RPOiBzb21laG93IGluZmVyIE90aGVyQXJncyBmcm9tIG1hc3RlckNhbGxiYWNrP1xyXG4gICAgVE9ETzogaW5mZXIgUmVmVHlwZSBmcm9tIG1hc3RlckNhbGxiYWNrIGlmIHByb3ZpZGVkXHJcbiAgICAqL1xyXG4gICAgY2xhc3MgUmVmTWFwIHtcclxuICAgICAgICBjb25zdHJ1Y3RvcihtYXN0ZXJDYWxsYmFjaykge1xyXG4gICAgICAgICAgICB0aGlzLm1hc3RlckNhbGxiYWNrID0gbWFzdGVyQ2FsbGJhY2s7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudE1hcCA9IHt9O1xyXG4gICAgICAgICAgICB0aGlzLmRlcHRocyA9IHt9O1xyXG4gICAgICAgICAgICB0aGlzLmNhbGxiYWNrTWFwID0ge307XHJcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlVmFsdWUgPSAodmFsLCBrZXkpID0+IHtcclxuICAgICAgICAgICAgICAgIGxldCB7IGRlcHRocywgY3VycmVudE1hcCB9ID0gdGhpcztcclxuICAgICAgICAgICAgICAgIGxldCByZW1vdmVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBsZXQgYWRkZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGlmICh2YWwgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBmb3IgYnVnLi4uIEFDVFVBTExZOiBjYW4gcHJvYmFibHkgZG8gYXdheSB3aXRoIHRoaXMgbm93IHRoYXQgY2FsbGVycyBkb24ndCBzaGFyZSBudW1lcmljIGluZGljZXMgYW55bW9yZVxyXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZWQgPSAoa2V5IGluIGN1cnJlbnRNYXApO1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRNYXBba2V5XSA9IHZhbDtcclxuICAgICAgICAgICAgICAgICAgICBkZXB0aHNba2V5XSA9IChkZXB0aHNba2V5XSB8fCAwKSArIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgYWRkZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVwdGhzW2tleV0gLT0gMTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWRlcHRoc1trZXldKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBjdXJyZW50TWFwW2tleV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmNhbGxiYWNrTWFwW2tleV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm1hc3RlckNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlbW92ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXN0ZXJDYWxsYmFjayhudWxsLCBTdHJpbmcoa2V5KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhZGRlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1hc3RlckNhbGxiYWNrKHZhbCwgU3RyaW5nKGtleSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY3JlYXRlUmVmKGtleSkge1xyXG4gICAgICAgICAgICBsZXQgcmVmQ2FsbGJhY2sgPSB0aGlzLmNhbGxiYWNrTWFwW2tleV07XHJcbiAgICAgICAgICAgIGlmICghcmVmQ2FsbGJhY2spIHtcclxuICAgICAgICAgICAgICAgIHJlZkNhbGxiYWNrID0gdGhpcy5jYWxsYmFja01hcFtrZXldID0gKHZhbCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlVmFsdWUodmFsLCBTdHJpbmcoa2V5KSk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZWZDYWxsYmFjaztcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVE9ETzogY2hlY2sgY2FsbGVycyB0aGF0IGRvbid0IGNhcmUgYWJvdXQgb3JkZXIuIHNob3VsZCB1c2UgZ2V0QWxsIGluc3RlYWRcclxuICAgICAgICAvLyBOT1RFOiB0aGlzIG1ldGhvZCBoYXMgYmVjb21lIGxlc3MgdmFsdWFibGUgbm93IHRoYXQgd2UgYXJlIGVuY291cmFnZWQgdG8gbWFwIG9yZGVyIGJ5IHNvbWUgb3RoZXIgaW5kZXhcclxuICAgICAgICAvLyBUT0RPOiBwcm92aWRlIE9ORSBhcnJheS1leHBvcnQgZnVuY3Rpb24sIGJ1aWxkQXJyYXksIHdoaWNoIGZhaWxzIG9uIG5vbi1udW1lcmljIGluZGV4ZXMuIGNhbGxlciBjYW4gbWFuaXB1bGF0ZSBhbmQgXCJjb2xsZWN0XCJcclxuICAgICAgICBjb2xsZWN0KHN0YXJ0SW5kZXgsIGVuZEluZGV4LCBzdGVwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjb2xsZWN0RnJvbUhhc2godGhpcy5jdXJyZW50TWFwLCBzdGFydEluZGV4LCBlbmRJbmRleCwgc3RlcCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGdldEFsbCgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGhhc2hWYWx1ZXNUb0FycmF5KHRoaXMuY3VycmVudE1hcCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNvbXB1dGVTaHJpbmtXaWR0aChjaHVua0Vscykge1xyXG4gICAgICAgIGxldCBzaHJpbmtDZWxscyA9IGZpbmRFbGVtZW50cyhjaHVua0VscywgJy5mYy1zY3JvbGxncmlkLXNocmluaycpO1xyXG4gICAgICAgIGxldCBsYXJnZXN0V2lkdGggPSAwO1xyXG4gICAgICAgIGZvciAobGV0IHNocmlua0NlbGwgb2Ygc2hyaW5rQ2VsbHMpIHtcclxuICAgICAgICAgICAgbGFyZ2VzdFdpZHRoID0gTWF0aC5tYXgobGFyZ2VzdFdpZHRoLCBjb21wdXRlU21hbGxlc3RDZWxsV2lkdGgoc2hyaW5rQ2VsbCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gTWF0aC5jZWlsKGxhcmdlc3RXaWR0aCk7IC8vIDx0YWJsZT4gZWxlbWVudHMgd29yayBiZXN0IHdpdGggaW50ZWdlcnMuIHJvdW5kIHVwIHRvIGVuc3VyZSBjb250ZW50cyBmaXRzXHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBnZXRTZWN0aW9uSGFzTGlxdWlkSGVpZ2h0KHByb3BzLCBzZWN0aW9uQ29uZmlnKSB7XHJcbiAgICAgICAgcmV0dXJuIHByb3BzLmxpcXVpZCAmJiBzZWN0aW9uQ29uZmlnLmxpcXVpZDsgLy8gZG9lcyB0aGUgc2VjdGlvbiBkbyBsaXF1aWQtaGVpZ2h0PyAobmVlZCB0byBoYXZlIHdob2xlIHNjcm9sbGdyaWQgbGlxdWlkLWhlaWdodCBhcyB3ZWxsKVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZ2V0QWxsb3dZU2Nyb2xsaW5nKHByb3BzLCBzZWN0aW9uQ29uZmlnKSB7XHJcbiAgICAgICAgcmV0dXJuIHNlY3Rpb25Db25maWcubWF4SGVpZ2h0ICE9IG51bGwgfHwgLy8gaWYgaXRzIHBvc3NpYmxlIGZvciB0aGUgaGVpZ2h0IHRvIG1heCBvdXQsIHdlIG1pZ2h0IG5lZWQgc2Nyb2xsYmFyc1xyXG4gICAgICAgICAgICBnZXRTZWN0aW9uSGFzTGlxdWlkSGVpZ2h0KHByb3BzLCBzZWN0aW9uQ29uZmlnKTsgLy8gaWYgdGhlIHNlY3Rpb24gaXMgbGlxdWlkIGhlaWdodCwgaXQgbWlnaHQgY29uZGVuc2UgZW5vdWdoIHRvIHJlcXVpcmUgc2Nyb2xsYmFyc1xyXG4gICAgfVxyXG4gICAgLy8gVE9ETzogT05MWSB1c2UgYGFyZ2AuIGZvcmNlIG91dCBpbnRlcm5hbCBmdW5jdGlvbiB0byB1c2Ugc2FtZSBBUElcclxuICAgIGZ1bmN0aW9uIHJlbmRlckNodW5rQ29udGVudChzZWN0aW9uQ29uZmlnLCBjaHVua0NvbmZpZywgYXJnLCBpc0hlYWRlcikge1xyXG4gICAgICAgIGxldCB7IGV4cGFuZFJvd3MgfSA9IGFyZztcclxuICAgICAgICBsZXQgY29udGVudCA9IHR5cGVvZiBjaHVua0NvbmZpZy5jb250ZW50ID09PSAnZnVuY3Rpb24nID9cclxuICAgICAgICAgICAgY2h1bmtDb25maWcuY29udGVudChhcmcpIDpcclxuICAgICAgICAgICAgeSgndGFibGUnLCB7XHJcbiAgICAgICAgICAgICAgICByb2xlOiAncHJlc2VudGF0aW9uJyxcclxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogW1xyXG4gICAgICAgICAgICAgICAgICAgIGNodW5rQ29uZmlnLnRhYmxlQ2xhc3NOYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgIHNlY3Rpb25Db25maWcuc3luY1Jvd0hlaWdodHMgPyAnZmMtc2Nyb2xsZ3JpZC1zeW5jLXRhYmxlJyA6ICcnLFxyXG4gICAgICAgICAgICAgICAgXS5qb2luKCcgJyksXHJcbiAgICAgICAgICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgICAgIG1pbldpZHRoOiBhcmcudGFibGVNaW5XaWR0aCxcclxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogYXJnLmNsaWVudFdpZHRoLFxyXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogZXhwYW5kUm93cyA/IGFyZy5jbGllbnRIZWlnaHQgOiAnJywgLy8gY3NzIGBoZWlnaHRgIG9uIGEgPHRhYmxlPiBzZXJ2ZXMgYXMgYSBtaW4taGVpZ2h0XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB9LCBhcmcudGFibGVDb2xHcm91cE5vZGUsIHkoaXNIZWFkZXIgPyAndGhlYWQnIDogJ3Rib2R5Jywge1xyXG4gICAgICAgICAgICAgICAgcm9sZTogJ3ByZXNlbnRhdGlvbicsXHJcbiAgICAgICAgICAgIH0sIHR5cGVvZiBjaHVua0NvbmZpZy5yb3dDb250ZW50ID09PSAnZnVuY3Rpb24nXHJcbiAgICAgICAgICAgICAgICA/IGNodW5rQ29uZmlnLnJvd0NvbnRlbnQoYXJnKVxyXG4gICAgICAgICAgICAgICAgOiBjaHVua0NvbmZpZy5yb3dDb250ZW50KSk7XHJcbiAgICAgICAgcmV0dXJuIGNvbnRlbnQ7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBpc0NvbFByb3BzRXF1YWwoY29sczAsIGNvbHMxKSB7XHJcbiAgICAgICAgcmV0dXJuIGlzQXJyYXlzRXF1YWwoY29sczAsIGNvbHMxLCBpc1Byb3BzRXF1YWwpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gcmVuZGVyTWljcm9Db2xHcm91cChjb2xzLCBzaHJpbmtXaWR0aCkge1xyXG4gICAgICAgIGxldCBjb2xOb2RlcyA9IFtdO1xyXG4gICAgICAgIC8qXHJcbiAgICAgICAgZm9yIENvbFByb3BzIHdpdGggc3BhbnMsIGl0IHdvdWxkIGhhdmUgYmVlbiBncmVhdCB0byBtYWtlIGEgc2luZ2xlIDxjb2wgc3Bhbj1cIlwiPlxyXG4gICAgICAgIEhPV0VWRVIsIENocm9tZSB3YXMgZ2V0dGluZyBtZXNzaW5nIHVwIGRpc3RyaWJ1dGluZyB0aGUgd2lkdGggdG8gPHRkPi88dGg+IGVsZW1lbnRzIHdpdGggY29sc3BhbnMuXHJcbiAgICAgICAgU09MVVRJT046IG1ha2luZyBpbmRpdmlkdWFsIDxjb2w+IGVsZW1lbnRzIG1ha2VzIENocm9tZSBiZWhhdmUuXHJcbiAgICAgICAgKi9cclxuICAgICAgICBmb3IgKGxldCBjb2xQcm9wcyBvZiBjb2xzKSB7XHJcbiAgICAgICAgICAgIGxldCBzcGFuID0gY29sUHJvcHMuc3BhbiB8fCAxO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNwYW47IGkgKz0gMSkge1xyXG4gICAgICAgICAgICAgICAgY29sTm9kZXMucHVzaCh5KFwiY29sXCIsIHsgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IGNvbFByb3BzLndpZHRoID09PSAnc2hyaW5rJyA/IHNhbml0aXplU2hyaW5rV2lkdGgoc2hyaW5rV2lkdGgpIDogKGNvbFByb3BzLndpZHRoIHx8ICcnKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWluV2lkdGg6IGNvbFByb3BzLm1pbldpZHRoIHx8ICcnLFxyXG4gICAgICAgICAgICAgICAgICAgIH0gfSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB5KCdjb2xncm91cCcsIHt9LCAuLi5jb2xOb2Rlcyk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBzYW5pdGl6ZVNocmlua1dpZHRoKHNocmlua1dpZHRoKSB7XHJcbiAgICAgICAgLyogd2h5IDQ/IGlmIHdlIGRvIDAsIGl0IHdpbGwga2lsbCBhbnkgYm9yZGVyLCB3aGljaCBhcmUgbmVlZGVkIGZvciBjb21wdXRlU21hbGxlc3RDZWxsV2lkdGhcclxuICAgICAgICA0IGFjY291bnRzIGZvciAyIDItcGl4ZWwgYm9yZGVycy4gVE9ETzogYmV0dGVyIHNvbHV0aW9uPyAqL1xyXG4gICAgICAgIHJldHVybiBzaHJpbmtXaWR0aCA9PSBudWxsID8gNCA6IHNocmlua1dpZHRoO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gaGFzU2hyaW5rV2lkdGgoY29scykge1xyXG4gICAgICAgIGZvciAobGV0IGNvbCBvZiBjb2xzKSB7XHJcbiAgICAgICAgICAgIGlmIChjb2wud2lkdGggPT09ICdzaHJpbmsnKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBnZXRTY3JvbGxHcmlkQ2xhc3NOYW1lcyhsaXF1aWQsIGNvbnRleHQpIHtcclxuICAgICAgICBsZXQgY2xhc3NOYW1lcyA9IFtcclxuICAgICAgICAgICAgJ2ZjLXNjcm9sbGdyaWQnLFxyXG4gICAgICAgICAgICBjb250ZXh0LnRoZW1lLmdldENsYXNzKCd0YWJsZScpLFxyXG4gICAgICAgIF07XHJcbiAgICAgICAgaWYgKGxpcXVpZCkge1xyXG4gICAgICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLXNjcm9sbGdyaWQtbGlxdWlkJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjbGFzc05hbWVzO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZ2V0U2VjdGlvbkNsYXNzTmFtZXMoc2VjdGlvbkNvbmZpZywgd2hvbGVUYWJsZVZHcm93KSB7XHJcbiAgICAgICAgbGV0IGNsYXNzTmFtZXMgPSBbXHJcbiAgICAgICAgICAgICdmYy1zY3JvbGxncmlkLXNlY3Rpb24nLFxyXG4gICAgICAgICAgICBgZmMtc2Nyb2xsZ3JpZC1zZWN0aW9uLSR7c2VjdGlvbkNvbmZpZy50eXBlfWAsXHJcbiAgICAgICAgICAgIHNlY3Rpb25Db25maWcuY2xhc3NOYW1lLCAvLyB1c2VkP1xyXG4gICAgICAgIF07XHJcbiAgICAgICAgaWYgKHdob2xlVGFibGVWR3JvdyAmJiBzZWN0aW9uQ29uZmlnLmxpcXVpZCAmJiBzZWN0aW9uQ29uZmlnLm1heEhlaWdodCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtc2Nyb2xsZ3JpZC1zZWN0aW9uLWxpcXVpZCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc2VjdGlvbkNvbmZpZy5pc1N0aWNreSkge1xyXG4gICAgICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLXNjcm9sbGdyaWQtc2VjdGlvbi1zdGlja3knKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNsYXNzTmFtZXM7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiByZW5kZXJTY3JvbGxTaGltKGFyZykge1xyXG4gICAgICAgIHJldHVybiAoeShcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy1zY3JvbGxncmlkLXN0aWNreS1zaGltXCIsIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICB3aWR0aDogYXJnLmNsaWVudFdpZHRoLFxyXG4gICAgICAgICAgICAgICAgbWluV2lkdGg6IGFyZy50YWJsZU1pbldpZHRoLFxyXG4gICAgICAgICAgICB9IH0pKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGdldFN0aWNreUhlYWRlckRhdGVzKG9wdGlvbnMpIHtcclxuICAgICAgICBsZXQgeyBzdGlja3lIZWFkZXJEYXRlcyB9ID0gb3B0aW9ucztcclxuICAgICAgICBpZiAoc3RpY2t5SGVhZGVyRGF0ZXMgPT0gbnVsbCB8fCBzdGlja3lIZWFkZXJEYXRlcyA9PT0gJ2F1dG8nKSB7XHJcbiAgICAgICAgICAgIHN0aWNreUhlYWRlckRhdGVzID0gb3B0aW9ucy5oZWlnaHQgPT09ICdhdXRvJyB8fCBvcHRpb25zLnZpZXdIZWlnaHQgPT09ICdhdXRvJztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHN0aWNreUhlYWRlckRhdGVzO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZ2V0U3RpY2t5Rm9vdGVyU2Nyb2xsYmFyKG9wdGlvbnMpIHtcclxuICAgICAgICBsZXQgeyBzdGlja3lGb290ZXJTY3JvbGxiYXIgfSA9IG9wdGlvbnM7XHJcbiAgICAgICAgaWYgKHN0aWNreUZvb3RlclNjcm9sbGJhciA9PSBudWxsIHx8IHN0aWNreUZvb3RlclNjcm9sbGJhciA9PT0gJ2F1dG8nKSB7XHJcbiAgICAgICAgICAgIHN0aWNreUZvb3RlclNjcm9sbGJhciA9IG9wdGlvbnMuaGVpZ2h0ID09PSAnYXV0bycgfHwgb3B0aW9ucy52aWV3SGVpZ2h0ID09PSAnYXV0byc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzdGlja3lGb290ZXJTY3JvbGxiYXI7XHJcbiAgICB9XHJcblxyXG4gICAgY2xhc3MgU2ltcGxlU2Nyb2xsR3JpZCBleHRlbmRzIEJhc2VDb21wb25lbnQge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NDb2xzID0gbWVtb2l6ZSgoYSkgPT4gYSwgaXNDb2xQcm9wc0VxdWFsKTsgLy8gc28gd2UgZ2V0IHNhbWUgYGNvbHNgIHByb3BzIGV2ZXJ5IHRpbWVcclxuICAgICAgICAgICAgLy8geXVja3kgdG8gbWVtb2l6ZSBWTm9kZXMsIGJ1dCBtdWNoIG1vcmUgZWZmaWNpZW50IGZvciBjb25zdW1lcnNcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJNaWNyb0NvbEdyb3VwID0gbWVtb2l6ZShyZW5kZXJNaWNyb0NvbEdyb3VwKTtcclxuICAgICAgICAgICAgdGhpcy5zY3JvbGxlclJlZnMgPSBuZXcgUmVmTWFwKCk7XHJcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsZXJFbFJlZnMgPSBuZXcgUmVmTWFwKHRoaXMuX2hhbmRsZVNjcm9sbGVyRWwuYmluZCh0aGlzKSk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSB7XHJcbiAgICAgICAgICAgICAgICBzaHJpbmtXaWR0aDogbnVsbCxcclxuICAgICAgICAgICAgICAgIGZvcmNlWVNjcm9sbGJhcnM6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgc2Nyb2xsZXJDbGllbnRXaWR0aHM6IHt9LFxyXG4gICAgICAgICAgICAgICAgc2Nyb2xsZXJDbGllbnRIZWlnaHRzOiB7fSxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLy8gVE9ETzogY2FuIGRvIGEgcmVhbGx5IHNpbXBsZSBwcmludC12aWV3LiBkb250IG5lZWQgdG8gam9pbiByb3dzXHJcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlU2l6aW5nID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zYWZlU2V0U3RhdGUoT2JqZWN0LmFzc2lnbih7IHNocmlua1dpZHRoOiB0aGlzLmNvbXB1dGVTaHJpbmtXaWR0aCgpIH0sIHRoaXMuY29tcHV0ZVNjcm9sbGVyRGltcygpKSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlbmRlcigpIHtcclxuICAgICAgICAgICAgbGV0IHsgcHJvcHMsIHN0YXRlLCBjb250ZXh0IH0gPSB0aGlzO1xyXG4gICAgICAgICAgICBsZXQgc2VjdGlvbkNvbmZpZ3MgPSBwcm9wcy5zZWN0aW9ucyB8fCBbXTtcclxuICAgICAgICAgICAgbGV0IGNvbHMgPSB0aGlzLnByb2Nlc3NDb2xzKHByb3BzLmNvbHMpO1xyXG4gICAgICAgICAgICBsZXQgbWljcm9Db2xHcm91cE5vZGUgPSB0aGlzLnJlbmRlck1pY3JvQ29sR3JvdXAoY29scywgc3RhdGUuc2hyaW5rV2lkdGgpO1xyXG4gICAgICAgICAgICBsZXQgY2xhc3NOYW1lcyA9IGdldFNjcm9sbEdyaWRDbGFzc05hbWVzKHByb3BzLmxpcXVpZCwgY29udGV4dCk7XHJcbiAgICAgICAgICAgIGlmIChwcm9wcy5jb2xsYXBzaWJsZVdpZHRoKSB7XHJcbiAgICAgICAgICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLXNjcm9sbGdyaWQtY29sbGFwc2libGUnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBUT0RPOiBtYWtlIERSWVxyXG4gICAgICAgICAgICBsZXQgY29uZmlnQ250ID0gc2VjdGlvbkNvbmZpZ3MubGVuZ3RoO1xyXG4gICAgICAgICAgICBsZXQgY29uZmlnSSA9IDA7XHJcbiAgICAgICAgICAgIGxldCBjdXJyZW50Q29uZmlnO1xyXG4gICAgICAgICAgICBsZXQgaGVhZFNlY3Rpb25Ob2RlcyA9IFtdO1xyXG4gICAgICAgICAgICBsZXQgYm9keVNlY3Rpb25Ob2RlcyA9IFtdO1xyXG4gICAgICAgICAgICBsZXQgZm9vdFNlY3Rpb25Ob2RlcyA9IFtdO1xyXG4gICAgICAgICAgICB3aGlsZSAoY29uZmlnSSA8IGNvbmZpZ0NudCAmJiAoY3VycmVudENvbmZpZyA9IHNlY3Rpb25Db25maWdzW2NvbmZpZ0ldKS50eXBlID09PSAnaGVhZGVyJykge1xyXG4gICAgICAgICAgICAgICAgaGVhZFNlY3Rpb25Ob2Rlcy5wdXNoKHRoaXMucmVuZGVyU2VjdGlvbihjdXJyZW50Q29uZmlnLCBtaWNyb0NvbEdyb3VwTm9kZSwgdHJ1ZSkpO1xyXG4gICAgICAgICAgICAgICAgY29uZmlnSSArPSAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHdoaWxlIChjb25maWdJIDwgY29uZmlnQ250ICYmIChjdXJyZW50Q29uZmlnID0gc2VjdGlvbkNvbmZpZ3NbY29uZmlnSV0pLnR5cGUgPT09ICdib2R5Jykge1xyXG4gICAgICAgICAgICAgICAgYm9keVNlY3Rpb25Ob2Rlcy5wdXNoKHRoaXMucmVuZGVyU2VjdGlvbihjdXJyZW50Q29uZmlnLCBtaWNyb0NvbEdyb3VwTm9kZSwgZmFsc2UpKTtcclxuICAgICAgICAgICAgICAgIGNvbmZpZ0kgKz0gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB3aGlsZSAoY29uZmlnSSA8IGNvbmZpZ0NudCAmJiAoY3VycmVudENvbmZpZyA9IHNlY3Rpb25Db25maWdzW2NvbmZpZ0ldKS50eXBlID09PSAnZm9vdGVyJykge1xyXG4gICAgICAgICAgICAgICAgZm9vdFNlY3Rpb25Ob2Rlcy5wdXNoKHRoaXMucmVuZGVyU2VjdGlvbihjdXJyZW50Q29uZmlnLCBtaWNyb0NvbEdyb3VwTm9kZSwgdHJ1ZSkpO1xyXG4gICAgICAgICAgICAgICAgY29uZmlnSSArPSAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGZpcmVmb3ggYnVnOiB3aGVuIHNldHRpbmcgaGVpZ2h0IG9uIHRhYmxlIGFuZCB0aGVyZSBpcyBhIHRoZWFkIG9yIHRmb290LFxyXG4gICAgICAgICAgICAvLyB0aGUgbmVjZXNzYXJ5IGhlaWdodDoxMDAlIG9uIHRoZSBsaXF1aWQtaGVpZ2h0IGJvZHkgc2VjdGlvbiBmb3JjZXMgdGhlICp3aG9sZSogdGFibGUgdG8gYmUgdGFsbGVyLiAoYnVnICM1NTI0KVxyXG4gICAgICAgICAgICAvLyB1c2UgZ2V0Q2FuVkdyb3dXaXRoaW5DZWxsIGFzIGEgd2F5IHRvIGRldGVjdCB0YWJsZS1zdHVwaWQgZmlyZWZveC5cclxuICAgICAgICAgICAgLy8gaWYgc28sIHVzZSBhIHNpbXBsZXIgZG9tIHN0cnVjdHVyZSwgamFtIGV2ZXJ5dGhpbmcgaW50byBhIGxvbmUgdGJvZHkuXHJcbiAgICAgICAgICAgIGxldCBpc0J1Z2d5ID0gIWdldENhblZHcm93V2l0aGluQ2VsbCgpO1xyXG4gICAgICAgICAgICBjb25zdCByb2xlQXR0cnMgPSB7IHJvbGU6ICdyb3dncm91cCcgfTtcclxuICAgICAgICAgICAgcmV0dXJuIHkoJ3RhYmxlJywge1xyXG4gICAgICAgICAgICAgICAgcm9sZTogJ2dyaWQnLFxyXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWVzLmpvaW4oJyAnKSxcclxuICAgICAgICAgICAgICAgIHN0eWxlOiB7IGhlaWdodDogcHJvcHMuaGVpZ2h0IH0sXHJcbiAgICAgICAgICAgIH0sIEJvb2xlYW4oIWlzQnVnZ3kgJiYgaGVhZFNlY3Rpb25Ob2Rlcy5sZW5ndGgpICYmIHkoJ3RoZWFkJywgcm9sZUF0dHJzLCAuLi5oZWFkU2VjdGlvbk5vZGVzKSwgQm9vbGVhbighaXNCdWdneSAmJiBib2R5U2VjdGlvbk5vZGVzLmxlbmd0aCkgJiYgeSgndGJvZHknLCByb2xlQXR0cnMsIC4uLmJvZHlTZWN0aW9uTm9kZXMpLCBCb29sZWFuKCFpc0J1Z2d5ICYmIGZvb3RTZWN0aW9uTm9kZXMubGVuZ3RoKSAmJiB5KCd0Zm9vdCcsIHJvbGVBdHRycywgLi4uZm9vdFNlY3Rpb25Ob2RlcyksIGlzQnVnZ3kgJiYgeSgndGJvZHknLCByb2xlQXR0cnMsIC4uLmhlYWRTZWN0aW9uTm9kZXMsIC4uLmJvZHlTZWN0aW9uTm9kZXMsIC4uLmZvb3RTZWN0aW9uTm9kZXMpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVuZGVyU2VjdGlvbihzZWN0aW9uQ29uZmlnLCBtaWNyb0NvbEdyb3VwTm9kZSwgaXNIZWFkZXIpIHtcclxuICAgICAgICAgICAgaWYgKCdvdXRlckNvbnRlbnQnIGluIHNlY3Rpb25Db25maWcpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAoeShfLCB7IGtleTogc2VjdGlvbkNvbmZpZy5rZXkgfSwgc2VjdGlvbkNvbmZpZy5vdXRlckNvbnRlbnQpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gKHkoXCJ0clwiLCB7IGtleTogc2VjdGlvbkNvbmZpZy5rZXksIHJvbGU6IFwicHJlc2VudGF0aW9uXCIsIGNsYXNzTmFtZTogZ2V0U2VjdGlvbkNsYXNzTmFtZXMoc2VjdGlvbkNvbmZpZywgdGhpcy5wcm9wcy5saXF1aWQpLmpvaW4oJyAnKSB9LCB0aGlzLnJlbmRlckNodW5rVGQoc2VjdGlvbkNvbmZpZywgbWljcm9Db2xHcm91cE5vZGUsIHNlY3Rpb25Db25maWcuY2h1bmssIGlzSGVhZGVyKSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZW5kZXJDaHVua1RkKHNlY3Rpb25Db25maWcsIG1pY3JvQ29sR3JvdXBOb2RlLCBjaHVua0NvbmZpZywgaXNIZWFkZXIpIHtcclxuICAgICAgICAgICAgaWYgKCdvdXRlckNvbnRlbnQnIGluIGNodW5rQ29uZmlnKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2h1bmtDb25maWcub3V0ZXJDb250ZW50O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxldCB7IHByb3BzIH0gPSB0aGlzO1xyXG4gICAgICAgICAgICBsZXQgeyBmb3JjZVlTY3JvbGxiYXJzLCBzY3JvbGxlckNsaWVudFdpZHRocywgc2Nyb2xsZXJDbGllbnRIZWlnaHRzIH0gPSB0aGlzLnN0YXRlO1xyXG4gICAgICAgICAgICBsZXQgbmVlZHNZU2Nyb2xsaW5nID0gZ2V0QWxsb3dZU2Nyb2xsaW5nKHByb3BzLCBzZWN0aW9uQ29uZmlnKTsgLy8gVE9ETzogZG8gbGF6aWx5LiBkbyBpbiBzZWN0aW9uIGNvbmZpZz9cclxuICAgICAgICAgICAgbGV0IGlzTGlxdWlkID0gZ2V0U2VjdGlvbkhhc0xpcXVpZEhlaWdodChwcm9wcywgc2VjdGlvbkNvbmZpZyk7XHJcbiAgICAgICAgICAgIC8vIGZvciBgIXByb3BzLmxpcXVpZGAgLSBpcyBXSE9MRSBzY3JvbGxncmlkIG5hdHVyYWwgaGVpZ2h0P1xyXG4gICAgICAgICAgICAvLyBUT0RPOiBkbyBzYW1lIHRoaW5nIGluIGFkdmFuY2VkIHNjcm9sbGdyaWQ/IHByb2xseSBub3QgYi9jIGFsd2F5cyBoYXMgaG9yaXpvbnRhbCBzY3JvbGxiYXJzXHJcbiAgICAgICAgICAgIGxldCBvdmVyZmxvd1kgPSAhcHJvcHMubGlxdWlkID8gJ3Zpc2libGUnIDpcclxuICAgICAgICAgICAgICAgIGZvcmNlWVNjcm9sbGJhcnMgPyAnc2Nyb2xsJyA6XHJcbiAgICAgICAgICAgICAgICAgICAgIW5lZWRzWVNjcm9sbGluZyA/ICdoaWRkZW4nIDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ2F1dG8nO1xyXG4gICAgICAgICAgICBsZXQgc2VjdGlvbktleSA9IHNlY3Rpb25Db25maWcua2V5O1xyXG4gICAgICAgICAgICBsZXQgY29udGVudCA9IHJlbmRlckNodW5rQ29udGVudChzZWN0aW9uQ29uZmlnLCBjaHVua0NvbmZpZywge1xyXG4gICAgICAgICAgICAgICAgdGFibGVDb2xHcm91cE5vZGU6IG1pY3JvQ29sR3JvdXBOb2RlLFxyXG4gICAgICAgICAgICAgICAgdGFibGVNaW5XaWR0aDogJycsXHJcbiAgICAgICAgICAgICAgICBjbGllbnRXaWR0aDogKCFwcm9wcy5jb2xsYXBzaWJsZVdpZHRoICYmIHNjcm9sbGVyQ2xpZW50V2lkdGhzW3NlY3Rpb25LZXldICE9PSB1bmRlZmluZWQpID8gc2Nyb2xsZXJDbGllbnRXaWR0aHNbc2VjdGlvbktleV0gOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgY2xpZW50SGVpZ2h0OiBzY3JvbGxlckNsaWVudEhlaWdodHNbc2VjdGlvbktleV0gIT09IHVuZGVmaW5lZCA/IHNjcm9sbGVyQ2xpZW50SGVpZ2h0c1tzZWN0aW9uS2V5XSA6IG51bGwsXHJcbiAgICAgICAgICAgICAgICBleHBhbmRSb3dzOiBzZWN0aW9uQ29uZmlnLmV4cGFuZFJvd3MsXHJcbiAgICAgICAgICAgICAgICBzeW5jUm93SGVpZ2h0czogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICByb3dTeW5jSGVpZ2h0czogW10sXHJcbiAgICAgICAgICAgICAgICByZXBvcnRSb3dIZWlnaHRDaGFuZ2U6ICgpID0+IHsgfSxcclxuICAgICAgICAgICAgfSwgaXNIZWFkZXIpO1xyXG4gICAgICAgICAgICByZXR1cm4geShpc0hlYWRlciA/ICd0aCcgOiAndGQnLCB7XHJcbiAgICAgICAgICAgICAgICByZWY6IGNodW5rQ29uZmlnLmVsUmVmLFxyXG4gICAgICAgICAgICAgICAgcm9sZTogJ3ByZXNlbnRhdGlvbicsXHJcbiAgICAgICAgICAgIH0sIHkoXCJkaXZcIiwgeyBjbGFzc05hbWU6IGBmYy1zY3JvbGxlci1oYXJuZXNzJHtpc0xpcXVpZCA/ICcgZmMtc2Nyb2xsZXItaGFybmVzcy1saXF1aWQnIDogJyd9YCB9LFxyXG4gICAgICAgICAgICAgICAgeShTY3JvbGxlciwgeyByZWY6IHRoaXMuc2Nyb2xsZXJSZWZzLmNyZWF0ZVJlZihzZWN0aW9uS2V5KSwgZWxSZWY6IHRoaXMuc2Nyb2xsZXJFbFJlZnMuY3JlYXRlUmVmKHNlY3Rpb25LZXkpLCBvdmVyZmxvd1k6IG92ZXJmbG93WSwgb3ZlcmZsb3dYOiAhcHJvcHMubGlxdWlkID8gJ3Zpc2libGUnIDogJ2hpZGRlbicgLyogbmF0dXJhbCBoZWlnaHQ/ICovLCBtYXhIZWlnaHQ6IHNlY3Rpb25Db25maWcubWF4SGVpZ2h0LCBsaXF1aWQ6IGlzTGlxdWlkLCBsaXF1aWRJc0Fic29sdXRlIC8vIGJlY2F1c2UgaXRzIHdpdGhpbiBhIGhhcm5lc3NcclxuICAgICAgICAgICAgICAgICAgICA6IHRydWUgfSwgY29udGVudCkpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgX2hhbmRsZVNjcm9sbGVyRWwoc2Nyb2xsZXJFbCwga2V5KSB7XHJcbiAgICAgICAgICAgIGxldCBzZWN0aW9uID0gZ2V0U2VjdGlvbkJ5S2V5KHRoaXMucHJvcHMuc2VjdGlvbnMsIGtleSk7XHJcbiAgICAgICAgICAgIGlmIChzZWN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICBzZXRSZWYoc2VjdGlvbi5jaHVuay5zY3JvbGxlckVsUmVmLCBzY3JvbGxlckVsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjb21wb25lbnREaWRNb3VudCgpIHtcclxuICAgICAgICAgICAgdGhpcy5oYW5kbGVTaXppbmcoKTtcclxuICAgICAgICAgICAgdGhpcy5jb250ZXh0LmFkZFJlc2l6ZUhhbmRsZXIodGhpcy5oYW5kbGVTaXppbmcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb21wb25lbnREaWRVcGRhdGUoKSB7XHJcbiAgICAgICAgICAgIC8vIFRPRE86IG5lZWQgYmV0dGVyIHNvbHV0aW9uIHdoZW4gc3RhdGUgY29udGFpbnMgbm9uLXNpemluZyB0aGluZ3NcclxuICAgICAgICAgICAgdGhpcy5oYW5kbGVTaXppbmcoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5yZW1vdmVSZXNpemVIYW5kbGVyKHRoaXMuaGFuZGxlU2l6aW5nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29tcHV0ZVNocmlua1dpZHRoKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gaGFzU2hyaW5rV2lkdGgodGhpcy5wcm9wcy5jb2xzKVxyXG4gICAgICAgICAgICAgICAgPyBjb21wdXRlU2hyaW5rV2lkdGgodGhpcy5zY3JvbGxlckVsUmVmcy5nZXRBbGwoKSlcclxuICAgICAgICAgICAgICAgIDogMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29tcHV0ZVNjcm9sbGVyRGltcygpIHtcclxuICAgICAgICAgICAgbGV0IHNjcm9sbGJhcldpZHRoID0gZ2V0U2Nyb2xsYmFyV2lkdGhzKCk7XHJcbiAgICAgICAgICAgIGxldCB7IHNjcm9sbGVyUmVmcywgc2Nyb2xsZXJFbFJlZnMgfSA9IHRoaXM7XHJcbiAgICAgICAgICAgIGxldCBmb3JjZVlTY3JvbGxiYXJzID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGxldCBzY3JvbGxlckNsaWVudFdpZHRocyA9IHt9O1xyXG4gICAgICAgICAgICBsZXQgc2Nyb2xsZXJDbGllbnRIZWlnaHRzID0ge307XHJcbiAgICAgICAgICAgIGZvciAobGV0IHNlY3Rpb25LZXkgaW4gc2Nyb2xsZXJSZWZzLmN1cnJlbnRNYXApIHtcclxuICAgICAgICAgICAgICAgIGxldCBzY3JvbGxlciA9IHNjcm9sbGVyUmVmcy5jdXJyZW50TWFwW3NlY3Rpb25LZXldO1xyXG4gICAgICAgICAgICAgICAgaWYgKHNjcm9sbGVyICYmIHNjcm9sbGVyLm5lZWRzWVNjcm9sbGluZygpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yY2VZU2Nyb2xsYmFycyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yIChsZXQgc2VjdGlvbiBvZiB0aGlzLnByb3BzLnNlY3Rpb25zKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgc2VjdGlvbktleSA9IHNlY3Rpb24ua2V5O1xyXG4gICAgICAgICAgICAgICAgbGV0IHNjcm9sbGVyRWwgPSBzY3JvbGxlckVsUmVmcy5jdXJyZW50TWFwW3NlY3Rpb25LZXldO1xyXG4gICAgICAgICAgICAgICAgaWYgKHNjcm9sbGVyRWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgaGFybmVzc0VsID0gc2Nyb2xsZXJFbC5wYXJlbnROb2RlOyAvLyBUT0RPOiB3ZWlyZCB3YXkgdG8gZ2V0IHRoaXMuIG5lZWQgaGFybmVzcyBiL2MgZG9lc24ndCBpbmNsdWRlIHRhYmxlIGJvcmRlcnNcclxuICAgICAgICAgICAgICAgICAgICBzY3JvbGxlckNsaWVudFdpZHRoc1tzZWN0aW9uS2V5XSA9IE1hdGguZmxvb3IoaGFybmVzc0VsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoIC0gKGZvcmNlWVNjcm9sbGJhcnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyBzY3JvbGxiYXJXaWR0aC55IC8vIHVzZSBnbG9iYWwgYmVjYXVzZSBzY3JvbGxlciBtaWdodCBub3QgaGF2ZSBzY3JvbGxiYXJzIHlldCBidXQgd2lsbCBuZWVkIHRoZW0gaW4gZnV0dXJlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogMCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNjcm9sbGVyQ2xpZW50SGVpZ2h0c1tzZWN0aW9uS2V5XSA9IE1hdGguZmxvb3IoaGFybmVzc0VsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHsgZm9yY2VZU2Nyb2xsYmFycywgc2Nyb2xsZXJDbGllbnRXaWR0aHMsIHNjcm9sbGVyQ2xpZW50SGVpZ2h0cyB9O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIFNpbXBsZVNjcm9sbEdyaWQuYWRkU3RhdGVFcXVhbGl0eSh7XHJcbiAgICAgICAgc2Nyb2xsZXJDbGllbnRXaWR0aHM6IGlzUHJvcHNFcXVhbCxcclxuICAgICAgICBzY3JvbGxlckNsaWVudEhlaWdodHM6IGlzUHJvcHNFcXVhbCxcclxuICAgIH0pO1xyXG4gICAgZnVuY3Rpb24gZ2V0U2VjdGlvbkJ5S2V5KHNlY3Rpb25zLCBrZXkpIHtcclxuICAgICAgICBmb3IgKGxldCBzZWN0aW9uIG9mIHNlY3Rpb25zKSB7XHJcbiAgICAgICAgICAgIGlmIChzZWN0aW9uLmtleSA9PT0ga2V5KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VjdGlvbjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBjbGFzcyBFdmVudENvbnRhaW5lciBleHRlbmRzIEJhc2VDb21wb25lbnQge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgICAgICB0aGlzLmhhbmRsZUVsID0gKGVsKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVsID0gZWw7XHJcbiAgICAgICAgICAgICAgICBpZiAoZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZXRFbFNlZyhlbCwgdGhpcy5wcm9wcy5zZWcpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZW5kZXIoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgcHJvcHMsIGNvbnRleHQgfSA9IHRoaXM7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgb3B0aW9ucyB9ID0gY29udGV4dDtcclxuICAgICAgICAgICAgY29uc3QgeyBzZWcgfSA9IHByb3BzO1xyXG4gICAgICAgICAgICBjb25zdCB7IGV2ZW50UmFuZ2UgfSA9IHNlZztcclxuICAgICAgICAgICAgY29uc3QgeyB1aSB9ID0gZXZlbnRSYW5nZTtcclxuICAgICAgICAgICAgY29uc3QgcmVuZGVyUHJvcHMgPSB7XHJcbiAgICAgICAgICAgICAgICBldmVudDogbmV3IEV2ZW50SW1wbChjb250ZXh0LCBldmVudFJhbmdlLmRlZiwgZXZlbnRSYW5nZS5pbnN0YW5jZSksXHJcbiAgICAgICAgICAgICAgICB2aWV3OiBjb250ZXh0LnZpZXdBcGksXHJcbiAgICAgICAgICAgICAgICB0aW1lVGV4dDogcHJvcHMudGltZVRleHQsXHJcbiAgICAgICAgICAgICAgICB0ZXh0Q29sb3I6IHVpLnRleHRDb2xvcixcclxuICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogdWkuYmFja2dyb3VuZENvbG9yLFxyXG4gICAgICAgICAgICAgICAgYm9yZGVyQ29sb3I6IHVpLmJvcmRlckNvbG9yLFxyXG4gICAgICAgICAgICAgICAgaXNEcmFnZ2FibGU6ICFwcm9wcy5kaXNhYmxlRHJhZ2dpbmcgJiYgY29tcHV0ZVNlZ0RyYWdnYWJsZShzZWcsIGNvbnRleHQpLFxyXG4gICAgICAgICAgICAgICAgaXNTdGFydFJlc2l6YWJsZTogIXByb3BzLmRpc2FibGVSZXNpemluZyAmJiBjb21wdXRlU2VnU3RhcnRSZXNpemFibGUoc2VnLCBjb250ZXh0KSxcclxuICAgICAgICAgICAgICAgIGlzRW5kUmVzaXphYmxlOiAhcHJvcHMuZGlzYWJsZVJlc2l6aW5nICYmIGNvbXB1dGVTZWdFbmRSZXNpemFibGUoc2VnKSxcclxuICAgICAgICAgICAgICAgIGlzTWlycm9yOiBCb29sZWFuKHByb3BzLmlzRHJhZ2dpbmcgfHwgcHJvcHMuaXNSZXNpemluZyB8fCBwcm9wcy5pc0RhdGVTZWxlY3RpbmcpLFxyXG4gICAgICAgICAgICAgICAgaXNTdGFydDogQm9vbGVhbihzZWcuaXNTdGFydCksXHJcbiAgICAgICAgICAgICAgICBpc0VuZDogQm9vbGVhbihzZWcuaXNFbmQpLFxyXG4gICAgICAgICAgICAgICAgaXNQYXN0OiBCb29sZWFuKHByb3BzLmlzUGFzdCksXHJcbiAgICAgICAgICAgICAgICBpc0Z1dHVyZTogQm9vbGVhbihwcm9wcy5pc0Z1dHVyZSksXHJcbiAgICAgICAgICAgICAgICBpc1RvZGF5OiBCb29sZWFuKHByb3BzLmlzVG9kYXkpLFxyXG4gICAgICAgICAgICAgICAgaXNTZWxlY3RlZDogQm9vbGVhbihwcm9wcy5pc1NlbGVjdGVkKSxcclxuICAgICAgICAgICAgICAgIGlzRHJhZ2dpbmc6IEJvb2xlYW4ocHJvcHMuaXNEcmFnZ2luZyksXHJcbiAgICAgICAgICAgICAgICBpc1Jlc2l6aW5nOiBCb29sZWFuKHByb3BzLmlzUmVzaXppbmcpLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4gKHkoQ29udGVudENvbnRhaW5lciwgT2JqZWN0LmFzc2lnbih7fSwgcHJvcHMgLyogY29udGFpbnMgY2hpbGRyZW4gKi8sIHsgZWxSZWY6IHRoaXMuaGFuZGxlRWwsIGVsQ2xhc3NlczogW1xyXG4gICAgICAgICAgICAgICAgICAgIC4uLmdldEV2ZW50Q2xhc3NOYW1lcyhyZW5kZXJQcm9wcyksXHJcbiAgICAgICAgICAgICAgICAgICAgLi4uc2VnLmV2ZW50UmFuZ2UudWkuY2xhc3NOYW1lcyxcclxuICAgICAgICAgICAgICAgICAgICAuLi4ocHJvcHMuZWxDbGFzc2VzIHx8IFtdKSxcclxuICAgICAgICAgICAgICAgIF0sIHJlbmRlclByb3BzOiByZW5kZXJQcm9wcywgZ2VuZXJhdG9yTmFtZTogXCJldmVudENvbnRlbnRcIiwgY3VzdG9tR2VuZXJhdG9yOiBvcHRpb25zLmV2ZW50Q29udGVudCwgZGVmYXVsdEdlbmVyYXRvcjogcHJvcHMuZGVmYXVsdEdlbmVyYXRvciwgY2xhc3NOYW1lR2VuZXJhdG9yOiBvcHRpb25zLmV2ZW50Q2xhc3NOYW1lcywgZGlkTW91bnQ6IG9wdGlvbnMuZXZlbnREaWRNb3VudCwgd2lsbFVubW91bnQ6IG9wdGlvbnMuZXZlbnRXaWxsVW5tb3VudCB9KSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmVsICYmIHRoaXMucHJvcHMuc2VnICE9PSBwcmV2UHJvcHMuc2VnKSB7XHJcbiAgICAgICAgICAgICAgICBzZXRFbFNlZyh0aGlzLmVsLCB0aGlzLnByb3BzLnNlZyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gc2hvdWxkIG5vdCBiZSBhIHB1cmVjb21wb25lbnRcclxuICAgIGNsYXNzIFN0YW5kYXJkRXZlbnQgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcclxuICAgICAgICByZW5kZXIoKSB7XHJcbiAgICAgICAgICAgIGxldCB7IHByb3BzLCBjb250ZXh0IH0gPSB0aGlzO1xyXG4gICAgICAgICAgICBsZXQgeyBvcHRpb25zIH0gPSBjb250ZXh0O1xyXG4gICAgICAgICAgICBsZXQgeyBzZWcgfSA9IHByb3BzO1xyXG4gICAgICAgICAgICBsZXQgeyB1aSB9ID0gc2VnLmV2ZW50UmFuZ2U7XHJcbiAgICAgICAgICAgIGxldCB0aW1lRm9ybWF0ID0gb3B0aW9ucy5ldmVudFRpbWVGb3JtYXQgfHwgcHJvcHMuZGVmYXVsdFRpbWVGb3JtYXQ7XHJcbiAgICAgICAgICAgIGxldCB0aW1lVGV4dCA9IGJ1aWxkU2VnVGltZVRleHQoc2VnLCB0aW1lRm9ybWF0LCBjb250ZXh0LCBwcm9wcy5kZWZhdWx0RGlzcGxheUV2ZW50VGltZSwgcHJvcHMuZGVmYXVsdERpc3BsYXlFdmVudEVuZCk7XHJcbiAgICAgICAgICAgIHJldHVybiAoeShFdmVudENvbnRhaW5lciwgT2JqZWN0LmFzc2lnbih7fSwgcHJvcHMgLyogaW5jbHVkZXMgZWxSZWYgKi8sIHsgZWxUYWc6IFwiYVwiLCBlbFN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgYm9yZGVyQ29sb3I6IHVpLmJvcmRlckNvbG9yLFxyXG4gICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogdWkuYmFja2dyb3VuZENvbG9yLFxyXG4gICAgICAgICAgICAgICAgfSwgZWxBdHRyczogZ2V0U2VnQW5jaG9yQXR0cnMoc2VnLCBjb250ZXh0KSwgZGVmYXVsdEdlbmVyYXRvcjogcmVuZGVySW5uZXJDb250ZW50JDEkMSwgdGltZVRleHQ6IHRpbWVUZXh0IH0pLCAoSW5uZXJDb250ZW50LCBldmVudENvbnRlbnRBcmcpID0+ICh5KF8sIG51bGwsXHJcbiAgICAgICAgICAgICAgICB5KElubmVyQ29udGVudCwgeyBlbFRhZzogXCJkaXZcIiwgZWxDbGFzc2VzOiBbJ2ZjLWV2ZW50LW1haW4nXSwgZWxTdHlsZTogeyBjb2xvcjogZXZlbnRDb250ZW50QXJnLnRleHRDb2xvciB9IH0pLFxyXG4gICAgICAgICAgICAgICAgQm9vbGVhbihldmVudENvbnRlbnRBcmcuaXNTdGFydFJlc2l6YWJsZSkgJiYgKHkoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtZXZlbnQtcmVzaXplciBmYy1ldmVudC1yZXNpemVyLXN0YXJ0XCIgfSkpLFxyXG4gICAgICAgICAgICAgICAgQm9vbGVhbihldmVudENvbnRlbnRBcmcuaXNFbmRSZXNpemFibGUpICYmICh5KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLWV2ZW50LXJlc2l6ZXIgZmMtZXZlbnQtcmVzaXplci1lbmRcIiB9KSkpKSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHJlbmRlcklubmVyQ29udGVudCQxJDEoaW5uZXJQcm9wcykge1xyXG4gICAgICAgIHJldHVybiAoeShcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy1ldmVudC1tYWluLWZyYW1lXCIgfSxcclxuICAgICAgICAgICAgaW5uZXJQcm9wcy50aW1lVGV4dCAmJiAoeShcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy1ldmVudC10aW1lXCIgfSwgaW5uZXJQcm9wcy50aW1lVGV4dCkpLFxyXG4gICAgICAgICAgICB5KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLWV2ZW50LXRpdGxlLWNvbnRhaW5lclwiIH0sXHJcbiAgICAgICAgICAgICAgICB5KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLWV2ZW50LXRpdGxlIGZjLXN0aWNreVwiIH0sIGlubmVyUHJvcHMuZXZlbnQudGl0bGUgfHwgeShfLCBudWxsLCBcIlxcdTAwQTBcIikpKSkpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IE5vd0luZGljYXRvckNvbnRhaW5lciA9IChwcm9wcykgPT4gKHkoVmlld0NvbnRleHRUeXBlLkNvbnN1bWVyLCBudWxsLCAoY29udGV4dCkgPT4ge1xyXG4gICAgICAgIGxldCB7IG9wdGlvbnMgfSA9IGNvbnRleHQ7XHJcbiAgICAgICAgbGV0IHJlbmRlclByb3BzID0ge1xyXG4gICAgICAgICAgICBpc0F4aXM6IHByb3BzLmlzQXhpcyxcclxuICAgICAgICAgICAgZGF0ZTogY29udGV4dC5kYXRlRW52LnRvRGF0ZShwcm9wcy5kYXRlKSxcclxuICAgICAgICAgICAgdmlldzogY29udGV4dC52aWV3QXBpLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuICh5KENvbnRlbnRDb250YWluZXIsIE9iamVjdC5hc3NpZ24oe30sIHByb3BzIC8qIGluY2x1ZGVzIGNoaWxkcmVuICovLCB7IGVsVGFnOiBwcm9wcy5lbFRhZyB8fCAnZGl2JywgcmVuZGVyUHJvcHM6IHJlbmRlclByb3BzLCBnZW5lcmF0b3JOYW1lOiBcIm5vd0luZGljYXRvckNvbnRlbnRcIiwgY3VzdG9tR2VuZXJhdG9yOiBvcHRpb25zLm5vd0luZGljYXRvckNvbnRlbnQsIGNsYXNzTmFtZUdlbmVyYXRvcjogb3B0aW9ucy5ub3dJbmRpY2F0b3JDbGFzc05hbWVzLCBkaWRNb3VudDogb3B0aW9ucy5ub3dJbmRpY2F0b3JEaWRNb3VudCwgd2lsbFVubW91bnQ6IG9wdGlvbnMubm93SW5kaWNhdG9yV2lsbFVubW91bnQgfSkpKTtcclxuICAgIH0pKTtcclxuXHJcbiAgICBjb25zdCBEQVlfTlVNX0ZPUk1BVCA9IGNyZWF0ZUZvcm1hdHRlcih7IGRheTogJ251bWVyaWMnIH0pO1xyXG4gICAgY2xhc3MgRGF5Q2VsbENvbnRhaW5lciBleHRlbmRzIEJhc2VDb21wb25lbnQge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgICAgICB0aGlzLnJlZmluZVJlbmRlclByb3BzID0gbWVtb2l6ZU9iakFyZyhyZWZpbmVSZW5kZXJQcm9wcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlbmRlcigpIHtcclxuICAgICAgICAgICAgbGV0IHsgcHJvcHMsIGNvbnRleHQgfSA9IHRoaXM7XHJcbiAgICAgICAgICAgIGxldCB7IG9wdGlvbnMgfSA9IGNvbnRleHQ7XHJcbiAgICAgICAgICAgIGxldCByZW5kZXJQcm9wcyA9IHRoaXMucmVmaW5lUmVuZGVyUHJvcHMoe1xyXG4gICAgICAgICAgICAgICAgZGF0ZTogcHJvcHMuZGF0ZSxcclxuICAgICAgICAgICAgICAgIGRhdGVQcm9maWxlOiBwcm9wcy5kYXRlUHJvZmlsZSxcclxuICAgICAgICAgICAgICAgIHRvZGF5UmFuZ2U6IHByb3BzLnRvZGF5UmFuZ2UsXHJcbiAgICAgICAgICAgICAgICBpc01vbnRoU3RhcnQ6IHByb3BzLmlzTW9udGhTdGFydCB8fCBmYWxzZSxcclxuICAgICAgICAgICAgICAgIHNob3dEYXlOdW1iZXI6IHByb3BzLnNob3dEYXlOdW1iZXIsXHJcbiAgICAgICAgICAgICAgICBleHRyYVJlbmRlclByb3BzOiBwcm9wcy5leHRyYVJlbmRlclByb3BzLFxyXG4gICAgICAgICAgICAgICAgdmlld0FwaTogY29udGV4dC52aWV3QXBpLFxyXG4gICAgICAgICAgICAgICAgZGF0ZUVudjogY29udGV4dC5kYXRlRW52LFxyXG4gICAgICAgICAgICAgICAgbW9udGhTdGFydEZvcm1hdDogb3B0aW9ucy5tb250aFN0YXJ0Rm9ybWF0LFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuICh5KENvbnRlbnRDb250YWluZXIsIE9iamVjdC5hc3NpZ24oe30sIHByb3BzIC8qIGluY2x1ZGVzIGNoaWxkcmVuICovLCB7IGVsQ2xhc3NlczogW1xyXG4gICAgICAgICAgICAgICAgICAgIC4uLmdldERheUNsYXNzTmFtZXMocmVuZGVyUHJvcHMsIGNvbnRleHQudGhlbWUpLFxyXG4gICAgICAgICAgICAgICAgICAgIC4uLihwcm9wcy5lbENsYXNzZXMgfHwgW10pLFxyXG4gICAgICAgICAgICAgICAgXSwgZWxBdHRyczogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwcm9wcy5lbEF0dHJzKSwgKHJlbmRlclByb3BzLmlzRGlzYWJsZWQgPyB7fSA6IHsgJ2RhdGEtZGF0ZSc6IGZvcm1hdERheVN0cmluZyhwcm9wcy5kYXRlKSB9KSksIHJlbmRlclByb3BzOiByZW5kZXJQcm9wcywgZ2VuZXJhdG9yTmFtZTogXCJkYXlDZWxsQ29udGVudFwiLCBjdXN0b21HZW5lcmF0b3I6IG9wdGlvbnMuZGF5Q2VsbENvbnRlbnQsIGRlZmF1bHRHZW5lcmF0b3I6IHByb3BzLmRlZmF1bHRHZW5lcmF0b3IsIGNsYXNzTmFtZUdlbmVyYXRvcjogXHJcbiAgICAgICAgICAgICAgICAvLyBkb24ndCB1c2UgY3VzdG9tIGNsYXNzTmFtZXMgaWYgZGlzYWJsZWRcclxuICAgICAgICAgICAgICAgIHJlbmRlclByb3BzLmlzRGlzYWJsZWQgPyB1bmRlZmluZWQgOiBvcHRpb25zLmRheUNlbGxDbGFzc05hbWVzLCBkaWRNb3VudDogb3B0aW9ucy5kYXlDZWxsRGlkTW91bnQsIHdpbGxVbm1vdW50OiBvcHRpb25zLmRheUNlbGxXaWxsVW5tb3VudCB9KSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGhhc0N1c3RvbURheUNlbGxDb250ZW50KG9wdGlvbnMpIHtcclxuICAgICAgICByZXR1cm4gQm9vbGVhbihvcHRpb25zLmRheUNlbGxDb250ZW50IHx8IGhhc0N1c3RvbVJlbmRlcmluZ0hhbmRsZXIoJ2RheUNlbGxDb250ZW50Jywgb3B0aW9ucykpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gcmVmaW5lUmVuZGVyUHJvcHMocmF3KSB7XHJcbiAgICAgICAgbGV0IHsgZGF0ZSwgZGF0ZUVudiwgZGF0ZVByb2ZpbGUsIGlzTW9udGhTdGFydCB9ID0gcmF3O1xyXG4gICAgICAgIGxldCBkYXlNZXRhID0gZ2V0RGF0ZU1ldGEoZGF0ZSwgcmF3LnRvZGF5UmFuZ2UsIG51bGwsIGRhdGVQcm9maWxlKTtcclxuICAgICAgICBsZXQgZGF5TnVtYmVyVGV4dCA9IHJhdy5zaG93RGF5TnVtYmVyID8gKGRhdGVFbnYuZm9ybWF0KGRhdGUsIGlzTW9udGhTdGFydCA/IHJhdy5tb250aFN0YXJ0Rm9ybWF0IDogREFZX05VTV9GT1JNQVQpKSA6ICcnO1xyXG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IGRhdGU6IGRhdGVFbnYudG9EYXRlKGRhdGUpLCB2aWV3OiByYXcudmlld0FwaSB9LCBkYXlNZXRhKSwgeyBpc01vbnRoU3RhcnQsXHJcbiAgICAgICAgICAgIGRheU51bWJlclRleHQgfSksIHJhdy5leHRyYVJlbmRlclByb3BzKTtcclxuICAgIH1cclxuXHJcbiAgICBjbGFzcyBCZ0V2ZW50IGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XHJcbiAgICAgICAgcmVuZGVyKCkge1xyXG4gICAgICAgICAgICBsZXQgeyBwcm9wcyB9ID0gdGhpcztcclxuICAgICAgICAgICAgbGV0IHsgc2VnIH0gPSBwcm9wcztcclxuICAgICAgICAgICAgcmV0dXJuICh5KEV2ZW50Q29udGFpbmVyLCB7IGVsVGFnOiBcImRpdlwiLCBlbENsYXNzZXM6IFsnZmMtYmctZXZlbnQnXSwgZWxTdHlsZTogeyBiYWNrZ3JvdW5kQ29sb3I6IHNlZy5ldmVudFJhbmdlLnVpLmJhY2tncm91bmRDb2xvciB9LCBkZWZhdWx0R2VuZXJhdG9yOiByZW5kZXJJbm5lckNvbnRlbnQkMywgc2VnOiBzZWcsIHRpbWVUZXh0OiBcIlwiLCBpc0RyYWdnaW5nOiBmYWxzZSwgaXNSZXNpemluZzogZmFsc2UsIGlzRGF0ZVNlbGVjdGluZzogZmFsc2UsIGlzU2VsZWN0ZWQ6IGZhbHNlLCBpc1Bhc3Q6IHByb3BzLmlzUGFzdCwgaXNGdXR1cmU6IHByb3BzLmlzRnV0dXJlLCBpc1RvZGF5OiBwcm9wcy5pc1RvZGF5LCBkaXNhYmxlRHJhZ2dpbmc6IHRydWUsIGRpc2FibGVSZXNpemluZzogdHJ1ZSB9KSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gcmVuZGVySW5uZXJDb250ZW50JDMocHJvcHMpIHtcclxuICAgICAgICBsZXQgeyB0aXRsZSB9ID0gcHJvcHMuZXZlbnQ7XHJcbiAgICAgICAgcmV0dXJuIHRpdGxlICYmICh5KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLWV2ZW50LXRpdGxlXCIgfSwgcHJvcHMuZXZlbnQudGl0bGUpKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHJlbmRlckZpbGwoZmlsbFR5cGUpIHtcclxuICAgICAgICByZXR1cm4gKHkoXCJkaXZcIiwgeyBjbGFzc05hbWU6IGBmYy0ke2ZpbGxUeXBlfWAgfSkpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IFdlZWtOdW1iZXJDb250YWluZXIgPSAocHJvcHMpID0+ICh5KFZpZXdDb250ZXh0VHlwZS5Db25zdW1lciwgbnVsbCwgKGNvbnRleHQpID0+IHtcclxuICAgICAgICBsZXQgeyBkYXRlRW52LCBvcHRpb25zIH0gPSBjb250ZXh0O1xyXG4gICAgICAgIGxldCB7IGRhdGUgfSA9IHByb3BzO1xyXG4gICAgICAgIGxldCBmb3JtYXQgPSBvcHRpb25zLndlZWtOdW1iZXJGb3JtYXQgfHwgcHJvcHMuZGVmYXVsdEZvcm1hdDtcclxuICAgICAgICBsZXQgbnVtID0gZGF0ZUVudi5jb21wdXRlV2Vla051bWJlcihkYXRlKTsgLy8gVE9ETzogc29tZWhvdyB1c2UgZm9yIGZvcm1hdHRpbmcgYXMgd2VsbD9cclxuICAgICAgICBsZXQgdGV4dCA9IGRhdGVFbnYuZm9ybWF0KGRhdGUsIGZvcm1hdCk7XHJcbiAgICAgICAgbGV0IHJlbmRlclByb3BzID0geyBudW0sIHRleHQsIGRhdGUgfTtcclxuICAgICAgICByZXR1cm4gKHkoQ29udGVudENvbnRhaW5lciAvLyB3aHkgaXNuJ3QgV2Vla051bWJlckNvbnRlbnRBcmcgYmVpbmcgYXV0by1kZXRlY3RlZD9cclxuICAgICAgICAsIE9iamVjdC5hc3NpZ24oe30sIHByb3BzIC8qIGluY2x1ZGVzIGNoaWxkcmVuICovLCB7IHJlbmRlclByb3BzOiByZW5kZXJQcm9wcywgZ2VuZXJhdG9yTmFtZTogXCJ3ZWVrTnVtYmVyQ29udGVudFwiLCBjdXN0b21HZW5lcmF0b3I6IG9wdGlvbnMud2Vla051bWJlckNvbnRlbnQsIGRlZmF1bHRHZW5lcmF0b3I6IHJlbmRlcklubmVyLCBjbGFzc05hbWVHZW5lcmF0b3I6IG9wdGlvbnMud2Vla051bWJlckNsYXNzTmFtZXMsIGRpZE1vdW50OiBvcHRpb25zLndlZWtOdW1iZXJEaWRNb3VudCwgd2lsbFVubW91bnQ6IG9wdGlvbnMud2Vla051bWJlcldpbGxVbm1vdW50IH0pKSk7XHJcbiAgICB9KSk7XHJcbiAgICBmdW5jdGlvbiByZW5kZXJJbm5lcihpbm5lclByb3BzKSB7XHJcbiAgICAgICAgcmV0dXJuIGlubmVyUHJvcHMudGV4dDtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBQQURESU5HX0ZST01fVklFV1BPUlQgPSAxMDtcclxuICAgIGNsYXNzIFBvcG92ZXIgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcclxuICAgICAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IHtcclxuICAgICAgICAgICAgICAgIHRpdGxlSWQ6IGdldFVuaXF1ZURvbUlkKCksXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlUm9vdEVsID0gKGVsKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJvb3RFbCA9IGVsO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucHJvcHMuZWxSZWYpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZXRSZWYodGhpcy5wcm9wcy5lbFJlZiwgZWwpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvLyBUcmlnZ2VyZWQgd2hlbiB0aGUgdXNlciBjbGlja3MgKmFueXdoZXJlKiBpbiB0aGUgZG9jdW1lbnQsIGZvciB0aGUgYXV0b0hpZGUgZmVhdHVyZVxyXG4gICAgICAgICAgICB0aGlzLmhhbmRsZURvY3VtZW50TW91c2VEb3duID0gKGV2KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAvLyBvbmx5IGhpZGUgdGhlIHBvcG92ZXIgaWYgdGhlIGNsaWNrIGhhcHBlbmVkIG91dHNpZGUgdGhlIHBvcG92ZXJcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IGdldEV2ZW50VGFyZ2V0VmlhUm9vdChldik7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMucm9vdEVsLmNvbnRhaW5zKHRhcmdldCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUNsb3NlQ2xpY2soKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdGhpcy5oYW5kbGVEb2N1bWVudEtleURvd24gPSAoZXYpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChldi5rZXkgPT09ICdFc2NhcGUnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVDbG9zZUNsaWNrKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlQ2xvc2VDbGljayA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGxldCB7IG9uQ2xvc2UgfSA9IHRoaXMucHJvcHM7XHJcbiAgICAgICAgICAgICAgICBpZiAob25DbG9zZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG9uQ2xvc2UoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVuZGVyKCkge1xyXG4gICAgICAgICAgICBsZXQgeyB0aGVtZSwgb3B0aW9ucyB9ID0gdGhpcy5jb250ZXh0O1xyXG4gICAgICAgICAgICBsZXQgeyBwcm9wcywgc3RhdGUgfSA9IHRoaXM7XHJcbiAgICAgICAgICAgIGxldCBjbGFzc05hbWVzID0gW1xyXG4gICAgICAgICAgICAgICAgJ2ZjLXBvcG92ZXInLFxyXG4gICAgICAgICAgICAgICAgdGhlbWUuZ2V0Q2xhc3MoJ3BvcG92ZXInKSxcclxuICAgICAgICAgICAgXS5jb25jYXQocHJvcHMuZXh0cmFDbGFzc05hbWVzIHx8IFtdKTtcclxuICAgICAgICAgICAgcmV0dXJuIGooeShcImRpdlwiLCBPYmplY3QuYXNzaWduKHt9LCBwcm9wcy5leHRyYUF0dHJzLCB7IGlkOiBwcm9wcy5pZCwgY2xhc3NOYW1lOiBjbGFzc05hbWVzLmpvaW4oJyAnKSwgXCJhcmlhLWxhYmVsbGVkYnlcIjogc3RhdGUudGl0bGVJZCwgcmVmOiB0aGlzLmhhbmRsZVJvb3RFbCB9KSxcclxuICAgICAgICAgICAgICAgIHkoXCJkaXZcIiwgeyBjbGFzc05hbWU6ICdmYy1wb3BvdmVyLWhlYWRlciAnICsgdGhlbWUuZ2V0Q2xhc3MoJ3BvcG92ZXJIZWFkZXInKSB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHkoXCJzcGFuXCIsIHsgY2xhc3NOYW1lOiBcImZjLXBvcG92ZXItdGl0bGVcIiwgaWQ6IHN0YXRlLnRpdGxlSWQgfSwgcHJvcHMudGl0bGUpLFxyXG4gICAgICAgICAgICAgICAgICAgIHkoXCJzcGFuXCIsIHsgY2xhc3NOYW1lOiAnZmMtcG9wb3Zlci1jbG9zZSAnICsgdGhlbWUuZ2V0SWNvbkNsYXNzKCdjbG9zZScpLCB0aXRsZTogb3B0aW9ucy5jbG9zZUhpbnQsIG9uQ2xpY2s6IHRoaXMuaGFuZGxlQ2xvc2VDbGljayB9KSksXHJcbiAgICAgICAgICAgICAgICB5KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiAnZmMtcG9wb3Zlci1ib2R5ICcgKyB0aGVtZS5nZXRDbGFzcygncG9wb3ZlckNvbnRlbnQnKSB9LCBwcm9wcy5jaGlsZHJlbikpLCBwcm9wcy5wYXJlbnRFbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xyXG4gICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLmhhbmRsZURvY3VtZW50TW91c2VEb3duKTtcclxuICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuaGFuZGxlRG9jdW1lbnRLZXlEb3duKTtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVTaXplKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xyXG4gICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLmhhbmRsZURvY3VtZW50TW91c2VEb3duKTtcclxuICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuaGFuZGxlRG9jdW1lbnRLZXlEb3duKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdXBkYXRlU2l6ZSgpIHtcclxuICAgICAgICAgICAgbGV0IHsgaXNSdGwgfSA9IHRoaXMuY29udGV4dDtcclxuICAgICAgICAgICAgbGV0IHsgYWxpZ25tZW50RWwsIGFsaWduR3JpZFRvcCB9ID0gdGhpcy5wcm9wcztcclxuICAgICAgICAgICAgbGV0IHsgcm9vdEVsIH0gPSB0aGlzO1xyXG4gICAgICAgICAgICBsZXQgYWxpZ25tZW50UmVjdCA9IGNvbXB1dGVDbGlwcGVkQ2xpZW50UmVjdChhbGlnbm1lbnRFbCk7XHJcbiAgICAgICAgICAgIGlmIChhbGlnbm1lbnRSZWN0KSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgcG9wb3ZlckRpbXMgPSByb290RWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICAgICAgICAgICAgICAvLyBwb3NpdGlvbiByZWxhdGl2ZSB0byB2aWV3cG9ydFxyXG4gICAgICAgICAgICAgICAgbGV0IHBvcG92ZXJUb3AgPSBhbGlnbkdyaWRUb3BcclxuICAgICAgICAgICAgICAgICAgICA/IGVsZW1lbnRDbG9zZXN0KGFsaWdubWVudEVsLCAnLmZjLXNjcm9sbGdyaWQnKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3BcclxuICAgICAgICAgICAgICAgICAgICA6IGFsaWdubWVudFJlY3QudG9wO1xyXG4gICAgICAgICAgICAgICAgbGV0IHBvcG92ZXJMZWZ0ID0gaXNSdGwgPyBhbGlnbm1lbnRSZWN0LnJpZ2h0IC0gcG9wb3ZlckRpbXMud2lkdGggOiBhbGlnbm1lbnRSZWN0LmxlZnQ7XHJcbiAgICAgICAgICAgICAgICAvLyBjb25zdHJhaW5cclxuICAgICAgICAgICAgICAgIHBvcG92ZXJUb3AgPSBNYXRoLm1heChwb3BvdmVyVG9wLCBQQURESU5HX0ZST01fVklFV1BPUlQpO1xyXG4gICAgICAgICAgICAgICAgcG9wb3ZlckxlZnQgPSBNYXRoLm1pbihwb3BvdmVyTGVmdCwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoIC0gUEFERElOR19GUk9NX1ZJRVdQT1JUIC0gcG9wb3ZlckRpbXMud2lkdGgpO1xyXG4gICAgICAgICAgICAgICAgcG9wb3ZlckxlZnQgPSBNYXRoLm1heChwb3BvdmVyTGVmdCwgUEFERElOR19GUk9NX1ZJRVdQT1JUKTtcclxuICAgICAgICAgICAgICAgIGxldCBvcmlnaW4gPSByb290RWwub2Zmc2V0UGFyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgICAgICAgICAgICAgYXBwbHlTdHlsZShyb290RWwsIHtcclxuICAgICAgICAgICAgICAgICAgICB0b3A6IHBvcG92ZXJUb3AgLSBvcmlnaW4udG9wLFxyXG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6IHBvcG92ZXJMZWZ0IC0gb3JpZ2luLmxlZnQsXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBjbGFzcyBNb3JlUG9wb3ZlciBleHRlbmRzIERhdGVDb21wb25lbnQge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgICAgICB0aGlzLmhhbmRsZVJvb3RFbCA9IChyb290RWwpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMucm9vdEVsID0gcm9vdEVsO1xyXG4gICAgICAgICAgICAgICAgaWYgKHJvb3RFbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5yZWdpc3RlckludGVyYWN0aXZlQ29tcG9uZW50KHRoaXMsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWw6IHJvb3RFbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXNlRXZlbnRDZW50ZXI6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LnVucmVnaXN0ZXJJbnRlcmFjdGl2ZUNvbXBvbmVudCh0aGlzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVuZGVyKCkge1xyXG4gICAgICAgICAgICBsZXQgeyBvcHRpb25zLCBkYXRlRW52IH0gPSB0aGlzLmNvbnRleHQ7XHJcbiAgICAgICAgICAgIGxldCB7IHByb3BzIH0gPSB0aGlzO1xyXG4gICAgICAgICAgICBsZXQgeyBzdGFydERhdGUsIHRvZGF5UmFuZ2UsIGRhdGVQcm9maWxlIH0gPSBwcm9wcztcclxuICAgICAgICAgICAgbGV0IHRpdGxlID0gZGF0ZUVudi5mb3JtYXQoc3RhcnREYXRlLCBvcHRpb25zLmRheVBvcG92ZXJGb3JtYXQpO1xyXG4gICAgICAgICAgICByZXR1cm4gKHkoRGF5Q2VsbENvbnRhaW5lciwgeyBlbFJlZjogdGhpcy5oYW5kbGVSb290RWwsIGRhdGU6IHN0YXJ0RGF0ZSwgZGF0ZVByb2ZpbGU6IGRhdGVQcm9maWxlLCB0b2RheVJhbmdlOiB0b2RheVJhbmdlIH0sIChJbm5lckNvbnRlbnQsIHJlbmRlclByb3BzLCBlbEF0dHJzKSA9PiAoeShQb3BvdmVyLCB7IGVsUmVmOiBlbEF0dHJzLnJlZiwgaWQ6IHByb3BzLmlkLCB0aXRsZTogdGl0bGUsIGV4dHJhQ2xhc3NOYW1lczogWydmYy1tb3JlLXBvcG92ZXInXS5jb25jYXQoZWxBdHRycy5jbGFzc05hbWUgfHwgW10pLCBleHRyYUF0dHJzOiBlbEF0dHJzIC8qIFRPRE86IG1ha2UgdGhlc2UgdGltZS1iYXNlZCB3aGVuIG5vdCB3aG9sZS1kYXk/ICovLCBwYXJlbnRFbDogcHJvcHMucGFyZW50RWwsIGFsaWdubWVudEVsOiBwcm9wcy5hbGlnbm1lbnRFbCwgYWxpZ25HcmlkVG9wOiBwcm9wcy5hbGlnbkdyaWRUb3AsIG9uQ2xvc2U6IHByb3BzLm9uQ2xvc2UgfSxcclxuICAgICAgICAgICAgICAgIGhhc0N1c3RvbURheUNlbGxDb250ZW50KG9wdGlvbnMpICYmICh5KElubmVyQ29udGVudCwgeyBlbFRhZzogXCJkaXZcIiwgZWxDbGFzc2VzOiBbJ2ZjLW1vcmUtcG9wb3Zlci1taXNjJ10gfSkpLFxyXG4gICAgICAgICAgICAgICAgcHJvcHMuY2hpbGRyZW4pKSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBxdWVyeUhpdChwb3NpdGlvbkxlZnQsIHBvc2l0aW9uVG9wLCBlbFdpZHRoLCBlbEhlaWdodCkge1xyXG4gICAgICAgICAgICBsZXQgeyByb290RWwsIHByb3BzIH0gPSB0aGlzO1xyXG4gICAgICAgICAgICBpZiAocG9zaXRpb25MZWZ0ID49IDAgJiYgcG9zaXRpb25MZWZ0IDwgZWxXaWR0aCAmJlxyXG4gICAgICAgICAgICAgICAgcG9zaXRpb25Ub3AgPj0gMCAmJiBwb3NpdGlvblRvcCA8IGVsSGVpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGVQcm9maWxlOiBwcm9wcy5kYXRlUHJvZmlsZSxcclxuICAgICAgICAgICAgICAgICAgICBkYXRlU3BhbjogT2JqZWN0LmFzc2lnbih7IGFsbERheTogIXByb3BzLmZvcmNlVGltZWQsIHJhbmdlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogcHJvcHMuc3RhcnREYXRlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiBwcm9wcy5lbmREYXRlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IH0sIHByb3BzLmV4dHJhRGF0ZVNwYW4pLFxyXG4gICAgICAgICAgICAgICAgICAgIGRheUVsOiByb290RWwsXHJcbiAgICAgICAgICAgICAgICAgICAgcmVjdDoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3A6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0OiBlbFdpZHRoLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBib3R0b206IGVsSGVpZ2h0LFxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgbGF5ZXI6IDEsIC8vIGltcG9ydGFudCB3aGVuIGNvbXBhcmluZyB3aXRoIGhpdHMgZnJvbSBvdGhlciBjb21wb25lbnRzXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBjbGFzcyBNb3JlTGlua0NvbnRhaW5lciBleHRlbmRzIEJhc2VDb21wb25lbnQge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0ge1xyXG4gICAgICAgICAgICAgICAgaXNQb3BvdmVyT3BlbjogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBwb3BvdmVySWQ6IGdldFVuaXF1ZURvbUlkKCksXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlTGlua0VsID0gKGxpbmtFbCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5saW5rRWwgPSBsaW5rRWw7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wcm9wcy5lbFJlZikge1xyXG4gICAgICAgICAgICAgICAgICAgIHNldFJlZih0aGlzLnByb3BzLmVsUmVmLCBsaW5rRWwpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB0aGlzLmhhbmRsZUNsaWNrID0gKGV2KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBsZXQgeyBwcm9wcywgY29udGV4dCB9ID0gdGhpcztcclxuICAgICAgICAgICAgICAgIGxldCB7IG1vcmVMaW5rQ2xpY2sgfSA9IGNvbnRleHQub3B0aW9ucztcclxuICAgICAgICAgICAgICAgIGxldCBkYXRlID0gY29tcHV0ZVJhbmdlKHByb3BzKS5zdGFydDtcclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGJ1aWxkUHVibGljU2VnKHNlZykge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCB7IGRlZiwgaW5zdGFuY2UsIHJhbmdlIH0gPSBzZWcuZXZlbnRSYW5nZTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudDogbmV3IEV2ZW50SW1wbChjb250ZXh0LCBkZWYsIGluc3RhbmNlKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IGNvbnRleHQuZGF0ZUVudi50b0RhdGUocmFuZ2Uuc3RhcnQpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IGNvbnRleHQuZGF0ZUVudi50b0RhdGUocmFuZ2UuZW5kKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXNTdGFydDogc2VnLmlzU3RhcnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzRW5kOiBzZWcuaXNFbmQsXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbW9yZUxpbmtDbGljayA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgICAgIG1vcmVMaW5rQ2xpY2sgPSBtb3JlTGlua0NsaWNrKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWxsRGF5OiBCb29sZWFuKHByb3BzLmFsbERheURhdGUpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxTZWdzOiBwcm9wcy5hbGxTZWdzLm1hcChidWlsZFB1YmxpY1NlZyksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhpZGRlblNlZ3M6IHByb3BzLmhpZGRlblNlZ3MubWFwKGJ1aWxkUHVibGljU2VnKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAganNFdmVudDogZXYsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpZXc6IGNvbnRleHQudmlld0FwaSxcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICghbW9yZUxpbmtDbGljayB8fCBtb3JlTGlua0NsaWNrID09PSAncG9wb3ZlcicpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKHsgaXNQb3BvdmVyT3BlbjogdHJ1ZSB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBtb3JlTGlua0NsaWNrID09PSAnc3RyaW5nJykgeyAvLyBhIHZpZXcgbmFtZVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuY2FsZW5kYXJBcGkuem9vbVRvKGRhdGUsIG1vcmVMaW5rQ2xpY2spO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB0aGlzLmhhbmRsZVBvcG92ZXJDbG9zZSA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoeyBpc1BvcG92ZXJPcGVuOiBmYWxzZSB9KTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVuZGVyKCkge1xyXG4gICAgICAgICAgICBsZXQgeyBwcm9wcywgc3RhdGUgfSA9IHRoaXM7XHJcbiAgICAgICAgICAgIHJldHVybiAoeShWaWV3Q29udGV4dFR5cGUuQ29uc3VtZXIsIG51bGwsIChjb250ZXh0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBsZXQgeyB2aWV3QXBpLCBvcHRpb25zLCBjYWxlbmRhckFwaSB9ID0gY29udGV4dDtcclxuICAgICAgICAgICAgICAgIGxldCB7IG1vcmVMaW5rVGV4dCB9ID0gb3B0aW9ucztcclxuICAgICAgICAgICAgICAgIGxldCB7IG1vcmVDbnQgfSA9IHByb3BzO1xyXG4gICAgICAgICAgICAgICAgbGV0IHJhbmdlID0gY29tcHV0ZVJhbmdlKHByb3BzKTtcclxuICAgICAgICAgICAgICAgIGxldCB0ZXh0ID0gdHlwZW9mIG1vcmVMaW5rVGV4dCA9PT0gJ2Z1bmN0aW9uJyAvLyBUT0RPOiBldmVudHVhbGx5IHVzZSBmb3JtYXRXaXRoT3JkaW5hbHNcclxuICAgICAgICAgICAgICAgICAgICA/IG1vcmVMaW5rVGV4dC5jYWxsKGNhbGVuZGFyQXBpLCBtb3JlQ250KVxyXG4gICAgICAgICAgICAgICAgICAgIDogYCske21vcmVDbnR9ICR7bW9yZUxpbmtUZXh0fWA7XHJcbiAgICAgICAgICAgICAgICBsZXQgaGludCA9IGZvcm1hdFdpdGhPcmRpbmFscyhvcHRpb25zLm1vcmVMaW5rSGludCwgW21vcmVDbnRdLCB0ZXh0KTtcclxuICAgICAgICAgICAgICAgIGxldCByZW5kZXJQcm9wcyA9IHtcclxuICAgICAgICAgICAgICAgICAgICBudW06IG1vcmVDbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgc2hvcnRUZXh0OiBgKyR7bW9yZUNudH1gLFxyXG4gICAgICAgICAgICAgICAgICAgIHRleHQsXHJcbiAgICAgICAgICAgICAgICAgICAgdmlldzogdmlld0FwaSxcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKHkoXywgbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICBCb29sZWFuKHByb3BzLm1vcmVDbnQpICYmICh5KENvbnRlbnRDb250YWluZXIsIHsgZWxUYWc6IHByb3BzLmVsVGFnIHx8ICdhJywgZWxSZWY6IHRoaXMuaGFuZGxlTGlua0VsLCBlbENsYXNzZXM6IFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLihwcm9wcy5lbENsYXNzZXMgfHwgW10pLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2ZjLW1vcmUtbGluaycsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF0sIGVsU3R5bGU6IHByb3BzLmVsU3R5bGUsIGVsQXR0cnM6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwcm9wcy5lbEF0dHJzKSwgY3JlYXRlQXJpYUNsaWNrQXR0cnModGhpcy5oYW5kbGVDbGljaykpLCB7IHRpdGxlOiBoaW50LCAnYXJpYS1leHBhbmRlZCc6IHN0YXRlLmlzUG9wb3Zlck9wZW4sICdhcmlhLWNvbnRyb2xzJzogc3RhdGUuaXNQb3BvdmVyT3BlbiA/IHN0YXRlLnBvcG92ZXJJZCA6ICcnIH0pLCByZW5kZXJQcm9wczogcmVuZGVyUHJvcHMsIGdlbmVyYXRvck5hbWU6IFwibW9yZUxpbmtDb250ZW50XCIsIGN1c3RvbUdlbmVyYXRvcjogb3B0aW9ucy5tb3JlTGlua0NvbnRlbnQsIGRlZmF1bHRHZW5lcmF0b3I6IHByb3BzLmRlZmF1bHRHZW5lcmF0b3IgfHwgcmVuZGVyTW9yZUxpbmtJbm5lciQxLCBjbGFzc05hbWVHZW5lcmF0b3I6IG9wdGlvbnMubW9yZUxpbmtDbGFzc05hbWVzLCBkaWRNb3VudDogb3B0aW9ucy5tb3JlTGlua0RpZE1vdW50LCB3aWxsVW5tb3VudDogb3B0aW9ucy5tb3JlTGlua1dpbGxVbm1vdW50IH0sIHByb3BzLmNoaWxkcmVuKSksXHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuaXNQb3BvdmVyT3BlbiAmJiAoeShNb3JlUG9wb3ZlciwgeyBpZDogc3RhdGUucG9wb3ZlcklkLCBzdGFydERhdGU6IHJhbmdlLnN0YXJ0LCBlbmREYXRlOiByYW5nZS5lbmQsIGRhdGVQcm9maWxlOiBwcm9wcy5kYXRlUHJvZmlsZSwgdG9kYXlSYW5nZTogcHJvcHMudG9kYXlSYW5nZSwgZXh0cmFEYXRlU3BhbjogcHJvcHMuZXh0cmFEYXRlU3BhbiwgcGFyZW50RWw6IHRoaXMucGFyZW50RWwsIGFsaWdubWVudEVsOiBwcm9wcy5hbGlnbm1lbnRFbFJlZiA/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wcy5hbGlnbm1lbnRFbFJlZi5jdXJyZW50IDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGlua0VsLCBhbGlnbkdyaWRUb3A6IHByb3BzLmFsaWduR3JpZFRvcCwgZm9yY2VUaW1lZDogcHJvcHMuZm9yY2VUaW1lZCwgb25DbG9zZTogdGhpcy5oYW5kbGVQb3BvdmVyQ2xvc2UgfSwgcHJvcHMucG9wb3ZlckNvbnRlbnQoKSkpKSk7XHJcbiAgICAgICAgICAgIH0pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29tcG9uZW50RGlkTW91bnQoKSB7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlUGFyZW50RWwoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29tcG9uZW50RGlkVXBkYXRlKCkge1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVBhcmVudEVsKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHVwZGF0ZVBhcmVudEVsKCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5saW5rRWwpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50RWwgPSBlbGVtZW50Q2xvc2VzdCh0aGlzLmxpbmtFbCwgJy5mYy12aWV3LWhhcm5lc3MnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHJlbmRlck1vcmVMaW5rSW5uZXIkMShwcm9wcykge1xyXG4gICAgICAgIHJldHVybiBwcm9wcy50ZXh0O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gY29tcHV0ZVJhbmdlKHByb3BzKSB7XHJcbiAgICAgICAgaWYgKHByb3BzLmFsbERheURhdGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHN0YXJ0OiBwcm9wcy5hbGxEYXlEYXRlLFxyXG4gICAgICAgICAgICAgICAgZW5kOiBhZGREYXlzKHByb3BzLmFsbERheURhdGUsIDEpLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgeyBoaWRkZW5TZWdzIH0gPSBwcm9wcztcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBzdGFydDogY29tcHV0ZUVhcmxpZXN0U2VnU3RhcnQoaGlkZGVuU2VncyksXHJcbiAgICAgICAgICAgIGVuZDogY29tcHV0ZUxhdGVzdFNlZ0VuZChoaWRkZW5TZWdzKSxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gY29tcHV0ZUVhcmxpZXN0U2VnU3RhcnQoc2Vncykge1xyXG4gICAgICAgIHJldHVybiBzZWdzLnJlZHVjZShwaWNrRWFybGllc3RTdGFydCkuZXZlbnRSYW5nZS5yYW5nZS5zdGFydDtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHBpY2tFYXJsaWVzdFN0YXJ0KHNlZzAsIHNlZzEpIHtcclxuICAgICAgICByZXR1cm4gc2VnMC5ldmVudFJhbmdlLnJhbmdlLnN0YXJ0IDwgc2VnMS5ldmVudFJhbmdlLnJhbmdlLnN0YXJ0ID8gc2VnMCA6IHNlZzE7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBjb21wdXRlTGF0ZXN0U2VnRW5kKHNlZ3MpIHtcclxuICAgICAgICByZXR1cm4gc2Vncy5yZWR1Y2UocGlja0xhdGVzdEVuZCkuZXZlbnRSYW5nZS5yYW5nZS5lbmQ7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBwaWNrTGF0ZXN0RW5kKHNlZzAsIHNlZzEpIHtcclxuICAgICAgICByZXR1cm4gc2VnMC5ldmVudFJhbmdlLnJhbmdlLmVuZCA+IHNlZzEuZXZlbnRSYW5nZS5yYW5nZS5lbmQgPyBzZWcwIDogc2VnMTtcclxuICAgIH1cclxuXHJcbiAgICBjbGFzcyBWaWV3Q29udGFpbmVyIGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XHJcbiAgICAgICAgcmVuZGVyKCkge1xyXG4gICAgICAgICAgICBsZXQgeyBwcm9wcywgY29udGV4dCB9ID0gdGhpcztcclxuICAgICAgICAgICAgbGV0IHsgb3B0aW9ucyB9ID0gY29udGV4dDtcclxuICAgICAgICAgICAgbGV0IHJlbmRlclByb3BzID0geyB2aWV3OiBjb250ZXh0LnZpZXdBcGkgfTtcclxuICAgICAgICAgICAgcmV0dXJuICh5KENvbnRlbnRDb250YWluZXIsIE9iamVjdC5hc3NpZ24oe30sIHByb3BzLCB7IGVsVGFnOiBwcm9wcy5lbFRhZyB8fCAnZGl2JywgZWxDbGFzc2VzOiBbXHJcbiAgICAgICAgICAgICAgICAgICAgLi4uYnVpbGRWaWV3Q2xhc3NOYW1lcyhwcm9wcy52aWV3U3BlYyksXHJcbiAgICAgICAgICAgICAgICAgICAgLi4uKHByb3BzLmVsQ2xhc3NlcyB8fCBbXSksXHJcbiAgICAgICAgICAgICAgICBdLCByZW5kZXJQcm9wczogcmVuZGVyUHJvcHMsIGNsYXNzTmFtZUdlbmVyYXRvcjogb3B0aW9ucy52aWV3Q2xhc3NOYW1lcywgZ2VuZXJhdG9yTmFtZTogdW5kZWZpbmVkLCBkaWRNb3VudDogb3B0aW9ucy52aWV3RGlkTW91bnQsIHdpbGxVbm1vdW50OiBvcHRpb25zLnZpZXdXaWxsVW5tb3VudCB9KSwgKCkgPT4gcHJvcHMuY2hpbGRyZW4pKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBidWlsZFZpZXdDbGFzc05hbWVzKHZpZXdTcGVjKSB7XHJcbiAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgYGZjLSR7dmlld1NwZWMudHlwZX0tdmlld2AsXHJcbiAgICAgICAgICAgICdmYy12aWV3JyxcclxuICAgICAgICBdO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IEVWRU5UX1NPVVJDRV9SRUZJTkVSUyA9IHtcclxuICAgICAgICBpZDogU3RyaW5nLFxyXG4gICAgICAgIGRlZmF1bHRBbGxEYXk6IEJvb2xlYW4sXHJcbiAgICAgICAgdXJsOiBTdHJpbmcsXHJcbiAgICAgICAgZm9ybWF0OiBTdHJpbmcsXHJcbiAgICAgICAgZXZlbnRzOiBpZGVudGl0eSxcclxuICAgICAgICBldmVudERhdGFUcmFuc2Zvcm06IGlkZW50aXR5LFxyXG4gICAgICAgIC8vIGZvciBhbnkgbmV0d29yay1yZWxhdGVkIHNvdXJjZXNcclxuICAgICAgICBzdWNjZXNzOiBpZGVudGl0eSxcclxuICAgICAgICBmYWlsdXJlOiBpZGVudGl0eSxcclxuICAgIH07XHJcbiAgICBmdW5jdGlvbiBwYXJzZUV2ZW50U291cmNlKHJhdywgY29udGV4dCwgcmVmaW5lcnMgPSBidWlsZEV2ZW50U291cmNlUmVmaW5lcnMoY29udGV4dCkpIHtcclxuICAgICAgICBsZXQgcmF3T2JqO1xyXG4gICAgICAgIGlmICh0eXBlb2YgcmF3ID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICByYXdPYmogPSB7IHVybDogcmF3IH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiByYXcgPT09ICdmdW5jdGlvbicgfHwgQXJyYXkuaXNBcnJheShyYXcpKSB7XHJcbiAgICAgICAgICAgIHJhd09iaiA9IHsgZXZlbnRzOiByYXcgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHJhdyA9PT0gJ29iamVjdCcgJiYgcmF3KSB7IC8vIG5vdCBudWxsXHJcbiAgICAgICAgICAgIHJhd09iaiA9IHJhdztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJhd09iaikge1xyXG4gICAgICAgICAgICBsZXQgeyByZWZpbmVkLCBleHRyYSB9ID0gcmVmaW5lUHJvcHMocmF3T2JqLCByZWZpbmVycyk7XHJcbiAgICAgICAgICAgIGxldCBtZXRhUmVzID0gYnVpbGRFdmVudFNvdXJjZU1ldGEocmVmaW5lZCwgY29udGV4dCk7XHJcbiAgICAgICAgICAgIGlmIChtZXRhUmVzKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIF9yYXc6IHJhdyxcclxuICAgICAgICAgICAgICAgICAgICBpc0ZldGNoaW5nOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICBsYXRlc3RGZXRjaElkOiAnJyxcclxuICAgICAgICAgICAgICAgICAgICBmZXRjaFJhbmdlOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRBbGxEYXk6IHJlZmluZWQuZGVmYXVsdEFsbERheSxcclxuICAgICAgICAgICAgICAgICAgICBldmVudERhdGFUcmFuc2Zvcm06IHJlZmluZWQuZXZlbnREYXRhVHJhbnNmb3JtLFxyXG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IHJlZmluZWQuc3VjY2VzcyxcclxuICAgICAgICAgICAgICAgICAgICBmYWlsdXJlOiByZWZpbmVkLmZhaWx1cmUsXHJcbiAgICAgICAgICAgICAgICAgICAgcHVibGljSWQ6IHJlZmluZWQuaWQgfHwgJycsXHJcbiAgICAgICAgICAgICAgICAgICAgc291cmNlSWQ6IGd1aWQoKSxcclxuICAgICAgICAgICAgICAgICAgICBzb3VyY2VEZWZJZDogbWV0YVJlcy5zb3VyY2VEZWZJZCxcclxuICAgICAgICAgICAgICAgICAgICBtZXRhOiBtZXRhUmVzLm1ldGEsXHJcbiAgICAgICAgICAgICAgICAgICAgdWk6IGNyZWF0ZUV2ZW50VWkocmVmaW5lZCwgY29udGV4dCksXHJcbiAgICAgICAgICAgICAgICAgICAgZXh0ZW5kZWRQcm9wczogZXh0cmEsXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYnVpbGRFdmVudFNvdXJjZVJlZmluZXJzKGNvbnRleHQpIHtcclxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIEVWRU5UX1VJX1JFRklORVJTKSwgRVZFTlRfU09VUkNFX1JFRklORVJTKSwgY29udGV4dC5wbHVnaW5Ib29rcy5ldmVudFNvdXJjZVJlZmluZXJzKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGJ1aWxkRXZlbnRTb3VyY2VNZXRhKHJhdywgY29udGV4dCkge1xyXG4gICAgICAgIGxldCBkZWZzID0gY29udGV4dC5wbHVnaW5Ib29rcy5ldmVudFNvdXJjZURlZnM7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IGRlZnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpIC09IDEpIHsgLy8gbGF0ZXItYWRkZWQgcGx1Z2lucyB0YWtlIHByZWNlZGVuY2VcclxuICAgICAgICAgICAgbGV0IGRlZiA9IGRlZnNbaV07XHJcbiAgICAgICAgICAgIGxldCBtZXRhID0gZGVmLnBhcnNlTWV0YShyYXcpO1xyXG4gICAgICAgICAgICBpZiAobWV0YSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgc291cmNlRGVmSWQ6IGksIG1ldGEgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBjbGFzcyBDYWxlbmRhckltcGwge1xyXG4gICAgICAgIGdldEN1cnJlbnREYXRhKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50RGF0YU1hbmFnZXIuZ2V0Q3VycmVudERhdGEoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZGlzcGF0Y2goYWN0aW9uKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudERhdGFNYW5hZ2VyLmRpc3BhdGNoKGFjdGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGdldCB2aWV3KCkgeyByZXR1cm4gdGhpcy5nZXRDdXJyZW50RGF0YSgpLnZpZXdBcGk7IH1cclxuICAgICAgICBiYXRjaFJlbmRlcmluZyhjYWxsYmFjaykge1xyXG4gICAgICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB1cGRhdGVTaXplKCkge1xyXG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ19yZXNpemUnLCB0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gT3B0aW9uc1xyXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAgICAgc2V0T3B0aW9uKG5hbWUsIHZhbCkge1xyXG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoKHtcclxuICAgICAgICAgICAgICAgIHR5cGU6ICdTRVRfT1BUSU9OJyxcclxuICAgICAgICAgICAgICAgIG9wdGlvbk5hbWU6IG5hbWUsXHJcbiAgICAgICAgICAgICAgICByYXdPcHRpb25WYWx1ZTogdmFsLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZ2V0T3B0aW9uKG5hbWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudERhdGFNYW5hZ2VyLmN1cnJlbnRDYWxlbmRhck9wdGlvbnNJbnB1dFtuYW1lXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZ2V0QXZhaWxhYmxlTG9jYWxlQ29kZXMoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLmdldEN1cnJlbnREYXRhKCkuYXZhaWxhYmxlUmF3TG9jYWxlcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFRyaWdnZXJcclxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgICAgIG9uKGhhbmRsZXJOYW1lLCBoYW5kbGVyKSB7XHJcbiAgICAgICAgICAgIGxldCB7IGN1cnJlbnREYXRhTWFuYWdlciB9ID0gdGhpcztcclxuICAgICAgICAgICAgaWYgKGN1cnJlbnREYXRhTWFuYWdlci5jdXJyZW50Q2FsZW5kYXJPcHRpb25zUmVmaW5lcnNbaGFuZGxlck5hbWVdKSB7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50RGF0YU1hbmFnZXIuZW1pdHRlci5vbihoYW5kbGVyTmFtZSwgaGFuZGxlcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYFVua25vd24gbGlzdGVuZXIgbmFtZSAnJHtoYW5kbGVyTmFtZX0nYCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgb2ZmKGhhbmRsZXJOYW1lLCBoYW5kbGVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudERhdGFNYW5hZ2VyLmVtaXR0ZXIub2ZmKGhhbmRsZXJOYW1lLCBoYW5kbGVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gbm90IG1lYW50IGZvciBwdWJsaWMgdXNlXHJcbiAgICAgICAgdHJpZ2dlcihoYW5kbGVyTmFtZSwgLi4uYXJncykge1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnREYXRhTWFuYWdlci5lbWl0dGVyLnRyaWdnZXIoaGFuZGxlck5hbWUsIC4uLmFyZ3MpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBWaWV3XHJcbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgICAgICBjaGFuZ2VWaWV3KHZpZXdUeXBlLCBkYXRlT3JSYW5nZSkge1xyXG4gICAgICAgICAgICB0aGlzLmJhdGNoUmVuZGVyaW5nKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMudW5zZWxlY3QoKTtcclxuICAgICAgICAgICAgICAgIGlmIChkYXRlT3JSYW5nZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRlT3JSYW5nZS5zdGFydCAmJiBkYXRlT3JSYW5nZS5lbmQpIHsgLy8gYSByYW5nZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdDSEFOR0VfVklFV19UWVBFJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpZXdUeXBlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnU0VUX09QVElPTicsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25OYW1lOiAndmlzaWJsZVJhbmdlJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhd09wdGlvblZhbHVlOiBkYXRlT3JSYW5nZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgeyBkYXRlRW52IH0gPSB0aGlzLmdldEN1cnJlbnREYXRhKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ0NIQU5HRV9WSUVXX1RZUEUnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlld1R5cGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRlTWFya2VyOiBkYXRlRW52LmNyZWF0ZU1hcmtlcihkYXRlT3JSYW5nZSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnQ0hBTkdFX1ZJRVdfVFlQRScsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpZXdUeXBlLFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gRm9yY2VzIG5hdmlnYXRpb24gdG8gYSB2aWV3IGZvciB0aGUgZ2l2ZW4gZGF0ZS5cclxuICAgICAgICAvLyBgdmlld1R5cGVgIGNhbiBiZSBhIHNwZWNpZmljIHZpZXcgbmFtZSBvciBhIGdlbmVyaWMgb25lIGxpa2UgXCJ3ZWVrXCIgb3IgXCJkYXlcIi5cclxuICAgICAgICAvLyBuZWVkcyB0byBjaGFuZ2VcclxuICAgICAgICB6b29tVG8oZGF0ZU1hcmtlciwgdmlld1R5cGUpIHtcclxuICAgICAgICAgICAgbGV0IHN0YXRlID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpO1xyXG4gICAgICAgICAgICBsZXQgc3BlYztcclxuICAgICAgICAgICAgdmlld1R5cGUgPSB2aWV3VHlwZSB8fCAnZGF5JzsgLy8gZGF5IGlzIGRlZmF1bHQgem9vbVxyXG4gICAgICAgICAgICBzcGVjID0gc3RhdGUudmlld1NwZWNzW3ZpZXdUeXBlXSB8fCB0aGlzLmdldFVuaXRWaWV3U3BlYyh2aWV3VHlwZSk7XHJcbiAgICAgICAgICAgIHRoaXMudW5zZWxlY3QoKTtcclxuICAgICAgICAgICAgaWYgKHNwZWMpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goe1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdDSEFOR0VfVklFV19UWVBFJyxcclxuICAgICAgICAgICAgICAgICAgICB2aWV3VHlwZTogc3BlYy50eXBlLFxyXG4gICAgICAgICAgICAgICAgICAgIGRhdGVNYXJrZXIsXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goe1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdDSEFOR0VfREFURScsXHJcbiAgICAgICAgICAgICAgICAgICAgZGF0ZU1hcmtlcixcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEdpdmVuIGEgZHVyYXRpb24gc2luZ3VsYXIgdW5pdCwgbGlrZSBcIndlZWtcIiBvciBcImRheVwiLCBmaW5kcyBhIG1hdGNoaW5nIHZpZXcgc3BlYy5cclxuICAgICAgICAvLyBQcmVmZXJlbmNlIGlzIGdpdmVuIHRvIHZpZXdzIHRoYXQgaGF2ZSBjb3JyZXNwb25kaW5nIGJ1dHRvbnMuXHJcbiAgICAgICAgZ2V0VW5pdFZpZXdTcGVjKHVuaXQpIHtcclxuICAgICAgICAgICAgbGV0IHsgdmlld1NwZWNzLCB0b29sYmFyQ29uZmlnIH0gPSB0aGlzLmdldEN1cnJlbnREYXRhKCk7XHJcbiAgICAgICAgICAgIGxldCB2aWV3VHlwZXMgPSBbXS5jb25jYXQodG9vbGJhckNvbmZpZy5oZWFkZXIgPyB0b29sYmFyQ29uZmlnLmhlYWRlci52aWV3c1dpdGhCdXR0b25zIDogW10sIHRvb2xiYXJDb25maWcuZm9vdGVyID8gdG9vbGJhckNvbmZpZy5mb290ZXIudmlld3NXaXRoQnV0dG9ucyA6IFtdKTtcclxuICAgICAgICAgICAgbGV0IGk7XHJcbiAgICAgICAgICAgIGxldCBzcGVjO1xyXG4gICAgICAgICAgICBmb3IgKGxldCB2aWV3VHlwZSBpbiB2aWV3U3BlY3MpIHtcclxuICAgICAgICAgICAgICAgIHZpZXdUeXBlcy5wdXNoKHZpZXdUeXBlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdmlld1R5cGVzLmxlbmd0aDsgaSArPSAxKSB7XHJcbiAgICAgICAgICAgICAgICBzcGVjID0gdmlld1NwZWNzW3ZpZXdUeXBlc1tpXV07XHJcbiAgICAgICAgICAgICAgICBpZiAoc3BlYykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzcGVjLnNpbmdsZVVuaXQgPT09IHVuaXQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNwZWM7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBDdXJyZW50IERhdGVcclxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgICAgIHByZXYoKSB7XHJcbiAgICAgICAgICAgIHRoaXMudW5zZWxlY3QoKTtcclxuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaCh7IHR5cGU6ICdQUkVWJyB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbmV4dCgpIHtcclxuICAgICAgICAgICAgdGhpcy51bnNlbGVjdCgpO1xyXG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoKHsgdHlwZTogJ05FWFQnIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwcmV2WWVhcigpIHtcclxuICAgICAgICAgICAgbGV0IHN0YXRlID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpO1xyXG4gICAgICAgICAgICB0aGlzLnVuc2VsZWN0KCk7XHJcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goe1xyXG4gICAgICAgICAgICAgICAgdHlwZTogJ0NIQU5HRV9EQVRFJyxcclxuICAgICAgICAgICAgICAgIGRhdGVNYXJrZXI6IHN0YXRlLmRhdGVFbnYuYWRkWWVhcnMoc3RhdGUuY3VycmVudERhdGUsIC0xKSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG5leHRZZWFyKCkge1xyXG4gICAgICAgICAgICBsZXQgc3RhdGUgPSB0aGlzLmdldEN1cnJlbnREYXRhKCk7XHJcbiAgICAgICAgICAgIHRoaXMudW5zZWxlY3QoKTtcclxuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaCh7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiAnQ0hBTkdFX0RBVEUnLFxyXG4gICAgICAgICAgICAgICAgZGF0ZU1hcmtlcjogc3RhdGUuZGF0ZUVudi5hZGRZZWFycyhzdGF0ZS5jdXJyZW50RGF0ZSwgMSksXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0b2RheSgpIHtcclxuICAgICAgICAgICAgbGV0IHN0YXRlID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpO1xyXG4gICAgICAgICAgICB0aGlzLnVuc2VsZWN0KCk7XHJcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goe1xyXG4gICAgICAgICAgICAgICAgdHlwZTogJ0NIQU5HRV9EQVRFJyxcclxuICAgICAgICAgICAgICAgIGRhdGVNYXJrZXI6IGdldE5vdyhzdGF0ZS5jYWxlbmRhck9wdGlvbnMubm93LCBzdGF0ZS5kYXRlRW52KSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGdvdG9EYXRlKHpvbmVkRGF0ZUlucHV0KSB7XHJcbiAgICAgICAgICAgIGxldCBzdGF0ZSA9IHRoaXMuZ2V0Q3VycmVudERhdGEoKTtcclxuICAgICAgICAgICAgdGhpcy51bnNlbGVjdCgpO1xyXG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoKHtcclxuICAgICAgICAgICAgICAgIHR5cGU6ICdDSEFOR0VfREFURScsXHJcbiAgICAgICAgICAgICAgICBkYXRlTWFya2VyOiBzdGF0ZS5kYXRlRW52LmNyZWF0ZU1hcmtlcih6b25lZERhdGVJbnB1dCksXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpbmNyZW1lbnREYXRlKGRlbHRhSW5wdXQpIHtcclxuICAgICAgICAgICAgbGV0IHN0YXRlID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpO1xyXG4gICAgICAgICAgICBsZXQgZGVsdGEgPSBjcmVhdGVEdXJhdGlvbihkZWx0YUlucHV0KTtcclxuICAgICAgICAgICAgaWYgKGRlbHRhKSB7IC8vIGVsc2UsIHdhcm4gYWJvdXQgaW52YWxpZCBpbnB1dD9cclxuICAgICAgICAgICAgICAgIHRoaXMudW5zZWxlY3QoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goe1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdDSEFOR0VfREFURScsXHJcbiAgICAgICAgICAgICAgICAgICAgZGF0ZU1hcmtlcjogc3RhdGUuZGF0ZUVudi5hZGQoc3RhdGUuY3VycmVudERhdGUsIGRlbHRhKSxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGdldERhdGUoKSB7XHJcbiAgICAgICAgICAgIGxldCBzdGF0ZSA9IHRoaXMuZ2V0Q3VycmVudERhdGEoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHN0YXRlLmRhdGVFbnYudG9EYXRlKHN0YXRlLmN1cnJlbnREYXRlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gRGF0ZSBGb3JtYXR0aW5nIFV0aWxzXHJcbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgICAgICBmb3JtYXREYXRlKGQsIGZvcm1hdHRlcikge1xyXG4gICAgICAgICAgICBsZXQgeyBkYXRlRW52IH0gPSB0aGlzLmdldEN1cnJlbnREYXRhKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBkYXRlRW52LmZvcm1hdChkYXRlRW52LmNyZWF0ZU1hcmtlcihkKSwgY3JlYXRlRm9ybWF0dGVyKGZvcm1hdHRlcikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBgc2V0dGluZ3NgIGlzIGZvciBmb3JtYXR0ZXIgQU5EIGlzRW5kRXhjbHVzaXZlXHJcbiAgICAgICAgZm9ybWF0UmFuZ2UoZDAsIGQxLCBzZXR0aW5ncykge1xyXG4gICAgICAgICAgICBsZXQgeyBkYXRlRW52IH0gPSB0aGlzLmdldEN1cnJlbnREYXRhKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBkYXRlRW52LmZvcm1hdFJhbmdlKGRhdGVFbnYuY3JlYXRlTWFya2VyKGQwKSwgZGF0ZUVudi5jcmVhdGVNYXJrZXIoZDEpLCBjcmVhdGVGb3JtYXR0ZXIoc2V0dGluZ3MpLCBzZXR0aW5ncyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvcm1hdElzbyhkLCBvbWl0VGltZSkge1xyXG4gICAgICAgICAgICBsZXQgeyBkYXRlRW52IH0gPSB0aGlzLmdldEN1cnJlbnREYXRhKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBkYXRlRW52LmZvcm1hdElzbyhkYXRlRW52LmNyZWF0ZU1hcmtlcihkKSwgeyBvbWl0VGltZSB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gRGF0ZSBTZWxlY3Rpb24gLyBFdmVudCBTZWxlY3Rpb24gLyBEYXlDbGlja1xyXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAgICAgc2VsZWN0KGRhdGVPck9iaiwgZW5kRGF0ZSkge1xyXG4gICAgICAgICAgICBsZXQgc2VsZWN0aW9uSW5wdXQ7XHJcbiAgICAgICAgICAgIGlmIChlbmREYXRlID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGlmIChkYXRlT3JPYmouc3RhcnQgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbklucHV0ID0gZGF0ZU9yT2JqO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uSW5wdXQgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBkYXRlT3JPYmosXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uSW5wdXQgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IGRhdGVPck9iaixcclxuICAgICAgICAgICAgICAgICAgICBlbmQ6IGVuZERhdGUsXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxldCBzdGF0ZSA9IHRoaXMuZ2V0Q3VycmVudERhdGEoKTtcclxuICAgICAgICAgICAgbGV0IHNlbGVjdGlvbiA9IHBhcnNlRGF0ZVNwYW4oc2VsZWN0aW9uSW5wdXQsIHN0YXRlLmRhdGVFbnYsIGNyZWF0ZUR1cmF0aW9uKHsgZGF5czogMSB9KSk7XHJcbiAgICAgICAgICAgIGlmIChzZWxlY3Rpb24pIHsgLy8gdGhyb3cgcGFyc2UgZXJyb3Igb3RoZXJ3aXNlP1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaCh7IHR5cGU6ICdTRUxFQ1RfREFURVMnLCBzZWxlY3Rpb24gfSk7XHJcbiAgICAgICAgICAgICAgICB0cmlnZ2VyRGF0ZVNlbGVjdChzZWxlY3Rpb24sIG51bGwsIHN0YXRlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB1bnNlbGVjdChwZXYpIHtcclxuICAgICAgICAgICAgbGV0IHN0YXRlID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpO1xyXG4gICAgICAgICAgICBpZiAoc3RhdGUuZGF0ZVNlbGVjdGlvbikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaCh7IHR5cGU6ICdVTlNFTEVDVF9EQVRFUycgfSk7XHJcbiAgICAgICAgICAgICAgICB0cmlnZ2VyRGF0ZVVuc2VsZWN0KHBldiwgc3RhdGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFB1YmxpYyBFdmVudHMgQVBJXHJcbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgICAgICBhZGRFdmVudChldmVudElucHV0LCBzb3VyY2VJbnB1dCkge1xyXG4gICAgICAgICAgICBpZiAoZXZlbnRJbnB1dCBpbnN0YW5jZW9mIEV2ZW50SW1wbCkge1xyXG4gICAgICAgICAgICAgICAgbGV0IGRlZiA9IGV2ZW50SW5wdXQuX2RlZjtcclxuICAgICAgICAgICAgICAgIGxldCBpbnN0YW5jZSA9IGV2ZW50SW5wdXQuX2luc3RhbmNlO1xyXG4gICAgICAgICAgICAgICAgbGV0IGN1cnJlbnREYXRhID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpO1xyXG4gICAgICAgICAgICAgICAgLy8gbm90IGFscmVhZHkgcHJlc2VudD8gZG9uJ3Qgd2FudCB0byBhZGQgYW4gb2xkIHNuYXBzaG90XHJcbiAgICAgICAgICAgICAgICBpZiAoIWN1cnJlbnREYXRhLmV2ZW50U3RvcmUuZGVmc1tkZWYuZGVmSWRdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdBRERfRVZFTlRTJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRTdG9yZTogZXZlbnRUdXBsZVRvU3RvcmUoeyBkZWYsIGluc3RhbmNlIH0pLCAvLyBUT0RPOiBiZXR0ZXIgdXRpbCBmb3IgdHdvIGFyZ3M/XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyRXZlbnRBZGQoZXZlbnRJbnB1dCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZXZlbnRJbnB1dDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgc3RhdGUgPSB0aGlzLmdldEN1cnJlbnREYXRhKCk7XHJcbiAgICAgICAgICAgIGxldCBldmVudFNvdXJjZTtcclxuICAgICAgICAgICAgaWYgKHNvdXJjZUlucHV0IGluc3RhbmNlb2YgRXZlbnRTb3VyY2VJbXBsKSB7XHJcbiAgICAgICAgICAgICAgICBldmVudFNvdXJjZSA9IHNvdXJjZUlucHV0LmludGVybmFsRXZlbnRTb3VyY2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHNvdXJjZUlucHV0ID09PSAnYm9vbGVhbicpIHtcclxuICAgICAgICAgICAgICAgIGlmIChzb3VyY2VJbnB1dCkgeyAvLyB0cnVlLiBwYXJ0IG9mIHRoZSBmaXJzdCBldmVudCBzb3VyY2VcclxuICAgICAgICAgICAgICAgICAgICBbZXZlbnRTb3VyY2VdID0gaGFzaFZhbHVlc1RvQXJyYXkoc3RhdGUuZXZlbnRTb3VyY2VzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChzb3VyY2VJbnB1dCAhPSBudWxsKSB7IC8vIGFuIElELiBhY2NlcHRzIGEgbnVtYmVyIHRvb1xyXG4gICAgICAgICAgICAgICAgbGV0IHNvdXJjZUFwaSA9IHRoaXMuZ2V0RXZlbnRTb3VyY2VCeUlkKHNvdXJjZUlucHV0KTsgLy8gVE9ETzogdXNlIGFuIGludGVybmFsIGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICBpZiAoIXNvdXJjZUFwaSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgQ291bGQgbm90IGZpbmQgYW4gZXZlbnQgc291cmNlIHdpdGggSUQgXCIke3NvdXJjZUlucHV0fVwiYCk7IC8vIFRPRE86IHRlc3RcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGV2ZW50U291cmNlID0gc291cmNlQXBpLmludGVybmFsRXZlbnRTb3VyY2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IHR1cGxlID0gcGFyc2VFdmVudChldmVudElucHV0LCBldmVudFNvdXJjZSwgc3RhdGUsIGZhbHNlKTtcclxuICAgICAgICAgICAgaWYgKHR1cGxlKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgbmV3RXZlbnRBcGkgPSBuZXcgRXZlbnRJbXBsKHN0YXRlLCB0dXBsZS5kZWYsIHR1cGxlLmRlZi5yZWN1cnJpbmdEZWYgPyBudWxsIDogdHVwbGUuaW5zdGFuY2UpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ0FERF9FVkVOVFMnLFxyXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50U3RvcmU6IGV2ZW50VHVwbGVUb1N0b3JlKHR1cGxlKSxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyRXZlbnRBZGQobmV3RXZlbnRBcGkpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ld0V2ZW50QXBpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0cmlnZ2VyRXZlbnRBZGQoZXZlbnRBcGkpIHtcclxuICAgICAgICAgICAgbGV0IHsgZW1pdHRlciB9ID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpO1xyXG4gICAgICAgICAgICBlbWl0dGVyLnRyaWdnZXIoJ2V2ZW50QWRkJywge1xyXG4gICAgICAgICAgICAgICAgZXZlbnQ6IGV2ZW50QXBpLFxyXG4gICAgICAgICAgICAgICAgcmVsYXRlZEV2ZW50czogW10sXHJcbiAgICAgICAgICAgICAgICByZXZlcnQ6ICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ1JFTU9WRV9FVkVOVFMnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudFN0b3JlOiBldmVudEFwaVRvU3RvcmUoZXZlbnRBcGkpLFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFRPRE86IG9wdGltaXplXHJcbiAgICAgICAgZ2V0RXZlbnRCeUlkKGlkKSB7XHJcbiAgICAgICAgICAgIGxldCBzdGF0ZSA9IHRoaXMuZ2V0Q3VycmVudERhdGEoKTtcclxuICAgICAgICAgICAgbGV0IHsgZGVmcywgaW5zdGFuY2VzIH0gPSBzdGF0ZS5ldmVudFN0b3JlO1xyXG4gICAgICAgICAgICBpZCA9IFN0cmluZyhpZCk7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGRlZklkIGluIGRlZnMpIHtcclxuICAgICAgICAgICAgICAgIGxldCBkZWYgPSBkZWZzW2RlZklkXTtcclxuICAgICAgICAgICAgICAgIGlmIChkZWYucHVibGljSWQgPT09IGlkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlZi5yZWN1cnJpbmdEZWYpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBFdmVudEltcGwoc3RhdGUsIGRlZiwgbnVsbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGluc3RhbmNlSWQgaW4gaW5zdGFuY2VzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBpbnN0YW5jZSA9IGluc3RhbmNlc1tpbnN0YW5jZUlkXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluc3RhbmNlLmRlZklkID09PSBkZWYuZGVmSWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRXZlbnRJbXBsKHN0YXRlLCBkZWYsIGluc3RhbmNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZ2V0RXZlbnRzKCkge1xyXG4gICAgICAgICAgICBsZXQgY3VycmVudERhdGEgPSB0aGlzLmdldEN1cnJlbnREYXRhKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBidWlsZEV2ZW50QXBpcyhjdXJyZW50RGF0YS5ldmVudFN0b3JlLCBjdXJyZW50RGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlbW92ZUFsbEV2ZW50cygpIHtcclxuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaCh7IHR5cGU6ICdSRU1PVkVfQUxMX0VWRU5UUycgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFB1YmxpYyBFdmVudCBTb3VyY2VzIEFQSVxyXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAgICAgZ2V0RXZlbnRTb3VyY2VzKCkge1xyXG4gICAgICAgICAgICBsZXQgc3RhdGUgPSB0aGlzLmdldEN1cnJlbnREYXRhKCk7XHJcbiAgICAgICAgICAgIGxldCBzb3VyY2VIYXNoID0gc3RhdGUuZXZlbnRTb3VyY2VzO1xyXG4gICAgICAgICAgICBsZXQgc291cmNlQXBpcyA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpbnRlcm5hbElkIGluIHNvdXJjZUhhc2gpIHtcclxuICAgICAgICAgICAgICAgIHNvdXJjZUFwaXMucHVzaChuZXcgRXZlbnRTb3VyY2VJbXBsKHN0YXRlLCBzb3VyY2VIYXNoW2ludGVybmFsSWRdKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHNvdXJjZUFwaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGdldEV2ZW50U291cmNlQnlJZChpZCkge1xyXG4gICAgICAgICAgICBsZXQgc3RhdGUgPSB0aGlzLmdldEN1cnJlbnREYXRhKCk7XHJcbiAgICAgICAgICAgIGxldCBzb3VyY2VIYXNoID0gc3RhdGUuZXZlbnRTb3VyY2VzO1xyXG4gICAgICAgICAgICBpZCA9IFN0cmluZyhpZCk7XHJcbiAgICAgICAgICAgIGZvciAobGV0IHNvdXJjZUlkIGluIHNvdXJjZUhhc2gpIHtcclxuICAgICAgICAgICAgICAgIGlmIChzb3VyY2VIYXNoW3NvdXJjZUlkXS5wdWJsaWNJZCA9PT0gaWQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEV2ZW50U291cmNlSW1wbChzdGF0ZSwgc291cmNlSGFzaFtzb3VyY2VJZF0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBhZGRFdmVudFNvdXJjZShzb3VyY2VJbnB1dCkge1xyXG4gICAgICAgICAgICBsZXQgc3RhdGUgPSB0aGlzLmdldEN1cnJlbnREYXRhKCk7XHJcbiAgICAgICAgICAgIGlmIChzb3VyY2VJbnB1dCBpbnN0YW5jZW9mIEV2ZW50U291cmNlSW1wbCkge1xyXG4gICAgICAgICAgICAgICAgLy8gbm90IGFscmVhZHkgcHJlc2VudD8gZG9uJ3Qgd2FudCB0byBhZGQgYW4gb2xkIHNuYXBzaG90XHJcbiAgICAgICAgICAgICAgICBpZiAoIXN0YXRlLmV2ZW50U291cmNlc1tzb3VyY2VJbnB1dC5pbnRlcm5hbEV2ZW50U291cmNlLnNvdXJjZUlkXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnQUREX0VWRU5UX1NPVVJDRVMnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VzOiBbc291cmNlSW5wdXQuaW50ZXJuYWxFdmVudFNvdXJjZV0sXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc291cmNlSW5wdXQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IGV2ZW50U291cmNlID0gcGFyc2VFdmVudFNvdXJjZShzb3VyY2VJbnB1dCwgc3RhdGUpO1xyXG4gICAgICAgICAgICBpZiAoZXZlbnRTb3VyY2UpIHsgLy8gVE9ETzogZXJyb3Igb3RoZXJ3aXNlP1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaCh7IHR5cGU6ICdBRERfRVZFTlRfU09VUkNFUycsIHNvdXJjZXM6IFtldmVudFNvdXJjZV0gfSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEV2ZW50U291cmNlSW1wbChzdGF0ZSwgZXZlbnRTb3VyY2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZW1vdmVBbGxFdmVudFNvdXJjZXMoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goeyB0eXBlOiAnUkVNT1ZFX0FMTF9FVkVOVF9TT1VSQ0VTJyB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVmZXRjaEV2ZW50cygpIHtcclxuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaCh7IHR5cGU6ICdGRVRDSF9FVkVOVF9TT1VSQ0VTJywgaXNSZWZldGNoOiB0cnVlIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBTY3JvbGxcclxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgICAgIHNjcm9sbFRvVGltZSh0aW1lSW5wdXQpIHtcclxuICAgICAgICAgICAgbGV0IHRpbWUgPSBjcmVhdGVEdXJhdGlvbih0aW1lSW5wdXQpO1xyXG4gICAgICAgICAgICBpZiAodGltZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCdfc2Nyb2xsUmVxdWVzdCcsIHsgdGltZSB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBjbGFzcyBTdG9yZSB7XHJcbiAgICAgICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlcnMgPSBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc2V0KHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGhhbmRsZXIgb2YgdGhpcy5oYW5kbGVycykge1xyXG4gICAgICAgICAgICAgICAgaGFuZGxlcih2YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgc3Vic2NyaWJlKGhhbmRsZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5oYW5kbGVycy5wdXNoKGhhbmRsZXIpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50VmFsdWUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgaGFuZGxlcih0aGlzLmN1cnJlbnRWYWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLypcclxuICAgIFN1YnNjcmliZXJzIHdpbGwgZ2V0IGEgTElTVCBvZiBDdXN0b21SZW5kZXJpbmdzXHJcbiAgICAqL1xyXG4gICAgY2xhc3MgQ3VzdG9tUmVuZGVyaW5nU3RvcmUgZXh0ZW5kcyBTdG9yZSB7XHJcbiAgICAgICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgIHRoaXMubWFwID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBmb3IgY29uc2lzdGVudCBvcmRlclxyXG4gICAgICAgIGhhbmRsZShjdXN0b21SZW5kZXJpbmcpIHtcclxuICAgICAgICAgICAgY29uc3QgeyBtYXAgfSA9IHRoaXM7XHJcbiAgICAgICAgICAgIGxldCB1cGRhdGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGlmIChjdXN0b21SZW5kZXJpbmcuaXNBY3RpdmUpIHtcclxuICAgICAgICAgICAgICAgIG1hcC5zZXQoY3VzdG9tUmVuZGVyaW5nLmlkLCBjdXN0b21SZW5kZXJpbmcpO1xyXG4gICAgICAgICAgICAgICAgdXBkYXRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAobWFwLmhhcyhjdXN0b21SZW5kZXJpbmcuaWQpKSB7XHJcbiAgICAgICAgICAgICAgICBtYXAuZGVsZXRlKGN1c3RvbVJlbmRlcmluZy5pZCk7XHJcbiAgICAgICAgICAgICAgICB1cGRhdGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodXBkYXRlZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXQobWFwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB2YXIgaW50ZXJuYWwgPSB7XHJcbiAgICAgICAgX19wcm90b19fOiBudWxsLFxyXG4gICAgICAgIEJBU0VfT1BUSU9OX0RFRkFVTFRTOiBCQVNFX09QVElPTl9ERUZBVUxUUyxcclxuICAgICAgICBCYXNlQ29tcG9uZW50OiBCYXNlQ29tcG9uZW50LFxyXG4gICAgICAgIEJnRXZlbnQ6IEJnRXZlbnQsXHJcbiAgICAgICAgQ2FsZW5kYXJJbXBsOiBDYWxlbmRhckltcGwsXHJcbiAgICAgICAgQ2FsZW5kYXJSb290OiBDYWxlbmRhclJvb3QsXHJcbiAgICAgICAgQ29udGVudENvbnRhaW5lcjogQ29udGVudENvbnRhaW5lcixcclxuICAgICAgICBDdXN0b21SZW5kZXJpbmdTdG9yZTogQ3VzdG9tUmVuZGVyaW5nU3RvcmUsXHJcbiAgICAgICAgRGF0ZUNvbXBvbmVudDogRGF0ZUNvbXBvbmVudCxcclxuICAgICAgICBEYXRlRW52OiBEYXRlRW52LFxyXG4gICAgICAgIERhdGVQcm9maWxlR2VuZXJhdG9yOiBEYXRlUHJvZmlsZUdlbmVyYXRvcixcclxuICAgICAgICBEYXlDZWxsQ29udGFpbmVyOiBEYXlDZWxsQ29udGFpbmVyLFxyXG4gICAgICAgIERheUhlYWRlcjogRGF5SGVhZGVyLFxyXG4gICAgICAgIERheVNlcmllc01vZGVsOiBEYXlTZXJpZXNNb2RlbCxcclxuICAgICAgICBEYXlUYWJsZU1vZGVsOiBEYXlUYWJsZU1vZGVsLFxyXG4gICAgICAgIERlbGF5ZWRSdW5uZXI6IERlbGF5ZWRSdW5uZXIsXHJcbiAgICAgICAgRWxlbWVudERyYWdnaW5nOiBFbGVtZW50RHJhZ2dpbmcsXHJcbiAgICAgICAgRWxlbWVudFNjcm9sbENvbnRyb2xsZXI6IEVsZW1lbnRTY3JvbGxDb250cm9sbGVyLFxyXG4gICAgICAgIEVtaXR0ZXI6IEVtaXR0ZXIsXHJcbiAgICAgICAgRXZlbnRDb250YWluZXI6IEV2ZW50Q29udGFpbmVyLFxyXG4gICAgICAgIEV2ZW50SW1wbDogRXZlbnRJbXBsLFxyXG4gICAgICAgIEludGVyYWN0aW9uOiBJbnRlcmFjdGlvbixcclxuICAgICAgICBNb3JlTGlua0NvbnRhaW5lcjogTW9yZUxpbmtDb250YWluZXIsXHJcbiAgICAgICAgTmFtZWRUaW1lWm9uZUltcGw6IE5hbWVkVGltZVpvbmVJbXBsLFxyXG4gICAgICAgIE5vd0luZGljYXRvckNvbnRhaW5lcjogTm93SW5kaWNhdG9yQ29udGFpbmVyLFxyXG4gICAgICAgIE5vd1RpbWVyOiBOb3dUaW1lcixcclxuICAgICAgICBQb3NpdGlvbkNhY2hlOiBQb3NpdGlvbkNhY2hlLFxyXG4gICAgICAgIFJlZk1hcDogUmVmTWFwLFxyXG4gICAgICAgIFNjcm9sbENvbnRyb2xsZXI6IFNjcm9sbENvbnRyb2xsZXIsXHJcbiAgICAgICAgU2Nyb2xsUmVzcG9uZGVyOiBTY3JvbGxSZXNwb25kZXIsXHJcbiAgICAgICAgU2Nyb2xsZXI6IFNjcm9sbGVyLFxyXG4gICAgICAgIFNlZ0hpZXJhcmNoeTogU2VnSGllcmFyY2h5LFxyXG4gICAgICAgIFNpbXBsZVNjcm9sbEdyaWQ6IFNpbXBsZVNjcm9sbEdyaWQsXHJcbiAgICAgICAgU2xpY2VyOiBTbGljZXIsXHJcbiAgICAgICAgU3BsaXR0ZXI6IFNwbGl0dGVyLFxyXG4gICAgICAgIFN0YW5kYXJkRXZlbnQ6IFN0YW5kYXJkRXZlbnQsXHJcbiAgICAgICAgVGFibGVEYXRlQ2VsbDogVGFibGVEYXRlQ2VsbCxcclxuICAgICAgICBUYWJsZURvd0NlbGw6IFRhYmxlRG93Q2VsbCxcclxuICAgICAgICBUaGVtZTogVGhlbWUsXHJcbiAgICAgICAgVmlld0NvbnRhaW5lcjogVmlld0NvbnRhaW5lcixcclxuICAgICAgICBWaWV3Q29udGV4dFR5cGU6IFZpZXdDb250ZXh0VHlwZSxcclxuICAgICAgICBXZWVrTnVtYmVyQ29udGFpbmVyOiBXZWVrTnVtYmVyQ29udGFpbmVyLFxyXG4gICAgICAgIFdpbmRvd1Njcm9sbENvbnRyb2xsZXI6IFdpbmRvd1Njcm9sbENvbnRyb2xsZXIsXHJcbiAgICAgICAgYWRkRGF5czogYWRkRGF5cyxcclxuICAgICAgICBhZGREdXJhdGlvbnM6IGFkZER1cmF0aW9ucyxcclxuICAgICAgICBhZGRNczogYWRkTXMsXHJcbiAgICAgICAgYWRkV2Vla3M6IGFkZFdlZWtzLFxyXG4gICAgICAgIGFsbG93Q29udGV4dE1lbnU6IGFsbG93Q29udGV4dE1lbnUsXHJcbiAgICAgICAgYWxsb3dTZWxlY3Rpb246IGFsbG93U2VsZWN0aW9uLFxyXG4gICAgICAgIGFwcGx5TXV0YXRpb25Ub0V2ZW50U3RvcmU6IGFwcGx5TXV0YXRpb25Ub0V2ZW50U3RvcmUsXHJcbiAgICAgICAgYXBwbHlTdHlsZTogYXBwbHlTdHlsZSxcclxuICAgICAgICBhc0NsZWFuRGF5czogYXNDbGVhbkRheXMsXHJcbiAgICAgICAgYXNSb3VnaE1pbnV0ZXM6IGFzUm91Z2hNaW51dGVzLFxyXG4gICAgICAgIGFzUm91Z2hNczogYXNSb3VnaE1zLFxyXG4gICAgICAgIGFzUm91Z2hTZWNvbmRzOiBhc1JvdWdoU2Vjb25kcyxcclxuICAgICAgICBiaW5hcnlTZWFyY2g6IGJpbmFyeVNlYXJjaCxcclxuICAgICAgICBidWlsZEVsQXR0cnM6IGJ1aWxkRWxBdHRycyxcclxuICAgICAgICBidWlsZEVudHJ5S2V5OiBidWlsZEVudHJ5S2V5LFxyXG4gICAgICAgIGJ1aWxkRXZlbnRBcGlzOiBidWlsZEV2ZW50QXBpcyxcclxuICAgICAgICBidWlsZEV2ZW50UmFuZ2VLZXk6IGJ1aWxkRXZlbnRSYW5nZUtleSxcclxuICAgICAgICBidWlsZElzb1N0cmluZzogYnVpbGRJc29TdHJpbmcsXHJcbiAgICAgICAgYnVpbGROYXZMaW5rQXR0cnM6IGJ1aWxkTmF2TGlua0F0dHJzLFxyXG4gICAgICAgIGJ1aWxkU2VnVGltZVRleHQ6IGJ1aWxkU2VnVGltZVRleHQsXHJcbiAgICAgICAgY29sbGVjdEZyb21IYXNoOiBjb2xsZWN0RnJvbUhhc2gsXHJcbiAgICAgICAgY29tYmluZUV2ZW50VWlzOiBjb21iaW5lRXZlbnRVaXMsXHJcbiAgICAgICAgY29tcGFyZUJ5RmllbGRTcGVjczogY29tcGFyZUJ5RmllbGRTcGVjcyxcclxuICAgICAgICBjb21wYXJlTnVtYmVyczogY29tcGFyZU51bWJlcnMsXHJcbiAgICAgICAgY29tcGFyZU9ianM6IGNvbXBhcmVPYmpzLFxyXG4gICAgICAgIGNvbXB1dGVFYXJsaWVzdFNlZ1N0YXJ0OiBjb21wdXRlRWFybGllc3RTZWdTdGFydCxcclxuICAgICAgICBjb21wdXRlRWRnZXM6IGNvbXB1dGVFZGdlcyxcclxuICAgICAgICBjb21wdXRlRmFsbGJhY2tIZWFkZXJGb3JtYXQ6IGNvbXB1dGVGYWxsYmFja0hlYWRlckZvcm1hdCxcclxuICAgICAgICBjb21wdXRlSW5uZXJSZWN0OiBjb21wdXRlSW5uZXJSZWN0LFxyXG4gICAgICAgIGNvbXB1dGVSZWN0OiBjb21wdXRlUmVjdCxcclxuICAgICAgICBjb21wdXRlU2hyaW5rV2lkdGg6IGNvbXB1dGVTaHJpbmtXaWR0aCxcclxuICAgICAgICBjb21wdXRlVmlzaWJsZURheVJhbmdlOiBjb21wdXRlVmlzaWJsZURheVJhbmdlLFxyXG4gICAgICAgIGNvbmZpZzogY29uZmlnLFxyXG4gICAgICAgIGNvbnN0cmFpblBvaW50OiBjb25zdHJhaW5Qb2ludCxcclxuICAgICAgICBjcmVhdGVEdXJhdGlvbjogY3JlYXRlRHVyYXRpb24sXHJcbiAgICAgICAgY3JlYXRlRW1wdHlFdmVudFN0b3JlOiBjcmVhdGVFbXB0eUV2ZW50U3RvcmUsXHJcbiAgICAgICAgY3JlYXRlRXZlbnRJbnN0YW5jZTogY3JlYXRlRXZlbnRJbnN0YW5jZSxcclxuICAgICAgICBjcmVhdGVFdmVudFVpOiBjcmVhdGVFdmVudFVpLFxyXG4gICAgICAgIGNyZWF0ZUZvcm1hdHRlcjogY3JlYXRlRm9ybWF0dGVyLFxyXG4gICAgICAgIGRpZmZEYXRlczogZGlmZkRhdGVzLFxyXG4gICAgICAgIGRpZmZEYXlBbmRUaW1lOiBkaWZmRGF5QW5kVGltZSxcclxuICAgICAgICBkaWZmRGF5czogZGlmZkRheXMsXHJcbiAgICAgICAgZGlmZlBvaW50czogZGlmZlBvaW50cyxcclxuICAgICAgICBkaWZmV2Vla3M6IGRpZmZXZWVrcyxcclxuICAgICAgICBkaWZmV2hvbGVEYXlzOiBkaWZmV2hvbGVEYXlzLFxyXG4gICAgICAgIGRpZmZXaG9sZVdlZWtzOiBkaWZmV2hvbGVXZWVrcyxcclxuICAgICAgICBkaXNhYmxlQ3Vyc29yOiBkaXNhYmxlQ3Vyc29yLFxyXG4gICAgICAgIGVsZW1lbnRDbG9zZXN0OiBlbGVtZW50Q2xvc2VzdCxcclxuICAgICAgICBlbGVtZW50TWF0Y2hlczogZWxlbWVudE1hdGNoZXMsXHJcbiAgICAgICAgZW5hYmxlQ3Vyc29yOiBlbmFibGVDdXJzb3IsXHJcbiAgICAgICAgZXZlbnRUdXBsZVRvU3RvcmU6IGV2ZW50VHVwbGVUb1N0b3JlLFxyXG4gICAgICAgIGZpbHRlckhhc2g6IGZpbHRlckhhc2gsXHJcbiAgICAgICAgZmluZERpcmVjdENoaWxkcmVuOiBmaW5kRGlyZWN0Q2hpbGRyZW4sXHJcbiAgICAgICAgZmluZEVsZW1lbnRzOiBmaW5kRWxlbWVudHMsXHJcbiAgICAgICAgZmxleGlibGVDb21wYXJlOiBmbGV4aWJsZUNvbXBhcmUsXHJcbiAgICAgICAgZm9ybWF0RGF5U3RyaW5nOiBmb3JtYXREYXlTdHJpbmcsXHJcbiAgICAgICAgZm9ybWF0SXNvTW9udGhTdHI6IGZvcm1hdElzb01vbnRoU3RyLFxyXG4gICAgICAgIGZvcm1hdElzb1RpbWVTdHJpbmc6IGZvcm1hdElzb1RpbWVTdHJpbmcsXHJcbiAgICAgICAgZ2V0QWxsb3dZU2Nyb2xsaW5nOiBnZXRBbGxvd1lTY3JvbGxpbmcsXHJcbiAgICAgICAgZ2V0Q2FuVkdyb3dXaXRoaW5DZWxsOiBnZXRDYW5WR3Jvd1dpdGhpbkNlbGwsXHJcbiAgICAgICAgZ2V0Q2xpcHBpbmdQYXJlbnRzOiBnZXRDbGlwcGluZ1BhcmVudHMsXHJcbiAgICAgICAgZ2V0RGF0ZU1ldGE6IGdldERhdGVNZXRhLFxyXG4gICAgICAgIGdldERheUNsYXNzTmFtZXM6IGdldERheUNsYXNzTmFtZXMsXHJcbiAgICAgICAgZ2V0RGVmYXVsdEV2ZW50RW5kOiBnZXREZWZhdWx0RXZlbnRFbmQsXHJcbiAgICAgICAgZ2V0RWxTZWc6IGdldEVsU2VnLFxyXG4gICAgICAgIGdldEVudHJ5U3BhbkVuZDogZ2V0RW50cnlTcGFuRW5kLFxyXG4gICAgICAgIGdldEV2ZW50VGFyZ2V0VmlhUm9vdDogZ2V0RXZlbnRUYXJnZXRWaWFSb290LFxyXG4gICAgICAgIGdldElzUnRsU2Nyb2xsYmFyT25MZWZ0OiBnZXRJc1J0bFNjcm9sbGJhck9uTGVmdCxcclxuICAgICAgICBnZXRSZWN0Q2VudGVyOiBnZXRSZWN0Q2VudGVyLFxyXG4gICAgICAgIGdldFJlbGV2YW50RXZlbnRzOiBnZXRSZWxldmFudEV2ZW50cyxcclxuICAgICAgICBnZXRTY3JvbGxHcmlkQ2xhc3NOYW1lczogZ2V0U2Nyb2xsR3JpZENsYXNzTmFtZXMsXHJcbiAgICAgICAgZ2V0U2Nyb2xsYmFyV2lkdGhzOiBnZXRTY3JvbGxiYXJXaWR0aHMsXHJcbiAgICAgICAgZ2V0U2VjdGlvbkNsYXNzTmFtZXM6IGdldFNlY3Rpb25DbGFzc05hbWVzLFxyXG4gICAgICAgIGdldFNlY3Rpb25IYXNMaXF1aWRIZWlnaHQ6IGdldFNlY3Rpb25IYXNMaXF1aWRIZWlnaHQsXHJcbiAgICAgICAgZ2V0U2VnQW5jaG9yQXR0cnM6IGdldFNlZ0FuY2hvckF0dHJzLFxyXG4gICAgICAgIGdldFNlZ01ldGE6IGdldFNlZ01ldGEsXHJcbiAgICAgICAgZ2V0U2xvdENsYXNzTmFtZXM6IGdldFNsb3RDbGFzc05hbWVzLFxyXG4gICAgICAgIGdldFN0aWNreUZvb3RlclNjcm9sbGJhcjogZ2V0U3RpY2t5Rm9vdGVyU2Nyb2xsYmFyLFxyXG4gICAgICAgIGdldFN0aWNreUhlYWRlckRhdGVzOiBnZXRTdGlja3lIZWFkZXJEYXRlcyxcclxuICAgICAgICBnZXRVbmlxdWVEb21JZDogZ2V0VW5pcXVlRG9tSWQsXHJcbiAgICAgICAgZ3JlYXRlc3REdXJhdGlvbkRlbm9taW5hdG9yOiBncmVhdGVzdER1cmF0aW9uRGVub21pbmF0b3IsXHJcbiAgICAgICAgZ3JvdXBJbnRlcnNlY3RpbmdFbnRyaWVzOiBncm91cEludGVyc2VjdGluZ0VudHJpZXMsXHJcbiAgICAgICAgZ3VpZDogZ3VpZCxcclxuICAgICAgICBoYXNCZ1JlbmRlcmluZzogaGFzQmdSZW5kZXJpbmcsXHJcbiAgICAgICAgaGFzQ3VzdG9tRGF5Q2VsbENvbnRlbnQ6IGhhc0N1c3RvbURheUNlbGxDb250ZW50LFxyXG4gICAgICAgIGhhc1Nocmlua1dpZHRoOiBoYXNTaHJpbmtXaWR0aCxcclxuICAgICAgICBpZGVudGl0eTogaWRlbnRpdHksXHJcbiAgICAgICAgaW5qZWN0U3R5bGVzOiBpbmplY3RTdHlsZXMsXHJcbiAgICAgICAgaW50ZXJhY3Rpb25TZXR0aW5nc1N0b3JlOiBpbnRlcmFjdGlvblNldHRpbmdzU3RvcmUsXHJcbiAgICAgICAgaW50ZXJhY3Rpb25TZXR0aW5nc1RvU3RvcmU6IGludGVyYWN0aW9uU2V0dGluZ3NUb1N0b3JlLFxyXG4gICAgICAgIGludGVyc2VjdFJhbmdlczogaW50ZXJzZWN0UmFuZ2VzLFxyXG4gICAgICAgIGludGVyc2VjdFJlY3RzOiBpbnRlcnNlY3RSZWN0cyxcclxuICAgICAgICBpbnRlcnNlY3RTcGFuczogaW50ZXJzZWN0U3BhbnMsXHJcbiAgICAgICAgaXNBcnJheXNFcXVhbDogaXNBcnJheXNFcXVhbCxcclxuICAgICAgICBpc0NvbFByb3BzRXF1YWw6IGlzQ29sUHJvcHNFcXVhbCxcclxuICAgICAgICBpc0RhdGVTZWxlY3Rpb25WYWxpZDogaXNEYXRlU2VsZWN0aW9uVmFsaWQsXHJcbiAgICAgICAgaXNEYXRlU3BhbnNFcXVhbDogaXNEYXRlU3BhbnNFcXVhbCxcclxuICAgICAgICBpc0ludDogaXNJbnQsXHJcbiAgICAgICAgaXNJbnRlcmFjdGlvblZhbGlkOiBpc0ludGVyYWN0aW9uVmFsaWQsXHJcbiAgICAgICAgaXNNdWx0aURheVJhbmdlOiBpc011bHRpRGF5UmFuZ2UsXHJcbiAgICAgICAgaXNQcm9wc0VxdWFsOiBpc1Byb3BzRXF1YWwsXHJcbiAgICAgICAgaXNQcm9wc1ZhbGlkOiBpc1Byb3BzVmFsaWQsXHJcbiAgICAgICAgaXNWYWxpZERhdGU6IGlzVmFsaWREYXRlLFxyXG4gICAgICAgIG1hcEhhc2g6IG1hcEhhc2gsXHJcbiAgICAgICAgbWVtb2l6ZTogbWVtb2l6ZSxcclxuICAgICAgICBtZW1vaXplQXJyYXlsaWtlOiBtZW1vaXplQXJyYXlsaWtlLFxyXG4gICAgICAgIG1lbW9pemVIYXNobGlrZTogbWVtb2l6ZUhhc2hsaWtlLFxyXG4gICAgICAgIG1lbW9pemVPYmpBcmc6IG1lbW9pemVPYmpBcmcsXHJcbiAgICAgICAgbWVyZ2VFdmVudFN0b3JlczogbWVyZ2VFdmVudFN0b3JlcyxcclxuICAgICAgICBtdWx0aXBseUR1cmF0aW9uOiBtdWx0aXBseUR1cmF0aW9uLFxyXG4gICAgICAgIHBhZFN0YXJ0OiBwYWRTdGFydCxcclxuICAgICAgICBwYXJzZUJ1c2luZXNzSG91cnM6IHBhcnNlQnVzaW5lc3NIb3VycyxcclxuICAgICAgICBwYXJzZUNsYXNzTmFtZXM6IHBhcnNlQ2xhc3NOYW1lcyxcclxuICAgICAgICBwYXJzZURyYWdNZXRhOiBwYXJzZURyYWdNZXRhLFxyXG4gICAgICAgIHBhcnNlRXZlbnREZWY6IHBhcnNlRXZlbnREZWYsXHJcbiAgICAgICAgcGFyc2VGaWVsZFNwZWNzOiBwYXJzZUZpZWxkU3BlY3MsXHJcbiAgICAgICAgcGFyc2VNYXJrZXI6IHBhcnNlLFxyXG4gICAgICAgIHBvaW50SW5zaWRlUmVjdDogcG9pbnRJbnNpZGVSZWN0LFxyXG4gICAgICAgIHByZXZlbnRDb250ZXh0TWVudTogcHJldmVudENvbnRleHRNZW51LFxyXG4gICAgICAgIHByZXZlbnREZWZhdWx0OiBwcmV2ZW50RGVmYXVsdCxcclxuICAgICAgICBwcmV2ZW50U2VsZWN0aW9uOiBwcmV2ZW50U2VsZWN0aW9uLFxyXG4gICAgICAgIHJhbmdlQ29udGFpbnNNYXJrZXI6IHJhbmdlQ29udGFpbnNNYXJrZXIsXHJcbiAgICAgICAgcmFuZ2VDb250YWluc1JhbmdlOiByYW5nZUNvbnRhaW5zUmFuZ2UsXHJcbiAgICAgICAgcmFuZ2VzRXF1YWw6IHJhbmdlc0VxdWFsLFxyXG4gICAgICAgIHJhbmdlc0ludGVyc2VjdDogcmFuZ2VzSW50ZXJzZWN0LFxyXG4gICAgICAgIHJlZmluZUV2ZW50RGVmOiByZWZpbmVFdmVudERlZixcclxuICAgICAgICByZWZpbmVQcm9wczogcmVmaW5lUHJvcHMsXHJcbiAgICAgICAgcmVtb3ZlRWxlbWVudDogcmVtb3ZlRWxlbWVudCxcclxuICAgICAgICByZW1vdmVFeGFjdDogcmVtb3ZlRXhhY3QsXHJcbiAgICAgICAgcmVuZGVyQ2h1bmtDb250ZW50OiByZW5kZXJDaHVua0NvbnRlbnQsXHJcbiAgICAgICAgcmVuZGVyRmlsbDogcmVuZGVyRmlsbCxcclxuICAgICAgICByZW5kZXJNaWNyb0NvbEdyb3VwOiByZW5kZXJNaWNyb0NvbEdyb3VwLFxyXG4gICAgICAgIHJlbmRlclNjcm9sbFNoaW06IHJlbmRlclNjcm9sbFNoaW0sXHJcbiAgICAgICAgcmVxdWVzdEpzb246IHJlcXVlc3RKc29uLFxyXG4gICAgICAgIHNhbml0aXplU2hyaW5rV2lkdGg6IHNhbml0aXplU2hyaW5rV2lkdGgsXHJcbiAgICAgICAgc2V0UmVmOiBzZXRSZWYsXHJcbiAgICAgICAgc2xpY2VFdmVudFN0b3JlOiBzbGljZUV2ZW50U3RvcmUsXHJcbiAgICAgICAgc29ydEV2ZW50U2Vnczogc29ydEV2ZW50U2VncyxcclxuICAgICAgICBzdGFydE9mRGF5OiBzdGFydE9mRGF5LFxyXG4gICAgICAgIHRyYW5zbGF0ZVJlY3Q6IHRyYW5zbGF0ZVJlY3QsXHJcbiAgICAgICAgdHJpZ2dlckRhdGVTZWxlY3Q6IHRyaWdnZXJEYXRlU2VsZWN0LFxyXG4gICAgICAgIHVucHJvbWlzaWZ5OiB1bnByb21pc2lmeSxcclxuICAgICAgICB3aGVuVHJhbnNpdGlvbkRvbmU6IHdoZW5UcmFuc2l0aW9uRG9uZSxcclxuICAgICAgICB3aG9sZURpdmlkZUR1cmF0aW9uczogd2hvbGVEaXZpZGVEdXJhdGlvbnNcclxuICAgIH07XHJcblxyXG4gICAgdmFyIHByZWFjdCA9IHtcclxuICAgICAgICBfX3Byb3RvX186IG51bGwsXHJcbiAgICAgICAgY3JlYXRlUG9ydGFsOiBqLFxyXG4gICAgICAgIGNyZWF0ZUNvbnRleHQ6IGNyZWF0ZUNvbnRleHQsXHJcbiAgICAgICAgZmx1c2hTeW5jOiBmbHVzaFN5bmMsXHJcbiAgICAgICAgQ29tcG9uZW50OiB4JDEsXHJcbiAgICAgICAgRnJhZ21lbnQ6IF8sXHJcbiAgICAgICAgY2xvbmVFbGVtZW50OiBGJDEsXHJcbiAgICAgICAgY3JlYXRlRWxlbWVudDogeSxcclxuICAgICAgICBjcmVhdGVSZWY6IGQsXHJcbiAgICAgICAgaDogeSxcclxuICAgICAgICBoeWRyYXRlOiBFLFxyXG4gICAgICAgIGdldCBpc1ZhbGlkRWxlbWVudCAoKSB7IHJldHVybiBpJDE7IH0sXHJcbiAgICAgICAgZ2V0IG9wdGlvbnMgKCkgeyByZXR1cm4gbCQxOyB9LFxyXG4gICAgICAgIHJlbmRlcjogRCQxLFxyXG4gICAgICAgIHRvQ2hpbGRBcnJheTogaiQyXHJcbiAgICB9O1xyXG5cclxuICAgIGNvbnN0IGdsb2JhbExvY2FsZXMgPSBbXTtcclxuXHJcbiAgICBjb25zdCBNSU5JTUFMX1JBV19FTl9MT0NBTEUgPSB7XHJcbiAgICAgICAgY29kZTogJ2VuJyxcclxuICAgICAgICB3ZWVrOiB7XHJcbiAgICAgICAgICAgIGRvdzogMCxcclxuICAgICAgICAgICAgZG95OiA0LCAvLyA0IGRheXMgbmVlZCB0byBiZSB3aXRoaW4gdGhlIHllYXIgdG8gYmUgY29uc2lkZXJlZCB0aGUgZmlyc3Qgd2Vla1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZGlyZWN0aW9uOiAnbHRyJyxcclxuICAgICAgICBidXR0b25UZXh0OiB7XHJcbiAgICAgICAgICAgIHByZXY6ICdwcmV2JyxcclxuICAgICAgICAgICAgbmV4dDogJ25leHQnLFxyXG4gICAgICAgICAgICBwcmV2WWVhcjogJ3ByZXYgeWVhcicsXHJcbiAgICAgICAgICAgIG5leHRZZWFyOiAnbmV4dCB5ZWFyJyxcclxuICAgICAgICAgICAgeWVhcjogJ3llYXInLFxyXG4gICAgICAgICAgICB0b2RheTogJ3RvZGF5JyxcclxuICAgICAgICAgICAgbW9udGg6ICdtb250aCcsXHJcbiAgICAgICAgICAgIHdlZWs6ICd3ZWVrJyxcclxuICAgICAgICAgICAgZGF5OiAnZGF5JyxcclxuICAgICAgICAgICAgbGlzdDogJ2xpc3QnLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgd2Vla1RleHQ6ICdXJyxcclxuICAgICAgICB3ZWVrVGV4dExvbmc6ICdXZWVrJyxcclxuICAgICAgICBjbG9zZUhpbnQ6ICdDbG9zZScsXHJcbiAgICAgICAgdGltZUhpbnQ6ICdUaW1lJyxcclxuICAgICAgICBldmVudEhpbnQ6ICdFdmVudCcsXHJcbiAgICAgICAgYWxsRGF5VGV4dDogJ2FsbC1kYXknLFxyXG4gICAgICAgIG1vcmVMaW5rVGV4dDogJ21vcmUnLFxyXG4gICAgICAgIG5vRXZlbnRzVGV4dDogJ05vIGV2ZW50cyB0byBkaXNwbGF5JyxcclxuICAgIH07XHJcbiAgICBjb25zdCBSQVdfRU5fTE9DQUxFID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBNSU5JTUFMX1JBV19FTl9MT0NBTEUpLCB7IFxyXG4gICAgICAgIC8vIEluY2x1ZGVzIHRoaW5ncyB3ZSBkb24ndCB3YW50IG90aGVyIGxvY2FsZXMgdG8gaW5oZXJpdCxcclxuICAgICAgICAvLyB0aGluZ3MgdGhhdCBkZXJpdmUgZnJvbSBvdGhlciB0cmFuc2xhdGFibGUgc3RyaW5ncy5cclxuICAgICAgICBidXR0b25IaW50czoge1xyXG4gICAgICAgICAgICBwcmV2OiAnUHJldmlvdXMgJDAnLFxyXG4gICAgICAgICAgICBuZXh0OiAnTmV4dCAkMCcsXHJcbiAgICAgICAgICAgIHRvZGF5KGJ1dHRvblRleHQsIHVuaXQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAodW5pdCA9PT0gJ2RheScpXHJcbiAgICAgICAgICAgICAgICAgICAgPyAnVG9kYXknXHJcbiAgICAgICAgICAgICAgICAgICAgOiBgVGhpcyAke2J1dHRvblRleHR9YDtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9LCB2aWV3SGludDogJyQwIHZpZXcnLCBuYXZMaW5rSGludDogJ0dvIHRvICQwJywgbW9yZUxpbmtIaW50KGV2ZW50Q250KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBgU2hvdyAke2V2ZW50Q250fSBtb3JlIGV2ZW50JHtldmVudENudCA9PT0gMSA/ICcnIDogJ3MnfWA7XHJcbiAgICAgICAgfSB9KTtcclxuICAgIGZ1bmN0aW9uIG9yZ2FuaXplUmF3TG9jYWxlcyhleHBsaWNpdFJhd0xvY2FsZXMpIHtcclxuICAgICAgICBsZXQgZGVmYXVsdENvZGUgPSBleHBsaWNpdFJhd0xvY2FsZXMubGVuZ3RoID4gMCA/IGV4cGxpY2l0UmF3TG9jYWxlc1swXS5jb2RlIDogJ2VuJztcclxuICAgICAgICBsZXQgYWxsUmF3TG9jYWxlcyA9IGdsb2JhbExvY2FsZXMuY29uY2F0KGV4cGxpY2l0UmF3TG9jYWxlcyk7XHJcbiAgICAgICAgbGV0IHJhd0xvY2FsZU1hcCA9IHtcclxuICAgICAgICAgICAgZW46IFJBV19FTl9MT0NBTEUsXHJcbiAgICAgICAgfTtcclxuICAgICAgICBmb3IgKGxldCByYXdMb2NhbGUgb2YgYWxsUmF3TG9jYWxlcykge1xyXG4gICAgICAgICAgICByYXdMb2NhbGVNYXBbcmF3TG9jYWxlLmNvZGVdID0gcmF3TG9jYWxlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBtYXA6IHJhd0xvY2FsZU1hcCxcclxuICAgICAgICAgICAgZGVmYXVsdENvZGUsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGJ1aWxkTG9jYWxlKGlucHV0U2luZ3VsYXIsIGF2YWlsYWJsZSkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXRTaW5ndWxhciA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkoaW5wdXRTaW5ndWxhcikpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlTG9jYWxlKGlucHV0U2luZ3VsYXIuY29kZSwgW2lucHV0U2luZ3VsYXIuY29kZV0sIGlucHV0U2luZ3VsYXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcXVlcnlMb2NhbGUoaW5wdXRTaW5ndWxhciwgYXZhaWxhYmxlKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHF1ZXJ5TG9jYWxlKGNvZGVBcmcsIGF2YWlsYWJsZSkge1xyXG4gICAgICAgIGxldCBjb2RlcyA9IFtdLmNvbmNhdChjb2RlQXJnIHx8IFtdKTsgLy8gd2lsbCBjb252ZXJ0IHRvIGFycmF5XHJcbiAgICAgICAgbGV0IHJhdyA9IHF1ZXJ5UmF3TG9jYWxlKGNvZGVzLCBhdmFpbGFibGUpIHx8IFJBV19FTl9MT0NBTEU7XHJcbiAgICAgICAgcmV0dXJuIHBhcnNlTG9jYWxlKGNvZGVBcmcsIGNvZGVzLCByYXcpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gcXVlcnlSYXdMb2NhbGUoY29kZXMsIGF2YWlsYWJsZSkge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29kZXMubGVuZ3RoOyBpICs9IDEpIHtcclxuICAgICAgICAgICAgbGV0IHBhcnRzID0gY29kZXNbaV0udG9Mb2NhbGVMb3dlckNhc2UoKS5zcGxpdCgnLScpO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gcGFydHMubGVuZ3RoOyBqID4gMDsgaiAtPSAxKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgc2ltcGxlSWQgPSBwYXJ0cy5zbGljZSgwLCBqKS5qb2luKCctJyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoYXZhaWxhYmxlW3NpbXBsZUlkXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhdmFpbGFibGVbc2ltcGxlSWRdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gcGFyc2VMb2NhbGUoY29kZUFyZywgY29kZXMsIHJhdykge1xyXG4gICAgICAgIGxldCBtZXJnZWQgPSBtZXJnZVByb3BzKFtNSU5JTUFMX1JBV19FTl9MT0NBTEUsIHJhd10sIFsnYnV0dG9uVGV4dCddKTtcclxuICAgICAgICBkZWxldGUgbWVyZ2VkLmNvZGU7IC8vIGRvbid0IHdhbnQgdGhpcyBwYXJ0IG9mIHRoZSBvcHRpb25zXHJcbiAgICAgICAgbGV0IHsgd2VlayB9ID0gbWVyZ2VkO1xyXG4gICAgICAgIGRlbGV0ZSBtZXJnZWQud2VlaztcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBjb2RlQXJnLFxyXG4gICAgICAgICAgICBjb2RlcyxcclxuICAgICAgICAgICAgd2VlayxcclxuICAgICAgICAgICAgc2ltcGxlTnVtYmVyRm9ybWF0OiBuZXcgSW50bC5OdW1iZXJGb3JtYXQoY29kZUFyZyksXHJcbiAgICAgICAgICAgIG9wdGlvbnM6IG1lcmdlZCxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFRPRE86IGVhc2llciB3YXkgdG8gYWRkIG5ldyBob29rcz8gbmVlZCB0byB1cGRhdGUgYSBtaWxsaW9uIHRoaW5nc1xyXG4gICAgZnVuY3Rpb24gY3JlYXRlUGx1Z2luKGlucHV0KSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgaWQ6IGd1aWQoKSxcclxuICAgICAgICAgICAgbmFtZTogaW5wdXQubmFtZSxcclxuICAgICAgICAgICAgcHJlbWl1bVJlbGVhc2VEYXRlOiBpbnB1dC5wcmVtaXVtUmVsZWFzZURhdGUgPyBuZXcgRGF0ZShpbnB1dC5wcmVtaXVtUmVsZWFzZURhdGUpIDogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICBkZXBzOiBpbnB1dC5kZXBzIHx8IFtdLFxyXG4gICAgICAgICAgICByZWR1Y2VyczogaW5wdXQucmVkdWNlcnMgfHwgW10sXHJcbiAgICAgICAgICAgIGlzTG9hZGluZ0Z1bmNzOiBpbnB1dC5pc0xvYWRpbmdGdW5jcyB8fCBbXSxcclxuICAgICAgICAgICAgY29udGV4dEluaXQ6IFtdLmNvbmNhdChpbnB1dC5jb250ZXh0SW5pdCB8fCBbXSksXHJcbiAgICAgICAgICAgIGV2ZW50UmVmaW5lcnM6IGlucHV0LmV2ZW50UmVmaW5lcnMgfHwge30sXHJcbiAgICAgICAgICAgIGV2ZW50RGVmTWVtYmVyQWRkZXJzOiBpbnB1dC5ldmVudERlZk1lbWJlckFkZGVycyB8fCBbXSxcclxuICAgICAgICAgICAgZXZlbnRTb3VyY2VSZWZpbmVyczogaW5wdXQuZXZlbnRTb3VyY2VSZWZpbmVycyB8fCB7fSxcclxuICAgICAgICAgICAgaXNEcmFnZ2FibGVUcmFuc2Zvcm1lcnM6IGlucHV0LmlzRHJhZ2dhYmxlVHJhbnNmb3JtZXJzIHx8IFtdLFxyXG4gICAgICAgICAgICBldmVudERyYWdNdXRhdGlvbk1hc3NhZ2VyczogaW5wdXQuZXZlbnREcmFnTXV0YXRpb25NYXNzYWdlcnMgfHwgW10sXHJcbiAgICAgICAgICAgIGV2ZW50RGVmTXV0YXRpb25BcHBsaWVyczogaW5wdXQuZXZlbnREZWZNdXRhdGlvbkFwcGxpZXJzIHx8IFtdLFxyXG4gICAgICAgICAgICBkYXRlU2VsZWN0aW9uVHJhbnNmb3JtZXJzOiBpbnB1dC5kYXRlU2VsZWN0aW9uVHJhbnNmb3JtZXJzIHx8IFtdLFxyXG4gICAgICAgICAgICBkYXRlUG9pbnRUcmFuc2Zvcm1zOiBpbnB1dC5kYXRlUG9pbnRUcmFuc2Zvcm1zIHx8IFtdLFxyXG4gICAgICAgICAgICBkYXRlU3BhblRyYW5zZm9ybXM6IGlucHV0LmRhdGVTcGFuVHJhbnNmb3JtcyB8fCBbXSxcclxuICAgICAgICAgICAgdmlld3M6IGlucHV0LnZpZXdzIHx8IHt9LFxyXG4gICAgICAgICAgICB2aWV3UHJvcHNUcmFuc2Zvcm1lcnM6IGlucHV0LnZpZXdQcm9wc1RyYW5zZm9ybWVycyB8fCBbXSxcclxuICAgICAgICAgICAgaXNQcm9wc1ZhbGlkOiBpbnB1dC5pc1Byb3BzVmFsaWQgfHwgbnVsbCxcclxuICAgICAgICAgICAgZXh0ZXJuYWxEZWZUcmFuc2Zvcm1zOiBpbnB1dC5leHRlcm5hbERlZlRyYW5zZm9ybXMgfHwgW10sXHJcbiAgICAgICAgICAgIHZpZXdDb250YWluZXJBcHBlbmRzOiBpbnB1dC52aWV3Q29udGFpbmVyQXBwZW5kcyB8fCBbXSxcclxuICAgICAgICAgICAgZXZlbnREcm9wVHJhbnNmb3JtZXJzOiBpbnB1dC5ldmVudERyb3BUcmFuc2Zvcm1lcnMgfHwgW10sXHJcbiAgICAgICAgICAgIGNvbXBvbmVudEludGVyYWN0aW9uczogaW5wdXQuY29tcG9uZW50SW50ZXJhY3Rpb25zIHx8IFtdLFxyXG4gICAgICAgICAgICBjYWxlbmRhckludGVyYWN0aW9uczogaW5wdXQuY2FsZW5kYXJJbnRlcmFjdGlvbnMgfHwgW10sXHJcbiAgICAgICAgICAgIHRoZW1lQ2xhc3NlczogaW5wdXQudGhlbWVDbGFzc2VzIHx8IHt9LFxyXG4gICAgICAgICAgICBldmVudFNvdXJjZURlZnM6IGlucHV0LmV2ZW50U291cmNlRGVmcyB8fCBbXSxcclxuICAgICAgICAgICAgY21kRm9ybWF0dGVyOiBpbnB1dC5jbWRGb3JtYXR0ZXIsXHJcbiAgICAgICAgICAgIHJlY3VycmluZ1R5cGVzOiBpbnB1dC5yZWN1cnJpbmdUeXBlcyB8fCBbXSxcclxuICAgICAgICAgICAgbmFtZWRUaW1lWm9uZWRJbXBsOiBpbnB1dC5uYW1lZFRpbWVab25lZEltcGwsXHJcbiAgICAgICAgICAgIGluaXRpYWxWaWV3OiBpbnB1dC5pbml0aWFsVmlldyB8fCAnJyxcclxuICAgICAgICAgICAgZWxlbWVudERyYWdnaW5nSW1wbDogaW5wdXQuZWxlbWVudERyYWdnaW5nSW1wbCxcclxuICAgICAgICAgICAgb3B0aW9uQ2hhbmdlSGFuZGxlcnM6IGlucHV0Lm9wdGlvbkNoYW5nZUhhbmRsZXJzIHx8IHt9LFxyXG4gICAgICAgICAgICBzY3JvbGxHcmlkSW1wbDogaW5wdXQuc2Nyb2xsR3JpZEltcGwgfHwgbnVsbCxcclxuICAgICAgICAgICAgbGlzdGVuZXJSZWZpbmVyczogaW5wdXQubGlzdGVuZXJSZWZpbmVycyB8fCB7fSxcclxuICAgICAgICAgICAgb3B0aW9uUmVmaW5lcnM6IGlucHV0Lm9wdGlvblJlZmluZXJzIHx8IHt9LFxyXG4gICAgICAgICAgICBwcm9wU2V0SGFuZGxlcnM6IGlucHV0LnByb3BTZXRIYW5kbGVycyB8fCB7fSxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYnVpbGRQbHVnaW5Ib29rcyhwbHVnaW5EZWZzLCBnbG9iYWxEZWZzKSB7XHJcbiAgICAgICAgbGV0IGN1cnJlbnRQbHVnaW5JZHMgPSB7fTtcclxuICAgICAgICBsZXQgaG9va3MgPSB7XHJcbiAgICAgICAgICAgIHByZW1pdW1SZWxlYXNlRGF0ZTogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICByZWR1Y2VyczogW10sXHJcbiAgICAgICAgICAgIGlzTG9hZGluZ0Z1bmNzOiBbXSxcclxuICAgICAgICAgICAgY29udGV4dEluaXQ6IFtdLFxyXG4gICAgICAgICAgICBldmVudFJlZmluZXJzOiB7fSxcclxuICAgICAgICAgICAgZXZlbnREZWZNZW1iZXJBZGRlcnM6IFtdLFxyXG4gICAgICAgICAgICBldmVudFNvdXJjZVJlZmluZXJzOiB7fSxcclxuICAgICAgICAgICAgaXNEcmFnZ2FibGVUcmFuc2Zvcm1lcnM6IFtdLFxyXG4gICAgICAgICAgICBldmVudERyYWdNdXRhdGlvbk1hc3NhZ2VyczogW10sXHJcbiAgICAgICAgICAgIGV2ZW50RGVmTXV0YXRpb25BcHBsaWVyczogW10sXHJcbiAgICAgICAgICAgIGRhdGVTZWxlY3Rpb25UcmFuc2Zvcm1lcnM6IFtdLFxyXG4gICAgICAgICAgICBkYXRlUG9pbnRUcmFuc2Zvcm1zOiBbXSxcclxuICAgICAgICAgICAgZGF0ZVNwYW5UcmFuc2Zvcm1zOiBbXSxcclxuICAgICAgICAgICAgdmlld3M6IHt9LFxyXG4gICAgICAgICAgICB2aWV3UHJvcHNUcmFuc2Zvcm1lcnM6IFtdLFxyXG4gICAgICAgICAgICBpc1Byb3BzVmFsaWQ6IG51bGwsXHJcbiAgICAgICAgICAgIGV4dGVybmFsRGVmVHJhbnNmb3JtczogW10sXHJcbiAgICAgICAgICAgIHZpZXdDb250YWluZXJBcHBlbmRzOiBbXSxcclxuICAgICAgICAgICAgZXZlbnREcm9wVHJhbnNmb3JtZXJzOiBbXSxcclxuICAgICAgICAgICAgY29tcG9uZW50SW50ZXJhY3Rpb25zOiBbXSxcclxuICAgICAgICAgICAgY2FsZW5kYXJJbnRlcmFjdGlvbnM6IFtdLFxyXG4gICAgICAgICAgICB0aGVtZUNsYXNzZXM6IHt9LFxyXG4gICAgICAgICAgICBldmVudFNvdXJjZURlZnM6IFtdLFxyXG4gICAgICAgICAgICBjbWRGb3JtYXR0ZXI6IG51bGwsXHJcbiAgICAgICAgICAgIHJlY3VycmluZ1R5cGVzOiBbXSxcclxuICAgICAgICAgICAgbmFtZWRUaW1lWm9uZWRJbXBsOiBudWxsLFxyXG4gICAgICAgICAgICBpbml0aWFsVmlldzogJycsXHJcbiAgICAgICAgICAgIGVsZW1lbnREcmFnZ2luZ0ltcGw6IG51bGwsXHJcbiAgICAgICAgICAgIG9wdGlvbkNoYW5nZUhhbmRsZXJzOiB7fSxcclxuICAgICAgICAgICAgc2Nyb2xsR3JpZEltcGw6IG51bGwsXHJcbiAgICAgICAgICAgIGxpc3RlbmVyUmVmaW5lcnM6IHt9LFxyXG4gICAgICAgICAgICBvcHRpb25SZWZpbmVyczoge30sXHJcbiAgICAgICAgICAgIHByb3BTZXRIYW5kbGVyczoge30sXHJcbiAgICAgICAgfTtcclxuICAgICAgICBmdW5jdGlvbiBhZGREZWZzKGRlZnMpIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgZGVmIG9mIGRlZnMpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHBsdWdpbk5hbWUgPSBkZWYubmFtZTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRJZCA9IGN1cnJlbnRQbHVnaW5JZHNbcGx1Z2luTmFtZV07XHJcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudElkID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50UGx1Z2luSWRzW3BsdWdpbk5hbWVdID0gZGVmLmlkO1xyXG4gICAgICAgICAgICAgICAgICAgIGFkZERlZnMoZGVmLmRlcHMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGhvb2tzID0gY29tYmluZUhvb2tzKGhvb2tzLCBkZWYpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY3VycmVudElkICE9PSBkZWYuaWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBkaWZmZXJlbnQgSUQgdGhhbiB0aGUgb25lIGFscmVhZHkgYWRkZWRcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYER1cGxpY2F0ZSBwbHVnaW4gJyR7cGx1Z2luTmFtZX0nYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHBsdWdpbkRlZnMpIHtcclxuICAgICAgICAgICAgYWRkRGVmcyhwbHVnaW5EZWZzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYWRkRGVmcyhnbG9iYWxEZWZzKTtcclxuICAgICAgICByZXR1cm4gaG9va3M7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBidWlsZEJ1aWxkUGx1Z2luSG9va3MoKSB7XHJcbiAgICAgICAgbGV0IGN1cnJlbnRPdmVycmlkZURlZnMgPSBbXTtcclxuICAgICAgICBsZXQgY3VycmVudEdsb2JhbERlZnMgPSBbXTtcclxuICAgICAgICBsZXQgY3VycmVudEhvb2tzO1xyXG4gICAgICAgIHJldHVybiAob3ZlcnJpZGVEZWZzLCBnbG9iYWxEZWZzKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICghY3VycmVudEhvb2tzIHx8ICFpc0FycmF5c0VxdWFsKG92ZXJyaWRlRGVmcywgY3VycmVudE92ZXJyaWRlRGVmcykgfHwgIWlzQXJyYXlzRXF1YWwoZ2xvYmFsRGVmcywgY3VycmVudEdsb2JhbERlZnMpKSB7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50SG9va3MgPSBidWlsZFBsdWdpbkhvb2tzKG92ZXJyaWRlRGVmcywgZ2xvYmFsRGVmcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY3VycmVudE92ZXJyaWRlRGVmcyA9IG92ZXJyaWRlRGVmcztcclxuICAgICAgICAgICAgY3VycmVudEdsb2JhbERlZnMgPSBnbG9iYWxEZWZzO1xyXG4gICAgICAgICAgICByZXR1cm4gY3VycmVudEhvb2tzO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBjb21iaW5lSG9va3MoaG9va3MwLCBob29rczEpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBwcmVtaXVtUmVsZWFzZURhdGU6IGNvbXBhcmVPcHRpb25hbERhdGVzKGhvb2tzMC5wcmVtaXVtUmVsZWFzZURhdGUsIGhvb2tzMS5wcmVtaXVtUmVsZWFzZURhdGUpLFxyXG4gICAgICAgICAgICByZWR1Y2VyczogaG9va3MwLnJlZHVjZXJzLmNvbmNhdChob29rczEucmVkdWNlcnMpLFxyXG4gICAgICAgICAgICBpc0xvYWRpbmdGdW5jczogaG9va3MwLmlzTG9hZGluZ0Z1bmNzLmNvbmNhdChob29rczEuaXNMb2FkaW5nRnVuY3MpLFxyXG4gICAgICAgICAgICBjb250ZXh0SW5pdDogaG9va3MwLmNvbnRleHRJbml0LmNvbmNhdChob29rczEuY29udGV4dEluaXQpLFxyXG4gICAgICAgICAgICBldmVudFJlZmluZXJzOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGhvb2tzMC5ldmVudFJlZmluZXJzKSwgaG9va3MxLmV2ZW50UmVmaW5lcnMpLFxyXG4gICAgICAgICAgICBldmVudERlZk1lbWJlckFkZGVyczogaG9va3MwLmV2ZW50RGVmTWVtYmVyQWRkZXJzLmNvbmNhdChob29rczEuZXZlbnREZWZNZW1iZXJBZGRlcnMpLFxyXG4gICAgICAgICAgICBldmVudFNvdXJjZVJlZmluZXJzOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGhvb2tzMC5ldmVudFNvdXJjZVJlZmluZXJzKSwgaG9va3MxLmV2ZW50U291cmNlUmVmaW5lcnMpLFxyXG4gICAgICAgICAgICBpc0RyYWdnYWJsZVRyYW5zZm9ybWVyczogaG9va3MwLmlzRHJhZ2dhYmxlVHJhbnNmb3JtZXJzLmNvbmNhdChob29rczEuaXNEcmFnZ2FibGVUcmFuc2Zvcm1lcnMpLFxyXG4gICAgICAgICAgICBldmVudERyYWdNdXRhdGlvbk1hc3NhZ2VyczogaG9va3MwLmV2ZW50RHJhZ011dGF0aW9uTWFzc2FnZXJzLmNvbmNhdChob29rczEuZXZlbnREcmFnTXV0YXRpb25NYXNzYWdlcnMpLFxyXG4gICAgICAgICAgICBldmVudERlZk11dGF0aW9uQXBwbGllcnM6IGhvb2tzMC5ldmVudERlZk11dGF0aW9uQXBwbGllcnMuY29uY2F0KGhvb2tzMS5ldmVudERlZk11dGF0aW9uQXBwbGllcnMpLFxyXG4gICAgICAgICAgICBkYXRlU2VsZWN0aW9uVHJhbnNmb3JtZXJzOiBob29rczAuZGF0ZVNlbGVjdGlvblRyYW5zZm9ybWVycy5jb25jYXQoaG9va3MxLmRhdGVTZWxlY3Rpb25UcmFuc2Zvcm1lcnMpLFxyXG4gICAgICAgICAgICBkYXRlUG9pbnRUcmFuc2Zvcm1zOiBob29rczAuZGF0ZVBvaW50VHJhbnNmb3Jtcy5jb25jYXQoaG9va3MxLmRhdGVQb2ludFRyYW5zZm9ybXMpLFxyXG4gICAgICAgICAgICBkYXRlU3BhblRyYW5zZm9ybXM6IGhvb2tzMC5kYXRlU3BhblRyYW5zZm9ybXMuY29uY2F0KGhvb2tzMS5kYXRlU3BhblRyYW5zZm9ybXMpLFxyXG4gICAgICAgICAgICB2aWV3czogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBob29rczAudmlld3MpLCBob29rczEudmlld3MpLFxyXG4gICAgICAgICAgICB2aWV3UHJvcHNUcmFuc2Zvcm1lcnM6IGhvb2tzMC52aWV3UHJvcHNUcmFuc2Zvcm1lcnMuY29uY2F0KGhvb2tzMS52aWV3UHJvcHNUcmFuc2Zvcm1lcnMpLFxyXG4gICAgICAgICAgICBpc1Byb3BzVmFsaWQ6IGhvb2tzMS5pc1Byb3BzVmFsaWQgfHwgaG9va3MwLmlzUHJvcHNWYWxpZCxcclxuICAgICAgICAgICAgZXh0ZXJuYWxEZWZUcmFuc2Zvcm1zOiBob29rczAuZXh0ZXJuYWxEZWZUcmFuc2Zvcm1zLmNvbmNhdChob29rczEuZXh0ZXJuYWxEZWZUcmFuc2Zvcm1zKSxcclxuICAgICAgICAgICAgdmlld0NvbnRhaW5lckFwcGVuZHM6IGhvb2tzMC52aWV3Q29udGFpbmVyQXBwZW5kcy5jb25jYXQoaG9va3MxLnZpZXdDb250YWluZXJBcHBlbmRzKSxcclxuICAgICAgICAgICAgZXZlbnREcm9wVHJhbnNmb3JtZXJzOiBob29rczAuZXZlbnREcm9wVHJhbnNmb3JtZXJzLmNvbmNhdChob29rczEuZXZlbnREcm9wVHJhbnNmb3JtZXJzKSxcclxuICAgICAgICAgICAgY2FsZW5kYXJJbnRlcmFjdGlvbnM6IGhvb2tzMC5jYWxlbmRhckludGVyYWN0aW9ucy5jb25jYXQoaG9va3MxLmNhbGVuZGFySW50ZXJhY3Rpb25zKSxcclxuICAgICAgICAgICAgY29tcG9uZW50SW50ZXJhY3Rpb25zOiBob29rczAuY29tcG9uZW50SW50ZXJhY3Rpb25zLmNvbmNhdChob29rczEuY29tcG9uZW50SW50ZXJhY3Rpb25zKSxcclxuICAgICAgICAgICAgdGhlbWVDbGFzc2VzOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGhvb2tzMC50aGVtZUNsYXNzZXMpLCBob29rczEudGhlbWVDbGFzc2VzKSxcclxuICAgICAgICAgICAgZXZlbnRTb3VyY2VEZWZzOiBob29rczAuZXZlbnRTb3VyY2VEZWZzLmNvbmNhdChob29rczEuZXZlbnRTb3VyY2VEZWZzKSxcclxuICAgICAgICAgICAgY21kRm9ybWF0dGVyOiBob29rczEuY21kRm9ybWF0dGVyIHx8IGhvb2tzMC5jbWRGb3JtYXR0ZXIsXHJcbiAgICAgICAgICAgIHJlY3VycmluZ1R5cGVzOiBob29rczAucmVjdXJyaW5nVHlwZXMuY29uY2F0KGhvb2tzMS5yZWN1cnJpbmdUeXBlcyksXHJcbiAgICAgICAgICAgIG5hbWVkVGltZVpvbmVkSW1wbDogaG9va3MxLm5hbWVkVGltZVpvbmVkSW1wbCB8fCBob29rczAubmFtZWRUaW1lWm9uZWRJbXBsLFxyXG4gICAgICAgICAgICBpbml0aWFsVmlldzogaG9va3MwLmluaXRpYWxWaWV3IHx8IGhvb2tzMS5pbml0aWFsVmlldyxcclxuICAgICAgICAgICAgZWxlbWVudERyYWdnaW5nSW1wbDogaG9va3MwLmVsZW1lbnREcmFnZ2luZ0ltcGwgfHwgaG9va3MxLmVsZW1lbnREcmFnZ2luZ0ltcGwsXHJcbiAgICAgICAgICAgIG9wdGlvbkNoYW5nZUhhbmRsZXJzOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGhvb2tzMC5vcHRpb25DaGFuZ2VIYW5kbGVycyksIGhvb2tzMS5vcHRpb25DaGFuZ2VIYW5kbGVycyksXHJcbiAgICAgICAgICAgIHNjcm9sbEdyaWRJbXBsOiBob29rczEuc2Nyb2xsR3JpZEltcGwgfHwgaG9va3MwLnNjcm9sbEdyaWRJbXBsLFxyXG4gICAgICAgICAgICBsaXN0ZW5lclJlZmluZXJzOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGhvb2tzMC5saXN0ZW5lclJlZmluZXJzKSwgaG9va3MxLmxpc3RlbmVyUmVmaW5lcnMpLFxyXG4gICAgICAgICAgICBvcHRpb25SZWZpbmVyczogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBob29rczAub3B0aW9uUmVmaW5lcnMpLCBob29rczEub3B0aW9uUmVmaW5lcnMpLFxyXG4gICAgICAgICAgICBwcm9wU2V0SGFuZGxlcnM6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgaG9va3MwLnByb3BTZXRIYW5kbGVycyksIGhvb2tzMS5wcm9wU2V0SGFuZGxlcnMpLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBjb21wYXJlT3B0aW9uYWxEYXRlcyhkYXRlMCwgZGF0ZTEpIHtcclxuICAgICAgICBpZiAoZGF0ZTAgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZGF0ZTE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChkYXRlMSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkYXRlMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKE1hdGgubWF4KGRhdGUwLnZhbHVlT2YoKSwgZGF0ZTEudmFsdWVPZigpKSk7XHJcbiAgICB9XHJcblxyXG4gICAgY2xhc3MgU3RhbmRhcmRUaGVtZSBleHRlbmRzIFRoZW1lIHtcclxuICAgIH1cclxuICAgIFN0YW5kYXJkVGhlbWUucHJvdG90eXBlLmNsYXNzZXMgPSB7XHJcbiAgICAgICAgcm9vdDogJ2ZjLXRoZW1lLXN0YW5kYXJkJyxcclxuICAgICAgICB0YWJsZUNlbGxTaGFkZWQ6ICdmYy1jZWxsLXNoYWRlZCcsXHJcbiAgICAgICAgYnV0dG9uR3JvdXA6ICdmYy1idXR0b24tZ3JvdXAnLFxyXG4gICAgICAgIGJ1dHRvbjogJ2ZjLWJ1dHRvbiBmYy1idXR0b24tcHJpbWFyeScsXHJcbiAgICAgICAgYnV0dG9uQWN0aXZlOiAnZmMtYnV0dG9uLWFjdGl2ZScsXHJcbiAgICB9O1xyXG4gICAgU3RhbmRhcmRUaGVtZS5wcm90b3R5cGUuYmFzZUljb25DbGFzcyA9ICdmYy1pY29uJztcclxuICAgIFN0YW5kYXJkVGhlbWUucHJvdG90eXBlLmljb25DbGFzc2VzID0ge1xyXG4gICAgICAgIGNsb3NlOiAnZmMtaWNvbi14JyxcclxuICAgICAgICBwcmV2OiAnZmMtaWNvbi1jaGV2cm9uLWxlZnQnLFxyXG4gICAgICAgIG5leHQ6ICdmYy1pY29uLWNoZXZyb24tcmlnaHQnLFxyXG4gICAgICAgIHByZXZZZWFyOiAnZmMtaWNvbi1jaGV2cm9ucy1sZWZ0JyxcclxuICAgICAgICBuZXh0WWVhcjogJ2ZjLWljb24tY2hldnJvbnMtcmlnaHQnLFxyXG4gICAgfTtcclxuICAgIFN0YW5kYXJkVGhlbWUucHJvdG90eXBlLnJ0bEljb25DbGFzc2VzID0ge1xyXG4gICAgICAgIHByZXY6ICdmYy1pY29uLWNoZXZyb24tcmlnaHQnLFxyXG4gICAgICAgIG5leHQ6ICdmYy1pY29uLWNoZXZyb24tbGVmdCcsXHJcbiAgICAgICAgcHJldlllYXI6ICdmYy1pY29uLWNoZXZyb25zLXJpZ2h0JyxcclxuICAgICAgICBuZXh0WWVhcjogJ2ZjLWljb24tY2hldnJvbnMtbGVmdCcsXHJcbiAgICB9O1xyXG4gICAgU3RhbmRhcmRUaGVtZS5wcm90b3R5cGUuaWNvbk92ZXJyaWRlT3B0aW9uID0gJ2J1dHRvbkljb25zJzsgLy8gVE9ETzogbWFrZSBUUy1mcmllbmRseVxyXG4gICAgU3RhbmRhcmRUaGVtZS5wcm90b3R5cGUuaWNvbk92ZXJyaWRlQ3VzdG9tQnV0dG9uT3B0aW9uID0gJ2ljb24nO1xyXG4gICAgU3RhbmRhcmRUaGVtZS5wcm90b3R5cGUuaWNvbk92ZXJyaWRlUHJlZml4ID0gJ2ZjLWljb24tJztcclxuXHJcbiAgICBmdW5jdGlvbiBjb21waWxlVmlld0RlZnMoZGVmYXVsdENvbmZpZ3MsIG92ZXJyaWRlQ29uZmlncykge1xyXG4gICAgICAgIGxldCBoYXNoID0ge307XHJcbiAgICAgICAgbGV0IHZpZXdUeXBlO1xyXG4gICAgICAgIGZvciAodmlld1R5cGUgaW4gZGVmYXVsdENvbmZpZ3MpIHtcclxuICAgICAgICAgICAgZW5zdXJlVmlld0RlZih2aWV3VHlwZSwgaGFzaCwgZGVmYXVsdENvbmZpZ3MsIG92ZXJyaWRlQ29uZmlncyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAodmlld1R5cGUgaW4gb3ZlcnJpZGVDb25maWdzKSB7XHJcbiAgICAgICAgICAgIGVuc3VyZVZpZXdEZWYodmlld1R5cGUsIGhhc2gsIGRlZmF1bHRDb25maWdzLCBvdmVycmlkZUNvbmZpZ3MpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaGFzaDtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGVuc3VyZVZpZXdEZWYodmlld1R5cGUsIGhhc2gsIGRlZmF1bHRDb25maWdzLCBvdmVycmlkZUNvbmZpZ3MpIHtcclxuICAgICAgICBpZiAoaGFzaFt2aWV3VHlwZV0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIGhhc2hbdmlld1R5cGVdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgdmlld0RlZiA9IGJ1aWxkVmlld0RlZih2aWV3VHlwZSwgaGFzaCwgZGVmYXVsdENvbmZpZ3MsIG92ZXJyaWRlQ29uZmlncyk7XHJcbiAgICAgICAgaWYgKHZpZXdEZWYpIHtcclxuICAgICAgICAgICAgaGFzaFt2aWV3VHlwZV0gPSB2aWV3RGVmO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdmlld0RlZjtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGJ1aWxkVmlld0RlZih2aWV3VHlwZSwgaGFzaCwgZGVmYXVsdENvbmZpZ3MsIG92ZXJyaWRlQ29uZmlncykge1xyXG4gICAgICAgIGxldCBkZWZhdWx0Q29uZmlnID0gZGVmYXVsdENvbmZpZ3Nbdmlld1R5cGVdO1xyXG4gICAgICAgIGxldCBvdmVycmlkZUNvbmZpZyA9IG92ZXJyaWRlQ29uZmlnc1t2aWV3VHlwZV07XHJcbiAgICAgICAgbGV0IHF1ZXJ5UHJvcCA9IChuYW1lKSA9PiAoKGRlZmF1bHRDb25maWcgJiYgZGVmYXVsdENvbmZpZ1tuYW1lXSAhPT0gbnVsbCkgPyBkZWZhdWx0Q29uZmlnW25hbWVdIDpcclxuICAgICAgICAgICAgKChvdmVycmlkZUNvbmZpZyAmJiBvdmVycmlkZUNvbmZpZ1tuYW1lXSAhPT0gbnVsbCkgPyBvdmVycmlkZUNvbmZpZ1tuYW1lXSA6IG51bGwpKTtcclxuICAgICAgICBsZXQgdGhlQ29tcG9uZW50ID0gcXVlcnlQcm9wKCdjb21wb25lbnQnKTtcclxuICAgICAgICBsZXQgc3VwZXJUeXBlID0gcXVlcnlQcm9wKCdzdXBlclR5cGUnKTtcclxuICAgICAgICBsZXQgc3VwZXJEZWYgPSBudWxsO1xyXG4gICAgICAgIGlmIChzdXBlclR5cGUpIHtcclxuICAgICAgICAgICAgaWYgKHN1cGVyVHlwZSA9PT0gdmlld1R5cGUpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuXFwndCBoYXZlIGEgY3VzdG9tIHZpZXcgdHlwZSB0aGF0IHJlZmVyZW5jZXMgaXRzZWxmJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc3VwZXJEZWYgPSBlbnN1cmVWaWV3RGVmKHN1cGVyVHlwZSwgaGFzaCwgZGVmYXVsdENvbmZpZ3MsIG92ZXJyaWRlQ29uZmlncyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdGhlQ29tcG9uZW50ICYmIHN1cGVyRGVmKSB7XHJcbiAgICAgICAgICAgIHRoZUNvbXBvbmVudCA9IHN1cGVyRGVmLmNvbXBvbmVudDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCF0aGVDb21wb25lbnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7IC8vIGRvbid0IHRocm93IGEgd2FybmluZywgbWlnaHQgYmUgc2V0dGluZ3MgZm9yIGEgc2luZ2xlLXVuaXQgdmlld1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB0eXBlOiB2aWV3VHlwZSxcclxuICAgICAgICAgICAgY29tcG9uZW50OiB0aGVDb21wb25lbnQsXHJcbiAgICAgICAgICAgIGRlZmF1bHRzOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIChzdXBlckRlZiA/IHN1cGVyRGVmLmRlZmF1bHRzIDoge30pKSwgKGRlZmF1bHRDb25maWcgPyBkZWZhdWx0Q29uZmlnLnJhd09wdGlvbnMgOiB7fSkpLFxyXG4gICAgICAgICAgICBvdmVycmlkZXM6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgKHN1cGVyRGVmID8gc3VwZXJEZWYub3ZlcnJpZGVzIDoge30pKSwgKG92ZXJyaWRlQ29uZmlnID8gb3ZlcnJpZGVDb25maWcucmF3T3B0aW9ucyA6IHt9KSksXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBwYXJzZVZpZXdDb25maWdzKGlucHV0cykge1xyXG4gICAgICAgIHJldHVybiBtYXBIYXNoKGlucHV0cywgcGFyc2VWaWV3Q29uZmlnKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHBhcnNlVmlld0NvbmZpZyhpbnB1dCkge1xyXG4gICAgICAgIGxldCByYXdPcHRpb25zID0gdHlwZW9mIGlucHV0ID09PSAnZnVuY3Rpb24nID9cclxuICAgICAgICAgICAgeyBjb21wb25lbnQ6IGlucHV0IH0gOlxyXG4gICAgICAgICAgICBpbnB1dDtcclxuICAgICAgICBsZXQgeyBjb21wb25lbnQgfSA9IHJhd09wdGlvbnM7XHJcbiAgICAgICAgaWYgKHJhd09wdGlvbnMuY29udGVudCkge1xyXG4gICAgICAgICAgICAvLyBUT0RPOiByZW1vdmUgY29udGVudC9jbGFzc05hbWVzL2RpZE1vdW50L2V0YyBmcm9tIG9wdGlvbnM/XHJcbiAgICAgICAgICAgIGNvbXBvbmVudCA9IGNyZWF0ZVZpZXdIb29rQ29tcG9uZW50KHJhd09wdGlvbnMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjb21wb25lbnQgJiYgIShjb21wb25lbnQucHJvdG90eXBlIGluc3RhbmNlb2YgQmFzZUNvbXBvbmVudCkpIHtcclxuICAgICAgICAgICAgLy8gV0hZPzogcGVvcGxlIHdlcmUgdXNpbmcgYGNvbXBvbmVudGAgcHJvcGVydHkgZm9yIGBjb250ZW50YFxyXG4gICAgICAgICAgICAvLyBUT0RPOiBjb252ZXJnZSBvbiBvbmUgc2V0dGluZyBuYW1lXHJcbiAgICAgICAgICAgIGNvbXBvbmVudCA9IGNyZWF0ZVZpZXdIb29rQ29tcG9uZW50KE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcmF3T3B0aW9ucyksIHsgY29udGVudDogY29tcG9uZW50IH0pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgc3VwZXJUeXBlOiByYXdPcHRpb25zLnR5cGUsXHJcbiAgICAgICAgICAgIGNvbXBvbmVudDogY29tcG9uZW50LFxyXG4gICAgICAgICAgICByYXdPcHRpb25zLCAvLyBpbmNsdWRlcyB0eXBlIGFuZCBjb21wb25lbnQgdG9vIDooXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGNyZWF0ZVZpZXdIb29rQ29tcG9uZW50KG9wdGlvbnMpIHtcclxuICAgICAgICByZXR1cm4gKHZpZXdQcm9wcykgPT4gKHkoVmlld0NvbnRleHRUeXBlLkNvbnN1bWVyLCBudWxsLCAoY29udGV4dCkgPT4gKHkoQ29udGVudENvbnRhaW5lciwgeyBlbFRhZzogXCJkaXZcIiwgZWxDbGFzc2VzOiBidWlsZFZpZXdDbGFzc05hbWVzKGNvbnRleHQudmlld1NwZWMpLCByZW5kZXJQcm9wczogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB2aWV3UHJvcHMpLCB7IG5leHREYXlUaHJlc2hvbGQ6IGNvbnRleHQub3B0aW9ucy5uZXh0RGF5VGhyZXNob2xkIH0pLCBnZW5lcmF0b3JOYW1lOiB1bmRlZmluZWQsIGN1c3RvbUdlbmVyYXRvcjogb3B0aW9ucy5jb250ZW50LCBjbGFzc05hbWVHZW5lcmF0b3I6IG9wdGlvbnMuY2xhc3NOYW1lcywgZGlkTW91bnQ6IG9wdGlvbnMuZGlkTW91bnQsIHdpbGxVbm1vdW50OiBvcHRpb25zLndpbGxVbm1vdW50IH0pKSkpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGJ1aWxkVmlld1NwZWNzKGRlZmF1bHRJbnB1dHMsIG9wdGlvbk92ZXJyaWRlcywgZHluYW1pY09wdGlvbk92ZXJyaWRlcywgbG9jYWxlRGVmYXVsdHMpIHtcclxuICAgICAgICBsZXQgZGVmYXVsdENvbmZpZ3MgPSBwYXJzZVZpZXdDb25maWdzKGRlZmF1bHRJbnB1dHMpO1xyXG4gICAgICAgIGxldCBvdmVycmlkZUNvbmZpZ3MgPSBwYXJzZVZpZXdDb25maWdzKG9wdGlvbk92ZXJyaWRlcy52aWV3cyk7XHJcbiAgICAgICAgbGV0IHZpZXdEZWZzID0gY29tcGlsZVZpZXdEZWZzKGRlZmF1bHRDb25maWdzLCBvdmVycmlkZUNvbmZpZ3MpO1xyXG4gICAgICAgIHJldHVybiBtYXBIYXNoKHZpZXdEZWZzLCAodmlld0RlZikgPT4gYnVpbGRWaWV3U3BlYyh2aWV3RGVmLCBvdmVycmlkZUNvbmZpZ3MsIG9wdGlvbk92ZXJyaWRlcywgZHluYW1pY09wdGlvbk92ZXJyaWRlcywgbG9jYWxlRGVmYXVsdHMpKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGJ1aWxkVmlld1NwZWModmlld0RlZiwgb3ZlcnJpZGVDb25maWdzLCBvcHRpb25PdmVycmlkZXMsIGR5bmFtaWNPcHRpb25PdmVycmlkZXMsIGxvY2FsZURlZmF1bHRzKSB7XHJcbiAgICAgICAgbGV0IGR1cmF0aW9uSW5wdXQgPSB2aWV3RGVmLm92ZXJyaWRlcy5kdXJhdGlvbiB8fFxyXG4gICAgICAgICAgICB2aWV3RGVmLmRlZmF1bHRzLmR1cmF0aW9uIHx8XHJcbiAgICAgICAgICAgIGR5bmFtaWNPcHRpb25PdmVycmlkZXMuZHVyYXRpb24gfHxcclxuICAgICAgICAgICAgb3B0aW9uT3ZlcnJpZGVzLmR1cmF0aW9uO1xyXG4gICAgICAgIGxldCBkdXJhdGlvbiA9IG51bGw7XHJcbiAgICAgICAgbGV0IGR1cmF0aW9uVW5pdCA9ICcnO1xyXG4gICAgICAgIGxldCBzaW5nbGVVbml0ID0gJyc7XHJcbiAgICAgICAgbGV0IHNpbmdsZVVuaXRPdmVycmlkZXMgPSB7fTtcclxuICAgICAgICBpZiAoZHVyYXRpb25JbnB1dCkge1xyXG4gICAgICAgICAgICBkdXJhdGlvbiA9IGNyZWF0ZUR1cmF0aW9uQ2FjaGVkKGR1cmF0aW9uSW5wdXQpO1xyXG4gICAgICAgICAgICBpZiAoZHVyYXRpb24pIHsgLy8gdmFsaWQ/XHJcbiAgICAgICAgICAgICAgICBsZXQgZGVub20gPSBncmVhdGVzdER1cmF0aW9uRGVub21pbmF0b3IoZHVyYXRpb24pO1xyXG4gICAgICAgICAgICAgICAgZHVyYXRpb25Vbml0ID0gZGVub20udW5pdDtcclxuICAgICAgICAgICAgICAgIGlmIChkZW5vbS52YWx1ZSA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNpbmdsZVVuaXQgPSBkdXJhdGlvblVuaXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgc2luZ2xlVW5pdE92ZXJyaWRlcyA9IG92ZXJyaWRlQ29uZmlnc1tkdXJhdGlvblVuaXRdID8gb3ZlcnJpZGVDb25maWdzW2R1cmF0aW9uVW5pdF0ucmF3T3B0aW9ucyA6IHt9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBxdWVyeUJ1dHRvblRleHQgPSAob3B0aW9uc1N1YnNldCkgPT4ge1xyXG4gICAgICAgICAgICBsZXQgYnV0dG9uVGV4dE1hcCA9IG9wdGlvbnNTdWJzZXQuYnV0dG9uVGV4dCB8fCB7fTtcclxuICAgICAgICAgICAgbGV0IGJ1dHRvblRleHRLZXkgPSB2aWV3RGVmLmRlZmF1bHRzLmJ1dHRvblRleHRLZXk7XHJcbiAgICAgICAgICAgIGlmIChidXR0b25UZXh0S2V5ICE9IG51bGwgJiYgYnV0dG9uVGV4dE1hcFtidXR0b25UZXh0S2V5XSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYnV0dG9uVGV4dE1hcFtidXR0b25UZXh0S2V5XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoYnV0dG9uVGV4dE1hcFt2aWV3RGVmLnR5cGVdICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBidXR0b25UZXh0TWFwW3ZpZXdEZWYudHlwZV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGJ1dHRvblRleHRNYXBbc2luZ2xlVW5pdF0gIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJ1dHRvblRleHRNYXBbc2luZ2xlVW5pdF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBsZXQgcXVlcnlCdXR0b25UaXRsZSA9IChvcHRpb25zU3Vic2V0KSA9PiB7XHJcbiAgICAgICAgICAgIGxldCBidXR0b25IaW50cyA9IG9wdGlvbnNTdWJzZXQuYnV0dG9uSGludHMgfHwge307XHJcbiAgICAgICAgICAgIGxldCBidXR0b25LZXkgPSB2aWV3RGVmLmRlZmF1bHRzLmJ1dHRvblRleHRLZXk7IC8vIHVzZSBzYW1lIGtleSBhcyB0ZXh0XHJcbiAgICAgICAgICAgIGlmIChidXR0b25LZXkgIT0gbnVsbCAmJiBidXR0b25IaW50c1tidXR0b25LZXldICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBidXR0b25IaW50c1tidXR0b25LZXldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChidXR0b25IaW50c1t2aWV3RGVmLnR5cGVdICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBidXR0b25IaW50c1t2aWV3RGVmLnR5cGVdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChidXR0b25IaW50c1tzaW5nbGVVbml0XSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYnV0dG9uSGludHNbc2luZ2xlVW5pdF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB0eXBlOiB2aWV3RGVmLnR5cGUsXHJcbiAgICAgICAgICAgIGNvbXBvbmVudDogdmlld0RlZi5jb21wb25lbnQsXHJcbiAgICAgICAgICAgIGR1cmF0aW9uLFxyXG4gICAgICAgICAgICBkdXJhdGlvblVuaXQsXHJcbiAgICAgICAgICAgIHNpbmdsZVVuaXQsXHJcbiAgICAgICAgICAgIG9wdGlvbkRlZmF1bHRzOiB2aWV3RGVmLmRlZmF1bHRzLFxyXG4gICAgICAgICAgICBvcHRpb25PdmVycmlkZXM6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc2luZ2xlVW5pdE92ZXJyaWRlcyksIHZpZXdEZWYub3ZlcnJpZGVzKSxcclxuICAgICAgICAgICAgYnV0dG9uVGV4dE92ZXJyaWRlOiBxdWVyeUJ1dHRvblRleHQoZHluYW1pY09wdGlvbk92ZXJyaWRlcykgfHxcclxuICAgICAgICAgICAgICAgIHF1ZXJ5QnV0dG9uVGV4dChvcHRpb25PdmVycmlkZXMpIHx8IC8vIGNvbnN0cnVjdG9yLXNwZWNpZmllZCBidXR0b25UZXh0IGxvb2t1cCBoYXNoIHRha2VzIHByZWNlZGVuY2VcclxuICAgICAgICAgICAgICAgIHZpZXdEZWYub3ZlcnJpZGVzLmJ1dHRvblRleHQsXHJcbiAgICAgICAgICAgIGJ1dHRvblRleHREZWZhdWx0OiBxdWVyeUJ1dHRvblRleHQobG9jYWxlRGVmYXVsdHMpIHx8XHJcbiAgICAgICAgICAgICAgICB2aWV3RGVmLmRlZmF1bHRzLmJ1dHRvblRleHQgfHxcclxuICAgICAgICAgICAgICAgIHF1ZXJ5QnV0dG9uVGV4dChCQVNFX09QVElPTl9ERUZBVUxUUykgfHxcclxuICAgICAgICAgICAgICAgIHZpZXdEZWYudHlwZSxcclxuICAgICAgICAgICAgLy8gbm90IERSWVxyXG4gICAgICAgICAgICBidXR0b25UaXRsZU92ZXJyaWRlOiBxdWVyeUJ1dHRvblRpdGxlKGR5bmFtaWNPcHRpb25PdmVycmlkZXMpIHx8XHJcbiAgICAgICAgICAgICAgICBxdWVyeUJ1dHRvblRpdGxlKG9wdGlvbk92ZXJyaWRlcykgfHxcclxuICAgICAgICAgICAgICAgIHZpZXdEZWYub3ZlcnJpZGVzLmJ1dHRvbkhpbnQsXHJcbiAgICAgICAgICAgIGJ1dHRvblRpdGxlRGVmYXVsdDogcXVlcnlCdXR0b25UaXRsZShsb2NhbGVEZWZhdWx0cykgfHxcclxuICAgICAgICAgICAgICAgIHZpZXdEZWYuZGVmYXVsdHMuYnV0dG9uSGludCB8fFxyXG4gICAgICAgICAgICAgICAgcXVlcnlCdXR0b25UaXRsZShCQVNFX09QVElPTl9ERUZBVUxUUyksXHJcbiAgICAgICAgICAgIC8vIHdpbGwgZXZlbnR1YWxseSBmYWxsIGJhY2sgdG8gYnV0dG9uVGV4dFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICAvLyBoYWNrIHRvIGdldCBtZW1vaXphdGlvbiB3b3JraW5nXHJcbiAgICBsZXQgZHVyYXRpb25JbnB1dE1hcCA9IHt9O1xyXG4gICAgZnVuY3Rpb24gY3JlYXRlRHVyYXRpb25DYWNoZWQoZHVyYXRpb25JbnB1dCkge1xyXG4gICAgICAgIGxldCBqc29uID0gSlNPTi5zdHJpbmdpZnkoZHVyYXRpb25JbnB1dCk7XHJcbiAgICAgICAgbGV0IHJlcyA9IGR1cmF0aW9uSW5wdXRNYXBbanNvbl07XHJcbiAgICAgICAgaWYgKHJlcyA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJlcyA9IGNyZWF0ZUR1cmF0aW9uKGR1cmF0aW9uSW5wdXQpO1xyXG4gICAgICAgICAgICBkdXJhdGlvbklucHV0TWFwW2pzb25dID0gcmVzO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHJlZHVjZVZpZXdUeXBlKHZpZXdUeXBlLCBhY3Rpb24pIHtcclxuICAgICAgICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgJ0NIQU5HRV9WSUVXX1RZUEUnOlxyXG4gICAgICAgICAgICAgICAgdmlld1R5cGUgPSBhY3Rpb24udmlld1R5cGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB2aWV3VHlwZTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiByZWR1Y2VEeW5hbWljT3B0aW9uT3ZlcnJpZGVzKGR5bmFtaWNPcHRpb25PdmVycmlkZXMsIGFjdGlvbikge1xyXG4gICAgICAgIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcclxuICAgICAgICAgICAgY2FzZSAnU0VUX09QVElPTic6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzKSwgeyBbYWN0aW9uLm9wdGlvbk5hbWVdOiBhY3Rpb24ucmF3T3B0aW9uVmFsdWUgfSk7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZHluYW1pY09wdGlvbk92ZXJyaWRlcztcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcmVkdWNlRGF0ZVByb2ZpbGUoY3VycmVudERhdGVQcm9maWxlLCBhY3Rpb24sIGN1cnJlbnREYXRlLCBkYXRlUHJvZmlsZUdlbmVyYXRvcikge1xyXG4gICAgICAgIGxldCBkcDtcclxuICAgICAgICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgJ0NIQU5HRV9WSUVXX1RZUEUnOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGVQcm9maWxlR2VuZXJhdG9yLmJ1aWxkKGFjdGlvbi5kYXRlTWFya2VyIHx8IGN1cnJlbnREYXRlKTtcclxuICAgICAgICAgICAgY2FzZSAnQ0hBTkdFX0RBVEUnOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGVQcm9maWxlR2VuZXJhdG9yLmJ1aWxkKGFjdGlvbi5kYXRlTWFya2VyKTtcclxuICAgICAgICAgICAgY2FzZSAnUFJFVic6XHJcbiAgICAgICAgICAgICAgICBkcCA9IGRhdGVQcm9maWxlR2VuZXJhdG9yLmJ1aWxkUHJldihjdXJyZW50RGF0ZVByb2ZpbGUsIGN1cnJlbnREYXRlKTtcclxuICAgICAgICAgICAgICAgIGlmIChkcC5pc1ZhbGlkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRwO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ05FWFQnOlxyXG4gICAgICAgICAgICAgICAgZHAgPSBkYXRlUHJvZmlsZUdlbmVyYXRvci5idWlsZE5leHQoY3VycmVudERhdGVQcm9maWxlLCBjdXJyZW50RGF0ZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZHAuaXNWYWxpZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkcDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY3VycmVudERhdGVQcm9maWxlO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGluaXRFdmVudFNvdXJjZXMoY2FsZW5kYXJPcHRpb25zLCBkYXRlUHJvZmlsZSwgY29udGV4dCkge1xyXG4gICAgICAgIGxldCBhY3RpdmVSYW5nZSA9IGRhdGVQcm9maWxlID8gZGF0ZVByb2ZpbGUuYWN0aXZlUmFuZ2UgOiBudWxsO1xyXG4gICAgICAgIHJldHVybiBhZGRTb3VyY2VzKHt9LCBwYXJzZUluaXRpYWxTb3VyY2VzKGNhbGVuZGFyT3B0aW9ucywgY29udGV4dCksIGFjdGl2ZVJhbmdlLCBjb250ZXh0KTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHJlZHVjZUV2ZW50U291cmNlcyhldmVudFNvdXJjZXMsIGFjdGlvbiwgZGF0ZVByb2ZpbGUsIGNvbnRleHQpIHtcclxuICAgICAgICBsZXQgYWN0aXZlUmFuZ2UgPSBkYXRlUHJvZmlsZSA/IGRhdGVQcm9maWxlLmFjdGl2ZVJhbmdlIDogbnVsbDsgLy8gbmVlZCB0aGlzIGNoZWNrP1xyXG4gICAgICAgIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcclxuICAgICAgICAgICAgY2FzZSAnQUREX0VWRU5UX1NPVVJDRVMnOiAvLyBhbHJlYWR5IHBhcnNlZFxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFkZFNvdXJjZXMoZXZlbnRTb3VyY2VzLCBhY3Rpb24uc291cmNlcywgYWN0aXZlUmFuZ2UsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICBjYXNlICdSRU1PVkVfRVZFTlRfU09VUkNFJzpcclxuICAgICAgICAgICAgICAgIHJldHVybiByZW1vdmVTb3VyY2UoZXZlbnRTb3VyY2VzLCBhY3Rpb24uc291cmNlSWQpO1xyXG4gICAgICAgICAgICBjYXNlICdQUkVWJzogLy8gVE9ETzogaG93IGRvIHdlIHRyYWNrIGFsbCBhY3Rpb25zIHRoYXQgYWZmZWN0IGRhdGVQcm9maWxlIDooXHJcbiAgICAgICAgICAgIGNhc2UgJ05FWFQnOlxyXG4gICAgICAgICAgICBjYXNlICdDSEFOR0VfREFURSc6XHJcbiAgICAgICAgICAgIGNhc2UgJ0NIQU5HRV9WSUVXX1RZUEUnOlxyXG4gICAgICAgICAgICAgICAgaWYgKGRhdGVQcm9maWxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZldGNoRGlydHlTb3VyY2VzKGV2ZW50U291cmNlcywgYWN0aXZlUmFuZ2UsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGV2ZW50U291cmNlcztcclxuICAgICAgICAgICAgY2FzZSAnRkVUQ0hfRVZFTlRfU09VUkNFUyc6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmV0Y2hTb3VyY2VzQnlJZHMoZXZlbnRTb3VyY2VzLCBhY3Rpb24uc291cmNlSWRzID8gLy8gd2h5IG5vIHR5cGU/XHJcbiAgICAgICAgICAgICAgICAgICAgYXJyYXlUb0hhc2goYWN0aW9uLnNvdXJjZUlkcykgOlxyXG4gICAgICAgICAgICAgICAgICAgIGV4Y2x1ZGVTdGF0aWNTb3VyY2VzKGV2ZW50U291cmNlcywgY29udGV4dCksIGFjdGl2ZVJhbmdlLCBhY3Rpb24uaXNSZWZldGNoIHx8IGZhbHNlLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgY2FzZSAnUkVDRUlWRV9FVkVOVFMnOlxyXG4gICAgICAgICAgICBjYXNlICdSRUNFSVZFX0VWRU5UX0VSUk9SJzpcclxuICAgICAgICAgICAgICAgIHJldHVybiByZWNlaXZlUmVzcG9uc2UoZXZlbnRTb3VyY2VzLCBhY3Rpb24uc291cmNlSWQsIGFjdGlvbi5mZXRjaElkLCBhY3Rpb24uZmV0Y2hSYW5nZSk7XHJcbiAgICAgICAgICAgIGNhc2UgJ1JFTU9WRV9BTExfRVZFTlRfU09VUkNFUyc6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge307XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZXZlbnRTb3VyY2VzO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHJlZHVjZUV2ZW50U291cmNlc05ld1RpbWVab25lKGV2ZW50U291cmNlcywgZGF0ZVByb2ZpbGUsIGNvbnRleHQpIHtcclxuICAgICAgICBsZXQgYWN0aXZlUmFuZ2UgPSBkYXRlUHJvZmlsZSA/IGRhdGVQcm9maWxlLmFjdGl2ZVJhbmdlIDogbnVsbDsgLy8gbmVlZCB0aGlzIGNoZWNrP1xyXG4gICAgICAgIHJldHVybiBmZXRjaFNvdXJjZXNCeUlkcyhldmVudFNvdXJjZXMsIGV4Y2x1ZGVTdGF0aWNTb3VyY2VzKGV2ZW50U291cmNlcywgY29udGV4dCksIGFjdGl2ZVJhbmdlLCB0cnVlLCBjb250ZXh0KTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGNvbXB1dGVFdmVudFNvdXJjZXNMb2FkaW5nKGV2ZW50U291cmNlcykge1xyXG4gICAgICAgIGZvciAobGV0IHNvdXJjZUlkIGluIGV2ZW50U291cmNlcykge1xyXG4gICAgICAgICAgICBpZiAoZXZlbnRTb3VyY2VzW3NvdXJjZUlkXS5pc0ZldGNoaW5nKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBhZGRTb3VyY2VzKGV2ZW50U291cmNlSGFzaCwgc291cmNlcywgZmV0Y2hSYW5nZSwgY29udGV4dCkge1xyXG4gICAgICAgIGxldCBoYXNoID0ge307XHJcbiAgICAgICAgZm9yIChsZXQgc291cmNlIG9mIHNvdXJjZXMpIHtcclxuICAgICAgICAgICAgaGFzaFtzb3VyY2Uuc291cmNlSWRdID0gc291cmNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZmV0Y2hSYW5nZSkge1xyXG4gICAgICAgICAgICBoYXNoID0gZmV0Y2hEaXJ0eVNvdXJjZXMoaGFzaCwgZmV0Y2hSYW5nZSwgY29udGV4dCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGV2ZW50U291cmNlSGFzaCksIGhhc2gpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gcmVtb3ZlU291cmNlKGV2ZW50U291cmNlSGFzaCwgc291cmNlSWQpIHtcclxuICAgICAgICByZXR1cm4gZmlsdGVySGFzaChldmVudFNvdXJjZUhhc2gsIChldmVudFNvdXJjZSkgPT4gZXZlbnRTb3VyY2Uuc291cmNlSWQgIT09IHNvdXJjZUlkKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGZldGNoRGlydHlTb3VyY2VzKHNvdXJjZUhhc2gsIGZldGNoUmFuZ2UsIGNvbnRleHQpIHtcclxuICAgICAgICByZXR1cm4gZmV0Y2hTb3VyY2VzQnlJZHMoc291cmNlSGFzaCwgZmlsdGVySGFzaChzb3VyY2VIYXNoLCAoZXZlbnRTb3VyY2UpID0+IGlzU291cmNlRGlydHkoZXZlbnRTb3VyY2UsIGZldGNoUmFuZ2UsIGNvbnRleHQpKSwgZmV0Y2hSYW5nZSwgZmFsc2UsIGNvbnRleHQpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gaXNTb3VyY2VEaXJ0eShldmVudFNvdXJjZSwgZmV0Y2hSYW5nZSwgY29udGV4dCkge1xyXG4gICAgICAgIGlmICghZG9lc1NvdXJjZU5lZWRSYW5nZShldmVudFNvdXJjZSwgY29udGV4dCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuICFldmVudFNvdXJjZS5sYXRlc3RGZXRjaElkO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gIWNvbnRleHQub3B0aW9ucy5sYXp5RmV0Y2hpbmcgfHxcclxuICAgICAgICAgICAgIWV2ZW50U291cmNlLmZldGNoUmFuZ2UgfHxcclxuICAgICAgICAgICAgZXZlbnRTb3VyY2UuaXNGZXRjaGluZyB8fCAvLyBhbHdheXMgY2FuY2VsIG91dGRhdGVkIGluLXByb2dyZXNzIGZldGNoZXNcclxuICAgICAgICAgICAgZmV0Y2hSYW5nZS5zdGFydCA8IGV2ZW50U291cmNlLmZldGNoUmFuZ2Uuc3RhcnQgfHxcclxuICAgICAgICAgICAgZmV0Y2hSYW5nZS5lbmQgPiBldmVudFNvdXJjZS5mZXRjaFJhbmdlLmVuZDtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGZldGNoU291cmNlc0J5SWRzKHByZXZTb3VyY2VzLCBzb3VyY2VJZEhhc2gsIGZldGNoUmFuZ2UsIGlzUmVmZXRjaCwgY29udGV4dCkge1xyXG4gICAgICAgIGxldCBuZXh0U291cmNlcyA9IHt9O1xyXG4gICAgICAgIGZvciAobGV0IHNvdXJjZUlkIGluIHByZXZTb3VyY2VzKSB7XHJcbiAgICAgICAgICAgIGxldCBzb3VyY2UgPSBwcmV2U291cmNlc1tzb3VyY2VJZF07XHJcbiAgICAgICAgICAgIGlmIChzb3VyY2VJZEhhc2hbc291cmNlSWRdKSB7XHJcbiAgICAgICAgICAgICAgICBuZXh0U291cmNlc1tzb3VyY2VJZF0gPSBmZXRjaFNvdXJjZShzb3VyY2UsIGZldGNoUmFuZ2UsIGlzUmVmZXRjaCwgY29udGV4dCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBuZXh0U291cmNlc1tzb3VyY2VJZF0gPSBzb3VyY2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5leHRTb3VyY2VzO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZmV0Y2hTb3VyY2UoZXZlbnRTb3VyY2UsIGZldGNoUmFuZ2UsIGlzUmVmZXRjaCwgY29udGV4dCkge1xyXG4gICAgICAgIGxldCB7IG9wdGlvbnMsIGNhbGVuZGFyQXBpIH0gPSBjb250ZXh0O1xyXG4gICAgICAgIGxldCBzb3VyY2VEZWYgPSBjb250ZXh0LnBsdWdpbkhvb2tzLmV2ZW50U291cmNlRGVmc1tldmVudFNvdXJjZS5zb3VyY2VEZWZJZF07XHJcbiAgICAgICAgbGV0IGZldGNoSWQgPSBndWlkKCk7XHJcbiAgICAgICAgc291cmNlRGVmLmZldGNoKHtcclxuICAgICAgICAgICAgZXZlbnRTb3VyY2UsXHJcbiAgICAgICAgICAgIHJhbmdlOiBmZXRjaFJhbmdlLFxyXG4gICAgICAgICAgICBpc1JlZmV0Y2gsXHJcbiAgICAgICAgICAgIGNvbnRleHQsXHJcbiAgICAgICAgfSwgKHJlcykgPT4ge1xyXG4gICAgICAgICAgICBsZXQgeyByYXdFdmVudHMgfSA9IHJlcztcclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZXZlbnRTb3VyY2VTdWNjZXNzKSB7XHJcbiAgICAgICAgICAgICAgICByYXdFdmVudHMgPSBvcHRpb25zLmV2ZW50U291cmNlU3VjY2Vzcy5jYWxsKGNhbGVuZGFyQXBpLCByYXdFdmVudHMsIHJlcy5yZXNwb25zZSkgfHwgcmF3RXZlbnRzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChldmVudFNvdXJjZS5zdWNjZXNzKSB7XHJcbiAgICAgICAgICAgICAgICByYXdFdmVudHMgPSBldmVudFNvdXJjZS5zdWNjZXNzLmNhbGwoY2FsZW5kYXJBcGksIHJhd0V2ZW50cywgcmVzLnJlc3BvbnNlKSB8fCByYXdFdmVudHM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29udGV4dC5kaXNwYXRjaCh7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiAnUkVDRUlWRV9FVkVOVFMnLFxyXG4gICAgICAgICAgICAgICAgc291cmNlSWQ6IGV2ZW50U291cmNlLnNvdXJjZUlkLFxyXG4gICAgICAgICAgICAgICAgZmV0Y2hJZCxcclxuICAgICAgICAgICAgICAgIGZldGNoUmFuZ2UsXHJcbiAgICAgICAgICAgICAgICByYXdFdmVudHMsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sIChlcnJvcikgPT4ge1xyXG4gICAgICAgICAgICBsZXQgZXJyb3JIYW5kbGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmV2ZW50U291cmNlRmFpbHVyZSkge1xyXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5ldmVudFNvdXJjZUZhaWx1cmUuY2FsbChjYWxlbmRhckFwaSwgZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgZXJyb3JIYW5kbGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZXZlbnRTb3VyY2UuZmFpbHVyZSkge1xyXG4gICAgICAgICAgICAgICAgZXZlbnRTb3VyY2UuZmFpbHVyZShlcnJvcik7XHJcbiAgICAgICAgICAgICAgICBlcnJvckhhbmRsZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghZXJyb3JIYW5kbGVkKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oZXJyb3IubWVzc2FnZSwgZXJyb3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnRleHQuZGlzcGF0Y2goe1xyXG4gICAgICAgICAgICAgICAgdHlwZTogJ1JFQ0VJVkVfRVZFTlRfRVJST1InLFxyXG4gICAgICAgICAgICAgICAgc291cmNlSWQ6IGV2ZW50U291cmNlLnNvdXJjZUlkLFxyXG4gICAgICAgICAgICAgICAgZmV0Y2hJZCxcclxuICAgICAgICAgICAgICAgIGZldGNoUmFuZ2UsXHJcbiAgICAgICAgICAgICAgICBlcnJvcixcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZXZlbnRTb3VyY2UpLCB7IGlzRmV0Y2hpbmc6IHRydWUsIGxhdGVzdEZldGNoSWQ6IGZldGNoSWQgfSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiByZWNlaXZlUmVzcG9uc2Uoc291cmNlSGFzaCwgc291cmNlSWQsIGZldGNoSWQsIGZldGNoUmFuZ2UpIHtcclxuICAgICAgICBsZXQgZXZlbnRTb3VyY2UgPSBzb3VyY2VIYXNoW3NvdXJjZUlkXTtcclxuICAgICAgICBpZiAoZXZlbnRTb3VyY2UgJiYgLy8gbm90IGFscmVhZHkgcmVtb3ZlZFxyXG4gICAgICAgICAgICBmZXRjaElkID09PSBldmVudFNvdXJjZS5sYXRlc3RGZXRjaElkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHNvdXJjZUhhc2gpLCB7IFtzb3VyY2VJZF06IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZXZlbnRTb3VyY2UpLCB7IGlzRmV0Y2hpbmc6IGZhbHNlLCBmZXRjaFJhbmdlIH0pIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc291cmNlSGFzaDtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGV4Y2x1ZGVTdGF0aWNTb3VyY2VzKGV2ZW50U291cmNlcywgY29udGV4dCkge1xyXG4gICAgICAgIHJldHVybiBmaWx0ZXJIYXNoKGV2ZW50U291cmNlcywgKGV2ZW50U291cmNlKSA9PiBkb2VzU291cmNlTmVlZFJhbmdlKGV2ZW50U291cmNlLCBjb250ZXh0KSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBwYXJzZUluaXRpYWxTb3VyY2VzKHJhd09wdGlvbnMsIGNvbnRleHQpIHtcclxuICAgICAgICBsZXQgcmVmaW5lcnMgPSBidWlsZEV2ZW50U291cmNlUmVmaW5lcnMoY29udGV4dCk7XHJcbiAgICAgICAgbGV0IHJhd1NvdXJjZXMgPSBbXS5jb25jYXQocmF3T3B0aW9ucy5ldmVudFNvdXJjZXMgfHwgW10pO1xyXG4gICAgICAgIGxldCBzb3VyY2VzID0gW107IC8vIHBhcnNlZFxyXG4gICAgICAgIGlmIChyYXdPcHRpb25zLmluaXRpYWxFdmVudHMpIHtcclxuICAgICAgICAgICAgcmF3U291cmNlcy51bnNoaWZ0KHJhd09wdGlvbnMuaW5pdGlhbEV2ZW50cyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChyYXdPcHRpb25zLmV2ZW50cykge1xyXG4gICAgICAgICAgICByYXdTb3VyY2VzLnVuc2hpZnQocmF3T3B0aW9ucy5ldmVudHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGxldCByYXdTb3VyY2Ugb2YgcmF3U291cmNlcykge1xyXG4gICAgICAgICAgICBsZXQgc291cmNlID0gcGFyc2VFdmVudFNvdXJjZShyYXdTb3VyY2UsIGNvbnRleHQsIHJlZmluZXJzKTtcclxuICAgICAgICAgICAgaWYgKHNvdXJjZSkge1xyXG4gICAgICAgICAgICAgICAgc291cmNlcy5wdXNoKHNvdXJjZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHNvdXJjZXM7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBkb2VzU291cmNlTmVlZFJhbmdlKGV2ZW50U291cmNlLCBjb250ZXh0KSB7XHJcbiAgICAgICAgbGV0IGRlZnMgPSBjb250ZXh0LnBsdWdpbkhvb2tzLmV2ZW50U291cmNlRGVmcztcclxuICAgICAgICByZXR1cm4gIWRlZnNbZXZlbnRTb3VyY2Uuc291cmNlRGVmSWRdLmlnbm9yZVJhbmdlO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHJlZHVjZURhdGVTZWxlY3Rpb24oY3VycmVudFNlbGVjdGlvbiwgYWN0aW9uKSB7XHJcbiAgICAgICAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xyXG4gICAgICAgICAgICBjYXNlICdVTlNFTEVDVF9EQVRFUyc6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgY2FzZSAnU0VMRUNUX0RBVEVTJzpcclxuICAgICAgICAgICAgICAgIHJldHVybiBhY3Rpb24uc2VsZWN0aW9uO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRTZWxlY3Rpb247XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHJlZHVjZVNlbGVjdGVkRXZlbnQoY3VycmVudEluc3RhbmNlSWQsIGFjdGlvbikge1xyXG4gICAgICAgIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcclxuICAgICAgICAgICAgY2FzZSAnVU5TRUxFQ1RfRVZFTlQnOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICAgICAgICBjYXNlICdTRUxFQ1RfRVZFTlQnOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjdGlvbi5ldmVudEluc3RhbmNlSWQ7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY3VycmVudEluc3RhbmNlSWQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHJlZHVjZUV2ZW50RHJhZyhjdXJyZW50RHJhZywgYWN0aW9uKSB7XHJcbiAgICAgICAgbGV0IG5ld0RyYWc7XHJcbiAgICAgICAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xyXG4gICAgICAgICAgICBjYXNlICdVTlNFVF9FVkVOVF9EUkFHJzpcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICBjYXNlICdTRVRfRVZFTlRfRFJBRyc6XHJcbiAgICAgICAgICAgICAgICBuZXdEcmFnID0gYWN0aW9uLnN0YXRlO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICBhZmZlY3RlZEV2ZW50czogbmV3RHJhZy5hZmZlY3RlZEV2ZW50cyxcclxuICAgICAgICAgICAgICAgICAgICBtdXRhdGVkRXZlbnRzOiBuZXdEcmFnLm11dGF0ZWRFdmVudHMsXHJcbiAgICAgICAgICAgICAgICAgICAgaXNFdmVudDogbmV3RHJhZy5pc0V2ZW50LFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHJldHVybiBjdXJyZW50RHJhZztcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcmVkdWNlRXZlbnRSZXNpemUoY3VycmVudFJlc2l6ZSwgYWN0aW9uKSB7XHJcbiAgICAgICAgbGV0IG5ld1Jlc2l6ZTtcclxuICAgICAgICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgJ1VOU0VUX0VWRU5UX1JFU0laRSc6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgY2FzZSAnU0VUX0VWRU5UX1JFU0laRSc6XHJcbiAgICAgICAgICAgICAgICBuZXdSZXNpemUgPSBhY3Rpb24uc3RhdGU7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGFmZmVjdGVkRXZlbnRzOiBuZXdSZXNpemUuYWZmZWN0ZWRFdmVudHMsXHJcbiAgICAgICAgICAgICAgICAgICAgbXV0YXRlZEV2ZW50czogbmV3UmVzaXplLm11dGF0ZWRFdmVudHMsXHJcbiAgICAgICAgICAgICAgICAgICAgaXNFdmVudDogbmV3UmVzaXplLmlzRXZlbnQsXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRSZXNpemU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHBhcnNlVG9vbGJhcnMoY2FsZW5kYXJPcHRpb25zLCBjYWxlbmRhck9wdGlvbk92ZXJyaWRlcywgdGhlbWUsIHZpZXdTcGVjcywgY2FsZW5kYXJBcGkpIHtcclxuICAgICAgICBsZXQgaGVhZGVyID0gY2FsZW5kYXJPcHRpb25zLmhlYWRlclRvb2xiYXIgPyBwYXJzZVRvb2xiYXIoY2FsZW5kYXJPcHRpb25zLmhlYWRlclRvb2xiYXIsIGNhbGVuZGFyT3B0aW9ucywgY2FsZW5kYXJPcHRpb25PdmVycmlkZXMsIHRoZW1lLCB2aWV3U3BlY3MsIGNhbGVuZGFyQXBpKSA6IG51bGw7XHJcbiAgICAgICAgbGV0IGZvb3RlciA9IGNhbGVuZGFyT3B0aW9ucy5mb290ZXJUb29sYmFyID8gcGFyc2VUb29sYmFyKGNhbGVuZGFyT3B0aW9ucy5mb290ZXJUb29sYmFyLCBjYWxlbmRhck9wdGlvbnMsIGNhbGVuZGFyT3B0aW9uT3ZlcnJpZGVzLCB0aGVtZSwgdmlld1NwZWNzLCBjYWxlbmRhckFwaSkgOiBudWxsO1xyXG4gICAgICAgIHJldHVybiB7IGhlYWRlciwgZm9vdGVyIH07XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBwYXJzZVRvb2xiYXIoc2VjdGlvblN0ckhhc2gsIGNhbGVuZGFyT3B0aW9ucywgY2FsZW5kYXJPcHRpb25PdmVycmlkZXMsIHRoZW1lLCB2aWV3U3BlY3MsIGNhbGVuZGFyQXBpKSB7XHJcbiAgICAgICAgbGV0IHNlY3Rpb25XaWRnZXRzID0ge307XHJcbiAgICAgICAgbGV0IHZpZXdzV2l0aEJ1dHRvbnMgPSBbXTtcclxuICAgICAgICBsZXQgaGFzVGl0bGUgPSBmYWxzZTtcclxuICAgICAgICBmb3IgKGxldCBzZWN0aW9uTmFtZSBpbiBzZWN0aW9uU3RySGFzaCkge1xyXG4gICAgICAgICAgICBsZXQgc2VjdGlvblN0ciA9IHNlY3Rpb25TdHJIYXNoW3NlY3Rpb25OYW1lXTtcclxuICAgICAgICAgICAgbGV0IHNlY3Rpb25SZXMgPSBwYXJzZVNlY3Rpb24oc2VjdGlvblN0ciwgY2FsZW5kYXJPcHRpb25zLCBjYWxlbmRhck9wdGlvbk92ZXJyaWRlcywgdGhlbWUsIHZpZXdTcGVjcywgY2FsZW5kYXJBcGkpO1xyXG4gICAgICAgICAgICBzZWN0aW9uV2lkZ2V0c1tzZWN0aW9uTmFtZV0gPSBzZWN0aW9uUmVzLndpZGdldHM7XHJcbiAgICAgICAgICAgIHZpZXdzV2l0aEJ1dHRvbnMucHVzaCguLi5zZWN0aW9uUmVzLnZpZXdzV2l0aEJ1dHRvbnMpO1xyXG4gICAgICAgICAgICBoYXNUaXRsZSA9IGhhc1RpdGxlIHx8IHNlY3Rpb25SZXMuaGFzVGl0bGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7IHNlY3Rpb25XaWRnZXRzLCB2aWV3c1dpdGhCdXR0b25zLCBoYXNUaXRsZSB9O1xyXG4gICAgfVxyXG4gICAgLypcclxuICAgIEJBRDogcXVlcnlpbmcgaWNvbnMgYW5kIHRleHQgaGVyZS4gc2hvdWxkIGJlIGRvbmUgYXQgcmVuZGVyIHRpbWVcclxuICAgICovXHJcbiAgICBmdW5jdGlvbiBwYXJzZVNlY3Rpb24oc2VjdGlvblN0ciwgY2FsZW5kYXJPcHRpb25zLCAvLyBkZWZhdWx0cytvdmVycmlkZXMsIHRoZW4gcmVmaW5lZFxyXG4gICAgY2FsZW5kYXJPcHRpb25PdmVycmlkZXMsIC8vIG92ZXJyaWRlcyBvbmx5ISwgdW5yZWZpbmVkIDooXHJcbiAgICB0aGVtZSwgdmlld1NwZWNzLCBjYWxlbmRhckFwaSkge1xyXG4gICAgICAgIGxldCBpc1J0bCA9IGNhbGVuZGFyT3B0aW9ucy5kaXJlY3Rpb24gPT09ICdydGwnO1xyXG4gICAgICAgIGxldCBjYWxlbmRhckN1c3RvbUJ1dHRvbnMgPSBjYWxlbmRhck9wdGlvbnMuY3VzdG9tQnV0dG9ucyB8fCB7fTtcclxuICAgICAgICBsZXQgY2FsZW5kYXJCdXR0b25UZXh0T3ZlcnJpZGVzID0gY2FsZW5kYXJPcHRpb25PdmVycmlkZXMuYnV0dG9uVGV4dCB8fCB7fTtcclxuICAgICAgICBsZXQgY2FsZW5kYXJCdXR0b25UZXh0ID0gY2FsZW5kYXJPcHRpb25zLmJ1dHRvblRleHQgfHwge307XHJcbiAgICAgICAgbGV0IGNhbGVuZGFyQnV0dG9uSGludE92ZXJyaWRlcyA9IGNhbGVuZGFyT3B0aW9uT3ZlcnJpZGVzLmJ1dHRvbkhpbnRzIHx8IHt9O1xyXG4gICAgICAgIGxldCBjYWxlbmRhckJ1dHRvbkhpbnRzID0gY2FsZW5kYXJPcHRpb25zLmJ1dHRvbkhpbnRzIHx8IHt9O1xyXG4gICAgICAgIGxldCBzZWN0aW9uU3Vic3RycyA9IHNlY3Rpb25TdHIgPyBzZWN0aW9uU3RyLnNwbGl0KCcgJykgOiBbXTtcclxuICAgICAgICBsZXQgdmlld3NXaXRoQnV0dG9ucyA9IFtdO1xyXG4gICAgICAgIGxldCBoYXNUaXRsZSA9IGZhbHNlO1xyXG4gICAgICAgIGxldCB3aWRnZXRzID0gc2VjdGlvblN1YnN0cnMubWFwKChidXR0b25Hcm91cFN0cikgPT4gKGJ1dHRvbkdyb3VwU3RyLnNwbGl0KCcsJykubWFwKChidXR0b25OYW1lKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChidXR0b25OYW1lID09PSAndGl0bGUnKSB7XHJcbiAgICAgICAgICAgICAgICBoYXNUaXRsZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4geyBidXR0b25OYW1lIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IGN1c3RvbUJ1dHRvblByb3BzO1xyXG4gICAgICAgICAgICBsZXQgdmlld1NwZWM7XHJcbiAgICAgICAgICAgIGxldCBidXR0b25DbGljaztcclxuICAgICAgICAgICAgbGV0IGJ1dHRvbkljb247IC8vIG9ubHkgb25lIG9mIHRoZXNlIHdpbGwgYmUgc2V0XHJcbiAgICAgICAgICAgIGxldCBidXR0b25UZXh0OyAvLyBcIlxyXG4gICAgICAgICAgICBsZXQgYnV0dG9uSGludDtcclxuICAgICAgICAgICAgLy8gXiBmb3IgdGhlIHRpdGxlPVwiXCIgYXR0cmlidXRlLCBmb3IgYWNjZXNzaWJpbGl0eVxyXG4gICAgICAgICAgICBpZiAoKGN1c3RvbUJ1dHRvblByb3BzID0gY2FsZW5kYXJDdXN0b21CdXR0b25zW2J1dHRvbk5hbWVdKSkge1xyXG4gICAgICAgICAgICAgICAgYnV0dG9uQ2xpY2sgPSAoZXYpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY3VzdG9tQnV0dG9uUHJvcHMuY2xpY2spIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3VzdG9tQnV0dG9uUHJvcHMuY2xpY2suY2FsbChldi50YXJnZXQsIGV2LCBldi50YXJnZXQpOyAvLyBUT0RPOiB1c2UgQ2FsZW5kYXIgdGhpcyBjb250ZXh0P1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAoYnV0dG9uSWNvbiA9IHRoZW1lLmdldEN1c3RvbUJ1dHRvbkljb25DbGFzcyhjdXN0b21CdXR0b25Qcm9wcykpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgKGJ1dHRvbkljb24gPSB0aGVtZS5nZXRJY29uQ2xhc3MoYnV0dG9uTmFtZSwgaXNSdGwpKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgIChidXR0b25UZXh0ID0gY3VzdG9tQnV0dG9uUHJvcHMudGV4dCk7XHJcbiAgICAgICAgICAgICAgICBidXR0b25IaW50ID0gY3VzdG9tQnV0dG9uUHJvcHMuaGludCB8fCBjdXN0b21CdXR0b25Qcm9wcy50ZXh0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCh2aWV3U3BlYyA9IHZpZXdTcGVjc1tidXR0b25OYW1lXSkpIHtcclxuICAgICAgICAgICAgICAgIHZpZXdzV2l0aEJ1dHRvbnMucHVzaChidXR0b25OYW1lKTtcclxuICAgICAgICAgICAgICAgIGJ1dHRvbkNsaWNrID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbGVuZGFyQXBpLmNoYW5nZVZpZXcoYnV0dG9uTmFtZSk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgKGJ1dHRvblRleHQgPSB2aWV3U3BlYy5idXR0b25UZXh0T3ZlcnJpZGUpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgKGJ1dHRvbkljb24gPSB0aGVtZS5nZXRJY29uQ2xhc3MoYnV0dG9uTmFtZSwgaXNSdGwpKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgIChidXR0b25UZXh0ID0gdmlld1NwZWMuYnV0dG9uVGV4dERlZmF1bHQpO1xyXG4gICAgICAgICAgICAgICAgbGV0IHRleHRGYWxsYmFjayA9IHZpZXdTcGVjLmJ1dHRvblRleHRPdmVycmlkZSB8fFxyXG4gICAgICAgICAgICAgICAgICAgIHZpZXdTcGVjLmJ1dHRvblRleHREZWZhdWx0O1xyXG4gICAgICAgICAgICAgICAgYnV0dG9uSGludCA9IGZvcm1hdFdpdGhPcmRpbmFscyh2aWV3U3BlYy5idXR0b25UaXRsZU92ZXJyaWRlIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgdmlld1NwZWMuYnV0dG9uVGl0bGVEZWZhdWx0IHx8XHJcbiAgICAgICAgICAgICAgICAgICAgY2FsZW5kYXJPcHRpb25zLnZpZXdIaW50LCBbdGV4dEZhbGxiYWNrLCBidXR0b25OYW1lXSwgLy8gdmlldy1uYW1lID0gYnV0dG9uTmFtZVxyXG4gICAgICAgICAgICAgICAgdGV4dEZhbGxiYWNrKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjYWxlbmRhckFwaVtidXR0b25OYW1lXSkgeyAvLyBhIGNhbGVuZGFyQXBpIG1ldGhvZFxyXG4gICAgICAgICAgICAgICAgYnV0dG9uQ2xpY2sgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FsZW5kYXJBcGlbYnV0dG9uTmFtZV0oKTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAoYnV0dG9uVGV4dCA9IGNhbGVuZGFyQnV0dG9uVGV4dE92ZXJyaWRlc1tidXR0b25OYW1lXSkgfHxcclxuICAgICAgICAgICAgICAgICAgICAoYnV0dG9uSWNvbiA9IHRoZW1lLmdldEljb25DbGFzcyhidXR0b25OYW1lLCBpc1J0bCkpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgKGJ1dHRvblRleHQgPSBjYWxlbmRhckJ1dHRvblRleHRbYnV0dG9uTmFtZV0pOyAvLyBldmVyeXRoaW5nIGVsc2UgaXMgY29uc2lkZXJlZCBkZWZhdWx0XHJcbiAgICAgICAgICAgICAgICBpZiAoYnV0dG9uTmFtZSA9PT0gJ3ByZXZZZWFyJyB8fCBidXR0b25OYW1lID09PSAnbmV4dFllYXInKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHByZXZPck5leHQgPSBidXR0b25OYW1lID09PSAncHJldlllYXInID8gJ3ByZXYnIDogJ25leHQnO1xyXG4gICAgICAgICAgICAgICAgICAgIGJ1dHRvbkhpbnQgPSBmb3JtYXRXaXRoT3JkaW5hbHMoY2FsZW5kYXJCdXR0b25IaW50T3ZlcnJpZGVzW3ByZXZPck5leHRdIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGVuZGFyQnV0dG9uSGludHNbcHJldk9yTmV4dF0sIFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsZW5kYXJCdXR0b25UZXh0LnllYXIgfHwgJ3llYXInLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAneWVhcicsXHJcbiAgICAgICAgICAgICAgICAgICAgXSwgY2FsZW5kYXJCdXR0b25UZXh0W2J1dHRvbk5hbWVdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGJ1dHRvbkhpbnQgPSAobmF2VW5pdCkgPT4gZm9ybWF0V2l0aE9yZGluYWxzKGNhbGVuZGFyQnV0dG9uSGludE92ZXJyaWRlc1tidXR0b25OYW1lXSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxlbmRhckJ1dHRvbkhpbnRzW2J1dHRvbk5hbWVdLCBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGVuZGFyQnV0dG9uVGV4dFtuYXZVbml0XSB8fCBuYXZVbml0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBuYXZVbml0LFxyXG4gICAgICAgICAgICAgICAgICAgIF0sIGNhbGVuZGFyQnV0dG9uVGV4dFtidXR0b25OYW1lXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHsgYnV0dG9uTmFtZSwgYnV0dG9uQ2xpY2ssIGJ1dHRvbkljb24sIGJ1dHRvblRleHQsIGJ1dHRvbkhpbnQgfTtcclxuICAgICAgICB9KSkpO1xyXG4gICAgICAgIHJldHVybiB7IHdpZGdldHMsIHZpZXdzV2l0aEJ1dHRvbnMsIGhhc1RpdGxlIH07XHJcbiAgICB9XHJcblxyXG4gICAgLy8gYWx3YXlzIHJlcHJlc2VudHMgdGhlIGN1cnJlbnQgdmlldy4gb3RoZXJ3aXNlLCBpdCdkIG5lZWQgdG8gY2hhbmdlIHZhbHVlIGV2ZXJ5IHRpbWUgZGF0ZSBjaGFuZ2VzXHJcbiAgICBjbGFzcyBWaWV3SW1wbCB7XHJcbiAgICAgICAgY29uc3RydWN0b3IodHlwZSwgZ2V0Q3VycmVudERhdGEsIGRhdGVFbnYpIHtcclxuICAgICAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcclxuICAgICAgICAgICAgdGhpcy5nZXRDdXJyZW50RGF0YSA9IGdldEN1cnJlbnREYXRhO1xyXG4gICAgICAgICAgICB0aGlzLmRhdGVFbnYgPSBkYXRlRW52O1xyXG4gICAgICAgIH1cclxuICAgICAgICBnZXQgY2FsZW5kYXIoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEN1cnJlbnREYXRhKCkuY2FsZW5kYXJBcGk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGdldCB0aXRsZSgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudERhdGEoKS52aWV3VGl0bGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGdldCBhY3RpdmVTdGFydCgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0ZUVudi50b0RhdGUodGhpcy5nZXRDdXJyZW50RGF0YSgpLmRhdGVQcm9maWxlLmFjdGl2ZVJhbmdlLnN0YXJ0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZ2V0IGFjdGl2ZUVuZCgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0ZUVudi50b0RhdGUodGhpcy5nZXRDdXJyZW50RGF0YSgpLmRhdGVQcm9maWxlLmFjdGl2ZVJhbmdlLmVuZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGdldCBjdXJyZW50U3RhcnQoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGVFbnYudG9EYXRlKHRoaXMuZ2V0Q3VycmVudERhdGEoKS5kYXRlUHJvZmlsZS5jdXJyZW50UmFuZ2Uuc3RhcnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBnZXQgY3VycmVudEVuZCgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0ZUVudi50b0RhdGUodGhpcy5nZXRDdXJyZW50RGF0YSgpLmRhdGVQcm9maWxlLmN1cnJlbnRSYW5nZS5lbmQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBnZXRPcHRpb24obmFtZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRDdXJyZW50RGF0YSgpLm9wdGlvbnNbbmFtZV07IC8vIGFyZSB0aGUgdmlldy1zcGVjaWZpYyBvcHRpb25zXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGxldCBldmVudFNvdXJjZURlZiQyID0ge1xyXG4gICAgICAgIGlnbm9yZVJhbmdlOiB0cnVlLFxyXG4gICAgICAgIHBhcnNlTWV0YShyZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHJlZmluZWQuZXZlbnRzKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlZmluZWQuZXZlbnRzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZmV0Y2goYXJnLCBzdWNjZXNzQ2FsbGJhY2spIHtcclxuICAgICAgICAgICAgc3VjY2Vzc0NhbGxiYWNrKHtcclxuICAgICAgICAgICAgICAgIHJhd0V2ZW50czogYXJnLmV2ZW50U291cmNlLm1ldGEsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sXHJcbiAgICB9O1xyXG4gICAgY29uc3QgYXJyYXlFdmVudFNvdXJjZVBsdWdpbiA9IGNyZWF0ZVBsdWdpbih7XHJcbiAgICAgICAgbmFtZTogJ2FycmF5LWV2ZW50LXNvdXJjZScsXHJcbiAgICAgICAgZXZlbnRTb3VyY2VEZWZzOiBbZXZlbnRTb3VyY2VEZWYkMl0sXHJcbiAgICB9KTtcclxuXHJcbiAgICBsZXQgZXZlbnRTb3VyY2VEZWYkMSA9IHtcclxuICAgICAgICBwYXJzZU1ldGEocmVmaW5lZCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHJlZmluZWQuZXZlbnRzID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVmaW5lZC5ldmVudHM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBmZXRjaChhcmcsIHN1Y2Nlc3NDYWxsYmFjaywgZXJyb3JDYWxsYmFjaykge1xyXG4gICAgICAgICAgICBjb25zdCB7IGRhdGVFbnYgfSA9IGFyZy5jb250ZXh0O1xyXG4gICAgICAgICAgICBjb25zdCBmdW5jID0gYXJnLmV2ZW50U291cmNlLm1ldGE7XHJcbiAgICAgICAgICAgIHVucHJvbWlzaWZ5KGZ1bmMuYmluZChudWxsLCBidWlsZFJhbmdlQXBpV2l0aFRpbWVab25lKGFyZy5yYW5nZSwgZGF0ZUVudikpLCAocmF3RXZlbnRzKSA9PiBzdWNjZXNzQ2FsbGJhY2soeyByYXdFdmVudHMgfSksIGVycm9yQ2FsbGJhY2spO1xyXG4gICAgICAgIH0sXHJcbiAgICB9O1xyXG4gICAgY29uc3QgZnVuY0V2ZW50U291cmNlUGx1Z2luID0gY3JlYXRlUGx1Z2luKHtcclxuICAgICAgICBuYW1lOiAnZnVuYy1ldmVudC1zb3VyY2UnLFxyXG4gICAgICAgIGV2ZW50U291cmNlRGVmczogW2V2ZW50U291cmNlRGVmJDFdLFxyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3QgSlNPTl9GRUVEX0VWRU5UX1NPVVJDRV9SRUZJTkVSUyA9IHtcclxuICAgICAgICBtZXRob2Q6IFN0cmluZyxcclxuICAgICAgICBleHRyYVBhcmFtczogaWRlbnRpdHksXHJcbiAgICAgICAgc3RhcnRQYXJhbTogU3RyaW5nLFxyXG4gICAgICAgIGVuZFBhcmFtOiBTdHJpbmcsXHJcbiAgICAgICAgdGltZVpvbmVQYXJhbTogU3RyaW5nLFxyXG4gICAgfTtcclxuXHJcbiAgICBsZXQgZXZlbnRTb3VyY2VEZWYgPSB7XHJcbiAgICAgICAgcGFyc2VNZXRhKHJlZmluZWQpIHtcclxuICAgICAgICAgICAgaWYgKHJlZmluZWQudXJsICYmIChyZWZpbmVkLmZvcm1hdCA9PT0gJ2pzb24nIHx8ICFyZWZpbmVkLmZvcm1hdCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdXJsOiByZWZpbmVkLnVybCxcclxuICAgICAgICAgICAgICAgICAgICBmb3JtYXQ6ICdqc29uJyxcclxuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IChyZWZpbmVkLm1ldGhvZCB8fCAnR0VUJykudG9VcHBlckNhc2UoKSxcclxuICAgICAgICAgICAgICAgICAgICBleHRyYVBhcmFtczogcmVmaW5lZC5leHRyYVBhcmFtcyxcclxuICAgICAgICAgICAgICAgICAgICBzdGFydFBhcmFtOiByZWZpbmVkLnN0YXJ0UGFyYW0sXHJcbiAgICAgICAgICAgICAgICAgICAgZW5kUGFyYW06IHJlZmluZWQuZW5kUGFyYW0sXHJcbiAgICAgICAgICAgICAgICAgICAgdGltZVpvbmVQYXJhbTogcmVmaW5lZC50aW1lWm9uZVBhcmFtLFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGZldGNoKGFyZywgc3VjY2Vzc0NhbGxiYWNrLCBlcnJvckNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgbWV0YSB9ID0gYXJnLmV2ZW50U291cmNlO1xyXG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0UGFyYW1zID0gYnVpbGRSZXF1ZXN0UGFyYW1zKG1ldGEsIGFyZy5yYW5nZSwgYXJnLmNvbnRleHQpO1xyXG4gICAgICAgICAgICByZXF1ZXN0SnNvbihtZXRhLm1ldGhvZCwgbWV0YS51cmwsIHJlcXVlc3RQYXJhbXMpLnRoZW4oKFtyYXdFdmVudHMsIHJlc3BvbnNlXSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgc3VjY2Vzc0NhbGxiYWNrKHsgcmF3RXZlbnRzLCByZXNwb25zZSB9KTtcclxuICAgICAgICAgICAgfSwgZXJyb3JDYWxsYmFjayk7XHJcbiAgICAgICAgfSxcclxuICAgIH07XHJcbiAgICBjb25zdCBqc29uRmVlZEV2ZW50U291cmNlUGx1Z2luID0gY3JlYXRlUGx1Z2luKHtcclxuICAgICAgICBuYW1lOiAnanNvbi1ldmVudC1zb3VyY2UnLFxyXG4gICAgICAgIGV2ZW50U291cmNlUmVmaW5lcnM6IEpTT05fRkVFRF9FVkVOVF9TT1VSQ0VfUkVGSU5FUlMsXHJcbiAgICAgICAgZXZlbnRTb3VyY2VEZWZzOiBbZXZlbnRTb3VyY2VEZWZdLFxyXG4gICAgfSk7XHJcbiAgICBmdW5jdGlvbiBidWlsZFJlcXVlc3RQYXJhbXMobWV0YSwgcmFuZ2UsIGNvbnRleHQpIHtcclxuICAgICAgICBsZXQgeyBkYXRlRW52LCBvcHRpb25zIH0gPSBjb250ZXh0O1xyXG4gICAgICAgIGxldCBzdGFydFBhcmFtO1xyXG4gICAgICAgIGxldCBlbmRQYXJhbTtcclxuICAgICAgICBsZXQgdGltZVpvbmVQYXJhbTtcclxuICAgICAgICBsZXQgY3VzdG9tUmVxdWVzdFBhcmFtcztcclxuICAgICAgICBsZXQgcGFyYW1zID0ge307XHJcbiAgICAgICAgc3RhcnRQYXJhbSA9IG1ldGEuc3RhcnRQYXJhbTtcclxuICAgICAgICBpZiAoc3RhcnRQYXJhbSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHN0YXJ0UGFyYW0gPSBvcHRpb25zLnN0YXJ0UGFyYW07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVuZFBhcmFtID0gbWV0YS5lbmRQYXJhbTtcclxuICAgICAgICBpZiAoZW5kUGFyYW0gPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBlbmRQYXJhbSA9IG9wdGlvbnMuZW5kUGFyYW07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRpbWVab25lUGFyYW0gPSBtZXRhLnRpbWVab25lUGFyYW07XHJcbiAgICAgICAgaWYgKHRpbWVab25lUGFyYW0gPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aW1lWm9uZVBhcmFtID0gb3B0aW9ucy50aW1lWm9uZVBhcmFtO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyByZXRyaWV2ZSBhbnkgb3V0Ym91bmQgR0VUL1BPU1QgZGF0YSBmcm9tIHRoZSBvcHRpb25zXHJcbiAgICAgICAgaWYgKHR5cGVvZiBtZXRhLmV4dHJhUGFyYW1zID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIC8vIHN1cHBsaWVkIGFzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEga2V5L3ZhbHVlIG9iamVjdFxyXG4gICAgICAgICAgICBjdXN0b21SZXF1ZXN0UGFyYW1zID0gbWV0YS5leHRyYVBhcmFtcygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gcHJvYmFibHkgc3VwcGxpZWQgYXMgYSBzdHJhaWdodCBrZXkvdmFsdWUgb2JqZWN0XHJcbiAgICAgICAgICAgIGN1c3RvbVJlcXVlc3RQYXJhbXMgPSBtZXRhLmV4dHJhUGFyYW1zIHx8IHt9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBPYmplY3QuYXNzaWduKHBhcmFtcywgY3VzdG9tUmVxdWVzdFBhcmFtcyk7XHJcbiAgICAgICAgcGFyYW1zW3N0YXJ0UGFyYW1dID0gZGF0ZUVudi5mb3JtYXRJc28ocmFuZ2Uuc3RhcnQpO1xyXG4gICAgICAgIHBhcmFtc1tlbmRQYXJhbV0gPSBkYXRlRW52LmZvcm1hdElzbyhyYW5nZS5lbmQpO1xyXG4gICAgICAgIGlmIChkYXRlRW52LnRpbWVab25lICE9PSAnbG9jYWwnKSB7XHJcbiAgICAgICAgICAgIHBhcmFtc1t0aW1lWm9uZVBhcmFtXSA9IGRhdGVFbnYudGltZVpvbmU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwYXJhbXM7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgU0lNUExFX1JFQ1VSUklOR19SRUZJTkVSUyA9IHtcclxuICAgICAgICBkYXlzT2ZXZWVrOiBpZGVudGl0eSxcclxuICAgICAgICBzdGFydFRpbWU6IGNyZWF0ZUR1cmF0aW9uLFxyXG4gICAgICAgIGVuZFRpbWU6IGNyZWF0ZUR1cmF0aW9uLFxyXG4gICAgICAgIGR1cmF0aW9uOiBjcmVhdGVEdXJhdGlvbixcclxuICAgICAgICBzdGFydFJlY3VyOiBpZGVudGl0eSxcclxuICAgICAgICBlbmRSZWN1cjogaWRlbnRpdHksXHJcbiAgICB9O1xyXG5cclxuICAgIGxldCByZWN1cnJpbmcgPSB7XHJcbiAgICAgICAgcGFyc2UocmVmaW5lZCwgZGF0ZUVudikge1xyXG4gICAgICAgICAgICBpZiAocmVmaW5lZC5kYXlzT2ZXZWVrIHx8IHJlZmluZWQuc3RhcnRUaW1lIHx8IHJlZmluZWQuZW5kVGltZSB8fCByZWZpbmVkLnN0YXJ0UmVjdXIgfHwgcmVmaW5lZC5lbmRSZWN1cikge1xyXG4gICAgICAgICAgICAgICAgbGV0IHJlY3VycmluZ0RhdGEgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGF5c09mV2VlazogcmVmaW5lZC5kYXlzT2ZXZWVrIHx8IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRUaW1lOiByZWZpbmVkLnN0YXJ0VGltZSB8fCBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgIGVuZFRpbWU6IHJlZmluZWQuZW5kVGltZSB8fCBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0UmVjdXI6IHJlZmluZWQuc3RhcnRSZWN1ciA/IGRhdGVFbnYuY3JlYXRlTWFya2VyKHJlZmluZWQuc3RhcnRSZWN1cikgOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgIGVuZFJlY3VyOiByZWZpbmVkLmVuZFJlY3VyID8gZGF0ZUVudi5jcmVhdGVNYXJrZXIocmVmaW5lZC5lbmRSZWN1cikgOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIGxldCBkdXJhdGlvbjtcclxuICAgICAgICAgICAgICAgIGlmIChyZWZpbmVkLmR1cmF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZHVyYXRpb24gPSByZWZpbmVkLmR1cmF0aW9uO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCFkdXJhdGlvbiAmJiByZWZpbmVkLnN0YXJ0VGltZSAmJiByZWZpbmVkLmVuZFRpbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbiA9IHN1YnRyYWN0RHVyYXRpb25zKHJlZmluZWQuZW5kVGltZSwgcmVmaW5lZC5zdGFydFRpbWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICBhbGxEYXlHdWVzczogQm9vbGVhbighcmVmaW5lZC5zdGFydFRpbWUgJiYgIXJlZmluZWQuZW5kVGltZSksXHJcbiAgICAgICAgICAgICAgICAgICAgZHVyYXRpb24sXHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZURhdGE6IHJlY3VycmluZ0RhdGEsIC8vIGRvZXNuJ3QgbmVlZCBlbmRUaW1lIGFueW1vcmUgYnV0IG9oIHdlbGxcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBleHBhbmQodHlwZURhdGEsIGZyYW1pbmdSYW5nZSwgZGF0ZUVudikge1xyXG4gICAgICAgICAgICBsZXQgY2xpcHBlZEZyYW1pbmdSYW5nZSA9IGludGVyc2VjdFJhbmdlcyhmcmFtaW5nUmFuZ2UsIHsgc3RhcnQ6IHR5cGVEYXRhLnN0YXJ0UmVjdXIsIGVuZDogdHlwZURhdGEuZW5kUmVjdXIgfSk7XHJcbiAgICAgICAgICAgIGlmIChjbGlwcGVkRnJhbWluZ1JhbmdlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZXhwYW5kUmFuZ2VzKHR5cGVEYXRhLmRheXNPZldlZWssIHR5cGVEYXRhLnN0YXJ0VGltZSwgY2xpcHBlZEZyYW1pbmdSYW5nZSwgZGF0ZUVudik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgIH0sXHJcbiAgICB9O1xyXG4gICAgY29uc3Qgc2ltcGxlUmVjdXJyaW5nRXZlbnRzUGx1Z2luID0gY3JlYXRlUGx1Z2luKHtcclxuICAgICAgICBuYW1lOiAnc2ltcGxlLXJlY3VycmluZy1ldmVudCcsXHJcbiAgICAgICAgcmVjdXJyaW5nVHlwZXM6IFtyZWN1cnJpbmddLFxyXG4gICAgICAgIGV2ZW50UmVmaW5lcnM6IFNJTVBMRV9SRUNVUlJJTkdfUkVGSU5FUlMsXHJcbiAgICB9KTtcclxuICAgIGZ1bmN0aW9uIGV4cGFuZFJhbmdlcyhkYXlzT2ZXZWVrLCBzdGFydFRpbWUsIGZyYW1pbmdSYW5nZSwgZGF0ZUVudikge1xyXG4gICAgICAgIGxldCBkb3dIYXNoID0gZGF5c09mV2VlayA/IGFycmF5VG9IYXNoKGRheXNPZldlZWspIDogbnVsbDtcclxuICAgICAgICBsZXQgZGF5TWFya2VyID0gc3RhcnRPZkRheShmcmFtaW5nUmFuZ2Uuc3RhcnQpO1xyXG4gICAgICAgIGxldCBlbmRNYXJrZXIgPSBmcmFtaW5nUmFuZ2UuZW5kO1xyXG4gICAgICAgIGxldCBpbnN0YW5jZVN0YXJ0cyA9IFtdO1xyXG4gICAgICAgIHdoaWxlIChkYXlNYXJrZXIgPCBlbmRNYXJrZXIpIHtcclxuICAgICAgICAgICAgbGV0IGluc3RhbmNlU3RhcnQ7XHJcbiAgICAgICAgICAgIC8vIGlmIGV2ZXJ5ZGF5LCBvciB0aGlzIHBhcnRpY3VsYXIgZGF5LW9mLXdlZWtcclxuICAgICAgICAgICAgaWYgKCFkb3dIYXNoIHx8IGRvd0hhc2hbZGF5TWFya2VyLmdldFVUQ0RheSgpXSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHN0YXJ0VGltZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlU3RhcnQgPSBkYXRlRW52LmFkZChkYXlNYXJrZXIsIHN0YXJ0VGltZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZVN0YXJ0ID0gZGF5TWFya2VyO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaW5zdGFuY2VTdGFydHMucHVzaChpbnN0YW5jZVN0YXJ0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBkYXlNYXJrZXIgPSBhZGREYXlzKGRheU1hcmtlciwgMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBpbnN0YW5jZVN0YXJ0cztcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBjaGFuZ2VIYW5kbGVyUGx1Z2luID0gY3JlYXRlUGx1Z2luKHtcclxuICAgICAgICBuYW1lOiAnY2hhbmdlLWhhbmRsZXInLFxyXG4gICAgICAgIG9wdGlvbkNoYW5nZUhhbmRsZXJzOiB7XHJcbiAgICAgICAgICAgIGV2ZW50cyhldmVudHMsIGNvbnRleHQpIHtcclxuICAgICAgICAgICAgICAgIGhhbmRsZUV2ZW50U291cmNlcyhbZXZlbnRzXSwgY29udGV4dCk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGV2ZW50U291cmNlczogaGFuZGxlRXZlbnRTb3VyY2VzLFxyXG4gICAgICAgIH0sXHJcbiAgICB9KTtcclxuICAgIC8qXHJcbiAgICBCVUc6IGlmIGBldmVudGAgd2FzIHN1cHBsaWVkLCBhbGwgcHJldmlvdXNseS1naXZlbiBgZXZlbnRTb3VyY2VzYCB3aWxsIGJlIHdpcGVkIG91dFxyXG4gICAgKi9cclxuICAgIGZ1bmN0aW9uIGhhbmRsZUV2ZW50U291cmNlcyhpbnB1dHMsIGNvbnRleHQpIHtcclxuICAgICAgICBsZXQgdW5mb3VuZFNvdXJjZXMgPSBoYXNoVmFsdWVzVG9BcnJheShjb250ZXh0LmdldEN1cnJlbnREYXRhKCkuZXZlbnRTb3VyY2VzKTtcclxuICAgICAgICBpZiAodW5mb3VuZFNvdXJjZXMubGVuZ3RoID09PSAxICYmXHJcbiAgICAgICAgICAgIGlucHV0cy5sZW5ndGggPT09IDEgJiZcclxuICAgICAgICAgICAgQXJyYXkuaXNBcnJheSh1bmZvdW5kU291cmNlc1swXS5fcmF3KSAmJlxyXG4gICAgICAgICAgICBBcnJheS5pc0FycmF5KGlucHV0c1swXSkpIHtcclxuICAgICAgICAgICAgY29udGV4dC5kaXNwYXRjaCh7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiAnUkVTRVRfUkFXX0VWRU5UUycsXHJcbiAgICAgICAgICAgICAgICBzb3VyY2VJZDogdW5mb3VuZFNvdXJjZXNbMF0uc291cmNlSWQsXHJcbiAgICAgICAgICAgICAgICByYXdFdmVudHM6IGlucHV0c1swXSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IG5ld0lucHV0cyA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IGlucHV0IG9mIGlucHV0cykge1xyXG4gICAgICAgICAgICBsZXQgaW5wdXRGb3VuZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHVuZm91bmRTb3VyY2VzLmxlbmd0aDsgaSArPSAxKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodW5mb3VuZFNvdXJjZXNbaV0uX3JhdyA9PT0gaW5wdXQpIHtcclxuICAgICAgICAgICAgICAgICAgICB1bmZvdW5kU291cmNlcy5zcGxpY2UoaSwgMSk7IC8vIGRlbGV0ZVxyXG4gICAgICAgICAgICAgICAgICAgIGlucHV0Rm91bmQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghaW5wdXRGb3VuZCkge1xyXG4gICAgICAgICAgICAgICAgbmV3SW5wdXRzLnB1c2goaW5wdXQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAobGV0IHVuZm91bmRTb3VyY2Ugb2YgdW5mb3VuZFNvdXJjZXMpIHtcclxuICAgICAgICAgICAgY29udGV4dC5kaXNwYXRjaCh7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiAnUkVNT1ZFX0VWRU5UX1NPVVJDRScsXHJcbiAgICAgICAgICAgICAgICBzb3VyY2VJZDogdW5mb3VuZFNvdXJjZS5zb3VyY2VJZCxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAobGV0IG5ld0lucHV0IG9mIG5ld0lucHV0cykge1xyXG4gICAgICAgICAgICBjb250ZXh0LmNhbGVuZGFyQXBpLmFkZEV2ZW50U291cmNlKG5ld0lucHV0KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaGFuZGxlRGF0ZVByb2ZpbGUoZGF0ZVByb2ZpbGUsIGNvbnRleHQpIHtcclxuICAgICAgICBjb250ZXh0LmVtaXR0ZXIudHJpZ2dlcignZGF0ZXNTZXQnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGJ1aWxkUmFuZ2VBcGlXaXRoVGltZVpvbmUoZGF0ZVByb2ZpbGUuYWN0aXZlUmFuZ2UsIGNvbnRleHQuZGF0ZUVudikpLCB7IHZpZXc6IGNvbnRleHQudmlld0FwaSB9KSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaGFuZGxlRXZlbnRTdG9yZShldmVudFN0b3JlLCBjb250ZXh0KSB7XHJcbiAgICAgICAgbGV0IHsgZW1pdHRlciB9ID0gY29udGV4dDtcclxuICAgICAgICBpZiAoZW1pdHRlci5oYXNIYW5kbGVycygnZXZlbnRzU2V0JykpIHtcclxuICAgICAgICAgICAgZW1pdHRlci50cmlnZ2VyKCdldmVudHNTZXQnLCBidWlsZEV2ZW50QXBpcyhldmVudFN0b3JlLCBjb250ZXh0KSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qXHJcbiAgICB0aGlzIGFycmF5IGlzIGV4cG9zZWQgb24gdGhlIHJvb3QgbmFtZXNwYWNlIHNvIHRoYXQgVU1EIHBsdWdpbnMgY2FuIGFkZCB0byBpdC5cclxuICAgIHNlZSB0aGUgcm9sbHVwLWJ1bmRsZXMgc2NyaXB0LlxyXG4gICAgKi9cclxuICAgIGNvbnN0IGdsb2JhbFBsdWdpbnMgPSBbXHJcbiAgICAgICAgYXJyYXlFdmVudFNvdXJjZVBsdWdpbixcclxuICAgICAgICBmdW5jRXZlbnRTb3VyY2VQbHVnaW4sXHJcbiAgICAgICAganNvbkZlZWRFdmVudFNvdXJjZVBsdWdpbixcclxuICAgICAgICBzaW1wbGVSZWN1cnJpbmdFdmVudHNQbHVnaW4sXHJcbiAgICAgICAgY2hhbmdlSGFuZGxlclBsdWdpbixcclxuICAgICAgICBjcmVhdGVQbHVnaW4oe1xyXG4gICAgICAgICAgICBuYW1lOiAnbWlzYycsXHJcbiAgICAgICAgICAgIGlzTG9hZGluZ0Z1bmNzOiBbXHJcbiAgICAgICAgICAgICAgICAoc3RhdGUpID0+IGNvbXB1dGVFdmVudFNvdXJjZXNMb2FkaW5nKHN0YXRlLmV2ZW50U291cmNlcyksXHJcbiAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgIHByb3BTZXRIYW5kbGVyczoge1xyXG4gICAgICAgICAgICAgICAgZGF0ZVByb2ZpbGU6IGhhbmRsZURhdGVQcm9maWxlLFxyXG4gICAgICAgICAgICAgICAgZXZlbnRTdG9yZTogaGFuZGxlRXZlbnRTdG9yZSxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9KSxcclxuICAgIF07XHJcblxyXG4gICAgY2xhc3MgVGFza1J1bm5lciB7XHJcbiAgICAgICAgY29uc3RydWN0b3IocnVuVGFza09wdGlvbiwgZHJhaW5lZE9wdGlvbikge1xyXG4gICAgICAgICAgICB0aGlzLnJ1blRhc2tPcHRpb24gPSBydW5UYXNrT3B0aW9uO1xyXG4gICAgICAgICAgICB0aGlzLmRyYWluZWRPcHRpb24gPSBkcmFpbmVkT3B0aW9uO1xyXG4gICAgICAgICAgICB0aGlzLnF1ZXVlID0gW107XHJcbiAgICAgICAgICAgIHRoaXMuZGVsYXllZFJ1bm5lciA9IG5ldyBEZWxheWVkUnVubmVyKHRoaXMuZHJhaW4uYmluZCh0aGlzKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlcXVlc3QodGFzaywgZGVsYXkpIHtcclxuICAgICAgICAgICAgdGhpcy5xdWV1ZS5wdXNoKHRhc2spO1xyXG4gICAgICAgICAgICB0aGlzLmRlbGF5ZWRSdW5uZXIucmVxdWVzdChkZWxheSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHBhdXNlKHNjb3BlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGVsYXllZFJ1bm5lci5wYXVzZShzY29wZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlc3VtZShzY29wZSwgZm9yY2UpIHtcclxuICAgICAgICAgICAgdGhpcy5kZWxheWVkUnVubmVyLnJlc3VtZShzY29wZSwgZm9yY2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkcmFpbigpIHtcclxuICAgICAgICAgICAgbGV0IHsgcXVldWUgfSA9IHRoaXM7XHJcbiAgICAgICAgICAgIHdoaWxlIChxdWV1ZS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIGxldCBjb21wbGV0ZWRUYXNrcyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgbGV0IHRhc2s7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoKHRhc2sgPSBxdWV1ZS5zaGlmdCgpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucnVuVGFzayh0YXNrKTtcclxuICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZWRUYXNrcy5wdXNoKHRhc2spO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5kcmFpbmVkKGNvbXBsZXRlZFRhc2tzKTtcclxuICAgICAgICAgICAgfSAvLyBrZWVwIGdvaW5nLCBpbiBjYXNlIG5ldyB0YXNrcyB3ZXJlIGFkZGVkIGluIHRoZSBkcmFpbmVkIGhhbmRsZXJcclxuICAgICAgICB9XHJcbiAgICAgICAgcnVuVGFzayh0YXNrKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnJ1blRhc2tPcHRpb24pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucnVuVGFza09wdGlvbih0YXNrKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBkcmFpbmVkKGNvbXBsZXRlZFRhc2tzKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmRyYWluZWRPcHRpb24pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZHJhaW5lZE9wdGlvbihjb21wbGV0ZWRUYXNrcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ29tcHV0ZXMgd2hhdCB0aGUgdGl0bGUgYXQgdGhlIHRvcCBvZiB0aGUgY2FsZW5kYXJBcGkgc2hvdWxkIGJlIGZvciB0aGlzIHZpZXdcclxuICAgIGZ1bmN0aW9uIGJ1aWxkVGl0bGUoZGF0ZVByb2ZpbGUsIHZpZXdPcHRpb25zLCBkYXRlRW52KSB7XHJcbiAgICAgICAgbGV0IHJhbmdlO1xyXG4gICAgICAgIC8vIGZvciB2aWV3cyB0aGF0IHNwYW4gYSBsYXJnZSB1bml0IG9mIHRpbWUsIHNob3cgdGhlIHByb3BlciBpbnRlcnZhbCwgaWdub3Jpbmcgc3RyYXkgZGF5cyBiZWZvcmUgYW5kIGFmdGVyXHJcbiAgICAgICAgaWYgKC9eKHllYXJ8bW9udGgpJC8udGVzdChkYXRlUHJvZmlsZS5jdXJyZW50UmFuZ2VVbml0KSkge1xyXG4gICAgICAgICAgICByYW5nZSA9IGRhdGVQcm9maWxlLmN1cnJlbnRSYW5nZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7IC8vIGZvciBkYXkgdW5pdHMgb3Igc21hbGxlciwgdXNlIHRoZSBhY3R1YWwgZGF5IHJhbmdlXHJcbiAgICAgICAgICAgIHJhbmdlID0gZGF0ZVByb2ZpbGUuYWN0aXZlUmFuZ2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkYXRlRW52LmZvcm1hdFJhbmdlKHJhbmdlLnN0YXJ0LCByYW5nZS5lbmQsIGNyZWF0ZUZvcm1hdHRlcih2aWV3T3B0aW9ucy50aXRsZUZvcm1hdCB8fCBidWlsZFRpdGxlRm9ybWF0KGRhdGVQcm9maWxlKSksIHtcclxuICAgICAgICAgICAgaXNFbmRFeGNsdXNpdmU6IGRhdGVQcm9maWxlLmlzUmFuZ2VBbGxEYXksXHJcbiAgICAgICAgICAgIGRlZmF1bHRTZXBhcmF0b3I6IHZpZXdPcHRpb25zLnRpdGxlUmFuZ2VTZXBhcmF0b3IsXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvLyBHZW5lcmF0ZXMgdGhlIGZvcm1hdCBzdHJpbmcgdGhhdCBzaG91bGQgYmUgdXNlZCB0byBnZW5lcmF0ZSB0aGUgdGl0bGUgZm9yIHRoZSBjdXJyZW50IGRhdGUgcmFuZ2UuXHJcbiAgICAvLyBBdHRlbXB0cyB0byBjb21wdXRlIHRoZSBtb3N0IGFwcHJvcHJpYXRlIGZvcm1hdCBpZiBub3QgZXhwbGljaXRseSBzcGVjaWZpZWQgd2l0aCBgdGl0bGVGb3JtYXRgLlxyXG4gICAgZnVuY3Rpb24gYnVpbGRUaXRsZUZvcm1hdChkYXRlUHJvZmlsZSkge1xyXG4gICAgICAgIGxldCB7IGN1cnJlbnRSYW5nZVVuaXQgfSA9IGRhdGVQcm9maWxlO1xyXG4gICAgICAgIGlmIChjdXJyZW50UmFuZ2VVbml0ID09PSAneWVhcicpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHsgeWVhcjogJ251bWVyaWMnIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjdXJyZW50UmFuZ2VVbml0ID09PSAnbW9udGgnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7IHllYXI6ICdudW1lcmljJywgbW9udGg6ICdsb25nJyB9OyAvLyBsaWtlIFwiU2VwdGVtYmVyIDIwMTRcIlxyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgZGF5cyA9IGRpZmZXaG9sZURheXMoZGF0ZVByb2ZpbGUuY3VycmVudFJhbmdlLnN0YXJ0LCBkYXRlUHJvZmlsZS5jdXJyZW50UmFuZ2UuZW5kKTtcclxuICAgICAgICBpZiAoZGF5cyAhPT0gbnVsbCAmJiBkYXlzID4gMSkge1xyXG4gICAgICAgICAgICAvLyBtdWx0aS1kYXkgcmFuZ2UuIHNob3J0ZXIsIGxpa2UgXCJTZXAgOSAtIDEwIDIwMTRcIlxyXG4gICAgICAgICAgICByZXR1cm4geyB5ZWFyOiAnbnVtZXJpYycsIG1vbnRoOiAnc2hvcnQnLCBkYXk6ICdudW1lcmljJyB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBvbmUgZGF5LiBsb25nZXIsIGxpa2UgXCJTZXB0ZW1iZXIgOSAyMDE0XCJcclxuICAgICAgICByZXR1cm4geyB5ZWFyOiAnbnVtZXJpYycsIG1vbnRoOiAnbG9uZycsIGRheTogJ251bWVyaWMnIH07XHJcbiAgICB9XHJcblxyXG4gICAgLy8gaW4gZnV0dXJlIHJlZmFjdG9yLCBkbyB0aGUgcmVkdXgtc3R5bGUgZnVuY3Rpb24oc3RhdGU9aW5pdGlhbCkgZm9yIGluaXRpYWwtc3RhdGVcclxuICAgIC8vIGFsc28sIHdoYXRldmVyIGlzIGhhcHBlbmluZyBpbiBjb25zdHJ1Y3RvciwgaGF2ZSBpdCBoYXBwZW4gaW4gYWN0aW9uIHF1ZXVlIHRvb1xyXG4gICAgY2xhc3MgQ2FsZW5kYXJEYXRhTWFuYWdlciB7XHJcbiAgICAgICAgY29uc3RydWN0b3IocHJvcHMpIHtcclxuICAgICAgICAgICAgdGhpcy5jb21wdXRlQ3VycmVudFZpZXdEYXRhID0gbWVtb2l6ZSh0aGlzLl9jb21wdXRlQ3VycmVudFZpZXdEYXRhKTtcclxuICAgICAgICAgICAgdGhpcy5vcmdhbml6ZVJhd0xvY2FsZXMgPSBtZW1vaXplKG9yZ2FuaXplUmF3TG9jYWxlcyk7XHJcbiAgICAgICAgICAgIHRoaXMuYnVpbGRMb2NhbGUgPSBtZW1vaXplKGJ1aWxkTG9jYWxlKTtcclxuICAgICAgICAgICAgdGhpcy5idWlsZFBsdWdpbkhvb2tzID0gYnVpbGRCdWlsZFBsdWdpbkhvb2tzKCk7XHJcbiAgICAgICAgICAgIHRoaXMuYnVpbGREYXRlRW52ID0gbWVtb2l6ZShidWlsZERhdGVFbnYkMSk7XHJcbiAgICAgICAgICAgIHRoaXMuYnVpbGRUaGVtZSA9IG1lbW9pemUoYnVpbGRUaGVtZSk7XHJcbiAgICAgICAgICAgIHRoaXMucGFyc2VUb29sYmFycyA9IG1lbW9pemUocGFyc2VUb29sYmFycyk7XHJcbiAgICAgICAgICAgIHRoaXMuYnVpbGRWaWV3U3BlY3MgPSBtZW1vaXplKGJ1aWxkVmlld1NwZWNzKTtcclxuICAgICAgICAgICAgdGhpcy5idWlsZERhdGVQcm9maWxlR2VuZXJhdG9yID0gbWVtb2l6ZU9iakFyZyhidWlsZERhdGVQcm9maWxlR2VuZXJhdG9yKTtcclxuICAgICAgICAgICAgdGhpcy5idWlsZFZpZXdBcGkgPSBtZW1vaXplKGJ1aWxkVmlld0FwaSk7XHJcbiAgICAgICAgICAgIHRoaXMuYnVpbGRWaWV3VWlQcm9wcyA9IG1lbW9pemVPYmpBcmcoYnVpbGRWaWV3VWlQcm9wcyk7XHJcbiAgICAgICAgICAgIHRoaXMuYnVpbGRFdmVudFVpQnlTb3VyY2UgPSBtZW1vaXplKGJ1aWxkRXZlbnRVaUJ5U291cmNlLCBpc1Byb3BzRXF1YWwpO1xyXG4gICAgICAgICAgICB0aGlzLmJ1aWxkRXZlbnRVaUJhc2VzID0gbWVtb2l6ZShidWlsZEV2ZW50VWlCYXNlcyk7XHJcbiAgICAgICAgICAgIHRoaXMucGFyc2VDb250ZXh0QnVzaW5lc3NIb3VycyA9IG1lbW9pemVPYmpBcmcocGFyc2VDb250ZXh0QnVzaW5lc3NIb3Vycyk7XHJcbiAgICAgICAgICAgIHRoaXMuYnVpbGRUaXRsZSA9IG1lbW9pemUoYnVpbGRUaXRsZSk7XHJcbiAgICAgICAgICAgIHRoaXMuZW1pdHRlciA9IG5ldyBFbWl0dGVyKCk7XHJcbiAgICAgICAgICAgIHRoaXMuYWN0aW9uUnVubmVyID0gbmV3IFRhc2tSdW5uZXIodGhpcy5faGFuZGxlQWN0aW9uLmJpbmQodGhpcyksIHRoaXMudXBkYXRlRGF0YS5iaW5kKHRoaXMpKTtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50Q2FsZW5kYXJPcHRpb25zSW5wdXQgPSB7fTtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50Q2FsZW5kYXJPcHRpb25zUmVmaW5lZCA9IHt9O1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRWaWV3T3B0aW9uc0lucHV0ID0ge307XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFZpZXdPcHRpb25zUmVmaW5lZCA9IHt9O1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRDYWxlbmRhck9wdGlvbnNSZWZpbmVycyA9IHt9O1xyXG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNGb3JSZWZpbmluZyA9IFtdO1xyXG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNGb3JIYW5kbGluZyA9IFtdO1xyXG4gICAgICAgICAgICB0aGlzLmdldEN1cnJlbnREYXRhID0gKCkgPT4gdGhpcy5kYXRhO1xyXG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoID0gKGFjdGlvbikgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hY3Rpb25SdW5uZXIucmVxdWVzdChhY3Rpb24pOyAvLyBwcm90ZWN0cyBhZ2FpbnN0IHJlY3Vyc2l2ZSBjYWxscyB0byBfaGFuZGxlQWN0aW9uXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHRoaXMucHJvcHMgPSBwcm9wcztcclxuICAgICAgICAgICAgdGhpcy5hY3Rpb25SdW5uZXIucGF1c2UoKTtcclxuICAgICAgICAgICAgbGV0IGR5bmFtaWNPcHRpb25PdmVycmlkZXMgPSB7fTtcclxuICAgICAgICAgICAgbGV0IG9wdGlvbnNEYXRhID0gdGhpcy5jb21wdXRlT3B0aW9uc0RhdGEocHJvcHMub3B0aW9uT3ZlcnJpZGVzLCBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzLCBwcm9wcy5jYWxlbmRhckFwaSk7XHJcbiAgICAgICAgICAgIGxldCBjdXJyZW50Vmlld1R5cGUgPSBvcHRpb25zRGF0YS5jYWxlbmRhck9wdGlvbnMuaW5pdGlhbFZpZXcgfHwgb3B0aW9uc0RhdGEucGx1Z2luSG9va3MuaW5pdGlhbFZpZXc7XHJcbiAgICAgICAgICAgIGxldCBjdXJyZW50Vmlld0RhdGEgPSB0aGlzLmNvbXB1dGVDdXJyZW50Vmlld0RhdGEoY3VycmVudFZpZXdUeXBlLCBvcHRpb25zRGF0YSwgcHJvcHMub3B0aW9uT3ZlcnJpZGVzLCBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzKTtcclxuICAgICAgICAgICAgLy8gd2lyZSB0aGluZ3MgdXBcclxuICAgICAgICAgICAgLy8gVE9ETzogbm90IERSWVxyXG4gICAgICAgICAgICBwcm9wcy5jYWxlbmRhckFwaS5jdXJyZW50RGF0YU1hbmFnZXIgPSB0aGlzO1xyXG4gICAgICAgICAgICB0aGlzLmVtaXR0ZXIuc2V0VGhpc0NvbnRleHQocHJvcHMuY2FsZW5kYXJBcGkpO1xyXG4gICAgICAgICAgICB0aGlzLmVtaXR0ZXIuc2V0T3B0aW9ucyhjdXJyZW50Vmlld0RhdGEub3B0aW9ucyk7XHJcbiAgICAgICAgICAgIGxldCBjdXJyZW50RGF0ZSA9IGdldEluaXRpYWxEYXRlKG9wdGlvbnNEYXRhLmNhbGVuZGFyT3B0aW9ucywgb3B0aW9uc0RhdGEuZGF0ZUVudik7XHJcbiAgICAgICAgICAgIGxldCBkYXRlUHJvZmlsZSA9IGN1cnJlbnRWaWV3RGF0YS5kYXRlUHJvZmlsZUdlbmVyYXRvci5idWlsZChjdXJyZW50RGF0ZSk7XHJcbiAgICAgICAgICAgIGlmICghcmFuZ2VDb250YWluc01hcmtlcihkYXRlUHJvZmlsZS5hY3RpdmVSYW5nZSwgY3VycmVudERhdGUpKSB7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50RGF0ZSA9IGRhdGVQcm9maWxlLmN1cnJlbnRSYW5nZS5zdGFydDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgY2FsZW5kYXJDb250ZXh0ID0ge1xyXG4gICAgICAgICAgICAgICAgZGF0ZUVudjogb3B0aW9uc0RhdGEuZGF0ZUVudixcclxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IG9wdGlvbnNEYXRhLmNhbGVuZGFyT3B0aW9ucyxcclxuICAgICAgICAgICAgICAgIHBsdWdpbkhvb2tzOiBvcHRpb25zRGF0YS5wbHVnaW5Ib29rcyxcclxuICAgICAgICAgICAgICAgIGNhbGVuZGFyQXBpOiBwcm9wcy5jYWxlbmRhckFwaSxcclxuICAgICAgICAgICAgICAgIGRpc3BhdGNoOiB0aGlzLmRpc3BhdGNoLFxyXG4gICAgICAgICAgICAgICAgZW1pdHRlcjogdGhpcy5lbWl0dGVyLFxyXG4gICAgICAgICAgICAgICAgZ2V0Q3VycmVudERhdGE6IHRoaXMuZ2V0Q3VycmVudERhdGEsXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8vIG5lZWRzIHRvIGJlIGFmdGVyIHNldFRoaXNDb250ZXh0XHJcbiAgICAgICAgICAgIGZvciAobGV0IGNhbGxiYWNrIG9mIG9wdGlvbnNEYXRhLnBsdWdpbkhvb2tzLmNvbnRleHRJbml0KSB7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhjYWxlbmRhckNvbnRleHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIE5PVCBEUllcclxuICAgICAgICAgICAgbGV0IGV2ZW50U291cmNlcyA9IGluaXRFdmVudFNvdXJjZXMob3B0aW9uc0RhdGEuY2FsZW5kYXJPcHRpb25zLCBkYXRlUHJvZmlsZSwgY2FsZW5kYXJDb250ZXh0KTtcclxuICAgICAgICAgICAgbGV0IGluaXRpYWxTdGF0ZSA9IHtcclxuICAgICAgICAgICAgICAgIGR5bmFtaWNPcHRpb25PdmVycmlkZXMsXHJcbiAgICAgICAgICAgICAgICBjdXJyZW50Vmlld1R5cGUsXHJcbiAgICAgICAgICAgICAgICBjdXJyZW50RGF0ZSxcclxuICAgICAgICAgICAgICAgIGRhdGVQcm9maWxlLFxyXG4gICAgICAgICAgICAgICAgYnVzaW5lc3NIb3VyczogdGhpcy5wYXJzZUNvbnRleHRCdXNpbmVzc0hvdXJzKGNhbGVuZGFyQ29udGV4dCksXHJcbiAgICAgICAgICAgICAgICBldmVudFNvdXJjZXMsXHJcbiAgICAgICAgICAgICAgICBldmVudFVpQmFzZXM6IHt9LFxyXG4gICAgICAgICAgICAgICAgZXZlbnRTdG9yZTogY3JlYXRlRW1wdHlFdmVudFN0b3JlKCksXHJcbiAgICAgICAgICAgICAgICByZW5kZXJhYmxlRXZlbnRTdG9yZTogY3JlYXRlRW1wdHlFdmVudFN0b3JlKCksXHJcbiAgICAgICAgICAgICAgICBkYXRlU2VsZWN0aW9uOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgZXZlbnRTZWxlY3Rpb246ICcnLFxyXG4gICAgICAgICAgICAgICAgZXZlbnREcmFnOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgZXZlbnRSZXNpemU6IG51bGwsXHJcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb25Db25maWc6IHRoaXMuYnVpbGRWaWV3VWlQcm9wcyhjYWxlbmRhckNvbnRleHQpLnNlbGVjdGlvbkNvbmZpZyxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgbGV0IGNvbnRleHRBbmRTdGF0ZSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY2FsZW5kYXJDb250ZXh0KSwgaW5pdGlhbFN0YXRlKTtcclxuICAgICAgICAgICAgZm9yIChsZXQgcmVkdWNlciBvZiBvcHRpb25zRGF0YS5wbHVnaW5Ib29rcy5yZWR1Y2Vycykge1xyXG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihpbml0aWFsU3RhdGUsIHJlZHVjZXIobnVsbCwgbnVsbCwgY29udGV4dEFuZFN0YXRlKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGNvbXB1dGVJc0xvYWRpbmcoaW5pdGlhbFN0YXRlLCBjYWxlbmRhckNvbnRleHQpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXR0ZXIudHJpZ2dlcignbG9hZGluZycsIHRydWUpOyAvLyBOT1QgRFJZXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IGluaXRpYWxTdGF0ZTtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVEYXRhKCk7XHJcbiAgICAgICAgICAgIHRoaXMuYWN0aW9uUnVubmVyLnJlc3VtZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXNldE9wdGlvbnMob3B0aW9uT3ZlcnJpZGVzLCBjaGFuZ2VkT3B0aW9uTmFtZXMpIHtcclxuICAgICAgICAgICAgbGV0IHsgcHJvcHMgfSA9IHRoaXM7XHJcbiAgICAgICAgICAgIGlmIChjaGFuZ2VkT3B0aW9uTmFtZXMgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgcHJvcHMub3B0aW9uT3ZlcnJpZGVzID0gb3B0aW9uT3ZlcnJpZGVzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcHJvcHMub3B0aW9uT3ZlcnJpZGVzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCAocHJvcHMub3B0aW9uT3ZlcnJpZGVzIHx8IHt9KSksIG9wdGlvbk92ZXJyaWRlcyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnNGb3JSZWZpbmluZy5wdXNoKC4uLmNoYW5nZWRPcHRpb25OYW1lcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGNoYW5nZWRPcHRpb25OYW1lcyA9PT0gdW5kZWZpbmVkIHx8IGNoYW5nZWRPcHRpb25OYW1lcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYWN0aW9uUnVubmVyLnJlcXVlc3Qoe1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdOT1RISU5HJyxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9oYW5kbGVBY3Rpb24oYWN0aW9uKSB7XHJcbiAgICAgICAgICAgIGxldCB7IHByb3BzLCBzdGF0ZSwgZW1pdHRlciB9ID0gdGhpcztcclxuICAgICAgICAgICAgbGV0IGR5bmFtaWNPcHRpb25PdmVycmlkZXMgPSByZWR1Y2VEeW5hbWljT3B0aW9uT3ZlcnJpZGVzKHN0YXRlLmR5bmFtaWNPcHRpb25PdmVycmlkZXMsIGFjdGlvbik7XHJcbiAgICAgICAgICAgIGxldCBvcHRpb25zRGF0YSA9IHRoaXMuY29tcHV0ZU9wdGlvbnNEYXRhKHByb3BzLm9wdGlvbk92ZXJyaWRlcywgZHluYW1pY09wdGlvbk92ZXJyaWRlcywgcHJvcHMuY2FsZW5kYXJBcGkpO1xyXG4gICAgICAgICAgICBsZXQgY3VycmVudFZpZXdUeXBlID0gcmVkdWNlVmlld1R5cGUoc3RhdGUuY3VycmVudFZpZXdUeXBlLCBhY3Rpb24pO1xyXG4gICAgICAgICAgICBsZXQgY3VycmVudFZpZXdEYXRhID0gdGhpcy5jb21wdXRlQ3VycmVudFZpZXdEYXRhKGN1cnJlbnRWaWV3VHlwZSwgb3B0aW9uc0RhdGEsIHByb3BzLm9wdGlvbk92ZXJyaWRlcywgZHluYW1pY09wdGlvbk92ZXJyaWRlcyk7XHJcbiAgICAgICAgICAgIC8vIHdpcmUgdGhpbmdzIHVwXHJcbiAgICAgICAgICAgIC8vIFRPRE86IG5vdCBEUllcclxuICAgICAgICAgICAgcHJvcHMuY2FsZW5kYXJBcGkuY3VycmVudERhdGFNYW5hZ2VyID0gdGhpcztcclxuICAgICAgICAgICAgZW1pdHRlci5zZXRUaGlzQ29udGV4dChwcm9wcy5jYWxlbmRhckFwaSk7XHJcbiAgICAgICAgICAgIGVtaXR0ZXIuc2V0T3B0aW9ucyhjdXJyZW50Vmlld0RhdGEub3B0aW9ucyk7XHJcbiAgICAgICAgICAgIGxldCBjYWxlbmRhckNvbnRleHQgPSB7XHJcbiAgICAgICAgICAgICAgICBkYXRlRW52OiBvcHRpb25zRGF0YS5kYXRlRW52LFxyXG4gICAgICAgICAgICAgICAgb3B0aW9uczogb3B0aW9uc0RhdGEuY2FsZW5kYXJPcHRpb25zLFxyXG4gICAgICAgICAgICAgICAgcGx1Z2luSG9va3M6IG9wdGlvbnNEYXRhLnBsdWdpbkhvb2tzLFxyXG4gICAgICAgICAgICAgICAgY2FsZW5kYXJBcGk6IHByb3BzLmNhbGVuZGFyQXBpLFxyXG4gICAgICAgICAgICAgICAgZGlzcGF0Y2g6IHRoaXMuZGlzcGF0Y2gsXHJcbiAgICAgICAgICAgICAgICBlbWl0dGVyLFxyXG4gICAgICAgICAgICAgICAgZ2V0Q3VycmVudERhdGE6IHRoaXMuZ2V0Q3VycmVudERhdGEsXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGxldCB7IGN1cnJlbnREYXRlLCBkYXRlUHJvZmlsZSB9ID0gc3RhdGU7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmRhdGEgJiYgdGhpcy5kYXRhLmRhdGVQcm9maWxlR2VuZXJhdG9yICE9PSBjdXJyZW50Vmlld0RhdGEuZGF0ZVByb2ZpbGVHZW5lcmF0b3IpIHsgLy8gaGFja1xyXG4gICAgICAgICAgICAgICAgZGF0ZVByb2ZpbGUgPSBjdXJyZW50Vmlld0RhdGEuZGF0ZVByb2ZpbGVHZW5lcmF0b3IuYnVpbGQoY3VycmVudERhdGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGN1cnJlbnREYXRlID0gcmVkdWNlQ3VycmVudERhdGUoY3VycmVudERhdGUsIGFjdGlvbik7XHJcbiAgICAgICAgICAgIGRhdGVQcm9maWxlID0gcmVkdWNlRGF0ZVByb2ZpbGUoZGF0ZVByb2ZpbGUsIGFjdGlvbiwgY3VycmVudERhdGUsIGN1cnJlbnRWaWV3RGF0YS5kYXRlUHJvZmlsZUdlbmVyYXRvcik7XHJcbiAgICAgICAgICAgIGlmIChhY3Rpb24udHlwZSA9PT0gJ1BSRVYnIHx8IC8vIFRPRE86IG1vdmUgdGhpcyBsb2dpYyBpbnRvIERhdGVQcm9maWxlR2VuZXJhdG9yXHJcbiAgICAgICAgICAgICAgICBhY3Rpb24udHlwZSA9PT0gJ05FWFQnIHx8IC8vIFwiXHJcbiAgICAgICAgICAgICAgICAhcmFuZ2VDb250YWluc01hcmtlcihkYXRlUHJvZmlsZS5jdXJyZW50UmFuZ2UsIGN1cnJlbnREYXRlKSkge1xyXG4gICAgICAgICAgICAgICAgY3VycmVudERhdGUgPSBkYXRlUHJvZmlsZS5jdXJyZW50UmFuZ2Uuc3RhcnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IGV2ZW50U291cmNlcyA9IHJlZHVjZUV2ZW50U291cmNlcyhzdGF0ZS5ldmVudFNvdXJjZXMsIGFjdGlvbiwgZGF0ZVByb2ZpbGUsIGNhbGVuZGFyQ29udGV4dCk7XHJcbiAgICAgICAgICAgIGxldCBldmVudFN0b3JlID0gcmVkdWNlRXZlbnRTdG9yZShzdGF0ZS5ldmVudFN0b3JlLCBhY3Rpb24sIGV2ZW50U291cmNlcywgZGF0ZVByb2ZpbGUsIGNhbGVuZGFyQ29udGV4dCk7XHJcbiAgICAgICAgICAgIGxldCBpc0V2ZW50c0xvYWRpbmcgPSBjb21wdXRlRXZlbnRTb3VyY2VzTG9hZGluZyhldmVudFNvdXJjZXMpOyAvLyBCQUQuIGFsc28gY2FsbGVkIGluIHRoaXMgZnVuYyBpbiBjb21wdXRlSXNMb2FkaW5nXHJcbiAgICAgICAgICAgIGxldCByZW5kZXJhYmxlRXZlbnRTdG9yZSA9IChpc0V2ZW50c0xvYWRpbmcgJiYgIWN1cnJlbnRWaWV3RGF0YS5vcHRpb25zLnByb2dyZXNzaXZlRXZlbnRSZW5kZXJpbmcpID9cclxuICAgICAgICAgICAgICAgIChzdGF0ZS5yZW5kZXJhYmxlRXZlbnRTdG9yZSB8fCBldmVudFN0b3JlKSA6IC8vIHRyeSBmcm9tIHByZXZpb3VzIHN0YXRlXHJcbiAgICAgICAgICAgICAgICBldmVudFN0b3JlO1xyXG4gICAgICAgICAgICBsZXQgeyBldmVudFVpU2luZ2xlQmFzZSwgc2VsZWN0aW9uQ29uZmlnIH0gPSB0aGlzLmJ1aWxkVmlld1VpUHJvcHMoY2FsZW5kYXJDb250ZXh0KTsgLy8gd2lsbCBtZW1vaXplIG9ialxyXG4gICAgICAgICAgICBsZXQgZXZlbnRVaUJ5U291cmNlID0gdGhpcy5idWlsZEV2ZW50VWlCeVNvdXJjZShldmVudFNvdXJjZXMpO1xyXG4gICAgICAgICAgICBsZXQgZXZlbnRVaUJhc2VzID0gdGhpcy5idWlsZEV2ZW50VWlCYXNlcyhyZW5kZXJhYmxlRXZlbnRTdG9yZS5kZWZzLCBldmVudFVpU2luZ2xlQmFzZSwgZXZlbnRVaUJ5U291cmNlKTtcclxuICAgICAgICAgICAgbGV0IG5ld1N0YXRlID0ge1xyXG4gICAgICAgICAgICAgICAgZHluYW1pY09wdGlvbk92ZXJyaWRlcyxcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRWaWV3VHlwZSxcclxuICAgICAgICAgICAgICAgIGN1cnJlbnREYXRlLFxyXG4gICAgICAgICAgICAgICAgZGF0ZVByb2ZpbGUsXHJcbiAgICAgICAgICAgICAgICBldmVudFNvdXJjZXMsXHJcbiAgICAgICAgICAgICAgICBldmVudFN0b3JlLFxyXG4gICAgICAgICAgICAgICAgcmVuZGVyYWJsZUV2ZW50U3RvcmUsXHJcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb25Db25maWcsXHJcbiAgICAgICAgICAgICAgICBldmVudFVpQmFzZXMsXHJcbiAgICAgICAgICAgICAgICBidXNpbmVzc0hvdXJzOiB0aGlzLnBhcnNlQ29udGV4dEJ1c2luZXNzSG91cnMoY2FsZW5kYXJDb250ZXh0KSxcclxuICAgICAgICAgICAgICAgIGRhdGVTZWxlY3Rpb246IHJlZHVjZURhdGVTZWxlY3Rpb24oc3RhdGUuZGF0ZVNlbGVjdGlvbiwgYWN0aW9uKSxcclxuICAgICAgICAgICAgICAgIGV2ZW50U2VsZWN0aW9uOiByZWR1Y2VTZWxlY3RlZEV2ZW50KHN0YXRlLmV2ZW50U2VsZWN0aW9uLCBhY3Rpb24pLFxyXG4gICAgICAgICAgICAgICAgZXZlbnREcmFnOiByZWR1Y2VFdmVudERyYWcoc3RhdGUuZXZlbnREcmFnLCBhY3Rpb24pLFxyXG4gICAgICAgICAgICAgICAgZXZlbnRSZXNpemU6IHJlZHVjZUV2ZW50UmVzaXplKHN0YXRlLmV2ZW50UmVzaXplLCBhY3Rpb24pLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBsZXQgY29udGV4dEFuZFN0YXRlID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBjYWxlbmRhckNvbnRleHQpLCBuZXdTdGF0ZSk7XHJcbiAgICAgICAgICAgIGZvciAobGV0IHJlZHVjZXIgb2Ygb3B0aW9uc0RhdGEucGx1Z2luSG9va3MucmVkdWNlcnMpIHtcclxuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24obmV3U3RhdGUsIHJlZHVjZXIoc3RhdGUsIGFjdGlvbiwgY29udGV4dEFuZFN0YXRlKSk7IC8vIGdpdmUgdGhlIE9MRCBzdGF0ZSwgZm9yIG9sZCB2YWx1ZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxldCB3YXNMb2FkaW5nID0gY29tcHV0ZUlzTG9hZGluZyhzdGF0ZSwgY2FsZW5kYXJDb250ZXh0KTtcclxuICAgICAgICAgICAgbGV0IGlzTG9hZGluZyA9IGNvbXB1dGVJc0xvYWRpbmcobmV3U3RhdGUsIGNhbGVuZGFyQ29udGV4dCk7XHJcbiAgICAgICAgICAgIC8vIFRPRE86IHVzZSBwcm9wU2V0SGFuZGxlcnMgaW4gcGx1Z2luIHN5c3RlbVxyXG4gICAgICAgICAgICBpZiAoIXdhc0xvYWRpbmcgJiYgaXNMb2FkaW5nKSB7XHJcbiAgICAgICAgICAgICAgICBlbWl0dGVyLnRyaWdnZXIoJ2xvYWRpbmcnLCB0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh3YXNMb2FkaW5nICYmICFpc0xvYWRpbmcpIHtcclxuICAgICAgICAgICAgICAgIGVtaXR0ZXIudHJpZ2dlcignbG9hZGluZycsIGZhbHNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gbmV3U3RhdGU7XHJcbiAgICAgICAgICAgIGlmIChwcm9wcy5vbkFjdGlvbikge1xyXG4gICAgICAgICAgICAgICAgcHJvcHMub25BY3Rpb24oYWN0aW9uKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB1cGRhdGVEYXRhKCkge1xyXG4gICAgICAgICAgICBsZXQgeyBwcm9wcywgc3RhdGUgfSA9IHRoaXM7XHJcbiAgICAgICAgICAgIGxldCBvbGREYXRhID0gdGhpcy5kYXRhO1xyXG4gICAgICAgICAgICBsZXQgb3B0aW9uc0RhdGEgPSB0aGlzLmNvbXB1dGVPcHRpb25zRGF0YShwcm9wcy5vcHRpb25PdmVycmlkZXMsIHN0YXRlLmR5bmFtaWNPcHRpb25PdmVycmlkZXMsIHByb3BzLmNhbGVuZGFyQXBpKTtcclxuICAgICAgICAgICAgbGV0IGN1cnJlbnRWaWV3RGF0YSA9IHRoaXMuY29tcHV0ZUN1cnJlbnRWaWV3RGF0YShzdGF0ZS5jdXJyZW50Vmlld1R5cGUsIG9wdGlvbnNEYXRhLCBwcm9wcy5vcHRpb25PdmVycmlkZXMsIHN0YXRlLmR5bmFtaWNPcHRpb25PdmVycmlkZXMpO1xyXG4gICAgICAgICAgICBsZXQgZGF0YSA9IHRoaXMuZGF0YSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgdmlld1RpdGxlOiB0aGlzLmJ1aWxkVGl0bGUoc3RhdGUuZGF0ZVByb2ZpbGUsIGN1cnJlbnRWaWV3RGF0YS5vcHRpb25zLCBvcHRpb25zRGF0YS5kYXRlRW52KSwgY2FsZW5kYXJBcGk6IHByb3BzLmNhbGVuZGFyQXBpLCBkaXNwYXRjaDogdGhpcy5kaXNwYXRjaCwgZW1pdHRlcjogdGhpcy5lbWl0dGVyLCBnZXRDdXJyZW50RGF0YTogdGhpcy5nZXRDdXJyZW50RGF0YSB9LCBvcHRpb25zRGF0YSksIGN1cnJlbnRWaWV3RGF0YSksIHN0YXRlKTtcclxuICAgICAgICAgICAgbGV0IGNoYW5nZUhhbmRsZXJzID0gb3B0aW9uc0RhdGEucGx1Z2luSG9va3Mub3B0aW9uQ2hhbmdlSGFuZGxlcnM7XHJcbiAgICAgICAgICAgIGxldCBvbGRDYWxlbmRhck9wdGlvbnMgPSBvbGREYXRhICYmIG9sZERhdGEuY2FsZW5kYXJPcHRpb25zO1xyXG4gICAgICAgICAgICBsZXQgbmV3Q2FsZW5kYXJPcHRpb25zID0gb3B0aW9uc0RhdGEuY2FsZW5kYXJPcHRpb25zO1xyXG4gICAgICAgICAgICBpZiAob2xkQ2FsZW5kYXJPcHRpb25zICYmIG9sZENhbGVuZGFyT3B0aW9ucyAhPT0gbmV3Q2FsZW5kYXJPcHRpb25zKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAob2xkQ2FsZW5kYXJPcHRpb25zLnRpbWVab25lICE9PSBuZXdDYWxlbmRhck9wdGlvbnMudGltZVpvbmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBoYWNrXHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuZXZlbnRTb3VyY2VzID0gZGF0YS5ldmVudFNvdXJjZXMgPSByZWR1Y2VFdmVudFNvdXJjZXNOZXdUaW1lWm9uZShkYXRhLmV2ZW50U291cmNlcywgc3RhdGUuZGF0ZVByb2ZpbGUsIGRhdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLmV2ZW50U3RvcmUgPSBkYXRhLmV2ZW50U3RvcmUgPSByZXpvbmVFdmVudFN0b3JlRGF0ZXMoZGF0YS5ldmVudFN0b3JlLCBvbGREYXRhLmRhdGVFbnYsIGRhdGEuZGF0ZUVudik7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUucmVuZGVyYWJsZUV2ZW50U3RvcmUgPSBkYXRhLnJlbmRlcmFibGVFdmVudFN0b3JlID0gcmV6b25lRXZlbnRTdG9yZURhdGVzKGRhdGEucmVuZGVyYWJsZUV2ZW50U3RvcmUsIG9sZERhdGEuZGF0ZUVudiwgZGF0YS5kYXRlRW52KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGZvciAobGV0IG9wdGlvbk5hbWUgaW4gY2hhbmdlSGFuZGxlcnMpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zRm9ySGFuZGxpbmcuaW5kZXhPZihvcHRpb25OYW1lKSAhPT0gLTEgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgb2xkQ2FsZW5kYXJPcHRpb25zW29wdGlvbk5hbWVdICE9PSBuZXdDYWxlbmRhck9wdGlvbnNbb3B0aW9uTmFtZV0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlSGFuZGxlcnNbb3B0aW9uTmFtZV0obmV3Q2FsZW5kYXJPcHRpb25zW29wdGlvbk5hbWVdLCBkYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5vcHRpb25zRm9ySGFuZGxpbmcgPSBbXTtcclxuICAgICAgICAgICAgaWYgKHByb3BzLm9uRGF0YSkge1xyXG4gICAgICAgICAgICAgICAgcHJvcHMub25EYXRhKGRhdGEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbXB1dGVPcHRpb25zRGF0YShvcHRpb25PdmVycmlkZXMsIGR5bmFtaWNPcHRpb25PdmVycmlkZXMsIGNhbGVuZGFyQXBpKSB7XHJcbiAgICAgICAgICAgIC8vIFRPRE86IGJsYWNrbGlzdCBvcHRpb25zIHRoYXQgYXJlIGhhbmRsZWQgYnkgb3B0aW9uQ2hhbmdlSGFuZGxlcnNcclxuICAgICAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnNGb3JSZWZpbmluZy5sZW5ndGggJiZcclxuICAgICAgICAgICAgICAgIG9wdGlvbk92ZXJyaWRlcyA9PT0gdGhpcy5zdGFibGVPcHRpb25PdmVycmlkZXMgJiZcclxuICAgICAgICAgICAgICAgIGR5bmFtaWNPcHRpb25PdmVycmlkZXMgPT09IHRoaXMuc3RhYmxlRHluYW1pY09wdGlvbk92ZXJyaWRlcykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhYmxlQ2FsZW5kYXJPcHRpb25zRGF0YTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgeyByZWZpbmVkT3B0aW9ucywgcGx1Z2luSG9va3MsIGxvY2FsZURlZmF1bHRzLCBhdmFpbGFibGVMb2NhbGVEYXRhLCBleHRyYSwgfSA9IHRoaXMucHJvY2Vzc1Jhd0NhbGVuZGFyT3B0aW9ucyhvcHRpb25PdmVycmlkZXMsIGR5bmFtaWNPcHRpb25PdmVycmlkZXMpO1xyXG4gICAgICAgICAgICB3YXJuVW5rbm93bk9wdGlvbnMoZXh0cmEpO1xyXG4gICAgICAgICAgICBsZXQgZGF0ZUVudiA9IHRoaXMuYnVpbGREYXRlRW52KHJlZmluZWRPcHRpb25zLnRpbWVab25lLCByZWZpbmVkT3B0aW9ucy5sb2NhbGUsIHJlZmluZWRPcHRpb25zLndlZWtOdW1iZXJDYWxjdWxhdGlvbiwgcmVmaW5lZE9wdGlvbnMuZmlyc3REYXksIHJlZmluZWRPcHRpb25zLndlZWtUZXh0LCBwbHVnaW5Ib29rcywgYXZhaWxhYmxlTG9jYWxlRGF0YSwgcmVmaW5lZE9wdGlvbnMuZGVmYXVsdFJhbmdlU2VwYXJhdG9yKTtcclxuICAgICAgICAgICAgbGV0IHZpZXdTcGVjcyA9IHRoaXMuYnVpbGRWaWV3U3BlY3MocGx1Z2luSG9va3Mudmlld3MsIHRoaXMuc3RhYmxlT3B0aW9uT3ZlcnJpZGVzLCB0aGlzLnN0YWJsZUR5bmFtaWNPcHRpb25PdmVycmlkZXMsIGxvY2FsZURlZmF1bHRzKTtcclxuICAgICAgICAgICAgbGV0IHRoZW1lID0gdGhpcy5idWlsZFRoZW1lKHJlZmluZWRPcHRpb25zLCBwbHVnaW5Ib29rcyk7XHJcbiAgICAgICAgICAgIGxldCB0b29sYmFyQ29uZmlnID0gdGhpcy5wYXJzZVRvb2xiYXJzKHJlZmluZWRPcHRpb25zLCB0aGlzLnN0YWJsZU9wdGlvbk92ZXJyaWRlcywgdGhlbWUsIHZpZXdTcGVjcywgY2FsZW5kYXJBcGkpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdGFibGVDYWxlbmRhck9wdGlvbnNEYXRhID0ge1xyXG4gICAgICAgICAgICAgICAgY2FsZW5kYXJPcHRpb25zOiByZWZpbmVkT3B0aW9ucyxcclxuICAgICAgICAgICAgICAgIHBsdWdpbkhvb2tzLFxyXG4gICAgICAgICAgICAgICAgZGF0ZUVudixcclxuICAgICAgICAgICAgICAgIHZpZXdTcGVjcyxcclxuICAgICAgICAgICAgICAgIHRoZW1lLFxyXG4gICAgICAgICAgICAgICAgdG9vbGJhckNvbmZpZyxcclxuICAgICAgICAgICAgICAgIGxvY2FsZURlZmF1bHRzLFxyXG4gICAgICAgICAgICAgICAgYXZhaWxhYmxlUmF3TG9jYWxlczogYXZhaWxhYmxlTG9jYWxlRGF0YS5tYXAsXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGFsd2F5cyBjYWxsZWQgZnJvbSBiZWhpbmQgYSBtZW1vaXplclxyXG4gICAgICAgIHByb2Nlc3NSYXdDYWxlbmRhck9wdGlvbnMob3B0aW9uT3ZlcnJpZGVzLCBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzKSB7XHJcbiAgICAgICAgICAgIGxldCB7IGxvY2FsZXMsIGxvY2FsZSB9ID0gbWVyZ2VSYXdPcHRpb25zKFtcclxuICAgICAgICAgICAgICAgIEJBU0VfT1BUSU9OX0RFRkFVTFRTLFxyXG4gICAgICAgICAgICAgICAgb3B0aW9uT3ZlcnJpZGVzLFxyXG4gICAgICAgICAgICAgICAgZHluYW1pY09wdGlvbk92ZXJyaWRlcyxcclxuICAgICAgICAgICAgXSk7XHJcbiAgICAgICAgICAgIGxldCBhdmFpbGFibGVMb2NhbGVEYXRhID0gdGhpcy5vcmdhbml6ZVJhd0xvY2FsZXMobG9jYWxlcyk7XHJcbiAgICAgICAgICAgIGxldCBhdmFpbGFibGVSYXdMb2NhbGVzID0gYXZhaWxhYmxlTG9jYWxlRGF0YS5tYXA7XHJcbiAgICAgICAgICAgIGxldCBsb2NhbGVEZWZhdWx0cyA9IHRoaXMuYnVpbGRMb2NhbGUobG9jYWxlIHx8IGF2YWlsYWJsZUxvY2FsZURhdGEuZGVmYXVsdENvZGUsIGF2YWlsYWJsZVJhd0xvY2FsZXMpLm9wdGlvbnM7XHJcbiAgICAgICAgICAgIGxldCBwbHVnaW5Ib29rcyA9IHRoaXMuYnVpbGRQbHVnaW5Ib29rcyhvcHRpb25PdmVycmlkZXMucGx1Z2lucyB8fCBbXSwgZ2xvYmFsUGx1Z2lucyk7XHJcbiAgICAgICAgICAgIGxldCByZWZpbmVycyA9IHRoaXMuY3VycmVudENhbGVuZGFyT3B0aW9uc1JlZmluZXJzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBCQVNFX09QVElPTl9SRUZJTkVSUyksIENBTEVOREFSX0xJU1RFTkVSX1JFRklORVJTKSwgQ0FMRU5EQVJfT1BUSU9OX1JFRklORVJTKSwgcGx1Z2luSG9va3MubGlzdGVuZXJSZWZpbmVycyksIHBsdWdpbkhvb2tzLm9wdGlvblJlZmluZXJzKTtcclxuICAgICAgICAgICAgbGV0IGV4dHJhID0ge307XHJcbiAgICAgICAgICAgIGxldCByYXcgPSBtZXJnZVJhd09wdGlvbnMoW1xyXG4gICAgICAgICAgICAgICAgQkFTRV9PUFRJT05fREVGQVVMVFMsXHJcbiAgICAgICAgICAgICAgICBsb2NhbGVEZWZhdWx0cyxcclxuICAgICAgICAgICAgICAgIG9wdGlvbk92ZXJyaWRlcyxcclxuICAgICAgICAgICAgICAgIGR5bmFtaWNPcHRpb25PdmVycmlkZXMsXHJcbiAgICAgICAgICAgIF0pO1xyXG4gICAgICAgICAgICBsZXQgcmVmaW5lZCA9IHt9O1xyXG4gICAgICAgICAgICBsZXQgY3VycmVudFJhdyA9IHRoaXMuY3VycmVudENhbGVuZGFyT3B0aW9uc0lucHV0O1xyXG4gICAgICAgICAgICBsZXQgY3VycmVudFJlZmluZWQgPSB0aGlzLmN1cnJlbnRDYWxlbmRhck9wdGlvbnNSZWZpbmVkO1xyXG4gICAgICAgICAgICBsZXQgYW55Q2hhbmdlcyA9IGZhbHNlO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBvcHRpb25OYW1lIGluIHJhdykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9uc0ZvclJlZmluaW5nLmluZGV4T2Yob3B0aW9uTmFtZSkgPT09IC0xICYmIChyYXdbb3B0aW9uTmFtZV0gPT09IGN1cnJlbnRSYXdbb3B0aW9uTmFtZV0gfHwgKENPTVBMRVhfT1BUSU9OX0NPTVBBUkFUT1JTW29wdGlvbk5hbWVdICYmXHJcbiAgICAgICAgICAgICAgICAgICAgKG9wdGlvbk5hbWUgaW4gY3VycmVudFJhdykgJiZcclxuICAgICAgICAgICAgICAgICAgICBDT01QTEVYX09QVElPTl9DT01QQVJBVE9SU1tvcHRpb25OYW1lXShjdXJyZW50UmF3W29wdGlvbk5hbWVdLCByYXdbb3B0aW9uTmFtZV0pKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZWZpbmVkW29wdGlvbk5hbWVdID0gY3VycmVudFJlZmluZWRbb3B0aW9uTmFtZV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyZWZpbmVyc1tvcHRpb25OYW1lXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlZmluZWRbb3B0aW9uTmFtZV0gPSByZWZpbmVyc1tvcHRpb25OYW1lXShyYXdbb3B0aW9uTmFtZV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGFueUNoYW5nZXMgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXh0cmFbb3B0aW9uTmFtZV0gPSBjdXJyZW50UmF3W29wdGlvbk5hbWVdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChhbnlDaGFuZ2VzKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRDYWxlbmRhck9wdGlvbnNJbnB1dCA9IHJhdztcclxuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudENhbGVuZGFyT3B0aW9uc1JlZmluZWQgPSByZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGFibGVPcHRpb25PdmVycmlkZXMgPSBvcHRpb25PdmVycmlkZXM7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0YWJsZUR5bmFtaWNPcHRpb25PdmVycmlkZXMgPSBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMub3B0aW9uc0ZvckhhbmRsaW5nLnB1c2goLi4udGhpcy5vcHRpb25zRm9yUmVmaW5pbmcpO1xyXG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNGb3JSZWZpbmluZyA9IFtdO1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgcmF3T3B0aW9uczogdGhpcy5jdXJyZW50Q2FsZW5kYXJPcHRpb25zSW5wdXQsXHJcbiAgICAgICAgICAgICAgICByZWZpbmVkT3B0aW9uczogdGhpcy5jdXJyZW50Q2FsZW5kYXJPcHRpb25zUmVmaW5lZCxcclxuICAgICAgICAgICAgICAgIHBsdWdpbkhvb2tzLFxyXG4gICAgICAgICAgICAgICAgYXZhaWxhYmxlTG9jYWxlRGF0YSxcclxuICAgICAgICAgICAgICAgIGxvY2FsZURlZmF1bHRzLFxyXG4gICAgICAgICAgICAgICAgZXh0cmEsXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9jb21wdXRlQ3VycmVudFZpZXdEYXRhKHZpZXdUeXBlLCBvcHRpb25zRGF0YSwgb3B0aW9uT3ZlcnJpZGVzLCBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzKSB7XHJcbiAgICAgICAgICAgIGxldCB2aWV3U3BlYyA9IG9wdGlvbnNEYXRhLnZpZXdTcGVjc1t2aWV3VHlwZV07XHJcbiAgICAgICAgICAgIGlmICghdmlld1NwZWMpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgdmlld1R5cGUgXCIke3ZpZXdUeXBlfVwiIGlzIG5vdCBhdmFpbGFibGUuIFBsZWFzZSBtYWtlIHN1cmUgeW91J3ZlIGxvYWRlZCBhbGwgbmVjY2Vzc2FyeSBwbHVnaW5zYCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IHsgcmVmaW5lZE9wdGlvbnMsIGV4dHJhIH0gPSB0aGlzLnByb2Nlc3NSYXdWaWV3T3B0aW9ucyh2aWV3U3BlYywgb3B0aW9uc0RhdGEucGx1Z2luSG9va3MsIG9wdGlvbnNEYXRhLmxvY2FsZURlZmF1bHRzLCBvcHRpb25PdmVycmlkZXMsIGR5bmFtaWNPcHRpb25PdmVycmlkZXMpO1xyXG4gICAgICAgICAgICB3YXJuVW5rbm93bk9wdGlvbnMoZXh0cmEpO1xyXG4gICAgICAgICAgICBsZXQgZGF0ZVByb2ZpbGVHZW5lcmF0b3IgPSB0aGlzLmJ1aWxkRGF0ZVByb2ZpbGVHZW5lcmF0b3Ioe1xyXG4gICAgICAgICAgICAgICAgZGF0ZVByb2ZpbGVHZW5lcmF0b3JDbGFzczogdmlld1NwZWMub3B0aW9uRGVmYXVsdHMuZGF0ZVByb2ZpbGVHZW5lcmF0b3JDbGFzcyxcclxuICAgICAgICAgICAgICAgIGR1cmF0aW9uOiB2aWV3U3BlYy5kdXJhdGlvbixcclxuICAgICAgICAgICAgICAgIGR1cmF0aW9uVW5pdDogdmlld1NwZWMuZHVyYXRpb25Vbml0LFxyXG4gICAgICAgICAgICAgICAgdXNlc01pbk1heFRpbWU6IHZpZXdTcGVjLm9wdGlvbkRlZmF1bHRzLnVzZXNNaW5NYXhUaW1lLFxyXG4gICAgICAgICAgICAgICAgZGF0ZUVudjogb3B0aW9uc0RhdGEuZGF0ZUVudixcclxuICAgICAgICAgICAgICAgIGNhbGVuZGFyQXBpOiB0aGlzLnByb3BzLmNhbGVuZGFyQXBpLFxyXG4gICAgICAgICAgICAgICAgc2xvdE1pblRpbWU6IHJlZmluZWRPcHRpb25zLnNsb3RNaW5UaW1lLFxyXG4gICAgICAgICAgICAgICAgc2xvdE1heFRpbWU6IHJlZmluZWRPcHRpb25zLnNsb3RNYXhUaW1lLFxyXG4gICAgICAgICAgICAgICAgc2hvd05vbkN1cnJlbnREYXRlczogcmVmaW5lZE9wdGlvbnMuc2hvd05vbkN1cnJlbnREYXRlcyxcclxuICAgICAgICAgICAgICAgIGRheUNvdW50OiByZWZpbmVkT3B0aW9ucy5kYXlDb3VudCxcclxuICAgICAgICAgICAgICAgIGRhdGVBbGlnbm1lbnQ6IHJlZmluZWRPcHRpb25zLmRhdGVBbGlnbm1lbnQsXHJcbiAgICAgICAgICAgICAgICBkYXRlSW5jcmVtZW50OiByZWZpbmVkT3B0aW9ucy5kYXRlSW5jcmVtZW50LFxyXG4gICAgICAgICAgICAgICAgaGlkZGVuRGF5czogcmVmaW5lZE9wdGlvbnMuaGlkZGVuRGF5cyxcclxuICAgICAgICAgICAgICAgIHdlZWtlbmRzOiByZWZpbmVkT3B0aW9ucy53ZWVrZW5kcyxcclxuICAgICAgICAgICAgICAgIG5vd0lucHV0OiByZWZpbmVkT3B0aW9ucy5ub3csXHJcbiAgICAgICAgICAgICAgICB2YWxpZFJhbmdlSW5wdXQ6IHJlZmluZWRPcHRpb25zLnZhbGlkUmFuZ2UsXHJcbiAgICAgICAgICAgICAgICB2aXNpYmxlUmFuZ2VJbnB1dDogcmVmaW5lZE9wdGlvbnMudmlzaWJsZVJhbmdlLFxyXG4gICAgICAgICAgICAgICAgZml4ZWRXZWVrQ291bnQ6IHJlZmluZWRPcHRpb25zLmZpeGVkV2Vla0NvdW50LFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgbGV0IHZpZXdBcGkgPSB0aGlzLmJ1aWxkVmlld0FwaSh2aWV3VHlwZSwgdGhpcy5nZXRDdXJyZW50RGF0YSwgb3B0aW9uc0RhdGEuZGF0ZUVudik7XHJcbiAgICAgICAgICAgIHJldHVybiB7IHZpZXdTcGVjLCBvcHRpb25zOiByZWZpbmVkT3B0aW9ucywgZGF0ZVByb2ZpbGVHZW5lcmF0b3IsIHZpZXdBcGkgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcHJvY2Vzc1Jhd1ZpZXdPcHRpb25zKHZpZXdTcGVjLCBwbHVnaW5Ib29rcywgbG9jYWxlRGVmYXVsdHMsIG9wdGlvbk92ZXJyaWRlcywgZHluYW1pY09wdGlvbk92ZXJyaWRlcykge1xyXG4gICAgICAgICAgICBsZXQgcmF3ID0gbWVyZ2VSYXdPcHRpb25zKFtcclxuICAgICAgICAgICAgICAgIEJBU0VfT1BUSU9OX0RFRkFVTFRTLFxyXG4gICAgICAgICAgICAgICAgdmlld1NwZWMub3B0aW9uRGVmYXVsdHMsXHJcbiAgICAgICAgICAgICAgICBsb2NhbGVEZWZhdWx0cyxcclxuICAgICAgICAgICAgICAgIG9wdGlvbk92ZXJyaWRlcyxcclxuICAgICAgICAgICAgICAgIHZpZXdTcGVjLm9wdGlvbk92ZXJyaWRlcyxcclxuICAgICAgICAgICAgICAgIGR5bmFtaWNPcHRpb25PdmVycmlkZXMsXHJcbiAgICAgICAgICAgIF0pO1xyXG4gICAgICAgICAgICBsZXQgcmVmaW5lcnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgQkFTRV9PUFRJT05fUkVGSU5FUlMpLCBDQUxFTkRBUl9MSVNURU5FUl9SRUZJTkVSUyksIENBTEVOREFSX09QVElPTl9SRUZJTkVSUyksIFZJRVdfT1BUSU9OX1JFRklORVJTKSwgcGx1Z2luSG9va3MubGlzdGVuZXJSZWZpbmVycyksIHBsdWdpbkhvb2tzLm9wdGlvblJlZmluZXJzKTtcclxuICAgICAgICAgICAgbGV0IHJlZmluZWQgPSB7fTtcclxuICAgICAgICAgICAgbGV0IGN1cnJlbnRSYXcgPSB0aGlzLmN1cnJlbnRWaWV3T3B0aW9uc0lucHV0O1xyXG4gICAgICAgICAgICBsZXQgY3VycmVudFJlZmluZWQgPSB0aGlzLmN1cnJlbnRWaWV3T3B0aW9uc1JlZmluZWQ7XHJcbiAgICAgICAgICAgIGxldCBhbnlDaGFuZ2VzID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGxldCBleHRyYSA9IHt9O1xyXG4gICAgICAgICAgICBmb3IgKGxldCBvcHRpb25OYW1lIGluIHJhdykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHJhd1tvcHRpb25OYW1lXSA9PT0gY3VycmVudFJhd1tvcHRpb25OYW1lXSB8fFxyXG4gICAgICAgICAgICAgICAgICAgIChDT01QTEVYX09QVElPTl9DT01QQVJBVE9SU1tvcHRpb25OYW1lXSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBDT01QTEVYX09QVElPTl9DT01QQVJBVE9SU1tvcHRpb25OYW1lXShyYXdbb3B0aW9uTmFtZV0sIGN1cnJlbnRSYXdbb3B0aW9uTmFtZV0pKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlZmluZWRbb3B0aW9uTmFtZV0gPSBjdXJyZW50UmVmaW5lZFtvcHRpb25OYW1lXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyYXdbb3B0aW9uTmFtZV0gPT09IHRoaXMuY3VycmVudENhbGVuZGFyT3B0aW9uc0lucHV0W29wdGlvbk5hbWVdIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChDT01QTEVYX09QVElPTl9DT01QQVJBVE9SU1tvcHRpb25OYW1lXSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQ09NUExFWF9PUFRJT05fQ09NUEFSQVRPUlNbb3B0aW9uTmFtZV0ocmF3W29wdGlvbk5hbWVdLCB0aGlzLmN1cnJlbnRDYWxlbmRhck9wdGlvbnNJbnB1dFtvcHRpb25OYW1lXSkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25OYW1lIGluIHRoaXMuY3VycmVudENhbGVuZGFyT3B0aW9uc1JlZmluZWQpIHsgLy8gbWlnaHQgYmUgYW4gXCJleHRyYVwiIHByb3BcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZmluZWRbb3B0aW9uTmFtZV0gPSB0aGlzLmN1cnJlbnRDYWxlbmRhck9wdGlvbnNSZWZpbmVkW29wdGlvbk5hbWVdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlZmluZXJzW29wdGlvbk5hbWVdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZmluZWRbb3B0aW9uTmFtZV0gPSByZWZpbmVyc1tvcHRpb25OYW1lXShyYXdbb3B0aW9uTmFtZV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmFbb3B0aW9uTmFtZV0gPSByYXdbb3B0aW9uTmFtZV07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGFueUNoYW5nZXMgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChhbnlDaGFuZ2VzKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRWaWV3T3B0aW9uc0lucHV0ID0gcmF3O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50Vmlld09wdGlvbnNSZWZpbmVkID0gcmVmaW5lZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgcmF3T3B0aW9uczogdGhpcy5jdXJyZW50Vmlld09wdGlvbnNJbnB1dCxcclxuICAgICAgICAgICAgICAgIHJlZmluZWRPcHRpb25zOiB0aGlzLmN1cnJlbnRWaWV3T3B0aW9uc1JlZmluZWQsXHJcbiAgICAgICAgICAgICAgICBleHRyYSxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBidWlsZERhdGVFbnYkMSh0aW1lWm9uZSwgZXhwbGljaXRMb2NhbGUsIHdlZWtOdW1iZXJDYWxjdWxhdGlvbiwgZmlyc3REYXksIHdlZWtUZXh0LCBwbHVnaW5Ib29rcywgYXZhaWxhYmxlTG9jYWxlRGF0YSwgZGVmYXVsdFNlcGFyYXRvcikge1xyXG4gICAgICAgIGxldCBsb2NhbGUgPSBidWlsZExvY2FsZShleHBsaWNpdExvY2FsZSB8fCBhdmFpbGFibGVMb2NhbGVEYXRhLmRlZmF1bHRDb2RlLCBhdmFpbGFibGVMb2NhbGVEYXRhLm1hcCk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlRW52KHtcclxuICAgICAgICAgICAgY2FsZW5kYXJTeXN0ZW06ICdncmVnb3J5JyxcclxuICAgICAgICAgICAgdGltZVpvbmUsXHJcbiAgICAgICAgICAgIG5hbWVkVGltZVpvbmVJbXBsOiBwbHVnaW5Ib29rcy5uYW1lZFRpbWVab25lZEltcGwsXHJcbiAgICAgICAgICAgIGxvY2FsZSxcclxuICAgICAgICAgICAgd2Vla051bWJlckNhbGN1bGF0aW9uLFxyXG4gICAgICAgICAgICBmaXJzdERheSxcclxuICAgICAgICAgICAgd2Vla1RleHQsXHJcbiAgICAgICAgICAgIGNtZEZvcm1hdHRlcjogcGx1Z2luSG9va3MuY21kRm9ybWF0dGVyLFxyXG4gICAgICAgICAgICBkZWZhdWx0U2VwYXJhdG9yLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYnVpbGRUaGVtZShvcHRpb25zLCBwbHVnaW5Ib29rcykge1xyXG4gICAgICAgIGxldCBUaGVtZUNsYXNzID0gcGx1Z2luSG9va3MudGhlbWVDbGFzc2VzW29wdGlvbnMudGhlbWVTeXN0ZW1dIHx8IFN0YW5kYXJkVGhlbWU7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBUaGVtZUNsYXNzKG9wdGlvbnMpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYnVpbGREYXRlUHJvZmlsZUdlbmVyYXRvcihwcm9wcykge1xyXG4gICAgICAgIGxldCBEYXRlUHJvZmlsZUdlbmVyYXRvckNsYXNzID0gcHJvcHMuZGF0ZVByb2ZpbGVHZW5lcmF0b3JDbGFzcyB8fCBEYXRlUHJvZmlsZUdlbmVyYXRvcjtcclxuICAgICAgICByZXR1cm4gbmV3IERhdGVQcm9maWxlR2VuZXJhdG9yQ2xhc3MocHJvcHMpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYnVpbGRWaWV3QXBpKHR5cGUsIGdldEN1cnJlbnREYXRhLCBkYXRlRW52KSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBWaWV3SW1wbCh0eXBlLCBnZXRDdXJyZW50RGF0YSwgZGF0ZUVudik7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBidWlsZEV2ZW50VWlCeVNvdXJjZShldmVudFNvdXJjZXMpIHtcclxuICAgICAgICByZXR1cm4gbWFwSGFzaChldmVudFNvdXJjZXMsIChldmVudFNvdXJjZSkgPT4gZXZlbnRTb3VyY2UudWkpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYnVpbGRFdmVudFVpQmFzZXMoZXZlbnREZWZzLCBldmVudFVpU2luZ2xlQmFzZSwgZXZlbnRVaUJ5U291cmNlKSB7XHJcbiAgICAgICAgbGV0IGV2ZW50VWlCYXNlcyA9IHsgJyc6IGV2ZW50VWlTaW5nbGVCYXNlIH07XHJcbiAgICAgICAgZm9yIChsZXQgZGVmSWQgaW4gZXZlbnREZWZzKSB7XHJcbiAgICAgICAgICAgIGxldCBkZWYgPSBldmVudERlZnNbZGVmSWRdO1xyXG4gICAgICAgICAgICBpZiAoZGVmLnNvdXJjZUlkICYmIGV2ZW50VWlCeVNvdXJjZVtkZWYuc291cmNlSWRdKSB7XHJcbiAgICAgICAgICAgICAgICBldmVudFVpQmFzZXNbZGVmSWRdID0gZXZlbnRVaUJ5U291cmNlW2RlZi5zb3VyY2VJZF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGV2ZW50VWlCYXNlcztcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGJ1aWxkVmlld1VpUHJvcHMoY2FsZW5kYXJDb250ZXh0KSB7XHJcbiAgICAgICAgbGV0IHsgb3B0aW9ucyB9ID0gY2FsZW5kYXJDb250ZXh0O1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGV2ZW50VWlTaW5nbGVCYXNlOiBjcmVhdGVFdmVudFVpKHtcclxuICAgICAgICAgICAgICAgIGRpc3BsYXk6IG9wdGlvbnMuZXZlbnREaXNwbGF5LFxyXG4gICAgICAgICAgICAgICAgZWRpdGFibGU6IG9wdGlvbnMuZWRpdGFibGUsXHJcbiAgICAgICAgICAgICAgICBzdGFydEVkaXRhYmxlOiBvcHRpb25zLmV2ZW50U3RhcnRFZGl0YWJsZSxcclxuICAgICAgICAgICAgICAgIGR1cmF0aW9uRWRpdGFibGU6IG9wdGlvbnMuZXZlbnREdXJhdGlvbkVkaXRhYmxlLFxyXG4gICAgICAgICAgICAgICAgY29uc3RyYWludDogb3B0aW9ucy5ldmVudENvbnN0cmFpbnQsXHJcbiAgICAgICAgICAgICAgICBvdmVybGFwOiB0eXBlb2Ygb3B0aW9ucy5ldmVudE92ZXJsYXAgPT09ICdib29sZWFuJyA/IG9wdGlvbnMuZXZlbnRPdmVybGFwIDogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAgICAgYWxsb3c6IG9wdGlvbnMuZXZlbnRBbGxvdyxcclxuICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogb3B0aW9ucy5ldmVudEJhY2tncm91bmRDb2xvcixcclxuICAgICAgICAgICAgICAgIGJvcmRlckNvbG9yOiBvcHRpb25zLmV2ZW50Qm9yZGVyQ29sb3IsXHJcbiAgICAgICAgICAgICAgICB0ZXh0Q29sb3I6IG9wdGlvbnMuZXZlbnRUZXh0Q29sb3IsXHJcbiAgICAgICAgICAgICAgICBjb2xvcjogb3B0aW9ucy5ldmVudENvbG9yLFxyXG4gICAgICAgICAgICAgICAgLy8gY2xhc3NOYW1lczogb3B0aW9ucy5ldmVudENsYXNzTmFtZXMgLy8gcmVuZGVyIGhvb2sgd2lsbCBoYW5kbGUgdGhpc1xyXG4gICAgICAgICAgICB9LCBjYWxlbmRhckNvbnRleHQpLFxyXG4gICAgICAgICAgICBzZWxlY3Rpb25Db25maWc6IGNyZWF0ZUV2ZW50VWkoe1xyXG4gICAgICAgICAgICAgICAgY29uc3RyYWludDogb3B0aW9ucy5zZWxlY3RDb25zdHJhaW50LFxyXG4gICAgICAgICAgICAgICAgb3ZlcmxhcDogdHlwZW9mIG9wdGlvbnMuc2VsZWN0T3ZlcmxhcCA9PT0gJ2Jvb2xlYW4nID8gb3B0aW9ucy5zZWxlY3RPdmVybGFwIDogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAgICAgYWxsb3c6IG9wdGlvbnMuc2VsZWN0QWxsb3csXHJcbiAgICAgICAgICAgIH0sIGNhbGVuZGFyQ29udGV4dCksXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGNvbXB1dGVJc0xvYWRpbmcoc3RhdGUsIGNvbnRleHQpIHtcclxuICAgICAgICBmb3IgKGxldCBpc0xvYWRpbmdGdW5jIG9mIGNvbnRleHQucGx1Z2luSG9va3MuaXNMb2FkaW5nRnVuY3MpIHtcclxuICAgICAgICAgICAgaWYgKGlzTG9hZGluZ0Z1bmMoc3RhdGUpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBwYXJzZUNvbnRleHRCdXNpbmVzc0hvdXJzKGNhbGVuZGFyQ29udGV4dCkge1xyXG4gICAgICAgIHJldHVybiBwYXJzZUJ1c2luZXNzSG91cnMoY2FsZW5kYXJDb250ZXh0Lm9wdGlvbnMuYnVzaW5lc3NIb3VycywgY2FsZW5kYXJDb250ZXh0KTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHdhcm5Vbmtub3duT3B0aW9ucyhvcHRpb25zLCB2aWV3TmFtZSkge1xyXG4gICAgICAgIGZvciAobGV0IG9wdGlvbk5hbWUgaW4gb3B0aW9ucykge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYFVua25vd24gb3B0aW9uICcke29wdGlvbk5hbWV9J2AgK1xyXG4gICAgICAgICAgICAgICAgKHZpZXdOYW1lID8gYCBmb3IgdmlldyAnJHt2aWV3TmFtZX0nYCA6ICcnKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNsYXNzIFRvb2xiYXJTZWN0aW9uIGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XHJcbiAgICAgICAgcmVuZGVyKCkge1xyXG4gICAgICAgICAgICBsZXQgY2hpbGRyZW4gPSB0aGlzLnByb3BzLndpZGdldEdyb3Vwcy5tYXAoKHdpZGdldEdyb3VwKSA9PiB0aGlzLnJlbmRlcldpZGdldEdyb3VwKHdpZGdldEdyb3VwKSk7XHJcbiAgICAgICAgICAgIHJldHVybiB5KCdkaXYnLCB7IGNsYXNzTmFtZTogJ2ZjLXRvb2xiYXItY2h1bmsnIH0sIC4uLmNoaWxkcmVuKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVuZGVyV2lkZ2V0R3JvdXAod2lkZ2V0R3JvdXApIHtcclxuICAgICAgICAgICAgbGV0IHsgcHJvcHMgfSA9IHRoaXM7XHJcbiAgICAgICAgICAgIGxldCB7IHRoZW1lIH0gPSB0aGlzLmNvbnRleHQ7XHJcbiAgICAgICAgICAgIGxldCBjaGlsZHJlbiA9IFtdO1xyXG4gICAgICAgICAgICBsZXQgaXNPbmx5QnV0dG9ucyA9IHRydWU7XHJcbiAgICAgICAgICAgIGZvciAobGV0IHdpZGdldCBvZiB3aWRnZXRHcm91cCkge1xyXG4gICAgICAgICAgICAgICAgbGV0IHsgYnV0dG9uTmFtZSwgYnV0dG9uQ2xpY2ssIGJ1dHRvblRleHQsIGJ1dHRvbkljb24sIGJ1dHRvbkhpbnQgfSA9IHdpZGdldDtcclxuICAgICAgICAgICAgICAgIGlmIChidXR0b25OYW1lID09PSAndGl0bGUnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaXNPbmx5QnV0dG9ucyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuLnB1c2goeShcImgyXCIsIHsgY2xhc3NOYW1lOiBcImZjLXRvb2xiYXItdGl0bGVcIiwgaWQ6IHByb3BzLnRpdGxlSWQgfSwgcHJvcHMudGl0bGUpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBpc1ByZXNzZWQgPSBidXR0b25OYW1lID09PSBwcm9wcy5hY3RpdmVCdXR0b247XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGlzRGlzYWJsZWQgPSAoIXByb3BzLmlzVG9kYXlFbmFibGVkICYmIGJ1dHRvbk5hbWUgPT09ICd0b2RheScpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICghcHJvcHMuaXNQcmV2RW5hYmxlZCAmJiBidXR0b25OYW1lID09PSAncHJldicpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICghcHJvcHMuaXNOZXh0RW5hYmxlZCAmJiBidXR0b25OYW1lID09PSAnbmV4dCcpO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBidXR0b25DbGFzc2VzID0gW2BmYy0ke2J1dHRvbk5hbWV9LWJ1dHRvbmAsIHRoZW1lLmdldENsYXNzKCdidXR0b24nKV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzUHJlc3NlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBidXR0b25DbGFzc2VzLnB1c2godGhlbWUuZ2V0Q2xhc3MoJ2J1dHRvbkFjdGl2ZScpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW4ucHVzaCh5KFwiYnV0dG9uXCIsIHsgdHlwZTogXCJidXR0b25cIiwgdGl0bGU6IHR5cGVvZiBidXR0b25IaW50ID09PSAnZnVuY3Rpb24nID8gYnV0dG9uSGludChwcm9wcy5uYXZVbml0KSA6IGJ1dHRvbkhpbnQsIGRpc2FibGVkOiBpc0Rpc2FibGVkLCBcImFyaWEtcHJlc3NlZFwiOiBpc1ByZXNzZWQsIGNsYXNzTmFtZTogYnV0dG9uQ2xhc3Nlcy5qb2luKCcgJyksIG9uQ2xpY2s6IGJ1dHRvbkNsaWNrIH0sIGJ1dHRvblRleHQgfHwgKGJ1dHRvbkljb24gPyB5KFwic3BhblwiLCB7IGNsYXNzTmFtZTogYnV0dG9uSWNvbiB9KSA6ICcnKSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgZ3JvdXBDbGFzc05hbWUgPSAoaXNPbmx5QnV0dG9ucyAmJiB0aGVtZS5nZXRDbGFzcygnYnV0dG9uR3JvdXAnKSkgfHwgJyc7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4geSgnZGl2JywgeyBjbGFzc05hbWU6IGdyb3VwQ2xhc3NOYW1lIH0sIC4uLmNoaWxkcmVuKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gY2hpbGRyZW5bMF07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNsYXNzIFRvb2xiYXIgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcclxuICAgICAgICByZW5kZXIoKSB7XHJcbiAgICAgICAgICAgIGxldCB7IG1vZGVsLCBleHRyYUNsYXNzTmFtZSB9ID0gdGhpcy5wcm9wcztcclxuICAgICAgICAgICAgbGV0IGZvcmNlTHRyID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGxldCBzdGFydENvbnRlbnQ7XHJcbiAgICAgICAgICAgIGxldCBlbmRDb250ZW50O1xyXG4gICAgICAgICAgICBsZXQgc2VjdGlvbldpZGdldHMgPSBtb2RlbC5zZWN0aW9uV2lkZ2V0cztcclxuICAgICAgICAgICAgbGV0IGNlbnRlckNvbnRlbnQgPSBzZWN0aW9uV2lkZ2V0cy5jZW50ZXI7XHJcbiAgICAgICAgICAgIGlmIChzZWN0aW9uV2lkZ2V0cy5sZWZ0KSB7XHJcbiAgICAgICAgICAgICAgICBmb3JjZUx0ciA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBzdGFydENvbnRlbnQgPSBzZWN0aW9uV2lkZ2V0cy5sZWZ0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc3RhcnRDb250ZW50ID0gc2VjdGlvbldpZGdldHMuc3RhcnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHNlY3Rpb25XaWRnZXRzLnJpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICBmb3JjZUx0ciA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBlbmRDb250ZW50ID0gc2VjdGlvbldpZGdldHMucmlnaHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBlbmRDb250ZW50ID0gc2VjdGlvbldpZGdldHMuZW5kO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxldCBjbGFzc05hbWVzID0gW1xyXG4gICAgICAgICAgICAgICAgZXh0cmFDbGFzc05hbWUgfHwgJycsXHJcbiAgICAgICAgICAgICAgICAnZmMtdG9vbGJhcicsXHJcbiAgICAgICAgICAgICAgICBmb3JjZUx0ciA/ICdmYy10b29sYmFyLWx0cicgOiAnJyxcclxuICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgcmV0dXJuICh5KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBjbGFzc05hbWVzLmpvaW4oJyAnKSB9LFxyXG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJTZWN0aW9uKCdzdGFydCcsIHN0YXJ0Q29udGVudCB8fCBbXSksXHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlclNlY3Rpb24oJ2NlbnRlcicsIGNlbnRlckNvbnRlbnQgfHwgW10pLFxyXG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJTZWN0aW9uKCdlbmQnLCBlbmRDb250ZW50IHx8IFtdKSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZW5kZXJTZWN0aW9uKGtleSwgd2lkZ2V0R3JvdXBzKSB7XHJcbiAgICAgICAgICAgIGxldCB7IHByb3BzIH0gPSB0aGlzO1xyXG4gICAgICAgICAgICByZXR1cm4gKHkoVG9vbGJhclNlY3Rpb24sIHsga2V5OiBrZXksIHdpZGdldEdyb3Vwczogd2lkZ2V0R3JvdXBzLCB0aXRsZTogcHJvcHMudGl0bGUsIG5hdlVuaXQ6IHByb3BzLm5hdlVuaXQsIGFjdGl2ZUJ1dHRvbjogcHJvcHMuYWN0aXZlQnV0dG9uLCBpc1RvZGF5RW5hYmxlZDogcHJvcHMuaXNUb2RheUVuYWJsZWQsIGlzUHJldkVuYWJsZWQ6IHByb3BzLmlzUHJldkVuYWJsZWQsIGlzTmV4dEVuYWJsZWQ6IHByb3BzLmlzTmV4dEVuYWJsZWQsIHRpdGxlSWQ6IHByb3BzLnRpdGxlSWQgfSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBjbGFzcyBWaWV3SGFybmVzcyBleHRlbmRzIEJhc2VDb21wb25lbnQge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0ge1xyXG4gICAgICAgICAgICAgICAgYXZhaWxhYmxlV2lkdGg6IG51bGwsXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlRWwgPSAoZWwpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZWwgPSBlbDtcclxuICAgICAgICAgICAgICAgIHNldFJlZih0aGlzLnByb3BzLmVsUmVmLCBlbCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUF2YWlsYWJsZVdpZHRoKCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlUmVzaXplID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVBdmFpbGFibGVXaWR0aCgpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZW5kZXIoKSB7XHJcbiAgICAgICAgICAgIGxldCB7IHByb3BzLCBzdGF0ZSB9ID0gdGhpcztcclxuICAgICAgICAgICAgbGV0IHsgYXNwZWN0UmF0aW8gfSA9IHByb3BzO1xyXG4gICAgICAgICAgICBsZXQgY2xhc3NOYW1lcyA9IFtcclxuICAgICAgICAgICAgICAgICdmYy12aWV3LWhhcm5lc3MnLFxyXG4gICAgICAgICAgICAgICAgKGFzcGVjdFJhdGlvIHx8IHByb3BzLmxpcXVpZCB8fCBwcm9wcy5oZWlnaHQpXHJcbiAgICAgICAgICAgICAgICAgICAgPyAnZmMtdmlldy1oYXJuZXNzLWFjdGl2ZScgLy8gaGFybmVzcyBjb250cm9scyB0aGUgaGVpZ2h0XHJcbiAgICAgICAgICAgICAgICAgICAgOiAnZmMtdmlldy1oYXJuZXNzLXBhc3NpdmUnLCAvLyBsZXQgdGhlIHZpZXcgZG8gdGhlIGhlaWdodFxyXG4gICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICBsZXQgaGVpZ2h0ID0gJyc7XHJcbiAgICAgICAgICAgIGxldCBwYWRkaW5nQm90dG9tID0gJyc7XHJcbiAgICAgICAgICAgIGlmIChhc3BlY3RSYXRpbykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlLmF2YWlsYWJsZVdpZHRoICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0ID0gc3RhdGUuYXZhaWxhYmxlV2lkdGggLyBhc3BlY3RSYXRpbztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHdoaWxlIHdhaXRpbmcgdG8ga25vdyBhdmFpbGFibGVXaWR0aCwgd2UgY2FuJ3Qgc2V0IGhlaWdodCB0byAqemVybypcclxuICAgICAgICAgICAgICAgICAgICAvLyBiZWNhdXNlIHdpbGwgY2F1c2UgbG90cyBvZiB1bm5lY2Vzc2FyeSBzY3JvbGxiYXJzIHdpdGhpbiBzY3JvbGxncmlkLlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEJFVFRFUjogZG9uJ3Qgc3RhcnQgcmVuZGVyaW5nIEFOWVRISU5HIHlldCB1bnRpbCB3ZSBrbm93IGNvbnRhaW5lciB3aWR0aFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIE5PVEU6IHdoeSBub3QgYWx3YXlzIHVzZSBwYWRkaW5nQm90dG9tPyBDYXVzZXMgaGVpZ2h0IG9zY2lsbGF0aW9uIChpc3N1ZSA1NjA2KVxyXG4gICAgICAgICAgICAgICAgICAgIHBhZGRpbmdCb3R0b20gPSBgJHsoMSAvIGFzcGVjdFJhdGlvKSAqIDEwMH0lYDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGhlaWdodCA9IHByb3BzLmhlaWdodCB8fCAnJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gKHkoXCJkaXZcIiwgeyBcImFyaWEtbGFiZWxsZWRieVwiOiBwcm9wcy5sYWJlbGVkQnlJZCwgcmVmOiB0aGlzLmhhbmRsZUVsLCBjbGFzc05hbWU6IGNsYXNzTmFtZXMuam9pbignICcpLCBzdHlsZTogeyBoZWlnaHQsIHBhZGRpbmdCb3R0b20gfSB9LCBwcm9wcy5jaGlsZHJlbikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb21wb25lbnREaWRNb3VudCgpIHtcclxuICAgICAgICAgICAgdGhpcy5jb250ZXh0LmFkZFJlc2l6ZUhhbmRsZXIodGhpcy5oYW5kbGVSZXNpemUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcclxuICAgICAgICAgICAgdGhpcy5jb250ZXh0LnJlbW92ZVJlc2l6ZUhhbmRsZXIodGhpcy5oYW5kbGVSZXNpemUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB1cGRhdGVBdmFpbGFibGVXaWR0aCgpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuZWwgJiYgLy8gbmVlZGVkLiBidXQgd2h5P1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5hc3BlY3RSYXRpbyAvLyBhc3BlY3RSYXRpbyBpcyB0aGUgb25seSBoZWlnaHQgc2V0dGluZyB0aGF0IG5lZWRzIGF2YWlsYWJsZVdpZHRoXHJcbiAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IGF2YWlsYWJsZVdpZHRoOiB0aGlzLmVsLm9mZnNldFdpZHRoIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qXHJcbiAgICBEZXRlY3RzIHdoZW4gdGhlIHVzZXIgY2xpY2tzIG9uIGFuIGV2ZW50IHdpdGhpbiBhIERhdGVDb21wb25lbnRcclxuICAgICovXHJcbiAgICBjbGFzcyBFdmVudENsaWNraW5nIGV4dGVuZHMgSW50ZXJhY3Rpb24ge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yKHNldHRpbmdzKSB7XHJcbiAgICAgICAgICAgIHN1cGVyKHNldHRpbmdzKTtcclxuICAgICAgICAgICAgdGhpcy5oYW5kbGVTZWdDbGljayA9IChldiwgc2VnRWwpID0+IHtcclxuICAgICAgICAgICAgICAgIGxldCB7IGNvbXBvbmVudCB9ID0gdGhpcztcclxuICAgICAgICAgICAgICAgIGxldCB7IGNvbnRleHQgfSA9IGNvbXBvbmVudDtcclxuICAgICAgICAgICAgICAgIGxldCBzZWcgPSBnZXRFbFNlZyhzZWdFbCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2VnICYmIC8vIG1pZ2h0IGJlIHRoZSA8ZGl2PiBzdXJyb3VuZGluZyB0aGUgbW9yZSBsaW5rXHJcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50LmlzVmFsaWRTZWdEb3duRWwoZXYudGFyZ2V0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIG91ciB3YXkgdG8gc2ltdWxhdGUgYSBsaW5rIGNsaWNrIGZvciBlbGVtZW50cyB0aGF0IGNhbid0IGJlIDxhPiB0YWdzXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZ3JhYiBiZWZvcmUgdHJpZ2dlciBmaXJlZCBpbiBjYXNlIHRyaWdnZXIgdHJhc2hlcyBET00gdGhydSByZXJlbmRlcmluZ1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBoYXNVcmxDb250YWluZXIgPSBlbGVtZW50Q2xvc2VzdChldi50YXJnZXQsICcuZmMtZXZlbnQtZm9yY2VkLXVybCcpO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCB1cmwgPSBoYXNVcmxDb250YWluZXIgPyBoYXNVcmxDb250YWluZXIucXVlcnlTZWxlY3RvcignYVtocmVmXScpLmhyZWYgOiAnJztcclxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmVtaXR0ZXIudHJpZ2dlcignZXZlbnRDbGljaycsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWw6IHNlZ0VsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudDogbmV3IEV2ZW50SW1wbChjb21wb25lbnQuY29udGV4dCwgc2VnLmV2ZW50UmFuZ2UuZGVmLCBzZWcuZXZlbnRSYW5nZS5pbnN0YW5jZSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGpzRXZlbnQ6IGV2LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2aWV3OiBjb250ZXh0LnZpZXdBcGksXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHVybCAmJiAhZXYuZGVmYXVsdFByZXZlbnRlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IHVybDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHRoaXMuZGVzdHJveSA9IGxpc3RlbkJ5U2VsZWN0b3Ioc2V0dGluZ3MuZWwsICdjbGljaycsICcuZmMtZXZlbnQnLCAvLyBvbiBib3RoIGZnIGFuZCBiZyBldmVudHNcclxuICAgICAgICAgICAgdGhpcy5oYW5kbGVTZWdDbGljayk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qXHJcbiAgICBUcmlnZ2VycyBldmVudHMgYW5kIGFkZHMvcmVtb3ZlcyBjb3JlIGNsYXNzTmFtZXMgd2hlbiB0aGUgdXNlcidzIHBvaW50ZXJcclxuICAgIGVudGVycy9sZWF2ZXMgZXZlbnQtZWxlbWVudHMgb2YgYSBjb21wb25lbnQuXHJcbiAgICAqL1xyXG4gICAgY2xhc3MgRXZlbnRIb3ZlcmluZyBleHRlbmRzIEludGVyYWN0aW9uIHtcclxuICAgICAgICBjb25zdHJ1Y3RvcihzZXR0aW5ncykge1xyXG4gICAgICAgICAgICBzdXBlcihzZXR0aW5ncyk7XHJcbiAgICAgICAgICAgIC8vIGZvciBzaW11bGF0aW5nIGFuIGV2ZW50TW91c2VMZWF2ZSB3aGVuIHRoZSBldmVudCBlbCBpcyBkZXN0cm95ZWQgd2hpbGUgbW91c2UgaXMgb3ZlciBpdFxyXG4gICAgICAgICAgICB0aGlzLmhhbmRsZUV2ZW50RWxSZW1vdmUgPSAoZWwpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChlbCA9PT0gdGhpcy5jdXJyZW50U2VnRWwpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVNlZ0xlYXZlKG51bGwsIHRoaXMuY3VycmVudFNlZ0VsKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdGhpcy5oYW5kbGVTZWdFbnRlciA9IChldiwgc2VnRWwpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChnZXRFbFNlZyhzZWdFbCkpIHsgLy8gVE9ETzogYmV0dGVyIHdheSB0byBtYWtlIHN1cmUgbm90IGhvdmVyaW5nIG92ZXIgbW9yZSsgbGluayBvciBpdHMgd3JhcHBlclxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFNlZ0VsID0gc2VnRWw7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyRXZlbnQoJ2V2ZW50TW91c2VFbnRlcicsIGV2LCBzZWdFbCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlU2VnTGVhdmUgPSAoZXYsIHNlZ0VsKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50U2VnRWwpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRTZWdFbCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyRXZlbnQoJ2V2ZW50TW91c2VMZWF2ZScsIGV2LCBzZWdFbCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlSG92ZXJMaXN0ZW5lcnMgPSBsaXN0ZW5Ub0hvdmVyQnlTZWxlY3RvcihzZXR0aW5ncy5lbCwgJy5mYy1ldmVudCcsIC8vIG9uIGJvdGggZmcgYW5kIGJnIGV2ZW50c1xyXG4gICAgICAgICAgICB0aGlzLmhhbmRsZVNlZ0VudGVyLCB0aGlzLmhhbmRsZVNlZ0xlYXZlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZGVzdHJveSgpIHtcclxuICAgICAgICAgICAgdGhpcy5yZW1vdmVIb3Zlckxpc3RlbmVycygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0cmlnZ2VyRXZlbnQocHVibGljRXZOYW1lLCBldiwgc2VnRWwpIHtcclxuICAgICAgICAgICAgbGV0IHsgY29tcG9uZW50IH0gPSB0aGlzO1xyXG4gICAgICAgICAgICBsZXQgeyBjb250ZXh0IH0gPSBjb21wb25lbnQ7XHJcbiAgICAgICAgICAgIGxldCBzZWcgPSBnZXRFbFNlZyhzZWdFbCk7XHJcbiAgICAgICAgICAgIGlmICghZXYgfHwgY29tcG9uZW50LmlzVmFsaWRTZWdEb3duRWwoZXYudGFyZ2V0KSkge1xyXG4gICAgICAgICAgICAgICAgY29udGV4dC5lbWl0dGVyLnRyaWdnZXIocHVibGljRXZOYW1lLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgZWw6IHNlZ0VsLFxyXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50OiBuZXcgRXZlbnRJbXBsKGNvbnRleHQsIHNlZy5ldmVudFJhbmdlLmRlZiwgc2VnLmV2ZW50UmFuZ2UuaW5zdGFuY2UpLFxyXG4gICAgICAgICAgICAgICAgICAgIGpzRXZlbnQ6IGV2LFxyXG4gICAgICAgICAgICAgICAgICAgIHZpZXc6IGNvbnRleHQudmlld0FwaSxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNsYXNzIENhbGVuZGFyQ29udGVudCBleHRlbmRzIFB1cmVDb21wb25lbnQge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgICAgICB0aGlzLmJ1aWxkVmlld0NvbnRleHQgPSBtZW1vaXplKGJ1aWxkVmlld0NvbnRleHQpO1xyXG4gICAgICAgICAgICB0aGlzLmJ1aWxkVmlld1Byb3BUcmFuc2Zvcm1lcnMgPSBtZW1vaXplKGJ1aWxkVmlld1Byb3BUcmFuc2Zvcm1lcnMpO1xyXG4gICAgICAgICAgICB0aGlzLmJ1aWxkVG9vbGJhclByb3BzID0gbWVtb2l6ZShidWlsZFRvb2xiYXJQcm9wcyk7XHJcbiAgICAgICAgICAgIHRoaXMuaGVhZGVyUmVmID0gZCgpO1xyXG4gICAgICAgICAgICB0aGlzLmZvb3RlclJlZiA9IGQoKTtcclxuICAgICAgICAgICAgdGhpcy5pbnRlcmFjdGlvbnNTdG9yZSA9IHt9O1xyXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IHtcclxuICAgICAgICAgICAgICAgIHZpZXdMYWJlbElkOiBnZXRVbmlxdWVEb21JZCgpLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvLyBDb21wb25lbnQgUmVnaXN0cmF0aW9uXHJcbiAgICAgICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAgICAgICAgIHRoaXMucmVnaXN0ZXJJbnRlcmFjdGl2ZUNvbXBvbmVudCA9IChjb21wb25lbnQsIHNldHRpbmdzSW5wdXQpID0+IHtcclxuICAgICAgICAgICAgICAgIGxldCBzZXR0aW5ncyA9IHBhcnNlSW50ZXJhY3Rpb25TZXR0aW5ncyhjb21wb25lbnQsIHNldHRpbmdzSW5wdXQpO1xyXG4gICAgICAgICAgICAgICAgbGV0IERFRkFVTFRfSU5URVJBQ1RJT05TID0gW1xyXG4gICAgICAgICAgICAgICAgICAgIEV2ZW50Q2xpY2tpbmcsXHJcbiAgICAgICAgICAgICAgICAgICAgRXZlbnRIb3ZlcmluZyxcclxuICAgICAgICAgICAgICAgIF07XHJcbiAgICAgICAgICAgICAgICBsZXQgaW50ZXJhY3Rpb25DbGFzc2VzID0gREVGQVVMVF9JTlRFUkFDVElPTlMuY29uY2F0KHRoaXMucHJvcHMucGx1Z2luSG9va3MuY29tcG9uZW50SW50ZXJhY3Rpb25zKTtcclxuICAgICAgICAgICAgICAgIGxldCBpbnRlcmFjdGlvbnMgPSBpbnRlcmFjdGlvbkNsYXNzZXMubWFwKChUaGVJbnRlcmFjdGlvbkNsYXNzKSA9PiBuZXcgVGhlSW50ZXJhY3Rpb25DbGFzcyhzZXR0aW5ncykpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbnRlcmFjdGlvbnNTdG9yZVtjb21wb25lbnQudWlkXSA9IGludGVyYWN0aW9ucztcclxuICAgICAgICAgICAgICAgIGludGVyYWN0aW9uU2V0dGluZ3NTdG9yZVtjb21wb25lbnQudWlkXSA9IHNldHRpbmdzO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB0aGlzLnVucmVnaXN0ZXJJbnRlcmFjdGl2ZUNvbXBvbmVudCA9IChjb21wb25lbnQpID0+IHtcclxuICAgICAgICAgICAgICAgIGxldCBsaXN0ZW5lcnMgPSB0aGlzLmludGVyYWN0aW9uc1N0b3JlW2NvbXBvbmVudC51aWRdO1xyXG4gICAgICAgICAgICAgICAgaWYgKGxpc3RlbmVycykge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGxpc3RlbmVyIG9mIGxpc3RlbmVycykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lci5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmludGVyYWN0aW9uc1N0b3JlW2NvbXBvbmVudC51aWRdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZGVsZXRlIGludGVyYWN0aW9uU2V0dGluZ3NTdG9yZVtjb21wb25lbnQudWlkXTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLy8gUmVzaXppbmdcclxuICAgICAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgICAgICAgICAgdGhpcy5yZXNpemVSdW5uZXIgPSBuZXcgRGVsYXllZFJ1bm5lcigoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BzLmVtaXR0ZXIudHJpZ2dlcignX3Jlc2l6ZScsIHRydWUpOyAvLyBzaG91bGQgd2luZG93IHJlc2l6ZXMgYmUgY29uc2lkZXJlZCBcImZvcmNlZFwiID9cclxuICAgICAgICAgICAgICAgIHRoaXMucHJvcHMuZW1pdHRlci50cmlnZ2VyKCd3aW5kb3dSZXNpemUnLCB7IHZpZXc6IHRoaXMucHJvcHMudmlld0FwaSB9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlV2luZG93UmVzaXplID0gKGV2KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBsZXQgeyBvcHRpb25zIH0gPSB0aGlzLnByb3BzO1xyXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuaGFuZGxlV2luZG93UmVzaXplICYmXHJcbiAgICAgICAgICAgICAgICAgICAgZXYudGFyZ2V0ID09PSB3aW5kb3cgLy8gYXZvaWQganF1aSBldmVudHNcclxuICAgICAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVzaXplUnVubmVyLnJlcXVlc3Qob3B0aW9ucy53aW5kb3dSZXNpemVEZWxheSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgcmVuZGVycyBJTlNJREUgb2YgYW4gb3V0ZXIgZGl2XHJcbiAgICAgICAgKi9cclxuICAgICAgICByZW5kZXIoKSB7XHJcbiAgICAgICAgICAgIGxldCB7IHByb3BzIH0gPSB0aGlzO1xyXG4gICAgICAgICAgICBsZXQgeyB0b29sYmFyQ29uZmlnLCBvcHRpb25zIH0gPSBwcm9wcztcclxuICAgICAgICAgICAgbGV0IHRvb2xiYXJQcm9wcyA9IHRoaXMuYnVpbGRUb29sYmFyUHJvcHMocHJvcHMudmlld1NwZWMsIHByb3BzLmRhdGVQcm9maWxlLCBwcm9wcy5kYXRlUHJvZmlsZUdlbmVyYXRvciwgcHJvcHMuY3VycmVudERhdGUsIGdldE5vdyhwcm9wcy5vcHRpb25zLm5vdywgcHJvcHMuZGF0ZUVudiksIC8vIFRPRE86IHVzZSBOb3dUaW1lcj8/Pz9cclxuICAgICAgICAgICAgcHJvcHMudmlld1RpdGxlKTtcclxuICAgICAgICAgICAgbGV0IHZpZXdWR3JvdyA9IGZhbHNlO1xyXG4gICAgICAgICAgICBsZXQgdmlld0hlaWdodCA9ICcnO1xyXG4gICAgICAgICAgICBsZXQgdmlld0FzcGVjdFJhdGlvO1xyXG4gICAgICAgICAgICBpZiAocHJvcHMuaXNIZWlnaHRBdXRvIHx8IHByb3BzLmZvclByaW50KSB7XHJcbiAgICAgICAgICAgICAgICB2aWV3SGVpZ2h0ID0gJyc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAob3B0aW9ucy5oZWlnaHQgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgdmlld1ZHcm93ID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChvcHRpb25zLmNvbnRlbnRIZWlnaHQgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgdmlld0hlaWdodCA9IG9wdGlvbnMuY29udGVudEhlaWdodDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZpZXdBc3BlY3RSYXRpbyA9IE1hdGgubWF4KG9wdGlvbnMuYXNwZWN0UmF0aW8sIDAuNSk7IC8vIHByZXZlbnQgZnJvbSBnZXR0aW5nIHRvbyB0YWxsXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IHZpZXdDb250ZXh0ID0gdGhpcy5idWlsZFZpZXdDb250ZXh0KHByb3BzLnZpZXdTcGVjLCBwcm9wcy52aWV3QXBpLCBwcm9wcy5vcHRpb25zLCBwcm9wcy5kYXRlUHJvZmlsZUdlbmVyYXRvciwgcHJvcHMuZGF0ZUVudiwgcHJvcHMudGhlbWUsIHByb3BzLnBsdWdpbkhvb2tzLCBwcm9wcy5kaXNwYXRjaCwgcHJvcHMuZ2V0Q3VycmVudERhdGEsIHByb3BzLmVtaXR0ZXIsIHByb3BzLmNhbGVuZGFyQXBpLCB0aGlzLnJlZ2lzdGVySW50ZXJhY3RpdmVDb21wb25lbnQsIHRoaXMudW5yZWdpc3RlckludGVyYWN0aXZlQ29tcG9uZW50KTtcclxuICAgICAgICAgICAgbGV0IHZpZXdMYWJlbElkID0gKHRvb2xiYXJDb25maWcuaGVhZGVyICYmIHRvb2xiYXJDb25maWcuaGVhZGVyLmhhc1RpdGxlKVxyXG4gICAgICAgICAgICAgICAgPyB0aGlzLnN0YXRlLnZpZXdMYWJlbElkXHJcbiAgICAgICAgICAgICAgICA6ICcnO1xyXG4gICAgICAgICAgICByZXR1cm4gKHkoVmlld0NvbnRleHRUeXBlLlByb3ZpZGVyLCB7IHZhbHVlOiB2aWV3Q29udGV4dCB9LFxyXG4gICAgICAgICAgICAgICAgdG9vbGJhckNvbmZpZy5oZWFkZXIgJiYgKHkoVG9vbGJhciwgT2JqZWN0LmFzc2lnbih7IHJlZjogdGhpcy5oZWFkZXJSZWYsIGV4dHJhQ2xhc3NOYW1lOiBcImZjLWhlYWRlci10b29sYmFyXCIsIG1vZGVsOiB0b29sYmFyQ29uZmlnLmhlYWRlciwgdGl0bGVJZDogdmlld0xhYmVsSWQgfSwgdG9vbGJhclByb3BzKSkpLFxyXG4gICAgICAgICAgICAgICAgeShWaWV3SGFybmVzcywgeyBsaXF1aWQ6IHZpZXdWR3JvdywgaGVpZ2h0OiB2aWV3SGVpZ2h0LCBhc3BlY3RSYXRpbzogdmlld0FzcGVjdFJhdGlvLCBsYWJlbGVkQnlJZDogdmlld0xhYmVsSWQgfSxcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlclZpZXcocHJvcHMpLFxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYnVpbGRBcHBlbmRDb250ZW50KCkpLFxyXG4gICAgICAgICAgICAgICAgdG9vbGJhckNvbmZpZy5mb290ZXIgJiYgKHkoVG9vbGJhciwgT2JqZWN0LmFzc2lnbih7IHJlZjogdGhpcy5mb290ZXJSZWYsIGV4dHJhQ2xhc3NOYW1lOiBcImZjLWZvb3Rlci10b29sYmFyXCIsIG1vZGVsOiB0b29sYmFyQ29uZmlnLmZvb3RlciwgdGl0bGVJZDogXCJcIiB9LCB0b29sYmFyUHJvcHMpKSkpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29tcG9uZW50RGlkTW91bnQoKSB7XHJcbiAgICAgICAgICAgIGxldCB7IHByb3BzIH0gPSB0aGlzO1xyXG4gICAgICAgICAgICB0aGlzLmNhbGVuZGFySW50ZXJhY3Rpb25zID0gcHJvcHMucGx1Z2luSG9va3MuY2FsZW5kYXJJbnRlcmFjdGlvbnNcclxuICAgICAgICAgICAgICAgIC5tYXAoKENhbGVuZGFySW50ZXJhY3Rpb25DbGFzcykgPT4gbmV3IENhbGVuZGFySW50ZXJhY3Rpb25DbGFzcyhwcm9wcykpO1xyXG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5oYW5kbGVXaW5kb3dSZXNpemUpO1xyXG4gICAgICAgICAgICBsZXQgeyBwcm9wU2V0SGFuZGxlcnMgfSA9IHByb3BzLnBsdWdpbkhvb2tzO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBwcm9wTmFtZSBpbiBwcm9wU2V0SGFuZGxlcnMpIHtcclxuICAgICAgICAgICAgICAgIHByb3BTZXRIYW5kbGVyc1twcm9wTmFtZV0ocHJvcHNbcHJvcE5hbWVdLCBwcm9wcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcykge1xyXG4gICAgICAgICAgICBsZXQgeyBwcm9wcyB9ID0gdGhpcztcclxuICAgICAgICAgICAgbGV0IHsgcHJvcFNldEhhbmRsZXJzIH0gPSBwcm9wcy5wbHVnaW5Ib29rcztcclxuICAgICAgICAgICAgZm9yIChsZXQgcHJvcE5hbWUgaW4gcHJvcFNldEhhbmRsZXJzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocHJvcHNbcHJvcE5hbWVdICE9PSBwcmV2UHJvcHNbcHJvcE5hbWVdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvcFNldEhhbmRsZXJzW3Byb3BOYW1lXShwcm9wc1twcm9wTmFtZV0sIHByb3BzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcclxuICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMuaGFuZGxlV2luZG93UmVzaXplKTtcclxuICAgICAgICAgICAgdGhpcy5yZXNpemVSdW5uZXIuY2xlYXIoKTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaW50ZXJhY3Rpb24gb2YgdGhpcy5jYWxlbmRhckludGVyYWN0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgaW50ZXJhY3Rpb24uZGVzdHJveSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMucHJvcHMuZW1pdHRlci50cmlnZ2VyKCdfdW5tb3VudCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBidWlsZEFwcGVuZENvbnRlbnQoKSB7XHJcbiAgICAgICAgICAgIGxldCB7IHByb3BzIH0gPSB0aGlzO1xyXG4gICAgICAgICAgICBsZXQgY2hpbGRyZW4gPSBwcm9wcy5wbHVnaW5Ib29rcy52aWV3Q29udGFpbmVyQXBwZW5kcy5tYXAoKGJ1aWxkQXBwZW5kQ29udGVudCkgPT4gYnVpbGRBcHBlbmRDb250ZW50KHByb3BzKSk7XHJcbiAgICAgICAgICAgIHJldHVybiB5KF8sIHt9LCAuLi5jaGlsZHJlbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlbmRlclZpZXcocHJvcHMpIHtcclxuICAgICAgICAgICAgbGV0IHsgcGx1Z2luSG9va3MgfSA9IHByb3BzO1xyXG4gICAgICAgICAgICBsZXQgeyB2aWV3U3BlYyB9ID0gcHJvcHM7XHJcbiAgICAgICAgICAgIGxldCB2aWV3UHJvcHMgPSB7XHJcbiAgICAgICAgICAgICAgICBkYXRlUHJvZmlsZTogcHJvcHMuZGF0ZVByb2ZpbGUsXHJcbiAgICAgICAgICAgICAgICBidXNpbmVzc0hvdXJzOiBwcm9wcy5idXNpbmVzc0hvdXJzLFxyXG4gICAgICAgICAgICAgICAgZXZlbnRTdG9yZTogcHJvcHMucmVuZGVyYWJsZUV2ZW50U3RvcmUsXHJcbiAgICAgICAgICAgICAgICBldmVudFVpQmFzZXM6IHByb3BzLmV2ZW50VWlCYXNlcyxcclxuICAgICAgICAgICAgICAgIGRhdGVTZWxlY3Rpb246IHByb3BzLmRhdGVTZWxlY3Rpb24sXHJcbiAgICAgICAgICAgICAgICBldmVudFNlbGVjdGlvbjogcHJvcHMuZXZlbnRTZWxlY3Rpb24sXHJcbiAgICAgICAgICAgICAgICBldmVudERyYWc6IHByb3BzLmV2ZW50RHJhZyxcclxuICAgICAgICAgICAgICAgIGV2ZW50UmVzaXplOiBwcm9wcy5ldmVudFJlc2l6ZSxcclxuICAgICAgICAgICAgICAgIGlzSGVpZ2h0QXV0bzogcHJvcHMuaXNIZWlnaHRBdXRvLFxyXG4gICAgICAgICAgICAgICAgZm9yUHJpbnQ6IHByb3BzLmZvclByaW50LFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBsZXQgdHJhbnNmb3JtZXJzID0gdGhpcy5idWlsZFZpZXdQcm9wVHJhbnNmb3JtZXJzKHBsdWdpbkhvb2tzLnZpZXdQcm9wc1RyYW5zZm9ybWVycyk7XHJcbiAgICAgICAgICAgIGZvciAobGV0IHRyYW5zZm9ybWVyIG9mIHRyYW5zZm9ybWVycykge1xyXG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih2aWV3UHJvcHMsIHRyYW5zZm9ybWVyLnRyYW5zZm9ybSh2aWV3UHJvcHMsIHByb3BzKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IFZpZXdDb21wb25lbnQgPSB2aWV3U3BlYy5jb21wb25lbnQ7XHJcbiAgICAgICAgICAgIHJldHVybiAoeShWaWV3Q29tcG9uZW50LCBPYmplY3QuYXNzaWduKHt9LCB2aWV3UHJvcHMpKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYnVpbGRUb29sYmFyUHJvcHModmlld1NwZWMsIGRhdGVQcm9maWxlLCBkYXRlUHJvZmlsZUdlbmVyYXRvciwgY3VycmVudERhdGUsIG5vdywgdGl0bGUpIHtcclxuICAgICAgICAvLyBkb24ndCBmb3JjZSBhbnkgZGF0ZS1wcm9maWxlcyB0byB2YWxpZCBkYXRlIHByb2ZpbGVzICh0aGUgYGZhbHNlYCkgc28gdGhhdCB3ZSBjYW4gdGVsbCBpZiBpdCdzIGludmFsaWRcclxuICAgICAgICBsZXQgdG9kYXlJbmZvID0gZGF0ZVByb2ZpbGVHZW5lcmF0b3IuYnVpbGQobm93LCB1bmRlZmluZWQsIGZhbHNlKTsgLy8gVE9ETzogbmVlZCBgdW5kZWZpbmVkYCBvciBlbHNlIElORklOSVRFIExPT1AgZm9yIHNvbWUgcmVhc29uXHJcbiAgICAgICAgbGV0IHByZXZJbmZvID0gZGF0ZVByb2ZpbGVHZW5lcmF0b3IuYnVpbGRQcmV2KGRhdGVQcm9maWxlLCBjdXJyZW50RGF0ZSwgZmFsc2UpO1xyXG4gICAgICAgIGxldCBuZXh0SW5mbyA9IGRhdGVQcm9maWxlR2VuZXJhdG9yLmJ1aWxkTmV4dChkYXRlUHJvZmlsZSwgY3VycmVudERhdGUsIGZhbHNlKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB0aXRsZSxcclxuICAgICAgICAgICAgYWN0aXZlQnV0dG9uOiB2aWV3U3BlYy50eXBlLFxyXG4gICAgICAgICAgICBuYXZVbml0OiB2aWV3U3BlYy5zaW5nbGVVbml0LFxyXG4gICAgICAgICAgICBpc1RvZGF5RW5hYmxlZDogdG9kYXlJbmZvLmlzVmFsaWQgJiYgIXJhbmdlQ29udGFpbnNNYXJrZXIoZGF0ZVByb2ZpbGUuY3VycmVudFJhbmdlLCBub3cpLFxyXG4gICAgICAgICAgICBpc1ByZXZFbmFibGVkOiBwcmV2SW5mby5pc1ZhbGlkLFxyXG4gICAgICAgICAgICBpc05leHRFbmFibGVkOiBuZXh0SW5mby5pc1ZhbGlkLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICAvLyBQbHVnaW5cclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICBmdW5jdGlvbiBidWlsZFZpZXdQcm9wVHJhbnNmb3JtZXJzKHRoZUNsYXNzZXMpIHtcclxuICAgICAgICByZXR1cm4gdGhlQ2xhc3Nlcy5tYXAoKFRoZUNsYXNzKSA9PiBuZXcgVGhlQ2xhc3MoKSk7XHJcbiAgICB9XHJcblxyXG4gICAgY2xhc3MgQ2FsZW5kYXIgZXh0ZW5kcyBDYWxlbmRhckltcGwge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yKGVsLCBvcHRpb25PdmVycmlkZXMgPSB7fSkge1xyXG4gICAgICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgICAgICB0aGlzLmlzUmVuZGVyaW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuaXNSZW5kZXJlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRDbGFzc05hbWVzID0gW107XHJcbiAgICAgICAgICAgIHRoaXMuY3VzdG9tQ29udGVudFJlbmRlcklkID0gMDtcclxuICAgICAgICAgICAgdGhpcy5oYW5kbGVBY3Rpb24gPSAoYWN0aW9uKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAvLyBhY3Rpb25zIHdlIGtub3cgd2Ugd2FudCB0byByZW5kZXIgaW1tZWRpYXRlbHlcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdTRVRfRVZFTlRfRFJBRyc6XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnU0VUX0VWRU5UX1JFU0laRSc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyUnVubmVyLnRyeURyYWluKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlRGF0YSA9IChkYXRhKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnREYXRhID0gZGF0YTtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyUnVubmVyLnJlcXVlc3QoZGF0YS5jYWxlbmRhck9wdGlvbnMucmVyZW5kZXJEZWxheSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlUmVuZGVyUmVxdWVzdCA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzUmVuZGVyaW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pc1JlbmRlcmVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgeyBjdXJyZW50RGF0YSB9ID0gdGhpcztcclxuICAgICAgICAgICAgICAgICAgICBmbHVzaFN5bmMoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBEJDEoeShDYWxlbmRhclJvb3QsIHsgb3B0aW9uczogY3VycmVudERhdGEuY2FsZW5kYXJPcHRpb25zLCB0aGVtZTogY3VycmVudERhdGEudGhlbWUsIGVtaXR0ZXI6IGN1cnJlbnREYXRhLmVtaXR0ZXIgfSwgKGNsYXNzTmFtZXMsIGhlaWdodCwgaXNIZWlnaHRBdXRvLCBmb3JQcmludCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRDbGFzc05hbWVzKGNsYXNzTmFtZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRIZWlnaHQoaGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoeShSZW5kZXJJZC5Qcm92aWRlciwgeyB2YWx1ZTogdGhpcy5jdXN0b21Db250ZW50UmVuZGVySWQgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5KENhbGVuZGFyQ29udGVudCwgT2JqZWN0LmFzc2lnbih7IGlzSGVpZ2h0QXV0bzogaXNIZWlnaHRBdXRvLCBmb3JQcmludDogZm9yUHJpbnQgfSwgY3VycmVudERhdGEpKSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSwgdGhpcy5lbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLmlzUmVuZGVyZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmlzUmVuZGVyZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICBEJDEobnVsbCwgdGhpcy5lbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRDbGFzc05hbWVzKFtdKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldEhlaWdodCgnJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGVuc3VyZUVsSGFzU3R5bGVzKGVsKTtcclxuICAgICAgICAgICAgdGhpcy5lbCA9IGVsO1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlclJ1bm5lciA9IG5ldyBEZWxheWVkUnVubmVyKHRoaXMuaGFuZGxlUmVuZGVyUmVxdWVzdCk7XHJcbiAgICAgICAgICAgIG5ldyBDYWxlbmRhckRhdGFNYW5hZ2VyKHtcclxuICAgICAgICAgICAgICAgIG9wdGlvbk92ZXJyaWRlcyxcclxuICAgICAgICAgICAgICAgIGNhbGVuZGFyQXBpOiB0aGlzLFxyXG4gICAgICAgICAgICAgICAgb25BY3Rpb246IHRoaXMuaGFuZGxlQWN0aW9uLFxyXG4gICAgICAgICAgICAgICAgb25EYXRhOiB0aGlzLmhhbmRsZURhdGEsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZW5kZXIoKSB7XHJcbiAgICAgICAgICAgIGxldCB3YXNSZW5kZXJpbmcgPSB0aGlzLmlzUmVuZGVyaW5nO1xyXG4gICAgICAgICAgICBpZiAoIXdhc1JlbmRlcmluZykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pc1JlbmRlcmluZyA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmN1c3RvbUNvbnRlbnRSZW5kZXJJZCArPSAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyUnVubmVyLnJlcXVlc3QoKTtcclxuICAgICAgICAgICAgaWYgKHdhc1JlbmRlcmluZykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVTaXplKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZGVzdHJveSgpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaXNSZW5kZXJpbmcpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaXNSZW5kZXJpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyUnVubmVyLnJlcXVlc3QoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB1cGRhdGVTaXplKCkge1xyXG4gICAgICAgICAgICBmbHVzaFN5bmMoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgc3VwZXIudXBkYXRlU2l6ZSgpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYmF0Y2hSZW5kZXJpbmcoZnVuYykge1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlclJ1bm5lci5wYXVzZSgnYmF0Y2hSZW5kZXJpbmcnKTtcclxuICAgICAgICAgICAgZnVuYygpO1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlclJ1bm5lci5yZXN1bWUoJ2JhdGNoUmVuZGVyaW5nJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHBhdXNlUmVuZGVyaW5nKCkge1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlclJ1bm5lci5wYXVzZSgncGF1c2VSZW5kZXJpbmcnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVzdW1lUmVuZGVyaW5nKCkge1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlclJ1bm5lci5yZXN1bWUoJ3BhdXNlUmVuZGVyaW5nJywgdHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlc2V0T3B0aW9ucyhvcHRpb25PdmVycmlkZXMsIGNoYW5nZWRPcHRpb25OYW1lcykge1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnREYXRhTWFuYWdlci5yZXNldE9wdGlvbnMob3B0aW9uT3ZlcnJpZGVzLCBjaGFuZ2VkT3B0aW9uTmFtZXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzZXRDbGFzc05hbWVzKGNsYXNzTmFtZXMpIHtcclxuICAgICAgICAgICAgaWYgKCFpc0FycmF5c0VxdWFsKGNsYXNzTmFtZXMsIHRoaXMuY3VycmVudENsYXNzTmFtZXMpKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgeyBjbGFzc0xpc3QgfSA9IHRoaXMuZWw7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBjbGFzc05hbWUgb2YgdGhpcy5jdXJyZW50Q2xhc3NOYW1lcykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTGlzdC5yZW1vdmUoY2xhc3NOYW1lKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGNsYXNzTmFtZSBvZiBjbGFzc05hbWVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NMaXN0LmFkZChjbGFzc05hbWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50Q2xhc3NOYW1lcyA9IGNsYXNzTmFtZXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgc2V0SGVpZ2h0KGhlaWdodCkge1xyXG4gICAgICAgICAgICBhcHBseVN0eWxlUHJvcCh0aGlzLmVsLCAnaGVpZ2h0JywgaGVpZ2h0KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZm9ybWF0RGF0ZShkYXRlSW5wdXQsIG9wdGlvbnMgPSB7fSkge1xyXG4gICAgICAgIGxldCBkYXRlRW52ID0gYnVpbGREYXRlRW52KG9wdGlvbnMpO1xyXG4gICAgICAgIGxldCBmb3JtYXR0ZXIgPSBjcmVhdGVGb3JtYXR0ZXIob3B0aW9ucyk7XHJcbiAgICAgICAgbGV0IGRhdGVNZXRhID0gZGF0ZUVudi5jcmVhdGVNYXJrZXJNZXRhKGRhdGVJbnB1dCk7XHJcbiAgICAgICAgaWYgKCFkYXRlTWV0YSkgeyAvLyBUT0RPOiB3YXJuaW5nP1xyXG4gICAgICAgICAgICByZXR1cm4gJyc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkYXRlRW52LmZvcm1hdChkYXRlTWV0YS5tYXJrZXIsIGZvcm1hdHRlciwge1xyXG4gICAgICAgICAgICBmb3JjZWRUem86IGRhdGVNZXRhLmZvcmNlZFR6byxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGZvcm1hdFJhbmdlKHN0YXJ0SW5wdXQsIGVuZElucHV0LCBvcHRpb25zKSB7XHJcbiAgICAgICAgbGV0IGRhdGVFbnYgPSBidWlsZERhdGVFbnYodHlwZW9mIG9wdGlvbnMgPT09ICdvYmplY3QnICYmIG9wdGlvbnMgPyBvcHRpb25zIDoge30pOyAvLyBwYXNzIGluIGlmIG5vbi1udWxsIG9iamVjdFxyXG4gICAgICAgIGxldCBmb3JtYXR0ZXIgPSBjcmVhdGVGb3JtYXR0ZXIob3B0aW9ucyk7XHJcbiAgICAgICAgbGV0IHN0YXJ0TWV0YSA9IGRhdGVFbnYuY3JlYXRlTWFya2VyTWV0YShzdGFydElucHV0KTtcclxuICAgICAgICBsZXQgZW5kTWV0YSA9IGRhdGVFbnYuY3JlYXRlTWFya2VyTWV0YShlbmRJbnB1dCk7XHJcbiAgICAgICAgaWYgKCFzdGFydE1ldGEgfHwgIWVuZE1ldGEpIHsgLy8gVE9ETzogd2FybmluZz9cclxuICAgICAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZGF0ZUVudi5mb3JtYXRSYW5nZShzdGFydE1ldGEubWFya2VyLCBlbmRNZXRhLm1hcmtlciwgZm9ybWF0dGVyLCB7XHJcbiAgICAgICAgICAgIGZvcmNlZFN0YXJ0VHpvOiBzdGFydE1ldGEuZm9yY2VkVHpvLFxyXG4gICAgICAgICAgICBmb3JjZWRFbmRUem86IGVuZE1ldGEuZm9yY2VkVHpvLFxyXG4gICAgICAgICAgICBpc0VuZEV4Y2x1c2l2ZTogb3B0aW9ucy5pc0VuZEV4Y2x1c2l2ZSxcclxuICAgICAgICAgICAgZGVmYXVsdFNlcGFyYXRvcjogQkFTRV9PUFRJT05fREVGQVVMVFMuZGVmYXVsdFJhbmdlU2VwYXJhdG9yLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLy8gVE9ETzogbW9yZSBEUlkgYW5kIG9wdGltaXplZFxyXG4gICAgZnVuY3Rpb24gYnVpbGREYXRlRW52KHNldHRpbmdzKSB7XHJcbiAgICAgICAgbGV0IGxvY2FsZSA9IGJ1aWxkTG9jYWxlKHNldHRpbmdzLmxvY2FsZSB8fCAnZW4nLCBvcmdhbml6ZVJhd0xvY2FsZXMoW10pLm1hcCk7IC8vIFRPRE86IGRvbid0IGhhcmRjb2RlICdlbicgZXZlcnl3aGVyZVxyXG4gICAgICAgIHJldHVybiBuZXcgRGF0ZUVudihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyB0aW1lWm9uZTogQkFTRV9PUFRJT05fREVGQVVMVFMudGltZVpvbmUsIGNhbGVuZGFyU3lzdGVtOiAnZ3JlZ29yeScgfSwgc2V0dGluZ3MpLCB7IGxvY2FsZSB9KSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gSEVMUEVSU1xyXG4gICAgLypcclxuICAgIGlmIG5leHREYXlUaHJlc2hvbGQgaXMgc3BlY2lmaWVkLCBzbGljaW5nIGlzIGRvbmUgaW4gYW4gYWxsLWRheSBmYXNoaW9uLlxyXG4gICAgeW91IGNhbiBnZXQgbmV4dERheVRocmVzaG9sZCBmcm9tIGNvbnRleHQubmV4dERheVRocmVzaG9sZFxyXG4gICAgKi9cclxuICAgIGZ1bmN0aW9uIHNsaWNlRXZlbnRzKHByb3BzLCBhbGxEYXkpIHtcclxuICAgICAgICByZXR1cm4gc2xpY2VFdmVudFN0b3JlKHByb3BzLmV2ZW50U3RvcmUsIHByb3BzLmV2ZW50VWlCYXNlcywgcHJvcHMuZGF0ZVByb2ZpbGUuYWN0aXZlUmFuZ2UsIGFsbERheSA/IHByb3BzLm5leHREYXlUaHJlc2hvbGQgOiBudWxsKS5mZztcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCB2ZXJzaW9uID0gJzYuMS44JztcclxuXHJcbiAgICBjb25maWcudG91Y2hNb3VzZUlnbm9yZVdhaXQgPSA1MDA7XHJcbiAgICBsZXQgaWdub3JlTW91c2VEZXB0aCA9IDA7XHJcbiAgICBsZXQgbGlzdGVuZXJDbnQgPSAwO1xyXG4gICAgbGV0IGlzV2luZG93VG91Y2hNb3ZlQ2FuY2VsbGVkID0gZmFsc2U7XHJcbiAgICAvKlxyXG4gICAgVXNlcyBhIFwicG9pbnRlclwiIGFic3RyYWN0aW9uLCB3aGljaCBtb25pdG9ycyBVSSBldmVudHMgZm9yIGJvdGggbW91c2UgYW5kIHRvdWNoLlxyXG4gICAgVHJhY2tzIHdoZW4gdGhlIHBvaW50ZXIgXCJkcmFnc1wiIG9uIGEgY2VydGFpbiBlbGVtZW50LCBtZWFuaW5nIGRvd24rbW92ZSt1cC5cclxuXHJcbiAgICBBbHNvLCB0cmFja3MgaWYgdGhlcmUgd2FzIHRvdWNoLXNjcm9sbGluZy5cclxuICAgIEFsc28sIGNhbiBwcmV2ZW50IHRvdWNoLXNjcm9sbGluZyBmcm9tIGhhcHBlbmluZy5cclxuICAgIEFsc28sIGNhbiBmaXJlIHBvaW50ZXJtb3ZlIGV2ZW50cyB3aGVuIHNjcm9sbGluZyBoYXBwZW5zIHVuZGVybmVhdGgsIGV2ZW4gd2hlbiBubyByZWFsIHBvaW50ZXIgbW92ZW1lbnQuXHJcblxyXG4gICAgZW1pdHM6XHJcbiAgICAtIHBvaW50ZXJkb3duXHJcbiAgICAtIHBvaW50ZXJtb3ZlXHJcbiAgICAtIHBvaW50ZXJ1cFxyXG4gICAgKi9cclxuICAgIGNsYXNzIFBvaW50ZXJEcmFnZ2luZyB7XHJcbiAgICAgICAgY29uc3RydWN0b3IoY29udGFpbmVyRWwpIHtcclxuICAgICAgICAgICAgdGhpcy5zdWJqZWN0RWwgPSBudWxsO1xyXG4gICAgICAgICAgICAvLyBvcHRpb25zIHRoYXQgY2FuIGJlIGRpcmVjdGx5IGFzc2lnbmVkIGJ5IGNhbGxlclxyXG4gICAgICAgICAgICB0aGlzLnNlbGVjdG9yID0gJyc7IC8vIHdpbGwgY2F1c2Ugc3ViamVjdEVsIGluIGFsbCBlbWl0dGVkIGV2ZW50cyB0byBiZSB0aGlzIGVsZW1lbnRcclxuICAgICAgICAgICAgdGhpcy5oYW5kbGVTZWxlY3RvciA9ICcnO1xyXG4gICAgICAgICAgICB0aGlzLnNob3VsZElnbm9yZU1vdmUgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5zaG91bGRXYXRjaFNjcm9sbCA9IHRydWU7IC8vIGZvciBzaW11bGF0aW5nIHBvaW50ZXJtb3ZlIG9uIHNjcm9sbFxyXG4gICAgICAgICAgICAvLyBpbnRlcm5hbCBzdGF0ZXNcclxuICAgICAgICAgICAgdGhpcy5pc0RyYWdnaW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuaXNUb3VjaERyYWdnaW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMud2FzVG91Y2hTY3JvbGwgPSBmYWxzZTtcclxuICAgICAgICAgICAgLy8gTW91c2VcclxuICAgICAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgICAgICAgICB0aGlzLmhhbmRsZU1vdXNlRG93biA9IChldikgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnNob3VsZElnbm9yZU1vdXNlKCkgJiZcclxuICAgICAgICAgICAgICAgICAgICBpc1ByaW1hcnlNb3VzZUJ1dHRvbihldikgJiZcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyeVN0YXJ0KGV2KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBwZXYgPSB0aGlzLmNyZWF0ZUV2ZW50RnJvbU1vdXNlKGV2LCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXR0ZXIudHJpZ2dlcigncG9pbnRlcmRvd24nLCBwZXYpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5pdFNjcm9sbFdhdGNoKHBldik7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLnNob3VsZElnbm9yZU1vdmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5oYW5kbGVNb3VzZU1vdmUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5oYW5kbGVNb3VzZVVwKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdGhpcy5oYW5kbGVNb3VzZU1vdmUgPSAoZXYpID0+IHtcclxuICAgICAgICAgICAgICAgIGxldCBwZXYgPSB0aGlzLmNyZWF0ZUV2ZW50RnJvbU1vdXNlKGV2KTtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVjb3JkQ29vcmRzKHBldik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXR0ZXIudHJpZ2dlcigncG9pbnRlcm1vdmUnLCBwZXYpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB0aGlzLmhhbmRsZU1vdXNlVXAgPSAoZXYpID0+IHtcclxuICAgICAgICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMuaGFuZGxlTW91c2VNb3ZlKTtcclxuICAgICAgICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLmhhbmRsZU1vdXNlVXApO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0dGVyLnRyaWdnZXIoJ3BvaW50ZXJ1cCcsIHRoaXMuY3JlYXRlRXZlbnRGcm9tTW91c2UoZXYpKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2xlYW51cCgpOyAvLyBjYWxsIGxhc3Qgc28gdGhhdCBwb2ludGVydXAgaGFzIGFjY2VzcyB0byBwcm9wc1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvLyBUb3VjaFxyXG4gICAgICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlVG91Y2hTdGFydCA9IChldikgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudHJ5U3RhcnQoZXYpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pc1RvdWNoRHJhZ2dpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBwZXYgPSB0aGlzLmNyZWF0ZUV2ZW50RnJvbVRvdWNoKGV2LCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXR0ZXIudHJpZ2dlcigncG9pbnRlcmRvd24nLCBwZXYpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5pdFNjcm9sbFdhdGNoKHBldik7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdW5saWtlIG1vdXNlLCBuZWVkIHRvIGF0dGFjaCB0byB0YXJnZXQsIG5vdCBkb2N1bWVudFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS80NTc2MDAxNFxyXG4gICAgICAgICAgICAgICAgICAgIGxldCB0YXJnZXRFbCA9IGV2LnRhcmdldDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuc2hvdWxkSWdub3JlTW92ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRFbC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLmhhbmRsZVRvdWNoTW92ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldEVsLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5oYW5kbGVUb3VjaEVuZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0RWwuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hjYW5jZWwnLCB0aGlzLmhhbmRsZVRvdWNoRW5kKTsgLy8gdHJlYXQgaXQgYXMgYSB0b3VjaCBlbmRcclxuICAgICAgICAgICAgICAgICAgICAvLyBhdHRhY2ggYSBoYW5kbGVyIHRvIGdldCBjYWxsZWQgd2hlbiBBTlkgc2Nyb2xsIGFjdGlvbiBoYXBwZW5zIG9uIHRoZSBwYWdlLlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgd2FzIGltcG9zc2libGUgdG8gZG8gd2l0aCBub3JtYWwgb24vb2ZmIGJlY2F1c2UgJ3Njcm9sbCcgZG9lc24ndCBidWJibGUuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzI5NTQ1NjUvOTYzNDJcclxuICAgICAgICAgICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcy5oYW5kbGVUb3VjaFNjcm9sbCwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlVG91Y2hNb3ZlID0gKGV2KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBsZXQgcGV2ID0gdGhpcy5jcmVhdGVFdmVudEZyb21Ub3VjaChldik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlY29yZENvb3JkcyhwZXYpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0dGVyLnRyaWdnZXIoJ3BvaW50ZXJtb3ZlJywgcGV2KTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdGhpcy5oYW5kbGVUb3VjaEVuZCA9IChldikgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNEcmFnZ2luZykgeyAvLyBkb25lIHRvIGd1YXJkIGFnYWluc3QgdG91Y2hlbmQgZm9sbG93ZWQgYnkgdG91Y2hjYW5jZWxcclxuICAgICAgICAgICAgICAgICAgICBsZXQgdGFyZ2V0RWwgPSBldi50YXJnZXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0RWwucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5oYW5kbGVUb3VjaE1vdmUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldEVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5oYW5kbGVUb3VjaEVuZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0RWwucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hjYW5jZWwnLCB0aGlzLmhhbmRsZVRvdWNoRW5kKTtcclxuICAgICAgICAgICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcy5oYW5kbGVUb3VjaFNjcm9sbCwgdHJ1ZSk7IC8vIHVzZUNhcHR1cmVkPXRydWVcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXR0ZXIudHJpZ2dlcigncG9pbnRlcnVwJywgdGhpcy5jcmVhdGVFdmVudEZyb21Ub3VjaChldikpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xlYW51cCgpOyAvLyBjYWxsIGxhc3Qgc28gdGhhdCBwb2ludGVydXAgaGFzIGFjY2VzcyB0byBwcm9wc1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaXNUb3VjaERyYWdnaW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRJZ25vcmluZ01vdXNlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlVG91Y2hTY3JvbGwgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLndhc1RvdWNoU2Nyb2xsID0gdHJ1ZTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdGhpcy5oYW5kbGVTY3JvbGwgPSAoZXYpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5zaG91bGRJZ25vcmVNb3ZlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBhZ2VYID0gKHdpbmRvdy5wYWdlWE9mZnNldCAtIHRoaXMucHJldlNjcm9sbFgpICsgdGhpcy5wcmV2UGFnZVg7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBhZ2VZID0gKHdpbmRvdy5wYWdlWU9mZnNldCAtIHRoaXMucHJldlNjcm9sbFkpICsgdGhpcy5wcmV2UGFnZVk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0dGVyLnRyaWdnZXIoJ3BvaW50ZXJtb3ZlJywge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvcmlnRXZlbnQ6IGV2LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpc1RvdWNoOiB0aGlzLmlzVG91Y2hEcmFnZ2luZyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3ViamVjdEVsOiB0aGlzLnN1YmplY3RFbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFnZVgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2VZLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWx0YVg6IHBhZ2VYIC0gdGhpcy5vcmlnUGFnZVgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbHRhWTogcGFnZVkgLSB0aGlzLm9yaWdQYWdlWSxcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdGhpcy5jb250YWluZXJFbCA9IGNvbnRhaW5lckVsO1xyXG4gICAgICAgICAgICB0aGlzLmVtaXR0ZXIgPSBuZXcgRW1pdHRlcigpO1xyXG4gICAgICAgICAgICBjb250YWluZXJFbC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLmhhbmRsZU1vdXNlRG93bik7XHJcbiAgICAgICAgICAgIGNvbnRhaW5lckVsLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCB0aGlzLmhhbmRsZVRvdWNoU3RhcnQsIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcclxuICAgICAgICAgICAgbGlzdGVuZXJDcmVhdGVkKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRlc3Ryb3koKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyRWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5oYW5kbGVNb3VzZURvd24pO1xyXG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lckVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCB0aGlzLmhhbmRsZVRvdWNoU3RhcnQsIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcclxuICAgICAgICAgICAgbGlzdGVuZXJEZXN0cm95ZWQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdHJ5U3RhcnQoZXYpIHtcclxuICAgICAgICAgICAgbGV0IHN1YmplY3RFbCA9IHRoaXMucXVlcnlTdWJqZWN0RWwoZXYpO1xyXG4gICAgICAgICAgICBsZXQgZG93bkVsID0gZXYudGFyZ2V0O1xyXG4gICAgICAgICAgICBpZiAoc3ViamVjdEVsICYmXHJcbiAgICAgICAgICAgICAgICAoIXRoaXMuaGFuZGxlU2VsZWN0b3IgfHwgZWxlbWVudENsb3Nlc3QoZG93bkVsLCB0aGlzLmhhbmRsZVNlbGVjdG9yKSkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3ViamVjdEVsID0gc3ViamVjdEVsO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pc0RyYWdnaW5nID0gdHJ1ZTsgLy8gZG8gdGhpcyBmaXJzdCBzbyBjYW5jZWxUb3VjaFNjcm9sbCB3aWxsIHdvcmtcclxuICAgICAgICAgICAgICAgIHRoaXMud2FzVG91Y2hTY3JvbGwgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2xlYW51cCgpIHtcclxuICAgICAgICAgICAgaXNXaW5kb3dUb3VjaE1vdmVDYW5jZWxsZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5pc0RyYWdnaW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuc3ViamVjdEVsID0gbnVsbDtcclxuICAgICAgICAgICAgLy8ga2VlcCB3YXNUb3VjaFNjcm9sbCBhcm91bmQgZm9yIGxhdGVyIGFjY2Vzc1xyXG4gICAgICAgICAgICB0aGlzLmRlc3Ryb3lTY3JvbGxXYXRjaCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBxdWVyeVN1YmplY3RFbChldikge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5zZWxlY3Rvcikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnRDbG9zZXN0KGV2LnRhcmdldCwgdGhpcy5zZWxlY3Rvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udGFpbmVyRWw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNob3VsZElnbm9yZU1vdXNlKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gaWdub3JlTW91c2VEZXB0aCB8fCB0aGlzLmlzVG91Y2hEcmFnZ2luZztcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gY2FuIGJlIGNhbGxlZCBieSB1c2VyIG9mIHRoaXMgY2xhc3MsIHRvIGNhbmNlbCB0b3VjaC1iYXNlZCBzY3JvbGxpbmcgZm9yIHRoZSBjdXJyZW50IGRyYWdcclxuICAgICAgICBjYW5jZWxUb3VjaFNjcm9sbCgpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaXNEcmFnZ2luZykge1xyXG4gICAgICAgICAgICAgICAgaXNXaW5kb3dUb3VjaE1vdmVDYW5jZWxsZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFNjcm9sbGluZyB0aGF0IHNpbXVsYXRlcyBwb2ludGVybW92ZXNcclxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAgICAgaW5pdFNjcm9sbFdhdGNoKGV2KSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnNob3VsZFdhdGNoU2Nyb2xsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlY29yZENvb3Jkcyhldik7XHJcbiAgICAgICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcy5oYW5kbGVTY3JvbGwsIHRydWUpOyAvLyB1c2VDYXB0dXJlPXRydWVcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZWNvcmRDb29yZHMoZXYpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuc2hvdWxkV2F0Y2hTY3JvbGwpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucHJldlBhZ2VYID0gZXYucGFnZVg7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnByZXZQYWdlWSA9IGV2LnBhZ2VZO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wcmV2U2Nyb2xsWCA9IHdpbmRvdy5wYWdlWE9mZnNldDtcclxuICAgICAgICAgICAgICAgIHRoaXMucHJldlNjcm9sbFkgPSB3aW5kb3cucGFnZVlPZmZzZXQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZGVzdHJveVNjcm9sbFdhdGNoKCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5zaG91bGRXYXRjaFNjcm9sbCkge1xyXG4gICAgICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMuaGFuZGxlU2Nyb2xsLCB0cnVlKTsgLy8gdXNlQ2FwdHVyZWQ9dHJ1ZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEV2ZW50IE5vcm1hbGl6YXRpb25cclxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAgICAgY3JlYXRlRXZlbnRGcm9tTW91c2UoZXYsIGlzRmlyc3QpIHtcclxuICAgICAgICAgICAgbGV0IGRlbHRhWCA9IDA7XHJcbiAgICAgICAgICAgIGxldCBkZWx0YVkgPSAwO1xyXG4gICAgICAgICAgICAvLyBUT0RPOiByZXBlYXQgY29kZVxyXG4gICAgICAgICAgICBpZiAoaXNGaXJzdCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vcmlnUGFnZVggPSBldi5wYWdlWDtcclxuICAgICAgICAgICAgICAgIHRoaXMub3JpZ1BhZ2VZID0gZXYucGFnZVk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBkZWx0YVggPSBldi5wYWdlWCAtIHRoaXMub3JpZ1BhZ2VYO1xyXG4gICAgICAgICAgICAgICAgZGVsdGFZID0gZXYucGFnZVkgLSB0aGlzLm9yaWdQYWdlWTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgb3JpZ0V2ZW50OiBldixcclxuICAgICAgICAgICAgICAgIGlzVG91Y2g6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgc3ViamVjdEVsOiB0aGlzLnN1YmplY3RFbCxcclxuICAgICAgICAgICAgICAgIHBhZ2VYOiBldi5wYWdlWCxcclxuICAgICAgICAgICAgICAgIHBhZ2VZOiBldi5wYWdlWSxcclxuICAgICAgICAgICAgICAgIGRlbHRhWCxcclxuICAgICAgICAgICAgICAgIGRlbHRhWSxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY3JlYXRlRXZlbnRGcm9tVG91Y2goZXYsIGlzRmlyc3QpIHtcclxuICAgICAgICAgICAgbGV0IHRvdWNoZXMgPSBldi50b3VjaGVzO1xyXG4gICAgICAgICAgICBsZXQgcGFnZVg7XHJcbiAgICAgICAgICAgIGxldCBwYWdlWTtcclxuICAgICAgICAgICAgbGV0IGRlbHRhWCA9IDA7XHJcbiAgICAgICAgICAgIGxldCBkZWx0YVkgPSAwO1xyXG4gICAgICAgICAgICAvLyBpZiB0b3VjaCBjb29yZHMgYXZhaWxhYmxlLCBwcmVmZXIsXHJcbiAgICAgICAgICAgIC8vIGJlY2F1c2UgRkYgd291bGQgZ2l2ZSBiYWQgZXYucGFnZVggZXYucGFnZVlcclxuICAgICAgICAgICAgaWYgKHRvdWNoZXMgJiYgdG91Y2hlcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHBhZ2VYID0gdG91Y2hlc1swXS5wYWdlWDtcclxuICAgICAgICAgICAgICAgIHBhZ2VZID0gdG91Y2hlc1swXS5wYWdlWTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHBhZ2VYID0gZXYucGFnZVg7XHJcbiAgICAgICAgICAgICAgICBwYWdlWSA9IGV2LnBhZ2VZO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFRPRE86IHJlcGVhdCBjb2RlXHJcbiAgICAgICAgICAgIGlmIChpc0ZpcnN0KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9yaWdQYWdlWCA9IHBhZ2VYO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vcmlnUGFnZVkgPSBwYWdlWTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGRlbHRhWCA9IHBhZ2VYIC0gdGhpcy5vcmlnUGFnZVg7XHJcbiAgICAgICAgICAgICAgICBkZWx0YVkgPSBwYWdlWSAtIHRoaXMub3JpZ1BhZ2VZO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBvcmlnRXZlbnQ6IGV2LFxyXG4gICAgICAgICAgICAgICAgaXNUb3VjaDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIHN1YmplY3RFbDogdGhpcy5zdWJqZWN0RWwsXHJcbiAgICAgICAgICAgICAgICBwYWdlWCxcclxuICAgICAgICAgICAgICAgIHBhZ2VZLFxyXG4gICAgICAgICAgICAgICAgZGVsdGFYLFxyXG4gICAgICAgICAgICAgICAgZGVsdGFZLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIFJldHVybnMgYSBib29sZWFuIHdoZXRoZXIgdGhpcyB3YXMgYSBsZWZ0IG1vdXNlIGNsaWNrIGFuZCBubyBjdHJsIGtleSAod2hpY2ggbWVhbnMgcmlnaHQgY2xpY2sgb24gTWFjKVxyXG4gICAgZnVuY3Rpb24gaXNQcmltYXJ5TW91c2VCdXR0b24oZXYpIHtcclxuICAgICAgICByZXR1cm4gZXYuYnV0dG9uID09PSAwICYmICFldi5jdHJsS2V5O1xyXG4gICAgfVxyXG4gICAgLy8gSWdub3JpbmcgZmFrZSBtb3VzZSBldmVudHMgZ2VuZXJhdGVkIGJ5IHRvdWNoXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICBmdW5jdGlvbiBzdGFydElnbm9yaW5nTW91c2UoKSB7XHJcbiAgICAgICAgaWdub3JlTW91c2VEZXB0aCArPSAxO1xyXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICBpZ25vcmVNb3VzZURlcHRoIC09IDE7XHJcbiAgICAgICAgfSwgY29uZmlnLnRvdWNoTW91c2VJZ25vcmVXYWl0KTtcclxuICAgIH1cclxuICAgIC8vIFdlIHdhbnQgdG8gYXR0YWNoIHRvdWNobW92ZSBhcyBlYXJseSBhcyBwb3NzaWJsZSBmb3IgU2FmYXJpXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICBmdW5jdGlvbiBsaXN0ZW5lckNyZWF0ZWQoKSB7XHJcbiAgICAgICAgbGlzdGVuZXJDbnQgKz0gMTtcclxuICAgICAgICBpZiAobGlzdGVuZXJDbnQgPT09IDEpIHtcclxuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIG9uV2luZG93VG91Y2hNb3ZlLCB7IHBhc3NpdmU6IGZhbHNlIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGxpc3RlbmVyRGVzdHJveWVkKCkge1xyXG4gICAgICAgIGxpc3RlbmVyQ250IC09IDE7XHJcbiAgICAgICAgaWYgKCFsaXN0ZW5lckNudCkge1xyXG4gICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgb25XaW5kb3dUb3VjaE1vdmUsIHsgcGFzc2l2ZTogZmFsc2UgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gb25XaW5kb3dUb3VjaE1vdmUoZXYpIHtcclxuICAgICAgICBpZiAoaXNXaW5kb3dUb3VjaE1vdmVDYW5jZWxsZWQpIHtcclxuICAgICAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLypcclxuICAgIEFuIGVmZmVjdCBpbiB3aGljaCBhbiBlbGVtZW50IGZvbGxvd3MgdGhlIG1vdmVtZW50IG9mIGEgcG9pbnRlciBhY3Jvc3MgdGhlIHNjcmVlbi5cclxuICAgIFRoZSBtb3ZpbmcgZWxlbWVudCBpcyBhIGNsb25lIG9mIHNvbWUgb3RoZXIgZWxlbWVudC5cclxuICAgIE11c3QgY2FsbCBzdGFydCArIGhhbmRsZU1vdmUgKyBzdG9wLlxyXG4gICAgKi9cclxuICAgIGNsYXNzIEVsZW1lbnRNaXJyb3Ige1xyXG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgICAgICB0aGlzLmlzVmlzaWJsZSA9IGZhbHNlOyAvLyBtdXN0IGJlIGV4cGxpY2l0bHkgZW5hYmxlZFxyXG4gICAgICAgICAgICB0aGlzLnNvdXJjZUVsID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5taXJyb3JFbCA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMuc291cmNlRWxSZWN0ID0gbnVsbDsgLy8gc2NyZWVuIGNvb3JkcyByZWxhdGl2ZSB0byB2aWV3cG9ydFxyXG4gICAgICAgICAgICAvLyBvcHRpb25zIHRoYXQgY2FuIGJlIHNldCBkaXJlY3RseSBieSBjYWxsZXJcclxuICAgICAgICAgICAgdGhpcy5wYXJlbnROb2RlID0gZG9jdW1lbnQuYm9keTsgLy8gSElHSExZIFNVR0dFU1RFRCB0byBzZXQgdGhpcyB0byBzaWRlc3RlcCBTaGFkb3dET00gaXNzdWVzXHJcbiAgICAgICAgICAgIHRoaXMuekluZGV4ID0gOTk5OTtcclxuICAgICAgICAgICAgdGhpcy5yZXZlcnREdXJhdGlvbiA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN0YXJ0KHNvdXJjZUVsLCBwYWdlWCwgcGFnZVkpIHtcclxuICAgICAgICAgICAgdGhpcy5zb3VyY2VFbCA9IHNvdXJjZUVsO1xyXG4gICAgICAgICAgICB0aGlzLnNvdXJjZUVsUmVjdCA9IHRoaXMuc291cmNlRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICAgICAgICAgIHRoaXMub3JpZ1NjcmVlblggPSBwYWdlWCAtIHdpbmRvdy5wYWdlWE9mZnNldDtcclxuICAgICAgICAgICAgdGhpcy5vcmlnU2NyZWVuWSA9IHBhZ2VZIC0gd2luZG93LnBhZ2VZT2Zmc2V0O1xyXG4gICAgICAgICAgICB0aGlzLmRlbHRhWCA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuZGVsdGFZID0gMDtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVFbFBvc2l0aW9uKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGhhbmRsZU1vdmUocGFnZVgsIHBhZ2VZKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGVsdGFYID0gKHBhZ2VYIC0gd2luZG93LnBhZ2VYT2Zmc2V0KSAtIHRoaXMub3JpZ1NjcmVlblg7XHJcbiAgICAgICAgICAgIHRoaXMuZGVsdGFZID0gKHBhZ2VZIC0gd2luZG93LnBhZ2VZT2Zmc2V0KSAtIHRoaXMub3JpZ1NjcmVlblk7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlRWxQb3NpdGlvbigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBjYW4gYmUgY2FsbGVkIGJlZm9yZSBzdGFydFxyXG4gICAgICAgIHNldElzVmlzaWJsZShib29sKSB7XHJcbiAgICAgICAgICAgIGlmIChib29sKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaXNWaXNpYmxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubWlycm9yRWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5taXJyb3JFbC5zdHlsZS5kaXNwbGF5ID0gJyc7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaXNWaXNpYmxlID0gYm9vbDsgLy8gbmVlZHMgdG8gaGFwcGVuIGJlZm9yZSB1cGRhdGVFbFBvc2l0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVFbFBvc2l0aW9uKCk7IC8vIGJlY2F1c2Ugd2FzIG5vdCB1cGRhdGluZyB0aGUgcG9zaXRpb24gd2hpbGUgaW52aXNpYmxlXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5pc1Zpc2libGUpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm1pcnJvckVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5taXJyb3JFbC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5pc1Zpc2libGUgPSBib29sO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGFsd2F5cyBhc3luY1xyXG4gICAgICAgIHN0b3AobmVlZHNSZXZlcnRBbmltYXRpb24sIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgIGxldCBkb25lID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhbnVwKCk7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBpZiAobmVlZHNSZXZlcnRBbmltYXRpb24gJiZcclxuICAgICAgICAgICAgICAgIHRoaXMubWlycm9yRWwgJiZcclxuICAgICAgICAgICAgICAgIHRoaXMuaXNWaXNpYmxlICYmXHJcbiAgICAgICAgICAgICAgICB0aGlzLnJldmVydER1cmF0aW9uICYmIC8vIGlmIDAsIHRyYW5zaXRpb24gd29uJ3Qgd29ya1xyXG4gICAgICAgICAgICAgICAgKHRoaXMuZGVsdGFYIHx8IHRoaXMuZGVsdGFZKSAvLyBpZiBzYW1lIGNvb3JkcywgdHJhbnNpdGlvbiB3b24ndCB3b3JrXHJcbiAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kb1JldmVydEFuaW1hdGlvbihkb25lLCB0aGlzLnJldmVydER1cmF0aW9uKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZG9uZSwgMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZG9SZXZlcnRBbmltYXRpb24oY2FsbGJhY2ssIHJldmVydER1cmF0aW9uKSB7XHJcbiAgICAgICAgICAgIGxldCBtaXJyb3JFbCA9IHRoaXMubWlycm9yRWw7XHJcbiAgICAgICAgICAgIGxldCBmaW5hbFNvdXJjZUVsUmVjdCA9IHRoaXMuc291cmNlRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7IC8vIGJlY2F1c2UgYXV0b3Njcm9sbGluZyBtaWdodCBoYXZlIGhhcHBlbmVkXHJcbiAgICAgICAgICAgIG1pcnJvckVsLnN0eWxlLnRyYW5zaXRpb24gPVxyXG4gICAgICAgICAgICAgICAgJ3RvcCAnICsgcmV2ZXJ0RHVyYXRpb24gKyAnbXMsJyArXHJcbiAgICAgICAgICAgICAgICAgICAgJ2xlZnQgJyArIHJldmVydER1cmF0aW9uICsgJ21zJztcclxuICAgICAgICAgICAgYXBwbHlTdHlsZShtaXJyb3JFbCwge1xyXG4gICAgICAgICAgICAgICAgbGVmdDogZmluYWxTb3VyY2VFbFJlY3QubGVmdCxcclxuICAgICAgICAgICAgICAgIHRvcDogZmluYWxTb3VyY2VFbFJlY3QudG9wLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgd2hlblRyYW5zaXRpb25Eb25lKG1pcnJvckVsLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBtaXJyb3JFbC5zdHlsZS50cmFuc2l0aW9uID0gJyc7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2xlYW51cCgpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMubWlycm9yRWwpIHtcclxuICAgICAgICAgICAgICAgIHJlbW92ZUVsZW1lbnQodGhpcy5taXJyb3JFbCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1pcnJvckVsID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnNvdXJjZUVsID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdXBkYXRlRWxQb3NpdGlvbigpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuc291cmNlRWwgJiYgdGhpcy5pc1Zpc2libGUpIHtcclxuICAgICAgICAgICAgICAgIGFwcGx5U3R5bGUodGhpcy5nZXRNaXJyb3JFbCgpLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogdGhpcy5zb3VyY2VFbFJlY3QubGVmdCArIHRoaXMuZGVsdGFYLFxyXG4gICAgICAgICAgICAgICAgICAgIHRvcDogdGhpcy5zb3VyY2VFbFJlY3QudG9wICsgdGhpcy5kZWx0YVksXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBnZXRNaXJyb3JFbCgpIHtcclxuICAgICAgICAgICAgbGV0IHNvdXJjZUVsUmVjdCA9IHRoaXMuc291cmNlRWxSZWN0O1xyXG4gICAgICAgICAgICBsZXQgbWlycm9yRWwgPSB0aGlzLm1pcnJvckVsO1xyXG4gICAgICAgICAgICBpZiAoIW1pcnJvckVsKSB7XHJcbiAgICAgICAgICAgICAgICBtaXJyb3JFbCA9IHRoaXMubWlycm9yRWwgPSB0aGlzLnNvdXJjZUVsLmNsb25lTm9kZSh0cnVlKTsgLy8gY2xvbmVDaGlsZHJlbj10cnVlXHJcbiAgICAgICAgICAgICAgICAvLyB3ZSBkb24ndCB3YW50IGxvbmcgdGFwcyBvciBhbnkgbW91c2UgaW50ZXJhY3Rpb24gY2F1c2luZyBzZWxlY3Rpb24vbWVudXMuXHJcbiAgICAgICAgICAgICAgICAvLyB3b3VsZCB1c2UgcHJldmVudFNlbGVjdGlvbigpLCBidXQgdGhhdCBwcmV2ZW50cyBzZWxlY3RzdGFydCwgY2F1c2luZyBwcm9ibGVtcy5cclxuICAgICAgICAgICAgICAgIG1pcnJvckVsLnN0eWxlLnVzZXJTZWxlY3QgPSAnbm9uZSc7XHJcbiAgICAgICAgICAgICAgICBtaXJyb3JFbC5jbGFzc0xpc3QuYWRkKCdmYy1ldmVudC1kcmFnZ2luZycpO1xyXG4gICAgICAgICAgICAgICAgYXBwbHlTdHlsZShtaXJyb3JFbCwge1xyXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAnZml4ZWQnLFxyXG4gICAgICAgICAgICAgICAgICAgIHpJbmRleDogdGhpcy56SW5kZXgsXHJcbiAgICAgICAgICAgICAgICAgICAgdmlzaWJpbGl0eTogJycsXHJcbiAgICAgICAgICAgICAgICAgICAgYm94U2l6aW5nOiAnYm9yZGVyLWJveCcsXHJcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHNvdXJjZUVsUmVjdC5yaWdodCAtIHNvdXJjZUVsUmVjdC5sZWZ0LFxyXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogc291cmNlRWxSZWN0LmJvdHRvbSAtIHNvdXJjZUVsUmVjdC50b3AsXHJcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQ6ICdhdXRvJyxcclxuICAgICAgICAgICAgICAgICAgICBib3R0b206ICdhdXRvJyxcclxuICAgICAgICAgICAgICAgICAgICBtYXJnaW46IDAsXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50Tm9kZS5hcHBlbmRDaGlsZChtaXJyb3JFbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG1pcnJvckVsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKlxyXG4gICAgSXMgYSBjYWNoZSBmb3IgYSBnaXZlbiBlbGVtZW50J3Mgc2Nyb2xsIGluZm9ybWF0aW9uIChhbGwgdGhlIGluZm8gdGhhdCBTY3JvbGxDb250cm9sbGVyIHN0b3JlcylcclxuICAgIGluIGFkZGl0aW9uIHRoZSBcImNsaWVudCByZWN0YW5nbGVcIiBvZiB0aGUgZWxlbWVudC4uIHRoZSBhcmVhIHdpdGhpbiB0aGUgc2Nyb2xsYmFycy5cclxuXHJcbiAgICBUaGUgY2FjaGUgY2FuIGJlIGluIG9uZSBvZiB0d28gbW9kZXM6XHJcbiAgICAtIGRvZXNMaXN0ZW5pbmc6ZmFsc2UgLSBpZ25vcmVzIHdoZW4gdGhlIGNvbnRhaW5lciBpcyBzY3JvbGxlZCBieSBzb21lb25lIGVsc2VcclxuICAgIC0gZG9lc0xpc3RlbmluZzp0cnVlIC0gd2F0Y2ggZm9yIHNjcm9sbGluZyBhbmQgdXBkYXRlIHRoZSBjYWNoZVxyXG4gICAgKi9cclxuICAgIGNsYXNzIFNjcm9sbEdlb21DYWNoZSBleHRlbmRzIFNjcm9sbENvbnRyb2xsZXIge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yKHNjcm9sbENvbnRyb2xsZXIsIGRvZXNMaXN0ZW5pbmcpIHtcclxuICAgICAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICAgICAgdGhpcy5oYW5kbGVTY3JvbGwgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbFRvcCA9IHRoaXMuc2Nyb2xsQ29udHJvbGxlci5nZXRTY3JvbGxUb3AoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsTGVmdCA9IHRoaXMuc2Nyb2xsQ29udHJvbGxlci5nZXRTY3JvbGxMZWZ0KCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVNjcm9sbENoYW5nZSgpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB0aGlzLnNjcm9sbENvbnRyb2xsZXIgPSBzY3JvbGxDb250cm9sbGVyO1xyXG4gICAgICAgICAgICB0aGlzLmRvZXNMaXN0ZW5pbmcgPSBkb2VzTGlzdGVuaW5nO1xyXG4gICAgICAgICAgICB0aGlzLnNjcm9sbFRvcCA9IHRoaXMub3JpZ1Njcm9sbFRvcCA9IHNjcm9sbENvbnRyb2xsZXIuZ2V0U2Nyb2xsVG9wKCk7XHJcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsTGVmdCA9IHRoaXMub3JpZ1Njcm9sbExlZnQgPSBzY3JvbGxDb250cm9sbGVyLmdldFNjcm9sbExlZnQoKTtcclxuICAgICAgICAgICAgdGhpcy5zY3JvbGxXaWR0aCA9IHNjcm9sbENvbnRyb2xsZXIuZ2V0U2Nyb2xsV2lkdGgoKTtcclxuICAgICAgICAgICAgdGhpcy5zY3JvbGxIZWlnaHQgPSBzY3JvbGxDb250cm9sbGVyLmdldFNjcm9sbEhlaWdodCgpO1xyXG4gICAgICAgICAgICB0aGlzLmNsaWVudFdpZHRoID0gc2Nyb2xsQ29udHJvbGxlci5nZXRDbGllbnRXaWR0aCgpO1xyXG4gICAgICAgICAgICB0aGlzLmNsaWVudEhlaWdodCA9IHNjcm9sbENvbnRyb2xsZXIuZ2V0Q2xpZW50SGVpZ2h0KCk7XHJcbiAgICAgICAgICAgIHRoaXMuY2xpZW50UmVjdCA9IHRoaXMuY29tcHV0ZUNsaWVudFJlY3QoKTsgLy8gZG8gbGFzdCBpbiBjYXNlIGl0IG5lZWRzIGNhY2hlZCB2YWx1ZXNcclxuICAgICAgICAgICAgaWYgKHRoaXMuZG9lc0xpc3RlbmluZykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5nZXRFdmVudFRhcmdldCgpLmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMuaGFuZGxlU2Nyb2xsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBkZXN0cm95KCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5kb2VzTGlzdGVuaW5nKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmdldEV2ZW50VGFyZ2V0KCkucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcy5oYW5kbGVTY3JvbGwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGdldFNjcm9sbFRvcCgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2Nyb2xsVG9wO1xyXG4gICAgICAgIH1cclxuICAgICAgICBnZXRTY3JvbGxMZWZ0KCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zY3JvbGxMZWZ0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBzZXRTY3JvbGxUb3AodG9wKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsQ29udHJvbGxlci5zZXRTY3JvbGxUb3AodG9wKTtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmRvZXNMaXN0ZW5pbmcpIHtcclxuICAgICAgICAgICAgICAgIC8vIHdlIGFyZSBub3QgcmVseWluZyBvbiB0aGUgZWxlbWVudCB0byBub3JtYWxpemUgb3V0LW9mLWJvdW5kcyBzY3JvbGwgdmFsdWVzXHJcbiAgICAgICAgICAgICAgICAvLyBzbyB3ZSBuZWVkIHRvIHNhbml0aXplIG91cnNlbHZlc1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxUb3AgPSBNYXRoLm1heChNYXRoLm1pbih0b3AsIHRoaXMuZ2V0TWF4U2Nyb2xsVG9wKCkpLCAwKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlU2Nyb2xsQ2hhbmdlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgc2V0U2Nyb2xsTGVmdCh0b3ApIHtcclxuICAgICAgICAgICAgdGhpcy5zY3JvbGxDb250cm9sbGVyLnNldFNjcm9sbExlZnQodG9wKTtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmRvZXNMaXN0ZW5pbmcpIHtcclxuICAgICAgICAgICAgICAgIC8vIHdlIGFyZSBub3QgcmVseWluZyBvbiB0aGUgZWxlbWVudCB0byBub3JtYWxpemUgb3V0LW9mLWJvdW5kcyBzY3JvbGwgdmFsdWVzXHJcbiAgICAgICAgICAgICAgICAvLyBzbyB3ZSBuZWVkIHRvIHNhbml0aXplIG91cnNlbHZlc1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxMZWZ0ID0gTWF0aC5tYXgoTWF0aC5taW4odG9wLCB0aGlzLmdldE1heFNjcm9sbExlZnQoKSksIDApO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVTY3JvbGxDaGFuZ2UoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBnZXRDbGllbnRXaWR0aCgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50V2lkdGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGdldENsaWVudEhlaWdodCgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50SGVpZ2h0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBnZXRTY3JvbGxXaWR0aCgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2Nyb2xsV2lkdGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGdldFNjcm9sbEhlaWdodCgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2Nyb2xsSGVpZ2h0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBoYW5kbGVTY3JvbGxDaGFuZ2UoKSB7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNsYXNzIEVsZW1lbnRTY3JvbGxHZW9tQ2FjaGUgZXh0ZW5kcyBTY3JvbGxHZW9tQ2FjaGUge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yKGVsLCBkb2VzTGlzdGVuaW5nKSB7XHJcbiAgICAgICAgICAgIHN1cGVyKG5ldyBFbGVtZW50U2Nyb2xsQ29udHJvbGxlcihlbCksIGRvZXNMaXN0ZW5pbmcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBnZXRFdmVudFRhcmdldCgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2Nyb2xsQ29udHJvbGxlci5lbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29tcHV0ZUNsaWVudFJlY3QoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjb21wdXRlSW5uZXJSZWN0KHRoaXMuc2Nyb2xsQ29udHJvbGxlci5lbCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNsYXNzIFdpbmRvd1Njcm9sbEdlb21DYWNoZSBleHRlbmRzIFNjcm9sbEdlb21DYWNoZSB7XHJcbiAgICAgICAgY29uc3RydWN0b3IoZG9lc0xpc3RlbmluZykge1xyXG4gICAgICAgICAgICBzdXBlcihuZXcgV2luZG93U2Nyb2xsQ29udHJvbGxlcigpLCBkb2VzTGlzdGVuaW5nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZ2V0RXZlbnRUYXJnZXQoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB3aW5kb3c7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbXB1dGVDbGllbnRSZWN0KCkge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgbGVmdDogdGhpcy5zY3JvbGxMZWZ0LFxyXG4gICAgICAgICAgICAgICAgcmlnaHQ6IHRoaXMuc2Nyb2xsTGVmdCArIHRoaXMuY2xpZW50V2lkdGgsXHJcbiAgICAgICAgICAgICAgICB0b3A6IHRoaXMuc2Nyb2xsVG9wLFxyXG4gICAgICAgICAgICAgICAgYm90dG9tOiB0aGlzLnNjcm9sbFRvcCArIHRoaXMuY2xpZW50SGVpZ2h0LFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyB0aGUgd2luZG93IGlzIHRoZSBvbmx5IHNjcm9sbCBvYmplY3QgdGhhdCBjaGFuZ2VzIGl0J3MgcmVjdGFuZ2xlIHJlbGF0aXZlXHJcbiAgICAgICAgLy8gdG8gdGhlIGRvY3VtZW50J3MgdG9wbGVmdCBhcyBpdCBzY3JvbGxzXHJcbiAgICAgICAgaGFuZGxlU2Nyb2xsQ2hhbmdlKCkge1xyXG4gICAgICAgICAgICB0aGlzLmNsaWVudFJlY3QgPSB0aGlzLmNvbXB1dGVDbGllbnRSZWN0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIElmIGF2YWlsYWJsZSB3ZSBhcmUgdXNpbmcgbmF0aXZlIFwicGVyZm9ybWFuY2VcIiBBUEkgaW5zdGVhZCBvZiBcIkRhdGVcIlxyXG4gICAgLy8gUmVhZCBtb3JlIGFib3V0IGl0IG9uIE1ETjpcclxuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9QZXJmb3JtYW5jZVxyXG4gICAgY29uc3QgZ2V0VGltZSA9IHR5cGVvZiBwZXJmb3JtYW5jZSA9PT0gJ2Z1bmN0aW9uJyA/IHBlcmZvcm1hbmNlLm5vdyA6IERhdGUubm93O1xyXG4gICAgLypcclxuICAgIEZvciBhIHBvaW50ZXIgaW50ZXJhY3Rpb24sIGF1dG9tYXRpY2FsbHkgc2Nyb2xscyBjZXJ0YWluIHNjcm9sbCBjb250YWluZXJzIHdoZW4gdGhlIHBvaW50ZXJcclxuICAgIGFwcHJvYWNoZXMgdGhlIGVkZ2UuXHJcblxyXG4gICAgVGhlIGNhbGxlciBtdXN0IGNhbGwgc3RhcnQgKyBoYW5kbGVNb3ZlICsgc3RvcC5cclxuICAgICovXHJcbiAgICBjbGFzcyBBdXRvU2Nyb2xsZXIge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgICAgICAvLyBvcHRpb25zIHRoYXQgY2FuIGJlIHNldCBieSBjYWxsZXJcclxuICAgICAgICAgICAgdGhpcy5pc0VuYWJsZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLnNjcm9sbFF1ZXJ5ID0gW3dpbmRvdywgJy5mYy1zY3JvbGxlciddO1xyXG4gICAgICAgICAgICB0aGlzLmVkZ2VUaHJlc2hvbGQgPSA1MDsgLy8gcGl4ZWxzXHJcbiAgICAgICAgICAgIHRoaXMubWF4VmVsb2NpdHkgPSAzMDA7IC8vIHBpeGVscyBwZXIgc2Vjb25kXHJcbiAgICAgICAgICAgIC8vIGludGVybmFsIHN0YXRlXHJcbiAgICAgICAgICAgIHRoaXMucG9pbnRlclNjcmVlblggPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLnBvaW50ZXJTY3JlZW5ZID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5pc0FuaW1hdGluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLnNjcm9sbENhY2hlcyA9IG51bGw7XHJcbiAgICAgICAgICAgIC8vIHByb3RlY3QgYWdhaW5zdCB0aGUgaW5pdGlhbCBwb2ludGVyZG93biBiZWluZyB0b28gY2xvc2UgdG8gYW4gZWRnZSBhbmQgc3RhcnRpbmcgdGhlIHNjcm9sbFxyXG4gICAgICAgICAgICB0aGlzLmV2ZXJNb3ZlZFVwID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuZXZlck1vdmVkRG93biA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLmV2ZXJNb3ZlZExlZnQgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5ldmVyTW92ZWRSaWdodCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLmFuaW1hdGUgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc0FuaW1hdGluZykgeyAvLyB3YXNuJ3QgY2FuY2VsbGVkIGJldHdlZW4gYW5pbWF0aW9uIGNhbGxzXHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGVkZ2UgPSB0aGlzLmNvbXB1dGVCZXN0RWRnZSh0aGlzLnBvaW50ZXJTY3JlZW5YICsgd2luZG93LnBhZ2VYT2Zmc2V0LCB0aGlzLnBvaW50ZXJTY3JlZW5ZICsgd2luZG93LnBhZ2VZT2Zmc2V0KTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZWRnZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbm93ID0gZ2V0VGltZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVNpZGUoZWRnZSwgKG5vdyAtIHRoaXMubXNTaW5jZVJlcXVlc3QpIC8gMTAwMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVxdWVzdEFuaW1hdGlvbihub3cpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pc0FuaW1hdGluZyA9IGZhbHNlOyAvLyB3aWxsIHN0b3AgYW5pbWF0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBzdGFydChwYWdlWCwgcGFnZVksIHNjcm9sbFN0YXJ0RWwpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaXNFbmFibGVkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbENhY2hlcyA9IHRoaXMuYnVpbGRDYWNoZXMoc2Nyb2xsU3RhcnRFbCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBvaW50ZXJTY3JlZW5YID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIHRoaXMucG9pbnRlclNjcmVlblkgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ldmVyTW92ZWRVcCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ldmVyTW92ZWREb3duID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZXJNb3ZlZExlZnQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZXZlck1vdmVkUmlnaHQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlTW92ZShwYWdlWCwgcGFnZVkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGhhbmRsZU1vdmUocGFnZVgsIHBhZ2VZKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmlzRW5hYmxlZCkge1xyXG4gICAgICAgICAgICAgICAgbGV0IHBvaW50ZXJTY3JlZW5YID0gcGFnZVggLSB3aW5kb3cucGFnZVhPZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICBsZXQgcG9pbnRlclNjcmVlblkgPSBwYWdlWSAtIHdpbmRvdy5wYWdlWU9mZnNldDtcclxuICAgICAgICAgICAgICAgIGxldCB5RGVsdGEgPSB0aGlzLnBvaW50ZXJTY3JlZW5ZID09PSBudWxsID8gMCA6IHBvaW50ZXJTY3JlZW5ZIC0gdGhpcy5wb2ludGVyU2NyZWVuWTtcclxuICAgICAgICAgICAgICAgIGxldCB4RGVsdGEgPSB0aGlzLnBvaW50ZXJTY3JlZW5YID09PSBudWxsID8gMCA6IHBvaW50ZXJTY3JlZW5YIC0gdGhpcy5wb2ludGVyU2NyZWVuWDtcclxuICAgICAgICAgICAgICAgIGlmICh5RGVsdGEgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ldmVyTW92ZWRVcCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh5RGVsdGEgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ldmVyTW92ZWREb3duID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh4RGVsdGEgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ldmVyTW92ZWRMZWZ0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHhEZWx0YSA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmV2ZXJNb3ZlZFJpZ2h0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMucG9pbnRlclNjcmVlblggPSBwb2ludGVyU2NyZWVuWDtcclxuICAgICAgICAgICAgICAgIHRoaXMucG9pbnRlclNjcmVlblkgPSBwb2ludGVyU2NyZWVuWTtcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5pc0FuaW1hdGluZykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaXNBbmltYXRpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVxdWVzdEFuaW1hdGlvbihnZXRUaW1lKCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN0b3AoKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmlzRW5hYmxlZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pc0FuaW1hdGluZyA9IGZhbHNlOyAvLyB3aWxsIHN0b3AgYW5pbWF0aW9uXHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBzY3JvbGxDYWNoZSBvZiB0aGlzLnNjcm9sbENhY2hlcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHNjcm9sbENhY2hlLmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsQ2FjaGVzID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uKG5vdykge1xyXG4gICAgICAgICAgICB0aGlzLm1zU2luY2VSZXF1ZXN0ID0gbm93O1xyXG4gICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5hbmltYXRlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaGFuZGxlU2lkZShlZGdlLCBzZWNvbmRzKSB7XHJcbiAgICAgICAgICAgIGxldCB7IHNjcm9sbENhY2hlIH0gPSBlZGdlO1xyXG4gICAgICAgICAgICBsZXQgeyBlZGdlVGhyZXNob2xkIH0gPSB0aGlzO1xyXG4gICAgICAgICAgICBsZXQgaW52RGlzdGFuY2UgPSBlZGdlVGhyZXNob2xkIC0gZWRnZS5kaXN0YW5jZTtcclxuICAgICAgICAgICAgbGV0IHZlbG9jaXR5ID0gLy8gdGhlIGNsb3NlciB0byB0aGUgZWRnZSwgdGhlIGZhc3RlciB3ZSBzY3JvbGxcclxuICAgICAgICAgICAgICgoaW52RGlzdGFuY2UgKiBpbnZEaXN0YW5jZSkgLyAoZWRnZVRocmVzaG9sZCAqIGVkZ2VUaHJlc2hvbGQpKSAqIC8vIHF1YWRyYXRpY1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tYXhWZWxvY2l0eSAqIHNlY29uZHM7XHJcbiAgICAgICAgICAgIGxldCBzaWduID0gMTtcclxuICAgICAgICAgICAgc3dpdGNoIChlZGdlLm5hbWUpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgJ2xlZnQnOlxyXG4gICAgICAgICAgICAgICAgICAgIHNpZ24gPSAtMTtcclxuICAgICAgICAgICAgICAgIC8vIGZhbGxzIHRocm91Z2hcclxuICAgICAgICAgICAgICAgIGNhc2UgJ3JpZ2h0JzpcclxuICAgICAgICAgICAgICAgICAgICBzY3JvbGxDYWNoZS5zZXRTY3JvbGxMZWZ0KHNjcm9sbENhY2hlLmdldFNjcm9sbExlZnQoKSArIHZlbG9jaXR5ICogc2lnbik7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlICd0b3AnOlxyXG4gICAgICAgICAgICAgICAgICAgIHNpZ24gPSAtMTtcclxuICAgICAgICAgICAgICAgIC8vIGZhbGxzIHRocm91Z2hcclxuICAgICAgICAgICAgICAgIGNhc2UgJ2JvdHRvbSc6XHJcbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsQ2FjaGUuc2V0U2Nyb2xsVG9wKHNjcm9sbENhY2hlLmdldFNjcm9sbFRvcCgpICsgdmVsb2NpdHkgKiBzaWduKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBsZWZ0L3RvcCBhcmUgcmVsYXRpdmUgdG8gZG9jdW1lbnQgdG9wbGVmdFxyXG4gICAgICAgIGNvbXB1dGVCZXN0RWRnZShsZWZ0LCB0b3ApIHtcclxuICAgICAgICAgICAgbGV0IHsgZWRnZVRocmVzaG9sZCB9ID0gdGhpcztcclxuICAgICAgICAgICAgbGV0IGJlc3RTaWRlID0gbnVsbDtcclxuICAgICAgICAgICAgbGV0IHNjcm9sbENhY2hlcyA9IHRoaXMuc2Nyb2xsQ2FjaGVzIHx8IFtdO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBzY3JvbGxDYWNoZSBvZiBzY3JvbGxDYWNoZXMpIHtcclxuICAgICAgICAgICAgICAgIGxldCByZWN0ID0gc2Nyb2xsQ2FjaGUuY2xpZW50UmVjdDtcclxuICAgICAgICAgICAgICAgIGxldCBsZWZ0RGlzdCA9IGxlZnQgLSByZWN0LmxlZnQ7XHJcbiAgICAgICAgICAgICAgICBsZXQgcmlnaHREaXN0ID0gcmVjdC5yaWdodCAtIGxlZnQ7XHJcbiAgICAgICAgICAgICAgICBsZXQgdG9wRGlzdCA9IHRvcCAtIHJlY3QudG9wO1xyXG4gICAgICAgICAgICAgICAgbGV0IGJvdHRvbURpc3QgPSByZWN0LmJvdHRvbSAtIHRvcDtcclxuICAgICAgICAgICAgICAgIC8vIGNvbXBsZXRlbHkgd2l0aGluIHRoZSByZWN0P1xyXG4gICAgICAgICAgICAgICAgaWYgKGxlZnREaXN0ID49IDAgJiYgcmlnaHREaXN0ID49IDAgJiYgdG9wRGlzdCA+PSAwICYmIGJvdHRvbURpc3QgPj0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0b3BEaXN0IDw9IGVkZ2VUaHJlc2hvbGQgJiYgdGhpcy5ldmVyTW92ZWRVcCAmJiBzY3JvbGxDYWNoZS5jYW5TY3JvbGxVcCgpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICghYmVzdFNpZGUgfHwgYmVzdFNpZGUuZGlzdGFuY2UgPiB0b3BEaXN0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0U2lkZSA9IHsgc2Nyb2xsQ2FjaGUsIG5hbWU6ICd0b3AnLCBkaXN0YW5jZTogdG9wRGlzdCB9O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoYm90dG9tRGlzdCA8PSBlZGdlVGhyZXNob2xkICYmIHRoaXMuZXZlck1vdmVkRG93biAmJiBzY3JvbGxDYWNoZS5jYW5TY3JvbGxEb3duKCkgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgKCFiZXN0U2lkZSB8fCBiZXN0U2lkZS5kaXN0YW5jZSA+IGJvdHRvbURpc3QpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RTaWRlID0geyBzY3JvbGxDYWNoZSwgbmFtZTogJ2JvdHRvbScsIGRpc3RhbmNlOiBib3R0b21EaXN0IH07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChsZWZ0RGlzdCA8PSBlZGdlVGhyZXNob2xkICYmIHRoaXMuZXZlck1vdmVkTGVmdCAmJiBzY3JvbGxDYWNoZS5jYW5TY3JvbGxMZWZ0KCkgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgKCFiZXN0U2lkZSB8fCBiZXN0U2lkZS5kaXN0YW5jZSA+IGxlZnREaXN0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0U2lkZSA9IHsgc2Nyb2xsQ2FjaGUsIG5hbWU6ICdsZWZ0JywgZGlzdGFuY2U6IGxlZnREaXN0IH07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyaWdodERpc3QgPD0gZWRnZVRocmVzaG9sZCAmJiB0aGlzLmV2ZXJNb3ZlZFJpZ2h0ICYmIHNjcm9sbENhY2hlLmNhblNjcm9sbFJpZ2h0KCkgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgKCFiZXN0U2lkZSB8fCBiZXN0U2lkZS5kaXN0YW5jZSA+IHJpZ2h0RGlzdCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYmVzdFNpZGUgPSB7IHNjcm9sbENhY2hlLCBuYW1lOiAncmlnaHQnLCBkaXN0YW5jZTogcmlnaHREaXN0IH07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBiZXN0U2lkZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYnVpbGRDYWNoZXMoc2Nyb2xsU3RhcnRFbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5xdWVyeVNjcm9sbEVscyhzY3JvbGxTdGFydEVsKS5tYXAoKGVsKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZWwgPT09IHdpbmRvdykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgV2luZG93U2Nyb2xsR2VvbUNhY2hlKGZhbHNlKTsgLy8gZmFsc2UgPSBkb24ndCBsaXN0ZW4gdG8gdXNlci1nZW5lcmF0ZWQgc2Nyb2xsc1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBFbGVtZW50U2Nyb2xsR2VvbUNhY2hlKGVsLCBmYWxzZSk7IC8vIGZhbHNlID0gZG9uJ3QgbGlzdGVuIHRvIHVzZXItZ2VuZXJhdGVkIHNjcm9sbHNcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHF1ZXJ5U2Nyb2xsRWxzKHNjcm9sbFN0YXJ0RWwpIHtcclxuICAgICAgICAgICAgbGV0IGVscyA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBxdWVyeSBvZiB0aGlzLnNjcm9sbFF1ZXJ5KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHF1ZXJ5ID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICAgICAgICAgIGVscy5wdXNoKHF1ZXJ5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGVscy5wdXNoKC4uLkFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHNjcm9sbFN0YXJ0RWwuZ2V0Um9vdE5vZGUoKS5xdWVyeVNlbGVjdG9yQWxsKHF1ZXJ5KSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBlbHM7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qXHJcbiAgICBNb25pdG9ycyBkcmFnZ2luZyBvbiBhbiBlbGVtZW50LiBIYXMgYSBudW1iZXIgb2YgaGlnaC1sZXZlbCBmZWF0dXJlczpcclxuICAgIC0gbWluaW11bSBkaXN0YW5jZSByZXF1aXJlZCBiZWZvcmUgZHJhZ2dpbmdcclxuICAgIC0gbWluaW11bSB3YWl0IHRpbWUgKFwiZGVsYXlcIikgYmVmb3JlIGRyYWdnaW5nXHJcbiAgICAtIGEgbWlycm9yIGVsZW1lbnQgdGhhdCBmb2xsb3dzIHRoZSBwb2ludGVyXHJcbiAgICAqL1xyXG4gICAgY2xhc3MgRmVhdHVyZWZ1bEVsZW1lbnREcmFnZ2luZyBleHRlbmRzIEVsZW1lbnREcmFnZ2luZyB7XHJcbiAgICAgICAgY29uc3RydWN0b3IoY29udGFpbmVyRWwsIHNlbGVjdG9yKSB7XHJcbiAgICAgICAgICAgIHN1cGVyKGNvbnRhaW5lckVsKTtcclxuICAgICAgICAgICAgdGhpcy5jb250YWluZXJFbCA9IGNvbnRhaW5lckVsO1xyXG4gICAgICAgICAgICAvLyBvcHRpb25zIHRoYXQgY2FuIGJlIGRpcmVjdGx5IHNldCBieSBjYWxsZXJcclxuICAgICAgICAgICAgLy8gdGhlIGNhbGxlciBjYW4gYWxzbyBzZXQgdGhlIFBvaW50ZXJEcmFnZ2luZydzIG9wdGlvbnMgYXMgd2VsbFxyXG4gICAgICAgICAgICB0aGlzLmRlbGF5ID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5taW5EaXN0YW5jZSA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMudG91Y2hTY3JvbGxBbGxvd2VkID0gdHJ1ZTsgLy8gcHJldmVudHMgZHJhZyBmcm9tIHN0YXJ0aW5nIGFuZCBibG9ja3Mgc2Nyb2xsaW5nIGR1cmluZyBkcmFnXHJcbiAgICAgICAgICAgIHRoaXMubWlycm9yTmVlZHNSZXZlcnQgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5pc0ludGVyYWN0aW5nID0gZmFsc2U7IC8vIGlzIHRoZSB1c2VyIHZhbGlkbHkgbW92aW5nIHRoZSBwb2ludGVyPyBsYXN0cyB1bnRpbCBwb2ludGVydXBcclxuICAgICAgICAgICAgdGhpcy5pc0RyYWdnaW5nID0gZmFsc2U7IC8vIGlzIGl0IElOVEVOVEZVTExZIGRyYWdnaW5nPyBsYXN0cyB1bnRpbCBhZnRlciByZXZlcnQgYW5pbWF0aW9uXHJcbiAgICAgICAgICAgIHRoaXMuaXNEZWxheUVuZGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuaXNEaXN0YW5jZVN1cnBhc3NlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLmRlbGF5VGltZW91dElkID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5vblBvaW50ZXJEb3duID0gKGV2KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaXNEcmFnZ2luZykgeyAvLyBzbyBuZXcgZHJhZyBkb2Vzbid0IGhhcHBlbiB3aGlsZSByZXZlcnQgYW5pbWF0aW9uIGlzIGdvaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pc0ludGVyYWN0aW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmlzRGVsYXlFbmRlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaXNEaXN0YW5jZVN1cnBhc3NlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIHByZXZlbnRTZWxlY3Rpb24oZG9jdW1lbnQuYm9keSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJldmVudENvbnRleHRNZW51KGRvY3VtZW50LmJvZHkpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHByZXZlbnQgbGlua3MgZnJvbSBiZWluZyB2aXNpdGVkIGlmIHRoZXJlJ3MgYW4gZXZlbnR1YWwgZHJhZy5cclxuICAgICAgICAgICAgICAgICAgICAvLyBhbHNvIHByZXZlbnRzIHNlbGVjdGlvbiBpbiBvbGRlciBicm93c2VycyAobWF5YmU/KS5cclxuICAgICAgICAgICAgICAgICAgICAvLyBub3QgbmVjZXNzYXJ5IGZvciB0b3VjaCwgYmVzaWRlcywgYnJvd3NlciB3b3VsZCBjb21wbGFpbiBhYm91dCBwYXNzaXZlbmVzcy5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWV2LmlzVG91Y2gpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXYub3JpZ0V2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdHRlci50cmlnZ2VyKCdwb2ludGVyZG93bicsIGV2KTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pc0ludGVyYWN0aW5nICYmIC8vIG5vdCBkZXN0cm95ZWQgdmlhIHBvaW50ZXJkb3duIGhhbmRsZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgIXRoaXMucG9pbnRlci5zaG91bGRJZ25vcmVNb3ZlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFjdGlvbnMgcmVsYXRlZCB0byBpbml0aWF0aW5nIGRyYWdzdGFydCtkcmFnbW92ZStkcmFnZW5kLi4uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWlycm9yLnNldElzVmlzaWJsZShmYWxzZSk7IC8vIHJlc2V0LiBjYWxsZXIgbXVzdCBzZXQtdmlzaWJsZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1pcnJvci5zdGFydChldi5zdWJqZWN0RWwsIGV2LnBhZ2VYLCBldi5wYWdlWSk7IC8vIG11c3QgaGFwcGVuIG9uIGZpcnN0IHBvaW50ZXIgZG93blxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0RGVsYXkoZXYpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMubWluRGlzdGFuY2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlRGlzdGFuY2VTdXJwYXNzZWQoZXYpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB0aGlzLm9uUG9pbnRlck1vdmUgPSAoZXYpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzSW50ZXJhY3RpbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXR0ZXIudHJpZ2dlcigncG9pbnRlcm1vdmUnLCBldik7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmlzRGlzdGFuY2VTdXJwYXNzZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG1pbkRpc3RhbmNlID0gdGhpcy5taW5EaXN0YW5jZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGRpc3RhbmNlU3E7IC8vIGN1cnJlbnQgZGlzdGFuY2UgZnJvbSB0aGUgb3JpZ2luLCBzcXVhcmVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB7IGRlbHRhWCwgZGVsdGFZIH0gPSBldjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzdGFuY2VTcSA9IGRlbHRhWCAqIGRlbHRhWCArIGRlbHRhWSAqIGRlbHRhWTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRpc3RhbmNlU3EgPj0gbWluRGlzdGFuY2UgKiBtaW5EaXN0YW5jZSkgeyAvLyB1c2UgcHl0aGFnb3JlYW4gdGhlb3JlbVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVEaXN0YW5jZVN1cnBhc3NlZChldik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNEcmFnZ2luZykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhIHJlYWwgcG9pbnRlciBtb3ZlPyAobm90IG9uZSBzaW11bGF0ZWQgYnkgc2Nyb2xsaW5nKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXYub3JpZ0V2ZW50LnR5cGUgIT09ICdzY3JvbGwnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1pcnJvci5oYW5kbGVNb3ZlKGV2LnBhZ2VYLCBldi5wYWdlWSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmF1dG9TY3JvbGxlci5oYW5kbGVNb3ZlKGV2LnBhZ2VYLCBldi5wYWdlWSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0dGVyLnRyaWdnZXIoJ2RyYWdtb3ZlJywgZXYpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdGhpcy5vblBvaW50ZXJVcCA9IChldikgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNJbnRlcmFjdGluZykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaXNJbnRlcmFjdGluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIGFsbG93U2VsZWN0aW9uKGRvY3VtZW50LmJvZHkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGFsbG93Q29udGV4dE1lbnUoZG9jdW1lbnQuYm9keSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0dGVyLnRyaWdnZXIoJ3BvaW50ZXJ1cCcsIGV2KTsgLy8gY2FuIHBvdGVudGlhbGx5IHNldCBtaXJyb3JOZWVkc1JldmVydFxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzRHJhZ2dpbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hdXRvU2Nyb2xsZXIuc3RvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRyeVN0b3BEcmFnKGV2KTsgLy8gd2hpY2ggd2lsbCBzdG9wIHRoZSBtaXJyb3JcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZGVsYXlUaW1lb3V0SWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuZGVsYXlUaW1lb3V0SWQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRlbGF5VGltZW91dElkID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGxldCBwb2ludGVyID0gdGhpcy5wb2ludGVyID0gbmV3IFBvaW50ZXJEcmFnZ2luZyhjb250YWluZXJFbCk7XHJcbiAgICAgICAgICAgIHBvaW50ZXIuZW1pdHRlci5vbigncG9pbnRlcmRvd24nLCB0aGlzLm9uUG9pbnRlckRvd24pO1xyXG4gICAgICAgICAgICBwb2ludGVyLmVtaXR0ZXIub24oJ3BvaW50ZXJtb3ZlJywgdGhpcy5vblBvaW50ZXJNb3ZlKTtcclxuICAgICAgICAgICAgcG9pbnRlci5lbWl0dGVyLm9uKCdwb2ludGVydXAnLCB0aGlzLm9uUG9pbnRlclVwKTtcclxuICAgICAgICAgICAgaWYgKHNlbGVjdG9yKSB7XHJcbiAgICAgICAgICAgICAgICBwb2ludGVyLnNlbGVjdG9yID0gc2VsZWN0b3I7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5taXJyb3IgPSBuZXcgRWxlbWVudE1pcnJvcigpO1xyXG4gICAgICAgICAgICB0aGlzLmF1dG9TY3JvbGxlciA9IG5ldyBBdXRvU2Nyb2xsZXIoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZGVzdHJveSgpIHtcclxuICAgICAgICAgICAgdGhpcy5wb2ludGVyLmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgLy8gSEFDSzogc2ltdWxhdGUgYSBwb2ludGVyLXVwIHRvIGVuZCB0aGUgY3VycmVudCBkcmFnXHJcbiAgICAgICAgICAgIC8vIFRPRE86IGZpcmUgJ2RyYWdlbmQnIGRpcmVjdGx5IGFuZCBzdG9wIGludGVyYWN0aW9uLiBkaXNjb3VyYWdlIHVzZSBvZiBwb2ludGVydXAgZXZlbnQgKGIvYyBtaWdodCBub3QgZmlyZSlcclxuICAgICAgICAgICAgdGhpcy5vblBvaW50ZXJVcCh7fSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN0YXJ0RGVsYXkoZXYpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmRlbGF5ID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kZWxheVRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVsYXlUaW1lb3V0SWQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlRGVsYXlFbmQoZXYpO1xyXG4gICAgICAgICAgICAgICAgfSwgdGhpcy5kZWxheSk7IC8vIG5vdCBhc3NpZ25hYmxlIHRvIG51bWJlciFcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlRGVsYXlFbmQoZXYpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGhhbmRsZURlbGF5RW5kKGV2KSB7XHJcbiAgICAgICAgICAgIHRoaXMuaXNEZWxheUVuZGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy50cnlTdGFydERyYWcoZXYpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBoYW5kbGVEaXN0YW5jZVN1cnBhc3NlZChldikge1xyXG4gICAgICAgICAgICB0aGlzLmlzRGlzdGFuY2VTdXJwYXNzZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLnRyeVN0YXJ0RHJhZyhldik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRyeVN0YXJ0RHJhZyhldikge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5pc0RlbGF5RW5kZWQgJiYgdGhpcy5pc0Rpc3RhbmNlU3VycGFzc2VkKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMucG9pbnRlci53YXNUb3VjaFNjcm9sbCB8fCB0aGlzLnRvdWNoU2Nyb2xsQWxsb3dlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaXNEcmFnZ2luZyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5taXJyb3JOZWVkc1JldmVydCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXV0b1Njcm9sbGVyLnN0YXJ0KGV2LnBhZ2VYLCBldi5wYWdlWSwgdGhpcy5jb250YWluZXJFbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0dGVyLnRyaWdnZXIoJ2RyYWdzdGFydCcsIGV2KTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy50b3VjaFNjcm9sbEFsbG93ZWQgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucG9pbnRlci5jYW5jZWxUb3VjaFNjcm9sbCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0cnlTdG9wRHJhZyhldikge1xyXG4gICAgICAgICAgICAvLyAuc3RvcCgpIGlzIEFMV0FZUyBhc3luY2hyb25vdXMsIHdoaWNoIHdlIE5FRUQgYmVjYXVzZSB3ZSB3YW50IGFsbCBwb2ludGVydXAgZXZlbnRzXHJcbiAgICAgICAgICAgIC8vIHRoYXQgY29tZSBmcm9tIHRoZSBkb2N1bWVudCB0byBmaXJlIGJlZm9yZWhhbmQuIG11Y2ggbW9yZSBjb252ZW5pZW50IHRoaXMgd2F5LlxyXG4gICAgICAgICAgICB0aGlzLm1pcnJvci5zdG9wKHRoaXMubWlycm9yTmVlZHNSZXZlcnQsIHRoaXMuc3RvcERyYWcuYmluZCh0aGlzLCBldikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzdG9wRHJhZyhldikge1xyXG4gICAgICAgICAgICB0aGlzLmlzRHJhZ2dpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5lbWl0dGVyLnRyaWdnZXIoJ2RyYWdlbmQnLCBldik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGZpbGwgaW4gdGhlIGltcGxlbWVudGF0aW9ucy4uLlxyXG4gICAgICAgIHNldElnbm9yZU1vdmUoYm9vbCkge1xyXG4gICAgICAgICAgICB0aGlzLnBvaW50ZXIuc2hvdWxkSWdub3JlTW92ZSA9IGJvb2w7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNldE1pcnJvcklzVmlzaWJsZShib29sKSB7XHJcbiAgICAgICAgICAgIHRoaXMubWlycm9yLnNldElzVmlzaWJsZShib29sKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc2V0TWlycm9yTmVlZHNSZXZlcnQoYm9vbCkge1xyXG4gICAgICAgICAgICB0aGlzLm1pcnJvck5lZWRzUmV2ZXJ0ID0gYm9vbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgc2V0QXV0b1Njcm9sbEVuYWJsZWQoYm9vbCkge1xyXG4gICAgICAgICAgICB0aGlzLmF1dG9TY3JvbGxlci5pc0VuYWJsZWQgPSBib29sO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKlxyXG4gICAgV2hlbiB0aGlzIGNsYXNzIGlzIGluc3RhbnRpYXRlZCwgaXQgcmVjb3JkcyB0aGUgb2Zmc2V0IG9mIGFuIGVsZW1lbnQgKHJlbGF0aXZlIHRvIHRoZSBkb2N1bWVudCB0b3BsZWZ0KSxcclxuICAgIGFuZCBjb250aW51ZXMgdG8gbW9uaXRvciBzY3JvbGxpbmcsIHVwZGF0aW5nIHRoZSBjYWNoZWQgY29vcmRpbmF0ZXMgaWYgaXQgbmVlZHMgdG8uXHJcbiAgICBEb2VzIG5vdCBhY2Nlc3MgdGhlIERPTSBhZnRlciBpbnN0YW50aWF0aW9uLCBzbyBoaWdobHkgcGVyZm9ybWFudC5cclxuXHJcbiAgICBBbHNvIGtlZXBzIHRyYWNrIG9mIGFsbCBzY3JvbGxpbmcvb3ZlcmZsb3c6aGlkZGVuIGNvbnRhaW5lcnMgdGhhdCBhcmUgcGFyZW50cyBvZiB0aGUgZ2l2ZW4gZWxlbWVudFxyXG4gICAgYW5kIGFuIGRldGVybWluZSBpZiBhIGdpdmVuIHBvaW50IGlzIGluc2lkZSB0aGUgY29tYmluZWQgY2xpcHBpbmcgcmVjdGFuZ2xlLlxyXG4gICAgKi9cclxuICAgIGNsYXNzIE9mZnNldFRyYWNrZXIge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yKGVsKSB7XHJcbiAgICAgICAgICAgIHRoaXMub3JpZ1JlY3QgPSBjb21wdXRlUmVjdChlbCk7XHJcbiAgICAgICAgICAgIC8vIHdpbGwgd29yayBmaW5lIGZvciBkaXZzIHRoYXQgaGF2ZSBvdmVyZmxvdzpoaWRkZW5cclxuICAgICAgICAgICAgdGhpcy5zY3JvbGxDYWNoZXMgPSBnZXRDbGlwcGluZ1BhcmVudHMoZWwpLm1hcCgoc2Nyb2xsRWwpID0+IG5ldyBFbGVtZW50U2Nyb2xsR2VvbUNhY2hlKHNjcm9sbEVsLCB0cnVlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRlc3Ryb3koKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IHNjcm9sbENhY2hlIG9mIHRoaXMuc2Nyb2xsQ2FjaGVzKSB7XHJcbiAgICAgICAgICAgICAgICBzY3JvbGxDYWNoZS5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY29tcHV0ZUxlZnQoKSB7XHJcbiAgICAgICAgICAgIGxldCBsZWZ0ID0gdGhpcy5vcmlnUmVjdC5sZWZ0O1xyXG4gICAgICAgICAgICBmb3IgKGxldCBzY3JvbGxDYWNoZSBvZiB0aGlzLnNjcm9sbENhY2hlcykge1xyXG4gICAgICAgICAgICAgICAgbGVmdCArPSBzY3JvbGxDYWNoZS5vcmlnU2Nyb2xsTGVmdCAtIHNjcm9sbENhY2hlLmdldFNjcm9sbExlZnQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbGVmdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29tcHV0ZVRvcCgpIHtcclxuICAgICAgICAgICAgbGV0IHRvcCA9IHRoaXMub3JpZ1JlY3QudG9wO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBzY3JvbGxDYWNoZSBvZiB0aGlzLnNjcm9sbENhY2hlcykge1xyXG4gICAgICAgICAgICAgICAgdG9wICs9IHNjcm9sbENhY2hlLm9yaWdTY3JvbGxUb3AgLSBzY3JvbGxDYWNoZS5nZXRTY3JvbGxUb3AoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdG9wO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpc1dpdGhpbkNsaXBwaW5nKHBhZ2VYLCBwYWdlWSkge1xyXG4gICAgICAgICAgICBsZXQgcG9pbnQgPSB7IGxlZnQ6IHBhZ2VYLCB0b3A6IHBhZ2VZIH07XHJcbiAgICAgICAgICAgIGZvciAobGV0IHNjcm9sbENhY2hlIG9mIHRoaXMuc2Nyb2xsQ2FjaGVzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzSWdub3JlZENsaXBwaW5nKHNjcm9sbENhY2hlLmdldEV2ZW50VGFyZ2V0KCkpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgIXBvaW50SW5zaWRlUmVjdChwb2ludCwgc2Nyb2xsQ2FjaGUuY2xpZW50UmVjdCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gY2VydGFpbiBjbGlwcGluZyBjb250YWluZXJzIHNob3VsZCBuZXZlciBjb25zdHJhaW4gaW50ZXJhY3Rpb25zLCBsaWtlIDxodG1sPiBhbmQgPGJvZHk+XHJcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZnVsbGNhbGVuZGFyL2Z1bGxjYWxlbmRhci9pc3N1ZXMvMzYxNVxyXG4gICAgZnVuY3Rpb24gaXNJZ25vcmVkQ2xpcHBpbmcobm9kZSkge1xyXG4gICAgICAgIGxldCB0YWdOYW1lID0gbm9kZS50YWdOYW1lO1xyXG4gICAgICAgIHJldHVybiB0YWdOYW1lID09PSAnSFRNTCcgfHwgdGFnTmFtZSA9PT0gJ0JPRFknO1xyXG4gICAgfVxyXG5cclxuICAgIC8qXHJcbiAgICBUcmFja3MgbW92ZW1lbnQgb3ZlciBtdWx0aXBsZSBkcm9wcGFibGUgYXJlYXMgKGFrYSBcImhpdHNcIilcclxuICAgIHRoYXQgZXhpc3QgaW4gb25lIG9yIG1vcmUgRGF0ZUNvbXBvbmVudHMuXHJcbiAgICBSZWxpZXMgb24gYW4gZXhpc3RpbmcgZHJhZ2dhYmxlLlxyXG5cclxuICAgIGVtaXRzOlxyXG4gICAgLSBwb2ludGVyZG93blxyXG4gICAgLSBkcmFnc3RhcnRcclxuICAgIC0gaGl0Y2hhbmdlIC0gZmlyZXMgaW5pdGlhbGx5LCBldmVuIGlmIG5vdCBvdmVyIGEgaGl0XHJcbiAgICAtIHBvaW50ZXJ1cFxyXG4gICAgLSAoaGl0Y2hhbmdlIC0gYWdhaW4sIHRvIG51bGwsIGlmIGVuZGVkIG92ZXIgYSBoaXQpXHJcbiAgICAtIGRyYWdlbmRcclxuICAgICovXHJcbiAgICBjbGFzcyBIaXREcmFnZ2luZyB7XHJcbiAgICAgICAgY29uc3RydWN0b3IoZHJhZ2dpbmcsIGRyb3BwYWJsZVN0b3JlKSB7XHJcbiAgICAgICAgICAgIC8vIG9wdGlvbnMgdGhhdCBjYW4gYmUgc2V0IGJ5IGNhbGxlclxyXG4gICAgICAgICAgICB0aGlzLnVzZVN1YmplY3RDZW50ZXIgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5yZXF1aXJlSW5pdGlhbCA9IHRydWU7IC8vIGlmIGRvZXNuJ3Qgc3RhcnQgb3V0IG9uIGEgaGl0LCB3b24ndCBlbWl0IGFueSBldmVudHNcclxuICAgICAgICAgICAgdGhpcy5pbml0aWFsSGl0ID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5tb3ZpbmdIaXQgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLmZpbmFsSGl0ID0gbnVsbDsgLy8gd29uJ3QgZXZlciBiZSBwb3B1bGF0ZWQgaWYgc2hvdWxkSWdub3JlTW92ZVxyXG4gICAgICAgICAgICB0aGlzLmhhbmRsZVBvaW50ZXJEb3duID0gKGV2KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBsZXQgeyBkcmFnZ2luZyB9ID0gdGhpcztcclxuICAgICAgICAgICAgICAgIHRoaXMuaW5pdGlhbEhpdCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1vdmluZ0hpdCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmZpbmFsSGl0ID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIHRoaXMucHJlcGFyZUhpdHMoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMucHJvY2Vzc0ZpcnN0Q29vcmQoZXYpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaW5pdGlhbEhpdCB8fCAhdGhpcy5yZXF1aXJlSW5pdGlhbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRyYWdnaW5nLnNldElnbm9yZU1vdmUoZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IGZpcmUgdGhpcyBiZWZvcmUgY29tcHV0aW5nIHByb2Nlc3NGaXJzdENvb3JkLCBzbyBsaXN0ZW5lcnMgY2FuIGNhbmNlbC4gdGhpcyBnZXRzIGZpcmVkIGJ5IGFsbW9zdCBldmVyeSBoYW5kbGVyIDooXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0dGVyLnRyaWdnZXIoJ3BvaW50ZXJkb3duJywgZXYpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZHJhZ2dpbmcuc2V0SWdub3JlTW92ZSh0cnVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdGhpcy5oYW5kbGVEcmFnU3RhcnQgPSAoZXYpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdHRlci50cmlnZ2VyKCdkcmFnc3RhcnQnLCBldik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZU1vdmUoZXYsIHRydWUpOyAvLyBmb3JjZSA9IGZpcmUgZXZlbiBpZiBpbml0aWFsbHkgbnVsbFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB0aGlzLmhhbmRsZURyYWdNb3ZlID0gKGV2KSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXR0ZXIudHJpZ2dlcignZHJhZ21vdmUnLCBldik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZU1vdmUoZXYpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB0aGlzLmhhbmRsZVBvaW50ZXJVcCA9IChldikgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZWxlYXNlSGl0cygpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0dGVyLnRyaWdnZXIoJ3BvaW50ZXJ1cCcsIGV2KTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdGhpcy5oYW5kbGVEcmFnRW5kID0gKGV2KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5tb3ZpbmdIaXQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXR0ZXIudHJpZ2dlcignaGl0dXBkYXRlJywgbnVsbCwgdHJ1ZSwgZXYpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5maW5hbEhpdCA9IHRoaXMubW92aW5nSGl0O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tb3ZpbmdIaXQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0dGVyLnRyaWdnZXIoJ2RyYWdlbmQnLCBldik7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHRoaXMuZHJvcHBhYmxlU3RvcmUgPSBkcm9wcGFibGVTdG9yZTtcclxuICAgICAgICAgICAgZHJhZ2dpbmcuZW1pdHRlci5vbigncG9pbnRlcmRvd24nLCB0aGlzLmhhbmRsZVBvaW50ZXJEb3duKTtcclxuICAgICAgICAgICAgZHJhZ2dpbmcuZW1pdHRlci5vbignZHJhZ3N0YXJ0JywgdGhpcy5oYW5kbGVEcmFnU3RhcnQpO1xyXG4gICAgICAgICAgICBkcmFnZ2luZy5lbWl0dGVyLm9uKCdkcmFnbW92ZScsIHRoaXMuaGFuZGxlRHJhZ01vdmUpO1xyXG4gICAgICAgICAgICBkcmFnZ2luZy5lbWl0dGVyLm9uKCdwb2ludGVydXAnLCB0aGlzLmhhbmRsZVBvaW50ZXJVcCk7XHJcbiAgICAgICAgICAgIGRyYWdnaW5nLmVtaXR0ZXIub24oJ2RyYWdlbmQnLCB0aGlzLmhhbmRsZURyYWdFbmQpO1xyXG4gICAgICAgICAgICB0aGlzLmRyYWdnaW5nID0gZHJhZ2dpbmc7XHJcbiAgICAgICAgICAgIHRoaXMuZW1pdHRlciA9IG5ldyBFbWl0dGVyKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHNldHMgaW5pdGlhbEhpdFxyXG4gICAgICAgIC8vIHNldHMgY29vcmRBZGp1c3RcclxuICAgICAgICBwcm9jZXNzRmlyc3RDb29yZChldikge1xyXG4gICAgICAgICAgICBsZXQgb3JpZ1BvaW50ID0geyBsZWZ0OiBldi5wYWdlWCwgdG9wOiBldi5wYWdlWSB9O1xyXG4gICAgICAgICAgICBsZXQgYWRqdXN0ZWRQb2ludCA9IG9yaWdQb2ludDtcclxuICAgICAgICAgICAgbGV0IHN1YmplY3RFbCA9IGV2LnN1YmplY3RFbDtcclxuICAgICAgICAgICAgbGV0IHN1YmplY3RSZWN0O1xyXG4gICAgICAgICAgICBpZiAoc3ViamVjdEVsIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHsgLy8gaS5lLiBub3QgYSBEb2N1bWVudC9TaGFkb3dSb290XHJcbiAgICAgICAgICAgICAgICBzdWJqZWN0UmVjdCA9IGNvbXB1dGVSZWN0KHN1YmplY3RFbCk7XHJcbiAgICAgICAgICAgICAgICBhZGp1c3RlZFBvaW50ID0gY29uc3RyYWluUG9pbnQoYWRqdXN0ZWRQb2ludCwgc3ViamVjdFJlY3QpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxldCBpbml0aWFsSGl0ID0gdGhpcy5pbml0aWFsSGl0ID0gdGhpcy5xdWVyeUhpdEZvck9mZnNldChhZGp1c3RlZFBvaW50LmxlZnQsIGFkanVzdGVkUG9pbnQudG9wKTtcclxuICAgICAgICAgICAgaWYgKGluaXRpYWxIaXQpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnVzZVN1YmplY3RDZW50ZXIgJiYgc3ViamVjdFJlY3QpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgc2xpY2VkU3ViamVjdFJlY3QgPSBpbnRlcnNlY3RSZWN0cyhzdWJqZWN0UmVjdCwgaW5pdGlhbEhpdC5yZWN0KTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2xpY2VkU3ViamVjdFJlY3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWRqdXN0ZWRQb2ludCA9IGdldFJlY3RDZW50ZXIoc2xpY2VkU3ViamVjdFJlY3QpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuY29vcmRBZGp1c3QgPSBkaWZmUG9pbnRzKGFkanVzdGVkUG9pbnQsIG9yaWdQb2ludCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvb3JkQWRqdXN0ID0geyBsZWZ0OiAwLCB0b3A6IDAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBoYW5kbGVNb3ZlKGV2LCBmb3JjZUhhbmRsZSkge1xyXG4gICAgICAgICAgICBsZXQgaGl0ID0gdGhpcy5xdWVyeUhpdEZvck9mZnNldChldi5wYWdlWCArIHRoaXMuY29vcmRBZGp1c3QubGVmdCwgZXYucGFnZVkgKyB0aGlzLmNvb3JkQWRqdXN0LnRvcCk7XHJcbiAgICAgICAgICAgIGlmIChmb3JjZUhhbmRsZSB8fCAhaXNIaXRzRXF1YWwodGhpcy5tb3ZpbmdIaXQsIGhpdCkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubW92aW5nSGl0ID0gaGl0O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0dGVyLnRyaWdnZXIoJ2hpdHVwZGF0ZScsIGhpdCwgZmFsc2UsIGV2KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBwcmVwYXJlSGl0cygpIHtcclxuICAgICAgICAgICAgdGhpcy5vZmZzZXRUcmFja2VycyA9IG1hcEhhc2godGhpcy5kcm9wcGFibGVTdG9yZSwgKGludGVyYWN0aW9uU2V0dGluZ3MpID0+IHtcclxuICAgICAgICAgICAgICAgIGludGVyYWN0aW9uU2V0dGluZ3MuY29tcG9uZW50LnByZXBhcmVIaXRzKCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IE9mZnNldFRyYWNrZXIoaW50ZXJhY3Rpb25TZXR0aW5ncy5lbCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZWxlYXNlSGl0cygpIHtcclxuICAgICAgICAgICAgbGV0IHsgb2Zmc2V0VHJhY2tlcnMgfSA9IHRoaXM7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGlkIGluIG9mZnNldFRyYWNrZXJzKSB7XHJcbiAgICAgICAgICAgICAgICBvZmZzZXRUcmFja2Vyc1tpZF0uZGVzdHJveSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMub2Zmc2V0VHJhY2tlcnMgPSB7fTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcXVlcnlIaXRGb3JPZmZzZXQob2Zmc2V0TGVmdCwgb2Zmc2V0VG9wKSB7XHJcbiAgICAgICAgICAgIGxldCB7IGRyb3BwYWJsZVN0b3JlLCBvZmZzZXRUcmFja2VycyB9ID0gdGhpcztcclxuICAgICAgICAgICAgbGV0IGJlc3RIaXQgPSBudWxsO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpZCBpbiBkcm9wcGFibGVTdG9yZSkge1xyXG4gICAgICAgICAgICAgICAgbGV0IGNvbXBvbmVudCA9IGRyb3BwYWJsZVN0b3JlW2lkXS5jb21wb25lbnQ7XHJcbiAgICAgICAgICAgICAgICBsZXQgb2Zmc2V0VHJhY2tlciA9IG9mZnNldFRyYWNrZXJzW2lkXTtcclxuICAgICAgICAgICAgICAgIGlmIChvZmZzZXRUcmFja2VyICYmIC8vIHdhc24ndCBkZXN0cm95ZWQgbWlkLWRyYWdcclxuICAgICAgICAgICAgICAgICAgICBvZmZzZXRUcmFja2VyLmlzV2l0aGluQ2xpcHBpbmcob2Zmc2V0TGVmdCwgb2Zmc2V0VG9wKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBvcmlnaW5MZWZ0ID0gb2Zmc2V0VHJhY2tlci5jb21wdXRlTGVmdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBvcmlnaW5Ub3AgPSBvZmZzZXRUcmFja2VyLmNvbXB1dGVUb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgcG9zaXRpb25MZWZ0ID0gb2Zmc2V0TGVmdCAtIG9yaWdpbkxlZnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBvc2l0aW9uVG9wID0gb2Zmc2V0VG9wIC0gb3JpZ2luVG9wO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCB7IG9yaWdSZWN0IH0gPSBvZmZzZXRUcmFja2VyO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCB3aWR0aCA9IG9yaWdSZWN0LnJpZ2h0IC0gb3JpZ1JlY3QubGVmdDtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgaGVpZ2h0ID0gb3JpZ1JlY3QuYm90dG9tIC0gb3JpZ1JlY3QudG9wO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgICAgICAgICAvLyBtdXN0IGJlIHdpdGhpbiB0aGUgZWxlbWVudCdzIGJvdW5kc1xyXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uTGVmdCA+PSAwICYmIHBvc2l0aW9uTGVmdCA8IHdpZHRoICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uVG9wID49IDAgJiYgcG9zaXRpb25Ub3AgPCBoZWlnaHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGhpdCA9IGNvbXBvbmVudC5xdWVyeUhpdChwb3NpdGlvbkxlZnQsIHBvc2l0aW9uVG9wLCB3aWR0aCwgaGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhpdCAmJiAoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSB0aGUgaGl0IGlzIHdpdGhpbiBhY3RpdmVSYW5nZSwgbWVhbmluZyBpdCdzIG5vdCBhIGRlYWQgY2VsbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByYW5nZUNvbnRhaW5zUmFuZ2UoaGl0LmRhdGVQcm9maWxlLmFjdGl2ZVJhbmdlLCBoaXQuZGF0ZVNwYW4ucmFuZ2UpKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKCFiZXN0SGl0IHx8IGhpdC5sYXllciA+IGJlc3RIaXQubGF5ZXIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaXQuY29tcG9uZW50SWQgPSBpZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhpdC5jb250ZXh0ID0gY29tcG9uZW50LmNvbnRleHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBiZXR0ZXIgd2F5IHRvIHJlLW9yaWVudCByZWN0YW5nbGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhpdC5yZWN0LmxlZnQgKz0gb3JpZ2luTGVmdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhpdC5yZWN0LnJpZ2h0ICs9IG9yaWdpbkxlZnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaXQucmVjdC50b3AgKz0gb3JpZ2luVG9wO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGl0LnJlY3QuYm90dG9tICs9IG9yaWdpblRvcDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RIaXQgPSBoaXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGJlc3RIaXQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gaXNIaXRzRXF1YWwoaGl0MCwgaGl0MSkge1xyXG4gICAgICAgIGlmICghaGl0MCAmJiAhaGl0MSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKEJvb2xlYW4oaGl0MCkgIT09IEJvb2xlYW4oaGl0MSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaXNEYXRlU3BhbnNFcXVhbChoaXQwLmRhdGVTcGFuLCBoaXQxLmRhdGVTcGFuKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBidWlsZERhdGVQb2ludEFwaVdpdGhDb250ZXh0KGRhdGVTcGFuLCBjb250ZXh0KSB7XHJcbiAgICAgICAgbGV0IHByb3BzID0ge307XHJcbiAgICAgICAgZm9yIChsZXQgdHJhbnNmb3JtIG9mIGNvbnRleHQucGx1Z2luSG9va3MuZGF0ZVBvaW50VHJhbnNmb3Jtcykge1xyXG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHByb3BzLCB0cmFuc2Zvcm0oZGF0ZVNwYW4sIGNvbnRleHQpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgT2JqZWN0LmFzc2lnbihwcm9wcywgYnVpbGREYXRlUG9pbnRBcGkoZGF0ZVNwYW4sIGNvbnRleHQuZGF0ZUVudikpO1xyXG4gICAgICAgIHJldHVybiBwcm9wcztcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGJ1aWxkRGF0ZVBvaW50QXBpKHNwYW4sIGRhdGVFbnYpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBkYXRlOiBkYXRlRW52LnRvRGF0ZShzcGFuLnJhbmdlLnN0YXJ0KSxcclxuICAgICAgICAgICAgZGF0ZVN0cjogZGF0ZUVudi5mb3JtYXRJc28oc3Bhbi5yYW5nZS5zdGFydCwgeyBvbWl0VGltZTogc3Bhbi5hbGxEYXkgfSksXHJcbiAgICAgICAgICAgIGFsbERheTogc3Bhbi5hbGxEYXksXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICAvKlxyXG4gICAgTW9uaXRvcnMgd2hlbiB0aGUgdXNlciBjbGlja3Mgb24gYSBzcGVjaWZpYyBkYXRlL3RpbWUgb2YgYSBjb21wb25lbnQuXHJcbiAgICBBIHBvaW50ZXJkb3duK3BvaW50ZXJ1cCBvbiB0aGUgc2FtZSBcImhpdFwiIGNvbnN0aXR1dGVzIGEgY2xpY2suXHJcbiAgICAqL1xyXG4gICAgY2xhc3MgRGF0ZUNsaWNraW5nIGV4dGVuZHMgSW50ZXJhY3Rpb24ge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yKHNldHRpbmdzKSB7XHJcbiAgICAgICAgICAgIHN1cGVyKHNldHRpbmdzKTtcclxuICAgICAgICAgICAgdGhpcy5oYW5kbGVQb2ludGVyRG93biA9IChwZXYpID0+IHtcclxuICAgICAgICAgICAgICAgIGxldCB7IGRyYWdnaW5nIH0gPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgbGV0IGRvd25FbCA9IHBldi5vcmlnRXZlbnQudGFyZ2V0O1xyXG4gICAgICAgICAgICAgICAgLy8gZG8gdGhpcyBpbiBwb2ludGVyZG93biAobm90IGRyYWdlbmQpIGJlY2F1c2UgRE9NIG1pZ2h0IGJlIG11dGF0ZWQgYnkgdGhlIHRpbWUgZHJhZ2VuZCBpcyBmaXJlZFxyXG4gICAgICAgICAgICAgICAgZHJhZ2dpbmcuc2V0SWdub3JlTW92ZSghdGhpcy5jb21wb25lbnQuaXNWYWxpZERhdGVEb3duRWwoZG93bkVsKSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8vIHdvbid0IGV2ZW4gZmlyZSBpZiBtb3Zpbmcgd2FzIGlnbm9yZWRcclxuICAgICAgICAgICAgdGhpcy5oYW5kbGVEcmFnRW5kID0gKGV2KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBsZXQgeyBjb21wb25lbnQgfSA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICBsZXQgeyBwb2ludGVyIH0gPSB0aGlzLmRyYWdnaW5nO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFwb2ludGVyLndhc1RvdWNoU2Nyb2xsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHsgaW5pdGlhbEhpdCwgZmluYWxIaXQgfSA9IHRoaXMuaGl0RHJhZ2dpbmc7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluaXRpYWxIaXQgJiYgZmluYWxIaXQgJiYgaXNIaXRzRXF1YWwoaW5pdGlhbEhpdCwgZmluYWxIaXQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB7IGNvbnRleHQgfSA9IGNvbXBvbmVudDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGFyZyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgYnVpbGREYXRlUG9pbnRBcGlXaXRoQ29udGV4dChpbml0aWFsSGl0LmRhdGVTcGFuLCBjb250ZXh0KSksIHsgZGF5RWw6IGluaXRpYWxIaXQuZGF5RWwsIGpzRXZlbnQ6IGV2Lm9yaWdFdmVudCwgdmlldzogY29udGV4dC52aWV3QXBpIHx8IGNvbnRleHQuY2FsZW5kYXJBcGkudmlldyB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5lbWl0dGVyLnRyaWdnZXIoJ2RhdGVDbGljaycsIGFyZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvLyB3ZSBETyB3YW50IHRvIHdhdGNoIHBvaW50ZXIgbW92ZXMgYmVjYXVzZSBvdGhlcndpc2UgZmluYWxIaXQgd29uJ3QgZ2V0IHBvcHVsYXRlZFxyXG4gICAgICAgICAgICB0aGlzLmRyYWdnaW5nID0gbmV3IEZlYXR1cmVmdWxFbGVtZW50RHJhZ2dpbmcoc2V0dGluZ3MuZWwpO1xyXG4gICAgICAgICAgICB0aGlzLmRyYWdnaW5nLmF1dG9TY3JvbGxlci5pc0VuYWJsZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgbGV0IGhpdERyYWdnaW5nID0gdGhpcy5oaXREcmFnZ2luZyA9IG5ldyBIaXREcmFnZ2luZyh0aGlzLmRyYWdnaW5nLCBpbnRlcmFjdGlvblNldHRpbmdzVG9TdG9yZShzZXR0aW5ncykpO1xyXG4gICAgICAgICAgICBoaXREcmFnZ2luZy5lbWl0dGVyLm9uKCdwb2ludGVyZG93bicsIHRoaXMuaGFuZGxlUG9pbnRlckRvd24pO1xyXG4gICAgICAgICAgICBoaXREcmFnZ2luZy5lbWl0dGVyLm9uKCdkcmFnZW5kJywgdGhpcy5oYW5kbGVEcmFnRW5kKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZGVzdHJveSgpIHtcclxuICAgICAgICAgICAgdGhpcy5kcmFnZ2luZy5kZXN0cm95KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qXHJcbiAgICBUcmFja3Mgd2hlbiB0aGUgdXNlciBzZWxlY3RzIGEgcG9ydGlvbiBvZiB0aW1lIG9mIGEgY29tcG9uZW50LFxyXG4gICAgY29uc3RpdHV0ZWQgYnkgYSBkcmFnIG92ZXIgZGF0ZSBjZWxscywgd2l0aCBhIHBvc3NpYmxlIGRlbGF5IGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGRyYWcuXHJcbiAgICAqL1xyXG4gICAgY2xhc3MgRGF0ZVNlbGVjdGluZyBleHRlbmRzIEludGVyYWN0aW9uIHtcclxuICAgICAgICBjb25zdHJ1Y3RvcihzZXR0aW5ncykge1xyXG4gICAgICAgICAgICBzdXBlcihzZXR0aW5ncyk7XHJcbiAgICAgICAgICAgIHRoaXMuZHJhZ1NlbGVjdGlvbiA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlUG9pbnRlckRvd24gPSAoZXYpID0+IHtcclxuICAgICAgICAgICAgICAgIGxldCB7IGNvbXBvbmVudCwgZHJhZ2dpbmcgfSA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICBsZXQgeyBvcHRpb25zIH0gPSBjb21wb25lbnQuY29udGV4dDtcclxuICAgICAgICAgICAgICAgIGxldCBjYW5TZWxlY3QgPSBvcHRpb25zLnNlbGVjdGFibGUgJiZcclxuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQuaXNWYWxpZERhdGVEb3duRWwoZXYub3JpZ0V2ZW50LnRhcmdldCk7XHJcbiAgICAgICAgICAgICAgICAvLyBkb24ndCBib3RoZXIgdG8gd2F0Y2ggZXhwZW5zaXZlIG1vdmVzIGlmIGNvbXBvbmVudCB3b24ndCBkbyBzZWxlY3Rpb25cclxuICAgICAgICAgICAgICAgIGRyYWdnaW5nLnNldElnbm9yZU1vdmUoIWNhblNlbGVjdCk7XHJcbiAgICAgICAgICAgICAgICAvLyBpZiB0b3VjaCwgcmVxdWlyZSB1c2VyIHRvIGhvbGQgZG93blxyXG4gICAgICAgICAgICAgICAgZHJhZ2dpbmcuZGVsYXkgPSBldi5pc1RvdWNoID8gZ2V0Q29tcG9uZW50VG91Y2hEZWxheSQxKGNvbXBvbmVudCkgOiBudWxsO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB0aGlzLmhhbmRsZURyYWdTdGFydCA9IChldikgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb21wb25lbnQuY29udGV4dC5jYWxlbmRhckFwaS51bnNlbGVjdChldik7IC8vIHVuc2VsZWN0IHByZXZpb3VzIHNlbGVjdGlvbnNcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdGhpcy5oYW5kbGVIaXRVcGRhdGUgPSAoaGl0LCBpc0ZpbmFsKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBsZXQgeyBjb250ZXh0IH0gPSB0aGlzLmNvbXBvbmVudDtcclxuICAgICAgICAgICAgICAgIGxldCBkcmFnU2VsZWN0aW9uID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIGxldCBpc0ludmFsaWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGlmIChoaXQpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgaW5pdGlhbEhpdCA9IHRoaXMuaGl0RHJhZ2dpbmcuaW5pdGlhbEhpdDtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgZGlzYWxsb3dlZCA9IGhpdC5jb21wb25lbnRJZCA9PT0gaW5pdGlhbEhpdC5jb21wb25lbnRJZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAmJiB0aGlzLmlzSGl0Q29tYm9BbGxvd2VkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICYmICF0aGlzLmlzSGl0Q29tYm9BbGxvd2VkKGluaXRpYWxIaXQsIGhpdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkaXNhbGxvd2VkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyYWdTZWxlY3Rpb24gPSBqb2luSGl0c0ludG9TZWxlY3Rpb24oaW5pdGlhbEhpdCwgaGl0LCBjb250ZXh0LnBsdWdpbkhvb2tzLmRhdGVTZWxlY3Rpb25UcmFuc2Zvcm1lcnMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWRyYWdTZWxlY3Rpb24gfHwgIWlzRGF0ZVNlbGVjdGlvblZhbGlkKGRyYWdTZWxlY3Rpb24sIGhpdC5kYXRlUHJvZmlsZSwgY29udGV4dCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXNJbnZhbGlkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZHJhZ1NlbGVjdGlvbiA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGRyYWdTZWxlY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmRpc3BhdGNoKHsgdHlwZTogJ1NFTEVDVF9EQVRFUycsIHNlbGVjdGlvbjogZHJhZ1NlbGVjdGlvbiB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFpc0ZpbmFsKSB7IC8vIG9ubHkgdW5zZWxlY3QgaWYgbW92ZWQgYXdheSB3aGlsZSBkcmFnZ2luZ1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuZGlzcGF0Y2goeyB0eXBlOiAnVU5TRUxFQ1RfREFURVMnIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCFpc0ludmFsaWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBlbmFibGVDdXJzb3IoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGRpc2FibGVDdXJzb3IoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICghaXNGaW5hbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhZ1NlbGVjdGlvbiA9IGRyYWdTZWxlY3Rpb247IC8vIG9ubHkgY2xlYXIgaWYgbW92ZWQgYXdheSBmcm9tIGFsbCBoaXRzIHdoaWxlIGRyYWdnaW5nXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlUG9pbnRlclVwID0gKHBldikgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZHJhZ1NlbGVjdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHNlbGVjdGlvbiBpcyBhbHJlYWR5IHJlbmRlcmVkLCBzbyBqdXN0IG5lZWQgdG8gcmVwb3J0IHNlbGVjdGlvblxyXG4gICAgICAgICAgICAgICAgICAgIHRyaWdnZXJEYXRlU2VsZWN0KHRoaXMuZHJhZ1NlbGVjdGlvbiwgcGV2LCB0aGlzLmNvbXBvbmVudC5jb250ZXh0KTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYWdTZWxlY3Rpb24gPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBsZXQgeyBjb21wb25lbnQgfSA9IHNldHRpbmdzO1xyXG4gICAgICAgICAgICBsZXQgeyBvcHRpb25zIH0gPSBjb21wb25lbnQuY29udGV4dDtcclxuICAgICAgICAgICAgbGV0IGRyYWdnaW5nID0gdGhpcy5kcmFnZ2luZyA9IG5ldyBGZWF0dXJlZnVsRWxlbWVudERyYWdnaW5nKHNldHRpbmdzLmVsKTtcclxuICAgICAgICAgICAgZHJhZ2dpbmcudG91Y2hTY3JvbGxBbGxvd2VkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGRyYWdnaW5nLm1pbkRpc3RhbmNlID0gb3B0aW9ucy5zZWxlY3RNaW5EaXN0YW5jZSB8fCAwO1xyXG4gICAgICAgICAgICBkcmFnZ2luZy5hdXRvU2Nyb2xsZXIuaXNFbmFibGVkID0gb3B0aW9ucy5kcmFnU2Nyb2xsO1xyXG4gICAgICAgICAgICBsZXQgaGl0RHJhZ2dpbmcgPSB0aGlzLmhpdERyYWdnaW5nID0gbmV3IEhpdERyYWdnaW5nKHRoaXMuZHJhZ2dpbmcsIGludGVyYWN0aW9uU2V0dGluZ3NUb1N0b3JlKHNldHRpbmdzKSk7XHJcbiAgICAgICAgICAgIGhpdERyYWdnaW5nLmVtaXR0ZXIub24oJ3BvaW50ZXJkb3duJywgdGhpcy5oYW5kbGVQb2ludGVyRG93bik7XHJcbiAgICAgICAgICAgIGhpdERyYWdnaW5nLmVtaXR0ZXIub24oJ2RyYWdzdGFydCcsIHRoaXMuaGFuZGxlRHJhZ1N0YXJ0KTtcclxuICAgICAgICAgICAgaGl0RHJhZ2dpbmcuZW1pdHRlci5vbignaGl0dXBkYXRlJywgdGhpcy5oYW5kbGVIaXRVcGRhdGUpO1xyXG4gICAgICAgICAgICBoaXREcmFnZ2luZy5lbWl0dGVyLm9uKCdwb2ludGVydXAnLCB0aGlzLmhhbmRsZVBvaW50ZXJVcCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRlc3Ryb3koKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmcuZGVzdHJveSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGdldENvbXBvbmVudFRvdWNoRGVsYXkkMShjb21wb25lbnQpIHtcclxuICAgICAgICBsZXQgeyBvcHRpb25zIH0gPSBjb21wb25lbnQuY29udGV4dDtcclxuICAgICAgICBsZXQgZGVsYXkgPSBvcHRpb25zLnNlbGVjdExvbmdQcmVzc0RlbGF5O1xyXG4gICAgICAgIGlmIChkZWxheSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGRlbGF5ID0gb3B0aW9ucy5sb25nUHJlc3NEZWxheTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGRlbGF5O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gam9pbkhpdHNJbnRvU2VsZWN0aW9uKGhpdDAsIGhpdDEsIGRhdGVTZWxlY3Rpb25UcmFuc2Zvcm1lcnMpIHtcclxuICAgICAgICBsZXQgZGF0ZVNwYW4wID0gaGl0MC5kYXRlU3BhbjtcclxuICAgICAgICBsZXQgZGF0ZVNwYW4xID0gaGl0MS5kYXRlU3BhbjtcclxuICAgICAgICBsZXQgbXMgPSBbXHJcbiAgICAgICAgICAgIGRhdGVTcGFuMC5yYW5nZS5zdGFydCxcclxuICAgICAgICAgICAgZGF0ZVNwYW4wLnJhbmdlLmVuZCxcclxuICAgICAgICAgICAgZGF0ZVNwYW4xLnJhbmdlLnN0YXJ0LFxyXG4gICAgICAgICAgICBkYXRlU3BhbjEucmFuZ2UuZW5kLFxyXG4gICAgICAgIF07XHJcbiAgICAgICAgbXMuc29ydChjb21wYXJlTnVtYmVycyk7XHJcbiAgICAgICAgbGV0IHByb3BzID0ge307XHJcbiAgICAgICAgZm9yIChsZXQgdHJhbnNmb3JtZXIgb2YgZGF0ZVNlbGVjdGlvblRyYW5zZm9ybWVycykge1xyXG4gICAgICAgICAgICBsZXQgcmVzID0gdHJhbnNmb3JtZXIoaGl0MCwgaGl0MSk7XHJcbiAgICAgICAgICAgIGlmIChyZXMgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocmVzKSB7XHJcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHByb3BzLCByZXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHByb3BzLnJhbmdlID0geyBzdGFydDogbXNbMF0sIGVuZDogbXNbM10gfTtcclxuICAgICAgICBwcm9wcy5hbGxEYXkgPSBkYXRlU3BhbjAuYWxsRGF5O1xyXG4gICAgICAgIHJldHVybiBwcm9wcztcclxuICAgIH1cclxuXHJcbiAgICBjbGFzcyBFdmVudERyYWdnaW5nIGV4dGVuZHMgSW50ZXJhY3Rpb24ge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yKHNldHRpbmdzKSB7XHJcbiAgICAgICAgICAgIHN1cGVyKHNldHRpbmdzKTtcclxuICAgICAgICAgICAgLy8gaW50ZXJuYWwgc3RhdGVcclxuICAgICAgICAgICAgdGhpcy5zdWJqZWN0RWwgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLnN1YmplY3RTZWcgPSBudWxsOyAvLyB0aGUgc2VnIGJlaW5nIHNlbGVjdGVkL2RyYWdnZWRcclxuICAgICAgICAgICAgdGhpcy5pc0RyYWdnaW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnRSYW5nZSA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMucmVsZXZhbnRFdmVudHMgPSBudWxsOyAvLyB0aGUgZXZlbnRzIGJlaW5nIGRyYWdnZWRcclxuICAgICAgICAgICAgdGhpcy5yZWNlaXZpbmdDb250ZXh0ID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy52YWxpZE11dGF0aW9uID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5tdXRhdGVkUmVsZXZhbnRFdmVudHMgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLmhhbmRsZVBvaW50ZXJEb3duID0gKGV2KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBsZXQgb3JpZ1RhcmdldCA9IGV2Lm9yaWdFdmVudC50YXJnZXQ7XHJcbiAgICAgICAgICAgICAgICBsZXQgeyBjb21wb25lbnQsIGRyYWdnaW5nIH0gPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgbGV0IHsgbWlycm9yIH0gPSBkcmFnZ2luZztcclxuICAgICAgICAgICAgICAgIGxldCB7IG9wdGlvbnMgfSA9IGNvbXBvbmVudC5jb250ZXh0O1xyXG4gICAgICAgICAgICAgICAgbGV0IGluaXRpYWxDb250ZXh0ID0gY29tcG9uZW50LmNvbnRleHQ7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN1YmplY3RFbCA9IGV2LnN1YmplY3RFbDtcclxuICAgICAgICAgICAgICAgIGxldCBzdWJqZWN0U2VnID0gdGhpcy5zdWJqZWN0U2VnID0gZ2V0RWxTZWcoZXYuc3ViamVjdEVsKTtcclxuICAgICAgICAgICAgICAgIGxldCBldmVudFJhbmdlID0gdGhpcy5ldmVudFJhbmdlID0gc3ViamVjdFNlZy5ldmVudFJhbmdlO1xyXG4gICAgICAgICAgICAgICAgbGV0IGV2ZW50SW5zdGFuY2VJZCA9IGV2ZW50UmFuZ2UuaW5zdGFuY2UuaW5zdGFuY2VJZDtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVsZXZhbnRFdmVudHMgPSBnZXRSZWxldmFudEV2ZW50cyhpbml0aWFsQ29udGV4dC5nZXRDdXJyZW50RGF0YSgpLmV2ZW50U3RvcmUsIGV2ZW50SW5zdGFuY2VJZCk7XHJcbiAgICAgICAgICAgICAgICBkcmFnZ2luZy5taW5EaXN0YW5jZSA9IGV2LmlzVG91Y2ggPyAwIDogb3B0aW9ucy5ldmVudERyYWdNaW5EaXN0YW5jZTtcclxuICAgICAgICAgICAgICAgIGRyYWdnaW5nLmRlbGF5ID1cclxuICAgICAgICAgICAgICAgICAgICAvLyBvbmx5IGRvIGEgdG91Y2ggZGVsYXkgaWYgdG91Y2ggYW5kIHRoaXMgZXZlbnQgaGFzbid0IGJlZW4gc2VsZWN0ZWQgeWV0XHJcbiAgICAgICAgICAgICAgICAgICAgKGV2LmlzVG91Y2ggJiYgZXZlbnRJbnN0YW5jZUlkICE9PSBjb21wb25lbnQucHJvcHMuZXZlbnRTZWxlY3Rpb24pID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0Q29tcG9uZW50VG91Y2hEZWxheShjb21wb25lbnQpIDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgbnVsbDtcclxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmZpeGVkTWlycm9yUGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWlycm9yLnBhcmVudE5vZGUgPSBvcHRpb25zLmZpeGVkTWlycm9yUGFyZW50O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWlycm9yLnBhcmVudE5vZGUgPSBlbGVtZW50Q2xvc2VzdChvcmlnVGFyZ2V0LCAnLmZjJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBtaXJyb3IucmV2ZXJ0RHVyYXRpb24gPSBvcHRpb25zLmRyYWdSZXZlcnREdXJhdGlvbjtcclxuICAgICAgICAgICAgICAgIGxldCBpc1ZhbGlkID0gY29tcG9uZW50LmlzVmFsaWRTZWdEb3duRWwob3JpZ1RhcmdldCkgJiZcclxuICAgICAgICAgICAgICAgICAgICAhZWxlbWVudENsb3Nlc3Qob3JpZ1RhcmdldCwgJy5mYy1ldmVudC1yZXNpemVyJyk7IC8vIE5PVCBvbiBhIHJlc2l6ZXJcclxuICAgICAgICAgICAgICAgIGRyYWdnaW5nLnNldElnbm9yZU1vdmUoIWlzVmFsaWQpO1xyXG4gICAgICAgICAgICAgICAgLy8gZGlzYWJsZSBkcmFnZ2luZyBmb3IgZWxlbWVudHMgdGhhdCBhcmUgcmVzaXphYmxlIChpZSwgc2VsZWN0YWJsZSlcclxuICAgICAgICAgICAgICAgIC8vIGJ1dCBhcmUgbm90IGRyYWdnYWJsZVxyXG4gICAgICAgICAgICAgICAgdGhpcy5pc0RyYWdnaW5nID0gaXNWYWxpZCAmJlxyXG4gICAgICAgICAgICAgICAgICAgIGV2LnN1YmplY3RFbC5jbGFzc0xpc3QuY29udGFpbnMoJ2ZjLWV2ZW50LWRyYWdnYWJsZScpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB0aGlzLmhhbmRsZURyYWdTdGFydCA9IChldikgPT4ge1xyXG4gICAgICAgICAgICAgICAgbGV0IGluaXRpYWxDb250ZXh0ID0gdGhpcy5jb21wb25lbnQuY29udGV4dDtcclxuICAgICAgICAgICAgICAgIGxldCBldmVudFJhbmdlID0gdGhpcy5ldmVudFJhbmdlO1xyXG4gICAgICAgICAgICAgICAgbGV0IGV2ZW50SW5zdGFuY2VJZCA9IGV2ZW50UmFuZ2UuaW5zdGFuY2UuaW5zdGFuY2VJZDtcclxuICAgICAgICAgICAgICAgIGlmIChldi5pc1RvdWNoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gbmVlZCB0byBzZWxlY3QgYSBkaWZmZXJlbnQgZXZlbnQ/XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50SW5zdGFuY2VJZCAhPT0gdGhpcy5jb21wb25lbnQucHJvcHMuZXZlbnRTZWxlY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5pdGlhbENvbnRleHQuZGlzcGF0Y2goeyB0eXBlOiAnU0VMRUNUX0VWRU5UJywgZXZlbnRJbnN0YW5jZUlkIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIG5vdyB1c2luZyBtb3VzZSwgYnV0IHdhcyBwcmV2aW91cyB0b3VjaCBpbnRlcmFjdGlvbiwgY2xlYXIgc2VsZWN0ZWQgZXZlbnRcclxuICAgICAgICAgICAgICAgICAgICBpbml0aWFsQ29udGV4dC5kaXNwYXRjaCh7IHR5cGU6ICdVTlNFTEVDVF9FVkVOVCcgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc0RyYWdnaW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5pdGlhbENvbnRleHQuY2FsZW5kYXJBcGkudW5zZWxlY3QoZXYpOyAvLyB1bnNlbGVjdCAqZGF0ZSogc2VsZWN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgaW5pdGlhbENvbnRleHQuZW1pdHRlci50cmlnZ2VyKCdldmVudERyYWdTdGFydCcsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWw6IHRoaXMuc3ViamVjdEVsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudDogbmV3IEV2ZW50SW1wbChpbml0aWFsQ29udGV4dCwgZXZlbnRSYW5nZS5kZWYsIGV2ZW50UmFuZ2UuaW5zdGFuY2UpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBqc0V2ZW50OiBldi5vcmlnRXZlbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpZXc6IGluaXRpYWxDb250ZXh0LnZpZXdBcGksXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlSGl0VXBkYXRlID0gKGhpdCwgaXNGaW5hbCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmlzRHJhZ2dpbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBsZXQgcmVsZXZhbnRFdmVudHMgPSB0aGlzLnJlbGV2YW50RXZlbnRzO1xyXG4gICAgICAgICAgICAgICAgbGV0IGluaXRpYWxIaXQgPSB0aGlzLmhpdERyYWdnaW5nLmluaXRpYWxIaXQ7XHJcbiAgICAgICAgICAgICAgICBsZXQgaW5pdGlhbENvbnRleHQgPSB0aGlzLmNvbXBvbmVudC5jb250ZXh0O1xyXG4gICAgICAgICAgICAgICAgLy8gc3RhdGVzIGJhc2VkIG9uIG5ldyBoaXRcclxuICAgICAgICAgICAgICAgIGxldCByZWNlaXZpbmdDb250ZXh0ID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIGxldCBtdXRhdGlvbiA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICBsZXQgbXV0YXRlZFJlbGV2YW50RXZlbnRzID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIGxldCBpc0ludmFsaWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGxldCBpbnRlcmFjdGlvbiA9IHtcclxuICAgICAgICAgICAgICAgICAgICBhZmZlY3RlZEV2ZW50czogcmVsZXZhbnRFdmVudHMsXHJcbiAgICAgICAgICAgICAgICAgICAgbXV0YXRlZEV2ZW50czogY3JlYXRlRW1wdHlFdmVudFN0b3JlKCksXHJcbiAgICAgICAgICAgICAgICAgICAgaXNFdmVudDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBpZiAoaGl0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVjZWl2aW5nQ29udGV4dCA9IGhpdC5jb250ZXh0O1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCByZWNlaXZpbmdPcHRpb25zID0gcmVjZWl2aW5nQ29udGV4dC5vcHRpb25zO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbml0aWFsQ29udGV4dCA9PT0gcmVjZWl2aW5nQ29udGV4dCB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAocmVjZWl2aW5nT3B0aW9ucy5lZGl0YWJsZSAmJiByZWNlaXZpbmdPcHRpb25zLmRyb3BwYWJsZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbXV0YXRpb24gPSBjb21wdXRlRXZlbnRNdXRhdGlvbihpbml0aWFsSGl0LCBoaXQsIHJlY2VpdmluZ0NvbnRleHQuZ2V0Q3VycmVudERhdGEoKS5wbHVnaW5Ib29rcy5ldmVudERyYWdNdXRhdGlvbk1hc3NhZ2Vycyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtdXRhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbXV0YXRlZFJlbGV2YW50RXZlbnRzID0gYXBwbHlNdXRhdGlvblRvRXZlbnRTdG9yZShyZWxldmFudEV2ZW50cywgcmVjZWl2aW5nQ29udGV4dC5nZXRDdXJyZW50RGF0YSgpLmV2ZW50VWlCYXNlcywgbXV0YXRpb24sIHJlY2VpdmluZ0NvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJhY3Rpb24ubXV0YXRlZEV2ZW50cyA9IG11dGF0ZWRSZWxldmFudEV2ZW50cztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNJbnRlcmFjdGlvblZhbGlkKGludGVyYWN0aW9uLCBoaXQuZGF0ZVByb2ZpbGUsIHJlY2VpdmluZ0NvbnRleHQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNJbnZhbGlkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtdXRhdGlvbiA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbXV0YXRlZFJlbGV2YW50RXZlbnRzID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRlcmFjdGlvbi5tdXRhdGVkRXZlbnRzID0gY3JlYXRlRW1wdHlFdmVudFN0b3JlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpdmluZ0NvbnRleHQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGxheURyYWcocmVjZWl2aW5nQ29udGV4dCwgaW50ZXJhY3Rpb24pO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc0ludmFsaWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBlbmFibGVDdXJzb3IoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGRpc2FibGVDdXJzb3IoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICghaXNGaW5hbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbml0aWFsQ29udGV4dCA9PT0gcmVjZWl2aW5nQ29udGV4dCAmJiAvLyBUT0RPOiB3cml0ZSB0ZXN0IGZvciB0aGlzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzSGl0c0VxdWFsKGluaXRpYWxIaXQsIGhpdCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbXV0YXRpb24gPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYWdnaW5nLnNldE1pcnJvck5lZWRzUmV2ZXJ0KCFtdXRhdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVuZGVyIHRoZSBtaXJyb3IgaWYgbm8gYWxyZWFkeS1yZW5kZXJlZCBtaXJyb3JcclxuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiB3aXNoIHdlIGNvdWxkIHNvbWVob3cgd2FpdCBmb3IgZGlzcGF0Y2ggdG8gZ3VhcmFudGVlIHJlbmRlclxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmcuc2V0TWlycm9ySXNWaXNpYmxlKCFoaXQgfHwgIXRoaXMuc3ViamVjdEVsLmdldFJvb3ROb2RlKCkucXVlcnlTZWxlY3RvcignLmZjLWV2ZW50LW1pcnJvcicpKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBhc3NpZ24gc3RhdGVzIGJhc2VkIG9uIG5ldyBoaXRcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlY2VpdmluZ0NvbnRleHQgPSByZWNlaXZpbmdDb250ZXh0O1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmFsaWRNdXRhdGlvbiA9IG11dGF0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubXV0YXRlZFJlbGV2YW50RXZlbnRzID0gbXV0YXRlZFJlbGV2YW50RXZlbnRzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB0aGlzLmhhbmRsZVBvaW50ZXJVcCA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5pc0RyYWdnaW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGVhbnVwKCk7IC8vIGJlY2F1c2UgaGFuZGxlRHJhZ0VuZCB3b24ndCBmaXJlXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlRHJhZ0VuZCA9IChldikgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNEcmFnZ2luZykge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBpbml0aWFsQ29udGV4dCA9IHRoaXMuY29tcG9uZW50LmNvbnRleHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGluaXRpYWxWaWV3ID0gaW5pdGlhbENvbnRleHQudmlld0FwaTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgeyByZWNlaXZpbmdDb250ZXh0LCB2YWxpZE11dGF0aW9uIH0gPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBldmVudERlZiA9IHRoaXMuZXZlbnRSYW5nZS5kZWY7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGV2ZW50SW5zdGFuY2UgPSB0aGlzLmV2ZW50UmFuZ2UuaW5zdGFuY2U7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGV2ZW50QXBpID0gbmV3IEV2ZW50SW1wbChpbml0aWFsQ29udGV4dCwgZXZlbnREZWYsIGV2ZW50SW5zdGFuY2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCByZWxldmFudEV2ZW50cyA9IHRoaXMucmVsZXZhbnRFdmVudHM7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IG11dGF0ZWRSZWxldmFudEV2ZW50cyA9IHRoaXMubXV0YXRlZFJlbGV2YW50RXZlbnRzO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCB7IGZpbmFsSGl0IH0gPSB0aGlzLmhpdERyYWdnaW5nO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJEcmFnKCk7IC8vIG11c3QgaGFwcGVuIGFmdGVyIHJldmVydCBhbmltYXRpb25cclxuICAgICAgICAgICAgICAgICAgICBpbml0aWFsQ29udGV4dC5lbWl0dGVyLnRyaWdnZXIoJ2V2ZW50RHJhZ1N0b3AnLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsOiB0aGlzLnN1YmplY3RFbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IGV2ZW50QXBpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBqc0V2ZW50OiBldi5vcmlnRXZlbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpZXc6IGluaXRpYWxWaWV3LFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWxpZE11dGF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRyb3BwZWQgd2l0aGluIHNhbWUgY2FsZW5kYXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlY2VpdmluZ0NvbnRleHQgPT09IGluaXRpYWxDb250ZXh0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgdXBkYXRlZEV2ZW50QXBpID0gbmV3IEV2ZW50SW1wbChpbml0aWFsQ29udGV4dCwgbXV0YXRlZFJlbGV2YW50RXZlbnRzLmRlZnNbZXZlbnREZWYuZGVmSWRdLCBldmVudEluc3RhbmNlID8gbXV0YXRlZFJlbGV2YW50RXZlbnRzLmluc3RhbmNlc1tldmVudEluc3RhbmNlLmluc3RhbmNlSWRdIDogbnVsbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbml0aWFsQ29udGV4dC5kaXNwYXRjaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ01FUkdFX0VWRU5UUycsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRTdG9yZTogbXV0YXRlZFJlbGV2YW50RXZlbnRzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZXZlbnRDaGFuZ2VBcmcgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2xkRXZlbnQ6IGV2ZW50QXBpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50OiB1cGRhdGVkRXZlbnRBcGksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVsYXRlZEV2ZW50czogYnVpbGRFdmVudEFwaXMobXV0YXRlZFJlbGV2YW50RXZlbnRzLCBpbml0aWFsQ29udGV4dCwgZXZlbnRJbnN0YW5jZSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV2ZXJ0KCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbml0aWFsQ29udGV4dC5kaXNwYXRjaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnTUVSR0VfRVZFTlRTJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50U3RvcmU6IHJlbGV2YW50RXZlbnRzLCAvLyB0aGUgcHJlLWNoYW5nZSBkYXRhXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHRyYW5zZm9ybWVkID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCB0cmFuc2Zvcm1lciBvZiBpbml0aWFsQ29udGV4dC5nZXRDdXJyZW50RGF0YSgpLnBsdWdpbkhvb2tzLmV2ZW50RHJvcFRyYW5zZm9ybWVycykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odHJhbnNmb3JtZWQsIHRyYW5zZm9ybWVyKHZhbGlkTXV0YXRpb24sIGluaXRpYWxDb250ZXh0KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbml0aWFsQ29udGV4dC5lbWl0dGVyLnRyaWdnZXIoJ2V2ZW50RHJvcCcsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBldmVudENoYW5nZUFyZyksIHRyYW5zZm9ybWVkKSwgeyBlbDogZXYuc3ViamVjdEVsLCBkZWx0YTogdmFsaWRNdXRhdGlvbi5kYXRlc0RlbHRhLCBqc0V2ZW50OiBldi5vcmlnRXZlbnQsIHZpZXc6IGluaXRpYWxWaWV3IH0pKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluaXRpYWxDb250ZXh0LmVtaXR0ZXIudHJpZ2dlcignZXZlbnRDaGFuZ2UnLCBldmVudENoYW5nZUFyZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkcm9wcGVkIGluIGRpZmZlcmVudCBjYWxlbmRhclxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlY2VpdmluZ0NvbnRleHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBldmVudFJlbW92ZUFyZyA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudDogZXZlbnRBcGksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVsYXRlZEV2ZW50czogYnVpbGRFdmVudEFwaXMocmVsZXZhbnRFdmVudHMsIGluaXRpYWxDb250ZXh0LCBldmVudEluc3RhbmNlKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXZlcnQoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluaXRpYWxDb250ZXh0LmRpc3BhdGNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdNRVJHRV9FVkVOVFMnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRTdG9yZTogcmVsZXZhbnRFdmVudHMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5pdGlhbENvbnRleHQuZW1pdHRlci50cmlnZ2VyKCdldmVudExlYXZlJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBldmVudFJlbW92ZUFyZyksIHsgZHJhZ2dlZEVsOiBldi5zdWJqZWN0RWwsIHZpZXc6IGluaXRpYWxWaWV3IH0pKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluaXRpYWxDb250ZXh0LmRpc3BhdGNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnUkVNT1ZFX0VWRU5UUycsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRTdG9yZTogcmVsZXZhbnRFdmVudHMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluaXRpYWxDb250ZXh0LmVtaXR0ZXIudHJpZ2dlcignZXZlbnRSZW1vdmUnLCBldmVudFJlbW92ZUFyZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgYWRkZWRFdmVudERlZiA9IG11dGF0ZWRSZWxldmFudEV2ZW50cy5kZWZzW2V2ZW50RGVmLmRlZklkXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBhZGRlZEV2ZW50SW5zdGFuY2UgPSBtdXRhdGVkUmVsZXZhbnRFdmVudHMuaW5zdGFuY2VzW2V2ZW50SW5zdGFuY2UuaW5zdGFuY2VJZF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgYWRkZWRFdmVudEFwaSA9IG5ldyBFdmVudEltcGwocmVjZWl2aW5nQ29udGV4dCwgYWRkZWRFdmVudERlZiwgYWRkZWRFdmVudEluc3RhbmNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpdmluZ0NvbnRleHQuZGlzcGF0Y2goe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdNRVJHRV9FVkVOVFMnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50U3RvcmU6IG11dGF0ZWRSZWxldmFudEV2ZW50cyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGV2ZW50QWRkQXJnID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50OiBhZGRlZEV2ZW50QXBpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbGF0ZWRFdmVudHM6IGJ1aWxkRXZlbnRBcGlzKG11dGF0ZWRSZWxldmFudEV2ZW50cywgcmVjZWl2aW5nQ29udGV4dCwgYWRkZWRFdmVudEluc3RhbmNlKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXZlcnQoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpdmluZ0NvbnRleHQuZGlzcGF0Y2goe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ1JFTU9WRV9FVkVOVFMnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRTdG9yZTogbXV0YXRlZFJlbGV2YW50RXZlbnRzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpdmluZ0NvbnRleHQuZW1pdHRlci50cmlnZ2VyKCdldmVudEFkZCcsIGV2ZW50QWRkQXJnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChldi5pc1RvdWNoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjZWl2aW5nQ29udGV4dC5kaXNwYXRjaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdTRUxFQ1RfRVZFTlQnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudEluc3RhbmNlSWQ6IGV2ZW50SW5zdGFuY2UuaW5zdGFuY2VJZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpdmluZ0NvbnRleHQuZW1pdHRlci50cmlnZ2VyKCdkcm9wJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBidWlsZERhdGVQb2ludEFwaVdpdGhDb250ZXh0KGZpbmFsSGl0LmRhdGVTcGFuLCByZWNlaXZpbmdDb250ZXh0KSksIHsgZHJhZ2dlZEVsOiBldi5zdWJqZWN0RWwsIGpzRXZlbnQ6IGV2Lm9yaWdFdmVudCwgdmlldzogZmluYWxIaXQuY29udGV4dC52aWV3QXBpIH0pKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpdmluZ0NvbnRleHQuZW1pdHRlci50cmlnZ2VyKCdldmVudFJlY2VpdmUnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGV2ZW50QWRkQXJnKSwgeyBkcmFnZ2VkRWw6IGV2LnN1YmplY3RFbCwgdmlldzogZmluYWxIaXQuY29udGV4dC52aWV3QXBpIH0pKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5pdGlhbENvbnRleHQuZW1pdHRlci50cmlnZ2VyKCdfbm9FdmVudERyb3AnKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNsZWFudXAoKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgbGV0IHsgY29tcG9uZW50IH0gPSB0aGlzO1xyXG4gICAgICAgICAgICBsZXQgeyBvcHRpb25zIH0gPSBjb21wb25lbnQuY29udGV4dDtcclxuICAgICAgICAgICAgbGV0IGRyYWdnaW5nID0gdGhpcy5kcmFnZ2luZyA9IG5ldyBGZWF0dXJlZnVsRWxlbWVudERyYWdnaW5nKHNldHRpbmdzLmVsKTtcclxuICAgICAgICAgICAgZHJhZ2dpbmcucG9pbnRlci5zZWxlY3RvciA9IEV2ZW50RHJhZ2dpbmcuU0VMRUNUT1I7XHJcbiAgICAgICAgICAgIGRyYWdnaW5nLnRvdWNoU2Nyb2xsQWxsb3dlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBkcmFnZ2luZy5hdXRvU2Nyb2xsZXIuaXNFbmFibGVkID0gb3B0aW9ucy5kcmFnU2Nyb2xsO1xyXG4gICAgICAgICAgICBsZXQgaGl0RHJhZ2dpbmcgPSB0aGlzLmhpdERyYWdnaW5nID0gbmV3IEhpdERyYWdnaW5nKHRoaXMuZHJhZ2dpbmcsIGludGVyYWN0aW9uU2V0dGluZ3NTdG9yZSk7XHJcbiAgICAgICAgICAgIGhpdERyYWdnaW5nLnVzZVN1YmplY3RDZW50ZXIgPSBzZXR0aW5ncy51c2VFdmVudENlbnRlcjtcclxuICAgICAgICAgICAgaGl0RHJhZ2dpbmcuZW1pdHRlci5vbigncG9pbnRlcmRvd24nLCB0aGlzLmhhbmRsZVBvaW50ZXJEb3duKTtcclxuICAgICAgICAgICAgaGl0RHJhZ2dpbmcuZW1pdHRlci5vbignZHJhZ3N0YXJ0JywgdGhpcy5oYW5kbGVEcmFnU3RhcnQpO1xyXG4gICAgICAgICAgICBoaXREcmFnZ2luZy5lbWl0dGVyLm9uKCdoaXR1cGRhdGUnLCB0aGlzLmhhbmRsZUhpdFVwZGF0ZSk7XHJcbiAgICAgICAgICAgIGhpdERyYWdnaW5nLmVtaXR0ZXIub24oJ3BvaW50ZXJ1cCcsIHRoaXMuaGFuZGxlUG9pbnRlclVwKTtcclxuICAgICAgICAgICAgaGl0RHJhZ2dpbmcuZW1pdHRlci5vbignZHJhZ2VuZCcsIHRoaXMuaGFuZGxlRHJhZ0VuZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRlc3Ryb3koKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmcuZGVzdHJveSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyByZW5kZXIgYSBkcmFnIHN0YXRlIG9uIHRoZSBuZXh0IHJlY2VpdmluZ0NhbGVuZGFyXHJcbiAgICAgICAgZGlzcGxheURyYWcobmV4dENvbnRleHQsIHN0YXRlKSB7XHJcbiAgICAgICAgICAgIGxldCBpbml0aWFsQ29udGV4dCA9IHRoaXMuY29tcG9uZW50LmNvbnRleHQ7XHJcbiAgICAgICAgICAgIGxldCBwcmV2Q29udGV4dCA9IHRoaXMucmVjZWl2aW5nQ29udGV4dDtcclxuICAgICAgICAgICAgLy8gZG9lcyB0aGUgcHJldmlvdXMgY2FsZW5kYXIgbmVlZCB0byBiZSBjbGVhcmVkP1xyXG4gICAgICAgICAgICBpZiAocHJldkNvbnRleHQgJiYgcHJldkNvbnRleHQgIT09IG5leHRDb250ZXh0KSB7XHJcbiAgICAgICAgICAgICAgICAvLyBkb2VzIHRoZSBpbml0aWFsIGNhbGVuZGFyIG5lZWQgdG8gYmUgY2xlYXJlZD9cclxuICAgICAgICAgICAgICAgIC8vIGlmIHNvLCBkb24ndCBjbGVhciBhbGwgdGhlIHdheS4gd2Ugc3RpbGwgbmVlZCB0byB0byBoaWRlIHRoZSBhZmZlY3RlZEV2ZW50c1xyXG4gICAgICAgICAgICAgICAgaWYgKHByZXZDb250ZXh0ID09PSBpbml0aWFsQ29udGV4dCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHByZXZDb250ZXh0LmRpc3BhdGNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ1NFVF9FVkVOVF9EUkFHJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGU6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFmZmVjdGVkRXZlbnRzOiBzdGF0ZS5hZmZlY3RlZEV2ZW50cyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG11dGF0ZWRFdmVudHM6IGNyZWF0ZUVtcHR5RXZlbnRTdG9yZSgpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNFdmVudDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBjb21wbGV0ZWx5IGNsZWFyIHRoZSBvbGQgY2FsZW5kYXIgaWYgaXQgd2Fzbid0IHRoZSBpbml0aWFsXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBwcmV2Q29udGV4dC5kaXNwYXRjaCh7IHR5cGU6ICdVTlNFVF9FVkVOVF9EUkFHJyB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobmV4dENvbnRleHQpIHtcclxuICAgICAgICAgICAgICAgIG5leHRDb250ZXh0LmRpc3BhdGNoKHsgdHlwZTogJ1NFVF9FVkVOVF9EUkFHJywgc3RhdGUgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY2xlYXJEcmFnKCkge1xyXG4gICAgICAgICAgICBsZXQgaW5pdGlhbENhbGVuZGFyID0gdGhpcy5jb21wb25lbnQuY29udGV4dDtcclxuICAgICAgICAgICAgbGV0IHsgcmVjZWl2aW5nQ29udGV4dCB9ID0gdGhpcztcclxuICAgICAgICAgICAgaWYgKHJlY2VpdmluZ0NvbnRleHQpIHtcclxuICAgICAgICAgICAgICAgIHJlY2VpdmluZ0NvbnRleHQuZGlzcGF0Y2goeyB0eXBlOiAnVU5TRVRfRVZFTlRfRFJBRycgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gdGhlIGluaXRpYWwgY2FsZW5kYXIgbWlnaHQgaGF2ZSBhbiBkdW1teSBkcmFnIHN0YXRlIGZyb20gZGlzcGxheURyYWdcclxuICAgICAgICAgICAgaWYgKGluaXRpYWxDYWxlbmRhciAhPT0gcmVjZWl2aW5nQ29udGV4dCkge1xyXG4gICAgICAgICAgICAgICAgaW5pdGlhbENhbGVuZGFyLmRpc3BhdGNoKHsgdHlwZTogJ1VOU0VUX0VWRU5UX0RSQUcnIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNsZWFudXAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3ViamVjdFNlZyA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMuaXNEcmFnZ2luZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLmV2ZW50UmFuZ2UgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLnJlbGV2YW50RXZlbnRzID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5yZWNlaXZpbmdDb250ZXh0ID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy52YWxpZE11dGF0aW9uID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5tdXRhdGVkUmVsZXZhbnRFdmVudHMgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIFRPRE86IHRlc3QgdGhpcyBpbiBJRTExXHJcbiAgICAvLyBRVUVTVElPTjogd2h5IGRvIHdlIG5lZWQgaXQgb24gdGhlIHJlc2l6YWJsZT8/P1xyXG4gICAgRXZlbnREcmFnZ2luZy5TRUxFQ1RPUiA9ICcuZmMtZXZlbnQtZHJhZ2dhYmxlLCAuZmMtZXZlbnQtcmVzaXphYmxlJztcclxuICAgIGZ1bmN0aW9uIGNvbXB1dGVFdmVudE11dGF0aW9uKGhpdDAsIGhpdDEsIG1hc3NhZ2Vycykge1xyXG4gICAgICAgIGxldCBkYXRlU3BhbjAgPSBoaXQwLmRhdGVTcGFuO1xyXG4gICAgICAgIGxldCBkYXRlU3BhbjEgPSBoaXQxLmRhdGVTcGFuO1xyXG4gICAgICAgIGxldCBkYXRlMCA9IGRhdGVTcGFuMC5yYW5nZS5zdGFydDtcclxuICAgICAgICBsZXQgZGF0ZTEgPSBkYXRlU3BhbjEucmFuZ2Uuc3RhcnQ7XHJcbiAgICAgICAgbGV0IHN0YW5kYXJkUHJvcHMgPSB7fTtcclxuICAgICAgICBpZiAoZGF0ZVNwYW4wLmFsbERheSAhPT0gZGF0ZVNwYW4xLmFsbERheSkge1xyXG4gICAgICAgICAgICBzdGFuZGFyZFByb3BzLmFsbERheSA9IGRhdGVTcGFuMS5hbGxEYXk7XHJcbiAgICAgICAgICAgIHN0YW5kYXJkUHJvcHMuaGFzRW5kID0gaGl0MS5jb250ZXh0Lm9wdGlvbnMuYWxsRGF5TWFpbnRhaW5EdXJhdGlvbjtcclxuICAgICAgICAgICAgaWYgKGRhdGVTcGFuMS5hbGxEYXkpIHtcclxuICAgICAgICAgICAgICAgIC8vIG1lYW5zIGRhdGUxIGlzIGFscmVhZHkgc3RhcnQtb2YtZGF5LFxyXG4gICAgICAgICAgICAgICAgLy8gYnV0IGRhdGUwIG5lZWRzIHRvIGJlIGNvbnZlcnRlZFxyXG4gICAgICAgICAgICAgICAgZGF0ZTAgPSBzdGFydE9mRGF5KGRhdGUwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgZGVsdGEgPSBkaWZmRGF0ZXMoZGF0ZTAsIGRhdGUxLCBoaXQwLmNvbnRleHQuZGF0ZUVudiwgaGl0MC5jb21wb25lbnRJZCA9PT0gaGl0MS5jb21wb25lbnRJZCA/XHJcbiAgICAgICAgICAgIGhpdDAubGFyZ2VVbml0IDpcclxuICAgICAgICAgICAgbnVsbCk7XHJcbiAgICAgICAgaWYgKGRlbHRhLm1pbGxpc2Vjb25kcykgeyAvLyBoYXMgaG91cnMvbWludXRlcy9zZWNvbmRzXHJcbiAgICAgICAgICAgIHN0YW5kYXJkUHJvcHMuYWxsRGF5ID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBtdXRhdGlvbiA9IHtcclxuICAgICAgICAgICAgZGF0ZXNEZWx0YTogZGVsdGEsXHJcbiAgICAgICAgICAgIHN0YW5kYXJkUHJvcHMsXHJcbiAgICAgICAgfTtcclxuICAgICAgICBmb3IgKGxldCBtYXNzYWdlciBvZiBtYXNzYWdlcnMpIHtcclxuICAgICAgICAgICAgbWFzc2FnZXIobXV0YXRpb24sIGhpdDAsIGhpdDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbXV0YXRpb247XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBnZXRDb21wb25lbnRUb3VjaERlbGF5KGNvbXBvbmVudCkge1xyXG4gICAgICAgIGxldCB7IG9wdGlvbnMgfSA9IGNvbXBvbmVudC5jb250ZXh0O1xyXG4gICAgICAgIGxldCBkZWxheSA9IG9wdGlvbnMuZXZlbnRMb25nUHJlc3NEZWxheTtcclxuICAgICAgICBpZiAoZGVsYXkgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBkZWxheSA9IG9wdGlvbnMubG9uZ1ByZXNzRGVsYXk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkZWxheTtcclxuICAgIH1cclxuXHJcbiAgICBjbGFzcyBFdmVudFJlc2l6aW5nIGV4dGVuZHMgSW50ZXJhY3Rpb24ge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yKHNldHRpbmdzKSB7XHJcbiAgICAgICAgICAgIHN1cGVyKHNldHRpbmdzKTtcclxuICAgICAgICAgICAgLy8gaW50ZXJuYWwgc3RhdGVcclxuICAgICAgICAgICAgdGhpcy5kcmFnZ2luZ1NlZ0VsID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5kcmFnZ2luZ1NlZyA9IG51bGw7IC8vIFRPRE86IHJlbmFtZSB0byByZXNpemluZ1NlZz8gc3ViamVjdFNlZz9cclxuICAgICAgICAgICAgdGhpcy5ldmVudFJhbmdlID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5yZWxldmFudEV2ZW50cyA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMudmFsaWRNdXRhdGlvbiA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMubXV0YXRlZFJlbGV2YW50RXZlbnRzID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5oYW5kbGVQb2ludGVyRG93biA9IChldikgPT4ge1xyXG4gICAgICAgICAgICAgICAgbGV0IHsgY29tcG9uZW50IH0gPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgbGV0IHNlZ0VsID0gdGhpcy5xdWVyeVNlZ0VsKGV2KTtcclxuICAgICAgICAgICAgICAgIGxldCBzZWcgPSBnZXRFbFNlZyhzZWdFbCk7XHJcbiAgICAgICAgICAgICAgICBsZXQgZXZlbnRSYW5nZSA9IHRoaXMuZXZlbnRSYW5nZSA9IHNlZy5ldmVudFJhbmdlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kcmFnZ2luZy5taW5EaXN0YW5jZSA9IGNvbXBvbmVudC5jb250ZXh0Lm9wdGlvbnMuZXZlbnREcmFnTWluRGlzdGFuY2U7XHJcbiAgICAgICAgICAgICAgICAvLyBpZiB0b3VjaCwgbmVlZCB0byBiZSB3b3JraW5nIHdpdGggYSBzZWxlY3RlZCBldmVudFxyXG4gICAgICAgICAgICAgICAgdGhpcy5kcmFnZ2luZy5zZXRJZ25vcmVNb3ZlKCF0aGlzLmNvbXBvbmVudC5pc1ZhbGlkU2VnRG93bkVsKGV2Lm9yaWdFdmVudC50YXJnZXQpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgKGV2LmlzVG91Y2ggJiYgdGhpcy5jb21wb25lbnQucHJvcHMuZXZlbnRTZWxlY3Rpb24gIT09IGV2ZW50UmFuZ2UuaW5zdGFuY2UuaW5zdGFuY2VJZCkpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB0aGlzLmhhbmRsZURyYWdTdGFydCA9IChldikgPT4ge1xyXG4gICAgICAgICAgICAgICAgbGV0IHsgY29udGV4dCB9ID0gdGhpcy5jb21wb25lbnQ7XHJcbiAgICAgICAgICAgICAgICBsZXQgZXZlbnRSYW5nZSA9IHRoaXMuZXZlbnRSYW5nZTtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVsZXZhbnRFdmVudHMgPSBnZXRSZWxldmFudEV2ZW50cyhjb250ZXh0LmdldEN1cnJlbnREYXRhKCkuZXZlbnRTdG9yZSwgdGhpcy5ldmVudFJhbmdlLmluc3RhbmNlLmluc3RhbmNlSWQpO1xyXG4gICAgICAgICAgICAgICAgbGV0IHNlZ0VsID0gdGhpcy5xdWVyeVNlZ0VsKGV2KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmdTZWdFbCA9IHNlZ0VsO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kcmFnZ2luZ1NlZyA9IGdldEVsU2VnKHNlZ0VsKTtcclxuICAgICAgICAgICAgICAgIGNvbnRleHQuY2FsZW5kYXJBcGkudW5zZWxlY3QoKTtcclxuICAgICAgICAgICAgICAgIGNvbnRleHQuZW1pdHRlci50cmlnZ2VyKCdldmVudFJlc2l6ZVN0YXJ0Jywge1xyXG4gICAgICAgICAgICAgICAgICAgIGVsOiBzZWdFbCxcclxuICAgICAgICAgICAgICAgICAgICBldmVudDogbmV3IEV2ZW50SW1wbChjb250ZXh0LCBldmVudFJhbmdlLmRlZiwgZXZlbnRSYW5nZS5pbnN0YW5jZSksXHJcbiAgICAgICAgICAgICAgICAgICAganNFdmVudDogZXYub3JpZ0V2ZW50LFxyXG4gICAgICAgICAgICAgICAgICAgIHZpZXc6IGNvbnRleHQudmlld0FwaSxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB0aGlzLmhhbmRsZUhpdFVwZGF0ZSA9IChoaXQsIGlzRmluYWwsIGV2KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBsZXQgeyBjb250ZXh0IH0gPSB0aGlzLmNvbXBvbmVudDtcclxuICAgICAgICAgICAgICAgIGxldCByZWxldmFudEV2ZW50cyA9IHRoaXMucmVsZXZhbnRFdmVudHM7XHJcbiAgICAgICAgICAgICAgICBsZXQgaW5pdGlhbEhpdCA9IHRoaXMuaGl0RHJhZ2dpbmcuaW5pdGlhbEhpdDtcclxuICAgICAgICAgICAgICAgIGxldCBldmVudEluc3RhbmNlID0gdGhpcy5ldmVudFJhbmdlLmluc3RhbmNlO1xyXG4gICAgICAgICAgICAgICAgbGV0IG11dGF0aW9uID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIGxldCBtdXRhdGVkUmVsZXZhbnRFdmVudHMgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgbGV0IGlzSW52YWxpZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgbGV0IGludGVyYWN0aW9uID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIGFmZmVjdGVkRXZlbnRzOiByZWxldmFudEV2ZW50cyxcclxuICAgICAgICAgICAgICAgICAgICBtdXRhdGVkRXZlbnRzOiBjcmVhdGVFbXB0eUV2ZW50U3RvcmUoKSxcclxuICAgICAgICAgICAgICAgICAgICBpc0V2ZW50OiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIGlmIChoaXQpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgZGlzYWxsb3dlZCA9IGhpdC5jb21wb25lbnRJZCA9PT0gaW5pdGlhbEhpdC5jb21wb25lbnRJZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAmJiB0aGlzLmlzSGl0Q29tYm9BbGxvd2VkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICYmICF0aGlzLmlzSGl0Q29tYm9BbGxvd2VkKGluaXRpYWxIaXQsIGhpdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkaXNhbGxvd2VkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG11dGF0aW9uID0gY29tcHV0ZU11dGF0aW9uKGluaXRpYWxIaXQsIGhpdCwgZXYuc3ViamVjdEVsLmNsYXNzTGlzdC5jb250YWlucygnZmMtZXZlbnQtcmVzaXplci1zdGFydCcpLCBldmVudEluc3RhbmNlLnJhbmdlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAobXV0YXRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICBtdXRhdGVkUmVsZXZhbnRFdmVudHMgPSBhcHBseU11dGF0aW9uVG9FdmVudFN0b3JlKHJlbGV2YW50RXZlbnRzLCBjb250ZXh0LmdldEN1cnJlbnREYXRhKCkuZXZlbnRVaUJhc2VzLCBtdXRhdGlvbiwgY29udGV4dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJhY3Rpb24ubXV0YXRlZEV2ZW50cyA9IG11dGF0ZWRSZWxldmFudEV2ZW50cztcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzSW50ZXJhY3Rpb25WYWxpZChpbnRlcmFjdGlvbiwgaGl0LmRhdGVQcm9maWxlLCBjb250ZXh0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0ludmFsaWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtdXRhdGlvbiA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG11dGF0ZWRSZWxldmFudEV2ZW50cyA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVyYWN0aW9uLm11dGF0ZWRFdmVudHMgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChtdXRhdGVkUmVsZXZhbnRFdmVudHMpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmRpc3BhdGNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ1NFVF9FVkVOVF9SRVNJWkUnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZTogaW50ZXJhY3Rpb24sXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmRpc3BhdGNoKHsgdHlwZTogJ1VOU0VUX0VWRU5UX1JFU0laRScgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzSW52YWxpZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGVuYWJsZUN1cnNvcigpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlzYWJsZUN1cnNvcigpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCFpc0ZpbmFsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG11dGF0aW9uICYmIGlzSGl0c0VxdWFsKGluaXRpYWxIaXQsIGhpdCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbXV0YXRpb24gPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbGlkTXV0YXRpb24gPSBtdXRhdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm11dGF0ZWRSZWxldmFudEV2ZW50cyA9IG11dGF0ZWRSZWxldmFudEV2ZW50cztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdGhpcy5oYW5kbGVEcmFnRW5kID0gKGV2KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBsZXQgeyBjb250ZXh0IH0gPSB0aGlzLmNvbXBvbmVudDtcclxuICAgICAgICAgICAgICAgIGxldCBldmVudERlZiA9IHRoaXMuZXZlbnRSYW5nZS5kZWY7XHJcbiAgICAgICAgICAgICAgICBsZXQgZXZlbnRJbnN0YW5jZSA9IHRoaXMuZXZlbnRSYW5nZS5pbnN0YW5jZTtcclxuICAgICAgICAgICAgICAgIGxldCBldmVudEFwaSA9IG5ldyBFdmVudEltcGwoY29udGV4dCwgZXZlbnREZWYsIGV2ZW50SW5zdGFuY2UpO1xyXG4gICAgICAgICAgICAgICAgbGV0IHJlbGV2YW50RXZlbnRzID0gdGhpcy5yZWxldmFudEV2ZW50cztcclxuICAgICAgICAgICAgICAgIGxldCBtdXRhdGVkUmVsZXZhbnRFdmVudHMgPSB0aGlzLm11dGF0ZWRSZWxldmFudEV2ZW50cztcclxuICAgICAgICAgICAgICAgIGNvbnRleHQuZW1pdHRlci50cmlnZ2VyKCdldmVudFJlc2l6ZVN0b3AnLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgZWw6IHRoaXMuZHJhZ2dpbmdTZWdFbCxcclxuICAgICAgICAgICAgICAgICAgICBldmVudDogZXZlbnRBcGksXHJcbiAgICAgICAgICAgICAgICAgICAganNFdmVudDogZXYub3JpZ0V2ZW50LFxyXG4gICAgICAgICAgICAgICAgICAgIHZpZXc6IGNvbnRleHQudmlld0FwaSxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudmFsaWRNdXRhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCB1cGRhdGVkRXZlbnRBcGkgPSBuZXcgRXZlbnRJbXBsKGNvbnRleHQsIG11dGF0ZWRSZWxldmFudEV2ZW50cy5kZWZzW2V2ZW50RGVmLmRlZklkXSwgZXZlbnRJbnN0YW5jZSA/IG11dGF0ZWRSZWxldmFudEV2ZW50cy5pbnN0YW5jZXNbZXZlbnRJbnN0YW5jZS5pbnN0YW5jZUlkXSA6IG51bGwpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuZGlzcGF0Y2goe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnTUVSR0VfRVZFTlRTJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRTdG9yZTogbXV0YXRlZFJlbGV2YW50RXZlbnRzLFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBldmVudENoYW5nZUFyZyA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb2xkRXZlbnQ6IGV2ZW50QXBpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudDogdXBkYXRlZEV2ZW50QXBpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZWxhdGVkRXZlbnRzOiBidWlsZEV2ZW50QXBpcyhtdXRhdGVkUmVsZXZhbnRFdmVudHMsIGNvbnRleHQsIGV2ZW50SW5zdGFuY2UpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXZlcnQoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmRpc3BhdGNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnTUVSR0VfRVZFTlRTJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudFN0b3JlOiByZWxldmFudEV2ZW50cywgLy8gdGhlIHByZS1jaGFuZ2UgZXZlbnRzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuZW1pdHRlci50cmlnZ2VyKCdldmVudFJlc2l6ZScsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZXZlbnRDaGFuZ2VBcmcpLCB7IGVsOiB0aGlzLmRyYWdnaW5nU2VnRWwsIHN0YXJ0RGVsdGE6IHRoaXMudmFsaWRNdXRhdGlvbi5zdGFydERlbHRhIHx8IGNyZWF0ZUR1cmF0aW9uKDApLCBlbmREZWx0YTogdGhpcy52YWxpZE11dGF0aW9uLmVuZERlbHRhIHx8IGNyZWF0ZUR1cmF0aW9uKDApLCBqc0V2ZW50OiBldi5vcmlnRXZlbnQsIHZpZXc6IGNvbnRleHQudmlld0FwaSB9KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5lbWl0dGVyLnRyaWdnZXIoJ2V2ZW50Q2hhbmdlJywgZXZlbnRDaGFuZ2VBcmcpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5lbWl0dGVyLnRyaWdnZXIoJ19ub0V2ZW50UmVzaXplJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyByZXNldCBhbGwgaW50ZXJuYWwgc3RhdGVcclxuICAgICAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmdTZWcgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZWxldmFudEV2ZW50cyA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnZhbGlkTXV0YXRpb24gPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgLy8gb2theSB0byBrZWVwIGV2ZW50SW5zdGFuY2UgYXJvdW5kLiB1c2VmdWwgdG8gc2V0IGl0IGluIGhhbmRsZVBvaW50ZXJEb3duXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGxldCB7IGNvbXBvbmVudCB9ID0gc2V0dGluZ3M7XHJcbiAgICAgICAgICAgIGxldCBkcmFnZ2luZyA9IHRoaXMuZHJhZ2dpbmcgPSBuZXcgRmVhdHVyZWZ1bEVsZW1lbnREcmFnZ2luZyhzZXR0aW5ncy5lbCk7XHJcbiAgICAgICAgICAgIGRyYWdnaW5nLnBvaW50ZXIuc2VsZWN0b3IgPSAnLmZjLWV2ZW50LXJlc2l6ZXInO1xyXG4gICAgICAgICAgICBkcmFnZ2luZy50b3VjaFNjcm9sbEFsbG93ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgZHJhZ2dpbmcuYXV0b1Njcm9sbGVyLmlzRW5hYmxlZCA9IGNvbXBvbmVudC5jb250ZXh0Lm9wdGlvbnMuZHJhZ1Njcm9sbDtcclxuICAgICAgICAgICAgbGV0IGhpdERyYWdnaW5nID0gdGhpcy5oaXREcmFnZ2luZyA9IG5ldyBIaXREcmFnZ2luZyh0aGlzLmRyYWdnaW5nLCBpbnRlcmFjdGlvblNldHRpbmdzVG9TdG9yZShzZXR0aW5ncykpO1xyXG4gICAgICAgICAgICBoaXREcmFnZ2luZy5lbWl0dGVyLm9uKCdwb2ludGVyZG93bicsIHRoaXMuaGFuZGxlUG9pbnRlckRvd24pO1xyXG4gICAgICAgICAgICBoaXREcmFnZ2luZy5lbWl0dGVyLm9uKCdkcmFnc3RhcnQnLCB0aGlzLmhhbmRsZURyYWdTdGFydCk7XHJcbiAgICAgICAgICAgIGhpdERyYWdnaW5nLmVtaXR0ZXIub24oJ2hpdHVwZGF0ZScsIHRoaXMuaGFuZGxlSGl0VXBkYXRlKTtcclxuICAgICAgICAgICAgaGl0RHJhZ2dpbmcuZW1pdHRlci5vbignZHJhZ2VuZCcsIHRoaXMuaGFuZGxlRHJhZ0VuZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRlc3Ryb3koKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmcuZGVzdHJveSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBxdWVyeVNlZ0VsKGV2KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50Q2xvc2VzdChldi5zdWJqZWN0RWwsICcuZmMtZXZlbnQnKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBjb21wdXRlTXV0YXRpb24oaGl0MCwgaGl0MSwgaXNGcm9tU3RhcnQsIGluc3RhbmNlUmFuZ2UpIHtcclxuICAgICAgICBsZXQgZGF0ZUVudiA9IGhpdDAuY29udGV4dC5kYXRlRW52O1xyXG4gICAgICAgIGxldCBkYXRlMCA9IGhpdDAuZGF0ZVNwYW4ucmFuZ2Uuc3RhcnQ7XHJcbiAgICAgICAgbGV0IGRhdGUxID0gaGl0MS5kYXRlU3Bhbi5yYW5nZS5zdGFydDtcclxuICAgICAgICBsZXQgZGVsdGEgPSBkaWZmRGF0ZXMoZGF0ZTAsIGRhdGUxLCBkYXRlRW52LCBoaXQwLmxhcmdlVW5pdCk7XHJcbiAgICAgICAgaWYgKGlzRnJvbVN0YXJ0KSB7XHJcbiAgICAgICAgICAgIGlmIChkYXRlRW52LmFkZChpbnN0YW5jZVJhbmdlLnN0YXJ0LCBkZWx0YSkgPCBpbnN0YW5jZVJhbmdlLmVuZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgc3RhcnREZWx0YTogZGVsdGEgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChkYXRlRW52LmFkZChpbnN0YW5jZVJhbmdlLmVuZCwgZGVsdGEpID4gaW5zdGFuY2VSYW5nZS5zdGFydCkge1xyXG4gICAgICAgICAgICByZXR1cm4geyBlbmREZWx0YTogZGVsdGEgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgY2xhc3MgVW5zZWxlY3RBdXRvIHtcclxuICAgICAgICBjb25zdHJ1Y3Rvcihjb250ZXh0KSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XHJcbiAgICAgICAgICAgIHRoaXMuaXNSZWNlbnRQb2ludGVyRGF0ZVNlbGVjdCA9IGZhbHNlOyAvLyB3aXNoIHdlIGNvdWxkIHVzZSBhIHNlbGVjdG9yIHRvIGRldGVjdCBkYXRlIHNlbGVjdGlvbiwgYnV0IHVzZXMgaGl0IHN5c3RlbVxyXG4gICAgICAgICAgICB0aGlzLm1hdGNoZXNDYW5jZWwgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5tYXRjaGVzRXZlbnQgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5vblNlbGVjdCA9IChzZWxlY3RJbmZvKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2VsZWN0SW5mby5qc0V2ZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pc1JlY2VudFBvaW50ZXJEYXRlU2VsZWN0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdGhpcy5vbkRvY3VtZW50UG9pbnRlckRvd24gPSAocGV2KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBsZXQgdW5zZWxlY3RDYW5jZWwgPSB0aGlzLmNvbnRleHQub3B0aW9ucy51bnNlbGVjdENhbmNlbDtcclxuICAgICAgICAgICAgICAgIGxldCBkb3duRWwgPSBnZXRFdmVudFRhcmdldFZpYVJvb3QocGV2Lm9yaWdFdmVudCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1hdGNoZXNDYW5jZWwgPSAhIWVsZW1lbnRDbG9zZXN0KGRvd25FbCwgdW5zZWxlY3RDYW5jZWwpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tYXRjaGVzRXZlbnQgPSAhIWVsZW1lbnRDbG9zZXN0KGRvd25FbCwgRXZlbnREcmFnZ2luZy5TRUxFQ1RPUik7IC8vIGludGVyYWN0aW9uIHN0YXJ0ZWQgb24gYW4gZXZlbnQ/XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHRoaXMub25Eb2N1bWVudFBvaW50ZXJVcCA9IChwZXYpID0+IHtcclxuICAgICAgICAgICAgICAgIGxldCB7IGNvbnRleHQgfSA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICBsZXQgeyBkb2N1bWVudFBvaW50ZXIgfSA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICBsZXQgY2FsZW5kYXJTdGF0ZSA9IGNvbnRleHQuZ2V0Q3VycmVudERhdGEoKTtcclxuICAgICAgICAgICAgICAgIC8vIHRvdWNoLXNjcm9sbGluZyBzaG91bGQgbmV2ZXIgdW5mb2N1cyBhbnkgdHlwZSBvZiBzZWxlY3Rpb25cclxuICAgICAgICAgICAgICAgIGlmICghZG9jdW1lbnRQb2ludGVyLndhc1RvdWNoU2Nyb2xsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhbGVuZGFyU3RhdGUuZGF0ZVNlbGVjdGlvbiAmJiAvLyBhbiBleGlzdGluZyBkYXRlIHNlbGVjdGlvbj9cclxuICAgICAgICAgICAgICAgICAgICAgICAgIXRoaXMuaXNSZWNlbnRQb2ludGVyRGF0ZVNlbGVjdCAvLyBhIG5ldyBwb2ludGVyLWluaXRpYXRlZCBkYXRlIHNlbGVjdGlvbiBzaW5jZSBsYXN0IG9uRG9jdW1lbnRQb2ludGVyVXA/XHJcbiAgICAgICAgICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB1bnNlbGVjdEF1dG8gPSBjb250ZXh0Lm9wdGlvbnMudW5zZWxlY3RBdXRvO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodW5zZWxlY3RBdXRvICYmICghdW5zZWxlY3RBdXRvIHx8ICF0aGlzLm1hdGNoZXNDYW5jZWwpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmNhbGVuZGFyQXBpLnVuc2VsZWN0KHBldik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhbGVuZGFyU3RhdGUuZXZlbnRTZWxlY3Rpb24gJiYgLy8gYW4gZXhpc3RpbmcgZXZlbnQgc2VsZWN0ZWQ/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICF0aGlzLm1hdGNoZXNFdmVudCAvLyBpbnRlcmFjdGlvbiBESUROJ1Qgc3RhcnQgb24gYW4gZXZlbnRcclxuICAgICAgICAgICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5kaXNwYXRjaCh7IHR5cGU6ICdVTlNFTEVDVF9FVkVOVCcgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5pc1JlY2VudFBvaW50ZXJEYXRlU2VsZWN0ID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGxldCBkb2N1bWVudFBvaW50ZXIgPSB0aGlzLmRvY3VtZW50UG9pbnRlciA9IG5ldyBQb2ludGVyRHJhZ2dpbmcoZG9jdW1lbnQpO1xyXG4gICAgICAgICAgICBkb2N1bWVudFBvaW50ZXIuc2hvdWxkSWdub3JlTW92ZSA9IHRydWU7XHJcbiAgICAgICAgICAgIGRvY3VtZW50UG9pbnRlci5zaG91bGRXYXRjaFNjcm9sbCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBkb2N1bWVudFBvaW50ZXIuZW1pdHRlci5vbigncG9pbnRlcmRvd24nLCB0aGlzLm9uRG9jdW1lbnRQb2ludGVyRG93bik7XHJcbiAgICAgICAgICAgIGRvY3VtZW50UG9pbnRlci5lbWl0dGVyLm9uKCdwb2ludGVydXAnLCB0aGlzLm9uRG9jdW1lbnRQb2ludGVyVXApO1xyXG4gICAgICAgICAgICAvKlxyXG4gICAgICAgICAgICBUT0RPOiBiZXR0ZXIgd2F5IHRvIGtub3cgYWJvdXQgd2hldGhlciB0aGVyZSB3YXMgYSBzZWxlY3Rpb24gd2l0aCB0aGUgcG9pbnRlclxyXG4gICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBjb250ZXh0LmVtaXR0ZXIub24oJ3NlbGVjdCcsIHRoaXMub25TZWxlY3QpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkZXN0cm95KCkge1xyXG4gICAgICAgICAgICB0aGlzLmNvbnRleHQuZW1pdHRlci5vZmYoJ3NlbGVjdCcsIHRoaXMub25TZWxlY3QpO1xyXG4gICAgICAgICAgICB0aGlzLmRvY3VtZW50UG9pbnRlci5kZXN0cm95KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IE9QVElPTl9SRUZJTkVSUyQzID0ge1xyXG4gICAgICAgIGZpeGVkTWlycm9yUGFyZW50OiBpZGVudGl0eSxcclxuICAgIH07XHJcbiAgICBjb25zdCBMSVNURU5FUl9SRUZJTkVSUyA9IHtcclxuICAgICAgICBkYXRlQ2xpY2s6IGlkZW50aXR5LFxyXG4gICAgICAgIGV2ZW50RHJhZ1N0YXJ0OiBpZGVudGl0eSxcclxuICAgICAgICBldmVudERyYWdTdG9wOiBpZGVudGl0eSxcclxuICAgICAgICBldmVudERyb3A6IGlkZW50aXR5LFxyXG4gICAgICAgIGV2ZW50UmVzaXplU3RhcnQ6IGlkZW50aXR5LFxyXG4gICAgICAgIGV2ZW50UmVzaXplU3RvcDogaWRlbnRpdHksXHJcbiAgICAgICAgZXZlbnRSZXNpemU6IGlkZW50aXR5LFxyXG4gICAgICAgIGRyb3A6IGlkZW50aXR5LFxyXG4gICAgICAgIGV2ZW50UmVjZWl2ZTogaWRlbnRpdHksXHJcbiAgICAgICAgZXZlbnRMZWF2ZTogaWRlbnRpdHksXHJcbiAgICB9O1xyXG5cclxuICAgIC8qXHJcbiAgICBHaXZlbiBhbiBhbHJlYWR5IGluc3RhbnRpYXRlZCBkcmFnZ2FibGUgb2JqZWN0IGZvciBvbmUtb3ItbW9yZSBlbGVtZW50cyxcclxuICAgIEludGVycHJldHMgYW55IGRyYWdnaW5nIGFzIGFuIGF0dGVtcHQgdG8gZHJhZyBhbiBldmVudHMgdGhhdCBsaXZlcyBvdXRzaWRlXHJcbiAgICBvZiBhIGNhbGVuZGFyIG9udG8gYSBjYWxlbmRhci5cclxuICAgICovXHJcbiAgICBjbGFzcyBFeHRlcm5hbEVsZW1lbnREcmFnZ2luZyB7XHJcbiAgICAgICAgY29uc3RydWN0b3IoZHJhZ2dpbmcsIHN1cHBsaWVkRHJhZ01ldGEpIHtcclxuICAgICAgICAgICAgdGhpcy5yZWNlaXZpbmdDb250ZXh0ID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5kcm9wcGFibGVFdmVudCA9IG51bGw7IC8vIHdpbGwgZXhpc3QgZm9yIGFsbCBkcmFncywgZXZlbiBpZiBjcmVhdGU6ZmFsc2VcclxuICAgICAgICAgICAgdGhpcy5zdXBwbGllZERyYWdNZXRhID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5kcmFnTWV0YSA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlRHJhZ1N0YXJ0ID0gKGV2KSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRyYWdNZXRhID0gdGhpcy5idWlsZERyYWdNZXRhKGV2LnN1YmplY3RFbCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlSGl0VXBkYXRlID0gKGhpdCwgaXNGaW5hbCwgZXYpID0+IHtcclxuICAgICAgICAgICAgICAgIGxldCB7IGRyYWdnaW5nIH0gPSB0aGlzLmhpdERyYWdnaW5nO1xyXG4gICAgICAgICAgICAgICAgbGV0IHJlY2VpdmluZ0NvbnRleHQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgbGV0IGRyb3BwYWJsZUV2ZW50ID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIGxldCBpc0ludmFsaWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGxldCBpbnRlcmFjdGlvbiA9IHtcclxuICAgICAgICAgICAgICAgICAgICBhZmZlY3RlZEV2ZW50czogY3JlYXRlRW1wdHlFdmVudFN0b3JlKCksXHJcbiAgICAgICAgICAgICAgICAgICAgbXV0YXRlZEV2ZW50czogY3JlYXRlRW1wdHlFdmVudFN0b3JlKCksXHJcbiAgICAgICAgICAgICAgICAgICAgaXNFdmVudDogdGhpcy5kcmFnTWV0YS5jcmVhdGUsXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgaWYgKGhpdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlY2VpdmluZ0NvbnRleHQgPSBoaXQuY29udGV4dDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jYW5Ecm9wRWxPbkNhbGVuZGFyKGV2LnN1YmplY3RFbCwgcmVjZWl2aW5nQ29udGV4dCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZHJvcHBhYmxlRXZlbnQgPSBjb21wdXRlRXZlbnRGb3JEYXRlU3BhbihoaXQuZGF0ZVNwYW4sIHRoaXMuZHJhZ01ldGEsIHJlY2VpdmluZ0NvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcmFjdGlvbi5tdXRhdGVkRXZlbnRzID0gZXZlbnRUdXBsZVRvU3RvcmUoZHJvcHBhYmxlRXZlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0ludmFsaWQgPSAhaXNJbnRlcmFjdGlvblZhbGlkKGludGVyYWN0aW9uLCBoaXQuZGF0ZVByb2ZpbGUsIHJlY2VpdmluZ0NvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNJbnZhbGlkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRlcmFjdGlvbi5tdXRhdGVkRXZlbnRzID0gY3JlYXRlRW1wdHlFdmVudFN0b3JlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkcm9wcGFibGVFdmVudCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BsYXlEcmFnKHJlY2VpdmluZ0NvbnRleHQsIGludGVyYWN0aW9uKTtcclxuICAgICAgICAgICAgICAgIC8vIHNob3cgbWlycm9yIGlmIG5vIGFscmVhZHktcmVuZGVyZWQgbWlycm9yIGVsZW1lbnQgT1IgaWYgd2UgYXJlIHNodXR0aW5nIGRvd24gdGhlIG1pcnJvciAoPylcclxuICAgICAgICAgICAgICAgIC8vIFRPRE86IHdpc2ggd2UgY291bGQgc29tZWhvdyB3YWl0IGZvciBkaXNwYXRjaCB0byBndWFyYW50ZWUgcmVuZGVyXHJcbiAgICAgICAgICAgICAgICBkcmFnZ2luZy5zZXRNaXJyb3JJc1Zpc2libGUoaXNGaW5hbCB8fCAhZHJvcHBhYmxlRXZlbnQgfHwgIWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5mYy1ldmVudC1taXJyb3InKSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzSW52YWxpZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGVuYWJsZUN1cnNvcigpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlzYWJsZUN1cnNvcigpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCFpc0ZpbmFsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZHJhZ2dpbmcuc2V0TWlycm9yTmVlZHNSZXZlcnQoIWRyb3BwYWJsZUV2ZW50KTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlY2VpdmluZ0NvbnRleHQgPSByZWNlaXZpbmdDb250ZXh0O1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJvcHBhYmxlRXZlbnQgPSBkcm9wcGFibGVFdmVudDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdGhpcy5oYW5kbGVEcmFnRW5kID0gKHBldikgPT4ge1xyXG4gICAgICAgICAgICAgICAgbGV0IHsgcmVjZWl2aW5nQ29udGV4dCwgZHJvcHBhYmxlRXZlbnQgfSA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNsZWFyRHJhZygpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlY2VpdmluZ0NvbnRleHQgJiYgZHJvcHBhYmxlRXZlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgZmluYWxIaXQgPSB0aGlzLmhpdERyYWdnaW5nLmZpbmFsSGl0O1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBmaW5hbFZpZXcgPSBmaW5hbEhpdC5jb250ZXh0LnZpZXdBcGk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGRyYWdNZXRhID0gdGhpcy5kcmFnTWV0YTtcclxuICAgICAgICAgICAgICAgICAgICByZWNlaXZpbmdDb250ZXh0LmVtaXR0ZXIudHJpZ2dlcignZHJvcCcsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgYnVpbGREYXRlUG9pbnRBcGlXaXRoQ29udGV4dChmaW5hbEhpdC5kYXRlU3BhbiwgcmVjZWl2aW5nQ29udGV4dCkpLCB7IGRyYWdnZWRFbDogcGV2LnN1YmplY3RFbCwganNFdmVudDogcGV2Lm9yaWdFdmVudCwgdmlldzogZmluYWxWaWV3IH0pKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZHJhZ01ldGEuY3JlYXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBhZGRpbmdFdmVudHMgPSBldmVudFR1cGxlVG9TdG9yZShkcm9wcGFibGVFdmVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpdmluZ0NvbnRleHQuZGlzcGF0Y2goe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ01FUkdFX0VWRU5UUycsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudFN0b3JlOiBhZGRpbmdFdmVudHMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGV2LmlzVG91Y2gpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpdmluZ0NvbnRleHQuZGlzcGF0Y2goe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdTRUxFQ1RfRVZFTlQnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50SW5zdGFuY2VJZDogZHJvcHBhYmxlRXZlbnQuaW5zdGFuY2UuaW5zdGFuY2VJZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNpZ25hbCB0aGF0IGFuIGV4dGVybmFsIGV2ZW50IGxhbmRlZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZWNlaXZpbmdDb250ZXh0LmVtaXR0ZXIudHJpZ2dlcignZXZlbnRSZWNlaXZlJywge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IG5ldyBFdmVudEltcGwocmVjZWl2aW5nQ29udGV4dCwgZHJvcHBhYmxlRXZlbnQuZGVmLCBkcm9wcGFibGVFdmVudC5pbnN0YW5jZSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWxhdGVkRXZlbnRzOiBbXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldmVydCgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWNlaXZpbmdDb250ZXh0LmRpc3BhdGNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ1JFTU9WRV9FVkVOVFMnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudFN0b3JlOiBhZGRpbmdFdmVudHMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZHJhZ2dlZEVsOiBwZXYuc3ViamVjdEVsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlldzogZmluYWxWaWV3LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlY2VpdmluZ0NvbnRleHQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kcm9wcGFibGVFdmVudCA9IG51bGw7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGxldCBoaXREcmFnZ2luZyA9IHRoaXMuaGl0RHJhZ2dpbmcgPSBuZXcgSGl0RHJhZ2dpbmcoZHJhZ2dpbmcsIGludGVyYWN0aW9uU2V0dGluZ3NTdG9yZSk7XHJcbiAgICAgICAgICAgIGhpdERyYWdnaW5nLnJlcXVpcmVJbml0aWFsID0gZmFsc2U7IC8vIHdpbGwgc3RhcnQgb3V0c2lkZSBvZiBhIGNvbXBvbmVudFxyXG4gICAgICAgICAgICBoaXREcmFnZ2luZy5lbWl0dGVyLm9uKCdkcmFnc3RhcnQnLCB0aGlzLmhhbmRsZURyYWdTdGFydCk7XHJcbiAgICAgICAgICAgIGhpdERyYWdnaW5nLmVtaXR0ZXIub24oJ2hpdHVwZGF0ZScsIHRoaXMuaGFuZGxlSGl0VXBkYXRlKTtcclxuICAgICAgICAgICAgaGl0RHJhZ2dpbmcuZW1pdHRlci5vbignZHJhZ2VuZCcsIHRoaXMuaGFuZGxlRHJhZ0VuZCk7XHJcbiAgICAgICAgICAgIHRoaXMuc3VwcGxpZWREcmFnTWV0YSA9IHN1cHBsaWVkRHJhZ01ldGE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJ1aWxkRHJhZ01ldGEoc3ViamVjdEVsKSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5zdXBwbGllZERyYWdNZXRhID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlRHJhZ01ldGEodGhpcy5zdXBwbGllZERyYWdNZXRhKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMuc3VwcGxpZWREcmFnTWV0YSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlRHJhZ01ldGEodGhpcy5zdXBwbGllZERyYWdNZXRhKHN1YmplY3RFbCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBnZXREcmFnTWV0YUZyb21FbChzdWJqZWN0RWwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkaXNwbGF5RHJhZyhuZXh0Q29udGV4dCwgc3RhdGUpIHtcclxuICAgICAgICAgICAgbGV0IHByZXZDb250ZXh0ID0gdGhpcy5yZWNlaXZpbmdDb250ZXh0O1xyXG4gICAgICAgICAgICBpZiAocHJldkNvbnRleHQgJiYgcHJldkNvbnRleHQgIT09IG5leHRDb250ZXh0KSB7XHJcbiAgICAgICAgICAgICAgICBwcmV2Q29udGV4dC5kaXNwYXRjaCh7IHR5cGU6ICdVTlNFVF9FVkVOVF9EUkFHJyB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobmV4dENvbnRleHQpIHtcclxuICAgICAgICAgICAgICAgIG5leHRDb250ZXh0LmRpc3BhdGNoKHsgdHlwZTogJ1NFVF9FVkVOVF9EUkFHJywgc3RhdGUgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY2xlYXJEcmFnKCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5yZWNlaXZpbmdDb250ZXh0KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlY2VpdmluZ0NvbnRleHQuZGlzcGF0Y2goeyB0eXBlOiAnVU5TRVRfRVZFTlRfRFJBRycgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY2FuRHJvcEVsT25DYWxlbmRhcihlbCwgcmVjZWl2aW5nQ29udGV4dCkge1xyXG4gICAgICAgICAgICBsZXQgZHJvcEFjY2VwdCA9IHJlY2VpdmluZ0NvbnRleHQub3B0aW9ucy5kcm9wQWNjZXB0O1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGRyb3BBY2NlcHQgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBkcm9wQWNjZXB0LmNhbGwocmVjZWl2aW5nQ29udGV4dC5jYWxlbmRhckFwaSwgZWwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZHJvcEFjY2VwdCA9PT0gJ3N0cmluZycgJiYgZHJvcEFjY2VwdCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIEJvb2xlYW4oZWxlbWVudE1hdGNoZXMoZWwsIGRyb3BBY2NlcHQpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBVdGlscyBmb3IgY29tcHV0aW5nIGV2ZW50IHN0b3JlIGZyb20gdGhlIERyYWdNZXRhXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICBmdW5jdGlvbiBjb21wdXRlRXZlbnRGb3JEYXRlU3BhbihkYXRlU3BhbiwgZHJhZ01ldGEsIGNvbnRleHQpIHtcclxuICAgICAgICBsZXQgZGVmUHJvcHMgPSBPYmplY3QuYXNzaWduKHt9LCBkcmFnTWV0YS5sZWZ0b3ZlclByb3BzKTtcclxuICAgICAgICBmb3IgKGxldCB0cmFuc2Zvcm0gb2YgY29udGV4dC5wbHVnaW5Ib29rcy5leHRlcm5hbERlZlRyYW5zZm9ybXMpIHtcclxuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihkZWZQcm9wcywgdHJhbnNmb3JtKGRhdGVTcGFuLCBkcmFnTWV0YSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgeyByZWZpbmVkLCBleHRyYSB9ID0gcmVmaW5lRXZlbnREZWYoZGVmUHJvcHMsIGNvbnRleHQpO1xyXG4gICAgICAgIGxldCBkZWYgPSBwYXJzZUV2ZW50RGVmKHJlZmluZWQsIGV4dHJhLCBkcmFnTWV0YS5zb3VyY2VJZCwgZGF0ZVNwYW4uYWxsRGF5LCBjb250ZXh0Lm9wdGlvbnMuZm9yY2VFdmVudER1cmF0aW9uIHx8IEJvb2xlYW4oZHJhZ01ldGEuZHVyYXRpb24pLCAvLyBoYXNFbmRcclxuICAgICAgICBjb250ZXh0KTtcclxuICAgICAgICBsZXQgc3RhcnQgPSBkYXRlU3Bhbi5yYW5nZS5zdGFydDtcclxuICAgICAgICAvLyBvbmx5IHJlbHkgb24gdGltZSBpbmZvIGlmIGRyb3Agem9uZSBpcyBhbGwtZGF5LFxyXG4gICAgICAgIC8vIG90aGVyd2lzZSwgd2UgYWxyZWFkeSBrbm93IHRoZSB0aW1lXHJcbiAgICAgICAgaWYgKGRhdGVTcGFuLmFsbERheSAmJiBkcmFnTWV0YS5zdGFydFRpbWUpIHtcclxuICAgICAgICAgICAgc3RhcnQgPSBjb250ZXh0LmRhdGVFbnYuYWRkKHN0YXJ0LCBkcmFnTWV0YS5zdGFydFRpbWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgZW5kID0gZHJhZ01ldGEuZHVyYXRpb24gP1xyXG4gICAgICAgICAgICBjb250ZXh0LmRhdGVFbnYuYWRkKHN0YXJ0LCBkcmFnTWV0YS5kdXJhdGlvbikgOlxyXG4gICAgICAgICAgICBnZXREZWZhdWx0RXZlbnRFbmQoZGF0ZVNwYW4uYWxsRGF5LCBzdGFydCwgY29udGV4dCk7XHJcbiAgICAgICAgbGV0IGluc3RhbmNlID0gY3JlYXRlRXZlbnRJbnN0YW5jZShkZWYuZGVmSWQsIHsgc3RhcnQsIGVuZCB9KTtcclxuICAgICAgICByZXR1cm4geyBkZWYsIGluc3RhbmNlIH07XHJcbiAgICB9XHJcbiAgICAvLyBVdGlscyBmb3IgZXh0cmFjdGluZyBkYXRhIGZyb20gZWxlbWVudFxyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgZnVuY3Rpb24gZ2V0RHJhZ01ldGFGcm9tRWwoZWwpIHtcclxuICAgICAgICBsZXQgc3RyID0gZ2V0RW1iZWRkZWRFbERhdGEoZWwsICdldmVudCcpO1xyXG4gICAgICAgIGxldCBvYmogPSBzdHIgP1xyXG4gICAgICAgICAgICBKU09OLnBhcnNlKHN0cikgOlxyXG4gICAgICAgICAgICB7IGNyZWF0ZTogZmFsc2UgfTsgLy8gaWYgbm8gZW1iZWRkZWQgZGF0YSwgYXNzdW1lIG5vIGV2ZW50IGNyZWF0aW9uXHJcbiAgICAgICAgcmV0dXJuIHBhcnNlRHJhZ01ldGEob2JqKTtcclxuICAgIH1cclxuICAgIGNvbmZpZy5kYXRhQXR0clByZWZpeCA9ICcnO1xyXG4gICAgZnVuY3Rpb24gZ2V0RW1iZWRkZWRFbERhdGEoZWwsIG5hbWUpIHtcclxuICAgICAgICBsZXQgcHJlZml4ID0gY29uZmlnLmRhdGFBdHRyUHJlZml4O1xyXG4gICAgICAgIGxldCBwcmVmaXhlZE5hbWUgPSAocHJlZml4ID8gcHJlZml4ICsgJy0nIDogJycpICsgbmFtZTtcclxuICAgICAgICByZXR1cm4gZWwuZ2V0QXR0cmlidXRlKCdkYXRhLScgKyBwcmVmaXhlZE5hbWUpIHx8ICcnO1xyXG4gICAgfVxyXG5cclxuICAgIC8qXHJcbiAgICBNYWtlcyBhbiBlbGVtZW50ICh0aGF0IGlzICpleHRlcm5hbCogdG8gYW55IGNhbGVuZGFyKSBkcmFnZ2FibGUuXHJcbiAgICBDYW4gcGFzcyBpbiBkYXRhIHRoYXQgZGV0ZXJtaW5lcyBob3cgYW4gZXZlbnQgd2lsbCBiZSBjcmVhdGVkIHdoZW4gZHJvcHBlZCBvbnRvIGEgY2FsZW5kYXIuXHJcbiAgICBMZXZlcmFnZXMgRnVsbENhbGVuZGFyJ3MgaW50ZXJuYWwgZHJhZy1uLWRyb3AgZnVuY3Rpb25hbGl0eSBXSVRIT1VUIGEgdGhpcmQtcGFydHkgZHJhZyBzeXN0ZW0uXHJcbiAgICAqL1xyXG4gICAgY2xhc3MgRXh0ZXJuYWxEcmFnZ2FibGUge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yKGVsLCBzZXR0aW5ncyA9IHt9KSB7XHJcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlUG9pbnRlckRvd24gPSAoZXYpID0+IHtcclxuICAgICAgICAgICAgICAgIGxldCB7IGRyYWdnaW5nIH0gPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgbGV0IHsgbWluRGlzdGFuY2UsIGxvbmdQcmVzc0RlbGF5IH0gPSB0aGlzLnNldHRpbmdzO1xyXG4gICAgICAgICAgICAgICAgZHJhZ2dpbmcubWluRGlzdGFuY2UgPVxyXG4gICAgICAgICAgICAgICAgICAgIG1pbkRpc3RhbmNlICE9IG51bGwgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5EaXN0YW5jZSA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChldi5pc1RvdWNoID8gMCA6IEJBU0VfT1BUSU9OX0RFRkFVTFRTLmV2ZW50RHJhZ01pbkRpc3RhbmNlKTtcclxuICAgICAgICAgICAgICAgIGRyYWdnaW5nLmRlbGF5ID1cclxuICAgICAgICAgICAgICAgICAgICBldi5pc1RvdWNoID8gLy8gVE9ETzogZXZlbnR1YWxseSByZWFkIGV2ZW50TG9uZ1ByZXNzRGVsYXkgaW5zdGVhZCB2dnZcclxuICAgICAgICAgICAgICAgICAgICAgICAgKGxvbmdQcmVzc0RlbGF5ICE9IG51bGwgPyBsb25nUHJlc3NEZWxheSA6IEJBU0VfT1BUSU9OX0RFRkFVTFRTLmxvbmdQcmVzc0RlbGF5KSA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDA7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlRHJhZ1N0YXJ0ID0gKGV2KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXYuaXNUb3VjaCAmJlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmcuZGVsYXkgJiZcclxuICAgICAgICAgICAgICAgICAgICBldi5zdWJqZWN0RWwuY2xhc3NMaXN0LmNvbnRhaW5zKCdmYy1ldmVudCcpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmFnZ2luZy5taXJyb3IuZ2V0TWlycm9yRWwoKS5jbGFzc0xpc3QuYWRkKCdmYy1ldmVudC1zZWxlY3RlZCcpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB0aGlzLnNldHRpbmdzID0gc2V0dGluZ3M7XHJcbiAgICAgICAgICAgIGxldCBkcmFnZ2luZyA9IHRoaXMuZHJhZ2dpbmcgPSBuZXcgRmVhdHVyZWZ1bEVsZW1lbnREcmFnZ2luZyhlbCk7XHJcbiAgICAgICAgICAgIGRyYWdnaW5nLnRvdWNoU2Nyb2xsQWxsb3dlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBpZiAoc2V0dGluZ3MuaXRlbVNlbGVjdG9yICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGRyYWdnaW5nLnBvaW50ZXIuc2VsZWN0b3IgPSBzZXR0aW5ncy5pdGVtU2VsZWN0b3I7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHNldHRpbmdzLmFwcGVuZFRvICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGRyYWdnaW5nLm1pcnJvci5wYXJlbnROb2RlID0gc2V0dGluZ3MuYXBwZW5kVG87IC8vIFRPRE86IHdyaXRlIHRlc3RzXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZHJhZ2dpbmcuZW1pdHRlci5vbigncG9pbnRlcmRvd24nLCB0aGlzLmhhbmRsZVBvaW50ZXJEb3duKTtcclxuICAgICAgICAgICAgZHJhZ2dpbmcuZW1pdHRlci5vbignZHJhZ3N0YXJ0JywgdGhpcy5oYW5kbGVEcmFnU3RhcnQpO1xyXG4gICAgICAgICAgICBuZXcgRXh0ZXJuYWxFbGVtZW50RHJhZ2dpbmcoZHJhZ2dpbmcsIHNldHRpbmdzLmV2ZW50RGF0YSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRlc3Ryb3koKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmcuZGVzdHJveSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKlxyXG4gICAgRGV0ZWN0cyB3aGVuIGEgKlRISVJELVBBUlRZKiBkcmFnLW4tZHJvcCBzeXN0ZW0gaW50ZXJhY3RzIHdpdGggZWxlbWVudHMuXHJcbiAgICBUaGUgdGhpcmQtcGFydHkgc3lzdGVtIGlzIHJlc3BvbnNpYmxlIGZvciBkcmF3aW5nIHRoZSB2aXN1YWxzIGVmZmVjdHMgb2YgdGhlIGRyYWcuXHJcbiAgICBUaGlzIGNsYXNzIHNpbXBseSBtb25pdG9ycyBmb3IgcG9pbnRlciBtb3ZlbWVudHMgYW5kIGZpcmVzIGV2ZW50cy5cclxuICAgIEl0IGFsc28gaGFzIHRoZSBhYmlsaXR5IHRvIGhpZGUgdGhlIG1vdmluZyBlbGVtZW50ICh0aGUgXCJtaXJyb3JcIikgZHVyaW5nIHRoZSBkcmFnLlxyXG4gICAgKi9cclxuICAgIGNsYXNzIEluZmVycmVkRWxlbWVudERyYWdnaW5nIGV4dGVuZHMgRWxlbWVudERyYWdnaW5nIHtcclxuICAgICAgICBjb25zdHJ1Y3Rvcihjb250YWluZXJFbCkge1xyXG4gICAgICAgICAgICBzdXBlcihjb250YWluZXJFbCk7XHJcbiAgICAgICAgICAgIHRoaXMuc2hvdWxkSWdub3JlTW92ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLm1pcnJvclNlbGVjdG9yID0gJyc7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudE1pcnJvckVsID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5oYW5kbGVQb2ludGVyRG93biA9IChldikgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0dGVyLnRyaWdnZXIoJ3BvaW50ZXJkb3duJywgZXYpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnNob3VsZElnbm9yZU1vdmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBmaXJlIGRyYWdzdGFydCByaWdodCBhd2F5LiBkb2VzIG5vdCBzdXBwb3J0IGRlbGF5IG9yIG1pbi1kaXN0YW5jZVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdHRlci50cmlnZ2VyKCdkcmFnc3RhcnQnLCBldik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlUG9pbnRlck1vdmUgPSAoZXYpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5zaG91bGRJZ25vcmVNb3ZlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0dGVyLnRyaWdnZXIoJ2RyYWdtb3ZlJywgZXYpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB0aGlzLmhhbmRsZVBvaW50ZXJVcCA9IChldikgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0dGVyLnRyaWdnZXIoJ3BvaW50ZXJ1cCcsIGV2KTtcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5zaG91bGRJZ25vcmVNb3ZlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZmlyZSBkcmFnZW5kIHJpZ2h0IGF3YXkuIGRvZXMgbm90IHN1cHBvcnQgYSByZXZlcnQgYW5pbWF0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0dGVyLnRyaWdnZXIoJ2RyYWdlbmQnLCBldik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGxldCBwb2ludGVyID0gdGhpcy5wb2ludGVyID0gbmV3IFBvaW50ZXJEcmFnZ2luZyhjb250YWluZXJFbCk7XHJcbiAgICAgICAgICAgIHBvaW50ZXIuZW1pdHRlci5vbigncG9pbnRlcmRvd24nLCB0aGlzLmhhbmRsZVBvaW50ZXJEb3duKTtcclxuICAgICAgICAgICAgcG9pbnRlci5lbWl0dGVyLm9uKCdwb2ludGVybW92ZScsIHRoaXMuaGFuZGxlUG9pbnRlck1vdmUpO1xyXG4gICAgICAgICAgICBwb2ludGVyLmVtaXR0ZXIub24oJ3BvaW50ZXJ1cCcsIHRoaXMuaGFuZGxlUG9pbnRlclVwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZGVzdHJveSgpIHtcclxuICAgICAgICAgICAgdGhpcy5wb2ludGVyLmRlc3Ryb3koKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc2V0SWdub3JlTW92ZShib29sKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2hvdWxkSWdub3JlTW92ZSA9IGJvb2w7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNldE1pcnJvcklzVmlzaWJsZShib29sKSB7XHJcbiAgICAgICAgICAgIGlmIChib29sKSB7XHJcbiAgICAgICAgICAgICAgICAvLyByZXN0b3JlIGEgcHJldmlvdXNseSBoaWRkZW4gZWxlbWVudC5cclxuICAgICAgICAgICAgICAgIC8vIHVzZSB0aGUgcmVmZXJlbmNlIGluIGNhc2UgdGhlIHNlbGVjdG9yIGNsYXNzIGhhcyBhbHJlYWR5IGJlZW4gcmVtb3ZlZC5cclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRNaXJyb3JFbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudE1pcnJvckVsLnN0eWxlLnZpc2liaWxpdHkgPSAnJztcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRNaXJyb3JFbCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgbWlycm9yRWwgPSB0aGlzLm1pcnJvclNlbGVjdG9yXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogc29tZWhvdyBxdWVyeSBGdWxsQ2FsZW5kYXJzIFdJVEhJTiBzaGFkb3ctcm9vdHNcclxuICAgICAgICAgICAgICAgICAgICA/IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGhpcy5taXJyb3JTZWxlY3RvcilcclxuICAgICAgICAgICAgICAgICAgICA6IG51bGw7XHJcbiAgICAgICAgICAgICAgICBpZiAobWlycm9yRWwpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRNaXJyb3JFbCA9IG1pcnJvckVsO1xyXG4gICAgICAgICAgICAgICAgICAgIG1pcnJvckVsLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKlxyXG4gICAgQnJpZGdlcyB0aGlyZC1wYXJ0eSBkcmFnLW4tZHJvcCBzeXN0ZW1zIHdpdGggRnVsbENhbGVuZGFyLlxyXG4gICAgTXVzdCBiZSBpbnN0YW50aWF0ZWQgYW5kIGRlc3Ryb3llZCBieSBjYWxsZXIuXHJcbiAgICAqL1xyXG4gICAgY2xhc3MgVGhpcmRQYXJ0eURyYWdnYWJsZSB7XHJcbiAgICAgICAgY29uc3RydWN0b3IoY29udGFpbmVyT3JTZXR0aW5ncywgc2V0dGluZ3MpIHtcclxuICAgICAgICAgICAgbGV0IGNvbnRhaW5lckVsID0gZG9jdW1lbnQ7XHJcbiAgICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgLy8gd2lzaCB3ZSBjb3VsZCBqdXN0IHRlc3QgaW5zdGFuY2VvZiBFdmVudFRhcmdldCwgYnV0IGRvZXNuJ3Qgd29yayBpbiBJRTExXHJcbiAgICAgICAgICAgIGNvbnRhaW5lck9yU2V0dGluZ3MgPT09IGRvY3VtZW50IHx8XHJcbiAgICAgICAgICAgICAgICBjb250YWluZXJPclNldHRpbmdzIGluc3RhbmNlb2YgRWxlbWVudCkge1xyXG4gICAgICAgICAgICAgICAgY29udGFpbmVyRWwgPSBjb250YWluZXJPclNldHRpbmdzO1xyXG4gICAgICAgICAgICAgICAgc2V0dGluZ3MgPSBzZXR0aW5ncyB8fCB7fTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHNldHRpbmdzID0gKGNvbnRhaW5lck9yU2V0dGluZ3MgfHwge30pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxldCBkcmFnZ2luZyA9IHRoaXMuZHJhZ2dpbmcgPSBuZXcgSW5mZXJyZWRFbGVtZW50RHJhZ2dpbmcoY29udGFpbmVyRWwpO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHNldHRpbmdzLml0ZW1TZWxlY3RvciA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgIGRyYWdnaW5nLnBvaW50ZXIuc2VsZWN0b3IgPSBzZXR0aW5ncy5pdGVtU2VsZWN0b3I7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY29udGFpbmVyRWwgPT09IGRvY3VtZW50KSB7XHJcbiAgICAgICAgICAgICAgICBkcmFnZ2luZy5wb2ludGVyLnNlbGVjdG9yID0gJ1tkYXRhLWV2ZW50XSc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBzZXR0aW5ncy5taXJyb3JTZWxlY3RvciA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgIGRyYWdnaW5nLm1pcnJvclNlbGVjdG9yID0gc2V0dGluZ3MubWlycm9yU2VsZWN0b3I7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbmV3IEV4dGVybmFsRWxlbWVudERyYWdnaW5nKGRyYWdnaW5nLCBzZXR0aW5ncy5ldmVudERhdGEpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xyXG4gICAgICAgIH1cclxuICAgICAgICBkZXN0cm95KCkge1xyXG4gICAgICAgICAgICB0aGlzLmRyYWdnaW5nLmRlc3Ryb3koKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGluZGV4JDQgPSBjcmVhdGVQbHVnaW4oe1xyXG4gICAgICAgIG5hbWU6ICdAZnVsbGNhbGVuZGFyL2ludGVyYWN0aW9uJyxcclxuICAgICAgICBjb21wb25lbnRJbnRlcmFjdGlvbnM6IFtEYXRlQ2xpY2tpbmcsIERhdGVTZWxlY3RpbmcsIEV2ZW50RHJhZ2dpbmcsIEV2ZW50UmVzaXppbmddLFxyXG4gICAgICAgIGNhbGVuZGFySW50ZXJhY3Rpb25zOiBbVW5zZWxlY3RBdXRvXSxcclxuICAgICAgICBlbGVtZW50RHJhZ2dpbmdJbXBsOiBGZWF0dXJlZnVsRWxlbWVudERyYWdnaW5nLFxyXG4gICAgICAgIG9wdGlvblJlZmluZXJzOiBPUFRJT05fUkVGSU5FUlMkMyxcclxuICAgICAgICBsaXN0ZW5lclJlZmluZXJzOiBMSVNURU5FUl9SRUZJTkVSUyxcclxuICAgIH0pO1xyXG5cclxuICAgIHZhciBjc3NfMjQ4eiQzID0gXCI6cm9vdHstLWZjLWRheWdyaWQtZXZlbnQtZG90LXdpZHRoOjhweH0uZmMtZGF5Z3JpZC1kYXktZXZlbnRzOmFmdGVyLC5mYy1kYXlncmlkLWRheS1ldmVudHM6YmVmb3JlLC5mYy1kYXlncmlkLWRheS1mcmFtZTphZnRlciwuZmMtZGF5Z3JpZC1kYXktZnJhbWU6YmVmb3JlLC5mYy1kYXlncmlkLWV2ZW50LWhhcm5lc3M6YWZ0ZXIsLmZjLWRheWdyaWQtZXZlbnQtaGFybmVzczpiZWZvcmV7Y2xlYXI6Ym90aDtjb250ZW50OlxcXCJcXFwiO2Rpc3BsYXk6dGFibGV9LmZjIC5mYy1kYXlncmlkLWJvZHl7cG9zaXRpb246cmVsYXRpdmU7ei1pbmRleDoxfS5mYyAuZmMtZGF5Z3JpZC1kYXkuZmMtZGF5LXRvZGF5e2JhY2tncm91bmQtY29sb3I6dmFyKC0tZmMtdG9kYXktYmctY29sb3IpfS5mYyAuZmMtZGF5Z3JpZC1kYXktZnJhbWV7bWluLWhlaWdodDoxMDAlO3Bvc2l0aW9uOnJlbGF0aXZlfS5mYyAuZmMtZGF5Z3JpZC1kYXktdG9we2Rpc3BsYXk6ZmxleDtmbGV4LWRpcmVjdGlvbjpyb3ctcmV2ZXJzZX0uZmMgLmZjLWRheS1vdGhlciAuZmMtZGF5Z3JpZC1kYXktdG9we29wYWNpdHk6LjN9LmZjIC5mYy1kYXlncmlkLWRheS1udW1iZXJ7cGFkZGluZzo0cHg7cG9zaXRpb246cmVsYXRpdmU7ei1pbmRleDo0fS5mYyAuZmMtZGF5Z3JpZC1tb250aC1zdGFydHtmb250LXNpemU6MS4xZW07Zm9udC13ZWlnaHQ6NzAwfS5mYyAuZmMtZGF5Z3JpZC1kYXktZXZlbnRze21hcmdpbi10b3A6MXB4fS5mYyAuZmMtZGF5Z3JpZC1ib2R5LWJhbGFuY2VkIC5mYy1kYXlncmlkLWRheS1ldmVudHN7bGVmdDowO3Bvc2l0aW9uOmFic29sdXRlO3JpZ2h0OjB9LmZjIC5mYy1kYXlncmlkLWJvZHktdW5iYWxhbmNlZCAuZmMtZGF5Z3JpZC1kYXktZXZlbnRze21pbi1oZWlnaHQ6MmVtO3Bvc2l0aW9uOnJlbGF0aXZlfS5mYyAuZmMtZGF5Z3JpZC1ib2R5LW5hdHVyYWwgLmZjLWRheWdyaWQtZGF5LWV2ZW50c3ttYXJnaW4tYm90dG9tOjFlbX0uZmMgLmZjLWRheWdyaWQtZXZlbnQtaGFybmVzc3twb3NpdGlvbjpyZWxhdGl2ZX0uZmMgLmZjLWRheWdyaWQtZXZlbnQtaGFybmVzcy1hYnN7bGVmdDowO3Bvc2l0aW9uOmFic29sdXRlO3JpZ2h0OjA7dG9wOjB9LmZjIC5mYy1kYXlncmlkLWJnLWhhcm5lc3N7Ym90dG9tOjA7cG9zaXRpb246YWJzb2x1dGU7dG9wOjB9LmZjIC5mYy1kYXlncmlkLWRheS1iZyAuZmMtbm9uLWJ1c2luZXNze3otaW5kZXg6MX0uZmMgLmZjLWRheWdyaWQtZGF5LWJnIC5mYy1iZy1ldmVudHt6LWluZGV4OjJ9LmZjIC5mYy1kYXlncmlkLWRheS1iZyAuZmMtaGlnaGxpZ2h0e3otaW5kZXg6M30uZmMgLmZjLWRheWdyaWQtZXZlbnR7bWFyZ2luLXRvcDoxcHg7ei1pbmRleDo2fS5mYyAuZmMtZGF5Z3JpZC1ldmVudC5mYy1ldmVudC1taXJyb3J7ei1pbmRleDo3fS5mYyAuZmMtZGF5Z3JpZC1kYXktYm90dG9te2ZvbnQtc2l6ZTouODVlbTttYXJnaW46MCAycHh9LmZjIC5mYy1kYXlncmlkLWRheS1ib3R0b206YWZ0ZXIsLmZjIC5mYy1kYXlncmlkLWRheS1ib3R0b206YmVmb3Jle2NsZWFyOmJvdGg7Y29udGVudDpcXFwiXFxcIjtkaXNwbGF5OnRhYmxlfS5mYyAuZmMtZGF5Z3JpZC1tb3JlLWxpbmt7Ym9yZGVyLXJhZGl1czozcHg7Y3Vyc29yOnBvaW50ZXI7bGluZS1oZWlnaHQ6MTttYXJnaW4tdG9wOjFweDttYXgtd2lkdGg6MTAwJTtvdmVyZmxvdzpoaWRkZW47cGFkZGluZzoycHg7cG9zaXRpb246cmVsYXRpdmU7d2hpdGUtc3BhY2U6bm93cmFwO3otaW5kZXg6NH0uZmMgLmZjLWRheWdyaWQtbW9yZS1saW5rOmhvdmVye2JhY2tncm91bmQtY29sb3I6cmdiYSgwLDAsMCwuMSl9LmZjIC5mYy1kYXlncmlkLXdlZWstbnVtYmVye2JhY2tncm91bmQtY29sb3I6dmFyKC0tZmMtbmV1dHJhbC1iZy1jb2xvcik7Y29sb3I6dmFyKC0tZmMtbmV1dHJhbC10ZXh0LWNvbG9yKTttaW4td2lkdGg6MS41ZW07cGFkZGluZzoycHg7cG9zaXRpb246YWJzb2x1dGU7dGV4dC1hbGlnbjpjZW50ZXI7dG9wOjA7ei1pbmRleDo1fS5mYyAuZmMtbW9yZS1wb3BvdmVyIC5mYy1wb3BvdmVyLWJvZHl7bWluLXdpZHRoOjIyMHB4O3BhZGRpbmc6MTBweH0uZmMtZGlyZWN0aW9uLWx0ciAuZmMtZGF5Z3JpZC1ldmVudC5mYy1ldmVudC1zdGFydCwuZmMtZGlyZWN0aW9uLXJ0bCAuZmMtZGF5Z3JpZC1ldmVudC5mYy1ldmVudC1lbmR7bWFyZ2luLWxlZnQ6MnB4fS5mYy1kaXJlY3Rpb24tbHRyIC5mYy1kYXlncmlkLWV2ZW50LmZjLWV2ZW50LWVuZCwuZmMtZGlyZWN0aW9uLXJ0bCAuZmMtZGF5Z3JpZC1ldmVudC5mYy1ldmVudC1zdGFydHttYXJnaW4tcmlnaHQ6MnB4fS5mYy1kaXJlY3Rpb24tbHRyIC5mYy1kYXlncmlkLW1vcmUtbGlua3tmbG9hdDpsZWZ0fS5mYy1kaXJlY3Rpb24tbHRyIC5mYy1kYXlncmlkLXdlZWstbnVtYmVye2JvcmRlci1yYWRpdXM6MCAwIDNweCAwO2xlZnQ6MH0uZmMtZGlyZWN0aW9uLXJ0bCAuZmMtZGF5Z3JpZC1tb3JlLWxpbmt7ZmxvYXQ6cmlnaHR9LmZjLWRpcmVjdGlvbi1ydGwgLmZjLWRheWdyaWQtd2Vlay1udW1iZXJ7Ym9yZGVyLXJhZGl1czowIDAgMCAzcHg7cmlnaHQ6MH0uZmMtbGlxdWlkLWhhY2sgLmZjLWRheWdyaWQtZGF5LWZyYW1le3Bvc2l0aW9uOnN0YXRpY30uZmMtZGF5Z3JpZC1ldmVudHtib3JkZXItcmFkaXVzOjNweDtmb250LXNpemU6dmFyKC0tZmMtc21hbGwtZm9udC1zaXplKTtwb3NpdGlvbjpyZWxhdGl2ZTt3aGl0ZS1zcGFjZTpub3dyYXB9LmZjLWRheWdyaWQtYmxvY2stZXZlbnQgLmZjLWV2ZW50LXRpbWV7Zm9udC13ZWlnaHQ6NzAwfS5mYy1kYXlncmlkLWJsb2NrLWV2ZW50IC5mYy1ldmVudC10aW1lLC5mYy1kYXlncmlkLWJsb2NrLWV2ZW50IC5mYy1ldmVudC10aXRsZXtwYWRkaW5nOjFweH0uZmMtZGF5Z3JpZC1kb3QtZXZlbnR7YWxpZ24taXRlbXM6Y2VudGVyO2Rpc3BsYXk6ZmxleDtwYWRkaW5nOjJweCAwfS5mYy1kYXlncmlkLWRvdC1ldmVudCAuZmMtZXZlbnQtdGl0bGV7ZmxleC1ncm93OjE7ZmxleC1zaHJpbms6MTtmb250LXdlaWdodDo3MDA7bWluLXdpZHRoOjA7b3ZlcmZsb3c6aGlkZGVufS5mYy1kYXlncmlkLWRvdC1ldmVudC5mYy1ldmVudC1taXJyb3IsLmZjLWRheWdyaWQtZG90LWV2ZW50OmhvdmVye2JhY2tncm91bmQ6cmdiYSgwLDAsMCwuMSl9LmZjLWRheWdyaWQtZG90LWV2ZW50LmZjLWV2ZW50LXNlbGVjdGVkOmJlZm9yZXtib3R0b206LTEwcHg7dG9wOi0xMHB4fS5mYy1kYXlncmlkLWV2ZW50LWRvdHtib3JkZXI6Y2FsYyh2YXIoLS1mYy1kYXlncmlkLWV2ZW50LWRvdC13aWR0aCkvMikgc29saWQgdmFyKC0tZmMtZXZlbnQtYm9yZGVyLWNvbG9yKTtib3JkZXItcmFkaXVzOmNhbGModmFyKC0tZmMtZGF5Z3JpZC1ldmVudC1kb3Qtd2lkdGgpLzIpO2JveC1zaXppbmc6Y29udGVudC1ib3g7aGVpZ2h0OjA7bWFyZ2luOjAgNHB4O3dpZHRoOjB9LmZjLWRpcmVjdGlvbi1sdHIgLmZjLWRheWdyaWQtZXZlbnQgLmZjLWV2ZW50LXRpbWV7bWFyZ2luLXJpZ2h0OjNweH0uZmMtZGlyZWN0aW9uLXJ0bCAuZmMtZGF5Z3JpZC1ldmVudCAuZmMtZXZlbnQtdGltZXttYXJnaW4tbGVmdDozcHh9XCI7XHJcbiAgICBpbmplY3RTdHlsZXMoY3NzXzI0OHokMyk7XHJcblxyXG4gICAgZnVuY3Rpb24gc3BsaXRTZWdzQnlSb3coc2Vncywgcm93Q250KSB7XHJcbiAgICAgICAgbGV0IGJ5Um93ID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByb3dDbnQ7IGkgKz0gMSkge1xyXG4gICAgICAgICAgICBieVJvd1tpXSA9IFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGxldCBzZWcgb2Ygc2Vncykge1xyXG4gICAgICAgICAgICBieVJvd1tzZWcucm93XS5wdXNoKHNlZyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBieVJvdztcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHNwbGl0U2Vnc0J5Rmlyc3RDb2woc2VncywgY29sQ250KSB7XHJcbiAgICAgICAgbGV0IGJ5Q29sID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2xDbnQ7IGkgKz0gMSkge1xyXG4gICAgICAgICAgICBieUNvbFtpXSA9IFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGxldCBzZWcgb2Ygc2Vncykge1xyXG4gICAgICAgICAgICBieUNvbFtzZWcuZmlyc3RDb2xdLnB1c2goc2VnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGJ5Q29sO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gc3BsaXRJbnRlcmFjdGlvbkJ5Um93KHVpLCByb3dDbnQpIHtcclxuICAgICAgICBsZXQgYnlSb3cgPSBbXTtcclxuICAgICAgICBpZiAoIXVpKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcm93Q250OyBpICs9IDEpIHtcclxuICAgICAgICAgICAgICAgIGJ5Um93W2ldID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByb3dDbnQ7IGkgKz0gMSkge1xyXG4gICAgICAgICAgICAgICAgYnlSb3dbaV0gPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWZmZWN0ZWRJbnN0YW5jZXM6IHVpLmFmZmVjdGVkSW5zdGFuY2VzLFxyXG4gICAgICAgICAgICAgICAgICAgIGlzRXZlbnQ6IHVpLmlzRXZlbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgc2VnczogW10sXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvciAobGV0IHNlZyBvZiB1aS5zZWdzKSB7XHJcbiAgICAgICAgICAgICAgICBieVJvd1tzZWcucm93XS5zZWdzLnB1c2goc2VnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYnlSb3c7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgREVGQVVMVF9UQUJMRV9FVkVOVF9USU1FX0ZPUk1BVCA9IGNyZWF0ZUZvcm1hdHRlcih7XHJcbiAgICAgICAgaG91cjogJ251bWVyaWMnLFxyXG4gICAgICAgIG1pbnV0ZTogJzItZGlnaXQnLFxyXG4gICAgICAgIG9taXRaZXJvTWludXRlOiB0cnVlLFxyXG4gICAgICAgIG1lcmlkaWVtOiAnbmFycm93JyxcclxuICAgIH0pO1xyXG4gICAgZnVuY3Rpb24gaGFzTGlzdEl0ZW1EaXNwbGF5KHNlZykge1xyXG4gICAgICAgIGxldCB7IGRpc3BsYXkgfSA9IHNlZy5ldmVudFJhbmdlLnVpO1xyXG4gICAgICAgIHJldHVybiBkaXNwbGF5ID09PSAnbGlzdC1pdGVtJyB8fCAoZGlzcGxheSA9PT0gJ2F1dG8nICYmXHJcbiAgICAgICAgICAgICFzZWcuZXZlbnRSYW5nZS5kZWYuYWxsRGF5ICYmXHJcbiAgICAgICAgICAgIHNlZy5maXJzdENvbCA9PT0gc2VnLmxhc3RDb2wgJiYgLy8gY2FuJ3QgYmUgbXVsdGktZGF5XHJcbiAgICAgICAgICAgIHNlZy5pc1N0YXJ0ICYmIC8vIFwiXHJcbiAgICAgICAgICAgIHNlZy5pc0VuZCAvLyBcIlxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgY2xhc3MgVGFibGVCbG9ja0V2ZW50IGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XHJcbiAgICAgICAgcmVuZGVyKCkge1xyXG4gICAgICAgICAgICBsZXQgeyBwcm9wcyB9ID0gdGhpcztcclxuICAgICAgICAgICAgcmV0dXJuICh5KFN0YW5kYXJkRXZlbnQsIE9iamVjdC5hc3NpZ24oe30sIHByb3BzLCB7IGVsQ2xhc3NlczogWydmYy1kYXlncmlkLWV2ZW50JywgJ2ZjLWRheWdyaWQtYmxvY2stZXZlbnQnLCAnZmMtaC1ldmVudCddLCBkZWZhdWx0VGltZUZvcm1hdDogREVGQVVMVF9UQUJMRV9FVkVOVF9USU1FX0ZPUk1BVCwgZGVmYXVsdERpc3BsYXlFdmVudEVuZDogcHJvcHMuZGVmYXVsdERpc3BsYXlFdmVudEVuZCwgZGlzYWJsZVJlc2l6aW5nOiAhcHJvcHMuc2VnLmV2ZW50UmFuZ2UuZGVmLmFsbERheSB9KSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBjbGFzcyBUYWJsZUxpc3RJdGVtRXZlbnQgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcclxuICAgICAgICByZW5kZXIoKSB7XHJcbiAgICAgICAgICAgIGxldCB7IHByb3BzLCBjb250ZXh0IH0gPSB0aGlzO1xyXG4gICAgICAgICAgICBsZXQgeyBvcHRpb25zIH0gPSBjb250ZXh0O1xyXG4gICAgICAgICAgICBsZXQgeyBzZWcgfSA9IHByb3BzO1xyXG4gICAgICAgICAgICBsZXQgdGltZUZvcm1hdCA9IG9wdGlvbnMuZXZlbnRUaW1lRm9ybWF0IHx8IERFRkFVTFRfVEFCTEVfRVZFTlRfVElNRV9GT1JNQVQ7XHJcbiAgICAgICAgICAgIGxldCB0aW1lVGV4dCA9IGJ1aWxkU2VnVGltZVRleHQoc2VnLCB0aW1lRm9ybWF0LCBjb250ZXh0LCB0cnVlLCBwcm9wcy5kZWZhdWx0RGlzcGxheUV2ZW50RW5kKTtcclxuICAgICAgICAgICAgcmV0dXJuICh5KEV2ZW50Q29udGFpbmVyLCBPYmplY3QuYXNzaWduKHt9LCBwcm9wcywgeyBlbFRhZzogXCJhXCIsIGVsQ2xhc3NlczogWydmYy1kYXlncmlkLWV2ZW50JywgJ2ZjLWRheWdyaWQtZG90LWV2ZW50J10sIGVsQXR0cnM6IGdldFNlZ0FuY2hvckF0dHJzKHByb3BzLnNlZywgY29udGV4dCksIGRlZmF1bHRHZW5lcmF0b3I6IHJlbmRlcklubmVyQ29udGVudCQyLCB0aW1lVGV4dDogdGltZVRleHQsIGlzUmVzaXppbmc6IGZhbHNlLCBpc0RhdGVTZWxlY3Rpbmc6IGZhbHNlIH0pKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gcmVuZGVySW5uZXJDb250ZW50JDIocmVuZGVyUHJvcHMpIHtcclxuICAgICAgICByZXR1cm4gKHkoXywgbnVsbCxcclxuICAgICAgICAgICAgeShcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy1kYXlncmlkLWV2ZW50LWRvdFwiLCBzdHlsZTogeyBib3JkZXJDb2xvcjogcmVuZGVyUHJvcHMuYm9yZGVyQ29sb3IgfHwgcmVuZGVyUHJvcHMuYmFja2dyb3VuZENvbG9yIH0gfSksXHJcbiAgICAgICAgICAgIHJlbmRlclByb3BzLnRpbWVUZXh0ICYmICh5KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLWV2ZW50LXRpbWVcIiB9LCByZW5kZXJQcm9wcy50aW1lVGV4dCkpLFxyXG4gICAgICAgICAgICB5KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLWV2ZW50LXRpdGxlXCIgfSwgcmVuZGVyUHJvcHMuZXZlbnQudGl0bGUgfHwgeShfLCBudWxsLCBcIlxcdTAwQTBcIikpKSk7XHJcbiAgICB9XHJcblxyXG4gICAgY2xhc3MgVGFibGVDZWxsTW9yZUxpbmsgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcclxuICAgICAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgdGhpcy5jb21waWxlU2VncyA9IG1lbW9pemUoY29tcGlsZVNlZ3MpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZW5kZXIoKSB7XHJcbiAgICAgICAgICAgIGxldCB7IHByb3BzIH0gPSB0aGlzO1xyXG4gICAgICAgICAgICBsZXQgeyBhbGxTZWdzLCBpbnZpc2libGVTZWdzIH0gPSB0aGlzLmNvbXBpbGVTZWdzKHByb3BzLnNpbmdsZVBsYWNlbWVudHMpO1xyXG4gICAgICAgICAgICByZXR1cm4gKHkoTW9yZUxpbmtDb250YWluZXIsIHsgZWxDbGFzc2VzOiBbJ2ZjLWRheWdyaWQtbW9yZS1saW5rJ10sIGRhdGVQcm9maWxlOiBwcm9wcy5kYXRlUHJvZmlsZSwgdG9kYXlSYW5nZTogcHJvcHMudG9kYXlSYW5nZSwgYWxsRGF5RGF0ZTogcHJvcHMuYWxsRGF5RGF0ZSwgbW9yZUNudDogcHJvcHMubW9yZUNudCwgYWxsU2VnczogYWxsU2VncywgaGlkZGVuU2VnczogaW52aXNpYmxlU2VncywgYWxpZ25tZW50RWxSZWY6IHByb3BzLmFsaWdubWVudEVsUmVmLCBhbGlnbkdyaWRUb3A6IHByb3BzLmFsaWduR3JpZFRvcCwgZXh0cmFEYXRlU3BhbjogcHJvcHMuZXh0cmFEYXRlU3BhbiwgcG9wb3ZlckNvbnRlbnQ6ICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgaXNGb3JjZWRJbnZpc2libGUgPSAocHJvcHMuZXZlbnREcmFnID8gcHJvcHMuZXZlbnREcmFnLmFmZmVjdGVkSW5zdGFuY2VzIDogbnVsbCkgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgKHByb3BzLmV2ZW50UmVzaXplID8gcHJvcHMuZXZlbnRSZXNpemUuYWZmZWN0ZWRJbnN0YW5jZXMgOiBudWxsKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7fTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHkoXywgbnVsbCwgYWxsU2Vncy5tYXAoKHNlZykgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgaW5zdGFuY2VJZCA9IHNlZy5ldmVudFJhbmdlLmluc3RhbmNlLmluc3RhbmNlSWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoeShcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy1kYXlncmlkLWV2ZW50LWhhcm5lc3NcIiwga2V5OiBpbnN0YW5jZUlkLCBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpc2liaWxpdHk6IGlzRm9yY2VkSW52aXNpYmxlW2luc3RhbmNlSWRdID8gJ2hpZGRlbicgOiAnJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gfSwgaGFzTGlzdEl0ZW1EaXNwbGF5KHNlZykgPyAoeShUYWJsZUxpc3RJdGVtRXZlbnQsIE9iamVjdC5hc3NpZ24oeyBzZWc6IHNlZywgaXNEcmFnZ2luZzogZmFsc2UsIGlzU2VsZWN0ZWQ6IGluc3RhbmNlSWQgPT09IHByb3BzLmV2ZW50U2VsZWN0aW9uLCBkZWZhdWx0RGlzcGxheUV2ZW50RW5kOiBmYWxzZSB9LCBnZXRTZWdNZXRhKHNlZywgcHJvcHMudG9kYXlSYW5nZSkpKSkgOiAoeShUYWJsZUJsb2NrRXZlbnQsIE9iamVjdC5hc3NpZ24oeyBzZWc6IHNlZywgaXNEcmFnZ2luZzogZmFsc2UsIGlzUmVzaXppbmc6IGZhbHNlLCBpc0RhdGVTZWxlY3Rpbmc6IGZhbHNlLCBpc1NlbGVjdGVkOiBpbnN0YW5jZUlkID09PSBwcm9wcy5ldmVudFNlbGVjdGlvbiwgZGVmYXVsdERpc3BsYXlFdmVudEVuZDogZmFsc2UgfSwgZ2V0U2VnTWV0YShzZWcsIHByb3BzLnRvZGF5UmFuZ2UpKSkpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSkpKTtcclxuICAgICAgICAgICAgICAgIH0gfSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGNvbXBpbGVTZWdzKHNpbmdsZVBsYWNlbWVudHMpIHtcclxuICAgICAgICBsZXQgYWxsU2VncyA9IFtdO1xyXG4gICAgICAgIGxldCBpbnZpc2libGVTZWdzID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgcGxhY2VtZW50IG9mIHNpbmdsZVBsYWNlbWVudHMpIHtcclxuICAgICAgICAgICAgYWxsU2Vncy5wdXNoKHBsYWNlbWVudC5zZWcpO1xyXG4gICAgICAgICAgICBpZiAoIXBsYWNlbWVudC5pc1Zpc2libGUpIHtcclxuICAgICAgICAgICAgICAgIGludmlzaWJsZVNlZ3MucHVzaChwbGFjZW1lbnQuc2VnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4geyBhbGxTZWdzLCBpbnZpc2libGVTZWdzIH07XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgREVGQVVMVF9XRUVLX05VTV9GT1JNQVQkMSA9IGNyZWF0ZUZvcm1hdHRlcih7IHdlZWs6ICduYXJyb3cnIH0pO1xyXG4gICAgY2xhc3MgVGFibGVDZWxsIGV4dGVuZHMgRGF0ZUNvbXBvbmVudCB7XHJcbiAgICAgICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgIHRoaXMucm9vdEVsUmVmID0gZCgpO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0ge1xyXG4gICAgICAgICAgICAgICAgZGF5TnVtYmVySWQ6IGdldFVuaXF1ZURvbUlkKCksXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlUm9vdEVsID0gKGVsKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBzZXRSZWYodGhpcy5yb290RWxSZWYsIGVsKTtcclxuICAgICAgICAgICAgICAgIHNldFJlZih0aGlzLnByb3BzLmVsUmVmLCBlbCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlbmRlcigpIHtcclxuICAgICAgICAgICAgbGV0IHsgY29udGV4dCwgcHJvcHMsIHN0YXRlLCByb290RWxSZWYgfSA9IHRoaXM7XHJcbiAgICAgICAgICAgIGxldCB7IG9wdGlvbnMsIGRhdGVFbnYgfSA9IGNvbnRleHQ7XHJcbiAgICAgICAgICAgIGxldCB7IGRhdGUsIGRhdGVQcm9maWxlIH0gPSBwcm9wcztcclxuICAgICAgICAgICAgLy8gVE9ETzogbWVtb2l6ZSB0aGlzP1xyXG4gICAgICAgICAgICBjb25zdCBpc01vbnRoU3RhcnQgPSBwcm9wcy5zaG93RGF5TnVtYmVyICYmXHJcbiAgICAgICAgICAgICAgICBzaG91bGREaXNwbGF5TW9udGhTdGFydChkYXRlLCBkYXRlUHJvZmlsZS5jdXJyZW50UmFuZ2UsIGRhdGVFbnYpO1xyXG4gICAgICAgICAgICByZXR1cm4gKHkoRGF5Q2VsbENvbnRhaW5lciwgeyBlbFRhZzogXCJ0ZFwiLCBlbFJlZjogdGhpcy5oYW5kbGVSb290RWwsIGVsQ2xhc3NlczogW1xyXG4gICAgICAgICAgICAgICAgICAgICdmYy1kYXlncmlkLWRheScsXHJcbiAgICAgICAgICAgICAgICAgICAgLi4uKHByb3BzLmV4dHJhQ2xhc3NOYW1lcyB8fCBbXSksXHJcbiAgICAgICAgICAgICAgICBdLCBlbEF0dHJzOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcHJvcHMuZXh0cmFEYXRhQXR0cnMpLCAocHJvcHMuc2hvd0RheU51bWJlciA/IHsgJ2FyaWEtbGFiZWxsZWRieSc6IHN0YXRlLmRheU51bWJlcklkIH0gOiB7fSkpLCB7IHJvbGU6ICdncmlkY2VsbCcgfSksIGRlZmF1bHRHZW5lcmF0b3I6IHJlbmRlclRvcElubmVyLCBkYXRlOiBkYXRlLCBkYXRlUHJvZmlsZTogZGF0ZVByb2ZpbGUsIHRvZGF5UmFuZ2U6IHByb3BzLnRvZGF5UmFuZ2UsIHNob3dEYXlOdW1iZXI6IHByb3BzLnNob3dEYXlOdW1iZXIsIGlzTW9udGhTdGFydDogaXNNb250aFN0YXJ0LCBleHRyYVJlbmRlclByb3BzOiBwcm9wcy5leHRyYVJlbmRlclByb3BzIH0sIChJbm5lckNvbnRlbnQsIHJlbmRlclByb3BzKSA9PiAoeShcImRpdlwiLCB7IHJlZjogcHJvcHMuaW5uZXJFbFJlZiwgY2xhc3NOYW1lOiBcImZjLWRheWdyaWQtZGF5LWZyYW1lIGZjLXNjcm9sbGdyaWQtc3luYy1pbm5lclwiLCBzdHlsZTogeyBtaW5IZWlnaHQ6IHByb3BzLm1pbkhlaWdodCB9IH0sXHJcbiAgICAgICAgICAgICAgICBwcm9wcy5zaG93V2Vla051bWJlciAmJiAoeShXZWVrTnVtYmVyQ29udGFpbmVyLCB7IGVsVGFnOiBcImFcIiwgZWxDbGFzc2VzOiBbJ2ZjLWRheWdyaWQtd2Vlay1udW1iZXInXSwgZWxBdHRyczogYnVpbGROYXZMaW5rQXR0cnMoY29udGV4dCwgZGF0ZSwgJ3dlZWsnKSwgZGF0ZTogZGF0ZSwgZGVmYXVsdEZvcm1hdDogREVGQVVMVF9XRUVLX05VTV9GT1JNQVQkMSB9KSksXHJcbiAgICAgICAgICAgICAgICAhcmVuZGVyUHJvcHMuaXNEaXNhYmxlZCAmJlxyXG4gICAgICAgICAgICAgICAgICAgIChwcm9wcy5zaG93RGF5TnVtYmVyIHx8IGhhc0N1c3RvbURheUNlbGxDb250ZW50KG9wdGlvbnMpIHx8IHByb3BzLmZvcmNlRGF5VG9wKSA/ICh5KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLWRheWdyaWQtZGF5LXRvcFwiIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgeShJbm5lckNvbnRlbnQsIHsgZWxUYWc6IFwiYVwiLCBlbENsYXNzZXM6IFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdmYy1kYXlncmlkLWRheS1udW1iZXInLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNNb250aFN0YXJ0ICYmICdmYy1kYXlncmlkLW1vbnRoLXN0YXJ0JyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgXSwgZWxBdHRyczogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBidWlsZE5hdkxpbmtBdHRycyhjb250ZXh0LCBkYXRlKSksIHsgaWQ6IHN0YXRlLmRheU51bWJlcklkIH0pIH0pKSkgOiBwcm9wcy5zaG93RGF5TnVtYmVyID8gKFxyXG4gICAgICAgICAgICAgICAgLy8gZm9yIGNyZWF0aW5nIGNvcnJlY3QgYW1vdW50IG9mIHNwYWNlIChzZWUgaXNzdWUgIzcxNjIpXHJcbiAgICAgICAgICAgICAgICB5KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLWRheWdyaWQtZGF5LXRvcFwiLCBzdHlsZTogeyB2aXNpYmlsaXR5OiAnaGlkZGVuJyB9IH0sXHJcbiAgICAgICAgICAgICAgICAgICAgeShcImFcIiwgeyBjbGFzc05hbWU6IFwiZmMtZGF5Z3JpZC1kYXktbnVtYmVyXCIgfSwgXCJcXHUwMEEwXCIpKSkgOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgICAgICB5KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLWRheWdyaWQtZGF5LWV2ZW50c1wiLCByZWY6IHByb3BzLmZnQ29udGVudEVsUmVmIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgcHJvcHMuZmdDb250ZW50LFxyXG4gICAgICAgICAgICAgICAgICAgIHkoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtZGF5Z3JpZC1kYXktYm90dG9tXCIsIHN0eWxlOiB7IG1hcmdpblRvcDogcHJvcHMubW9yZU1hcmdpblRvcCB9IH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHkoVGFibGVDZWxsTW9yZUxpbmssIHsgYWxsRGF5RGF0ZTogZGF0ZSwgc2luZ2xlUGxhY2VtZW50czogcHJvcHMuc2luZ2xlUGxhY2VtZW50cywgbW9yZUNudDogcHJvcHMubW9yZUNudCwgYWxpZ25tZW50RWxSZWY6IHJvb3RFbFJlZiwgYWxpZ25HcmlkVG9wOiAhcHJvcHMuc2hvd0RheU51bWJlciwgZXh0cmFEYXRlU3BhbjogcHJvcHMuZXh0cmFEYXRlU3BhbiwgZGF0ZVByb2ZpbGU6IHByb3BzLmRhdGVQcm9maWxlLCBldmVudFNlbGVjdGlvbjogcHJvcHMuZXZlbnRTZWxlY3Rpb24sIGV2ZW50RHJhZzogcHJvcHMuZXZlbnREcmFnLCBldmVudFJlc2l6ZTogcHJvcHMuZXZlbnRSZXNpemUsIHRvZGF5UmFuZ2U6IHByb3BzLnRvZGF5UmFuZ2UgfSkpKSxcclxuICAgICAgICAgICAgICAgIHkoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtZGF5Z3JpZC1kYXktYmdcIiB9LCBwcm9wcy5iZ0NvbnRlbnQpKSkpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiByZW5kZXJUb3BJbm5lcihwcm9wcykge1xyXG4gICAgICAgIHJldHVybiBwcm9wcy5kYXlOdW1iZXJUZXh0IHx8IHkoXywgbnVsbCwgXCJcXHUwMEEwXCIpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gc2hvdWxkRGlzcGxheU1vbnRoU3RhcnQoZGF0ZSwgY3VycmVudFJhbmdlLCBkYXRlRW52KSB7XHJcbiAgICAgICAgY29uc3QgeyBzdGFydDogY3VycmVudFN0YXJ0LCBlbmQ6IGN1cnJlbnRFbmQgfSA9IGN1cnJlbnRSYW5nZTtcclxuICAgICAgICBjb25zdCBjdXJyZW50RW5kSW5jbCA9IGFkZE1zKGN1cnJlbnRFbmQsIC0xKTtcclxuICAgICAgICBjb25zdCBjdXJyZW50Rmlyc3RZZWFyID0gZGF0ZUVudi5nZXRZZWFyKGN1cnJlbnRTdGFydCk7XHJcbiAgICAgICAgY29uc3QgY3VycmVudEZpcnN0TW9udGggPSBkYXRlRW52LmdldE1vbnRoKGN1cnJlbnRTdGFydCk7XHJcbiAgICAgICAgY29uc3QgY3VycmVudExhc3RZZWFyID0gZGF0ZUVudi5nZXRZZWFyKGN1cnJlbnRFbmRJbmNsKTtcclxuICAgICAgICBjb25zdCBjdXJyZW50TGFzdE1vbnRoID0gZGF0ZUVudi5nZXRNb250aChjdXJyZW50RW5kSW5jbCk7XHJcbiAgICAgICAgLy8gc3BhbnMgbW9yZSB0aGFuIG9uZSBtb250aD9cclxuICAgICAgICByZXR1cm4gIShjdXJyZW50Rmlyc3RZZWFyID09PSBjdXJyZW50TGFzdFllYXIgJiYgY3VycmVudEZpcnN0TW9udGggPT09IGN1cnJlbnRMYXN0TW9udGgpICYmXHJcbiAgICAgICAgICAgIEJvb2xlYW4oXHJcbiAgICAgICAgICAgIC8vIGZpcnN0IGRhdGUgaW4gY3VycmVudCB2aWV3P1xyXG4gICAgICAgICAgICBkYXRlLnZhbHVlT2YoKSA9PT0gY3VycmVudFN0YXJ0LnZhbHVlT2YoKSB8fFxyXG4gICAgICAgICAgICAgICAgLy8gYSBtb250aC1zdGFydCB0aGF0J3Mgd2l0aGluIHRoZSBjdXJyZW50IHJhbmdlP1xyXG4gICAgICAgICAgICAgICAgKGRhdGVFbnYuZ2V0RGF5KGRhdGUpID09PSAxICYmIGRhdGUudmFsdWVPZigpIDwgY3VycmVudEVuZC52YWx1ZU9mKCkpKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjb21wdXRlRmdTZWdQbGFjZW1lbnQoc2VncywgLy8gYXNzdW1lZCBhbHJlYWR5IHNvcnRlZFxyXG4gICAgZGF5TWF4RXZlbnRzLCBkYXlNYXhFdmVudFJvd3MsIHN0cmljdE9yZGVyLCBldmVudEluc3RhbmNlSGVpZ2h0cywgbWF4Q29udGVudEhlaWdodCwgY2VsbHMpIHtcclxuICAgICAgICBsZXQgaGllcmFyY2h5ID0gbmV3IERheUdyaWRTZWdIaWVyYXJjaHkoKTtcclxuICAgICAgICBoaWVyYXJjaHkuYWxsb3dSZXNsaWNpbmcgPSB0cnVlO1xyXG4gICAgICAgIGhpZXJhcmNoeS5zdHJpY3RPcmRlciA9IHN0cmljdE9yZGVyO1xyXG4gICAgICAgIGlmIChkYXlNYXhFdmVudHMgPT09IHRydWUgfHwgZGF5TWF4RXZlbnRSb3dzID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgIGhpZXJhcmNoeS5tYXhDb29yZCA9IG1heENvbnRlbnRIZWlnaHQ7XHJcbiAgICAgICAgICAgIGhpZXJhcmNoeS5oaWRkZW5Db25zdW1lcyA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBkYXlNYXhFdmVudHMgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgIGhpZXJhcmNoeS5tYXhTdGFja0NudCA9IGRheU1heEV2ZW50cztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGRheU1heEV2ZW50Um93cyA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgaGllcmFyY2h5Lm1heFN0YWNrQ250ID0gZGF5TWF4RXZlbnRSb3dzO1xyXG4gICAgICAgICAgICBoaWVyYXJjaHkuaGlkZGVuQ29uc3VtZXMgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBjcmVhdGUgc2VnSW5wdXRzIG9ubHkgZm9yIHNlZ3Mgd2l0aCBrbm93biBoZWlnaHRzXHJcbiAgICAgICAgbGV0IHNlZ0lucHV0cyA9IFtdO1xyXG4gICAgICAgIGxldCB1bmtub3duSGVpZ2h0U2VncyA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2Vncy5sZW5ndGg7IGkgKz0gMSkge1xyXG4gICAgICAgICAgICBsZXQgc2VnID0gc2Vnc1tpXTtcclxuICAgICAgICAgICAgbGV0IHsgaW5zdGFuY2VJZCB9ID0gc2VnLmV2ZW50UmFuZ2UuaW5zdGFuY2U7XHJcbiAgICAgICAgICAgIGxldCBldmVudEhlaWdodCA9IGV2ZW50SW5zdGFuY2VIZWlnaHRzW2luc3RhbmNlSWRdO1xyXG4gICAgICAgICAgICBpZiAoZXZlbnRIZWlnaHQgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgc2VnSW5wdXRzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiBpLFxyXG4gICAgICAgICAgICAgICAgICAgIHRoaWNrbmVzczogZXZlbnRIZWlnaHQsXHJcbiAgICAgICAgICAgICAgICAgICAgc3Bhbjoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogc2VnLmZpcnN0Q29sLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IHNlZy5sYXN0Q29sICsgMSxcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB1bmtub3duSGVpZ2h0U2Vncy5wdXNoKHNlZyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGhpZGRlbkVudHJpZXMgPSBoaWVyYXJjaHkuYWRkU2VncyhzZWdJbnB1dHMpO1xyXG4gICAgICAgIGxldCBzZWdSZWN0cyA9IGhpZXJhcmNoeS50b1JlY3RzKCk7XHJcbiAgICAgICAgbGV0IHsgc2luZ2xlQ29sUGxhY2VtZW50cywgbXVsdGlDb2xQbGFjZW1lbnRzLCBsZWZ0b3Zlck1hcmdpbnMgfSA9IHBsYWNlUmVjdHMoc2VnUmVjdHMsIHNlZ3MsIGNlbGxzKTtcclxuICAgICAgICBsZXQgbW9yZUNudHMgPSBbXTtcclxuICAgICAgICBsZXQgbW9yZU1hcmdpblRvcHMgPSBbXTtcclxuICAgICAgICAvLyBhZGQgc2VncyB3aXRoIHVua25vd24gaGVpZ2h0c1xyXG4gICAgICAgIGZvciAobGV0IHNlZyBvZiB1bmtub3duSGVpZ2h0U2Vncykge1xyXG4gICAgICAgICAgICBtdWx0aUNvbFBsYWNlbWVudHNbc2VnLmZpcnN0Q29sXS5wdXNoKHtcclxuICAgICAgICAgICAgICAgIHNlZyxcclxuICAgICAgICAgICAgICAgIGlzVmlzaWJsZTogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBpc0Fic29sdXRlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgYWJzb2x1dGVUb3A6IDAsXHJcbiAgICAgICAgICAgICAgICBtYXJnaW5Ub3A6IDAsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBjb2wgPSBzZWcuZmlyc3RDb2w7IGNvbCA8PSBzZWcubGFzdENvbDsgY29sICs9IDEpIHtcclxuICAgICAgICAgICAgICAgIHNpbmdsZUNvbFBsYWNlbWVudHNbY29sXS5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICBzZWc6IHJlc2xpY2VTZWcoc2VnLCBjb2wsIGNvbCArIDEsIGNlbGxzKSxcclxuICAgICAgICAgICAgICAgICAgICBpc1Zpc2libGU6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgIGlzQWJzb2x1dGU6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgIGFic29sdXRlVG9wOiAwLFxyXG4gICAgICAgICAgICAgICAgICAgIG1hcmdpblRvcDogMCxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGFkZCB0aGUgaGlkZGVuIGVudHJpZXNcclxuICAgICAgICBmb3IgKGxldCBjb2wgPSAwOyBjb2wgPCBjZWxscy5sZW5ndGg7IGNvbCArPSAxKSB7XHJcbiAgICAgICAgICAgIG1vcmVDbnRzLnB1c2goMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAobGV0IGhpZGRlbkVudHJ5IG9mIGhpZGRlbkVudHJpZXMpIHtcclxuICAgICAgICAgICAgbGV0IHNlZyA9IHNlZ3NbaGlkZGVuRW50cnkuaW5kZXhdO1xyXG4gICAgICAgICAgICBsZXQgaGlkZGVuU3BhbiA9IGhpZGRlbkVudHJ5LnNwYW47XHJcbiAgICAgICAgICAgIG11bHRpQ29sUGxhY2VtZW50c1toaWRkZW5TcGFuLnN0YXJ0XS5wdXNoKHtcclxuICAgICAgICAgICAgICAgIHNlZzogcmVzbGljZVNlZyhzZWcsIGhpZGRlblNwYW4uc3RhcnQsIGhpZGRlblNwYW4uZW5kLCBjZWxscyksXHJcbiAgICAgICAgICAgICAgICBpc1Zpc2libGU6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgaXNBYnNvbHV0ZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGFic29sdXRlVG9wOiAwLFxyXG4gICAgICAgICAgICAgICAgbWFyZ2luVG9wOiAwLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgZm9yIChsZXQgY29sID0gaGlkZGVuU3Bhbi5zdGFydDsgY29sIDwgaGlkZGVuU3Bhbi5lbmQ7IGNvbCArPSAxKSB7XHJcbiAgICAgICAgICAgICAgICBtb3JlQ250c1tjb2xdICs9IDE7XHJcbiAgICAgICAgICAgICAgICBzaW5nbGVDb2xQbGFjZW1lbnRzW2NvbF0ucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VnOiByZXNsaWNlU2VnKHNlZywgY29sLCBjb2wgKyAxLCBjZWxscyksXHJcbiAgICAgICAgICAgICAgICAgICAgaXNWaXNpYmxlOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICBpc0Fic29sdXRlOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICBhYnNvbHV0ZVRvcDogMCxcclxuICAgICAgICAgICAgICAgICAgICBtYXJnaW5Ub3A6IDAsXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBkZWFsIHdpdGggbGVmdG92ZXIgbWFyZ2luc1xyXG4gICAgICAgIGZvciAobGV0IGNvbCA9IDA7IGNvbCA8IGNlbGxzLmxlbmd0aDsgY29sICs9IDEpIHtcclxuICAgICAgICAgICAgbW9yZU1hcmdpblRvcHMucHVzaChsZWZ0b3Zlck1hcmdpbnNbY29sXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7IHNpbmdsZUNvbFBsYWNlbWVudHMsIG11bHRpQ29sUGxhY2VtZW50cywgbW9yZUNudHMsIG1vcmVNYXJnaW5Ub3BzIH07XHJcbiAgICB9XHJcbiAgICAvLyByZWN0cyBvcmRlcmVkIGJ5IHRvcCBjb29yZCwgdGhlbiBsZWZ0XHJcbiAgICBmdW5jdGlvbiBwbGFjZVJlY3RzKGFsbFJlY3RzLCBzZWdzLCBjZWxscykge1xyXG4gICAgICAgIGxldCByZWN0c0J5RWFjaENvbCA9IGdyb3VwUmVjdHNCeUVhY2hDb2woYWxsUmVjdHMsIGNlbGxzLmxlbmd0aCk7XHJcbiAgICAgICAgbGV0IHNpbmdsZUNvbFBsYWNlbWVudHMgPSBbXTtcclxuICAgICAgICBsZXQgbXVsdGlDb2xQbGFjZW1lbnRzID0gW107XHJcbiAgICAgICAgbGV0IGxlZnRvdmVyTWFyZ2lucyA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IGNvbCA9IDA7IGNvbCA8IGNlbGxzLmxlbmd0aDsgY29sICs9IDEpIHtcclxuICAgICAgICAgICAgbGV0IHJlY3RzID0gcmVjdHNCeUVhY2hDb2xbY29sXTtcclxuICAgICAgICAgICAgLy8gY29tcHV0ZSBhbGwgc3RhdGljIHNlZ3MgaW4gc2luZ2xlUGxhY2VtZW50c1xyXG4gICAgICAgICAgICBsZXQgc2luZ2xlUGxhY2VtZW50cyA9IFtdO1xyXG4gICAgICAgICAgICBsZXQgY3VycmVudEhlaWdodCA9IDA7XHJcbiAgICAgICAgICAgIGxldCBjdXJyZW50TWFyZ2luVG9wID0gMDtcclxuICAgICAgICAgICAgZm9yIChsZXQgcmVjdCBvZiByZWN0cykge1xyXG4gICAgICAgICAgICAgICAgbGV0IHNlZyA9IHNlZ3NbcmVjdC5pbmRleF07XHJcbiAgICAgICAgICAgICAgICBzaW5nbGVQbGFjZW1lbnRzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgIHNlZzogcmVzbGljZVNlZyhzZWcsIGNvbCwgY29sICsgMSwgY2VsbHMpLFxyXG4gICAgICAgICAgICAgICAgICAgIGlzVmlzaWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICBpc0Fic29sdXRlOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICBhYnNvbHV0ZVRvcDogcmVjdC5sZXZlbENvb3JkLFxyXG4gICAgICAgICAgICAgICAgICAgIG1hcmdpblRvcDogcmVjdC5sZXZlbENvb3JkIC0gY3VycmVudEhlaWdodCxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgY3VycmVudEhlaWdodCA9IHJlY3QubGV2ZWxDb29yZCArIHJlY3QudGhpY2tuZXNzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGNvbXB1dGUgbWl4ZWQgc3RhdGljL2Fic29sdXRlIHNlZ3MgaW4gbXVsdGlQbGFjZW1lbnRzXHJcbiAgICAgICAgICAgIGxldCBtdWx0aVBsYWNlbWVudHMgPSBbXTtcclxuICAgICAgICAgICAgY3VycmVudEhlaWdodCA9IDA7XHJcbiAgICAgICAgICAgIGN1cnJlbnRNYXJnaW5Ub3AgPSAwO1xyXG4gICAgICAgICAgICBmb3IgKGxldCByZWN0IG9mIHJlY3RzKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgc2VnID0gc2Vnc1tyZWN0LmluZGV4XTtcclxuICAgICAgICAgICAgICAgIGxldCBpc0Fic29sdXRlID0gcmVjdC5zcGFuLmVuZCAtIHJlY3Quc3Bhbi5zdGFydCA+IDE7IC8vIG11bHRpLWNvbHVtbj9cclxuICAgICAgICAgICAgICAgIGxldCBpc0ZpcnN0Q29sID0gcmVjdC5zcGFuLnN0YXJ0ID09PSBjb2w7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50TWFyZ2luVG9wICs9IHJlY3QubGV2ZWxDb29yZCAtIGN1cnJlbnRIZWlnaHQ7IC8vIGFtb3VudCBvZiBzcGFjZSBzaW5jZSBib3R0b20gb2YgcHJldmlvdXMgc2VnXHJcbiAgICAgICAgICAgICAgICBjdXJyZW50SGVpZ2h0ID0gcmVjdC5sZXZlbENvb3JkICsgcmVjdC50aGlja25lc3M7IC8vIGhlaWdodCB3aWxsIG5vdyBiZSBib3R0b20gb2YgY3VycmVudCBzZWdcclxuICAgICAgICAgICAgICAgIGlmIChpc0Fic29sdXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudE1hcmdpblRvcCArPSByZWN0LnRoaWNrbmVzcztcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNGaXJzdENvbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtdWx0aVBsYWNlbWVudHMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWc6IHJlc2xpY2VTZWcoc2VnLCByZWN0LnNwYW4uc3RhcnQsIHJlY3Quc3Bhbi5lbmQsIGNlbGxzKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzVmlzaWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzQWJzb2x1dGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhYnNvbHV0ZVRvcDogcmVjdC5sZXZlbENvb3JkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFyZ2luVG9wOiAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc0ZpcnN0Q29sKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbXVsdGlQbGFjZW1lbnRzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWc6IHJlc2xpY2VTZWcoc2VnLCByZWN0LnNwYW4uc3RhcnQsIHJlY3Quc3Bhbi5lbmQsIGNlbGxzKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXNWaXNpYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0Fic29sdXRlOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWJzb2x1dGVUb3A6IHJlY3QubGV2ZWxDb29yZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWFyZ2luVG9wOiBjdXJyZW50TWFyZ2luVG9wLCAvLyBjbGFpbSB0aGUgbWFyZ2luXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudE1hcmdpblRvcCA9IDA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc2luZ2xlQ29sUGxhY2VtZW50cy5wdXNoKHNpbmdsZVBsYWNlbWVudHMpO1xyXG4gICAgICAgICAgICBtdWx0aUNvbFBsYWNlbWVudHMucHVzaChtdWx0aVBsYWNlbWVudHMpO1xyXG4gICAgICAgICAgICBsZWZ0b3Zlck1hcmdpbnMucHVzaChjdXJyZW50TWFyZ2luVG9wKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHsgc2luZ2xlQ29sUGxhY2VtZW50cywgbXVsdGlDb2xQbGFjZW1lbnRzLCBsZWZ0b3Zlck1hcmdpbnMgfTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGdyb3VwUmVjdHNCeUVhY2hDb2wocmVjdHMsIGNvbENudCkge1xyXG4gICAgICAgIGxldCByZWN0c0J5RWFjaENvbCA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IGNvbCA9IDA7IGNvbCA8IGNvbENudDsgY29sICs9IDEpIHtcclxuICAgICAgICAgICAgcmVjdHNCeUVhY2hDb2wucHVzaChbXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAobGV0IHJlY3Qgb2YgcmVjdHMpIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgY29sID0gcmVjdC5zcGFuLnN0YXJ0OyBjb2wgPCByZWN0LnNwYW4uZW5kOyBjb2wgKz0gMSkge1xyXG4gICAgICAgICAgICAgICAgcmVjdHNCeUVhY2hDb2xbY29sXS5wdXNoKHJlY3QpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZWN0c0J5RWFjaENvbDtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHJlc2xpY2VTZWcoc2VnLCBzcGFuU3RhcnQsIHNwYW5FbmQsIGNlbGxzKSB7XHJcbiAgICAgICAgaWYgKHNlZy5maXJzdENvbCA9PT0gc3BhblN0YXJ0ICYmIHNlZy5sYXN0Q29sID09PSBzcGFuRW5kIC0gMSkge1xyXG4gICAgICAgICAgICByZXR1cm4gc2VnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgZXZlbnRSYW5nZSA9IHNlZy5ldmVudFJhbmdlO1xyXG4gICAgICAgIGxldCBvcmlnUmFuZ2UgPSBldmVudFJhbmdlLnJhbmdlO1xyXG4gICAgICAgIGxldCBzbGljZWRSYW5nZSA9IGludGVyc2VjdFJhbmdlcyhvcmlnUmFuZ2UsIHtcclxuICAgICAgICAgICAgc3RhcnQ6IGNlbGxzW3NwYW5TdGFydF0uZGF0ZSxcclxuICAgICAgICAgICAgZW5kOiBhZGREYXlzKGNlbGxzW3NwYW5FbmQgLSAxXS5kYXRlLCAxKSxcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzZWcpLCB7IGZpcnN0Q29sOiBzcGFuU3RhcnQsIGxhc3RDb2w6IHNwYW5FbmQgLSAxLCBldmVudFJhbmdlOiB7XHJcbiAgICAgICAgICAgICAgICBkZWY6IGV2ZW50UmFuZ2UuZGVmLFxyXG4gICAgICAgICAgICAgICAgdWk6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZXZlbnRSYW5nZS51aSksIHsgZHVyYXRpb25FZGl0YWJsZTogZmFsc2UgfSksXHJcbiAgICAgICAgICAgICAgICBpbnN0YW5jZTogZXZlbnRSYW5nZS5pbnN0YW5jZSxcclxuICAgICAgICAgICAgICAgIHJhbmdlOiBzbGljZWRSYW5nZSxcclxuICAgICAgICAgICAgfSwgaXNTdGFydDogc2VnLmlzU3RhcnQgJiYgc2xpY2VkUmFuZ2Uuc3RhcnQudmFsdWVPZigpID09PSBvcmlnUmFuZ2Uuc3RhcnQudmFsdWVPZigpLCBpc0VuZDogc2VnLmlzRW5kICYmIHNsaWNlZFJhbmdlLmVuZC52YWx1ZU9mKCkgPT09IG9yaWdSYW5nZS5lbmQudmFsdWVPZigpIH0pO1xyXG4gICAgfVxyXG4gICAgY2xhc3MgRGF5R3JpZFNlZ0hpZXJhcmNoeSBleHRlbmRzIFNlZ0hpZXJhcmNoeSB7XHJcbiAgICAgICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgIC8vIGNvbmZpZ1xyXG4gICAgICAgICAgICB0aGlzLmhpZGRlbkNvbnN1bWVzID0gZmFsc2U7XHJcbiAgICAgICAgICAgIC8vIGFsbG93cyB1cyB0byBrZWVwIGhpZGRlbiBlbnRyaWVzIGluIHRoZSBoaWVyYXJjaHkgc28gdGhleSB0YWtlIHVwIHNwYWNlXHJcbiAgICAgICAgICAgIHRoaXMuZm9yY2VIaWRkZW4gPSB7fTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYWRkU2VncyhzZWdJbnB1dHMpIHtcclxuICAgICAgICAgICAgY29uc3QgaGlkZGVuU2VncyA9IHN1cGVyLmFkZFNlZ3Moc2VnSW5wdXRzKTtcclxuICAgICAgICAgICAgY29uc3QgeyBlbnRyaWVzQnlMZXZlbCB9ID0gdGhpcztcclxuICAgICAgICAgICAgY29uc3QgZXhjbHVkZUhpZGRlbiA9IChlbnRyeSkgPT4gIXRoaXMuZm9yY2VIaWRkZW5bYnVpbGRFbnRyeUtleShlbnRyeSldO1xyXG4gICAgICAgICAgICAvLyByZW1vdmUgdGhlIGZvcmNlZC1oaWRkZW4gc2Vnc1xyXG4gICAgICAgICAgICBmb3IgKGxldCBsZXZlbCA9IDA7IGxldmVsIDwgZW50cmllc0J5TGV2ZWwubGVuZ3RoOyBsZXZlbCArPSAxKSB7XHJcbiAgICAgICAgICAgICAgICBlbnRyaWVzQnlMZXZlbFtsZXZlbF0gPSBlbnRyaWVzQnlMZXZlbFtsZXZlbF0uZmlsdGVyKGV4Y2x1ZGVIaWRkZW4pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBoaWRkZW5TZWdzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBoYW5kbGVJbnZhbGlkSW5zZXJ0aW9uKGluc2VydGlvbiwgZW50cnksIGhpZGRlbkVudHJpZXMpIHtcclxuICAgICAgICAgICAgY29uc3QgeyBlbnRyaWVzQnlMZXZlbCwgZm9yY2VIaWRkZW4gfSA9IHRoaXM7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgdG91Y2hpbmdFbnRyeSwgdG91Y2hpbmdMZXZlbCwgdG91Y2hpbmdMYXRlcmFsIH0gPSBpbnNlcnRpb247XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmhpZGRlbkNvbnN1bWVzICYmIHRvdWNoaW5nRW50cnkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRvdWNoaW5nRW50cnlJZCA9IGJ1aWxkRW50cnlLZXkodG91Y2hpbmdFbnRyeSk7XHJcbiAgICAgICAgICAgICAgICAvLyBpZiBub3QgYWxyZWFkeSBoaWRkZW5cclxuICAgICAgICAgICAgICAgIGlmICghZm9yY2VIaWRkZW5bdG91Y2hpbmdFbnRyeUlkXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmFsbG93UmVzbGljaW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBsYWNlaG9sZGVyRW50cnkgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRvdWNoaW5nRW50cnkpLCB7IHNwYW46IGludGVyc2VjdFNwYW5zKHRvdWNoaW5nRW50cnkuc3BhbiwgZW50cnkuc3BhbikgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBsYWNlaG9sZGVyRW50cnlJZCA9IGJ1aWxkRW50cnlLZXkocGxhY2Vob2xkZXJFbnRyeSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcmNlSGlkZGVuW3BsYWNlaG9sZGVyRW50cnlJZF0gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbnRyaWVzQnlMZXZlbFt0b3VjaGluZ0xldmVsXVt0b3VjaGluZ0xhdGVyYWxdID0gcGxhY2Vob2xkZXJFbnRyeTsgLy8gcmVwbGFjZSB0b3VjaGluZ0VudHJ5IHdpdGggb3VyIHBsYWNlaG9sZGVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3BsaXRFbnRyeSh0b3VjaGluZ0VudHJ5LCBlbnRyeSwgaGlkZGVuRW50cmllcyk7IC8vIHNwbGl0IHVwIHRoZSB0b3VjaGluZ0VudHJ5LCByZWluc2VydCBpdFxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yY2VIaWRkZW5bdG91Y2hpbmdFbnRyeUlkXSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhpZGRlbkVudHJpZXMucHVzaCh0b3VjaGluZ0VudHJ5KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHN1cGVyLmhhbmRsZUludmFsaWRJbnNlcnRpb24oaW5zZXJ0aW9uLCBlbnRyeSwgaGlkZGVuRW50cmllcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNsYXNzIFRhYmxlUm93IGV4dGVuZHMgRGF0ZUNvbXBvbmVudCB7XHJcbiAgICAgICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgIHRoaXMuY2VsbEVsUmVmcyA9IG5ldyBSZWZNYXAoKTsgLy8gdGhlIDx0ZD5cclxuICAgICAgICAgICAgdGhpcy5mcmFtZUVsUmVmcyA9IG5ldyBSZWZNYXAoKTsgLy8gdGhlIGZjLWRheWdyaWQtZGF5LWZyYW1lXHJcbiAgICAgICAgICAgIHRoaXMuZmdFbFJlZnMgPSBuZXcgUmVmTWFwKCk7IC8vIHRoZSBmYy1kYXlncmlkLWRheS1ldmVudHNcclxuICAgICAgICAgICAgdGhpcy5zZWdIYXJuZXNzUmVmcyA9IG5ldyBSZWZNYXAoKTsgLy8gaW5kZXhlZCBieSBcImluc3RhbmNlSWQ6Zmlyc3RDb2xcIlxyXG4gICAgICAgICAgICB0aGlzLnJvb3RFbFJlZiA9IGQoKTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IHtcclxuICAgICAgICAgICAgICAgIGZyYW1lUG9zaXRpb25zOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgbWF4Q29udGVudEhlaWdodDogbnVsbCxcclxuICAgICAgICAgICAgICAgIGV2ZW50SW5zdGFuY2VIZWlnaHRzOiB7fSxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdGhpcy5oYW5kbGVSZXNpemUgPSAoaXNGb3JjZWQpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChpc0ZvcmNlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlU2l6aW5nKHRydWUpOyAvLyBpc0V4dGVybmFsPXRydWVcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVuZGVyKCkge1xyXG4gICAgICAgICAgICBsZXQgeyBwcm9wcywgc3RhdGUsIGNvbnRleHQgfSA9IHRoaXM7XHJcbiAgICAgICAgICAgIGxldCB7IG9wdGlvbnMgfSA9IGNvbnRleHQ7XHJcbiAgICAgICAgICAgIGxldCBjb2xDbnQgPSBwcm9wcy5jZWxscy5sZW5ndGg7XHJcbiAgICAgICAgICAgIGxldCBidXNpbmVzc0hvdXJzQnlDb2wgPSBzcGxpdFNlZ3NCeUZpcnN0Q29sKHByb3BzLmJ1c2luZXNzSG91clNlZ3MsIGNvbENudCk7XHJcbiAgICAgICAgICAgIGxldCBiZ0V2ZW50U2Vnc0J5Q29sID0gc3BsaXRTZWdzQnlGaXJzdENvbChwcm9wcy5iZ0V2ZW50U2VncywgY29sQ250KTtcclxuICAgICAgICAgICAgbGV0IGhpZ2hsaWdodFNlZ3NCeUNvbCA9IHNwbGl0U2Vnc0J5Rmlyc3RDb2wodGhpcy5nZXRIaWdobGlnaHRTZWdzKCksIGNvbENudCk7XHJcbiAgICAgICAgICAgIGxldCBtaXJyb3JTZWdzQnlDb2wgPSBzcGxpdFNlZ3NCeUZpcnN0Q29sKHRoaXMuZ2V0TWlycm9yU2VncygpLCBjb2xDbnQpO1xyXG4gICAgICAgICAgICBsZXQgeyBzaW5nbGVDb2xQbGFjZW1lbnRzLCBtdWx0aUNvbFBsYWNlbWVudHMsIG1vcmVDbnRzLCBtb3JlTWFyZ2luVG9wcyB9ID0gY29tcHV0ZUZnU2VnUGxhY2VtZW50KHNvcnRFdmVudFNlZ3MocHJvcHMuZmdFdmVudFNlZ3MsIG9wdGlvbnMuZXZlbnRPcmRlciksIHByb3BzLmRheU1heEV2ZW50cywgcHJvcHMuZGF5TWF4RXZlbnRSb3dzLCBvcHRpb25zLmV2ZW50T3JkZXJTdHJpY3QsIHN0YXRlLmV2ZW50SW5zdGFuY2VIZWlnaHRzLCBzdGF0ZS5tYXhDb250ZW50SGVpZ2h0LCBwcm9wcy5jZWxscyk7XHJcbiAgICAgICAgICAgIGxldCBpc0ZvcmNlZEludmlzaWJsZSA9IC8vIFRPRE86IG1lc3N5IHdheSB0byBjb21wdXRlIHRoaXNcclxuICAgICAgICAgICAgIChwcm9wcy5ldmVudERyYWcgJiYgcHJvcHMuZXZlbnREcmFnLmFmZmVjdGVkSW5zdGFuY2VzKSB8fFxyXG4gICAgICAgICAgICAgICAgKHByb3BzLmV2ZW50UmVzaXplICYmIHByb3BzLmV2ZW50UmVzaXplLmFmZmVjdGVkSW5zdGFuY2VzKSB8fFxyXG4gICAgICAgICAgICAgICAge307XHJcbiAgICAgICAgICAgIHJldHVybiAoeShcInRyXCIsIHsgcmVmOiB0aGlzLnJvb3RFbFJlZiwgcm9sZTogXCJyb3dcIiB9LFxyXG4gICAgICAgICAgICAgICAgcHJvcHMucmVuZGVySW50cm8gJiYgcHJvcHMucmVuZGVySW50cm8oKSxcclxuICAgICAgICAgICAgICAgIHByb3BzLmNlbGxzLm1hcCgoY2VsbCwgY29sKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5vcm1hbEZnTm9kZXMgPSB0aGlzLnJlbmRlckZnU2Vncyhjb2wsIHByb3BzLmZvclByaW50ID8gc2luZ2xlQ29sUGxhY2VtZW50c1tjb2xdIDogbXVsdGlDb2xQbGFjZW1lbnRzW2NvbF0sIHByb3BzLnRvZGF5UmFuZ2UsIGlzRm9yY2VkSW52aXNpYmxlKTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgbWlycm9yRmdOb2RlcyA9IHRoaXMucmVuZGVyRmdTZWdzKGNvbCwgYnVpbGRNaXJyb3JQbGFjZW1lbnRzKG1pcnJvclNlZ3NCeUNvbFtjb2xdLCBtdWx0aUNvbFBsYWNlbWVudHMpLCBwcm9wcy50b2RheVJhbmdlLCB7fSwgQm9vbGVhbihwcm9wcy5ldmVudERyYWcpLCBCb29sZWFuKHByb3BzLmV2ZW50UmVzaXplKSwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoeShUYWJsZUNlbGwsIHsga2V5OiBjZWxsLmtleSwgZWxSZWY6IHRoaXMuY2VsbEVsUmVmcy5jcmVhdGVSZWYoY2VsbC5rZXkpLCBpbm5lckVsUmVmOiB0aGlzLmZyYW1lRWxSZWZzLmNyZWF0ZVJlZihjZWxsLmtleSkgLyogRkYgPHRkPiBwcm9ibGVtLCBidXQgb2theSB0byB1c2UgZm9yIGxlZnQvcmlnaHQuIFRPRE86IHJlbmFtZSBwcm9wICovLCBkYXRlUHJvZmlsZTogcHJvcHMuZGF0ZVByb2ZpbGUsIGRhdGU6IGNlbGwuZGF0ZSwgc2hvd0RheU51bWJlcjogcHJvcHMuc2hvd0RheU51bWJlcnMsIHNob3dXZWVrTnVtYmVyOiBwcm9wcy5zaG93V2Vla051bWJlcnMgJiYgY29sID09PSAwLCBmb3JjZURheVRvcDogcHJvcHMuc2hvd1dlZWtOdW1iZXJzIC8qIGV2ZW4gZGlzcGxheWluZyB3ZWVrbnVtIGZvciByb3csIG5vdCBuZWNlc3NhcmlseSBkYXkgKi8sIHRvZGF5UmFuZ2U6IHByb3BzLnRvZGF5UmFuZ2UsIGV2ZW50U2VsZWN0aW9uOiBwcm9wcy5ldmVudFNlbGVjdGlvbiwgZXZlbnREcmFnOiBwcm9wcy5ldmVudERyYWcsIGV2ZW50UmVzaXplOiBwcm9wcy5ldmVudFJlc2l6ZSwgZXh0cmFSZW5kZXJQcm9wczogY2VsbC5leHRyYVJlbmRlclByb3BzLCBleHRyYURhdGFBdHRyczogY2VsbC5leHRyYURhdGFBdHRycywgZXh0cmFDbGFzc05hbWVzOiBjZWxsLmV4dHJhQ2xhc3NOYW1lcywgZXh0cmFEYXRlU3BhbjogY2VsbC5leHRyYURhdGVTcGFuLCBtb3JlQ250OiBtb3JlQ250c1tjb2xdLCBtb3JlTWFyZ2luVG9wOiBtb3JlTWFyZ2luVG9wc1tjb2xdLCBzaW5nbGVQbGFjZW1lbnRzOiBzaW5nbGVDb2xQbGFjZW1lbnRzW2NvbF0sIGZnQ29udGVudEVsUmVmOiB0aGlzLmZnRWxSZWZzLmNyZWF0ZVJlZihjZWxsLmtleSksIGZnQ29udGVudDogKCAvLyBGcmFnbWVudCBzY29wZXMgdGhlIGtleXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgeShfLCBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeShfLCBudWxsLCBub3JtYWxGZ05vZGVzKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkoXywgbnVsbCwgbWlycm9yRmdOb2RlcykpKSwgYmdDb250ZW50OiAoIC8vIEZyYWdtZW50IHNjb3BlcyB0aGUga2V5c1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB5KF8sIG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlckZpbGxTZWdzKGhpZ2hsaWdodFNlZ3NCeUNvbFtjb2xdLCAnaGlnaGxpZ2h0JyksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlckZpbGxTZWdzKGJ1c2luZXNzSG91cnNCeUNvbFtjb2xdLCAnbm9uLWJ1c2luZXNzJyksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlckZpbGxTZWdzKGJnRXZlbnRTZWdzQnlDb2xbY29sXSwgJ2JnLWV2ZW50JykpKSwgbWluSGVpZ2h0OiBwcm9wcy5jZWxsTWluSGVpZ2h0IH0pKTtcclxuICAgICAgICAgICAgICAgIH0pKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVNpemluZyh0cnVlKTtcclxuICAgICAgICAgICAgdGhpcy5jb250ZXh0LmFkZFJlc2l6ZUhhbmRsZXIodGhpcy5oYW5kbGVSZXNpemUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzLCBwcmV2U3RhdGUpIHtcclxuICAgICAgICAgICAgbGV0IGN1cnJlbnRQcm9wcyA9IHRoaXMucHJvcHM7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlU2l6aW5nKCFpc1Byb3BzRXF1YWwocHJldlByb3BzLCBjdXJyZW50UHJvcHMpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5yZW1vdmVSZXNpemVIYW5kbGVyKHRoaXMuaGFuZGxlUmVzaXplKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZ2V0SGlnaGxpZ2h0U2VncygpIHtcclxuICAgICAgICAgICAgbGV0IHsgcHJvcHMgfSA9IHRoaXM7XHJcbiAgICAgICAgICAgIGlmIChwcm9wcy5ldmVudERyYWcgJiYgcHJvcHMuZXZlbnREcmFnLnNlZ3MubGVuZ3RoKSB7IC8vIG1lc3N5IGNoZWNrXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvcHMuZXZlbnREcmFnLnNlZ3M7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHByb3BzLmV2ZW50UmVzaXplICYmIHByb3BzLmV2ZW50UmVzaXplLnNlZ3MubGVuZ3RoKSB7IC8vIG1lc3N5IGNoZWNrXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvcHMuZXZlbnRSZXNpemUuc2VncztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcHJvcHMuZGF0ZVNlbGVjdGlvblNlZ3M7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGdldE1pcnJvclNlZ3MoKSB7XHJcbiAgICAgICAgICAgIGxldCB7IHByb3BzIH0gPSB0aGlzO1xyXG4gICAgICAgICAgICBpZiAocHJvcHMuZXZlbnRSZXNpemUgJiYgcHJvcHMuZXZlbnRSZXNpemUuc2Vncy5sZW5ndGgpIHsgLy8gbWVzc3kgY2hlY2tcclxuICAgICAgICAgICAgICAgIHJldHVybiBwcm9wcy5ldmVudFJlc2l6ZS5zZWdzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVuZGVyRmdTZWdzKGNvbCwgc2VnUGxhY2VtZW50cywgdG9kYXlSYW5nZSwgaXNGb3JjZWRJbnZpc2libGUsIGlzRHJhZ2dpbmcsIGlzUmVzaXppbmcsIGlzRGF0ZVNlbGVjdGluZykge1xyXG4gICAgICAgICAgICBsZXQgeyBjb250ZXh0IH0gPSB0aGlzO1xyXG4gICAgICAgICAgICBsZXQgeyBldmVudFNlbGVjdGlvbiB9ID0gdGhpcy5wcm9wcztcclxuICAgICAgICAgICAgbGV0IHsgZnJhbWVQb3NpdGlvbnMgfSA9IHRoaXMuc3RhdGU7XHJcbiAgICAgICAgICAgIGxldCBkZWZhdWx0RGlzcGxheUV2ZW50RW5kID0gdGhpcy5wcm9wcy5jZWxscy5sZW5ndGggPT09IDE7IC8vIGNvbENudCA9PT0gMVxyXG4gICAgICAgICAgICBsZXQgaXNNaXJyb3IgPSBpc0RyYWdnaW5nIHx8IGlzUmVzaXppbmcgfHwgaXNEYXRlU2VsZWN0aW5nO1xyXG4gICAgICAgICAgICBsZXQgbm9kZXMgPSBbXTtcclxuICAgICAgICAgICAgaWYgKGZyYW1lUG9zaXRpb25zKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBwbGFjZW1lbnQgb2Ygc2VnUGxhY2VtZW50cykge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCB7IHNlZyB9ID0gcGxhY2VtZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCB7IGluc3RhbmNlSWQgfSA9IHNlZy5ldmVudFJhbmdlLmluc3RhbmNlO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBrZXkgPSBpbnN0YW5jZUlkICsgJzonICsgY29sO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBpc1Zpc2libGUgPSBwbGFjZW1lbnQuaXNWaXNpYmxlICYmICFpc0ZvcmNlZEludmlzaWJsZVtpbnN0YW5jZUlkXTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgaXNBYnNvbHV0ZSA9IHBsYWNlbWVudC5pc0Fic29sdXRlO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBsZWZ0ID0gJyc7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJpZ2h0ID0gJyc7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzQWJzb2x1dGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRleHQuaXNSdGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBmcmFtZVBvc2l0aW9ucy5sZWZ0c1tzZWcubGFzdENvbF0gLSBmcmFtZVBvc2l0aW9ucy5sZWZ0c1tzZWcuZmlyc3RDb2xdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByaWdodCA9IGZyYW1lUG9zaXRpb25zLnJpZ2h0c1tzZWcuZmlyc3RDb2xdIC0gZnJhbWVQb3NpdGlvbnMucmlnaHRzW3NlZy5sYXN0Q29sXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvKlxyXG4gICAgICAgICAgICAgICAgICAgIGtub3duIGJ1ZzogZXZlbnRzIHRoYXQgYXJlIGZvcmNlIHRvIGJlIGxpc3QtaXRlbSBidXQgc3BhbiBtdWx0aXBsZSBkYXlzIHN0aWxsIHRha2UgdXAgc3BhY2UgaW4gbGF0ZXIgY29sdW1uc1xyXG4gICAgICAgICAgICAgICAgICAgIHRvZG86IGluIHByaW50IHZpZXcsIGZvciBtdWx0aS1kYXkgZXZlbnRzLCBkb24ndCBkaXNwbGF5IHRpdGxlIHdpdGhpbiBub24tc3RhcnQvZW5kIHNlZ3NcclxuICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgIG5vZGVzLnB1c2goeShcImRpdlwiLCB7IGNsYXNzTmFtZTogJ2ZjLWRheWdyaWQtZXZlbnQtaGFybmVzcycgKyAoaXNBYnNvbHV0ZSA/ICcgZmMtZGF5Z3JpZC1ldmVudC1oYXJuZXNzLWFicycgOiAnJyksIGtleToga2V5LCByZWY6IGlzTWlycm9yID8gbnVsbCA6IHRoaXMuc2VnSGFybmVzc1JlZnMuY3JlYXRlUmVmKGtleSksIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aXNpYmlsaXR5OiBpc1Zpc2libGUgPyAnJyA6ICdoaWRkZW4nLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFyZ2luVG9wOiBpc0Fic29sdXRlID8gJycgOiBwbGFjZW1lbnQubWFyZ2luVG9wLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiBpc0Fic29sdXRlID8gcGxhY2VtZW50LmFic29sdXRlVG9wIDogJycsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gfSwgaGFzTGlzdEl0ZW1EaXNwbGF5KHNlZykgPyAoeShUYWJsZUxpc3RJdGVtRXZlbnQsIE9iamVjdC5hc3NpZ24oeyBzZWc6IHNlZywgaXNEcmFnZ2luZzogaXNEcmFnZ2luZywgaXNTZWxlY3RlZDogaW5zdGFuY2VJZCA9PT0gZXZlbnRTZWxlY3Rpb24sIGRlZmF1bHREaXNwbGF5RXZlbnRFbmQ6IGRlZmF1bHREaXNwbGF5RXZlbnRFbmQgfSwgZ2V0U2VnTWV0YShzZWcsIHRvZGF5UmFuZ2UpKSkpIDogKHkoVGFibGVCbG9ja0V2ZW50LCBPYmplY3QuYXNzaWduKHsgc2VnOiBzZWcsIGlzRHJhZ2dpbmc6IGlzRHJhZ2dpbmcsIGlzUmVzaXppbmc6IGlzUmVzaXppbmcsIGlzRGF0ZVNlbGVjdGluZzogaXNEYXRlU2VsZWN0aW5nLCBpc1NlbGVjdGVkOiBpbnN0YW5jZUlkID09PSBldmVudFNlbGVjdGlvbiwgZGVmYXVsdERpc3BsYXlFdmVudEVuZDogZGVmYXVsdERpc3BsYXlFdmVudEVuZCB9LCBnZXRTZWdNZXRhKHNlZywgdG9kYXlSYW5nZSkpKSkpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbm9kZXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlbmRlckZpbGxTZWdzKHNlZ3MsIGZpbGxUeXBlKSB7XHJcbiAgICAgICAgICAgIGxldCB7IGlzUnRsIH0gPSB0aGlzLmNvbnRleHQ7XHJcbiAgICAgICAgICAgIGxldCB7IHRvZGF5UmFuZ2UgfSA9IHRoaXMucHJvcHM7XHJcbiAgICAgICAgICAgIGxldCB7IGZyYW1lUG9zaXRpb25zIH0gPSB0aGlzLnN0YXRlO1xyXG4gICAgICAgICAgICBsZXQgbm9kZXMgPSBbXTtcclxuICAgICAgICAgICAgaWYgKGZyYW1lUG9zaXRpb25zKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBzZWcgb2Ygc2Vncykge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBsZWZ0UmlnaHRDc3MgPSBpc1J0bCA/IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IGZyYW1lUG9zaXRpb25zLmxlZnRzW3NlZy5sYXN0Q29sXSAtIGZyYW1lUG9zaXRpb25zLmxlZnRzW3NlZy5maXJzdENvbF0sXHJcbiAgICAgICAgICAgICAgICAgICAgfSA6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IGZyYW1lUG9zaXRpb25zLnJpZ2h0c1tzZWcuZmlyc3RDb2xdIC0gZnJhbWVQb3NpdGlvbnMucmlnaHRzW3NlZy5sYXN0Q29sXSxcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIG5vZGVzLnB1c2goeShcImRpdlwiLCB7IGtleTogYnVpbGRFdmVudFJhbmdlS2V5KHNlZy5ldmVudFJhbmdlKSwgY2xhc3NOYW1lOiBcImZjLWRheWdyaWQtYmctaGFybmVzc1wiLCBzdHlsZTogbGVmdFJpZ2h0Q3NzIH0sIGZpbGxUeXBlID09PSAnYmctZXZlbnQnID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgeShCZ0V2ZW50LCBPYmplY3QuYXNzaWduKHsgc2VnOiBzZWcgfSwgZ2V0U2VnTWV0YShzZWcsIHRvZGF5UmFuZ2UpKSkgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZW5kZXJGaWxsKGZpbGxUeXBlKSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB5KF8sIHt9LCAuLi5ub2Rlcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHVwZGF0ZVNpemluZyhpc0V4dGVybmFsU2l6aW5nQ2hhbmdlKSB7XHJcbiAgICAgICAgICAgIGxldCB7IHByb3BzLCBzdGF0ZSwgZnJhbWVFbFJlZnMgfSA9IHRoaXM7XHJcbiAgICAgICAgICAgIGlmICghcHJvcHMuZm9yUHJpbnQgJiZcclxuICAgICAgICAgICAgICAgIHByb3BzLmNsaWVudFdpZHRoICE9PSBudWxsIC8vIHBvc2l0aW9uaW5nIHJlYWR5P1xyXG4gICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICAgIGlmIChpc0V4dGVybmFsU2l6aW5nQ2hhbmdlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZyYW1lRWxzID0gcHJvcHMuY2VsbHMubWFwKChjZWxsKSA9PiBmcmFtZUVsUmVmcy5jdXJyZW50TWFwW2NlbGwua2V5XSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZyYW1lRWxzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgb3JpZ2luRWwgPSB0aGlzLnJvb3RFbFJlZi5jdXJyZW50O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbmV3UG9zaXRpb25DYWNoZSA9IG5ldyBQb3NpdGlvbkNhY2hlKG9yaWdpbkVsLCBmcmFtZUVscywgdHJ1ZSwgLy8gaXNIb3Jpem9udGFsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzdGF0ZS5mcmFtZVBvc2l0aW9ucyB8fCAhc3RhdGUuZnJhbWVQb3NpdGlvbnMuc2ltaWxhclRvKG5ld1Bvc2l0aW9uQ2FjaGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcmFtZVBvc2l0aW9uczogbmV3IFBvc2l0aW9uQ2FjaGUob3JpZ2luRWwsIGZyYW1lRWxzLCB0cnVlLCAvLyBpc0hvcml6b250YWxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWxzZSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnN0IG9sZEluc3RhbmNlSGVpZ2h0cyA9IHRoaXMuc3RhdGUuZXZlbnRJbnN0YW5jZUhlaWdodHM7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdJbnN0YW5jZUhlaWdodHMgPSB0aGlzLnF1ZXJ5RXZlbnRJbnN0YW5jZUhlaWdodHMoKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGxpbWl0QnlDb250ZW50SGVpZ2h0ID0gcHJvcHMuZGF5TWF4RXZlbnRzID09PSB0cnVlIHx8IHByb3BzLmRheU1heEV2ZW50Um93cyA9PT0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2FmZVNldFN0YXRlKHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBIQUNLIHRvIHByZXZlbnQgb3NjaWxsYXRpb25zIG9mIGV2ZW50cyBiZWluZyBzaG93bi9oaWRkZW4gZnJvbSBtYXgtZXZlbnQtcm93c1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEVzc2VudGlhbGx5LCBvbmNlIHlvdSBjb21wdXRlIGFuIGVsZW1lbnQncyBoZWlnaHQsIG5ldmVyIG51bGwtb3V0LlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IGFsd2F5cyBkaXNwbGF5IGFsbCBldmVudHMsIGFzIHZpc2liaWxpdHk6aGlkZGVuP1xyXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50SW5zdGFuY2VIZWlnaHRzOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG9sZEluc3RhbmNlSGVpZ2h0cyksIG5ld0luc3RhbmNlSGVpZ2h0cyksXHJcbiAgICAgICAgICAgICAgICAgICAgbWF4Q29udGVudEhlaWdodDogbGltaXRCeUNvbnRlbnRIZWlnaHQgPyB0aGlzLmNvbXB1dGVNYXhDb250ZW50SGVpZ2h0KCkgOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcXVlcnlFdmVudEluc3RhbmNlSGVpZ2h0cygpIHtcclxuICAgICAgICAgICAgbGV0IHNlZ0VsTWFwID0gdGhpcy5zZWdIYXJuZXNzUmVmcy5jdXJyZW50TWFwO1xyXG4gICAgICAgICAgICBsZXQgZXZlbnRJbnN0YW5jZUhlaWdodHMgPSB7fTtcclxuICAgICAgICAgICAgLy8gZ2V0IHRoZSBtYXggaGVpZ2h0IGFtb25nc3QgaW5zdGFuY2Ugc2Vnc1xyXG4gICAgICAgICAgICBmb3IgKGxldCBrZXkgaW4gc2VnRWxNYXApIHtcclxuICAgICAgICAgICAgICAgIGxldCBoZWlnaHQgPSBNYXRoLnJvdW5kKHNlZ0VsTWFwW2tleV0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgIGxldCBpbnN0YW5jZUlkID0ga2V5LnNwbGl0KCc6JylbMF07IC8vIGRlY29uc3RydWN0IGhvdyByZW5kZXJGZ1NlZ3MgbWFrZXMgdGhlIGtleVxyXG4gICAgICAgICAgICAgICAgZXZlbnRJbnN0YW5jZUhlaWdodHNbaW5zdGFuY2VJZF0gPSBNYXRoLm1heChldmVudEluc3RhbmNlSGVpZ2h0c1tpbnN0YW5jZUlkXSB8fCAwLCBoZWlnaHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBldmVudEluc3RhbmNlSGVpZ2h0cztcclxuICAgICAgICB9XHJcbiAgICAgICAgY29tcHV0ZU1heENvbnRlbnRIZWlnaHQoKSB7XHJcbiAgICAgICAgICAgIGxldCBmaXJzdEtleSA9IHRoaXMucHJvcHMuY2VsbHNbMF0ua2V5O1xyXG4gICAgICAgICAgICBsZXQgY2VsbEVsID0gdGhpcy5jZWxsRWxSZWZzLmN1cnJlbnRNYXBbZmlyc3RLZXldO1xyXG4gICAgICAgICAgICBsZXQgZmNDb250YWluZXJFbCA9IHRoaXMuZmdFbFJlZnMuY3VycmVudE1hcFtmaXJzdEtleV07XHJcbiAgICAgICAgICAgIHJldHVybiBjZWxsRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuYm90dG9tIC0gZmNDb250YWluZXJFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3A7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGdldENlbGxFbHMoKSB7XHJcbiAgICAgICAgICAgIGxldCBlbE1hcCA9IHRoaXMuY2VsbEVsUmVmcy5jdXJyZW50TWFwO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9wcy5jZWxscy5tYXAoKGNlbGwpID0+IGVsTWFwW2NlbGwua2V5XSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgVGFibGVSb3cuYWRkU3RhdGVFcXVhbGl0eSh7XHJcbiAgICAgICAgZXZlbnRJbnN0YW5jZUhlaWdodHM6IGlzUHJvcHNFcXVhbCxcclxuICAgIH0pO1xyXG4gICAgZnVuY3Rpb24gYnVpbGRNaXJyb3JQbGFjZW1lbnRzKG1pcnJvclNlZ3MsIGNvbFBsYWNlbWVudHMpIHtcclxuICAgICAgICBpZiAoIW1pcnJvclNlZ3MubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHRvcHNCeUluc3RhbmNlSWQgPSBidWlsZEFic29sdXRlVG9wSGFzaChjb2xQbGFjZW1lbnRzKTsgLy8gVE9ETzogY2FjaGUgdGhpcyBhdCBmaXJzdCByZW5kZXI/XHJcbiAgICAgICAgcmV0dXJuIG1pcnJvclNlZ3MubWFwKChzZWcpID0+ICh7XHJcbiAgICAgICAgICAgIHNlZyxcclxuICAgICAgICAgICAgaXNWaXNpYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBpc0Fic29sdXRlOiB0cnVlLFxyXG4gICAgICAgICAgICBhYnNvbHV0ZVRvcDogdG9wc0J5SW5zdGFuY2VJZFtzZWcuZXZlbnRSYW5nZS5pbnN0YW5jZS5pbnN0YW5jZUlkXSxcclxuICAgICAgICAgICAgbWFyZ2luVG9wOiAwLFxyXG4gICAgICAgIH0pKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGJ1aWxkQWJzb2x1dGVUb3BIYXNoKGNvbFBsYWNlbWVudHMpIHtcclxuICAgICAgICBsZXQgdG9wc0J5SW5zdGFuY2VJZCA9IHt9O1xyXG4gICAgICAgIGZvciAobGV0IHBsYWNlbWVudHMgb2YgY29sUGxhY2VtZW50cykge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBwbGFjZW1lbnQgb2YgcGxhY2VtZW50cykge1xyXG4gICAgICAgICAgICAgICAgdG9wc0J5SW5zdGFuY2VJZFtwbGFjZW1lbnQuc2VnLmV2ZW50UmFuZ2UuaW5zdGFuY2UuaW5zdGFuY2VJZF0gPSBwbGFjZW1lbnQuYWJzb2x1dGVUb3A7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRvcHNCeUluc3RhbmNlSWQ7XHJcbiAgICB9XHJcblxyXG4gICAgY2xhc3MgVGFibGVSb3dzIGV4dGVuZHMgRGF0ZUNvbXBvbmVudCB7XHJcbiAgICAgICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgIHRoaXMuc3BsaXRCdXNpbmVzc0hvdXJTZWdzID0gbWVtb2l6ZShzcGxpdFNlZ3NCeVJvdyk7XHJcbiAgICAgICAgICAgIHRoaXMuc3BsaXRCZ0V2ZW50U2VncyA9IG1lbW9pemUoc3BsaXRTZWdzQnlSb3cpO1xyXG4gICAgICAgICAgICB0aGlzLnNwbGl0RmdFdmVudFNlZ3MgPSBtZW1vaXplKHNwbGl0U2Vnc0J5Um93KTtcclxuICAgICAgICAgICAgdGhpcy5zcGxpdERhdGVTZWxlY3Rpb25TZWdzID0gbWVtb2l6ZShzcGxpdFNlZ3NCeVJvdyk7XHJcbiAgICAgICAgICAgIHRoaXMuc3BsaXRFdmVudERyYWcgPSBtZW1vaXplKHNwbGl0SW50ZXJhY3Rpb25CeVJvdyk7XHJcbiAgICAgICAgICAgIHRoaXMuc3BsaXRFdmVudFJlc2l6ZSA9IG1lbW9pemUoc3BsaXRJbnRlcmFjdGlvbkJ5Um93KTtcclxuICAgICAgICAgICAgdGhpcy5yb3dSZWZzID0gbmV3IFJlZk1hcCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZW5kZXIoKSB7XHJcbiAgICAgICAgICAgIGxldCB7IHByb3BzLCBjb250ZXh0IH0gPSB0aGlzO1xyXG4gICAgICAgICAgICBsZXQgcm93Q250ID0gcHJvcHMuY2VsbHMubGVuZ3RoO1xyXG4gICAgICAgICAgICBsZXQgYnVzaW5lc3NIb3VyU2Vnc0J5Um93ID0gdGhpcy5zcGxpdEJ1c2luZXNzSG91clNlZ3MocHJvcHMuYnVzaW5lc3NIb3VyU2Vncywgcm93Q250KTtcclxuICAgICAgICAgICAgbGV0IGJnRXZlbnRTZWdzQnlSb3cgPSB0aGlzLnNwbGl0QmdFdmVudFNlZ3MocHJvcHMuYmdFdmVudFNlZ3MsIHJvd0NudCk7XHJcbiAgICAgICAgICAgIGxldCBmZ0V2ZW50U2Vnc0J5Um93ID0gdGhpcy5zcGxpdEZnRXZlbnRTZWdzKHByb3BzLmZnRXZlbnRTZWdzLCByb3dDbnQpO1xyXG4gICAgICAgICAgICBsZXQgZGF0ZVNlbGVjdGlvblNlZ3NCeVJvdyA9IHRoaXMuc3BsaXREYXRlU2VsZWN0aW9uU2Vncyhwcm9wcy5kYXRlU2VsZWN0aW9uU2Vncywgcm93Q250KTtcclxuICAgICAgICAgICAgbGV0IGV2ZW50RHJhZ0J5Um93ID0gdGhpcy5zcGxpdEV2ZW50RHJhZyhwcm9wcy5ldmVudERyYWcsIHJvd0NudCk7XHJcbiAgICAgICAgICAgIGxldCBldmVudFJlc2l6ZUJ5Um93ID0gdGhpcy5zcGxpdEV2ZW50UmVzaXplKHByb3BzLmV2ZW50UmVzaXplLCByb3dDbnQpO1xyXG4gICAgICAgICAgICAvLyBmb3IgRGF5R3JpZCB2aWV3IHdpdGggbWFueSByb3dzLCBmb3JjZSBhIG1pbi1oZWlnaHQgb24gY2VsbHMgc28gZG9lc24ndCBhcHBlYXIgc3F1aXNoZWRcclxuICAgICAgICAgICAgLy8gY2hvb3NlIDcgYmVjYXVzZSBhIG1vbnRoIHZpZXcgd2lsbCBoYXZlIG1heCA2IHJvd3NcclxuICAgICAgICAgICAgbGV0IGNlbGxNaW5IZWlnaHQgPSAocm93Q250ID49IDcgJiYgcHJvcHMuY2xpZW50V2lkdGgpID9cclxuICAgICAgICAgICAgICAgIHByb3BzLmNsaWVudFdpZHRoIC8gY29udGV4dC5vcHRpb25zLmFzcGVjdFJhdGlvIC8gNiA6XHJcbiAgICAgICAgICAgICAgICBudWxsO1xyXG4gICAgICAgICAgICByZXR1cm4gKHkoTm93VGltZXIsIHsgdW5pdDogXCJkYXlcIiB9LCAobm93RGF0ZSwgdG9kYXlSYW5nZSkgPT4gKHkoXywgbnVsbCwgcHJvcHMuY2VsbHMubWFwKChjZWxscywgcm93KSA9PiAoeShUYWJsZVJvdywgeyByZWY6IHRoaXMucm93UmVmcy5jcmVhdGVSZWYocm93KSwga2V5OiBjZWxscy5sZW5ndGhcclxuICAgICAgICAgICAgICAgICAgICA/IGNlbGxzWzBdLmRhdGUudG9JU09TdHJpbmcoKSAvKiBiZXN0PyBvciBwdXQga2V5IG9uIGNlbGw/IG9yIHVzZSBkaWZmIGZvcm1hdHRlcj8gKi9cclxuICAgICAgICAgICAgICAgICAgICA6IHJvdyAvLyBpbiBjYXNlIHRoZXJlIGFyZSBubyBjZWxscyAobGlrZSB3aGVuIHJlc291cmNlIHZpZXcgaXMgbG9hZGluZylcclxuICAgICAgICAgICAgICAgICwgc2hvd0RheU51bWJlcnM6IHJvd0NudCA+IDEsIHNob3dXZWVrTnVtYmVyczogcHJvcHMuc2hvd1dlZWtOdW1iZXJzLCB0b2RheVJhbmdlOiB0b2RheVJhbmdlLCBkYXRlUHJvZmlsZTogcHJvcHMuZGF0ZVByb2ZpbGUsIGNlbGxzOiBjZWxscywgcmVuZGVySW50cm86IHByb3BzLnJlbmRlclJvd0ludHJvLCBidXNpbmVzc0hvdXJTZWdzOiBidXNpbmVzc0hvdXJTZWdzQnlSb3dbcm93XSwgZXZlbnRTZWxlY3Rpb246IHByb3BzLmV2ZW50U2VsZWN0aW9uLCBiZ0V2ZW50U2VnczogYmdFdmVudFNlZ3NCeVJvd1tyb3ddLmZpbHRlcihpc1NlZ0FsbERheSkgLyogaGFjayAqLywgZmdFdmVudFNlZ3M6IGZnRXZlbnRTZWdzQnlSb3dbcm93XSwgZGF0ZVNlbGVjdGlvblNlZ3M6IGRhdGVTZWxlY3Rpb25TZWdzQnlSb3dbcm93XSwgZXZlbnREcmFnOiBldmVudERyYWdCeVJvd1tyb3ddLCBldmVudFJlc2l6ZTogZXZlbnRSZXNpemVCeVJvd1tyb3ddLCBkYXlNYXhFdmVudHM6IHByb3BzLmRheU1heEV2ZW50cywgZGF5TWF4RXZlbnRSb3dzOiBwcm9wcy5kYXlNYXhFdmVudFJvd3MsIGNsaWVudFdpZHRoOiBwcm9wcy5jbGllbnRXaWR0aCwgY2xpZW50SGVpZ2h0OiBwcm9wcy5jbGllbnRIZWlnaHQsIGNlbGxNaW5IZWlnaHQ6IGNlbGxNaW5IZWlnaHQsIGZvclByaW50OiBwcm9wcy5mb3JQcmludCB9KSkpKSkpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29tcG9uZW50RGlkTW91bnQoKSB7XHJcbiAgICAgICAgICAgIC8vIEhBQ0s6IG5lZWQgYSBkYXlncmlkIHdyYXBwZXIgcGFyZW50IHRvIGRvIHBvc2l0aW9uaW5nXHJcbiAgICAgICAgICAgIC8vIE5PVEU6IGEgZGF5Z3JpZCByZXNvdXJjZSB2aWV3IHcvbyByZXNvdXJjZXMgY2FuIGhhdmUgemVybyBjZWxsc1xyXG4gICAgICAgICAgICBjb25zdCBmaXJzdENlbGxFbCA9IHRoaXMucm93UmVmcy5jdXJyZW50TWFwWzBdLmdldENlbGxFbHMoKVswXTtcclxuICAgICAgICAgICAgdGhpcy5yb290RWwgPSBmaXJzdENlbGxFbCA/IGZpcnN0Q2VsbEVsLmNsb3Nlc3QoJy5mYy1kYXlncmlkLWJvZHknKSA6IG51bGw7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnJvb3RFbCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LnJlZ2lzdGVySW50ZXJhY3RpdmVDb21wb25lbnQodGhpcywge1xyXG4gICAgICAgICAgICAgICAgICAgIGVsOiB0aGlzLnJvb3RFbCxcclxuICAgICAgICAgICAgICAgICAgICBpc0hpdENvbWJvQWxsb3dlZDogdGhpcy5wcm9wcy5pc0hpdENvbWJvQWxsb3dlZCxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5yb290RWwpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC51bnJlZ2lzdGVySW50ZXJhY3RpdmVDb21wb25lbnQodGhpcyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJvb3RFbCA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gSGl0IFN5c3RlbVxyXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgICAgICBwcmVwYXJlSGl0cygpIHtcclxuICAgICAgICAgICAgdGhpcy5yb3dQb3NpdGlvbnMgPSBuZXcgUG9zaXRpb25DYWNoZSh0aGlzLnJvb3RFbCwgdGhpcy5yb3dSZWZzLmNvbGxlY3QoKS5tYXAoKHJvd09iaikgPT4gcm93T2JqLmdldENlbGxFbHMoKVswXSksIC8vIGZpcnN0IGNlbGwgZWwgaW4gZWFjaCByb3cuIFRPRE86IG5vdCBvcHRpbWFsXHJcbiAgICAgICAgICAgIGZhbHNlLCB0cnVlKTtcclxuICAgICAgICAgICAgdGhpcy5jb2xQb3NpdGlvbnMgPSBuZXcgUG9zaXRpb25DYWNoZSh0aGlzLnJvb3RFbCwgdGhpcy5yb3dSZWZzLmN1cnJlbnRNYXBbMF0uZ2V0Q2VsbEVscygpLCAvLyBjZWxsIGVscyBpbiBmaXJzdCByb3dcclxuICAgICAgICAgICAgdHJ1ZSwgLy8gaG9yaXpvbnRhbFxyXG4gICAgICAgICAgICBmYWxzZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHF1ZXJ5SGl0KHBvc2l0aW9uTGVmdCwgcG9zaXRpb25Ub3ApIHtcclxuICAgICAgICAgICAgbGV0IHsgY29sUG9zaXRpb25zLCByb3dQb3NpdGlvbnMgfSA9IHRoaXM7XHJcbiAgICAgICAgICAgIGxldCBjb2wgPSBjb2xQb3NpdGlvbnMubGVmdFRvSW5kZXgocG9zaXRpb25MZWZ0KTtcclxuICAgICAgICAgICAgbGV0IHJvdyA9IHJvd1Bvc2l0aW9ucy50b3BUb0luZGV4KHBvc2l0aW9uVG9wKTtcclxuICAgICAgICAgICAgaWYgKHJvdyAhPSBudWxsICYmIGNvbCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgY2VsbCA9IHRoaXMucHJvcHMuY2VsbHNbcm93XVtjb2xdO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICBkYXRlUHJvZmlsZTogdGhpcy5wcm9wcy5kYXRlUHJvZmlsZSxcclxuICAgICAgICAgICAgICAgICAgICBkYXRlU3BhbjogT2JqZWN0LmFzc2lnbih7IHJhbmdlOiB0aGlzLmdldENlbGxSYW5nZShyb3csIGNvbCksIGFsbERheTogdHJ1ZSB9LCBjZWxsLmV4dHJhRGF0ZVNwYW4pLFxyXG4gICAgICAgICAgICAgICAgICAgIGRheUVsOiB0aGlzLmdldENlbGxFbChyb3csIGNvbCksXHJcbiAgICAgICAgICAgICAgICAgICAgcmVjdDoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiBjb2xQb3NpdGlvbnMubGVmdHNbY29sXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IGNvbFBvc2l0aW9ucy5yaWdodHNbY29sXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiByb3dQb3NpdGlvbnMudG9wc1tyb3ddLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBib3R0b206IHJvd1Bvc2l0aW9ucy5ib3R0b21zW3Jvd10sXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBsYXllcjogMCxcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGdldENlbGxFbChyb3csIGNvbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yb3dSZWZzLmN1cnJlbnRNYXBbcm93XS5nZXRDZWxsRWxzKClbY29sXTsgLy8gVE9ETzogbm90IG9wdGltYWxcclxuICAgICAgICB9XHJcbiAgICAgICAgZ2V0Q2VsbFJhbmdlKHJvdywgY29sKSB7XHJcbiAgICAgICAgICAgIGxldCBzdGFydCA9IHRoaXMucHJvcHMuY2VsbHNbcm93XVtjb2xdLmRhdGU7XHJcbiAgICAgICAgICAgIGxldCBlbmQgPSBhZGREYXlzKHN0YXJ0LCAxKTtcclxuICAgICAgICAgICAgcmV0dXJuIHsgc3RhcnQsIGVuZCB9O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGlzU2VnQWxsRGF5KHNlZykge1xyXG4gICAgICAgIHJldHVybiBzZWcuZXZlbnRSYW5nZS5kZWYuYWxsRGF5O1xyXG4gICAgfVxyXG5cclxuICAgIGNsYXNzIFRhYmxlIGV4dGVuZHMgRGF0ZUNvbXBvbmVudCB7XHJcbiAgICAgICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgIHRoaXMuZWxSZWYgPSBkKCk7XHJcbiAgICAgICAgICAgIHRoaXMubmVlZHNTY3JvbGxSZXNldCA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZW5kZXIoKSB7XHJcbiAgICAgICAgICAgIGxldCB7IHByb3BzIH0gPSB0aGlzO1xyXG4gICAgICAgICAgICBsZXQgeyBkYXlNYXhFdmVudFJvd3MsIGRheU1heEV2ZW50cywgZXhwYW5kUm93cyB9ID0gcHJvcHM7XHJcbiAgICAgICAgICAgIGxldCBsaW1pdFZpYUJhbGFuY2VkID0gZGF5TWF4RXZlbnRzID09PSB0cnVlIHx8IGRheU1heEV2ZW50Um93cyA9PT0gdHJ1ZTtcclxuICAgICAgICAgICAgLy8gaWYgcm93cyBjYW4ndCBleHBhbmQgdG8gZmlsbCBmaXhlZCBoZWlnaHQsIGNhbid0IGRvIGJhbGFuY2VkLWhlaWdodCBldmVudCBsaW1pdFxyXG4gICAgICAgICAgICAvLyBUT0RPOiBiZXN0IHBsYWNlIHRvIG5vcm1hbGl6ZSB0aGVzZSBvcHRpb25zP1xyXG4gICAgICAgICAgICBpZiAobGltaXRWaWFCYWxhbmNlZCAmJiAhZXhwYW5kUm93cykge1xyXG4gICAgICAgICAgICAgICAgbGltaXRWaWFCYWxhbmNlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgZGF5TWF4RXZlbnRSb3dzID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIGRheU1heEV2ZW50cyA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IGNsYXNzTmFtZXMgPSBbXHJcbiAgICAgICAgICAgICAgICAnZmMtZGF5Z3JpZC1ib2R5JyxcclxuICAgICAgICAgICAgICAgIGxpbWl0VmlhQmFsYW5jZWQgPyAnZmMtZGF5Z3JpZC1ib2R5LWJhbGFuY2VkJyA6ICdmYy1kYXlncmlkLWJvZHktdW5iYWxhbmNlZCcsXHJcbiAgICAgICAgICAgICAgICBleHBhbmRSb3dzID8gJycgOiAnZmMtZGF5Z3JpZC1ib2R5LW5hdHVyYWwnLCAvLyB3aWxsIGhlaWdodCBvZiBvbmUgcm93IGRlcGVuZCBvbiB0aGUgb3RoZXJzP1xyXG4gICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICByZXR1cm4gKHkoXCJkaXZcIiwgeyByZWY6IHRoaXMuZWxSZWYsIGNsYXNzTmFtZTogY2xhc3NOYW1lcy5qb2luKCcgJyksIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlc2UgcHJvcHMgYXJlIGltcG9ydGFudCB0byBnaXZlIHRoaXMgd3JhcHBlciBjb3JyZWN0IGRpbWVuc2lvbnMgZm9yIGludGVyYWN0aW9uc1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IGlmIHdlIHNldCBpdCBoZXJlLCBjYW4gd2UgYXZvaWQgZ2l2aW5nIHRvIGlubmVyIHRhYmxlcz9cclxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogcHJvcHMuY2xpZW50V2lkdGgsXHJcbiAgICAgICAgICAgICAgICAgICAgbWluV2lkdGg6IHByb3BzLnRhYmxlTWluV2lkdGgsXHJcbiAgICAgICAgICAgICAgICB9IH0sXHJcbiAgICAgICAgICAgICAgICB5KFwidGFibGVcIiwgeyByb2xlOiBcInByZXNlbnRhdGlvblwiLCBjbGFzc05hbWU6IFwiZmMtc2Nyb2xsZ3JpZC1zeW5jLXRhYmxlXCIsIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBwcm9wcy5jbGllbnRXaWR0aCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWluV2lkdGg6IHByb3BzLnRhYmxlTWluV2lkdGgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogZXhwYW5kUm93cyA/IHByb3BzLmNsaWVudEhlaWdodCA6ICcnLFxyXG4gICAgICAgICAgICAgICAgICAgIH0gfSxcclxuICAgICAgICAgICAgICAgICAgICBwcm9wcy5jb2xHcm91cE5vZGUsXHJcbiAgICAgICAgICAgICAgICAgICAgeShcInRib2R5XCIsIHsgcm9sZTogXCJwcmVzZW50YXRpb25cIiB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB5KFRhYmxlUm93cywgeyBkYXRlUHJvZmlsZTogcHJvcHMuZGF0ZVByb2ZpbGUsIGNlbGxzOiBwcm9wcy5jZWxscywgcmVuZGVyUm93SW50cm86IHByb3BzLnJlbmRlclJvd0ludHJvLCBzaG93V2Vla051bWJlcnM6IHByb3BzLnNob3dXZWVrTnVtYmVycywgY2xpZW50V2lkdGg6IHByb3BzLmNsaWVudFdpZHRoLCBjbGllbnRIZWlnaHQ6IHByb3BzLmNsaWVudEhlaWdodCwgYnVzaW5lc3NIb3VyU2VnczogcHJvcHMuYnVzaW5lc3NIb3VyU2VncywgYmdFdmVudFNlZ3M6IHByb3BzLmJnRXZlbnRTZWdzLCBmZ0V2ZW50U2VnczogcHJvcHMuZmdFdmVudFNlZ3MsIGRhdGVTZWxlY3Rpb25TZWdzOiBwcm9wcy5kYXRlU2VsZWN0aW9uU2VncywgZXZlbnRTZWxlY3Rpb246IHByb3BzLmV2ZW50U2VsZWN0aW9uLCBldmVudERyYWc6IHByb3BzLmV2ZW50RHJhZywgZXZlbnRSZXNpemU6IHByb3BzLmV2ZW50UmVzaXplLCBkYXlNYXhFdmVudHM6IGRheU1heEV2ZW50cywgZGF5TWF4RXZlbnRSb3dzOiBkYXlNYXhFdmVudFJvd3MsIGZvclByaW50OiBwcm9wcy5mb3JQcmludCwgaXNIaXRDb21ib0FsbG93ZWQ6IHByb3BzLmlzSGl0Q29tYm9BbGxvd2VkIH0pKSkpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29tcG9uZW50RGlkTW91bnQoKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdFNjcm9sbFJlc2V0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMpIHtcclxuICAgICAgICAgICAgaWYgKHByZXZQcm9wcy5kYXRlUHJvZmlsZSAhPT0gdGhpcy5wcm9wcy5kYXRlUHJvZmlsZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZXF1ZXN0U2Nyb2xsUmVzZXQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZmx1c2hTY3JvbGxSZXNldCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlcXVlc3RTY3JvbGxSZXNldCgpIHtcclxuICAgICAgICAgICAgdGhpcy5uZWVkc1Njcm9sbFJlc2V0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5mbHVzaFNjcm9sbFJlc2V0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZsdXNoU2Nyb2xsUmVzZXQoKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLm5lZWRzU2Nyb2xsUmVzZXQgJiZcclxuICAgICAgICAgICAgICAgIHRoaXMucHJvcHMuY2xpZW50V2lkdGggLy8gc2l6ZXMgY29tcHV0ZWQ/XHJcbiAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc3ViamVjdEVsID0gZ2V0U2Nyb2xsU3ViamVjdEVsKHRoaXMuZWxSZWYuY3VycmVudCwgdGhpcy5wcm9wcy5kYXRlUHJvZmlsZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3ViamVjdEVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3JpZ2luRWwgPSBzdWJqZWN0RWwuY2xvc2VzdCgnLmZjLWRheWdyaWQtYm9keScpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNjcm9sbEVsID0gb3JpZ2luRWwuY2xvc2VzdCgnLmZjLXNjcm9sbGVyJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2Nyb2xsVG9wID0gc3ViamVjdEVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCAtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbkVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcDtcclxuICAgICAgICAgICAgICAgICAgICBzY3JvbGxFbC5zY3JvbGxUb3AgPSBzY3JvbGxUb3AgPyAoc2Nyb2xsVG9wICsgMSkgOiAwOyAvLyBvdmVyY29tZSBib3JkZXJcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMubmVlZHNTY3JvbGxSZXNldCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZ2V0U2Nyb2xsU3ViamVjdEVsKGNvbnRhaW5lckVsLCBkYXRlUHJvZmlsZSkge1xyXG4gICAgICAgIGxldCBlbDtcclxuICAgICAgICBpZiAoZGF0ZVByb2ZpbGUuY3VycmVudFJhbmdlVW5pdC5tYXRjaCgveWVhcnxtb250aC8pKSB7XHJcbiAgICAgICAgICAgIGVsID0gY29udGFpbmVyRWwucXVlcnlTZWxlY3RvcihgW2RhdGEtZGF0ZT1cIiR7Zm9ybWF0SXNvTW9udGhTdHIoZGF0ZVByb2ZpbGUuY3VycmVudERhdGUpfS0wMVwiXWApO1xyXG4gICAgICAgICAgICAvLyBldmVuIGlmIHZpZXcgaXMgbW9udGgtYmFzZWQsIGZpcnN0LW9mLW1vbnRoIG1pZ2h0IGJlIGhpZGRlbi4uLlxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWVsKSB7XHJcbiAgICAgICAgICAgIGVsID0gY29udGFpbmVyRWwucXVlcnlTZWxlY3RvcihgW2RhdGEtZGF0ZT1cIiR7Zm9ybWF0RGF5U3RyaW5nKGRhdGVQcm9maWxlLmN1cnJlbnREYXRlKX1cIl1gKTtcclxuICAgICAgICAgICAgLy8gY291bGQgc3RpbGwgYmUgaGlkZGVuIGlmIGFuIGludGVyaW9yLXZpZXcgaGlkZGVuIGRheVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZWw7XHJcbiAgICB9XHJcblxyXG4gICAgY2xhc3MgRGF5VGFibGVTbGljZXIgZXh0ZW5kcyBTbGljZXIge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgICAgICB0aGlzLmZvcmNlRGF5SWZMaXN0SXRlbSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNsaWNlUmFuZ2UoZGF0ZVJhbmdlLCBkYXlUYWJsZU1vZGVsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkYXlUYWJsZU1vZGVsLnNsaWNlUmFuZ2UoZGF0ZVJhbmdlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY2xhc3MgRGF5VGFibGUgZXh0ZW5kcyBEYXRlQ29tcG9uZW50IHtcclxuICAgICAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgdGhpcy5zbGljZXIgPSBuZXcgRGF5VGFibGVTbGljZXIoKTtcclxuICAgICAgICAgICAgdGhpcy50YWJsZVJlZiA9IGQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVuZGVyKCkge1xyXG4gICAgICAgICAgICBsZXQgeyBwcm9wcywgY29udGV4dCB9ID0gdGhpcztcclxuICAgICAgICAgICAgcmV0dXJuICh5KFRhYmxlLCBPYmplY3QuYXNzaWduKHsgcmVmOiB0aGlzLnRhYmxlUmVmIH0sIHRoaXMuc2xpY2VyLnNsaWNlUHJvcHMocHJvcHMsIHByb3BzLmRhdGVQcm9maWxlLCBwcm9wcy5uZXh0RGF5VGhyZXNob2xkLCBjb250ZXh0LCBwcm9wcy5kYXlUYWJsZU1vZGVsKSwgeyBkYXRlUHJvZmlsZTogcHJvcHMuZGF0ZVByb2ZpbGUsIGNlbGxzOiBwcm9wcy5kYXlUYWJsZU1vZGVsLmNlbGxzLCBjb2xHcm91cE5vZGU6IHByb3BzLmNvbEdyb3VwTm9kZSwgdGFibGVNaW5XaWR0aDogcHJvcHMudGFibGVNaW5XaWR0aCwgcmVuZGVyUm93SW50cm86IHByb3BzLnJlbmRlclJvd0ludHJvLCBkYXlNYXhFdmVudHM6IHByb3BzLmRheU1heEV2ZW50cywgZGF5TWF4RXZlbnRSb3dzOiBwcm9wcy5kYXlNYXhFdmVudFJvd3MsIHNob3dXZWVrTnVtYmVyczogcHJvcHMuc2hvd1dlZWtOdW1iZXJzLCBleHBhbmRSb3dzOiBwcm9wcy5leHBhbmRSb3dzLCBoZWFkZXJBbGlnbkVsUmVmOiBwcm9wcy5oZWFkZXJBbGlnbkVsUmVmLCBjbGllbnRXaWR0aDogcHJvcHMuY2xpZW50V2lkdGgsIGNsaWVudEhlaWdodDogcHJvcHMuY2xpZW50SGVpZ2h0LCBmb3JQcmludDogcHJvcHMuZm9yUHJpbnQgfSkpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY2xhc3MgVGFibGVEYXRlUHJvZmlsZUdlbmVyYXRvciBleHRlbmRzIERhdGVQcm9maWxlR2VuZXJhdG9yIHtcclxuICAgICAgICAvLyBDb21wdXRlcyB0aGUgZGF0ZSByYW5nZSB0aGF0IHdpbGwgYmUgcmVuZGVyZWRcclxuICAgICAgICBidWlsZFJlbmRlclJhbmdlKGN1cnJlbnRSYW5nZSwgY3VycmVudFJhbmdlVW5pdCwgaXNSYW5nZUFsbERheSkge1xyXG4gICAgICAgICAgICBsZXQgcmVuZGVyUmFuZ2UgPSBzdXBlci5idWlsZFJlbmRlclJhbmdlKGN1cnJlbnRSYW5nZSwgY3VycmVudFJhbmdlVW5pdCwgaXNSYW5nZUFsbERheSk7XHJcbiAgICAgICAgICAgIGxldCB7IHByb3BzIH0gPSB0aGlzO1xyXG4gICAgICAgICAgICByZXR1cm4gYnVpbGREYXlUYWJsZVJlbmRlclJhbmdlKHtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRSYW5nZTogcmVuZGVyUmFuZ2UsXHJcbiAgICAgICAgICAgICAgICBzbmFwVG9XZWVrOiAvXih5ZWFyfG1vbnRoKSQvLnRlc3QoY3VycmVudFJhbmdlVW5pdCksXHJcbiAgICAgICAgICAgICAgICBmaXhlZFdlZWtDb3VudDogcHJvcHMuZml4ZWRXZWVrQ291bnQsXHJcbiAgICAgICAgICAgICAgICBkYXRlRW52OiBwcm9wcy5kYXRlRW52LFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBidWlsZERheVRhYmxlUmVuZGVyUmFuZ2UocHJvcHMpIHtcclxuICAgICAgICBsZXQgeyBkYXRlRW52LCBjdXJyZW50UmFuZ2UgfSA9IHByb3BzO1xyXG4gICAgICAgIGxldCB7IHN0YXJ0LCBlbmQgfSA9IGN1cnJlbnRSYW5nZTtcclxuICAgICAgICBsZXQgZW5kT2ZXZWVrO1xyXG4gICAgICAgIC8vIHllYXIgYW5kIG1vbnRoIHZpZXdzIHNob3VsZCBiZSBhbGlnbmVkIHdpdGggd2Vla3MuIHRoaXMgaXMgYWxyZWFkeSBkb25lIGZvciB3ZWVrXHJcbiAgICAgICAgaWYgKHByb3BzLnNuYXBUb1dlZWspIHtcclxuICAgICAgICAgICAgc3RhcnQgPSBkYXRlRW52LnN0YXJ0T2ZXZWVrKHN0YXJ0KTtcclxuICAgICAgICAgICAgLy8gbWFrZSBlbmQtb2Ytd2VlayBpZiBub3QgYWxyZWFkeVxyXG4gICAgICAgICAgICBlbmRPZldlZWsgPSBkYXRlRW52LnN0YXJ0T2ZXZWVrKGVuZCk7XHJcbiAgICAgICAgICAgIGlmIChlbmRPZldlZWsudmFsdWVPZigpICE9PSBlbmQudmFsdWVPZigpKSB7XHJcbiAgICAgICAgICAgICAgICBlbmQgPSBhZGRXZWVrcyhlbmRPZldlZWssIDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGVuc3VyZSA2IHdlZWtzXHJcbiAgICAgICAgaWYgKHByb3BzLmZpeGVkV2Vla0NvdW50KSB7XHJcbiAgICAgICAgICAgIC8vIFRPRE86IGluc3RlYWQgb2YgdGhlc2UgZGF0ZS1tYXRoIGd5bW5hc3RpY3MgKGZvciBtdWx0aW1vbnRoIHZpZXcpLFxyXG4gICAgICAgICAgICAvLyBjb21wdXRlIGRhdGVwcm9maWxlcyBvZiBhbGwgbW9udGhzLCB0aGVuIHVzZSBzdGFydCBvZiBmaXJzdCBhbmQgZW5kIG9mIGxhc3QuXHJcbiAgICAgICAgICAgIGxldCBsYXN0TW9udGhSZW5kZXJTdGFydCA9IGRhdGVFbnYuc3RhcnRPZldlZWsoZGF0ZUVudi5zdGFydE9mTW9udGgoYWRkRGF5cyhjdXJyZW50UmFuZ2UuZW5kLCAtMSkpKTtcclxuICAgICAgICAgICAgbGV0IHJvd0NudCA9IE1hdGguY2VpbCgvLyBjb3VsZCBiZSBwYXJ0aWFsIHdlZWtzIGR1ZSB0byBoaWRkZW5EYXlzXHJcbiAgICAgICAgICAgIGRpZmZXZWVrcyhsYXN0TW9udGhSZW5kZXJTdGFydCwgZW5kKSk7XHJcbiAgICAgICAgICAgIGVuZCA9IGFkZFdlZWtzKGVuZCwgNiAtIHJvd0NudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7IHN0YXJ0LCBlbmQgfTtcclxuICAgIH1cclxuXHJcbiAgICAvKiBBbiBhYnN0cmFjdCBjbGFzcyBmb3IgdGhlIGRheWdyaWQgdmlld3MsIGFzIHdlbGwgYXMgbW9udGggdmlldy4gUmVuZGVycyBvbmUgb3IgbW9yZSByb3dzIG9mIGRheSBjZWxscy5cclxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgLy8gSXQgaXMgYSBtYW5hZ2VyIGZvciBhIFRhYmxlIHN1YmNvbXBvbmVudCwgd2hpY2ggZG9lcyBtb3N0IG9mIHRoZSBoZWF2eSBsaWZ0aW5nLlxyXG4gICAgLy8gSXQgaXMgcmVzcG9uc2libGUgZm9yIG1hbmFnaW5nIHdpZHRoL2hlaWdodC5cclxuICAgIGNsYXNzIFRhYmxlVmlldyBleHRlbmRzIERhdGVDb21wb25lbnQge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgICAgICB0aGlzLmhlYWRlckVsUmVmID0gZCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZW5kZXJTaW1wbGVMYXlvdXQoaGVhZGVyUm93Q29udGVudCwgYm9keUNvbnRlbnQpIHtcclxuICAgICAgICAgICAgbGV0IHsgcHJvcHMsIGNvbnRleHQgfSA9IHRoaXM7XHJcbiAgICAgICAgICAgIGxldCBzZWN0aW9ucyA9IFtdO1xyXG4gICAgICAgICAgICBsZXQgc3RpY2t5SGVhZGVyRGF0ZXMgPSBnZXRTdGlja3lIZWFkZXJEYXRlcyhjb250ZXh0Lm9wdGlvbnMpO1xyXG4gICAgICAgICAgICBpZiAoaGVhZGVyUm93Q29udGVudCkge1xyXG4gICAgICAgICAgICAgICAgc2VjdGlvbnMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2hlYWRlcicsXHJcbiAgICAgICAgICAgICAgICAgICAga2V5OiAnaGVhZGVyJyxcclxuICAgICAgICAgICAgICAgICAgICBpc1N0aWNreTogc3RpY2t5SGVhZGVyRGF0ZXMsXHJcbiAgICAgICAgICAgICAgICAgICAgY2h1bms6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxSZWY6IHRoaXMuaGVhZGVyRWxSZWYsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhYmxlQ2xhc3NOYW1lOiAnZmMtY29sLWhlYWRlcicsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvd0NvbnRlbnQ6IGhlYWRlclJvd0NvbnRlbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHNlY3Rpb25zLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgdHlwZTogJ2JvZHknLFxyXG4gICAgICAgICAgICAgICAga2V5OiAnYm9keScsXHJcbiAgICAgICAgICAgICAgICBsaXF1aWQ6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBjaHVuazogeyBjb250ZW50OiBib2R5Q29udGVudCB9LFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuICh5KFZpZXdDb250YWluZXIsIHsgZWxDbGFzc2VzOiBbJ2ZjLWRheWdyaWQnXSwgdmlld1NwZWM6IGNvbnRleHQudmlld1NwZWMgfSxcclxuICAgICAgICAgICAgICAgIHkoU2ltcGxlU2Nyb2xsR3JpZCwgeyBsaXF1aWQ6ICFwcm9wcy5pc0hlaWdodEF1dG8gJiYgIXByb3BzLmZvclByaW50LCBjb2xsYXBzaWJsZVdpZHRoOiBwcm9wcy5mb3JQcmludCwgY29sczogW10gLyogVE9ETzogbWFrZSBvcHRpb25hbD8gKi8sIHNlY3Rpb25zOiBzZWN0aW9ucyB9KSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZW5kZXJIU2Nyb2xsTGF5b3V0KGhlYWRlclJvd0NvbnRlbnQsIGJvZHlDb250ZW50LCBjb2xDbnQsIGRheU1pbldpZHRoKSB7XHJcbiAgICAgICAgICAgIGxldCBTY3JvbGxHcmlkID0gdGhpcy5jb250ZXh0LnBsdWdpbkhvb2tzLnNjcm9sbEdyaWRJbXBsO1xyXG4gICAgICAgICAgICBpZiAoIVNjcm9sbEdyaWQpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gU2Nyb2xsR3JpZCBpbXBsZW1lbnRhdGlvbicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxldCB7IHByb3BzLCBjb250ZXh0IH0gPSB0aGlzO1xyXG4gICAgICAgICAgICBsZXQgc3RpY2t5SGVhZGVyRGF0ZXMgPSAhcHJvcHMuZm9yUHJpbnQgJiYgZ2V0U3RpY2t5SGVhZGVyRGF0ZXMoY29udGV4dC5vcHRpb25zKTtcclxuICAgICAgICAgICAgbGV0IHN0aWNreUZvb3RlclNjcm9sbGJhciA9ICFwcm9wcy5mb3JQcmludCAmJiBnZXRTdGlja3lGb290ZXJTY3JvbGxiYXIoY29udGV4dC5vcHRpb25zKTtcclxuICAgICAgICAgICAgbGV0IHNlY3Rpb25zID0gW107XHJcbiAgICAgICAgICAgIGlmIChoZWFkZXJSb3dDb250ZW50KSB7XHJcbiAgICAgICAgICAgICAgICBzZWN0aW9ucy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnaGVhZGVyJyxcclxuICAgICAgICAgICAgICAgICAgICBrZXk6ICdoZWFkZXInLFxyXG4gICAgICAgICAgICAgICAgICAgIGlzU3RpY2t5OiBzdGlja3lIZWFkZXJEYXRlcyxcclxuICAgICAgICAgICAgICAgICAgICBjaHVua3M6IFt7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXk6ICdtYWluJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsUmVmOiB0aGlzLmhlYWRlckVsUmVmLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFibGVDbGFzc05hbWU6ICdmYy1jb2wtaGVhZGVyJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvd0NvbnRlbnQ6IGhlYWRlclJvd0NvbnRlbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1dLFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc2VjdGlvbnMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiAnYm9keScsXHJcbiAgICAgICAgICAgICAgICBrZXk6ICdib2R5JyxcclxuICAgICAgICAgICAgICAgIGxpcXVpZDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGNodW5rczogW3tcclxuICAgICAgICAgICAgICAgICAgICAgICAga2V5OiAnbWFpbicsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IGJvZHlDb250ZW50LFxyXG4gICAgICAgICAgICAgICAgICAgIH1dLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgaWYgKHN0aWNreUZvb3RlclNjcm9sbGJhcikge1xyXG4gICAgICAgICAgICAgICAgc2VjdGlvbnMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2Zvb3RlcicsXHJcbiAgICAgICAgICAgICAgICAgICAga2V5OiAnZm9vdGVyJyxcclxuICAgICAgICAgICAgICAgICAgICBpc1N0aWNreTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICBjaHVua3M6IFt7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXk6ICdtYWluJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHJlbmRlclNjcm9sbFNoaW0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1dLFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuICh5KFZpZXdDb250YWluZXIsIHsgZWxDbGFzc2VzOiBbJ2ZjLWRheWdyaWQnXSwgdmlld1NwZWM6IGNvbnRleHQudmlld1NwZWMgfSxcclxuICAgICAgICAgICAgICAgIHkoU2Nyb2xsR3JpZCwgeyBsaXF1aWQ6ICFwcm9wcy5pc0hlaWdodEF1dG8gJiYgIXByb3BzLmZvclByaW50LCBmb3JQcmludDogcHJvcHMuZm9yUHJpbnQsIGNvbGxhcHNpYmxlV2lkdGg6IHByb3BzLmZvclByaW50LCBjb2xHcm91cHM6IFt7IGNvbHM6IFt7IHNwYW46IGNvbENudCwgbWluV2lkdGg6IGRheU1pbldpZHRoIH1dIH1dLCBzZWN0aW9uczogc2VjdGlvbnMgfSkpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY2xhc3MgRGF5VGFibGVWaWV3IGV4dGVuZHMgVGFibGVWaWV3IHtcclxuICAgICAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgdGhpcy5idWlsZERheVRhYmxlTW9kZWwgPSBtZW1vaXplKGJ1aWxkRGF5VGFibGVNb2RlbCk7XHJcbiAgICAgICAgICAgIHRoaXMuaGVhZGVyUmVmID0gZCgpO1xyXG4gICAgICAgICAgICB0aGlzLnRhYmxlUmVmID0gZCgpO1xyXG4gICAgICAgICAgICAvLyBjYW4ndCBvdmVycmlkZSBhbnkgbGlmZWN5Y2xlIG1ldGhvZHMgZnJvbSBwYXJlbnRcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVuZGVyKCkge1xyXG4gICAgICAgICAgICBsZXQgeyBvcHRpb25zLCBkYXRlUHJvZmlsZUdlbmVyYXRvciB9ID0gdGhpcy5jb250ZXh0O1xyXG4gICAgICAgICAgICBsZXQgeyBwcm9wcyB9ID0gdGhpcztcclxuICAgICAgICAgICAgbGV0IGRheVRhYmxlTW9kZWwgPSB0aGlzLmJ1aWxkRGF5VGFibGVNb2RlbChwcm9wcy5kYXRlUHJvZmlsZSwgZGF0ZVByb2ZpbGVHZW5lcmF0b3IpO1xyXG4gICAgICAgICAgICBsZXQgaGVhZGVyQ29udGVudCA9IG9wdGlvbnMuZGF5SGVhZGVycyAmJiAoeShEYXlIZWFkZXIsIHsgcmVmOiB0aGlzLmhlYWRlclJlZiwgZGF0ZVByb2ZpbGU6IHByb3BzLmRhdGVQcm9maWxlLCBkYXRlczogZGF5VGFibGVNb2RlbC5oZWFkZXJEYXRlcywgZGF0ZXNSZXBEaXN0aW5jdERheXM6IGRheVRhYmxlTW9kZWwucm93Q250ID09PSAxIH0pKTtcclxuICAgICAgICAgICAgbGV0IGJvZHlDb250ZW50ID0gKGNvbnRlbnRBcmcpID0+ICh5KERheVRhYmxlLCB7IHJlZjogdGhpcy50YWJsZVJlZiwgZGF0ZVByb2ZpbGU6IHByb3BzLmRhdGVQcm9maWxlLCBkYXlUYWJsZU1vZGVsOiBkYXlUYWJsZU1vZGVsLCBidXNpbmVzc0hvdXJzOiBwcm9wcy5idXNpbmVzc0hvdXJzLCBkYXRlU2VsZWN0aW9uOiBwcm9wcy5kYXRlU2VsZWN0aW9uLCBldmVudFN0b3JlOiBwcm9wcy5ldmVudFN0b3JlLCBldmVudFVpQmFzZXM6IHByb3BzLmV2ZW50VWlCYXNlcywgZXZlbnRTZWxlY3Rpb246IHByb3BzLmV2ZW50U2VsZWN0aW9uLCBldmVudERyYWc6IHByb3BzLmV2ZW50RHJhZywgZXZlbnRSZXNpemU6IHByb3BzLmV2ZW50UmVzaXplLCBuZXh0RGF5VGhyZXNob2xkOiBvcHRpb25zLm5leHREYXlUaHJlc2hvbGQsIGNvbEdyb3VwTm9kZTogY29udGVudEFyZy50YWJsZUNvbEdyb3VwTm9kZSwgdGFibGVNaW5XaWR0aDogY29udGVudEFyZy50YWJsZU1pbldpZHRoLCBkYXlNYXhFdmVudHM6IG9wdGlvbnMuZGF5TWF4RXZlbnRzLCBkYXlNYXhFdmVudFJvd3M6IG9wdGlvbnMuZGF5TWF4RXZlbnRSb3dzLCBzaG93V2Vla051bWJlcnM6IG9wdGlvbnMud2Vla051bWJlcnMsIGV4cGFuZFJvd3M6ICFwcm9wcy5pc0hlaWdodEF1dG8sIGhlYWRlckFsaWduRWxSZWY6IHRoaXMuaGVhZGVyRWxSZWYsIGNsaWVudFdpZHRoOiBjb250ZW50QXJnLmNsaWVudFdpZHRoLCBjbGllbnRIZWlnaHQ6IGNvbnRlbnRBcmcuY2xpZW50SGVpZ2h0LCBmb3JQcmludDogcHJvcHMuZm9yUHJpbnQgfSkpO1xyXG4gICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5kYXlNaW5XaWR0aFxyXG4gICAgICAgICAgICAgICAgPyB0aGlzLnJlbmRlckhTY3JvbGxMYXlvdXQoaGVhZGVyQ29udGVudCwgYm9keUNvbnRlbnQsIGRheVRhYmxlTW9kZWwuY29sQ250LCBvcHRpb25zLmRheU1pbldpZHRoKVxyXG4gICAgICAgICAgICAgICAgOiB0aGlzLnJlbmRlclNpbXBsZUxheW91dChoZWFkZXJDb250ZW50LCBib2R5Q29udGVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYnVpbGREYXlUYWJsZU1vZGVsKGRhdGVQcm9maWxlLCBkYXRlUHJvZmlsZUdlbmVyYXRvcikge1xyXG4gICAgICAgIGxldCBkYXlTZXJpZXMgPSBuZXcgRGF5U2VyaWVzTW9kZWwoZGF0ZVByb2ZpbGUucmVuZGVyUmFuZ2UsIGRhdGVQcm9maWxlR2VuZXJhdG9yKTtcclxuICAgICAgICByZXR1cm4gbmV3IERheVRhYmxlTW9kZWwoZGF5U2VyaWVzLCAveWVhcnxtb250aHx3ZWVrLy50ZXN0KGRhdGVQcm9maWxlLmN1cnJlbnRSYW5nZVVuaXQpKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgaW5kZXgkMyA9IGNyZWF0ZVBsdWdpbih7XHJcbiAgICAgICAgbmFtZTogJ0BmdWxsY2FsZW5kYXIvZGF5Z3JpZCcsXHJcbiAgICAgICAgaW5pdGlhbFZpZXc6ICdkYXlHcmlkTW9udGgnLFxyXG4gICAgICAgIHZpZXdzOiB7XHJcbiAgICAgICAgICAgIGRheUdyaWQ6IHtcclxuICAgICAgICAgICAgICAgIGNvbXBvbmVudDogRGF5VGFibGVWaWV3LFxyXG4gICAgICAgICAgICAgICAgZGF0ZVByb2ZpbGVHZW5lcmF0b3JDbGFzczogVGFibGVEYXRlUHJvZmlsZUdlbmVyYXRvcixcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZGF5R3JpZERheToge1xyXG4gICAgICAgICAgICAgICAgdHlwZTogJ2RheUdyaWQnLFxyXG4gICAgICAgICAgICAgICAgZHVyYXRpb246IHsgZGF5czogMSB9LFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBkYXlHcmlkV2Vlazoge1xyXG4gICAgICAgICAgICAgICAgdHlwZTogJ2RheUdyaWQnLFxyXG4gICAgICAgICAgICAgICAgZHVyYXRpb246IHsgd2Vla3M6IDEgfSxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZGF5R3JpZE1vbnRoOiB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiAnZGF5R3JpZCcsXHJcbiAgICAgICAgICAgICAgICBkdXJhdGlvbjogeyBtb250aHM6IDEgfSxcclxuICAgICAgICAgICAgICAgIGZpeGVkV2Vla0NvdW50OiB0cnVlLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBkYXlHcmlkWWVhcjoge1xyXG4gICAgICAgICAgICAgICAgdHlwZTogJ2RheUdyaWQnLFxyXG4gICAgICAgICAgICAgICAgZHVyYXRpb246IHsgeWVhcnM6IDEgfSxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9LFxyXG4gICAgfSk7XHJcblxyXG4gICAgdmFyIGNzc18yNDh6JDIgPSBcIi5mYy12LWV2ZW50e2JhY2tncm91bmQtY29sb3I6dmFyKC0tZmMtZXZlbnQtYmctY29sb3IpO2JvcmRlcjoxcHggc29saWQgdmFyKC0tZmMtZXZlbnQtYm9yZGVyLWNvbG9yKTtkaXNwbGF5OmJsb2NrfS5mYy12LWV2ZW50IC5mYy1ldmVudC1tYWlue2NvbG9yOnZhcigtLWZjLWV2ZW50LXRleHQtY29sb3IpO2hlaWdodDoxMDAlfS5mYy12LWV2ZW50IC5mYy1ldmVudC1tYWluLWZyYW1le2Rpc3BsYXk6ZmxleDtmbGV4LWRpcmVjdGlvbjpjb2x1bW47aGVpZ2h0OjEwMCV9LmZjLXYtZXZlbnQgLmZjLWV2ZW50LXRpbWV7ZmxleC1ncm93OjA7ZmxleC1zaHJpbms6MDttYXgtaGVpZ2h0OjEwMCU7b3ZlcmZsb3c6aGlkZGVufS5mYy12LWV2ZW50IC5mYy1ldmVudC10aXRsZS1jb250YWluZXJ7ZmxleC1ncm93OjE7ZmxleC1zaHJpbms6MTttaW4taGVpZ2h0OjB9LmZjLXYtZXZlbnQgLmZjLWV2ZW50LXRpdGxle2JvdHRvbTowO21heC1oZWlnaHQ6MTAwJTtvdmVyZmxvdzpoaWRkZW47dG9wOjB9LmZjLXYtZXZlbnQ6bm90KC5mYy1ldmVudC1zdGFydCl7Ym9yZGVyLXRvcC1sZWZ0LXJhZGl1czowO2JvcmRlci10b3AtcmlnaHQtcmFkaXVzOjA7Ym9yZGVyLXRvcC13aWR0aDowfS5mYy12LWV2ZW50Om5vdCguZmMtZXZlbnQtZW5kKXtib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOjA7Ym9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6MDtib3JkZXItYm90dG9tLXdpZHRoOjB9LmZjLXYtZXZlbnQuZmMtZXZlbnQtc2VsZWN0ZWQ6YmVmb3Jle2xlZnQ6LTEwcHg7cmlnaHQ6LTEwcHh9LmZjLXYtZXZlbnQgLmZjLWV2ZW50LXJlc2l6ZXItc3RhcnR7Y3Vyc29yOm4tcmVzaXplfS5mYy12LWV2ZW50IC5mYy1ldmVudC1yZXNpemVyLWVuZHtjdXJzb3I6cy1yZXNpemV9LmZjLXYtZXZlbnQ6bm90KC5mYy1ldmVudC1zZWxlY3RlZCkgLmZjLWV2ZW50LXJlc2l6ZXJ7aGVpZ2h0OnZhcigtLWZjLWV2ZW50LXJlc2l6ZXItdGhpY2tuZXNzKTtsZWZ0OjA7cmlnaHQ6MH0uZmMtdi1ldmVudDpub3QoLmZjLWV2ZW50LXNlbGVjdGVkKSAuZmMtZXZlbnQtcmVzaXplci1zdGFydHt0b3A6Y2FsYyh2YXIoLS1mYy1ldmVudC1yZXNpemVyLXRoaWNrbmVzcykvLTIpfS5mYy12LWV2ZW50Om5vdCguZmMtZXZlbnQtc2VsZWN0ZWQpIC5mYy1ldmVudC1yZXNpemVyLWVuZHtib3R0b206Y2FsYyh2YXIoLS1mYy1ldmVudC1yZXNpemVyLXRoaWNrbmVzcykvLTIpfS5mYy12LWV2ZW50LmZjLWV2ZW50LXNlbGVjdGVkIC5mYy1ldmVudC1yZXNpemVye2xlZnQ6NTAlO21hcmdpbi1sZWZ0OmNhbGModmFyKC0tZmMtZXZlbnQtcmVzaXplci1kb3QtdG90YWwtd2lkdGgpLy0yKX0uZmMtdi1ldmVudC5mYy1ldmVudC1zZWxlY3RlZCAuZmMtZXZlbnQtcmVzaXplci1zdGFydHt0b3A6Y2FsYyh2YXIoLS1mYy1ldmVudC1yZXNpemVyLWRvdC10b3RhbC13aWR0aCkvLTIpfS5mYy12LWV2ZW50LmZjLWV2ZW50LXNlbGVjdGVkIC5mYy1ldmVudC1yZXNpemVyLWVuZHtib3R0b206Y2FsYyh2YXIoLS1mYy1ldmVudC1yZXNpemVyLWRvdC10b3RhbC13aWR0aCkvLTIpfS5mYyAuZmMtdGltZWdyaWQgLmZjLWRheWdyaWQtYm9keXt6LWluZGV4OjJ9LmZjIC5mYy10aW1lZ3JpZC1kaXZpZGVye3BhZGRpbmc6MCAwIDJweH0uZmMgLmZjLXRpbWVncmlkLWJvZHl7bWluLWhlaWdodDoxMDAlO3Bvc2l0aW9uOnJlbGF0aXZlO3otaW5kZXg6MX0uZmMgLmZjLXRpbWVncmlkLWF4aXMtY2h1bmt7cG9zaXRpb246cmVsYXRpdmV9LmZjIC5mYy10aW1lZ3JpZC1heGlzLWNodW5rPnRhYmxlLC5mYyAuZmMtdGltZWdyaWQtc2xvdHN7cG9zaXRpb246cmVsYXRpdmU7ei1pbmRleDoxfS5mYyAuZmMtdGltZWdyaWQtc2xvdHtib3JkZXItYm90dG9tOjA7aGVpZ2h0OjEuNWVtfS5mYyAuZmMtdGltZWdyaWQtc2xvdDplbXB0eTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXDAwYTBcXFwifS5mYyAuZmMtdGltZWdyaWQtc2xvdC1taW5vcntib3JkZXItdG9wLXN0eWxlOmRvdHRlZH0uZmMgLmZjLXRpbWVncmlkLXNsb3QtbGFiZWwtY3VzaGlvbntkaXNwbGF5OmlubGluZS1ibG9jazt3aGl0ZS1zcGFjZTpub3dyYXB9LmZjIC5mYy10aW1lZ3JpZC1zbG90LWxhYmVse3ZlcnRpY2FsLWFsaWduOm1pZGRsZX0uZmMgLmZjLXRpbWVncmlkLWF4aXMtY3VzaGlvbiwuZmMgLmZjLXRpbWVncmlkLXNsb3QtbGFiZWwtY3VzaGlvbntwYWRkaW5nOjAgNHB4fS5mYyAuZmMtdGltZWdyaWQtYXhpcy1mcmFtZS1saXF1aWR7aGVpZ2h0OjEwMCV9LmZjIC5mYy10aW1lZ3JpZC1heGlzLWZyYW1le2FsaWduLWl0ZW1zOmNlbnRlcjtkaXNwbGF5OmZsZXg7anVzdGlmeS1jb250ZW50OmZsZXgtZW5kO292ZXJmbG93OmhpZGRlbn0uZmMgLmZjLXRpbWVncmlkLWF4aXMtY3VzaGlvbntmbGV4LXNocmluazowO21heC13aWR0aDo2MHB4fS5mYy1kaXJlY3Rpb24tbHRyIC5mYy10aW1lZ3JpZC1zbG90LWxhYmVsLWZyYW1le3RleHQtYWxpZ246cmlnaHR9LmZjLWRpcmVjdGlvbi1ydGwgLmZjLXRpbWVncmlkLXNsb3QtbGFiZWwtZnJhbWV7dGV4dC1hbGlnbjpsZWZ0fS5mYy1saXF1aWQtaGFjayAuZmMtdGltZWdyaWQtYXhpcy1mcmFtZS1saXF1aWR7Ym90dG9tOjA7aGVpZ2h0OmF1dG87bGVmdDowO3Bvc2l0aW9uOmFic29sdXRlO3JpZ2h0OjA7dG9wOjB9LmZjIC5mYy10aW1lZ3JpZC1jb2wuZmMtZGF5LXRvZGF5e2JhY2tncm91bmQtY29sb3I6dmFyKC0tZmMtdG9kYXktYmctY29sb3IpfS5mYyAuZmMtdGltZWdyaWQtY29sLWZyYW1le21pbi1oZWlnaHQ6MTAwJTtwb3NpdGlvbjpyZWxhdGl2ZX0uZmMtbWVkaWEtc2NyZWVuLmZjLWxpcXVpZC1oYWNrIC5mYy10aW1lZ3JpZC1jb2wtZnJhbWV7Ym90dG9tOjA7aGVpZ2h0OmF1dG87bGVmdDowO3Bvc2l0aW9uOmFic29sdXRlO3JpZ2h0OjA7dG9wOjB9LmZjLW1lZGlhLXNjcmVlbiAuZmMtdGltZWdyaWQtY29sc3tib3R0b206MDtsZWZ0OjA7cG9zaXRpb246YWJzb2x1dGU7cmlnaHQ6MDt0b3A6MH0uZmMtbWVkaWEtc2NyZWVuIC5mYy10aW1lZ3JpZC1jb2xzPnRhYmxle2hlaWdodDoxMDAlfS5mYy1tZWRpYS1zY3JlZW4gLmZjLXRpbWVncmlkLWNvbC1iZywuZmMtbWVkaWEtc2NyZWVuIC5mYy10aW1lZ3JpZC1jb2wtZXZlbnRzLC5mYy1tZWRpYS1zY3JlZW4gLmZjLXRpbWVncmlkLW5vdy1pbmRpY2F0b3ItY29udGFpbmVye2xlZnQ6MDtwb3NpdGlvbjphYnNvbHV0ZTtyaWdodDowO3RvcDowfS5mYyAuZmMtdGltZWdyaWQtY29sLWJne3otaW5kZXg6Mn0uZmMgLmZjLXRpbWVncmlkLWNvbC1iZyAuZmMtbm9uLWJ1c2luZXNze3otaW5kZXg6MX0uZmMgLmZjLXRpbWVncmlkLWNvbC1iZyAuZmMtYmctZXZlbnR7ei1pbmRleDoyfS5mYyAuZmMtdGltZWdyaWQtY29sLWJnIC5mYy1oaWdobGlnaHR7ei1pbmRleDozfS5mYyAuZmMtdGltZWdyaWQtYmctaGFybmVzc3tsZWZ0OjA7cG9zaXRpb246YWJzb2x1dGU7cmlnaHQ6MH0uZmMgLmZjLXRpbWVncmlkLWNvbC1ldmVudHN7ei1pbmRleDozfS5mYyAuZmMtdGltZWdyaWQtbm93LWluZGljYXRvci1jb250YWluZXJ7Ym90dG9tOjA7b3ZlcmZsb3c6aGlkZGVufS5mYy1kaXJlY3Rpb24tbHRyIC5mYy10aW1lZ3JpZC1jb2wtZXZlbnRze21hcmdpbjowIDIuNSUgMCAycHh9LmZjLWRpcmVjdGlvbi1ydGwgLmZjLXRpbWVncmlkLWNvbC1ldmVudHN7bWFyZ2luOjAgMnB4IDAgMi41JX0uZmMtdGltZWdyaWQtZXZlbnQtaGFybmVzc3twb3NpdGlvbjphYnNvbHV0ZX0uZmMtdGltZWdyaWQtZXZlbnQtaGFybmVzcz4uZmMtdGltZWdyaWQtZXZlbnR7Ym90dG9tOjA7bGVmdDowO3Bvc2l0aW9uOmFic29sdXRlO3JpZ2h0OjA7dG9wOjB9LmZjLXRpbWVncmlkLWV2ZW50LWhhcm5lc3MtaW5zZXQgLmZjLXRpbWVncmlkLWV2ZW50LC5mYy10aW1lZ3JpZC1ldmVudC5mYy1ldmVudC1taXJyb3IsLmZjLXRpbWVncmlkLW1vcmUtbGlua3tib3gtc2hhZG93OjAgMCAwIDFweCB2YXIoLS1mYy1wYWdlLWJnLWNvbG9yKX0uZmMtdGltZWdyaWQtZXZlbnQsLmZjLXRpbWVncmlkLW1vcmUtbGlua3tib3JkZXItcmFkaXVzOjNweDtmb250LXNpemU6dmFyKC0tZmMtc21hbGwtZm9udC1zaXplKX0uZmMtdGltZWdyaWQtZXZlbnR7bWFyZ2luLWJvdHRvbToxcHh9LmZjLXRpbWVncmlkLWV2ZW50IC5mYy1ldmVudC1tYWlue3BhZGRpbmc6MXB4IDFweCAwfS5mYy10aW1lZ3JpZC1ldmVudCAuZmMtZXZlbnQtdGltZXtmb250LXNpemU6dmFyKC0tZmMtc21hbGwtZm9udC1zaXplKTttYXJnaW4tYm90dG9tOjFweDt3aGl0ZS1zcGFjZTpub3dyYXB9LmZjLXRpbWVncmlkLWV2ZW50LXNob3J0IC5mYy1ldmVudC1tYWluLWZyYW1le2ZsZXgtZGlyZWN0aW9uOnJvdztvdmVyZmxvdzpoaWRkZW59LmZjLXRpbWVncmlkLWV2ZW50LXNob3J0IC5mYy1ldmVudC10aW1lOmFmdGVye2NvbnRlbnQ6XFxcIlxcXFwwMGEwLVxcXFwwMGEwXFxcIn0uZmMtdGltZWdyaWQtZXZlbnQtc2hvcnQgLmZjLWV2ZW50LXRpdGxle2ZvbnQtc2l6ZTp2YXIoLS1mYy1zbWFsbC1mb250LXNpemUpfS5mYy10aW1lZ3JpZC1tb3JlLWxpbmt7YmFja2dyb3VuZDp2YXIoLS1mYy1tb3JlLWxpbmstYmctY29sb3IpO2NvbG9yOnZhcigtLWZjLW1vcmUtbGluay10ZXh0LWNvbG9yKTtjdXJzb3I6cG9pbnRlcjttYXJnaW4tYm90dG9tOjFweDtwb3NpdGlvbjphYnNvbHV0ZTt6LWluZGV4Ojk5OTl9LmZjLXRpbWVncmlkLW1vcmUtbGluay1pbm5lcntwYWRkaW5nOjNweCAycHg7dG9wOjB9LmZjLWRpcmVjdGlvbi1sdHIgLmZjLXRpbWVncmlkLW1vcmUtbGlua3tyaWdodDowfS5mYy1kaXJlY3Rpb24tcnRsIC5mYy10aW1lZ3JpZC1tb3JlLWxpbmt7bGVmdDowfS5mYyAuZmMtdGltZWdyaWQtbm93LWluZGljYXRvci1saW5le2JvcmRlci1jb2xvcjp2YXIoLS1mYy1ub3ctaW5kaWNhdG9yLWNvbG9yKTtib3JkZXItc3R5bGU6c29saWQ7Ym9yZGVyLXdpZHRoOjFweCAwIDA7bGVmdDowO3Bvc2l0aW9uOmFic29sdXRlO3JpZ2h0OjA7ei1pbmRleDo0fS5mYyAuZmMtdGltZWdyaWQtbm93LWluZGljYXRvci1hcnJvd3tib3JkZXItY29sb3I6dmFyKC0tZmMtbm93LWluZGljYXRvci1jb2xvcik7Ym9yZGVyLXN0eWxlOnNvbGlkO21hcmdpbi10b3A6LTVweDtwb3NpdGlvbjphYnNvbHV0ZTt6LWluZGV4OjR9LmZjLWRpcmVjdGlvbi1sdHIgLmZjLXRpbWVncmlkLW5vdy1pbmRpY2F0b3ItYXJyb3d7Ym9yZGVyLWJvdHRvbS1jb2xvcjp0cmFuc3BhcmVudDtib3JkZXItdG9wLWNvbG9yOnRyYW5zcGFyZW50O2JvcmRlci13aWR0aDo1cHggMCA1cHggNnB4O2xlZnQ6MH0uZmMtZGlyZWN0aW9uLXJ0bCAuZmMtdGltZWdyaWQtbm93LWluZGljYXRvci1hcnJvd3tib3JkZXItYm90dG9tLWNvbG9yOnRyYW5zcGFyZW50O2JvcmRlci10b3AtY29sb3I6dHJhbnNwYXJlbnQ7Ym9yZGVyLXdpZHRoOjVweCA2cHggNXB4IDA7cmlnaHQ6MH1cIjtcclxuICAgIGluamVjdFN0eWxlcyhjc3NfMjQ4eiQyKTtcclxuXHJcbiAgICBjbGFzcyBBbGxEYXlTcGxpdHRlciBleHRlbmRzIFNwbGl0dGVyIHtcclxuICAgICAgICBnZXRLZXlJbmZvKCkge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgYWxsRGF5OiB7fSxcclxuICAgICAgICAgICAgICAgIHRpbWVkOiB7fSxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZ2V0S2V5c0ZvckRhdGVTcGFuKGRhdGVTcGFuKSB7XHJcbiAgICAgICAgICAgIGlmIChkYXRlU3Bhbi5hbGxEYXkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBbJ2FsbERheSddO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBbJ3RpbWVkJ107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGdldEtleXNGb3JFdmVudERlZihldmVudERlZikge1xyXG4gICAgICAgICAgICBpZiAoIWV2ZW50RGVmLmFsbERheSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFsndGltZWQnXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoaGFzQmdSZW5kZXJpbmcoZXZlbnREZWYpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gWyd0aW1lZCcsICdhbGxEYXknXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gWydhbGxEYXknXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgREVGQVVMVF9TTEFUX0xBQkVMX0ZPUk1BVCA9IGNyZWF0ZUZvcm1hdHRlcih7XHJcbiAgICAgICAgaG91cjogJ251bWVyaWMnLFxyXG4gICAgICAgIG1pbnV0ZTogJzItZGlnaXQnLFxyXG4gICAgICAgIG9taXRaZXJvTWludXRlOiB0cnVlLFxyXG4gICAgICAgIG1lcmlkaWVtOiAnc2hvcnQnLFxyXG4gICAgfSk7XHJcbiAgICBmdW5jdGlvbiBUaW1lQ29sc0F4aXNDZWxsKHByb3BzKSB7XHJcbiAgICAgICAgbGV0IGNsYXNzTmFtZXMgPSBbXHJcbiAgICAgICAgICAgICdmYy10aW1lZ3JpZC1zbG90JyxcclxuICAgICAgICAgICAgJ2ZjLXRpbWVncmlkLXNsb3QtbGFiZWwnLFxyXG4gICAgICAgICAgICBwcm9wcy5pc0xhYmVsZWQgPyAnZmMtc2Nyb2xsZ3JpZC1zaHJpbmsnIDogJ2ZjLXRpbWVncmlkLXNsb3QtbWlub3InLFxyXG4gICAgICAgIF07XHJcbiAgICAgICAgcmV0dXJuICh5KFZpZXdDb250ZXh0VHlwZS5Db25zdW1lciwgbnVsbCwgKGNvbnRleHQpID0+IHtcclxuICAgICAgICAgICAgaWYgKCFwcm9wcy5pc0xhYmVsZWQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAoeShcInRkXCIsIHsgY2xhc3NOYW1lOiBjbGFzc05hbWVzLmpvaW4oJyAnKSwgXCJkYXRhLXRpbWVcIjogcHJvcHMuaXNvVGltZVN0ciB9KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IHsgZGF0ZUVudiwgb3B0aW9ucywgdmlld0FwaSB9ID0gY29udGV4dDtcclxuICAgICAgICAgICAgbGV0IGxhYmVsRm9ybWF0ID0gLy8gVE9ETzogZnVsbHkgcHJlLXBhcnNlXHJcbiAgICAgICAgICAgICBvcHRpb25zLnNsb3RMYWJlbEZvcm1hdCA9PSBudWxsID8gREVGQVVMVF9TTEFUX0xBQkVMX0ZPUk1BVCA6XHJcbiAgICAgICAgICAgICAgICBBcnJheS5pc0FycmF5KG9wdGlvbnMuc2xvdExhYmVsRm9ybWF0KSA/IGNyZWF0ZUZvcm1hdHRlcihvcHRpb25zLnNsb3RMYWJlbEZvcm1hdFswXSkgOlxyXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZUZvcm1hdHRlcihvcHRpb25zLnNsb3RMYWJlbEZvcm1hdCk7XHJcbiAgICAgICAgICAgIGxldCByZW5kZXJQcm9wcyA9IHtcclxuICAgICAgICAgICAgICAgIGxldmVsOiAwLFxyXG4gICAgICAgICAgICAgICAgdGltZTogcHJvcHMudGltZSxcclxuICAgICAgICAgICAgICAgIGRhdGU6IGRhdGVFbnYudG9EYXRlKHByb3BzLmRhdGUpLFxyXG4gICAgICAgICAgICAgICAgdmlldzogdmlld0FwaSxcclxuICAgICAgICAgICAgICAgIHRleHQ6IGRhdGVFbnYuZm9ybWF0KHByb3BzLmRhdGUsIGxhYmVsRm9ybWF0KSxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuICh5KENvbnRlbnRDb250YWluZXIsIHsgZWxUYWc6IFwidGRcIiwgZWxDbGFzc2VzOiBjbGFzc05hbWVzLCBlbEF0dHJzOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgJ2RhdGEtdGltZSc6IHByb3BzLmlzb1RpbWVTdHIsXHJcbiAgICAgICAgICAgICAgICB9LCByZW5kZXJQcm9wczogcmVuZGVyUHJvcHMsIGdlbmVyYXRvck5hbWU6IFwic2xvdExhYmVsQ29udGVudFwiLCBjdXN0b21HZW5lcmF0b3I6IG9wdGlvbnMuc2xvdExhYmVsQ29udGVudCwgZGVmYXVsdEdlbmVyYXRvcjogcmVuZGVySW5uZXJDb250ZW50JDEsIGNsYXNzTmFtZUdlbmVyYXRvcjogb3B0aW9ucy5zbG90TGFiZWxDbGFzc05hbWVzLCBkaWRNb3VudDogb3B0aW9ucy5zbG90TGFiZWxEaWRNb3VudCwgd2lsbFVubW91bnQ6IG9wdGlvbnMuc2xvdExhYmVsV2lsbFVubW91bnQgfSwgKElubmVyQ29udGVudCkgPT4gKHkoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtdGltZWdyaWQtc2xvdC1sYWJlbC1mcmFtZSBmYy1zY3JvbGxncmlkLXNocmluay1mcmFtZVwiIH0sXHJcbiAgICAgICAgICAgICAgICB5KElubmVyQ29udGVudCwgeyBlbFRhZzogXCJkaXZcIiwgZWxDbGFzc2VzOiBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdmYy10aW1lZ3JpZC1zbG90LWxhYmVsLWN1c2hpb24nLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAnZmMtc2Nyb2xsZ3JpZC1zaHJpbmstY3VzaGlvbicsXHJcbiAgICAgICAgICAgICAgICAgICAgXSB9KSkpKSk7XHJcbiAgICAgICAgfSkpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gcmVuZGVySW5uZXJDb250ZW50JDEocHJvcHMpIHtcclxuICAgICAgICByZXR1cm4gcHJvcHMudGV4dDtcclxuICAgIH1cclxuXHJcbiAgICBjbGFzcyBUaW1lQm9keUF4aXMgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcclxuICAgICAgICByZW5kZXIoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb3BzLnNsYXRNZXRhcy5tYXAoKHNsYXRNZXRhKSA9PiAoeShcInRyXCIsIHsga2V5OiBzbGF0TWV0YS5rZXkgfSxcclxuICAgICAgICAgICAgICAgIHkoVGltZUNvbHNBeGlzQ2VsbCwgT2JqZWN0LmFzc2lnbih7fSwgc2xhdE1ldGEpKSkpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgREVGQVVMVF9XRUVLX05VTV9GT1JNQVQgPSBjcmVhdGVGb3JtYXR0ZXIoeyB3ZWVrOiAnc2hvcnQnIH0pO1xyXG4gICAgY29uc3QgQVVUT19BTExfREFZX01BWF9FVkVOVF9ST1dTID0gNTtcclxuICAgIGNsYXNzIFRpbWVDb2xzVmlldyBleHRlbmRzIERhdGVDb21wb25lbnQge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgICAgICB0aGlzLmFsbERheVNwbGl0dGVyID0gbmV3IEFsbERheVNwbGl0dGVyKCk7IC8vIGZvciB1c2UgYnkgc3ViY2xhc3Nlc1xyXG4gICAgICAgICAgICB0aGlzLmhlYWRlckVsUmVmID0gZCgpO1xyXG4gICAgICAgICAgICB0aGlzLnJvb3RFbFJlZiA9IGQoKTtcclxuICAgICAgICAgICAgdGhpcy5zY3JvbGxlckVsUmVmID0gZCgpO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0ge1xyXG4gICAgICAgICAgICAgICAgc2xhdENvb3JkczogbnVsbCxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdGhpcy5oYW5kbGVTY3JvbGxUb3BSZXF1ZXN0ID0gKHNjcm9sbFRvcCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgbGV0IHNjcm9sbGVyRWwgPSB0aGlzLnNjcm9sbGVyRWxSZWYuY3VycmVudDtcclxuICAgICAgICAgICAgICAgIGlmIChzY3JvbGxlckVsKSB7IC8vIFRPRE86IG5vdCBzdXJlIGhvdyB0aGlzIGNvdWxkIGV2ZXIgYmUgbnVsbC4gd2VpcmRuZXNzIHdpdGggdGhlIHJlZHVjZXJcclxuICAgICAgICAgICAgICAgICAgICBzY3JvbGxlckVsLnNjcm9sbFRvcCA9IHNjcm9sbFRvcDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyogSGVhZGVyIFJlbmRlciBNZXRob2RzXHJcbiAgICAgICAgICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVySGVhZEF4aXMgPSAocm93S2V5LCBmcmFtZUhlaWdodCA9ICcnKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBsZXQgeyBvcHRpb25zIH0gPSB0aGlzLmNvbnRleHQ7XHJcbiAgICAgICAgICAgICAgICBsZXQgeyBkYXRlUHJvZmlsZSB9ID0gdGhpcy5wcm9wcztcclxuICAgICAgICAgICAgICAgIGxldCByYW5nZSA9IGRhdGVQcm9maWxlLnJlbmRlclJhbmdlO1xyXG4gICAgICAgICAgICAgICAgbGV0IGRheUNudCA9IGRpZmZEYXlzKHJhbmdlLnN0YXJ0LCByYW5nZS5lbmQpO1xyXG4gICAgICAgICAgICAgICAgLy8gb25seSBkbyBpbiBkYXkgdmlld3MgKHRvIGF2b2lkIGRvaW5nIGluIHdlZWsgdmlld3MgdGhhdCBkb250IG5lZWQgaXQpXHJcbiAgICAgICAgICAgICAgICBsZXQgbmF2TGlua0F0dHJzID0gKGRheUNudCA9PT0gMSlcclxuICAgICAgICAgICAgICAgICAgICA/IGJ1aWxkTmF2TGlua0F0dHJzKHRoaXMuY29udGV4dCwgcmFuZ2Uuc3RhcnQsICd3ZWVrJylcclxuICAgICAgICAgICAgICAgICAgICA6IHt9O1xyXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMud2Vla051bWJlcnMgJiYgcm93S2V5ID09PSAnZGF5Jykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoeShXZWVrTnVtYmVyQ29udGFpbmVyLCB7IGVsVGFnOiBcInRoXCIsIGVsQ2xhc3NlczogW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2ZjLXRpbWVncmlkLWF4aXMnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2ZjLXNjcm9sbGdyaWQtc2hyaW5rJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgXSwgZWxBdHRyczoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2FyaWEtaGlkZGVuJzogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgZGF0ZTogcmFuZ2Uuc3RhcnQsIGRlZmF1bHRGb3JtYXQ6IERFRkFVTFRfV0VFS19OVU1fRk9STUFUIH0sIChJbm5lckNvbnRlbnQpID0+ICh5KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZmMtdGltZWdyaWQtYXhpcy1mcmFtZScsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZmMtc2Nyb2xsZ3JpZC1zaHJpbmstZnJhbWUnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2ZjLXRpbWVncmlkLWF4aXMtZnJhbWUtbGlxdWlkJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgXS5qb2luKCcgJyksIHN0eWxlOiB7IGhlaWdodDogZnJhbWVIZWlnaHQgfSB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB5KElubmVyQ29udGVudCwgeyBlbFRhZzogXCJhXCIsIGVsQ2xhc3NlczogW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdmYy10aW1lZ3JpZC1heGlzLWN1c2hpb24nLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdmYy1zY3JvbGxncmlkLXNocmluay1jdXNoaW9uJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZmMtc2Nyb2xsZ3JpZC1zeW5jLWlubmVyJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0sIGVsQXR0cnM6IG5hdkxpbmtBdHRycyB9KSkpKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKHkoXCJ0aFwiLCB7IFwiYXJpYS1oaWRkZW5cIjogdHJ1ZSwgY2xhc3NOYW1lOiBcImZjLXRpbWVncmlkLWF4aXNcIiB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHkoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtdGltZWdyaWQtYXhpcy1mcmFtZVwiLCBzdHlsZTogeyBoZWlnaHQ6IGZyYW1lSGVpZ2h0IH0gfSkpKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyogVGFibGUgQ29tcG9uZW50IFJlbmRlciBNZXRob2RzXHJcbiAgICAgICAgICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbiAgICAgICAgICAgIC8vIG9ubHkgYSBvbmUtd2F5IGhlaWdodCBzeW5jLiB3ZSBkb24ndCBzZW5kIHRoZSBheGlzIGlubmVyLWNvbnRlbnQgaGVpZ2h0IHRvIHRoZSBEYXlHcmlkLFxyXG4gICAgICAgICAgICAvLyBidXQgRGF5R3JpZCBzdGlsbCBuZWVkcyB0byBoYXZlIGNsYXNzTmFtZXMgb24gaW5uZXIgZWxlbWVudHMgaW4gb3JkZXIgdG8gbWVhc3VyZS5cclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJUYWJsZVJvd0F4aXMgPSAocm93SGVpZ2h0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBsZXQgeyBvcHRpb25zLCB2aWV3QXBpIH0gPSB0aGlzLmNvbnRleHQ7XHJcbiAgICAgICAgICAgICAgICBsZXQgcmVuZGVyUHJvcHMgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogb3B0aW9ucy5hbGxEYXlUZXh0LFxyXG4gICAgICAgICAgICAgICAgICAgIHZpZXc6IHZpZXdBcGksXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgICAgIC8vIFRPRE86IG1ha2UgcmV1c2FibGUgaG9vay4gdXNlZCBpbiBsaXN0IHZpZXcgdG9vXHJcbiAgICAgICAgICAgICAgICB5KENvbnRlbnRDb250YWluZXIsIHsgZWxUYWc6IFwidGRcIiwgZWxDbGFzc2VzOiBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdmYy10aW1lZ3JpZC1heGlzJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ2ZjLXNjcm9sbGdyaWQtc2hyaW5rJyxcclxuICAgICAgICAgICAgICAgICAgICBdLCBlbEF0dHJzOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdhcmlhLWhpZGRlbic6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgfSwgcmVuZGVyUHJvcHM6IHJlbmRlclByb3BzLCBnZW5lcmF0b3JOYW1lOiBcImFsbERheUNvbnRlbnRcIiwgY3VzdG9tR2VuZXJhdG9yOiBvcHRpb25zLmFsbERheUNvbnRlbnQsIGRlZmF1bHRHZW5lcmF0b3I6IHJlbmRlckFsbERheUlubmVyJDEsIGNsYXNzTmFtZUdlbmVyYXRvcjogb3B0aW9ucy5hbGxEYXlDbGFzc05hbWVzLCBkaWRNb3VudDogb3B0aW9ucy5hbGxEYXlEaWRNb3VudCwgd2lsbFVubW91bnQ6IG9wdGlvbnMuYWxsRGF5V2lsbFVubW91bnQgfSwgKElubmVyQ29udGVudCkgPT4gKHkoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ2ZjLXRpbWVncmlkLWF4aXMtZnJhbWUnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAnZmMtc2Nyb2xsZ3JpZC1zaHJpbmstZnJhbWUnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByb3dIZWlnaHQgPT0gbnVsbCA/ICcgZmMtdGltZWdyaWQtYXhpcy1mcmFtZS1saXF1aWQnIDogJycsXHJcbiAgICAgICAgICAgICAgICAgICAgXS5qb2luKCcgJyksIHN0eWxlOiB7IGhlaWdodDogcm93SGVpZ2h0IH0gfSxcclxuICAgICAgICAgICAgICAgICAgICB5KElubmVyQ29udGVudCwgeyBlbFRhZzogXCJzcGFuXCIsIGVsQ2xhc3NlczogW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2ZjLXRpbWVncmlkLWF4aXMtY3VzaGlvbicsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZmMtc2Nyb2xsZ3JpZC1zaHJpbmstY3VzaGlvbicsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZmMtc2Nyb2xsZ3JpZC1zeW5jLWlubmVyJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgXSB9KSkpKSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlU2xhdENvb3JkcyA9IChzbGF0Q29vcmRzKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKHsgc2xhdENvb3JkcyB9KTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gcmVuZGVyaW5nXHJcbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgICAgIHJlbmRlclNpbXBsZUxheW91dChoZWFkZXJSb3dDb250ZW50LCBhbGxEYXlDb250ZW50LCB0aW1lQ29udGVudCkge1xyXG4gICAgICAgICAgICBsZXQgeyBjb250ZXh0LCBwcm9wcyB9ID0gdGhpcztcclxuICAgICAgICAgICAgbGV0IHNlY3Rpb25zID0gW107XHJcbiAgICAgICAgICAgIGxldCBzdGlja3lIZWFkZXJEYXRlcyA9IGdldFN0aWNreUhlYWRlckRhdGVzKGNvbnRleHQub3B0aW9ucyk7XHJcbiAgICAgICAgICAgIGlmIChoZWFkZXJSb3dDb250ZW50KSB7XHJcbiAgICAgICAgICAgICAgICBzZWN0aW9ucy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnaGVhZGVyJyxcclxuICAgICAgICAgICAgICAgICAgICBrZXk6ICdoZWFkZXInLFxyXG4gICAgICAgICAgICAgICAgICAgIGlzU3RpY2t5OiBzdGlja3lIZWFkZXJEYXRlcyxcclxuICAgICAgICAgICAgICAgICAgICBjaHVuazoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbFJlZjogdGhpcy5oZWFkZXJFbFJlZixcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGFibGVDbGFzc05hbWU6ICdmYy1jb2wtaGVhZGVyJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcm93Q29udGVudDogaGVhZGVyUm93Q29udGVudCxcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGFsbERheUNvbnRlbnQpIHtcclxuICAgICAgICAgICAgICAgIHNlY3Rpb25zLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdib2R5JyxcclxuICAgICAgICAgICAgICAgICAgICBrZXk6ICdhbGwtZGF5JyxcclxuICAgICAgICAgICAgICAgICAgICBjaHVuazogeyBjb250ZW50OiBhbGxEYXlDb250ZW50IH0sXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHNlY3Rpb25zLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdib2R5JyxcclxuICAgICAgICAgICAgICAgICAgICBrZXk6ICdhbGwtZGF5LWRpdmlkZXInLFxyXG4gICAgICAgICAgICAgICAgICAgIG91dGVyQ29udGVudDogKCAvLyBUT0RPOiByZW5hbWUgdG8gY2VsbENvbnRlbnQgc28gZG9uJ3QgbmVlZCB0byBkZWZpbmUgPHRyPj9cclxuICAgICAgICAgICAgICAgICAgICB5KFwidHJcIiwgeyByb2xlOiBcInByZXNlbnRhdGlvblwiLCBjbGFzc05hbWU6IFwiZmMtc2Nyb2xsZ3JpZC1zZWN0aW9uXCIgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgeShcInRkXCIsIHsgY2xhc3NOYW1lOiAnZmMtdGltZWdyaWQtZGl2aWRlciAnICsgY29udGV4dC50aGVtZS5nZXRDbGFzcygndGFibGVDZWxsU2hhZGVkJykgfSkpKSxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHNlY3Rpb25zLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgdHlwZTogJ2JvZHknLFxyXG4gICAgICAgICAgICAgICAga2V5OiAnYm9keScsXHJcbiAgICAgICAgICAgICAgICBsaXF1aWQ6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBleHBhbmRSb3dzOiBCb29sZWFuKGNvbnRleHQub3B0aW9ucy5leHBhbmRSb3dzKSxcclxuICAgICAgICAgICAgICAgIGNodW5rOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsZXJFbFJlZjogdGhpcy5zY3JvbGxlckVsUmVmLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHRpbWVDb250ZW50LFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiAoeShWaWV3Q29udGFpbmVyLCB7IGVsUmVmOiB0aGlzLnJvb3RFbFJlZiwgZWxDbGFzc2VzOiBbJ2ZjLXRpbWVncmlkJ10sIHZpZXdTcGVjOiBjb250ZXh0LnZpZXdTcGVjIH0sXHJcbiAgICAgICAgICAgICAgICB5KFNpbXBsZVNjcm9sbEdyaWQsIHsgbGlxdWlkOiAhcHJvcHMuaXNIZWlnaHRBdXRvICYmICFwcm9wcy5mb3JQcmludCwgY29sbGFwc2libGVXaWR0aDogcHJvcHMuZm9yUHJpbnQsIGNvbHM6IFt7IHdpZHRoOiAnc2hyaW5rJyB9XSwgc2VjdGlvbnM6IHNlY3Rpb25zIH0pKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlbmRlckhTY3JvbGxMYXlvdXQoaGVhZGVyUm93Q29udGVudCwgYWxsRGF5Q29udGVudCwgdGltZUNvbnRlbnQsIGNvbENudCwgZGF5TWluV2lkdGgsIHNsYXRNZXRhcywgc2xhdENvb3Jkcykge1xyXG4gICAgICAgICAgICBsZXQgU2Nyb2xsR3JpZCA9IHRoaXMuY29udGV4dC5wbHVnaW5Ib29rcy5zY3JvbGxHcmlkSW1wbDtcclxuICAgICAgICAgICAgaWYgKCFTY3JvbGxHcmlkKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIFNjcm9sbEdyaWQgaW1wbGVtZW50YXRpb24nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgeyBjb250ZXh0LCBwcm9wcyB9ID0gdGhpcztcclxuICAgICAgICAgICAgbGV0IHN0aWNreUhlYWRlckRhdGVzID0gIXByb3BzLmZvclByaW50ICYmIGdldFN0aWNreUhlYWRlckRhdGVzKGNvbnRleHQub3B0aW9ucyk7XHJcbiAgICAgICAgICAgIGxldCBzdGlja3lGb290ZXJTY3JvbGxiYXIgPSAhcHJvcHMuZm9yUHJpbnQgJiYgZ2V0U3RpY2t5Rm9vdGVyU2Nyb2xsYmFyKGNvbnRleHQub3B0aW9ucyk7XHJcbiAgICAgICAgICAgIGxldCBzZWN0aW9ucyA9IFtdO1xyXG4gICAgICAgICAgICBpZiAoaGVhZGVyUm93Q29udGVudCkge1xyXG4gICAgICAgICAgICAgICAgc2VjdGlvbnMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2hlYWRlcicsXHJcbiAgICAgICAgICAgICAgICAgICAga2V5OiAnaGVhZGVyJyxcclxuICAgICAgICAgICAgICAgICAgICBpc1N0aWNreTogc3RpY2t5SGVhZGVyRGF0ZXMsXHJcbiAgICAgICAgICAgICAgICAgICAgc3luY1Jvd0hlaWdodHM6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgY2h1bmtzOiBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleTogJ2F4aXMnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcm93Q29udGVudDogKGFyZykgPT4gKHkoXCJ0clwiLCB7IHJvbGU6IFwicHJlc2VudGF0aW9uXCIgfSwgdGhpcy5yZW5kZXJIZWFkQXhpcygnZGF5JywgYXJnLnJvd1N5bmNIZWlnaHRzWzBdKSkpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXk6ICdjb2xzJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsUmVmOiB0aGlzLmhlYWRlckVsUmVmLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFibGVDbGFzc05hbWU6ICdmYy1jb2wtaGVhZGVyJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvd0NvbnRlbnQ6IGhlYWRlclJvd0NvbnRlbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChhbGxEYXlDb250ZW50KSB7XHJcbiAgICAgICAgICAgICAgICBzZWN0aW9ucy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnYm9keScsXHJcbiAgICAgICAgICAgICAgICAgICAga2V5OiAnYWxsLWRheScsXHJcbiAgICAgICAgICAgICAgICAgICAgc3luY1Jvd0hlaWdodHM6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgY2h1bmtzOiBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleTogJ2F4aXMnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcm93Q29udGVudDogKGNvbnRlbnRBcmcpID0+ICh5KFwidHJcIiwgeyByb2xlOiBcInByZXNlbnRhdGlvblwiIH0sIHRoaXMucmVuZGVyVGFibGVSb3dBeGlzKGNvbnRlbnRBcmcucm93U3luY0hlaWdodHNbMF0pKSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleTogJ2NvbHMnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogYWxsRGF5Q29udGVudCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBzZWN0aW9ucy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICBrZXk6ICdhbGwtZGF5LWRpdmlkZXInLFxyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdib2R5JyxcclxuICAgICAgICAgICAgICAgICAgICBvdXRlckNvbnRlbnQ6ICggLy8gVE9ETzogcmVuYW1lIHRvIGNlbGxDb250ZW50IHNvIGRvbid0IG5lZWQgdG8gZGVmaW5lIDx0cj4/XHJcbiAgICAgICAgICAgICAgICAgICAgeShcInRyXCIsIHsgcm9sZTogXCJwcmVzZW50YXRpb25cIiwgY2xhc3NOYW1lOiBcImZjLXNjcm9sbGdyaWQtc2VjdGlvblwiIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHkoXCJ0ZFwiLCB7IGNvbFNwYW46IDIsIGNsYXNzTmFtZTogJ2ZjLXRpbWVncmlkLWRpdmlkZXIgJyArIGNvbnRleHQudGhlbWUuZ2V0Q2xhc3MoJ3RhYmxlQ2VsbFNoYWRlZCcpIH0pKSksXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgaXNOb3dJbmRpY2F0b3IgPSBjb250ZXh0Lm9wdGlvbnMubm93SW5kaWNhdG9yO1xyXG4gICAgICAgICAgICBzZWN0aW9ucy5wdXNoKHtcclxuICAgICAgICAgICAgICAgIHR5cGU6ICdib2R5JyxcclxuICAgICAgICAgICAgICAgIGtleTogJ2JvZHknLFxyXG4gICAgICAgICAgICAgICAgbGlxdWlkOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgZXhwYW5kUm93czogQm9vbGVhbihjb250ZXh0Lm9wdGlvbnMuZXhwYW5kUm93cyksXHJcbiAgICAgICAgICAgICAgICBjaHVua3M6IFtcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleTogJ2F4aXMnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiAoYXJnKSA9PiAoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IG1ha2UgdGhpcyBub3ctaW5kaWNhdG9yIGFycm93IG1vcmUgRFJZIHdpdGggVGltZUNvbHNDb250ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHkoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtdGltZWdyaWQtYXhpcy1jaHVua1wiIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5KFwidGFibGVcIiwgeyBcImFyaWEtaGlkZGVuXCI6IHRydWUsIHN0eWxlOiB7IGhlaWdodDogYXJnLmV4cGFuZFJvd3MgPyBhcmcuY2xpZW50SGVpZ2h0IDogJycgfSB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZy50YWJsZUNvbEdyb3VwTm9kZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5KFwidGJvZHlcIiwgbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeShUaW1lQm9keUF4aXMsIHsgc2xhdE1ldGFzOiBzbGF0TWV0YXMgfSkpKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtdGltZWdyaWQtbm93LWluZGljYXRvci1jb250YWluZXJcIiB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkoTm93VGltZXIsIHsgdW5pdDogaXNOb3dJbmRpY2F0b3IgPyAnbWludXRlJyA6ICdkYXknIC8qIGhhY2t5ICovIH0sIChub3dEYXRlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBub3dJbmRpY2F0b3JUb3AgPSBpc05vd0luZGljYXRvciAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2xhdENvb3JkcyAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2xhdENvb3Jkcy5zYWZlQ29tcHV0ZVRvcChub3dEYXRlKTsgLy8gbWlnaHQgcmV0dXJuIHZvaWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBub3dJbmRpY2F0b3JUb3AgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHkoTm93SW5kaWNhdG9yQ29udGFpbmVyLCB7IGVsQ2xhc3NlczogWydmYy10aW1lZ3JpZC1ub3ctaW5kaWNhdG9yLWFycm93J10sIGVsU3R5bGU6IHsgdG9wOiBub3dJbmRpY2F0b3JUb3AgfSwgaXNBeGlzOiB0cnVlLCBkYXRlOiBub3dEYXRlIH0pKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSkpKSxcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAga2V5OiAnY29scycsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbGVyRWxSZWY6IHRoaXMuc2Nyb2xsZXJFbFJlZixcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogdGltZUNvbnRlbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBpZiAoc3RpY2t5Rm9vdGVyU2Nyb2xsYmFyKSB7XHJcbiAgICAgICAgICAgICAgICBzZWN0aW9ucy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICBrZXk6ICdmb290ZXInLFxyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdmb290ZXInLFxyXG4gICAgICAgICAgICAgICAgICAgIGlzU3RpY2t5OiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgIGNodW5rczogW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXk6ICdheGlzJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHJlbmRlclNjcm9sbFNoaW0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleTogJ2NvbHMnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogcmVuZGVyU2Nyb2xsU2hpbSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuICh5KFZpZXdDb250YWluZXIsIHsgZWxSZWY6IHRoaXMucm9vdEVsUmVmLCBlbENsYXNzZXM6IFsnZmMtdGltZWdyaWQnXSwgdmlld1NwZWM6IGNvbnRleHQudmlld1NwZWMgfSxcclxuICAgICAgICAgICAgICAgIHkoU2Nyb2xsR3JpZCwgeyBsaXF1aWQ6ICFwcm9wcy5pc0hlaWdodEF1dG8gJiYgIXByb3BzLmZvclByaW50LCBmb3JQcmludDogcHJvcHMuZm9yUHJpbnQsIGNvbGxhcHNpYmxlV2lkdGg6IGZhbHNlLCBjb2xHcm91cHM6IFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeyB3aWR0aDogJ3NocmluaycsIGNvbHM6IFt7IHdpZHRoOiAnc2hyaW5rJyB9XSB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7IGNvbHM6IFt7IHNwYW46IGNvbENudCwgbWluV2lkdGg6IGRheU1pbldpZHRoIH1dIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgXSwgc2VjdGlvbnM6IHNlY3Rpb25zIH0pKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qIERpbWVuc2lvbnNcclxuICAgICAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgICAgIGdldEFsbERheU1heEV2ZW50UHJvcHMoKSB7XHJcbiAgICAgICAgICAgIGxldCB7IGRheU1heEV2ZW50cywgZGF5TWF4RXZlbnRSb3dzIH0gPSB0aGlzLmNvbnRleHQub3B0aW9ucztcclxuICAgICAgICAgICAgaWYgKGRheU1heEV2ZW50cyA9PT0gdHJ1ZSB8fCBkYXlNYXhFdmVudFJvd3MgPT09IHRydWUpIHsgLy8gaXMgYXV0bz9cclxuICAgICAgICAgICAgICAgIGRheU1heEV2ZW50cyA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgIGRheU1heEV2ZW50Um93cyA9IEFVVE9fQUxMX0RBWV9NQVhfRVZFTlRfUk9XUzsgLy8gbWFrZSBzdXJlIFwiYXV0b1wiIGdvZXMgdG8gYSByZWFsIG51bWJlclxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB7IGRheU1heEV2ZW50cywgZGF5TWF4RXZlbnRSb3dzIH07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gcmVuZGVyQWxsRGF5SW5uZXIkMShyZW5kZXJQcm9wcykge1xyXG4gICAgICAgIHJldHVybiByZW5kZXJQcm9wcy50ZXh0O1xyXG4gICAgfVxyXG5cclxuICAgIGNsYXNzIFRpbWVDb2xzU2xhdHNDb29yZHMge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yKHBvc2l0aW9ucywgZGF0ZVByb2ZpbGUsIHNsb3REdXJhdGlvbikge1xyXG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9ucyA9IHBvc2l0aW9ucztcclxuICAgICAgICAgICAgdGhpcy5kYXRlUHJvZmlsZSA9IGRhdGVQcm9maWxlO1xyXG4gICAgICAgICAgICB0aGlzLnNsb3REdXJhdGlvbiA9IHNsb3REdXJhdGlvbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgc2FmZUNvbXB1dGVUb3AoZGF0ZSkge1xyXG4gICAgICAgICAgICBsZXQgeyBkYXRlUHJvZmlsZSB9ID0gdGhpcztcclxuICAgICAgICAgICAgaWYgKHJhbmdlQ29udGFpbnNNYXJrZXIoZGF0ZVByb2ZpbGUuY3VycmVudFJhbmdlLCBkYXRlKSkge1xyXG4gICAgICAgICAgICAgICAgbGV0IHN0YXJ0T2ZEYXlEYXRlID0gc3RhcnRPZkRheShkYXRlKTtcclxuICAgICAgICAgICAgICAgIGxldCB0aW1lTXMgPSBkYXRlLnZhbHVlT2YoKSAtIHN0YXJ0T2ZEYXlEYXRlLnZhbHVlT2YoKTtcclxuICAgICAgICAgICAgICAgIGlmICh0aW1lTXMgPj0gYXNSb3VnaE1zKGRhdGVQcm9maWxlLnNsb3RNaW5UaW1lKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgIHRpbWVNcyA8IGFzUm91Z2hNcyhkYXRlUHJvZmlsZS5zbG90TWF4VGltZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb21wdXRlVGltZVRvcChjcmVhdGVEdXJhdGlvbih0aW1lTXMpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQ29tcHV0ZXMgdGhlIHRvcCBjb29yZGluYXRlLCByZWxhdGl2ZSB0byB0aGUgYm91bmRzIG9mIHRoZSBncmlkLCBvZiB0aGUgZ2l2ZW4gZGF0ZS5cclxuICAgICAgICAvLyBBIGBzdGFydE9mRGF5RGF0ZWAgbXVzdCBiZSBnaXZlbiBmb3IgYXZvaWRpbmcgYW1iaWd1aXR5IG92ZXIgaG93IHRvIHRyZWF0IG1pZG5pZ2h0LlxyXG4gICAgICAgIGNvbXB1dGVEYXRlVG9wKHdoZW4sIHN0YXJ0T2ZEYXlEYXRlKSB7XHJcbiAgICAgICAgICAgIGlmICghc3RhcnRPZkRheURhdGUpIHtcclxuICAgICAgICAgICAgICAgIHN0YXJ0T2ZEYXlEYXRlID0gc3RhcnRPZkRheSh3aGVuKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb21wdXRlVGltZVRvcChjcmVhdGVEdXJhdGlvbih3aGVuLnZhbHVlT2YoKSAtIHN0YXJ0T2ZEYXlEYXRlLnZhbHVlT2YoKSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBDb21wdXRlcyB0aGUgdG9wIGNvb3JkaW5hdGUsIHJlbGF0aXZlIHRvIHRoZSBib3VuZHMgb2YgdGhlIGdyaWQsIG9mIHRoZSBnaXZlbiB0aW1lIChhIER1cmF0aW9uKS5cclxuICAgICAgICAvLyBUaGlzIGlzIGEgbWFrZXNoaWZ5IHdheSB0byBjb21wdXRlIHRoZSB0aW1lLXRvcC4gQXNzdW1lcyBhbGwgc2xhdE1ldGFzIGRhdGVzIGFyZSB1bmlmb3JtLlxyXG4gICAgICAgIC8vIEV2ZW50dWFsbHkgYWxsb3cgY29tcHV0YXRpb24gd2l0aCBhcmJpcmFyeSBzbGF0IGRhdGVzLlxyXG4gICAgICAgIGNvbXB1dGVUaW1lVG9wKGR1cmF0aW9uKSB7XHJcbiAgICAgICAgICAgIGxldCB7IHBvc2l0aW9ucywgZGF0ZVByb2ZpbGUgfSA9IHRoaXM7XHJcbiAgICAgICAgICAgIGxldCBsZW4gPSBwb3NpdGlvbnMuZWxzLmxlbmd0aDtcclxuICAgICAgICAgICAgLy8gZmxvYXRpbmctcG9pbnQgdmFsdWUgb2YgIyBvZiBzbG90cyBjb3ZlcmVkXHJcbiAgICAgICAgICAgIGxldCBzbGF0Q292ZXJhZ2UgPSAoZHVyYXRpb24ubWlsbGlzZWNvbmRzIC0gYXNSb3VnaE1zKGRhdGVQcm9maWxlLnNsb3RNaW5UaW1lKSkgLyBhc1JvdWdoTXModGhpcy5zbG90RHVyYXRpb24pO1xyXG4gICAgICAgICAgICBsZXQgc2xhdEluZGV4O1xyXG4gICAgICAgICAgICBsZXQgc2xhdFJlbWFpbmRlcjtcclxuICAgICAgICAgICAgLy8gY29tcHV0ZSBhIGZsb2F0aW5nLXBvaW50IG51bWJlciBmb3IgaG93IG1hbnkgc2xhdHMgc2hvdWxkIGJlIHByb2dyZXNzZWQgdGhyb3VnaC5cclxuICAgICAgICAgICAgLy8gZnJvbSAwIHRvIG51bWJlciBvZiBzbGF0cyAoaW5jbHVzaXZlKVxyXG4gICAgICAgICAgICAvLyBjb25zdHJhaW5lZCBiZWNhdXNlIHNsb3RNaW5UaW1lL3Nsb3RNYXhUaW1lIG1pZ2h0IGJlIGN1c3RvbWl6ZWQuXHJcbiAgICAgICAgICAgIHNsYXRDb3ZlcmFnZSA9IE1hdGgubWF4KDAsIHNsYXRDb3ZlcmFnZSk7XHJcbiAgICAgICAgICAgIHNsYXRDb3ZlcmFnZSA9IE1hdGgubWluKGxlbiwgc2xhdENvdmVyYWdlKTtcclxuICAgICAgICAgICAgLy8gYW4gaW50ZWdlciBpbmRleCBvZiB0aGUgZnVydGhlc3Qgd2hvbGUgc2xhdFxyXG4gICAgICAgICAgICAvLyBmcm9tIDAgdG8gbnVtYmVyIHNsYXRzICgqZXhjbHVzaXZlKiwgc28gbGVuLTEpXHJcbiAgICAgICAgICAgIHNsYXRJbmRleCA9IE1hdGguZmxvb3Ioc2xhdENvdmVyYWdlKTtcclxuICAgICAgICAgICAgc2xhdEluZGV4ID0gTWF0aC5taW4oc2xhdEluZGV4LCBsZW4gLSAxKTtcclxuICAgICAgICAgICAgLy8gaG93IG11Y2ggZnVydGhlciB0aHJvdWdoIHRoZSBzbGF0SW5kZXggc2xhdCAoZnJvbSAwLjAtMS4wKSBtdXN0IGJlIGNvdmVyZWQgaW4gYWRkaXRpb24uXHJcbiAgICAgICAgICAgIC8vIGNvdWxkIGJlIDEuMCBpZiBzbGF0Q292ZXJhZ2UgaXMgY292ZXJpbmcgKmFsbCogdGhlIHNsb3RzXHJcbiAgICAgICAgICAgIHNsYXRSZW1haW5kZXIgPSBzbGF0Q292ZXJhZ2UgLSBzbGF0SW5kZXg7XHJcbiAgICAgICAgICAgIHJldHVybiBwb3NpdGlvbnMudG9wc1tzbGF0SW5kZXhdICtcclxuICAgICAgICAgICAgICAgIHBvc2l0aW9ucy5nZXRIZWlnaHQoc2xhdEluZGV4KSAqIHNsYXRSZW1haW5kZXI7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNsYXNzIFRpbWVDb2xzU2xhdHNCb2R5IGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XHJcbiAgICAgICAgcmVuZGVyKCkge1xyXG4gICAgICAgICAgICBsZXQgeyBwcm9wcywgY29udGV4dCB9ID0gdGhpcztcclxuICAgICAgICAgICAgbGV0IHsgb3B0aW9ucyB9ID0gY29udGV4dDtcclxuICAgICAgICAgICAgbGV0IHsgc2xhdEVsUmVmcyB9ID0gcHJvcHM7XHJcbiAgICAgICAgICAgIHJldHVybiAoeShcInRib2R5XCIsIG51bGwsIHByb3BzLnNsYXRNZXRhcy5tYXAoKHNsYXRNZXRhLCBpKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBsZXQgcmVuZGVyUHJvcHMgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGltZTogc2xhdE1ldGEudGltZSxcclxuICAgICAgICAgICAgICAgICAgICBkYXRlOiBjb250ZXh0LmRhdGVFbnYudG9EYXRlKHNsYXRNZXRhLmRhdGUpLFxyXG4gICAgICAgICAgICAgICAgICAgIHZpZXc6IGNvbnRleHQudmlld0FwaSxcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKHkoXCJ0clwiLCB7IGtleTogc2xhdE1ldGEua2V5LCByZWY6IHNsYXRFbFJlZnMuY3JlYXRlUmVmKHNsYXRNZXRhLmtleSkgfSxcclxuICAgICAgICAgICAgICAgICAgICBwcm9wcy5heGlzICYmICh5KFRpbWVDb2xzQXhpc0NlbGwsIE9iamVjdC5hc3NpZ24oe30sIHNsYXRNZXRhKSkpLFxyXG4gICAgICAgICAgICAgICAgICAgIHkoQ29udGVudENvbnRhaW5lciwgeyBlbFRhZzogXCJ0ZFwiLCBlbENsYXNzZXM6IFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdmYy10aW1lZ3JpZC1zbG90JyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdmYy10aW1lZ3JpZC1zbG90LWxhbmUnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIXNsYXRNZXRhLmlzTGFiZWxlZCAmJiAnZmMtdGltZWdyaWQtc2xvdC1taW5vcicsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF0sIGVsQXR0cnM6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdkYXRhLXRpbWUnOiBzbGF0TWV0YS5pc29UaW1lU3RyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCByZW5kZXJQcm9wczogcmVuZGVyUHJvcHMsIGdlbmVyYXRvck5hbWU6IFwic2xvdExhbmVDb250ZW50XCIsIGN1c3RvbUdlbmVyYXRvcjogb3B0aW9ucy5zbG90TGFuZUNvbnRlbnQsIGNsYXNzTmFtZUdlbmVyYXRvcjogb3B0aW9ucy5zbG90TGFuZUNsYXNzTmFtZXMsIGRpZE1vdW50OiBvcHRpb25zLnNsb3RMYW5lRGlkTW91bnQsIHdpbGxVbm1vdW50OiBvcHRpb25zLnNsb3RMYW5lV2lsbFVubW91bnQgfSkpKTtcclxuICAgICAgICAgICAgfSkpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLypcclxuICAgIGZvciB0aGUgaG9yaXpvbnRhbCBcInNsYXRzXCIgdGhhdCBydW4gd2lkdGgtd2lzZS4gSGFzIGEgdGltZSBheGlzIG9uIGEgc2lkZS4gRGVwZW5kcyBvbiBSVEwuXHJcbiAgICAqL1xyXG4gICAgY2xhc3MgVGltZUNvbHNTbGF0cyBleHRlbmRzIEJhc2VDb21wb25lbnQge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgICAgICB0aGlzLnJvb3RFbFJlZiA9IGQoKTtcclxuICAgICAgICAgICAgdGhpcy5zbGF0RWxSZWZzID0gbmV3IFJlZk1hcCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZW5kZXIoKSB7XHJcbiAgICAgICAgICAgIGxldCB7IHByb3BzLCBjb250ZXh0IH0gPSB0aGlzO1xyXG4gICAgICAgICAgICByZXR1cm4gKHkoXCJkaXZcIiwgeyByZWY6IHRoaXMucm9vdEVsUmVmLCBjbGFzc05hbWU6IFwiZmMtdGltZWdyaWQtc2xvdHNcIiB9LFxyXG4gICAgICAgICAgICAgICAgeShcInRhYmxlXCIsIHsgXCJhcmlhLWhpZGRlblwiOiB0cnVlLCBjbGFzc05hbWU6IGNvbnRleHQudGhlbWUuZ2V0Q2xhc3MoJ3RhYmxlJyksIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbldpZHRoOiBwcm9wcy50YWJsZU1pbldpZHRoLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogcHJvcHMuY2xpZW50V2lkdGgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogcHJvcHMubWluSGVpZ2h0LFxyXG4gICAgICAgICAgICAgICAgICAgIH0gfSxcclxuICAgICAgICAgICAgICAgICAgICBwcm9wcy50YWJsZUNvbEdyb3VwTm9kZSAvKiByZWxpZXMgb24gdGhlcmUgb25seSBiZWluZyBhIHNpbmdsZSA8Y29sPiBmb3IgdGhlIGF4aXMgKi8sXHJcbiAgICAgICAgICAgICAgICAgICAgeShUaW1lQ29sc1NsYXRzQm9keSwgeyBzbGF0RWxSZWZzOiB0aGlzLnNsYXRFbFJlZnMsIGF4aXM6IHByb3BzLmF4aXMsIHNsYXRNZXRhczogcHJvcHMuc2xhdE1ldGFzIH0pKSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb21wb25lbnREaWRNb3VudCgpIHtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVTaXppbmcoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29tcG9uZW50RGlkVXBkYXRlKCkge1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVNpemluZygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMucHJvcHMub25Db29yZHMpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucHJvcHMub25Db29yZHMobnVsbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdXBkYXRlU2l6aW5nKCkge1xyXG4gICAgICAgICAgICBsZXQgeyBjb250ZXh0LCBwcm9wcyB9ID0gdGhpcztcclxuICAgICAgICAgICAgaWYgKHByb3BzLm9uQ29vcmRzICYmXHJcbiAgICAgICAgICAgICAgICBwcm9wcy5jbGllbnRXaWR0aCAhPT0gbnVsbCAvLyBtZWFucyBzaXppbmcgaGFzIHN0YWJpbGl6ZWRcclxuICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgcm9vdEVsID0gdGhpcy5yb290RWxSZWYuY3VycmVudDtcclxuICAgICAgICAgICAgICAgIGlmIChyb290RWwub2Zmc2V0SGVpZ2h0KSB7IC8vIG5vdCBoaWRkZW4gYnkgY3NzXHJcbiAgICAgICAgICAgICAgICAgICAgcHJvcHMub25Db29yZHMobmV3IFRpbWVDb2xzU2xhdHNDb29yZHMobmV3IFBvc2l0aW9uQ2FjaGUodGhpcy5yb290RWxSZWYuY3VycmVudCwgY29sbGVjdFNsYXRFbHModGhpcy5zbGF0RWxSZWZzLmN1cnJlbnRNYXAsIHByb3BzLnNsYXRNZXRhcyksIGZhbHNlLCB0cnVlKSwgdGhpcy5wcm9wcy5kYXRlUHJvZmlsZSwgY29udGV4dC5vcHRpb25zLnNsb3REdXJhdGlvbikpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gY29sbGVjdFNsYXRFbHMoZWxNYXAsIHNsYXRNZXRhcykge1xyXG4gICAgICAgIHJldHVybiBzbGF0TWV0YXMubWFwKChzbGF0TWV0YSkgPT4gZWxNYXBbc2xhdE1ldGEua2V5XSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gc3BsaXRTZWdzQnlDb2woc2VncywgY29sQ250KSB7XHJcbiAgICAgICAgbGV0IHNlZ3NCeUNvbCA9IFtdO1xyXG4gICAgICAgIGxldCBpO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb2xDbnQ7IGkgKz0gMSkge1xyXG4gICAgICAgICAgICBzZWdzQnlDb2wucHVzaChbXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzZWdzKSB7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBzZWdzLmxlbmd0aDsgaSArPSAxKSB7XHJcbiAgICAgICAgICAgICAgICBzZWdzQnlDb2xbc2Vnc1tpXS5jb2xdLnB1c2goc2Vnc1tpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHNlZ3NCeUNvbDtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHNwbGl0SW50ZXJhY3Rpb25CeUNvbCh1aSwgY29sQ250KSB7XHJcbiAgICAgICAgbGV0IGJ5Um93ID0gW107XHJcbiAgICAgICAgaWYgKCF1aSkge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbENudDsgaSArPSAxKSB7XHJcbiAgICAgICAgICAgICAgICBieVJvd1tpXSA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29sQ250OyBpICs9IDEpIHtcclxuICAgICAgICAgICAgICAgIGJ5Um93W2ldID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIGFmZmVjdGVkSW5zdGFuY2VzOiB1aS5hZmZlY3RlZEluc3RhbmNlcyxcclxuICAgICAgICAgICAgICAgICAgICBpc0V2ZW50OiB1aS5pc0V2ZW50LFxyXG4gICAgICAgICAgICAgICAgICAgIHNlZ3M6IFtdLFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKGxldCBzZWcgb2YgdWkuc2Vncykge1xyXG4gICAgICAgICAgICAgICAgYnlSb3dbc2VnLmNvbF0uc2Vncy5wdXNoKHNlZyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGJ5Um93O1xyXG4gICAgfVxyXG5cclxuICAgIGNsYXNzIFRpbWVDb2xNb3JlTGluayBleHRlbmRzIEJhc2VDb21wb25lbnQge1xyXG4gICAgICAgIHJlbmRlcigpIHtcclxuICAgICAgICAgICAgbGV0IHsgcHJvcHMgfSA9IHRoaXM7XHJcbiAgICAgICAgICAgIHJldHVybiAoeShNb3JlTGlua0NvbnRhaW5lciwgeyBlbENsYXNzZXM6IFsnZmMtdGltZWdyaWQtbW9yZS1saW5rJ10sIGVsU3R5bGU6IHtcclxuICAgICAgICAgICAgICAgICAgICB0b3A6IHByb3BzLnRvcCxcclxuICAgICAgICAgICAgICAgICAgICBib3R0b206IHByb3BzLmJvdHRvbSxcclxuICAgICAgICAgICAgICAgIH0sIGFsbERheURhdGU6IG51bGwsIG1vcmVDbnQ6IHByb3BzLmhpZGRlblNlZ3MubGVuZ3RoLCBhbGxTZWdzOiBwcm9wcy5oaWRkZW5TZWdzLCBoaWRkZW5TZWdzOiBwcm9wcy5oaWRkZW5TZWdzLCBleHRyYURhdGVTcGFuOiBwcm9wcy5leHRyYURhdGVTcGFuLCBkYXRlUHJvZmlsZTogcHJvcHMuZGF0ZVByb2ZpbGUsIHRvZGF5UmFuZ2U6IHByb3BzLnRvZGF5UmFuZ2UsIHBvcG92ZXJDb250ZW50OiAoKSA9PiByZW5kZXJQbGFpbkZnU2Vncyhwcm9wcy5oaWRkZW5TZWdzLCBwcm9wcyksIGRlZmF1bHRHZW5lcmF0b3I6IHJlbmRlck1vcmVMaW5rSW5uZXIsIGZvcmNlVGltZWQ6IHRydWUgfSwgKElubmVyQ29udGVudCkgPT4gKHkoSW5uZXJDb250ZW50LCB7IGVsVGFnOiBcImRpdlwiLCBlbENsYXNzZXM6IFsnZmMtdGltZWdyaWQtbW9yZS1saW5rLWlubmVyJywgJ2ZjLXN0aWNreSddIH0pKSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHJlbmRlck1vcmVMaW5rSW5uZXIocHJvcHMpIHtcclxuICAgICAgICByZXR1cm4gcHJvcHMuc2hvcnRUZXh0O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHNlZ0lucHV0cyBhc3N1bWVkIHNvcnRlZFxyXG4gICAgZnVuY3Rpb24gYnVpbGRQb3NpdGlvbmluZyhzZWdJbnB1dHMsIHN0cmljdE9yZGVyLCBtYXhTdGFja0NudCkge1xyXG4gICAgICAgIGxldCBoaWVyYXJjaHkgPSBuZXcgU2VnSGllcmFyY2h5KCk7XHJcbiAgICAgICAgaWYgKHN0cmljdE9yZGVyICE9IG51bGwpIHtcclxuICAgICAgICAgICAgaGllcmFyY2h5LnN0cmljdE9yZGVyID0gc3RyaWN0T3JkZXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChtYXhTdGFja0NudCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIGhpZXJhcmNoeS5tYXhTdGFja0NudCA9IG1heFN0YWNrQ250O1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgaGlkZGVuRW50cmllcyA9IGhpZXJhcmNoeS5hZGRTZWdzKHNlZ0lucHV0cyk7XHJcbiAgICAgICAgbGV0IGhpZGRlbkdyb3VwcyA9IGdyb3VwSW50ZXJzZWN0aW5nRW50cmllcyhoaWRkZW5FbnRyaWVzKTtcclxuICAgICAgICBsZXQgd2ViID0gYnVpbGRXZWIoaGllcmFyY2h5KTtcclxuICAgICAgICB3ZWIgPSBzdHJldGNoV2ViKHdlYiwgMSk7IC8vIGFsbCBsZXZlbENvb3Jkcy90aGlja25lc3Mgd2lsbCBoYXZlIDAuMC0xLjBcclxuICAgICAgICBsZXQgc2VnUmVjdHMgPSB3ZWJUb1JlY3RzKHdlYik7XHJcbiAgICAgICAgcmV0dXJuIHsgc2VnUmVjdHMsIGhpZGRlbkdyb3VwcyB9O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYnVpbGRXZWIoaGllcmFyY2h5KSB7XHJcbiAgICAgICAgY29uc3QgeyBlbnRyaWVzQnlMZXZlbCB9ID0gaGllcmFyY2h5O1xyXG4gICAgICAgIGNvbnN0IGJ1aWxkTm9kZSA9IGNhY2hlYWJsZSgobGV2ZWwsIGxhdGVyYWwpID0+IGxldmVsICsgJzonICsgbGF0ZXJhbCwgKGxldmVsLCBsYXRlcmFsKSA9PiB7XHJcbiAgICAgICAgICAgIGxldCBzaWJsaW5nUmFuZ2UgPSBmaW5kTmV4dExldmVsU2VncyhoaWVyYXJjaHksIGxldmVsLCBsYXRlcmFsKTtcclxuICAgICAgICAgICAgbGV0IG5leHRMZXZlbFJlcyA9IGJ1aWxkTm9kZXMoc2libGluZ1JhbmdlLCBidWlsZE5vZGUpO1xyXG4gICAgICAgICAgICBsZXQgZW50cnkgPSBlbnRyaWVzQnlMZXZlbFtsZXZlbF1bbGF0ZXJhbF07XHJcbiAgICAgICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGVudHJ5KSwgeyBuZXh0TGV2ZWxOb2RlczogbmV4dExldmVsUmVzWzBdIH0pLFxyXG4gICAgICAgICAgICAgICAgZW50cnkudGhpY2tuZXNzICsgbmV4dExldmVsUmVzWzFdLCAvLyB0aGUgcHJlc3N1cmUgYnVpbGRzXHJcbiAgICAgICAgICAgIF07XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGJ1aWxkTm9kZXMoZW50cmllc0J5TGV2ZWwubGVuZ3RoXHJcbiAgICAgICAgICAgID8geyBsZXZlbDogMCwgbGF0ZXJhbFN0YXJ0OiAwLCBsYXRlcmFsRW5kOiBlbnRyaWVzQnlMZXZlbFswXS5sZW5ndGggfVxyXG4gICAgICAgICAgICA6IG51bGwsIGJ1aWxkTm9kZSlbMF07XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBidWlsZE5vZGVzKHNpYmxpbmdSYW5nZSwgYnVpbGROb2RlKSB7XHJcbiAgICAgICAgaWYgKCFzaWJsaW5nUmFuZ2UpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFtbXSwgMF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCB7IGxldmVsLCBsYXRlcmFsU3RhcnQsIGxhdGVyYWxFbmQgfSA9IHNpYmxpbmdSYW5nZTtcclxuICAgICAgICBsZXQgbGF0ZXJhbCA9IGxhdGVyYWxTdGFydDtcclxuICAgICAgICBsZXQgcGFpcnMgPSBbXTtcclxuICAgICAgICB3aGlsZSAobGF0ZXJhbCA8IGxhdGVyYWxFbmQpIHtcclxuICAgICAgICAgICAgcGFpcnMucHVzaChidWlsZE5vZGUobGV2ZWwsIGxhdGVyYWwpKTtcclxuICAgICAgICAgICAgbGF0ZXJhbCArPSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwYWlycy5zb3J0KGNtcERlc2NQcmVzc3VyZXMpO1xyXG4gICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgIHBhaXJzLm1hcChleHRyYWN0Tm9kZSksXHJcbiAgICAgICAgICAgIHBhaXJzWzBdWzFdLCAvLyBmaXJzdCBpdGVtJ3MgcHJlc3N1cmVcclxuICAgICAgICBdO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gY21wRGVzY1ByZXNzdXJlcyhhLCBiKSB7XHJcbiAgICAgICAgcmV0dXJuIGJbMV0gLSBhWzFdO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZXh0cmFjdE5vZGUoYSkge1xyXG4gICAgICAgIHJldHVybiBhWzBdO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZmluZE5leHRMZXZlbFNlZ3MoaGllcmFyY2h5LCBzdWJqZWN0TGV2ZWwsIHN1YmplY3RMYXRlcmFsKSB7XHJcbiAgICAgICAgbGV0IHsgbGV2ZWxDb29yZHMsIGVudHJpZXNCeUxldmVsIH0gPSBoaWVyYXJjaHk7XHJcbiAgICAgICAgbGV0IHN1YmplY3RFbnRyeSA9IGVudHJpZXNCeUxldmVsW3N1YmplY3RMZXZlbF1bc3ViamVjdExhdGVyYWxdO1xyXG4gICAgICAgIGxldCBhZnRlclN1YmplY3QgPSBsZXZlbENvb3Jkc1tzdWJqZWN0TGV2ZWxdICsgc3ViamVjdEVudHJ5LnRoaWNrbmVzcztcclxuICAgICAgICBsZXQgbGV2ZWxDbnQgPSBsZXZlbENvb3Jkcy5sZW5ndGg7XHJcbiAgICAgICAgbGV0IGxldmVsID0gc3ViamVjdExldmVsO1xyXG4gICAgICAgIC8vIHNraXAgcGFzdCBsZXZlbHMgdGhhdCBhcmUgdG9vIGhpZ2ggdXBcclxuICAgICAgICBmb3IgKDsgbGV2ZWwgPCBsZXZlbENudCAmJiBsZXZlbENvb3Jkc1tsZXZlbF0gPCBhZnRlclN1YmplY3Q7IGxldmVsICs9IDEpXHJcbiAgICAgICAgICAgIDsgLy8gZG8gbm90aGluZ1xyXG4gICAgICAgIGZvciAoOyBsZXZlbCA8IGxldmVsQ250OyBsZXZlbCArPSAxKSB7XHJcbiAgICAgICAgICAgIGxldCBlbnRyaWVzID0gZW50cmllc0J5TGV2ZWxbbGV2ZWxdO1xyXG4gICAgICAgICAgICBsZXQgZW50cnk7XHJcbiAgICAgICAgICAgIGxldCBzZWFyY2hJbmRleCA9IGJpbmFyeVNlYXJjaChlbnRyaWVzLCBzdWJqZWN0RW50cnkuc3Bhbi5zdGFydCwgZ2V0RW50cnlTcGFuRW5kKTtcclxuICAgICAgICAgICAgbGV0IGxhdGVyYWxTdGFydCA9IHNlYXJjaEluZGV4WzBdICsgc2VhcmNoSW5kZXhbMV07IC8vIGlmIGV4YWN0IG1hdGNoICh3aGljaCBkb2Vzbid0IGNvbGxpZGUpLCBnbyB0byBuZXh0IG9uZVxyXG4gICAgICAgICAgICBsZXQgbGF0ZXJhbEVuZCA9IGxhdGVyYWxTdGFydDtcclxuICAgICAgICAgICAgd2hpbGUgKCAvLyBsb29wIHRocm91Z2ggZW50cmllcyB0aGF0IGhvcml6b250YWxseSBpbnRlcnNlY3RcclxuICAgICAgICAgICAgKGVudHJ5ID0gZW50cmllc1tsYXRlcmFsRW5kXSkgJiYgLy8gYnV0IG5vdCBwYXN0IHRoZSB3aG9sZSBzZWcgbGlzdFxyXG4gICAgICAgICAgICAgICAgZW50cnkuc3Bhbi5zdGFydCA8IHN1YmplY3RFbnRyeS5zcGFuLmVuZCkge1xyXG4gICAgICAgICAgICAgICAgbGF0ZXJhbEVuZCArPSAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChsYXRlcmFsU3RhcnQgPCBsYXRlcmFsRW5kKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4geyBsZXZlbCwgbGF0ZXJhbFN0YXJ0LCBsYXRlcmFsRW5kIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBzdHJldGNoV2ViKHRvcExldmVsTm9kZXMsIHRvdGFsVGhpY2tuZXNzKSB7XHJcbiAgICAgICAgY29uc3Qgc3RyZXRjaE5vZGUgPSBjYWNoZWFibGUoKG5vZGUsIHN0YXJ0Q29vcmQsIHByZXZUaGlja25lc3MpID0+IGJ1aWxkRW50cnlLZXkobm9kZSksIChub2RlLCBzdGFydENvb3JkLCBwcmV2VGhpY2tuZXNzKSA9PiB7XHJcbiAgICAgICAgICAgIGxldCB7IG5leHRMZXZlbE5vZGVzLCB0aGlja25lc3MgfSA9IG5vZGU7XHJcbiAgICAgICAgICAgIGxldCBhbGxUaGlja25lc3MgPSB0aGlja25lc3MgKyBwcmV2VGhpY2tuZXNzO1xyXG4gICAgICAgICAgICBsZXQgdGhpY2tuZXNzRnJhY3Rpb24gPSB0aGlja25lc3MgLyBhbGxUaGlja25lc3M7XHJcbiAgICAgICAgICAgIGxldCBlbmRDb29yZDtcclxuICAgICAgICAgICAgbGV0IG5ld0NoaWxkcmVuID0gW107XHJcbiAgICAgICAgICAgIGlmICghbmV4dExldmVsTm9kZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBlbmRDb29yZCA9IHRvdGFsVGhpY2tuZXNzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgY2hpbGROb2RlIG9mIG5leHRMZXZlbE5vZGVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVuZENvb3JkID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJlcyA9IHN0cmV0Y2hOb2RlKGNoaWxkTm9kZSwgc3RhcnRDb29yZCwgYWxsVGhpY2tuZXNzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kQ29vcmQgPSByZXNbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0NoaWxkcmVuLnB1c2gocmVzWzFdKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCByZXMgPSBzdHJldGNoTm9kZShjaGlsZE5vZGUsIGVuZENvb3JkLCAwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3Q2hpbGRyZW4ucHVzaChyZXNbMV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgbmV3VGhpY2tuZXNzID0gKGVuZENvb3JkIC0gc3RhcnRDb29yZCkgKiB0aGlja25lc3NGcmFjdGlvbjtcclxuICAgICAgICAgICAgcmV0dXJuIFtlbmRDb29yZCAtIG5ld1RoaWNrbmVzcywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBub2RlKSwgeyB0aGlja25lc3M6IG5ld1RoaWNrbmVzcywgbmV4dExldmVsTm9kZXM6IG5ld0NoaWxkcmVuIH0pXTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gdG9wTGV2ZWxOb2Rlcy5tYXAoKG5vZGUpID0+IHN0cmV0Y2hOb2RlKG5vZGUsIDAsIDApWzFdKTtcclxuICAgIH1cclxuICAgIC8vIG5vdCBzb3J0ZWQgaW4gYW55IHBhcnRpY3VsYXIgb3JkZXJcclxuICAgIGZ1bmN0aW9uIHdlYlRvUmVjdHModG9wTGV2ZWxOb2Rlcykge1xyXG4gICAgICAgIGxldCByZWN0cyA9IFtdO1xyXG4gICAgICAgIGNvbnN0IHByb2Nlc3NOb2RlID0gY2FjaGVhYmxlKChub2RlLCBsZXZlbENvb3JkLCBzdGFja0RlcHRoKSA9PiBidWlsZEVudHJ5S2V5KG5vZGUpLCAobm9kZSwgbGV2ZWxDb29yZCwgc3RhY2tEZXB0aCkgPT4ge1xyXG4gICAgICAgICAgICBsZXQgcmVjdCA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbm9kZSksIHsgbGV2ZWxDb29yZCxcclxuICAgICAgICAgICAgICAgIHN0YWNrRGVwdGgsIHN0YWNrRm9yd2FyZDogMCB9KTtcclxuICAgICAgICAgICAgcmVjdHMucHVzaChyZWN0KTtcclxuICAgICAgICAgICAgcmV0dXJuIChyZWN0LnN0YWNrRm9yd2FyZCA9IHByb2Nlc3NOb2Rlcyhub2RlLm5leHRMZXZlbE5vZGVzLCBsZXZlbENvb3JkICsgbm9kZS50aGlja25lc3MsIHN0YWNrRGVwdGggKyAxKSArIDEpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGZ1bmN0aW9uIHByb2Nlc3NOb2Rlcyhub2RlcywgbGV2ZWxDb29yZCwgc3RhY2tEZXB0aCkge1xyXG4gICAgICAgICAgICBsZXQgc3RhY2tGb3J3YXJkID0gMDtcclxuICAgICAgICAgICAgZm9yIChsZXQgbm9kZSBvZiBub2Rlcykge1xyXG4gICAgICAgICAgICAgICAgc3RhY2tGb3J3YXJkID0gTWF0aC5tYXgocHJvY2Vzc05vZGUobm9kZSwgbGV2ZWxDb29yZCwgc3RhY2tEZXB0aCksIHN0YWNrRm9yd2FyZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHN0YWNrRm9yd2FyZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcHJvY2Vzc05vZGVzKHRvcExldmVsTm9kZXMsIDAsIDApO1xyXG4gICAgICAgIHJldHVybiByZWN0czsgLy8gVE9ETzogc29ydCByZWN0cyBieSBsZXZlbENvb3JkIHRvIGJlIGNvbnNpc3RlbnQgd2l0aCB0b1JlY3RzP1xyXG4gICAgfVxyXG4gICAgLy8gVE9ETzogbW92ZSB0byBnZW5lcmFsIHV0aWxcclxuICAgIGZ1bmN0aW9uIGNhY2hlYWJsZShrZXlGdW5jLCB3b3JrRnVuYykge1xyXG4gICAgICAgIGNvbnN0IGNhY2hlID0ge307XHJcbiAgICAgICAgcmV0dXJuICguLi5hcmdzKSA9PiB7XHJcbiAgICAgICAgICAgIGxldCBrZXkgPSBrZXlGdW5jKC4uLmFyZ3MpO1xyXG4gICAgICAgICAgICByZXR1cm4gKGtleSBpbiBjYWNoZSlcclxuICAgICAgICAgICAgICAgID8gY2FjaGVba2V5XVxyXG4gICAgICAgICAgICAgICAgOiAoY2FjaGVba2V5XSA9IHdvcmtGdW5jKC4uLmFyZ3MpKTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNvbXB1dGVTZWdWQ29vcmRzKHNlZ3MsIGNvbERhdGUsIHNsYXRDb29yZHMgPSBudWxsLCBldmVudE1pbkhlaWdodCA9IDApIHtcclxuICAgICAgICBsZXQgdmNvb3JkcyA9IFtdO1xyXG4gICAgICAgIGlmIChzbGF0Q29vcmRzKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2Vncy5sZW5ndGg7IGkgKz0gMSkge1xyXG4gICAgICAgICAgICAgICAgbGV0IHNlZyA9IHNlZ3NbaV07XHJcbiAgICAgICAgICAgICAgICBsZXQgc3BhblN0YXJ0ID0gc2xhdENvb3Jkcy5jb21wdXRlRGF0ZVRvcChzZWcuc3RhcnQsIGNvbERhdGUpO1xyXG4gICAgICAgICAgICAgICAgbGV0IHNwYW5FbmQgPSBNYXRoLm1heChzcGFuU3RhcnQgKyAoZXZlbnRNaW5IZWlnaHQgfHwgMCksIC8vIDooXHJcbiAgICAgICAgICAgICAgICBzbGF0Q29vcmRzLmNvbXB1dGVEYXRlVG9wKHNlZy5lbmQsIGNvbERhdGUpKTtcclxuICAgICAgICAgICAgICAgIHZjb29yZHMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IE1hdGgucm91bmQoc3BhblN0YXJ0KSxcclxuICAgICAgICAgICAgICAgICAgICBlbmQ6IE1hdGgucm91bmQoc3BhbkVuZCksIC8vXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdmNvb3JkcztcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGNvbXB1dGVGZ1NlZ1BsYWNlbWVudHMoc2Vncywgc2VnVkNvb3JkcywgLy8gbWlnaHQgbm90IGhhdmUgZm9yIGV2ZXJ5IHNlZ1xyXG4gICAgZXZlbnRPcmRlclN0cmljdCwgZXZlbnRNYXhTdGFjaykge1xyXG4gICAgICAgIGxldCBzZWdJbnB1dHMgPSBbXTtcclxuICAgICAgICBsZXQgZHVtYlNlZ3MgPSBbXTsgLy8gc2VncyB3aXRob3V0IGNvb3Jkc1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2Vncy5sZW5ndGg7IGkgKz0gMSkge1xyXG4gICAgICAgICAgICBsZXQgdmNvb3JkcyA9IHNlZ1ZDb29yZHNbaV07XHJcbiAgICAgICAgICAgIGlmICh2Y29vcmRzKSB7XHJcbiAgICAgICAgICAgICAgICBzZWdJbnB1dHMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGksXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpY2tuZXNzOiAxLFxyXG4gICAgICAgICAgICAgICAgICAgIHNwYW46IHZjb29yZHMsXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGR1bWJTZWdzLnB1c2goc2Vnc1tpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHsgc2VnUmVjdHMsIGhpZGRlbkdyb3VwcyB9ID0gYnVpbGRQb3NpdGlvbmluZyhzZWdJbnB1dHMsIGV2ZW50T3JkZXJTdHJpY3QsIGV2ZW50TWF4U3RhY2spO1xyXG4gICAgICAgIGxldCBzZWdQbGFjZW1lbnRzID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgc2VnUmVjdCBvZiBzZWdSZWN0cykge1xyXG4gICAgICAgICAgICBzZWdQbGFjZW1lbnRzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgc2VnOiBzZWdzW3NlZ1JlY3QuaW5kZXhdLFxyXG4gICAgICAgICAgICAgICAgcmVjdDogc2VnUmVjdCxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAobGV0IGR1bWJTZWcgb2YgZHVtYlNlZ3MpIHtcclxuICAgICAgICAgICAgc2VnUGxhY2VtZW50cy5wdXNoKHsgc2VnOiBkdW1iU2VnLCByZWN0OiBudWxsIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4geyBzZWdQbGFjZW1lbnRzLCBoaWRkZW5Hcm91cHMgfTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBERUZBVUxUX1RJTUVfRk9STUFUJDEgPSBjcmVhdGVGb3JtYXR0ZXIoe1xyXG4gICAgICAgIGhvdXI6ICdudW1lcmljJyxcclxuICAgICAgICBtaW51dGU6ICcyLWRpZ2l0JyxcclxuICAgICAgICBtZXJpZGllbTogZmFsc2UsXHJcbiAgICB9KTtcclxuICAgIGNsYXNzIFRpbWVDb2xFdmVudCBleHRlbmRzIEJhc2VDb21wb25lbnQge1xyXG4gICAgICAgIHJlbmRlcigpIHtcclxuICAgICAgICAgICAgcmV0dXJuICh5KFN0YW5kYXJkRXZlbnQsIE9iamVjdC5hc3NpZ24oe30sIHRoaXMucHJvcHMsIHsgZWxDbGFzc2VzOiBbXHJcbiAgICAgICAgICAgICAgICAgICAgJ2ZjLXRpbWVncmlkLWV2ZW50JyxcclxuICAgICAgICAgICAgICAgICAgICAnZmMtdi1ldmVudCcsXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5pc1Nob3J0ICYmICdmYy10aW1lZ3JpZC1ldmVudC1zaG9ydCcsXHJcbiAgICAgICAgICAgICAgICBdLCBkZWZhdWx0VGltZUZvcm1hdDogREVGQVVMVF9USU1FX0ZPUk1BVCQxIH0pKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNsYXNzIFRpbWVDb2wgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcclxuICAgICAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgdGhpcy5zb3J0RXZlbnRTZWdzID0gbWVtb2l6ZShzb3J0RXZlbnRTZWdzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVE9ETzogbWVtb2l6ZSBldmVudC1wbGFjZW1lbnQ/XHJcbiAgICAgICAgcmVuZGVyKCkge1xyXG4gICAgICAgICAgICBsZXQgeyBwcm9wcywgY29udGV4dCB9ID0gdGhpcztcclxuICAgICAgICAgICAgbGV0IHsgb3B0aW9ucyB9ID0gY29udGV4dDtcclxuICAgICAgICAgICAgbGV0IGlzU2VsZWN0TWlycm9yID0gb3B0aW9ucy5zZWxlY3RNaXJyb3I7XHJcbiAgICAgICAgICAgIGxldCBtaXJyb3JTZWdzID0gLy8geXVja1xyXG4gICAgICAgICAgICAgKHByb3BzLmV2ZW50RHJhZyAmJiBwcm9wcy5ldmVudERyYWcuc2VncykgfHxcclxuICAgICAgICAgICAgICAgIChwcm9wcy5ldmVudFJlc2l6ZSAmJiBwcm9wcy5ldmVudFJlc2l6ZS5zZWdzKSB8fFxyXG4gICAgICAgICAgICAgICAgKGlzU2VsZWN0TWlycm9yICYmIHByb3BzLmRhdGVTZWxlY3Rpb25TZWdzKSB8fFxyXG4gICAgICAgICAgICAgICAgW107XHJcbiAgICAgICAgICAgIGxldCBpbnRlcmFjdGlvbkFmZmVjdGVkSW5zdGFuY2VzID0gLy8gVE9ETzogbWVzc3kgd2F5IHRvIGNvbXB1dGUgdGhpc1xyXG4gICAgICAgICAgICAgKHByb3BzLmV2ZW50RHJhZyAmJiBwcm9wcy5ldmVudERyYWcuYWZmZWN0ZWRJbnN0YW5jZXMpIHx8XHJcbiAgICAgICAgICAgICAgICAocHJvcHMuZXZlbnRSZXNpemUgJiYgcHJvcHMuZXZlbnRSZXNpemUuYWZmZWN0ZWRJbnN0YW5jZXMpIHx8XHJcbiAgICAgICAgICAgICAgICB7fTtcclxuICAgICAgICAgICAgbGV0IHNvcnRlZEZnU2VncyA9IHRoaXMuc29ydEV2ZW50U2Vncyhwcm9wcy5mZ0V2ZW50U2Vncywgb3B0aW9ucy5ldmVudE9yZGVyKTtcclxuICAgICAgICAgICAgcmV0dXJuICh5KERheUNlbGxDb250YWluZXIsIHsgZWxUYWc6IFwidGRcIiwgZWxSZWY6IHByb3BzLmVsUmVmLCBlbENsYXNzZXM6IFtcclxuICAgICAgICAgICAgICAgICAgICAnZmMtdGltZWdyaWQtY29sJyxcclxuICAgICAgICAgICAgICAgICAgICAuLi4ocHJvcHMuZXh0cmFDbGFzc05hbWVzIHx8IFtdKSxcclxuICAgICAgICAgICAgICAgIF0sIGVsQXR0cnM6IE9iamVjdC5hc3NpZ24oeyByb2xlOiAnZ3JpZGNlbGwnIH0sIHByb3BzLmV4dHJhRGF0YUF0dHJzKSwgZGF0ZTogcHJvcHMuZGF0ZSwgZGF0ZVByb2ZpbGU6IHByb3BzLmRhdGVQcm9maWxlLCB0b2RheVJhbmdlOiBwcm9wcy50b2RheVJhbmdlLCBleHRyYVJlbmRlclByb3BzOiBwcm9wcy5leHRyYVJlbmRlclByb3BzIH0sIChJbm5lckNvbnRlbnQpID0+ICh5KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLXRpbWVncmlkLWNvbC1mcmFtZVwiIH0sXHJcbiAgICAgICAgICAgICAgICB5KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLXRpbWVncmlkLWNvbC1iZ1wiIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJGaWxsU2Vncyhwcm9wcy5idXNpbmVzc0hvdXJTZWdzLCAnbm9uLWJ1c2luZXNzJyksXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJGaWxsU2Vncyhwcm9wcy5iZ0V2ZW50U2VncywgJ2JnLWV2ZW50JyksXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJGaWxsU2Vncyhwcm9wcy5kYXRlU2VsZWN0aW9uU2VncywgJ2hpZ2hsaWdodCcpKSxcclxuICAgICAgICAgICAgICAgIHkoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtdGltZWdyaWQtY29sLWV2ZW50c1wiIH0sIHRoaXMucmVuZGVyRmdTZWdzKHNvcnRlZEZnU2VncywgaW50ZXJhY3Rpb25BZmZlY3RlZEluc3RhbmNlcywgZmFsc2UsIGZhbHNlLCBmYWxzZSkpLFxyXG4gICAgICAgICAgICAgICAgeShcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy10aW1lZ3JpZC1jb2wtZXZlbnRzXCIgfSwgdGhpcy5yZW5kZXJGZ1NlZ3MobWlycm9yU2Vncywge30sIEJvb2xlYW4ocHJvcHMuZXZlbnREcmFnKSwgQm9vbGVhbihwcm9wcy5ldmVudFJlc2l6ZSksIEJvb2xlYW4oaXNTZWxlY3RNaXJyb3IpLCAnbWlycm9yJykpLFxyXG4gICAgICAgICAgICAgICAgeShcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy10aW1lZ3JpZC1ub3ctaW5kaWNhdG9yLWNvbnRhaW5lclwiIH0sIHRoaXMucmVuZGVyTm93SW5kaWNhdG9yKHByb3BzLm5vd0luZGljYXRvclNlZ3MpKSxcclxuICAgICAgICAgICAgICAgIGhhc0N1c3RvbURheUNlbGxDb250ZW50KG9wdGlvbnMpICYmICh5KElubmVyQ29udGVudCwgeyBlbFRhZzogXCJkaXZcIiwgZWxDbGFzc2VzOiBbJ2ZjLXRpbWVncmlkLWNvbC1taXNjJ10gfSkpKSkpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVuZGVyRmdTZWdzKHNvcnRlZEZnU2Vncywgc2VnSXNJbnZpc2libGUsIGlzRHJhZ2dpbmcsIGlzUmVzaXppbmcsIGlzRGF0ZVNlbGVjdGluZywgZm9yY2VkS2V5KSB7XHJcbiAgICAgICAgICAgIGxldCB7IHByb3BzIH0gPSB0aGlzO1xyXG4gICAgICAgICAgICBpZiAocHJvcHMuZm9yUHJpbnQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZW5kZXJQbGFpbkZnU2Vncyhzb3J0ZWRGZ1NlZ3MsIHByb3BzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJQb3NpdGlvbmVkRmdTZWdzKHNvcnRlZEZnU2Vncywgc2VnSXNJbnZpc2libGUsIGlzRHJhZ2dpbmcsIGlzUmVzaXppbmcsIGlzRGF0ZVNlbGVjdGluZywgZm9yY2VkS2V5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVuZGVyUG9zaXRpb25lZEZnU2VncyhzZWdzLCAvLyBpZiBub3QgbWlycm9yLCBuZWVkcyB0byBiZSBzb3J0ZWRcclxuICAgICAgICBzZWdJc0ludmlzaWJsZSwgaXNEcmFnZ2luZywgaXNSZXNpemluZywgaXNEYXRlU2VsZWN0aW5nLCBmb3JjZWRLZXkpIHtcclxuICAgICAgICAgICAgbGV0IHsgZXZlbnRNYXhTdGFjaywgZXZlbnRTaG9ydEhlaWdodCwgZXZlbnRPcmRlclN0cmljdCwgZXZlbnRNaW5IZWlnaHQgfSA9IHRoaXMuY29udGV4dC5vcHRpb25zO1xyXG4gICAgICAgICAgICBsZXQgeyBkYXRlLCBzbGF0Q29vcmRzLCBldmVudFNlbGVjdGlvbiwgdG9kYXlSYW5nZSwgbm93RGF0ZSB9ID0gdGhpcy5wcm9wcztcclxuICAgICAgICAgICAgbGV0IGlzTWlycm9yID0gaXNEcmFnZ2luZyB8fCBpc1Jlc2l6aW5nIHx8IGlzRGF0ZVNlbGVjdGluZztcclxuICAgICAgICAgICAgbGV0IHNlZ1ZDb29yZHMgPSBjb21wdXRlU2VnVkNvb3JkcyhzZWdzLCBkYXRlLCBzbGF0Q29vcmRzLCBldmVudE1pbkhlaWdodCk7XHJcbiAgICAgICAgICAgIGxldCB7IHNlZ1BsYWNlbWVudHMsIGhpZGRlbkdyb3VwcyB9ID0gY29tcHV0ZUZnU2VnUGxhY2VtZW50cyhzZWdzLCBzZWdWQ29vcmRzLCBldmVudE9yZGVyU3RyaWN0LCBldmVudE1heFN0YWNrKTtcclxuICAgICAgICAgICAgcmV0dXJuICh5KF8sIG51bGwsXHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlckhpZGRlbkdyb3VwcyhoaWRkZW5Hcm91cHMsIHNlZ3MpLFxyXG4gICAgICAgICAgICAgICAgc2VnUGxhY2VtZW50cy5tYXAoKHNlZ1BsYWNlbWVudCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCB7IHNlZywgcmVjdCB9ID0gc2VnUGxhY2VtZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBpbnN0YW5jZUlkID0gc2VnLmV2ZW50UmFuZ2UuaW5zdGFuY2UuaW5zdGFuY2VJZDtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgaXNWaXNpYmxlID0gaXNNaXJyb3IgfHwgQm9vbGVhbighc2VnSXNJbnZpc2libGVbaW5zdGFuY2VJZF0gJiYgcmVjdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHZTdHlsZSA9IGNvbXB1dGVTZWdWU3R5bGUocmVjdCAmJiByZWN0LnNwYW4pO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBoU3R5bGUgPSAoIWlzTWlycm9yICYmIHJlY3QpID8gdGhpcy5jb21wdXRlU2VnSFN0eWxlKHJlY3QpIDogeyBsZWZ0OiAwLCByaWdodDogMCB9O1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBpc0luc2V0ID0gQm9vbGVhbihyZWN0KSAmJiByZWN0LnN0YWNrRm9yd2FyZCA+IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGlzU2hvcnQgPSBCb29sZWFuKHJlY3QpICYmIChyZWN0LnNwYW4uZW5kIC0gcmVjdC5zcGFuLnN0YXJ0KSA8IGV2ZW50U2hvcnRIZWlnaHQ7IC8vIGxvb2sgYXQgb3RoZXIgcGxhY2VzIGZvciB0aGlzIHByb2JsZW1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHkoXCJkaXZcIiwgeyBjbGFzc05hbWU6ICdmYy10aW1lZ3JpZC1ldmVudC1oYXJuZXNzJyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoaXNJbnNldCA/ICcgZmMtdGltZWdyaWQtZXZlbnQtaGFybmVzcy1pbnNldCcgOiAnJyksIGtleTogZm9yY2VkS2V5IHx8IGluc3RhbmNlSWQsIHN0eWxlOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyB2aXNpYmlsaXR5OiBpc1Zpc2libGUgPyAnJyA6ICdoaWRkZW4nIH0sIHZTdHlsZSksIGhTdHlsZSkgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgeShUaW1lQ29sRXZlbnQsIE9iamVjdC5hc3NpZ24oeyBzZWc6IHNlZywgaXNEcmFnZ2luZzogaXNEcmFnZ2luZywgaXNSZXNpemluZzogaXNSZXNpemluZywgaXNEYXRlU2VsZWN0aW5nOiBpc0RhdGVTZWxlY3RpbmcsIGlzU2VsZWN0ZWQ6IGluc3RhbmNlSWQgPT09IGV2ZW50U2VsZWN0aW9uLCBpc1Nob3J0OiBpc1Nob3J0IH0sIGdldFNlZ01ldGEoc2VnLCB0b2RheVJhbmdlLCBub3dEYXRlKSkpKSk7XHJcbiAgICAgICAgICAgICAgICB9KSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyB3aWxsIGFscmVhZHkgaGF2ZSBldmVudE1pbkhlaWdodCBhcHBsaWVkIGJlY2F1c2Ugc2VnSW5wdXRzIGFscmVhZHkgaGFkIGl0XHJcbiAgICAgICAgcmVuZGVySGlkZGVuR3JvdXBzKGhpZGRlbkdyb3Vwcywgc2Vncykge1xyXG4gICAgICAgICAgICBsZXQgeyBleHRyYURhdGVTcGFuLCBkYXRlUHJvZmlsZSwgdG9kYXlSYW5nZSwgbm93RGF0ZSwgZXZlbnRTZWxlY3Rpb24sIGV2ZW50RHJhZywgZXZlbnRSZXNpemUgfSA9IHRoaXMucHJvcHM7XHJcbiAgICAgICAgICAgIHJldHVybiAoeShfLCBudWxsLCBoaWRkZW5Hcm91cHMubWFwKChoaWRkZW5Hcm91cCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgbGV0IHBvc2l0aW9uQ3NzID0gY29tcHV0ZVNlZ1ZTdHlsZShoaWRkZW5Hcm91cC5zcGFuKTtcclxuICAgICAgICAgICAgICAgIGxldCBoaWRkZW5TZWdzID0gY29tcGlsZVNlZ3NGcm9tRW50cmllcyhoaWRkZW5Hcm91cC5lbnRyaWVzLCBzZWdzKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiAoeShUaW1lQ29sTW9yZUxpbmssIHsga2V5OiBidWlsZElzb1N0cmluZyhjb21wdXRlRWFybGllc3RTZWdTdGFydChoaWRkZW5TZWdzKSksIGhpZGRlblNlZ3M6IGhpZGRlblNlZ3MsIHRvcDogcG9zaXRpb25Dc3MudG9wLCBib3R0b206IHBvc2l0aW9uQ3NzLmJvdHRvbSwgZXh0cmFEYXRlU3BhbjogZXh0cmFEYXRlU3BhbiwgZGF0ZVByb2ZpbGU6IGRhdGVQcm9maWxlLCB0b2RheVJhbmdlOiB0b2RheVJhbmdlLCBub3dEYXRlOiBub3dEYXRlLCBldmVudFNlbGVjdGlvbjogZXZlbnRTZWxlY3Rpb24sIGV2ZW50RHJhZzogZXZlbnREcmFnLCBldmVudFJlc2l6ZTogZXZlbnRSZXNpemUgfSkpO1xyXG4gICAgICAgICAgICB9KSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZW5kZXJGaWxsU2VncyhzZWdzLCBmaWxsVHlwZSkge1xyXG4gICAgICAgICAgICBsZXQgeyBwcm9wcywgY29udGV4dCB9ID0gdGhpcztcclxuICAgICAgICAgICAgbGV0IHNlZ1ZDb29yZHMgPSBjb21wdXRlU2VnVkNvb3JkcyhzZWdzLCBwcm9wcy5kYXRlLCBwcm9wcy5zbGF0Q29vcmRzLCBjb250ZXh0Lm9wdGlvbnMuZXZlbnRNaW5IZWlnaHQpOyAvLyBkb24ndCBhc3N1bWUgYWxsIHBvcHVsYXRlZFxyXG4gICAgICAgICAgICBsZXQgY2hpbGRyZW4gPSBzZWdWQ29vcmRzLm1hcCgodmNvb3JkcywgaSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgbGV0IHNlZyA9IHNlZ3NbaV07XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKHkoXCJkaXZcIiwgeyBrZXk6IGJ1aWxkRXZlbnRSYW5nZUtleShzZWcuZXZlbnRSYW5nZSksIGNsYXNzTmFtZTogXCJmYy10aW1lZ3JpZC1iZy1oYXJuZXNzXCIsIHN0eWxlOiBjb21wdXRlU2VnVlN0eWxlKHZjb29yZHMpIH0sIGZpbGxUeXBlID09PSAnYmctZXZlbnQnID9cclxuICAgICAgICAgICAgICAgICAgICB5KEJnRXZlbnQsIE9iamVjdC5hc3NpZ24oeyBzZWc6IHNlZyB9LCBnZXRTZWdNZXRhKHNlZywgcHJvcHMudG9kYXlSYW5nZSwgcHJvcHMubm93RGF0ZSkpKSA6XHJcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyRmlsbChmaWxsVHlwZSkpKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiB5KF8sIG51bGwsIGNoaWxkcmVuKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVuZGVyTm93SW5kaWNhdG9yKHNlZ3MpIHtcclxuICAgICAgICAgICAgbGV0IHsgc2xhdENvb3JkcywgZGF0ZSB9ID0gdGhpcy5wcm9wcztcclxuICAgICAgICAgICAgaWYgKCFzbGF0Q29vcmRzKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gc2Vncy5tYXAoKHNlZywgaSkgPT4gKHkoTm93SW5kaWNhdG9yQ29udGFpbmVyXHJcbiAgICAgICAgICAgIC8vIGtleSBkb2Vzbid0IG1hdHRlci4gd2lsbCBvbmx5IGV2ZXIgYmUgb25lXHJcbiAgICAgICAgICAgICwgeyBcclxuICAgICAgICAgICAgICAgIC8vIGtleSBkb2Vzbid0IG1hdHRlci4gd2lsbCBvbmx5IGV2ZXIgYmUgb25lXHJcbiAgICAgICAgICAgICAgICBrZXk6IGksIGVsQ2xhc3NlczogWydmYy10aW1lZ3JpZC1ub3ctaW5kaWNhdG9yLWxpbmUnXSwgZWxTdHlsZToge1xyXG4gICAgICAgICAgICAgICAgICAgIHRvcDogc2xhdENvb3Jkcy5jb21wdXRlRGF0ZVRvcChzZWcuc3RhcnQsIGRhdGUpLFxyXG4gICAgICAgICAgICAgICAgfSwgaXNBeGlzOiBmYWxzZSwgZGF0ZTogZGF0ZSB9KSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb21wdXRlU2VnSFN0eWxlKHNlZ0hDb29yZHMpIHtcclxuICAgICAgICAgICAgbGV0IHsgaXNSdGwsIG9wdGlvbnMgfSA9IHRoaXMuY29udGV4dDtcclxuICAgICAgICAgICAgbGV0IHNob3VsZE92ZXJsYXAgPSBvcHRpb25zLnNsb3RFdmVudE92ZXJsYXA7XHJcbiAgICAgICAgICAgIGxldCBuZWFyQ29vcmQgPSBzZWdIQ29vcmRzLmxldmVsQ29vcmQ7IC8vIHRoZSBsZWZ0IHNpZGUgaWYgTFRSLiB0aGUgcmlnaHQgc2lkZSBpZiBSVEwuIGZsb2F0aW5nLXBvaW50XHJcbiAgICAgICAgICAgIGxldCBmYXJDb29yZCA9IHNlZ0hDb29yZHMubGV2ZWxDb29yZCArIHNlZ0hDb29yZHMudGhpY2tuZXNzOyAvLyB0aGUgcmlnaHQgc2lkZSBpZiBMVFIuIHRoZSBsZWZ0IHNpZGUgaWYgUlRMLiBmbG9hdGluZy1wb2ludFxyXG4gICAgICAgICAgICBsZXQgbGVmdDsgLy8gYW1vdW50IG9mIHNwYWNlIGZyb20gbGVmdCBlZGdlLCBhIGZyYWN0aW9uIG9mIHRoZSB0b3RhbCB3aWR0aFxyXG4gICAgICAgICAgICBsZXQgcmlnaHQ7IC8vIGFtb3VudCBvZiBzcGFjZSBmcm9tIHJpZ2h0IGVkZ2UsIGEgZnJhY3Rpb24gb2YgdGhlIHRvdGFsIHdpZHRoXHJcbiAgICAgICAgICAgIGlmIChzaG91bGRPdmVybGFwKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBkb3VibGUgdGhlIHdpZHRoLCBidXQgZG9uJ3QgZ28gYmV5b25kIHRoZSBtYXhpbXVtIGZvcndhcmQgY29vcmRpbmF0ZSAoMS4wKVxyXG4gICAgICAgICAgICAgICAgZmFyQ29vcmQgPSBNYXRoLm1pbigxLCBuZWFyQ29vcmQgKyAoZmFyQ29vcmQgLSBuZWFyQ29vcmQpICogMik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGlzUnRsKSB7XHJcbiAgICAgICAgICAgICAgICBsZWZ0ID0gMSAtIGZhckNvb3JkO1xyXG4gICAgICAgICAgICAgICAgcmlnaHQgPSBuZWFyQ29vcmQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBsZWZ0ID0gbmVhckNvb3JkO1xyXG4gICAgICAgICAgICAgICAgcmlnaHQgPSAxIC0gZmFyQ29vcmQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IHByb3BzID0ge1xyXG4gICAgICAgICAgICAgICAgekluZGV4OiBzZWdIQ29vcmRzLnN0YWNrRGVwdGggKyAxLFxyXG4gICAgICAgICAgICAgICAgbGVmdDogbGVmdCAqIDEwMCArICclJyxcclxuICAgICAgICAgICAgICAgIHJpZ2h0OiByaWdodCAqIDEwMCArICclJyxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgaWYgKHNob3VsZE92ZXJsYXAgJiYgIXNlZ0hDb29yZHMuc3RhY2tGb3J3YXJkKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBhZGQgcGFkZGluZyB0byB0aGUgZWRnZSBzbyB0aGF0IGZvcndhcmQgc3RhY2tlZCBldmVudHMgZG9uJ3QgY292ZXIgdGhlIHJlc2l6ZXIncyBpY29uXHJcbiAgICAgICAgICAgICAgICBwcm9wc1tpc1J0bCA/ICdtYXJnaW5MZWZ0JyA6ICdtYXJnaW5SaWdodCddID0gMTAgKiAyOyAvLyAxMCBpcyBhIGd1ZXNzdGltYXRlIG9mIHRoZSBpY29uJ3Mgd2lkdGhcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcHJvcHM7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gcmVuZGVyUGxhaW5GZ1NlZ3Moc29ydGVkRmdTZWdzLCB7IHRvZGF5UmFuZ2UsIG5vd0RhdGUsIGV2ZW50U2VsZWN0aW9uLCBldmVudERyYWcsIGV2ZW50UmVzaXplIH0pIHtcclxuICAgICAgICBsZXQgaGlkZGVuSW5zdGFuY2VzID0gKGV2ZW50RHJhZyA/IGV2ZW50RHJhZy5hZmZlY3RlZEluc3RhbmNlcyA6IG51bGwpIHx8XHJcbiAgICAgICAgICAgIChldmVudFJlc2l6ZSA/IGV2ZW50UmVzaXplLmFmZmVjdGVkSW5zdGFuY2VzIDogbnVsbCkgfHxcclxuICAgICAgICAgICAge307XHJcbiAgICAgICAgcmV0dXJuICh5KF8sIG51bGwsIHNvcnRlZEZnU2Vncy5tYXAoKHNlZykgPT4ge1xyXG4gICAgICAgICAgICBsZXQgaW5zdGFuY2VJZCA9IHNlZy5ldmVudFJhbmdlLmluc3RhbmNlLmluc3RhbmNlSWQ7XHJcbiAgICAgICAgICAgIHJldHVybiAoeShcImRpdlwiLCB7IGtleTogaW5zdGFuY2VJZCwgc3R5bGU6IHsgdmlzaWJpbGl0eTogaGlkZGVuSW5zdGFuY2VzW2luc3RhbmNlSWRdID8gJ2hpZGRlbicgOiAnJyB9IH0sXHJcbiAgICAgICAgICAgICAgICB5KFRpbWVDb2xFdmVudCwgT2JqZWN0LmFzc2lnbih7IHNlZzogc2VnLCBpc0RyYWdnaW5nOiBmYWxzZSwgaXNSZXNpemluZzogZmFsc2UsIGlzRGF0ZVNlbGVjdGluZzogZmFsc2UsIGlzU2VsZWN0ZWQ6IGluc3RhbmNlSWQgPT09IGV2ZW50U2VsZWN0aW9uLCBpc1Nob3J0OiBmYWxzZSB9LCBnZXRTZWdNZXRhKHNlZywgdG9kYXlSYW5nZSwgbm93RGF0ZSkpKSkpO1xyXG4gICAgICAgIH0pKSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBjb21wdXRlU2VnVlN0eWxlKHNlZ1ZDb29yZHMpIHtcclxuICAgICAgICBpZiAoIXNlZ1ZDb29yZHMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHsgdG9wOiAnJywgYm90dG9tOiAnJyB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB0b3A6IHNlZ1ZDb29yZHMuc3RhcnQsXHJcbiAgICAgICAgICAgIGJvdHRvbTogLXNlZ1ZDb29yZHMuZW5kLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBjb21waWxlU2Vnc0Zyb21FbnRyaWVzKHNlZ0VudHJpZXMsIGFsbFNlZ3MpIHtcclxuICAgICAgICByZXR1cm4gc2VnRW50cmllcy5tYXAoKHNlZ0VudHJ5KSA9PiBhbGxTZWdzW3NlZ0VudHJ5LmluZGV4XSk7XHJcbiAgICB9XHJcblxyXG4gICAgY2xhc3MgVGltZUNvbHNDb250ZW50IGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XHJcbiAgICAgICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgIHRoaXMuc3BsaXRGZ0V2ZW50U2VncyA9IG1lbW9pemUoc3BsaXRTZWdzQnlDb2wpO1xyXG4gICAgICAgICAgICB0aGlzLnNwbGl0QmdFdmVudFNlZ3MgPSBtZW1vaXplKHNwbGl0U2Vnc0J5Q29sKTtcclxuICAgICAgICAgICAgdGhpcy5zcGxpdEJ1c2luZXNzSG91clNlZ3MgPSBtZW1vaXplKHNwbGl0U2Vnc0J5Q29sKTtcclxuICAgICAgICAgICAgdGhpcy5zcGxpdE5vd0luZGljYXRvclNlZ3MgPSBtZW1vaXplKHNwbGl0U2Vnc0J5Q29sKTtcclxuICAgICAgICAgICAgdGhpcy5zcGxpdERhdGVTZWxlY3Rpb25TZWdzID0gbWVtb2l6ZShzcGxpdFNlZ3NCeUNvbCk7XHJcbiAgICAgICAgICAgIHRoaXMuc3BsaXRFdmVudERyYWcgPSBtZW1vaXplKHNwbGl0SW50ZXJhY3Rpb25CeUNvbCk7XHJcbiAgICAgICAgICAgIHRoaXMuc3BsaXRFdmVudFJlc2l6ZSA9IG1lbW9pemUoc3BsaXRJbnRlcmFjdGlvbkJ5Q29sKTtcclxuICAgICAgICAgICAgdGhpcy5yb290RWxSZWYgPSBkKCk7XHJcbiAgICAgICAgICAgIHRoaXMuY2VsbEVsUmVmcyA9IG5ldyBSZWZNYXAoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVuZGVyKCkge1xyXG4gICAgICAgICAgICBsZXQgeyBwcm9wcywgY29udGV4dCB9ID0gdGhpcztcclxuICAgICAgICAgICAgbGV0IG5vd0luZGljYXRvclRvcCA9IGNvbnRleHQub3B0aW9ucy5ub3dJbmRpY2F0b3IgJiZcclxuICAgICAgICAgICAgICAgIHByb3BzLnNsYXRDb29yZHMgJiZcclxuICAgICAgICAgICAgICAgIHByb3BzLnNsYXRDb29yZHMuc2FmZUNvbXB1dGVUb3AocHJvcHMubm93RGF0ZSk7IC8vIG1pZ2h0IHJldHVybiB2b2lkXHJcbiAgICAgICAgICAgIGxldCBjb2xDbnQgPSBwcm9wcy5jZWxscy5sZW5ndGg7XHJcbiAgICAgICAgICAgIGxldCBmZ0V2ZW50U2Vnc0J5Um93ID0gdGhpcy5zcGxpdEZnRXZlbnRTZWdzKHByb3BzLmZnRXZlbnRTZWdzLCBjb2xDbnQpO1xyXG4gICAgICAgICAgICBsZXQgYmdFdmVudFNlZ3NCeVJvdyA9IHRoaXMuc3BsaXRCZ0V2ZW50U2Vncyhwcm9wcy5iZ0V2ZW50U2VncywgY29sQ250KTtcclxuICAgICAgICAgICAgbGV0IGJ1c2luZXNzSG91clNlZ3NCeVJvdyA9IHRoaXMuc3BsaXRCdXNpbmVzc0hvdXJTZWdzKHByb3BzLmJ1c2luZXNzSG91clNlZ3MsIGNvbENudCk7XHJcbiAgICAgICAgICAgIGxldCBub3dJbmRpY2F0b3JTZWdzQnlSb3cgPSB0aGlzLnNwbGl0Tm93SW5kaWNhdG9yU2Vncyhwcm9wcy5ub3dJbmRpY2F0b3JTZWdzLCBjb2xDbnQpO1xyXG4gICAgICAgICAgICBsZXQgZGF0ZVNlbGVjdGlvblNlZ3NCeVJvdyA9IHRoaXMuc3BsaXREYXRlU2VsZWN0aW9uU2Vncyhwcm9wcy5kYXRlU2VsZWN0aW9uU2VncywgY29sQ250KTtcclxuICAgICAgICAgICAgbGV0IGV2ZW50RHJhZ0J5Um93ID0gdGhpcy5zcGxpdEV2ZW50RHJhZyhwcm9wcy5ldmVudERyYWcsIGNvbENudCk7XHJcbiAgICAgICAgICAgIGxldCBldmVudFJlc2l6ZUJ5Um93ID0gdGhpcy5zcGxpdEV2ZW50UmVzaXplKHByb3BzLmV2ZW50UmVzaXplLCBjb2xDbnQpO1xyXG4gICAgICAgICAgICByZXR1cm4gKHkoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtdGltZWdyaWQtY29sc1wiLCByZWY6IHRoaXMucm9vdEVsUmVmIH0sXHJcbiAgICAgICAgICAgICAgICB5KFwidGFibGVcIiwgeyByb2xlOiBcInByZXNlbnRhdGlvblwiLCBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5XaWR0aDogcHJvcHMudGFibGVNaW5XaWR0aCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHByb3BzLmNsaWVudFdpZHRoLFxyXG4gICAgICAgICAgICAgICAgICAgIH0gfSxcclxuICAgICAgICAgICAgICAgICAgICBwcm9wcy50YWJsZUNvbEdyb3VwTm9kZSxcclxuICAgICAgICAgICAgICAgICAgICB5KFwidGJvZHlcIiwgeyByb2xlOiBcInByZXNlbnRhdGlvblwiIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHkoXCJ0clwiLCB7IHJvbGU6IFwicm93XCIgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzLmF4aXMgJiYgKHkoXCJ0ZFwiLCB7IFwiYXJpYS1oaWRkZW5cIjogdHJ1ZSwgY2xhc3NOYW1lOiBcImZjLXRpbWVncmlkLWNvbCBmYy10aW1lZ3JpZC1heGlzXCIgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLXRpbWVncmlkLWNvbC1mcmFtZVwiIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtdGltZWdyaWQtbm93LWluZGljYXRvci1jb250YWluZXJcIiB9LCB0eXBlb2Ygbm93SW5kaWNhdG9yVG9wID09PSAnbnVtYmVyJyAmJiAoeShOb3dJbmRpY2F0b3JDb250YWluZXIsIHsgZWxDbGFzc2VzOiBbJ2ZjLXRpbWVncmlkLW5vdy1pbmRpY2F0b3ItYXJyb3cnXSwgZWxTdHlsZTogeyB0b3A6IG5vd0luZGljYXRvclRvcCB9LCBpc0F4aXM6IHRydWUsIGRhdGU6IHByb3BzLm5vd0RhdGUgfSkpKSkpKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzLmNlbGxzLm1hcCgoY2VsbCwgaSkgPT4gKHkoVGltZUNvbCwgeyBrZXk6IGNlbGwua2V5LCBlbFJlZjogdGhpcy5jZWxsRWxSZWZzLmNyZWF0ZVJlZihjZWxsLmtleSksIGRhdGVQcm9maWxlOiBwcm9wcy5kYXRlUHJvZmlsZSwgZGF0ZTogY2VsbC5kYXRlLCBub3dEYXRlOiBwcm9wcy5ub3dEYXRlLCB0b2RheVJhbmdlOiBwcm9wcy50b2RheVJhbmdlLCBleHRyYVJlbmRlclByb3BzOiBjZWxsLmV4dHJhUmVuZGVyUHJvcHMsIGV4dHJhRGF0YUF0dHJzOiBjZWxsLmV4dHJhRGF0YUF0dHJzLCBleHRyYUNsYXNzTmFtZXM6IGNlbGwuZXh0cmFDbGFzc05hbWVzLCBleHRyYURhdGVTcGFuOiBjZWxsLmV4dHJhRGF0ZVNwYW4sIGZnRXZlbnRTZWdzOiBmZ0V2ZW50U2Vnc0J5Um93W2ldLCBiZ0V2ZW50U2VnczogYmdFdmVudFNlZ3NCeVJvd1tpXSwgYnVzaW5lc3NIb3VyU2VnczogYnVzaW5lc3NIb3VyU2Vnc0J5Um93W2ldLCBub3dJbmRpY2F0b3JTZWdzOiBub3dJbmRpY2F0b3JTZWdzQnlSb3dbaV0sIGRhdGVTZWxlY3Rpb25TZWdzOiBkYXRlU2VsZWN0aW9uU2Vnc0J5Um93W2ldLCBldmVudERyYWc6IGV2ZW50RHJhZ0J5Um93W2ldLCBldmVudFJlc2l6ZTogZXZlbnRSZXNpemVCeVJvd1tpXSwgc2xhdENvb3JkczogcHJvcHMuc2xhdENvb3JkcywgZXZlbnRTZWxlY3Rpb246IHByb3BzLmV2ZW50U2VsZWN0aW9uLCBmb3JQcmludDogcHJvcHMuZm9yUHJpbnQgfSkpKSkpKSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb21wb25lbnREaWRNb3VudCgpIHtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVDb29yZHMoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29tcG9uZW50RGlkVXBkYXRlKCkge1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUNvb3JkcygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB1cGRhdGVDb29yZHMoKSB7XHJcbiAgICAgICAgICAgIGxldCB7IHByb3BzIH0gPSB0aGlzO1xyXG4gICAgICAgICAgICBpZiAocHJvcHMub25Db2xDb29yZHMgJiZcclxuICAgICAgICAgICAgICAgIHByb3BzLmNsaWVudFdpZHRoICE9PSBudWxsIC8vIG1lYW5zIHNpemluZyBoYXMgc3RhYmlsaXplZFxyXG4gICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICAgIHByb3BzLm9uQ29sQ29vcmRzKG5ldyBQb3NpdGlvbkNhY2hlKHRoaXMucm9vdEVsUmVmLmN1cnJlbnQsIGNvbGxlY3RDZWxsRWxzKHRoaXMuY2VsbEVsUmVmcy5jdXJyZW50TWFwLCBwcm9wcy5jZWxscyksIHRydWUsIC8vIGhvcml6b250YWxcclxuICAgICAgICAgICAgICAgIGZhbHNlKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBjb2xsZWN0Q2VsbEVscyhlbE1hcCwgY2VsbHMpIHtcclxuICAgICAgICByZXR1cm4gY2VsbHMubWFwKChjZWxsKSA9PiBlbE1hcFtjZWxsLmtleV0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qIEEgY29tcG9uZW50IHRoYXQgcmVuZGVycyBvbmUgb3IgbW9yZSBjb2x1bW5zIG9mIHZlcnRpY2FsIHRpbWUgc2xvdHNcclxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgY2xhc3MgVGltZUNvbHMgZXh0ZW5kcyBEYXRlQ29tcG9uZW50IHtcclxuICAgICAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgdGhpcy5wcm9jZXNzU2xvdE9wdGlvbnMgPSBtZW1vaXplKHByb2Nlc3NTbG90T3B0aW9ucyk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSB7XHJcbiAgICAgICAgICAgICAgICBzbGF0Q29vcmRzOiBudWxsLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB0aGlzLmhhbmRsZVJvb3RFbCA9IChlbCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LnJlZ2lzdGVySW50ZXJhY3RpdmVDb21wb25lbnQodGhpcywge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXNIaXRDb21ib0FsbG93ZWQ6IHRoaXMucHJvcHMuaXNIaXRDb21ib0FsbG93ZWQsXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQudW5yZWdpc3RlckludGVyYWN0aXZlQ29tcG9uZW50KHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB0aGlzLmhhbmRsZVNjcm9sbFJlcXVlc3QgPSAocmVxdWVzdCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgbGV0IHsgb25TY3JvbGxUb3BSZXF1ZXN0IH0gPSB0aGlzLnByb3BzO1xyXG4gICAgICAgICAgICAgICAgbGV0IHsgc2xhdENvb3JkcyB9ID0gdGhpcy5zdGF0ZTtcclxuICAgICAgICAgICAgICAgIGlmIChvblNjcm9sbFRvcFJlcXVlc3QgJiYgc2xhdENvb3Jkcykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXF1ZXN0LnRpbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHRvcCA9IHNsYXRDb29yZHMuY29tcHV0ZVRpbWVUb3AocmVxdWVzdC50aW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdG9wID0gTWF0aC5jZWlsKHRvcCk7IC8vIHpvb20gY2FuIGdpdmUgd2VpcmQgZmxvYXRpbmctcG9pbnQgdmFsdWVzLiByYXRoZXIgc2Nyb2xsIGEgbGl0dGxlIGJpdCBmdXJ0aGVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0b3ApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcCArPSAxOyAvLyB0byBvdmVyY29tZSB0b3AgYm9yZGVyIHRoYXQgc2xvdHMgYmV5b25kIHRoZSBmaXJzdCBoYXZlLiBsb29rcyBiZXR0ZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvblNjcm9sbFRvcFJlcXVlc3QodG9wKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlQ29sQ29vcmRzID0gKGNvbENvb3JkcykgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb2xDb29yZHMgPSBjb2xDb29yZHM7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlU2xhdENvb3JkcyA9IChzbGF0Q29vcmRzKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKHsgc2xhdENvb3JkcyB9KTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnByb3BzLm9uU2xhdENvb3Jkcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJvcHMub25TbGF0Q29vcmRzKHNsYXRDb29yZHMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZW5kZXIoKSB7XHJcbiAgICAgICAgICAgIGxldCB7IHByb3BzLCBzdGF0ZSB9ID0gdGhpcztcclxuICAgICAgICAgICAgcmV0dXJuICh5KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLXRpbWVncmlkLWJvZHlcIiwgcmVmOiB0aGlzLmhhbmRsZVJvb3RFbCwgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgICAgICAvLyB0aGVzZSBwcm9wcyBhcmUgaW1wb3J0YW50IHRvIGdpdmUgdGhpcyB3cmFwcGVyIGNvcnJlY3QgZGltZW5zaW9ucyBmb3IgaW50ZXJhY3Rpb25zXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogaWYgd2Ugc2V0IGl0IGhlcmUsIGNhbiB3ZSBhdm9pZCBnaXZpbmcgdG8gaW5uZXIgdGFibGVzP1xyXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBwcm9wcy5jbGllbnRXaWR0aCxcclxuICAgICAgICAgICAgICAgICAgICBtaW5XaWR0aDogcHJvcHMudGFibGVNaW5XaWR0aCxcclxuICAgICAgICAgICAgICAgIH0gfSxcclxuICAgICAgICAgICAgICAgIHkoVGltZUNvbHNTbGF0cywgeyBheGlzOiBwcm9wcy5heGlzLCBkYXRlUHJvZmlsZTogcHJvcHMuZGF0ZVByb2ZpbGUsIHNsYXRNZXRhczogcHJvcHMuc2xhdE1ldGFzLCBjbGllbnRXaWR0aDogcHJvcHMuY2xpZW50V2lkdGgsIG1pbkhlaWdodDogcHJvcHMuZXhwYW5kUm93cyA/IHByb3BzLmNsaWVudEhlaWdodCA6ICcnLCB0YWJsZU1pbldpZHRoOiBwcm9wcy50YWJsZU1pbldpZHRoLCB0YWJsZUNvbEdyb3VwTm9kZTogcHJvcHMuYXhpcyA/IHByb3BzLnRhYmxlQ29sR3JvdXBOb2RlIDogbnVsbCAvKiBheGlzIGRlcGVuZHMgb24gdGhlIGNvbGdyb3VwJ3Mgc2hyaW5raW5nICovLCBvbkNvb3JkczogdGhpcy5oYW5kbGVTbGF0Q29vcmRzIH0pLFxyXG4gICAgICAgICAgICAgICAgeShUaW1lQ29sc0NvbnRlbnQsIHsgY2VsbHM6IHByb3BzLmNlbGxzLCBheGlzOiBwcm9wcy5heGlzLCBkYXRlUHJvZmlsZTogcHJvcHMuZGF0ZVByb2ZpbGUsIGJ1c2luZXNzSG91clNlZ3M6IHByb3BzLmJ1c2luZXNzSG91clNlZ3MsIGJnRXZlbnRTZWdzOiBwcm9wcy5iZ0V2ZW50U2VncywgZmdFdmVudFNlZ3M6IHByb3BzLmZnRXZlbnRTZWdzLCBkYXRlU2VsZWN0aW9uU2VnczogcHJvcHMuZGF0ZVNlbGVjdGlvblNlZ3MsIGV2ZW50U2VsZWN0aW9uOiBwcm9wcy5ldmVudFNlbGVjdGlvbiwgZXZlbnREcmFnOiBwcm9wcy5ldmVudERyYWcsIGV2ZW50UmVzaXplOiBwcm9wcy5ldmVudFJlc2l6ZSwgdG9kYXlSYW5nZTogcHJvcHMudG9kYXlSYW5nZSwgbm93RGF0ZTogcHJvcHMubm93RGF0ZSwgbm93SW5kaWNhdG9yU2VnczogcHJvcHMubm93SW5kaWNhdG9yU2VncywgY2xpZW50V2lkdGg6IHByb3BzLmNsaWVudFdpZHRoLCB0YWJsZU1pbldpZHRoOiBwcm9wcy50YWJsZU1pbldpZHRoLCB0YWJsZUNvbEdyb3VwTm9kZTogcHJvcHMudGFibGVDb2xHcm91cE5vZGUsIHNsYXRDb29yZHM6IHN0YXRlLnNsYXRDb29yZHMsIG9uQ29sQ29vcmRzOiB0aGlzLmhhbmRsZUNvbENvb3JkcywgZm9yUHJpbnQ6IHByb3BzLmZvclByaW50IH0pKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xyXG4gICAgICAgICAgICB0aGlzLnNjcm9sbFJlc3BvbmRlciA9IHRoaXMuY29udGV4dC5jcmVhdGVTY3JvbGxSZXNwb25kZXIodGhpcy5oYW5kbGVTY3JvbGxSZXF1ZXN0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcykge1xyXG4gICAgICAgICAgICB0aGlzLnNjcm9sbFJlc3BvbmRlci51cGRhdGUocHJldlByb3BzLmRhdGVQcm9maWxlICE9PSB0aGlzLnByb3BzLmRhdGVQcm9maWxlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsUmVzcG9uZGVyLmRldGFjaCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBxdWVyeUhpdChwb3NpdGlvbkxlZnQsIHBvc2l0aW9uVG9wKSB7XHJcbiAgICAgICAgICAgIGxldCB7IGRhdGVFbnYsIG9wdGlvbnMgfSA9IHRoaXMuY29udGV4dDtcclxuICAgICAgICAgICAgbGV0IHsgY29sQ29vcmRzIH0gPSB0aGlzO1xyXG4gICAgICAgICAgICBsZXQgeyBkYXRlUHJvZmlsZSB9ID0gdGhpcy5wcm9wcztcclxuICAgICAgICAgICAgbGV0IHsgc2xhdENvb3JkcyB9ID0gdGhpcy5zdGF0ZTtcclxuICAgICAgICAgICAgbGV0IHsgc25hcER1cmF0aW9uLCBzbmFwc1BlclNsb3QgfSA9IHRoaXMucHJvY2Vzc1Nsb3RPcHRpb25zKHRoaXMucHJvcHMuc2xvdER1cmF0aW9uLCBvcHRpb25zLnNuYXBEdXJhdGlvbik7XHJcbiAgICAgICAgICAgIGxldCBjb2xJbmRleCA9IGNvbENvb3Jkcy5sZWZ0VG9JbmRleChwb3NpdGlvbkxlZnQpO1xyXG4gICAgICAgICAgICBsZXQgc2xhdEluZGV4ID0gc2xhdENvb3Jkcy5wb3NpdGlvbnMudG9wVG9JbmRleChwb3NpdGlvblRvcCk7XHJcbiAgICAgICAgICAgIGlmIChjb2xJbmRleCAhPSBudWxsICYmIHNsYXRJbmRleCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgY2VsbCA9IHRoaXMucHJvcHMuY2VsbHNbY29sSW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgbGV0IHNsYXRUb3AgPSBzbGF0Q29vcmRzLnBvc2l0aW9ucy50b3BzW3NsYXRJbmRleF07XHJcbiAgICAgICAgICAgICAgICBsZXQgc2xhdEhlaWdodCA9IHNsYXRDb29yZHMucG9zaXRpb25zLmdldEhlaWdodChzbGF0SW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgbGV0IHBhcnRpYWwgPSAocG9zaXRpb25Ub3AgLSBzbGF0VG9wKSAvIHNsYXRIZWlnaHQ7IC8vIGZsb2F0aW5nIHBvaW50IG51bWJlciBiZXR3ZWVuIDAgYW5kIDFcclxuICAgICAgICAgICAgICAgIGxldCBsb2NhbFNuYXBJbmRleCA9IE1hdGguZmxvb3IocGFydGlhbCAqIHNuYXBzUGVyU2xvdCk7IC8vIHRoZSBzbmFwICMgcmVsYXRpdmUgdG8gc3RhcnQgb2Ygc2xhdFxyXG4gICAgICAgICAgICAgICAgbGV0IHNuYXBJbmRleCA9IHNsYXRJbmRleCAqIHNuYXBzUGVyU2xvdCArIGxvY2FsU25hcEluZGV4O1xyXG4gICAgICAgICAgICAgICAgbGV0IGRheURhdGUgPSB0aGlzLnByb3BzLmNlbGxzW2NvbEluZGV4XS5kYXRlO1xyXG4gICAgICAgICAgICAgICAgbGV0IHRpbWUgPSBhZGREdXJhdGlvbnMoZGF0ZVByb2ZpbGUuc2xvdE1pblRpbWUsIG11bHRpcGx5RHVyYXRpb24oc25hcER1cmF0aW9uLCBzbmFwSW5kZXgpKTtcclxuICAgICAgICAgICAgICAgIGxldCBzdGFydCA9IGRhdGVFbnYuYWRkKGRheURhdGUsIHRpbWUpO1xyXG4gICAgICAgICAgICAgICAgbGV0IGVuZCA9IGRhdGVFbnYuYWRkKHN0YXJ0LCBzbmFwRHVyYXRpb24pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICBkYXRlUHJvZmlsZSxcclxuICAgICAgICAgICAgICAgICAgICBkYXRlU3BhbjogT2JqZWN0LmFzc2lnbih7IHJhbmdlOiB7IHN0YXJ0LCBlbmQgfSwgYWxsRGF5OiBmYWxzZSB9LCBjZWxsLmV4dHJhRGF0ZVNwYW4pLFxyXG4gICAgICAgICAgICAgICAgICAgIGRheUVsOiBjb2xDb29yZHMuZWxzW2NvbEluZGV4XSxcclxuICAgICAgICAgICAgICAgICAgICByZWN0OiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IGNvbENvb3Jkcy5sZWZ0c1tjb2xJbmRleF0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0OiBjb2xDb29yZHMucmlnaHRzW2NvbEluZGV4XSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiBzbGF0VG9wLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBib3R0b206IHNsYXRUb3AgKyBzbGF0SGVpZ2h0LFxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgbGF5ZXI6IDAsXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHByb2Nlc3NTbG90T3B0aW9ucyhzbG90RHVyYXRpb24sIHNuYXBEdXJhdGlvbk92ZXJyaWRlKSB7XHJcbiAgICAgICAgbGV0IHNuYXBEdXJhdGlvbiA9IHNuYXBEdXJhdGlvbk92ZXJyaWRlIHx8IHNsb3REdXJhdGlvbjtcclxuICAgICAgICBsZXQgc25hcHNQZXJTbG90ID0gd2hvbGVEaXZpZGVEdXJhdGlvbnMoc2xvdER1cmF0aW9uLCBzbmFwRHVyYXRpb24pO1xyXG4gICAgICAgIGlmIChzbmFwc1BlclNsb3QgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgc25hcER1cmF0aW9uID0gc2xvdER1cmF0aW9uO1xyXG4gICAgICAgICAgICBzbmFwc1BlclNsb3QgPSAxO1xyXG4gICAgICAgICAgICAvLyBUT0RPOiBzYXkgd2FybmluZz9cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHsgc25hcER1cmF0aW9uLCBzbmFwc1BlclNsb3QgfTtcclxuICAgIH1cclxuXHJcbiAgICBjbGFzcyBEYXlUaW1lQ29sc1NsaWNlciBleHRlbmRzIFNsaWNlciB7XHJcbiAgICAgICAgc2xpY2VSYW5nZShyYW5nZSwgZGF5UmFuZ2VzKSB7XHJcbiAgICAgICAgICAgIGxldCBzZWdzID0gW107XHJcbiAgICAgICAgICAgIGZvciAobGV0IGNvbCA9IDA7IGNvbCA8IGRheVJhbmdlcy5sZW5ndGg7IGNvbCArPSAxKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgc2VnUmFuZ2UgPSBpbnRlcnNlY3RSYW5nZXMocmFuZ2UsIGRheVJhbmdlc1tjb2xdKTtcclxuICAgICAgICAgICAgICAgIGlmIChzZWdSYW5nZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlZ3MucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBzZWdSYW5nZS5zdGFydCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiBzZWdSYW5nZS5lbmQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzU3RhcnQ6IHNlZ1JhbmdlLnN0YXJ0LnZhbHVlT2YoKSA9PT0gcmFuZ2Uuc3RhcnQudmFsdWVPZigpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0VuZDogc2VnUmFuZ2UuZW5kLnZhbHVlT2YoKSA9PT0gcmFuZ2UuZW5kLnZhbHVlT2YoKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29sLFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBzZWdzO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBjbGFzcyBEYXlUaW1lQ29scyBleHRlbmRzIERhdGVDb21wb25lbnQge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgICAgICB0aGlzLmJ1aWxkRGF5UmFuZ2VzID0gbWVtb2l6ZShidWlsZERheVJhbmdlcyk7XHJcbiAgICAgICAgICAgIHRoaXMuc2xpY2VyID0gbmV3IERheVRpbWVDb2xzU2xpY2VyKCk7XHJcbiAgICAgICAgICAgIHRoaXMudGltZUNvbHNSZWYgPSBkKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlbmRlcigpIHtcclxuICAgICAgICAgICAgbGV0IHsgcHJvcHMsIGNvbnRleHQgfSA9IHRoaXM7XHJcbiAgICAgICAgICAgIGxldCB7IGRhdGVQcm9maWxlLCBkYXlUYWJsZU1vZGVsIH0gPSBwcm9wcztcclxuICAgICAgICAgICAgbGV0IHsgbm93SW5kaWNhdG9yLCBuZXh0RGF5VGhyZXNob2xkIH0gPSBjb250ZXh0Lm9wdGlvbnM7XHJcbiAgICAgICAgICAgIGxldCBkYXlSYW5nZXMgPSB0aGlzLmJ1aWxkRGF5UmFuZ2VzKGRheVRhYmxlTW9kZWwsIGRhdGVQcm9maWxlLCBjb250ZXh0LmRhdGVFbnYpO1xyXG4gICAgICAgICAgICAvLyBnaXZlIGl0IHRoZSBmaXJzdCByb3cgb2YgY2VsbHNcclxuICAgICAgICAgICAgLy8gVE9ETzogd291bGQgbW92ZSB0aGlzIGZ1cnRoZXIgZG93biBoaWVyYXJjaHksIGJ1dCBzbGljZU5vd0RhdGUgbmVlZHMgaXRcclxuICAgICAgICAgICAgcmV0dXJuICh5KE5vd1RpbWVyLCB7IHVuaXQ6IG5vd0luZGljYXRvciA/ICdtaW51dGUnIDogJ2RheScgfSwgKG5vd0RhdGUsIHRvZGF5UmFuZ2UpID0+ICh5KFRpbWVDb2xzLCBPYmplY3QuYXNzaWduKHsgcmVmOiB0aGlzLnRpbWVDb2xzUmVmIH0sIHRoaXMuc2xpY2VyLnNsaWNlUHJvcHMocHJvcHMsIGRhdGVQcm9maWxlLCBudWxsLCBjb250ZXh0LCBkYXlSYW5nZXMpLCB7IGZvclByaW50OiBwcm9wcy5mb3JQcmludCwgYXhpczogcHJvcHMuYXhpcywgZGF0ZVByb2ZpbGU6IGRhdGVQcm9maWxlLCBzbGF0TWV0YXM6IHByb3BzLnNsYXRNZXRhcywgc2xvdER1cmF0aW9uOiBwcm9wcy5zbG90RHVyYXRpb24sIGNlbGxzOiBkYXlUYWJsZU1vZGVsLmNlbGxzWzBdLCB0YWJsZUNvbEdyb3VwTm9kZTogcHJvcHMudGFibGVDb2xHcm91cE5vZGUsIHRhYmxlTWluV2lkdGg6IHByb3BzLnRhYmxlTWluV2lkdGgsIGNsaWVudFdpZHRoOiBwcm9wcy5jbGllbnRXaWR0aCwgY2xpZW50SGVpZ2h0OiBwcm9wcy5jbGllbnRIZWlnaHQsIGV4cGFuZFJvd3M6IHByb3BzLmV4cGFuZFJvd3MsIG5vd0RhdGU6IG5vd0RhdGUsIG5vd0luZGljYXRvclNlZ3M6IG5vd0luZGljYXRvciAmJiB0aGlzLnNsaWNlci5zbGljZU5vd0RhdGUobm93RGF0ZSwgZGF0ZVByb2ZpbGUsIG5leHREYXlUaHJlc2hvbGQsIGNvbnRleHQsIGRheVJhbmdlcyksIHRvZGF5UmFuZ2U6IHRvZGF5UmFuZ2UsIG9uU2Nyb2xsVG9wUmVxdWVzdDogcHJvcHMub25TY3JvbGxUb3BSZXF1ZXN0LCBvblNsYXRDb29yZHM6IHByb3BzLm9uU2xhdENvb3JkcyB9KSkpKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYnVpbGREYXlSYW5nZXMoZGF5VGFibGVNb2RlbCwgZGF0ZVByb2ZpbGUsIGRhdGVFbnYpIHtcclxuICAgICAgICBsZXQgcmFuZ2VzID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgZGF0ZSBvZiBkYXlUYWJsZU1vZGVsLmhlYWRlckRhdGVzKSB7XHJcbiAgICAgICAgICAgIHJhbmdlcy5wdXNoKHtcclxuICAgICAgICAgICAgICAgIHN0YXJ0OiBkYXRlRW52LmFkZChkYXRlLCBkYXRlUHJvZmlsZS5zbG90TWluVGltZSksXHJcbiAgICAgICAgICAgICAgICBlbmQ6IGRhdGVFbnYuYWRkKGRhdGUsIGRhdGVQcm9maWxlLnNsb3RNYXhUaW1lKSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByYW5nZXM7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gcG90ZW50aWFsIG5pY2UgdmFsdWVzIGZvciB0aGUgc2xvdC1kdXJhdGlvbiBhbmQgaW50ZXJ2YWwtZHVyYXRpb25cclxuICAgIC8vIGZyb20gbGFyZ2VzdCB0byBzbWFsbGVzdFxyXG4gICAgY29uc3QgU1RPQ0tfU1VCX0RVUkFUSU9OUyA9IFtcclxuICAgICAgICB7IGhvdXJzOiAxIH0sXHJcbiAgICAgICAgeyBtaW51dGVzOiAzMCB9LFxyXG4gICAgICAgIHsgbWludXRlczogMTUgfSxcclxuICAgICAgICB7IHNlY29uZHM6IDMwIH0sXHJcbiAgICAgICAgeyBzZWNvbmRzOiAxNSB9LFxyXG4gICAgXTtcclxuICAgIGZ1bmN0aW9uIGJ1aWxkU2xhdE1ldGFzKHNsb3RNaW5UaW1lLCBzbG90TWF4VGltZSwgZXhwbGljaXRMYWJlbEludGVydmFsLCBzbG90RHVyYXRpb24sIGRhdGVFbnYpIHtcclxuICAgICAgICBsZXQgZGF5U3RhcnQgPSBuZXcgRGF0ZSgwKTtcclxuICAgICAgICBsZXQgc2xhdFRpbWUgPSBzbG90TWluVGltZTtcclxuICAgICAgICBsZXQgc2xhdEl0ZXJhdG9yID0gY3JlYXRlRHVyYXRpb24oMCk7XHJcbiAgICAgICAgbGV0IGxhYmVsSW50ZXJ2YWwgPSBleHBsaWNpdExhYmVsSW50ZXJ2YWwgfHwgY29tcHV0ZUxhYmVsSW50ZXJ2YWwoc2xvdER1cmF0aW9uKTtcclxuICAgICAgICBsZXQgbWV0YXMgPSBbXTtcclxuICAgICAgICB3aGlsZSAoYXNSb3VnaE1zKHNsYXRUaW1lKSA8IGFzUm91Z2hNcyhzbG90TWF4VGltZSkpIHtcclxuICAgICAgICAgICAgbGV0IGRhdGUgPSBkYXRlRW52LmFkZChkYXlTdGFydCwgc2xhdFRpbWUpO1xyXG4gICAgICAgICAgICBsZXQgaXNMYWJlbGVkID0gd2hvbGVEaXZpZGVEdXJhdGlvbnMoc2xhdEl0ZXJhdG9yLCBsYWJlbEludGVydmFsKSAhPT0gbnVsbDtcclxuICAgICAgICAgICAgbWV0YXMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICBkYXRlLFxyXG4gICAgICAgICAgICAgICAgdGltZTogc2xhdFRpbWUsXHJcbiAgICAgICAgICAgICAgICBrZXk6IGRhdGUudG9JU09TdHJpbmcoKSxcclxuICAgICAgICAgICAgICAgIGlzb1RpbWVTdHI6IGZvcm1hdElzb1RpbWVTdHJpbmcoZGF0ZSksXHJcbiAgICAgICAgICAgICAgICBpc0xhYmVsZWQsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBzbGF0VGltZSA9IGFkZER1cmF0aW9ucyhzbGF0VGltZSwgc2xvdER1cmF0aW9uKTtcclxuICAgICAgICAgICAgc2xhdEl0ZXJhdG9yID0gYWRkRHVyYXRpb25zKHNsYXRJdGVyYXRvciwgc2xvdER1cmF0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG1ldGFzO1xyXG4gICAgfVxyXG4gICAgLy8gQ29tcHV0ZXMgYW4gYXV0b21hdGljIHZhbHVlIGZvciBzbG90TGFiZWxJbnRlcnZhbFxyXG4gICAgZnVuY3Rpb24gY29tcHV0ZUxhYmVsSW50ZXJ2YWwoc2xvdER1cmF0aW9uKSB7XHJcbiAgICAgICAgbGV0IGk7XHJcbiAgICAgICAgbGV0IGxhYmVsSW50ZXJ2YWw7XHJcbiAgICAgICAgbGV0IHNsb3RzUGVyTGFiZWw7XHJcbiAgICAgICAgLy8gZmluZCB0aGUgc21hbGxlc3Qgc3RvY2sgbGFiZWwgaW50ZXJ2YWwgdGhhdCByZXN1bHRzIGluIG1vcmUgdGhhbiBvbmUgc2xvdHMtcGVyLWxhYmVsXHJcbiAgICAgICAgZm9yIChpID0gU1RPQ0tfU1VCX0RVUkFUSU9OUy5sZW5ndGggLSAxOyBpID49IDA7IGkgLT0gMSkge1xyXG4gICAgICAgICAgICBsYWJlbEludGVydmFsID0gY3JlYXRlRHVyYXRpb24oU1RPQ0tfU1VCX0RVUkFUSU9OU1tpXSk7XHJcbiAgICAgICAgICAgIHNsb3RzUGVyTGFiZWwgPSB3aG9sZURpdmlkZUR1cmF0aW9ucyhsYWJlbEludGVydmFsLCBzbG90RHVyYXRpb24pO1xyXG4gICAgICAgICAgICBpZiAoc2xvdHNQZXJMYWJlbCAhPT0gbnVsbCAmJiBzbG90c1BlckxhYmVsID4gMSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxhYmVsSW50ZXJ2YWw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHNsb3REdXJhdGlvbjsgLy8gZmFsbCBiYWNrXHJcbiAgICB9XHJcblxyXG4gICAgY2xhc3MgRGF5VGltZUNvbHNWaWV3IGV4dGVuZHMgVGltZUNvbHNWaWV3IHtcclxuICAgICAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgdGhpcy5idWlsZFRpbWVDb2xzTW9kZWwgPSBtZW1vaXplKGJ1aWxkVGltZUNvbHNNb2RlbCk7XHJcbiAgICAgICAgICAgIHRoaXMuYnVpbGRTbGF0TWV0YXMgPSBtZW1vaXplKGJ1aWxkU2xhdE1ldGFzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVuZGVyKCkge1xyXG4gICAgICAgICAgICBsZXQgeyBvcHRpb25zLCBkYXRlRW52LCBkYXRlUHJvZmlsZUdlbmVyYXRvciB9ID0gdGhpcy5jb250ZXh0O1xyXG4gICAgICAgICAgICBsZXQgeyBwcm9wcyB9ID0gdGhpcztcclxuICAgICAgICAgICAgbGV0IHsgZGF0ZVByb2ZpbGUgfSA9IHByb3BzO1xyXG4gICAgICAgICAgICBsZXQgZGF5VGFibGVNb2RlbCA9IHRoaXMuYnVpbGRUaW1lQ29sc01vZGVsKGRhdGVQcm9maWxlLCBkYXRlUHJvZmlsZUdlbmVyYXRvcik7XHJcbiAgICAgICAgICAgIGxldCBzcGxpdFByb3BzID0gdGhpcy5hbGxEYXlTcGxpdHRlci5zcGxpdFByb3BzKHByb3BzKTtcclxuICAgICAgICAgICAgbGV0IHNsYXRNZXRhcyA9IHRoaXMuYnVpbGRTbGF0TWV0YXMoZGF0ZVByb2ZpbGUuc2xvdE1pblRpbWUsIGRhdGVQcm9maWxlLnNsb3RNYXhUaW1lLCBvcHRpb25zLnNsb3RMYWJlbEludGVydmFsLCBvcHRpb25zLnNsb3REdXJhdGlvbiwgZGF0ZUVudik7XHJcbiAgICAgICAgICAgIGxldCB7IGRheU1pbldpZHRoIH0gPSBvcHRpb25zO1xyXG4gICAgICAgICAgICBsZXQgaGFzQXR0YWNoZWRBeGlzID0gIWRheU1pbldpZHRoO1xyXG4gICAgICAgICAgICBsZXQgaGFzRGV0YWNoZWRBeGlzID0gZGF5TWluV2lkdGg7XHJcbiAgICAgICAgICAgIGxldCBoZWFkZXJDb250ZW50ID0gb3B0aW9ucy5kYXlIZWFkZXJzICYmICh5KERheUhlYWRlciwgeyBkYXRlczogZGF5VGFibGVNb2RlbC5oZWFkZXJEYXRlcywgZGF0ZVByb2ZpbGU6IGRhdGVQcm9maWxlLCBkYXRlc1JlcERpc3RpbmN0RGF5czogdHJ1ZSwgcmVuZGVySW50cm86IGhhc0F0dGFjaGVkQXhpcyA/IHRoaXMucmVuZGVySGVhZEF4aXMgOiBudWxsIH0pKTtcclxuICAgICAgICAgICAgbGV0IGFsbERheUNvbnRlbnQgPSAob3B0aW9ucy5hbGxEYXlTbG90ICE9PSBmYWxzZSkgJiYgKChjb250ZW50QXJnKSA9PiAoeShEYXlUYWJsZSwgT2JqZWN0LmFzc2lnbih7fSwgc3BsaXRQcm9wcy5hbGxEYXksIHsgZGF0ZVByb2ZpbGU6IGRhdGVQcm9maWxlLCBkYXlUYWJsZU1vZGVsOiBkYXlUYWJsZU1vZGVsLCBuZXh0RGF5VGhyZXNob2xkOiBvcHRpb25zLm5leHREYXlUaHJlc2hvbGQsIHRhYmxlTWluV2lkdGg6IGNvbnRlbnRBcmcudGFibGVNaW5XaWR0aCwgY29sR3JvdXBOb2RlOiBjb250ZW50QXJnLnRhYmxlQ29sR3JvdXBOb2RlLCByZW5kZXJSb3dJbnRybzogaGFzQXR0YWNoZWRBeGlzID8gdGhpcy5yZW5kZXJUYWJsZVJvd0F4aXMgOiBudWxsLCBzaG93V2Vla051bWJlcnM6IGZhbHNlLCBleHBhbmRSb3dzOiBmYWxzZSwgaGVhZGVyQWxpZ25FbFJlZjogdGhpcy5oZWFkZXJFbFJlZiwgY2xpZW50V2lkdGg6IGNvbnRlbnRBcmcuY2xpZW50V2lkdGgsIGNsaWVudEhlaWdodDogY29udGVudEFyZy5jbGllbnRIZWlnaHQsIGZvclByaW50OiBwcm9wcy5mb3JQcmludCB9LCB0aGlzLmdldEFsbERheU1heEV2ZW50UHJvcHMoKSkpKSk7XHJcbiAgICAgICAgICAgIGxldCB0aW1lR3JpZENvbnRlbnQgPSAoY29udGVudEFyZykgPT4gKHkoRGF5VGltZUNvbHMsIE9iamVjdC5hc3NpZ24oe30sIHNwbGl0UHJvcHMudGltZWQsIHsgZGF5VGFibGVNb2RlbDogZGF5VGFibGVNb2RlbCwgZGF0ZVByb2ZpbGU6IGRhdGVQcm9maWxlLCBheGlzOiBoYXNBdHRhY2hlZEF4aXMsIHNsb3REdXJhdGlvbjogb3B0aW9ucy5zbG90RHVyYXRpb24sIHNsYXRNZXRhczogc2xhdE1ldGFzLCBmb3JQcmludDogcHJvcHMuZm9yUHJpbnQsIHRhYmxlQ29sR3JvdXBOb2RlOiBjb250ZW50QXJnLnRhYmxlQ29sR3JvdXBOb2RlLCB0YWJsZU1pbldpZHRoOiBjb250ZW50QXJnLnRhYmxlTWluV2lkdGgsIGNsaWVudFdpZHRoOiBjb250ZW50QXJnLmNsaWVudFdpZHRoLCBjbGllbnRIZWlnaHQ6IGNvbnRlbnRBcmcuY2xpZW50SGVpZ2h0LCBvblNsYXRDb29yZHM6IHRoaXMuaGFuZGxlU2xhdENvb3JkcywgZXhwYW5kUm93czogY29udGVudEFyZy5leHBhbmRSb3dzLCBvblNjcm9sbFRvcFJlcXVlc3Q6IHRoaXMuaGFuZGxlU2Nyb2xsVG9wUmVxdWVzdCB9KSkpO1xyXG4gICAgICAgICAgICByZXR1cm4gaGFzRGV0YWNoZWRBeGlzXHJcbiAgICAgICAgICAgICAgICA/IHRoaXMucmVuZGVySFNjcm9sbExheW91dChoZWFkZXJDb250ZW50LCBhbGxEYXlDb250ZW50LCB0aW1lR3JpZENvbnRlbnQsIGRheVRhYmxlTW9kZWwuY29sQ250LCBkYXlNaW5XaWR0aCwgc2xhdE1ldGFzLCB0aGlzLnN0YXRlLnNsYXRDb29yZHMpXHJcbiAgICAgICAgICAgICAgICA6IHRoaXMucmVuZGVyU2ltcGxlTGF5b3V0KGhlYWRlckNvbnRlbnQsIGFsbERheUNvbnRlbnQsIHRpbWVHcmlkQ29udGVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYnVpbGRUaW1lQ29sc01vZGVsKGRhdGVQcm9maWxlLCBkYXRlUHJvZmlsZUdlbmVyYXRvcikge1xyXG4gICAgICAgIGxldCBkYXlTZXJpZXMgPSBuZXcgRGF5U2VyaWVzTW9kZWwoZGF0ZVByb2ZpbGUucmVuZGVyUmFuZ2UsIGRhdGVQcm9maWxlR2VuZXJhdG9yKTtcclxuICAgICAgICByZXR1cm4gbmV3IERheVRhYmxlTW9kZWwoZGF5U2VyaWVzLCBmYWxzZSk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgT1BUSU9OX1JFRklORVJTJDIgPSB7XHJcbiAgICAgICAgYWxsRGF5U2xvdDogQm9vbGVhbixcclxuICAgIH07XHJcblxyXG4gICAgdmFyIGluZGV4JDIgPSBjcmVhdGVQbHVnaW4oe1xyXG4gICAgICAgIG5hbWU6ICdAZnVsbGNhbGVuZGFyL3RpbWVncmlkJyxcclxuICAgICAgICBpbml0aWFsVmlldzogJ3RpbWVHcmlkV2VlaycsXHJcbiAgICAgICAgb3B0aW9uUmVmaW5lcnM6IE9QVElPTl9SRUZJTkVSUyQyLFxyXG4gICAgICAgIHZpZXdzOiB7XHJcbiAgICAgICAgICAgIHRpbWVHcmlkOiB7XHJcbiAgICAgICAgICAgICAgICBjb21wb25lbnQ6IERheVRpbWVDb2xzVmlldyxcclxuICAgICAgICAgICAgICAgIHVzZXNNaW5NYXhUaW1lOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgYWxsRGF5U2xvdDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIHNsb3REdXJhdGlvbjogJzAwOjMwOjAwJyxcclxuICAgICAgICAgICAgICAgIHNsb3RFdmVudE92ZXJsYXA6IHRydWUsIC8vIGEgYmFkIG5hbWUuIGNvbmZ1c2VkIHdpdGggb3ZlcmxhcC9jb25zdHJhaW50IHN5c3RlbVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB0aW1lR3JpZERheToge1xyXG4gICAgICAgICAgICAgICAgdHlwZTogJ3RpbWVHcmlkJyxcclxuICAgICAgICAgICAgICAgIGR1cmF0aW9uOiB7IGRheXM6IDEgfSxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgdGltZUdyaWRXZWVrOiB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiAndGltZUdyaWQnLFxyXG4gICAgICAgICAgICAgICAgZHVyYXRpb246IHsgd2Vla3M6IDEgfSxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9LFxyXG4gICAgfSk7XHJcblxyXG4gICAgdmFyIGNzc18yNDh6JDEgPSBcIjpyb290ey0tZmMtbGlzdC1ldmVudC1kb3Qtd2lkdGg6MTBweDstLWZjLWxpc3QtZXZlbnQtaG92ZXItYmctY29sb3I6I2Y1ZjVmNX0uZmMtdGhlbWUtc3RhbmRhcmQgLmZjLWxpc3R7Ym9yZGVyOjFweCBzb2xpZCB2YXIoLS1mYy1ib3JkZXItY29sb3IpfS5mYyAuZmMtbGlzdC1lbXB0eXthbGlnbi1pdGVtczpjZW50ZXI7YmFja2dyb3VuZC1jb2xvcjp2YXIoLS1mYy1uZXV0cmFsLWJnLWNvbG9yKTtkaXNwbGF5OmZsZXg7aGVpZ2h0OjEwMCU7anVzdGlmeS1jb250ZW50OmNlbnRlcn0uZmMgLmZjLWxpc3QtZW1wdHktY3VzaGlvbnttYXJnaW46NWVtIDB9LmZjIC5mYy1saXN0LXRhYmxle2JvcmRlci1zdHlsZTpoaWRkZW47d2lkdGg6MTAwJX0uZmMgLmZjLWxpc3QtdGFibGUgdHI+Kntib3JkZXItbGVmdDowO2JvcmRlci1yaWdodDowfS5mYyAuZmMtbGlzdC1zdGlja3kgLmZjLWxpc3QtZGF5Pip7YmFja2dyb3VuZDp2YXIoLS1mYy1wYWdlLWJnLWNvbG9yKTtwb3NpdGlvbjpzdGlja3k7dG9wOjB9LmZjIC5mYy1saXN0LXRhYmxlIHRoZWFke2xlZnQ6LTEwMDAwcHg7cG9zaXRpb246YWJzb2x1dGV9LmZjIC5mYy1saXN0LXRhYmxlIHRib2R5PnRyOmZpcnN0LWNoaWxkIHRoe2JvcmRlci10b3A6MH0uZmMgLmZjLWxpc3QtdGFibGUgdGh7cGFkZGluZzowfS5mYyAuZmMtbGlzdC1kYXktY3VzaGlvbiwuZmMgLmZjLWxpc3QtdGFibGUgdGR7cGFkZGluZzo4cHggMTRweH0uZmMgLmZjLWxpc3QtZGF5LWN1c2hpb246YWZ0ZXJ7Y2xlYXI6Ym90aDtjb250ZW50OlxcXCJcXFwiO2Rpc3BsYXk6dGFibGV9LmZjLXRoZW1lLXN0YW5kYXJkIC5mYy1saXN0LWRheS1jdXNoaW9ue2JhY2tncm91bmQtY29sb3I6dmFyKC0tZmMtbmV1dHJhbC1iZy1jb2xvcil9LmZjLWRpcmVjdGlvbi1sdHIgLmZjLWxpc3QtZGF5LXRleHQsLmZjLWRpcmVjdGlvbi1ydGwgLmZjLWxpc3QtZGF5LXNpZGUtdGV4dHtmbG9hdDpsZWZ0fS5mYy1kaXJlY3Rpb24tbHRyIC5mYy1saXN0LWRheS1zaWRlLXRleHQsLmZjLWRpcmVjdGlvbi1ydGwgLmZjLWxpc3QtZGF5LXRleHR7ZmxvYXQ6cmlnaHR9LmZjLWRpcmVjdGlvbi1sdHIgLmZjLWxpc3QtdGFibGUgLmZjLWxpc3QtZXZlbnQtZ3JhcGhpY3twYWRkaW5nLXJpZ2h0OjB9LmZjLWRpcmVjdGlvbi1ydGwgLmZjLWxpc3QtdGFibGUgLmZjLWxpc3QtZXZlbnQtZ3JhcGhpY3twYWRkaW5nLWxlZnQ6MH0uZmMgLmZjLWxpc3QtZXZlbnQuZmMtZXZlbnQtZm9yY2VkLXVybHtjdXJzb3I6cG9pbnRlcn0uZmMgLmZjLWxpc3QtZXZlbnQ6aG92ZXIgdGR7YmFja2dyb3VuZC1jb2xvcjp2YXIoLS1mYy1saXN0LWV2ZW50LWhvdmVyLWJnLWNvbG9yKX0uZmMgLmZjLWxpc3QtZXZlbnQtZ3JhcGhpYywuZmMgLmZjLWxpc3QtZXZlbnQtdGltZXt3aGl0ZS1zcGFjZTpub3dyYXA7d2lkdGg6MXB4fS5mYyAuZmMtbGlzdC1ldmVudC1kb3R7Ym9yZGVyOmNhbGModmFyKC0tZmMtbGlzdC1ldmVudC1kb3Qtd2lkdGgpLzIpIHNvbGlkIHZhcigtLWZjLWV2ZW50LWJvcmRlci1jb2xvcik7Ym9yZGVyLXJhZGl1czpjYWxjKHZhcigtLWZjLWxpc3QtZXZlbnQtZG90LXdpZHRoKS8yKTtib3gtc2l6aW5nOmNvbnRlbnQtYm94O2Rpc3BsYXk6aW5saW5lLWJsb2NrO2hlaWdodDowO3dpZHRoOjB9LmZjIC5mYy1saXN0LWV2ZW50LXRpdGxlIGF7Y29sb3I6aW5oZXJpdDt0ZXh0LWRlY29yYXRpb246bm9uZX0uZmMgLmZjLWxpc3QtZXZlbnQuZmMtZXZlbnQtZm9yY2VkLXVybDpob3ZlciBhe3RleHQtZGVjb3JhdGlvbjp1bmRlcmxpbmV9XCI7XHJcbiAgICBpbmplY3RTdHlsZXMoY3NzXzI0OHokMSk7XHJcblxyXG4gICAgY2xhc3MgTGlzdFZpZXdIZWFkZXJSb3cgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcclxuICAgICAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IHtcclxuICAgICAgICAgICAgICAgIHRleHRJZDogZ2V0VW5pcXVlRG9tSWQoKSxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVuZGVyKCkge1xyXG4gICAgICAgICAgICBsZXQgeyB0aGVtZSwgZGF0ZUVudiwgb3B0aW9ucywgdmlld0FwaSB9ID0gdGhpcy5jb250ZXh0O1xyXG4gICAgICAgICAgICBsZXQgeyBjZWxsSWQsIGRheURhdGUsIHRvZGF5UmFuZ2UgfSA9IHRoaXMucHJvcHM7XHJcbiAgICAgICAgICAgIGxldCB7IHRleHRJZCB9ID0gdGhpcy5zdGF0ZTtcclxuICAgICAgICAgICAgbGV0IGRheU1ldGEgPSBnZXREYXRlTWV0YShkYXlEYXRlLCB0b2RheVJhbmdlKTtcclxuICAgICAgICAgICAgLy8gd2lsbCBldmVyIGJlIGZhbHN5P1xyXG4gICAgICAgICAgICBsZXQgdGV4dCA9IG9wdGlvbnMubGlzdERheUZvcm1hdCA/IGRhdGVFbnYuZm9ybWF0KGRheURhdGUsIG9wdGlvbnMubGlzdERheUZvcm1hdCkgOiAnJztcclxuICAgICAgICAgICAgLy8gd2lsbCBldmVyIGJlIGZhbHN5PyBhbHNvLCBCQUQgTkFNRSBcImFsdFwiXHJcbiAgICAgICAgICAgIGxldCBzaWRlVGV4dCA9IG9wdGlvbnMubGlzdERheVNpZGVGb3JtYXQgPyBkYXRlRW52LmZvcm1hdChkYXlEYXRlLCBvcHRpb25zLmxpc3REYXlTaWRlRm9ybWF0KSA6ICcnO1xyXG4gICAgICAgICAgICBsZXQgcmVuZGVyUHJvcHMgPSBPYmplY3QuYXNzaWduKHsgZGF0ZTogZGF0ZUVudi50b0RhdGUoZGF5RGF0ZSksIHZpZXc6IHZpZXdBcGksIHRleHRJZCxcclxuICAgICAgICAgICAgICAgIHRleHQsXHJcbiAgICAgICAgICAgICAgICBzaWRlVGV4dCwgbmF2TGlua0F0dHJzOiBidWlsZE5hdkxpbmtBdHRycyh0aGlzLmNvbnRleHQsIGRheURhdGUpLCBzaWRlTmF2TGlua0F0dHJzOiBidWlsZE5hdkxpbmtBdHRycyh0aGlzLmNvbnRleHQsIGRheURhdGUsICdkYXknLCBmYWxzZSkgfSwgZGF5TWV0YSk7XHJcbiAgICAgICAgICAgIC8vIFRPRE86IG1ha2UgYSByZXVzYWJsZSBIT0MgZm9yIGRheUhlYWRlciAodXNlZCBpbiBkYXlncmlkL3RpbWVncmlkIHRvbylcclxuICAgICAgICAgICAgcmV0dXJuICh5KENvbnRlbnRDb250YWluZXIsIHsgZWxUYWc6IFwidHJcIiwgZWxDbGFzc2VzOiBbXHJcbiAgICAgICAgICAgICAgICAgICAgJ2ZjLWxpc3QtZGF5JyxcclxuICAgICAgICAgICAgICAgICAgICAuLi5nZXREYXlDbGFzc05hbWVzKGRheU1ldGEsIHRoZW1lKSxcclxuICAgICAgICAgICAgICAgIF0sIGVsQXR0cnM6IHtcclxuICAgICAgICAgICAgICAgICAgICAnZGF0YS1kYXRlJzogZm9ybWF0RGF5U3RyaW5nKGRheURhdGUpLFxyXG4gICAgICAgICAgICAgICAgfSwgcmVuZGVyUHJvcHM6IHJlbmRlclByb3BzLCBnZW5lcmF0b3JOYW1lOiBcImRheUhlYWRlckNvbnRlbnRcIiwgY3VzdG9tR2VuZXJhdG9yOiBvcHRpb25zLmRheUhlYWRlckNvbnRlbnQsIGRlZmF1bHRHZW5lcmF0b3I6IHJlbmRlcklubmVyQ29udGVudCwgY2xhc3NOYW1lR2VuZXJhdG9yOiBvcHRpb25zLmRheUhlYWRlckNsYXNzTmFtZXMsIGRpZE1vdW50OiBvcHRpb25zLmRheUhlYWRlckRpZE1vdW50LCB3aWxsVW5tb3VudDogb3B0aW9ucy5kYXlIZWFkZXJXaWxsVW5tb3VudCB9LCAoSW5uZXJDb250ZW50KSA9PiAoIC8vIFRPRE86IGZvcmNlLWhpZGUgdG9wIGJvcmRlciBiYXNlZCBvbiA6Zmlyc3QtY2hpbGRcclxuICAgICAgICAgICAgeShcInRoXCIsIHsgc2NvcGU6IFwiY29sZ3JvdXBcIiwgY29sU3BhbjogMywgaWQ6IGNlbGxJZCwgXCJhcmlhLWxhYmVsbGVkYnlcIjogdGV4dElkIH0sXHJcbiAgICAgICAgICAgICAgICB5KElubmVyQ29udGVudCwgeyBlbFRhZzogXCJkaXZcIiwgZWxDbGFzc2VzOiBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdmYy1saXN0LWRheS1jdXNoaW9uJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhlbWUuZ2V0Q2xhc3MoJ3RhYmxlQ2VsbFNoYWRlZCcpLFxyXG4gICAgICAgICAgICAgICAgICAgIF0gfSkpKSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHJlbmRlcklubmVyQ29udGVudChwcm9wcykge1xyXG4gICAgICAgIHJldHVybiAoeShfLCBudWxsLFxyXG4gICAgICAgICAgICBwcm9wcy50ZXh0ICYmICh5KFwiYVwiLCBPYmplY3QuYXNzaWduKHsgaWQ6IHByb3BzLnRleHRJZCwgY2xhc3NOYW1lOiBcImZjLWxpc3QtZGF5LXRleHRcIiB9LCBwcm9wcy5uYXZMaW5rQXR0cnMpLCBwcm9wcy50ZXh0KSksXHJcbiAgICAgICAgICAgIHByb3BzLnNpZGVUZXh0ICYmICggLyogbm90IGtleWJvYXJkIHRhYmJhYmxlICoveShcImFcIiwgT2JqZWN0LmFzc2lnbih7IFwiYXJpYS1oaWRkZW5cIjogdHJ1ZSwgY2xhc3NOYW1lOiBcImZjLWxpc3QtZGF5LXNpZGUtdGV4dFwiIH0sIHByb3BzLnNpZGVOYXZMaW5rQXR0cnMpLCBwcm9wcy5zaWRlVGV4dCkpKSk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgREVGQVVMVF9USU1FX0ZPUk1BVCA9IGNyZWF0ZUZvcm1hdHRlcih7XHJcbiAgICAgICAgaG91cjogJ251bWVyaWMnLFxyXG4gICAgICAgIG1pbnV0ZTogJzItZGlnaXQnLFxyXG4gICAgICAgIG1lcmlkaWVtOiAnc2hvcnQnLFxyXG4gICAgfSk7XHJcbiAgICBjbGFzcyBMaXN0Vmlld0V2ZW50Um93IGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XHJcbiAgICAgICAgcmVuZGVyKCkge1xyXG4gICAgICAgICAgICBsZXQgeyBwcm9wcywgY29udGV4dCB9ID0gdGhpcztcclxuICAgICAgICAgICAgbGV0IHsgb3B0aW9ucyB9ID0gY29udGV4dDtcclxuICAgICAgICAgICAgbGV0IHsgc2VnLCB0aW1lSGVhZGVySWQsIGV2ZW50SGVhZGVySWQsIGRhdGVIZWFkZXJJZCB9ID0gcHJvcHM7XHJcbiAgICAgICAgICAgIGxldCB0aW1lRm9ybWF0ID0gb3B0aW9ucy5ldmVudFRpbWVGb3JtYXQgfHwgREVGQVVMVF9USU1FX0ZPUk1BVDtcclxuICAgICAgICAgICAgcmV0dXJuICh5KEV2ZW50Q29udGFpbmVyLCBPYmplY3QuYXNzaWduKHt9LCBwcm9wcywgeyBlbFRhZzogXCJ0clwiLCBlbENsYXNzZXM6IFtcclxuICAgICAgICAgICAgICAgICAgICAnZmMtbGlzdC1ldmVudCcsXHJcbiAgICAgICAgICAgICAgICAgICAgc2VnLmV2ZW50UmFuZ2UuZGVmLnVybCAmJiAnZmMtZXZlbnQtZm9yY2VkLXVybCcsXHJcbiAgICAgICAgICAgICAgICBdLCBkZWZhdWx0R2VuZXJhdG9yOiAoKSA9PiByZW5kZXJFdmVudElubmVyQ29udGVudChzZWcsIGNvbnRleHQpIC8qIHdlaXJkICovLCBzZWc6IHNlZywgdGltZVRleHQ6IFwiXCIsIGRpc2FibGVEcmFnZ2luZzogdHJ1ZSwgZGlzYWJsZVJlc2l6aW5nOiB0cnVlIH0pLCAoSW5uZXJDb250ZW50LCBldmVudENvbnRlbnRBcmcpID0+ICh5KF8sIG51bGwsXHJcbiAgICAgICAgICAgICAgICBidWlsZFRpbWVDb250ZW50KHNlZywgdGltZUZvcm1hdCwgY29udGV4dCwgdGltZUhlYWRlcklkLCBkYXRlSGVhZGVySWQpLFxyXG4gICAgICAgICAgICAgICAgeShcInRkXCIsIHsgXCJhcmlhLWhpZGRlblwiOiB0cnVlLCBjbGFzc05hbWU6IFwiZmMtbGlzdC1ldmVudC1ncmFwaGljXCIgfSxcclxuICAgICAgICAgICAgICAgICAgICB5KFwic3BhblwiLCB7IGNsYXNzTmFtZTogXCJmYy1saXN0LWV2ZW50LWRvdFwiLCBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyQ29sb3I6IGV2ZW50Q29udGVudEFyZy5ib3JkZXJDb2xvciB8fCBldmVudENvbnRlbnRBcmcuYmFja2dyb3VuZENvbG9yLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IH0pKSxcclxuICAgICAgICAgICAgICAgIHkoSW5uZXJDb250ZW50LCB7IGVsVGFnOiBcInRkXCIsIGVsQ2xhc3NlczogWydmYy1saXN0LWV2ZW50LXRpdGxlJ10sIGVsQXR0cnM6IHsgaGVhZGVyczogYCR7ZXZlbnRIZWFkZXJJZH0gJHtkYXRlSGVhZGVySWR9YCB9IH0pKSkpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiByZW5kZXJFdmVudElubmVyQ29udGVudChzZWcsIGNvbnRleHQpIHtcclxuICAgICAgICBsZXQgaW50ZXJhY3RpdmVBdHRycyA9IGdldFNlZ0FuY2hvckF0dHJzKHNlZywgY29udGV4dCk7XHJcbiAgICAgICAgcmV0dXJuICh5KFwiYVwiLCBPYmplY3QuYXNzaWduKHt9LCBpbnRlcmFjdGl2ZUF0dHJzKSwgc2VnLmV2ZW50UmFuZ2UuZGVmLnRpdGxlKSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBidWlsZFRpbWVDb250ZW50KHNlZywgdGltZUZvcm1hdCwgY29udGV4dCwgdGltZUhlYWRlcklkLCBkYXRlSGVhZGVySWQpIHtcclxuICAgICAgICBsZXQgeyBvcHRpb25zIH0gPSBjb250ZXh0O1xyXG4gICAgICAgIGlmIChvcHRpb25zLmRpc3BsYXlFdmVudFRpbWUgIT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIGxldCBldmVudERlZiA9IHNlZy5ldmVudFJhbmdlLmRlZjtcclxuICAgICAgICAgICAgbGV0IGV2ZW50SW5zdGFuY2UgPSBzZWcuZXZlbnRSYW5nZS5pbnN0YW5jZTtcclxuICAgICAgICAgICAgbGV0IGRvQWxsRGF5ID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGxldCB0aW1lVGV4dDtcclxuICAgICAgICAgICAgaWYgKGV2ZW50RGVmLmFsbERheSkge1xyXG4gICAgICAgICAgICAgICAgZG9BbGxEYXkgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzTXVsdGlEYXlSYW5nZShzZWcuZXZlbnRSYW5nZS5yYW5nZSkpIHsgLy8gVE9ETzogdXNlICghaXNTdGFydCB8fCAhaXNFbmQpIGluc3RlYWQ/XHJcbiAgICAgICAgICAgICAgICBpZiAoc2VnLmlzU3RhcnQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aW1lVGV4dCA9IGJ1aWxkU2VnVGltZVRleHQoc2VnLCB0aW1lRm9ybWF0LCBjb250ZXh0LCBudWxsLCBudWxsLCBldmVudEluc3RhbmNlLnJhbmdlLnN0YXJ0LCBzZWcuZW5kKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNlZy5pc0VuZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRpbWVUZXh0ID0gYnVpbGRTZWdUaW1lVGV4dChzZWcsIHRpbWVGb3JtYXQsIGNvbnRleHQsIG51bGwsIG51bGwsIHNlZy5zdGFydCwgZXZlbnRJbnN0YW5jZS5yYW5nZS5lbmQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZG9BbGxEYXkgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGltZVRleHQgPSBidWlsZFNlZ1RpbWVUZXh0KHNlZywgdGltZUZvcm1hdCwgY29udGV4dCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGRvQWxsRGF5KSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgcmVuZGVyUHJvcHMgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogY29udGV4dC5vcHRpb25zLmFsbERheVRleHQsXHJcbiAgICAgICAgICAgICAgICAgICAgdmlldzogY29udGV4dC52aWV3QXBpLFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIHJldHVybiAoeShDb250ZW50Q29udGFpbmVyLCB7IGVsVGFnOiBcInRkXCIsIGVsQ2xhc3NlczogWydmYy1saXN0LWV2ZW50LXRpbWUnXSwgZWxBdHRyczoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBgJHt0aW1lSGVhZGVySWR9ICR7ZGF0ZUhlYWRlcklkfWAsXHJcbiAgICAgICAgICAgICAgICAgICAgfSwgcmVuZGVyUHJvcHM6IHJlbmRlclByb3BzLCBnZW5lcmF0b3JOYW1lOiBcImFsbERheUNvbnRlbnRcIiwgY3VzdG9tR2VuZXJhdG9yOiBvcHRpb25zLmFsbERheUNvbnRlbnQsIGRlZmF1bHRHZW5lcmF0b3I6IHJlbmRlckFsbERheUlubmVyLCBjbGFzc05hbWVHZW5lcmF0b3I6IG9wdGlvbnMuYWxsRGF5Q2xhc3NOYW1lcywgZGlkTW91bnQ6IG9wdGlvbnMuYWxsRGF5RGlkTW91bnQsIHdpbGxVbm1vdW50OiBvcHRpb25zLmFsbERheVdpbGxVbm1vdW50IH0pKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gKHkoXCJ0ZFwiLCB7IGNsYXNzTmFtZTogXCJmYy1saXN0LWV2ZW50LXRpbWVcIiB9LCB0aW1lVGV4dCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHJlbmRlckFsbERheUlubmVyKHJlbmRlclByb3BzKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlbmRlclByb3BzLnRleHQ7XHJcbiAgICB9XHJcblxyXG4gICAgLypcclxuICAgIFJlc3BvbnNpYmxlIGZvciB0aGUgc2Nyb2xsZXIsIGFuZCBmb3J3YXJkaW5nIGV2ZW50LXJlbGF0ZWQgYWN0aW9ucyBpbnRvIHRoZSBcImdyaWRcIi5cclxuICAgICovXHJcbiAgICBjbGFzcyBMaXN0VmlldyBleHRlbmRzIERhdGVDb21wb25lbnQge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgICAgICB0aGlzLmNvbXB1dGVEYXRlVmFycyA9IG1lbW9pemUoY29tcHV0ZURhdGVWYXJzKTtcclxuICAgICAgICAgICAgdGhpcy5ldmVudFN0b3JlVG9TZWdzID0gbWVtb2l6ZSh0aGlzLl9ldmVudFN0b3JlVG9TZWdzKTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IHtcclxuICAgICAgICAgICAgICAgIHRpbWVIZWFkZXJJZDogZ2V0VW5pcXVlRG9tSWQoKSxcclxuICAgICAgICAgICAgICAgIGV2ZW50SGVhZGVySWQ6IGdldFVuaXF1ZURvbUlkKCksXHJcbiAgICAgICAgICAgICAgICBkYXRlSGVhZGVySWRSb290OiBnZXRVbmlxdWVEb21JZCgpLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB0aGlzLnNldFJvb3RFbCA9IChyb290RWwpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChyb290RWwpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQucmVnaXN0ZXJJbnRlcmFjdGl2ZUNvbXBvbmVudCh0aGlzLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsOiByb290RWwsXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQudW5yZWdpc3RlckludGVyYWN0aXZlQ29tcG9uZW50KHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZW5kZXIoKSB7XHJcbiAgICAgICAgICAgIGxldCB7IHByb3BzLCBjb250ZXh0IH0gPSB0aGlzO1xyXG4gICAgICAgICAgICBsZXQgeyBkYXlEYXRlcywgZGF5UmFuZ2VzIH0gPSB0aGlzLmNvbXB1dGVEYXRlVmFycyhwcm9wcy5kYXRlUHJvZmlsZSk7XHJcbiAgICAgICAgICAgIGxldCBldmVudFNlZ3MgPSB0aGlzLmV2ZW50U3RvcmVUb1NlZ3MocHJvcHMuZXZlbnRTdG9yZSwgcHJvcHMuZXZlbnRVaUJhc2VzLCBkYXlSYW5nZXMpO1xyXG4gICAgICAgICAgICByZXR1cm4gKHkoVmlld0NvbnRhaW5lciwgeyBlbFJlZjogdGhpcy5zZXRSb290RWwsIGVsQ2xhc3NlczogW1xyXG4gICAgICAgICAgICAgICAgICAgICdmYy1saXN0JyxcclxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnRoZW1lLmdldENsYXNzKCd0YWJsZScpLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQub3B0aW9ucy5zdGlja3lIZWFkZXJEYXRlcyAhPT0gZmFsc2UgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnZmMtbGlzdC1zdGlja3knIDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgJycsXHJcbiAgICAgICAgICAgICAgICBdLCB2aWV3U3BlYzogY29udGV4dC52aWV3U3BlYyB9LFxyXG4gICAgICAgICAgICAgICAgeShTY3JvbGxlciwgeyBsaXF1aWQ6ICFwcm9wcy5pc0hlaWdodEF1dG8sIG92ZXJmbG93WDogcHJvcHMuaXNIZWlnaHRBdXRvID8gJ3Zpc2libGUnIDogJ2hpZGRlbicsIG92ZXJmbG93WTogcHJvcHMuaXNIZWlnaHRBdXRvID8gJ3Zpc2libGUnIDogJ2F1dG8nIH0sIGV2ZW50U2Vncy5sZW5ndGggPiAwID9cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlclNlZ0xpc3QoZXZlbnRTZWdzLCBkYXlEYXRlcykgOlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyRW1wdHlNZXNzYWdlKCkpKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlbmRlckVtcHR5TWVzc2FnZSgpIHtcclxuICAgICAgICAgICAgbGV0IHsgb3B0aW9ucywgdmlld0FwaSB9ID0gdGhpcy5jb250ZXh0O1xyXG4gICAgICAgICAgICBsZXQgcmVuZGVyUHJvcHMgPSB7XHJcbiAgICAgICAgICAgICAgICB0ZXh0OiBvcHRpb25zLm5vRXZlbnRzVGV4dCxcclxuICAgICAgICAgICAgICAgIHZpZXc6IHZpZXdBcGksXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJldHVybiAoeShDb250ZW50Q29udGFpbmVyLCB7IGVsVGFnOiBcImRpdlwiLCBlbENsYXNzZXM6IFsnZmMtbGlzdC1lbXB0eSddLCByZW5kZXJQcm9wczogcmVuZGVyUHJvcHMsIGdlbmVyYXRvck5hbWU6IFwibm9FdmVudHNDb250ZW50XCIsIGN1c3RvbUdlbmVyYXRvcjogb3B0aW9ucy5ub0V2ZW50c0NvbnRlbnQsIGRlZmF1bHRHZW5lcmF0b3I6IHJlbmRlck5vRXZlbnRzSW5uZXIsIGNsYXNzTmFtZUdlbmVyYXRvcjogb3B0aW9ucy5ub0V2ZW50c0NsYXNzTmFtZXMsIGRpZE1vdW50OiBvcHRpb25zLm5vRXZlbnRzRGlkTW91bnQsIHdpbGxVbm1vdW50OiBvcHRpb25zLm5vRXZlbnRzV2lsbFVubW91bnQgfSwgKElubmVyQ29udGVudCkgPT4gKHkoSW5uZXJDb250ZW50LCB7IGVsVGFnOiBcImRpdlwiLCBlbENsYXNzZXM6IFsnZmMtbGlzdC1lbXB0eS1jdXNoaW9uJ10gfSkpKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlbmRlclNlZ0xpc3QoYWxsU2VncywgZGF5RGF0ZXMpIHtcclxuICAgICAgICAgICAgbGV0IHsgdGhlbWUsIG9wdGlvbnMgfSA9IHRoaXMuY29udGV4dDtcclxuICAgICAgICAgICAgbGV0IHsgdGltZUhlYWRlcklkLCBldmVudEhlYWRlcklkLCBkYXRlSGVhZGVySWRSb290IH0gPSB0aGlzLnN0YXRlO1xyXG4gICAgICAgICAgICBsZXQgc2Vnc0J5RGF5ID0gZ3JvdXBTZWdzQnlEYXkoYWxsU2Vncyk7IC8vIHNwYXJzZSBhcnJheVxyXG4gICAgICAgICAgICByZXR1cm4gKHkoTm93VGltZXIsIHsgdW5pdDogXCJkYXlcIiB9LCAobm93RGF0ZSwgdG9kYXlSYW5nZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgbGV0IGlubmVyTm9kZXMgPSBbXTtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGRheUluZGV4ID0gMDsgZGF5SW5kZXggPCBzZWdzQnlEYXkubGVuZ3RoOyBkYXlJbmRleCArPSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGRheVNlZ3MgPSBzZWdzQnlEYXlbZGF5SW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXlTZWdzKSB7IC8vIHNwYXJzZSBhcnJheSwgc28gbWlnaHQgYmUgdW5kZWZpbmVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBkYXlTdHIgPSBmb3JtYXREYXlTdHJpbmcoZGF5RGF0ZXNbZGF5SW5kZXhdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGRhdGVIZWFkZXJJZCA9IGRhdGVIZWFkZXJJZFJvb3QgKyAnLScgKyBkYXlTdHI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFwcGVuZCBhIGRheSBoZWFkZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5uZXJOb2Rlcy5wdXNoKHkoTGlzdFZpZXdIZWFkZXJSb3csIHsga2V5OiBkYXlTdHIsIGNlbGxJZDogZGF0ZUhlYWRlcklkLCBkYXlEYXRlOiBkYXlEYXRlc1tkYXlJbmRleF0sIHRvZGF5UmFuZ2U6IHRvZGF5UmFuZ2UgfSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXlTZWdzID0gc29ydEV2ZW50U2VncyhkYXlTZWdzLCBvcHRpb25zLmV2ZW50T3JkZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBzZWcgb2YgZGF5U2Vncykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5uZXJOb2Rlcy5wdXNoKHkoTGlzdFZpZXdFdmVudFJvdywgT2JqZWN0LmFzc2lnbih7IGtleTogZGF5U3RyICsgJzonICsgc2VnLmV2ZW50UmFuZ2UuaW5zdGFuY2UuaW5zdGFuY2VJZCAvKiBhcmUgbXVsdGlwbGUgc2VncyBmb3IgYW4gaW5zdGFuY2VJZCAqLywgc2VnOiBzZWcsIGlzRHJhZ2dpbmc6IGZhbHNlLCBpc1Jlc2l6aW5nOiBmYWxzZSwgaXNEYXRlU2VsZWN0aW5nOiBmYWxzZSwgaXNTZWxlY3RlZDogZmFsc2UsIHRpbWVIZWFkZXJJZDogdGltZUhlYWRlcklkLCBldmVudEhlYWRlcklkOiBldmVudEhlYWRlcklkLCBkYXRlSGVhZGVySWQ6IGRhdGVIZWFkZXJJZCB9LCBnZXRTZWdNZXRhKHNlZywgdG9kYXlSYW5nZSwgbm93RGF0ZSkpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKHkoXCJ0YWJsZVwiLCB7IGNsYXNzTmFtZTogJ2ZjLWxpc3QtdGFibGUgJyArIHRoZW1lLmdldENsYXNzKCd0YWJsZScpIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgeShcInRoZWFkXCIsIG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHkoXCJ0clwiLCBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeShcInRoXCIsIHsgc2NvcGU6IFwiY29sXCIsIGlkOiB0aW1lSGVhZGVySWQgfSwgb3B0aW9ucy50aW1lSGludCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5KFwidGhcIiwgeyBzY29wZTogXCJjb2xcIiwgXCJhcmlhLWhpZGRlblwiOiB0cnVlIH0pLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeShcInRoXCIsIHsgc2NvcGU6IFwiY29sXCIsIGlkOiBldmVudEhlYWRlcklkIH0sIG9wdGlvbnMuZXZlbnRIaW50KSkpLFxyXG4gICAgICAgICAgICAgICAgICAgIHkoXCJ0Ym9keVwiLCBudWxsLCBpbm5lck5vZGVzKSkpO1xyXG4gICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9ldmVudFN0b3JlVG9TZWdzKGV2ZW50U3RvcmUsIGV2ZW50VWlCYXNlcywgZGF5UmFuZ2VzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmV2ZW50UmFuZ2VzVG9TZWdzKHNsaWNlRXZlbnRTdG9yZShldmVudFN0b3JlLCBldmVudFVpQmFzZXMsIHRoaXMucHJvcHMuZGF0ZVByb2ZpbGUuYWN0aXZlUmFuZ2UsIHRoaXMuY29udGV4dC5vcHRpb25zLm5leHREYXlUaHJlc2hvbGQpLmZnLCBkYXlSYW5nZXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBldmVudFJhbmdlc1RvU2VncyhldmVudFJhbmdlcywgZGF5UmFuZ2VzKSB7XHJcbiAgICAgICAgICAgIGxldCBzZWdzID0gW107XHJcbiAgICAgICAgICAgIGZvciAobGV0IGV2ZW50UmFuZ2Ugb2YgZXZlbnRSYW5nZXMpIHtcclxuICAgICAgICAgICAgICAgIHNlZ3MucHVzaCguLi50aGlzLmV2ZW50UmFuZ2VUb1NlZ3MoZXZlbnRSYW5nZSwgZGF5UmFuZ2VzKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHNlZ3M7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGV2ZW50UmFuZ2VUb1NlZ3MoZXZlbnRSYW5nZSwgZGF5UmFuZ2VzKSB7XHJcbiAgICAgICAgICAgIGxldCB7IGRhdGVFbnYgfSA9IHRoaXMuY29udGV4dDtcclxuICAgICAgICAgICAgbGV0IHsgbmV4dERheVRocmVzaG9sZCB9ID0gdGhpcy5jb250ZXh0Lm9wdGlvbnM7XHJcbiAgICAgICAgICAgIGxldCByYW5nZSA9IGV2ZW50UmFuZ2UucmFuZ2U7XHJcbiAgICAgICAgICAgIGxldCBhbGxEYXkgPSBldmVudFJhbmdlLmRlZi5hbGxEYXk7XHJcbiAgICAgICAgICAgIGxldCBkYXlJbmRleDtcclxuICAgICAgICAgICAgbGV0IHNlZ1JhbmdlO1xyXG4gICAgICAgICAgICBsZXQgc2VnO1xyXG4gICAgICAgICAgICBsZXQgc2VncyA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKGRheUluZGV4ID0gMDsgZGF5SW5kZXggPCBkYXlSYW5nZXMubGVuZ3RoOyBkYXlJbmRleCArPSAxKSB7XHJcbiAgICAgICAgICAgICAgICBzZWdSYW5nZSA9IGludGVyc2VjdFJhbmdlcyhyYW5nZSwgZGF5UmFuZ2VzW2RheUluZGV4XSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2VnUmFuZ2UpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZWcgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudDogdGhpcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRSYW5nZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHNlZ1JhbmdlLnN0YXJ0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IHNlZ1JhbmdlLmVuZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXNTdGFydDogZXZlbnRSYW5nZS5pc1N0YXJ0ICYmIHNlZ1JhbmdlLnN0YXJ0LnZhbHVlT2YoKSA9PT0gcmFuZ2Uuc3RhcnQudmFsdWVPZigpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0VuZDogZXZlbnRSYW5nZS5pc0VuZCAmJiBzZWdSYW5nZS5lbmQudmFsdWVPZigpID09PSByYW5nZS5lbmQudmFsdWVPZigpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXlJbmRleCxcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIHNlZ3MucHVzaChzZWcpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGRldGVjdCB3aGVuIHJhbmdlIHdvbid0IGdvIGZ1bGx5IGludG8gdGhlIG5leHQgZGF5LFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGFuZCBtdXRhdGUgdGhlIGxhdGVzdCBzZWcgdG8gdGhlIGJlIHRoZSBlbmQuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzZWcuaXNFbmQgJiYgIWFsbERheSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXlJbmRleCArIDEgPCBkYXlSYW5nZXMubGVuZ3RoICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlLmVuZCA8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRlRW52LmFkZChkYXlSYW5nZXNbZGF5SW5kZXggKyAxXS5zdGFydCwgbmV4dERheVRocmVzaG9sZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VnLmVuZCA9IHJhbmdlLmVuZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VnLmlzRW5kID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBzZWdzO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHJlbmRlck5vRXZlbnRzSW5uZXIocmVuZGVyUHJvcHMpIHtcclxuICAgICAgICByZXR1cm4gcmVuZGVyUHJvcHMudGV4dDtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGNvbXB1dGVEYXRlVmFycyhkYXRlUHJvZmlsZSkge1xyXG4gICAgICAgIGxldCBkYXlTdGFydCA9IHN0YXJ0T2ZEYXkoZGF0ZVByb2ZpbGUucmVuZGVyUmFuZ2Uuc3RhcnQpO1xyXG4gICAgICAgIGxldCB2aWV3RW5kID0gZGF0ZVByb2ZpbGUucmVuZGVyUmFuZ2UuZW5kO1xyXG4gICAgICAgIGxldCBkYXlEYXRlcyA9IFtdO1xyXG4gICAgICAgIGxldCBkYXlSYW5nZXMgPSBbXTtcclxuICAgICAgICB3aGlsZSAoZGF5U3RhcnQgPCB2aWV3RW5kKSB7XHJcbiAgICAgICAgICAgIGRheURhdGVzLnB1c2goZGF5U3RhcnQpO1xyXG4gICAgICAgICAgICBkYXlSYW5nZXMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICBzdGFydDogZGF5U3RhcnQsXHJcbiAgICAgICAgICAgICAgICBlbmQ6IGFkZERheXMoZGF5U3RhcnQsIDEpLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgZGF5U3RhcnQgPSBhZGREYXlzKGRheVN0YXJ0LCAxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHsgZGF5RGF0ZXMsIGRheVJhbmdlcyB9O1xyXG4gICAgfVxyXG4gICAgLy8gUmV0dXJucyBhIHNwYXJzZSBhcnJheSBvZiBhcnJheXMsIHNlZ3MgZ3JvdXBlZCBieSB0aGVpciBkYXlJbmRleFxyXG4gICAgZnVuY3Rpb24gZ3JvdXBTZWdzQnlEYXkoc2Vncykge1xyXG4gICAgICAgIGxldCBzZWdzQnlEYXkgPSBbXTsgLy8gc3BhcnNlIGFycmF5XHJcbiAgICAgICAgbGV0IGk7XHJcbiAgICAgICAgbGV0IHNlZztcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2Vncy5sZW5ndGg7IGkgKz0gMSkge1xyXG4gICAgICAgICAgICBzZWcgPSBzZWdzW2ldO1xyXG4gICAgICAgICAgICAoc2Vnc0J5RGF5W3NlZy5kYXlJbmRleF0gfHwgKHNlZ3NCeURheVtzZWcuZGF5SW5kZXhdID0gW10pKVxyXG4gICAgICAgICAgICAgICAgLnB1c2goc2VnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHNlZ3NCeURheTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBPUFRJT05fUkVGSU5FUlMkMSA9IHtcclxuICAgICAgICBsaXN0RGF5Rm9ybWF0OiBjcmVhdGVGYWxzYWJsZUZvcm1hdHRlcixcclxuICAgICAgICBsaXN0RGF5U2lkZUZvcm1hdDogY3JlYXRlRmFsc2FibGVGb3JtYXR0ZXIsXHJcbiAgICAgICAgbm9FdmVudHNDbGFzc05hbWVzOiBpZGVudGl0eSxcclxuICAgICAgICBub0V2ZW50c0NvbnRlbnQ6IGlkZW50aXR5LFxyXG4gICAgICAgIG5vRXZlbnRzRGlkTW91bnQ6IGlkZW50aXR5LFxyXG4gICAgICAgIG5vRXZlbnRzV2lsbFVubW91bnQ6IGlkZW50aXR5LFxyXG4gICAgICAgIC8vIG5vRXZlbnRzVGV4dCBpcyBkZWZpbmVkIGluIGJhc2Ugb3B0aW9uc1xyXG4gICAgfTtcclxuICAgIGZ1bmN0aW9uIGNyZWF0ZUZhbHNhYmxlRm9ybWF0dGVyKGlucHV0KSB7XHJcbiAgICAgICAgcmV0dXJuIGlucHV0ID09PSBmYWxzZSA/IG51bGwgOiBjcmVhdGVGb3JtYXR0ZXIoaW5wdXQpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBpbmRleCQxID0gY3JlYXRlUGx1Z2luKHtcclxuICAgICAgICBuYW1lOiAnQGZ1bGxjYWxlbmRhci9saXN0JyxcclxuICAgICAgICBvcHRpb25SZWZpbmVyczogT1BUSU9OX1JFRklORVJTJDEsXHJcbiAgICAgICAgdmlld3M6IHtcclxuICAgICAgICAgICAgbGlzdDoge1xyXG4gICAgICAgICAgICAgICAgY29tcG9uZW50OiBMaXN0VmlldyxcclxuICAgICAgICAgICAgICAgIGJ1dHRvblRleHRLZXk6ICdsaXN0JyxcclxuICAgICAgICAgICAgICAgIGxpc3REYXlGb3JtYXQ6IHsgbW9udGg6ICdsb25nJywgZGF5OiAnbnVtZXJpYycsIHllYXI6ICdudW1lcmljJyB9LCAvLyBsaWtlIFwiSmFudWFyeSAxLCAyMDE2XCJcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgbGlzdERheToge1xyXG4gICAgICAgICAgICAgICAgdHlwZTogJ2xpc3QnLFxyXG4gICAgICAgICAgICAgICAgZHVyYXRpb246IHsgZGF5czogMSB9LFxyXG4gICAgICAgICAgICAgICAgbGlzdERheUZvcm1hdDogeyB3ZWVrZGF5OiAnbG9uZycgfSwgLy8gZGF5LW9mLXdlZWsgaXMgYWxsIHdlIG5lZWQuIGZ1bGwgZGF0ZSBpcyBwcm9iYWJseSBpbiBoZWFkZXJUb29sYmFyXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGxpc3RXZWVrOiB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiAnbGlzdCcsXHJcbiAgICAgICAgICAgICAgICBkdXJhdGlvbjogeyB3ZWVrczogMSB9LFxyXG4gICAgICAgICAgICAgICAgbGlzdERheUZvcm1hdDogeyB3ZWVrZGF5OiAnbG9uZycgfSxcclxuICAgICAgICAgICAgICAgIGxpc3REYXlTaWRlRm9ybWF0OiB7IG1vbnRoOiAnbG9uZycsIGRheTogJ251bWVyaWMnLCB5ZWFyOiAnbnVtZXJpYycgfSxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgbGlzdE1vbnRoOiB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiAnbGlzdCcsXHJcbiAgICAgICAgICAgICAgICBkdXJhdGlvbjogeyBtb250aDogMSB9LFxyXG4gICAgICAgICAgICAgICAgbGlzdERheVNpZGVGb3JtYXQ6IHsgd2Vla2RheTogJ2xvbmcnIH0sIC8vIGRheS1vZi13ZWVrIGlzIG5pY2UtdG8taGF2ZVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBsaXN0WWVhcjoge1xyXG4gICAgICAgICAgICAgICAgdHlwZTogJ2xpc3QnLFxyXG4gICAgICAgICAgICAgICAgZHVyYXRpb246IHsgeWVhcjogMSB9LFxyXG4gICAgICAgICAgICAgICAgbGlzdERheVNpZGVGb3JtYXQ6IHsgd2Vla2RheTogJ2xvbmcnIH0sIC8vIGRheS1vZi13ZWVrIGlzIG5pY2UtdG8taGF2ZVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH0sXHJcbiAgICB9KTtcclxuXHJcbiAgICBjbGFzcyBTaW5nbGVNb250aCBleHRlbmRzIERhdGVDb21wb25lbnQge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgICAgICB0aGlzLmJ1aWxkRGF5VGFibGVNb2RlbCA9IG1lbW9pemUoYnVpbGREYXlUYWJsZU1vZGVsKTtcclxuICAgICAgICAgICAgdGhpcy5zbGljZXIgPSBuZXcgRGF5VGFibGVTbGljZXIoKTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IHtcclxuICAgICAgICAgICAgICAgIGxhYmVsSWQ6IGdldFVuaXF1ZURvbUlkKCksXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlbmRlcigpIHtcclxuICAgICAgICAgICAgY29uc3QgeyBwcm9wcywgc3RhdGUsIGNvbnRleHQgfSA9IHRoaXM7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgZGF0ZVByb2ZpbGUsIGZvclByaW50IH0gPSBwcm9wcztcclxuICAgICAgICAgICAgY29uc3QgeyBvcHRpb25zIH0gPSBjb250ZXh0O1xyXG4gICAgICAgICAgICBjb25zdCBkYXlUYWJsZU1vZGVsID0gdGhpcy5idWlsZERheVRhYmxlTW9kZWwoZGF0ZVByb2ZpbGUsIGNvbnRleHQuZGF0ZVByb2ZpbGVHZW5lcmF0b3IpO1xyXG4gICAgICAgICAgICBjb25zdCBzbGljZWRQcm9wcyA9IHRoaXMuc2xpY2VyLnNsaWNlUHJvcHMocHJvcHMsIGRhdGVQcm9maWxlLCBvcHRpb25zLm5leHREYXlUaHJlc2hvbGQsIGNvbnRleHQsIGRheVRhYmxlTW9kZWwpO1xyXG4gICAgICAgICAgICAvLyBlbnN1cmUgc2luZ2xlLW1vbnRoIGhhcyBhc3BlY3QgcmF0aW9cclxuICAgICAgICAgICAgY29uc3QgdGFibGVIZWlnaHQgPSBwcm9wcy50YWJsZVdpZHRoICE9IG51bGwgPyBwcm9wcy50YWJsZVdpZHRoIC8gb3B0aW9ucy5hc3BlY3RSYXRpbyA6IG51bGw7XHJcbiAgICAgICAgICAgIGNvbnN0IHJvd0NudCA9IGRheVRhYmxlTW9kZWwuY2VsbHMubGVuZ3RoO1xyXG4gICAgICAgICAgICBjb25zdCByb3dIZWlnaHQgPSB0YWJsZUhlaWdodCAhPSBudWxsID8gdGFibGVIZWlnaHQgLyByb3dDbnQgOiBudWxsO1xyXG4gICAgICAgICAgICByZXR1cm4gKHkoXCJkaXZcIiwgeyByZWY6IHByb3BzLmVsUmVmLCBcImRhdGEtZGF0ZVwiOiBwcm9wcy5pc29EYXRlU3RyLCBjbGFzc05hbWU6IFwiZmMtbXVsdGltb250aC1tb250aFwiLCBzdHlsZTogeyB3aWR0aDogcHJvcHMud2lkdGggfSwgcm9sZTogXCJncmlkXCIsIFwiYXJpYS1sYWJlbGxlZGJ5XCI6IHN0YXRlLmxhYmVsSWQgfSxcclxuICAgICAgICAgICAgICAgIHkoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtbXVsdGltb250aC1oZWFkZXJcIiwgc3R5bGU6IHsgbWFyZ2luQm90dG9tOiByb3dIZWlnaHQgfSwgcm9sZTogXCJwcmVzZW50YXRpb25cIiB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHkoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtbXVsdGltb250aC10aXRsZVwiLCBpZDogc3RhdGUubGFiZWxJZCB9LCBjb250ZXh0LmRhdGVFbnYuZm9ybWF0KHByb3BzLmRhdGVQcm9maWxlLmN1cnJlbnRSYW5nZS5zdGFydCwgcHJvcHMudGl0bGVGb3JtYXQpKSxcclxuICAgICAgICAgICAgICAgICAgICB5KFwidGFibGVcIiwgeyBjbGFzc05hbWU6IFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdmYy1tdWx0aW1vbnRoLWhlYWRlci10YWJsZScsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnRoZW1lLmdldENsYXNzKCd0YWJsZScpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBdLmpvaW4oJyAnKSwgcm9sZTogXCJwcmVzZW50YXRpb25cIiB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB5KFwidGhlYWRcIiwgeyByb2xlOiBcInJvd2dyb3VwXCIgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkoRGF5SGVhZGVyLCB7IGRhdGVQcm9maWxlOiBwcm9wcy5kYXRlUHJvZmlsZSwgZGF0ZXM6IGRheVRhYmxlTW9kZWwuaGVhZGVyRGF0ZXMsIGRhdGVzUmVwRGlzdGluY3REYXlzOiBmYWxzZSB9KSkpKSxcclxuICAgICAgICAgICAgICAgIHkoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ2ZjLW11bHRpbW9udGgtZGF5Z3JpZCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdmYy1kYXlncmlkJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ2ZjLWRheWdyaWQtYm9keScsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICFmb3JQcmludCAmJiAnZmMtZGF5Z3JpZC1ib2R5LWJhbGFuY2VkJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yUHJpbnQgJiYgJ2ZjLWRheWdyaWQtYm9keS11bmJhbGFuY2VkJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yUHJpbnQgJiYgJ2ZjLWRheWdyaWQtYm9keS1uYXR1cmFsJyxcclxuICAgICAgICAgICAgICAgICAgICBdLmpvaW4oJyAnKSwgc3R5bGU6IHsgbWFyZ2luVG9wOiAtcm93SGVpZ2h0IH0gfSxcclxuICAgICAgICAgICAgICAgICAgICB5KFwidGFibGVcIiwgeyBjbGFzc05hbWU6IFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdmYy1tdWx0aW1vbnRoLWRheWdyaWQtdGFibGUnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC50aGVtZS5nZXRDbGFzcygndGFibGUnKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgXS5qb2luKCcgJyksIHN0eWxlOiB7IGhlaWdodDogZm9yUHJpbnQgPyAnJyA6IHRhYmxlSGVpZ2h0IH0sIHJvbGU6IFwicHJlc2VudGF0aW9uXCIgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgeShcInRib2R5XCIsIHsgcm9sZTogXCJyb3dncm91cFwiIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5KFRhYmxlUm93cywgT2JqZWN0LmFzc2lnbih7fSwgc2xpY2VkUHJvcHMsIHsgZGF0ZVByb2ZpbGU6IGRhdGVQcm9maWxlLCBjZWxsczogZGF5VGFibGVNb2RlbC5jZWxscywgZXZlbnRTZWxlY3Rpb246IHByb3BzLmV2ZW50U2VsZWN0aW9uLCBkYXlNYXhFdmVudHM6ICFmb3JQcmludCwgZGF5TWF4RXZlbnRSb3dzOiAhZm9yUHJpbnQsIHNob3dXZWVrTnVtYmVyczogb3B0aW9ucy53ZWVrTnVtYmVycywgY2xpZW50V2lkdGg6IHByb3BzLmNsaWVudFdpZHRoLCBjbGllbnRIZWlnaHQ6IHByb3BzLmNsaWVudEhlaWdodCwgZm9yUHJpbnQ6IGZvclByaW50IH0pKSkpKSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBjbGFzcyBNdWx0aU1vbnRoVmlldyBleHRlbmRzIERhdGVDb21wb25lbnQge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgICAgICB0aGlzLnNwbGl0RGF0ZVByb2ZpbGVCeU1vbnRoID0gbWVtb2l6ZShzcGxpdERhdGVQcm9maWxlQnlNb250aCk7XHJcbiAgICAgICAgICAgIHRoaXMuYnVpbGRNb250aEZvcm1hdCA9IG1lbW9pemUoYnVpbGRNb250aEZvcm1hdCk7XHJcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsRWxSZWYgPSBkKCk7XHJcbiAgICAgICAgICAgIHRoaXMuZmlyc3RNb250aEVsUmVmID0gZCgpO1xyXG4gICAgICAgICAgICB0aGlzLm5lZWRzU2Nyb2xsUmVzZXQgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5oYW5kbGVTaXppbmcgPSAoaXNGb3JjZWQpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChpc0ZvcmNlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlU2l6ZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZW5kZXIoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgY29udGV4dCwgcHJvcHMsIHN0YXRlIH0gPSB0aGlzO1xyXG4gICAgICAgICAgICBjb25zdCB7IG9wdGlvbnMgfSA9IGNvbnRleHQ7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgY2xpZW50V2lkdGgsIGNsaWVudEhlaWdodCB9ID0gc3RhdGU7XHJcbiAgICAgICAgICAgIGNvbnN0IG1vbnRoSFBhZGRpbmcgPSBzdGF0ZS5tb250aEhQYWRkaW5nIHx8IDA7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbENvdW50ID0gTWF0aC5taW4oY2xpZW50V2lkdGggIT0gbnVsbCA/XHJcbiAgICAgICAgICAgICAgICBNYXRoLmZsb29yKGNsaWVudFdpZHRoIC8gKG9wdGlvbnMubXVsdGlNb250aE1pbldpZHRoICsgbW9udGhIUGFkZGluZykpIDpcclxuICAgICAgICAgICAgICAgIDEsIG9wdGlvbnMubXVsdGlNb250aE1heENvbHVtbnMpIHx8IDE7XHJcbiAgICAgICAgICAgIGNvbnN0IG1vbnRoV2lkdGhQY3QgPSAoMTAwIC8gY29sQ291bnQpICsgJyUnO1xyXG4gICAgICAgICAgICBjb25zdCBtb250aFRhYmxlV2lkdGggPSBjbGllbnRXaWR0aCA9PSBudWxsID8gbnVsbCA6XHJcbiAgICAgICAgICAgICAgICAoY2xpZW50V2lkdGggLyBjb2xDb3VudCkgLSBtb250aEhQYWRkaW5nO1xyXG4gICAgICAgICAgICBjb25zdCBpc0xlZ2l0U2luZ2xlQ29sID0gY2xpZW50V2lkdGggIT0gbnVsbCAmJiBjb2xDb3VudCA9PT0gMTtcclxuICAgICAgICAgICAgY29uc3QgbW9udGhEYXRlUHJvZmlsZXMgPSB0aGlzLnNwbGl0RGF0ZVByb2ZpbGVCeU1vbnRoKGNvbnRleHQuZGF0ZVByb2ZpbGVHZW5lcmF0b3IsIHByb3BzLmRhdGVQcm9maWxlLCBjb250ZXh0LmRhdGVFbnYsIGlzTGVnaXRTaW5nbGVDb2wgPyBmYWxzZSA6IG9wdGlvbnMuZml4ZWRXZWVrQ291bnQsIG9wdGlvbnMuc2hvd05vbkN1cnJlbnREYXRlcyk7XHJcbiAgICAgICAgICAgIGNvbnN0IG1vbnRoVGl0bGVGb3JtYXQgPSB0aGlzLmJ1aWxkTW9udGhGb3JtYXQob3B0aW9ucy5tdWx0aU1vbnRoVGl0bGVGb3JtYXQsIG1vbnRoRGF0ZVByb2ZpbGVzKTtcclxuICAgICAgICAgICAgY29uc3Qgcm9vdENsYXNzTmFtZXMgPSBbXHJcbiAgICAgICAgICAgICAgICAnZmMtbXVsdGltb250aCcsXHJcbiAgICAgICAgICAgICAgICBpc0xlZ2l0U2luZ2xlQ29sID9cclxuICAgICAgICAgICAgICAgICAgICAnZmMtbXVsdGltb250aC1zaW5nbGVjb2wnIDpcclxuICAgICAgICAgICAgICAgICAgICAnZmMtbXVsdGltb250aC1tdWx0aWNvbCcsXHJcbiAgICAgICAgICAgICAgICAobW9udGhUYWJsZVdpZHRoICE9IG51bGwgJiYgbW9udGhUYWJsZVdpZHRoIDwgNDAwKSA/XHJcbiAgICAgICAgICAgICAgICAgICAgJ2ZjLW11bHRpbW9udGgtY29tcGFjdCcgOlxyXG4gICAgICAgICAgICAgICAgICAgICcnLFxyXG4gICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICByZXR1cm4gKHkoVmlld0NvbnRhaW5lciwgeyBlbFJlZjogdGhpcy5zY3JvbGxFbFJlZiwgZWxDbGFzc2VzOiByb290Q2xhc3NOYW1lcywgdmlld1NwZWM6IGNvbnRleHQudmlld1NwZWMgfSwgbW9udGhEYXRlUHJvZmlsZXMubWFwKChtb250aERhdGVQcm9maWxlLCBpKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBtb250aFN0ciA9IGZvcm1hdElzb01vbnRoU3RyKG1vbnRoRGF0ZVByb2ZpbGUuY3VycmVudFJhbmdlLnN0YXJ0KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiAoeShTaW5nbGVNb250aCwgT2JqZWN0LmFzc2lnbih7fSwgcHJvcHMsIHsga2V5OiBtb250aFN0ciwgaXNvRGF0ZVN0cjogbW9udGhTdHIsIGVsUmVmOiBpID09PSAwID8gdGhpcy5maXJzdE1vbnRoRWxSZWYgOiB1bmRlZmluZWQsIHRpdGxlRm9ybWF0OiBtb250aFRpdGxlRm9ybWF0LCBkYXRlUHJvZmlsZTogbW9udGhEYXRlUHJvZmlsZSwgd2lkdGg6IG1vbnRoV2lkdGhQY3QsIHRhYmxlV2lkdGg6IG1vbnRoVGFibGVXaWR0aCwgY2xpZW50V2lkdGg6IGNsaWVudFdpZHRoLCBjbGllbnRIZWlnaHQ6IGNsaWVudEhlaWdodCB9KSkpO1xyXG4gICAgICAgICAgICB9KSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb21wb25lbnREaWRNb3VudCgpIHtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVTaXplKCk7XHJcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5hZGRSZXNpemVIYW5kbGVyKHRoaXMuaGFuZGxlU2l6aW5nKTtcclxuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0U2Nyb2xsUmVzZXQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcykge1xyXG4gICAgICAgICAgICBpZiAoIWlzUHJvcHNFcXVhbChwcmV2UHJvcHMsIHRoaXMucHJvcHMpKSB7IC8vIGFuIGV4dGVybmFsIGNoYW5nZT9cclxuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlU2l6aW5nKGZhbHNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocHJldlByb3BzLmRhdGVQcm9maWxlICE9PSB0aGlzLnByb3BzLmRhdGVQcm9maWxlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlcXVlc3RTY3JvbGxSZXNldCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5mbHVzaFNjcm9sbFJlc2V0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5yZW1vdmVSZXNpemVIYW5kbGVyKHRoaXMuaGFuZGxlU2l6aW5nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdXBkYXRlU2l6ZSgpIHtcclxuICAgICAgICAgICAgY29uc3Qgc2Nyb2xsRWwgPSB0aGlzLnNjcm9sbEVsUmVmLmN1cnJlbnQ7XHJcbiAgICAgICAgICAgIGNvbnN0IGZpcnN0TW9udGhFbCA9IHRoaXMuZmlyc3RNb250aEVsUmVmLmN1cnJlbnQ7XHJcbiAgICAgICAgICAgIGlmIChzY3JvbGxFbCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgY2xpZW50V2lkdGg6IHNjcm9sbEVsLmNsaWVudFdpZHRoLFxyXG4gICAgICAgICAgICAgICAgICAgIGNsaWVudEhlaWdodDogc2Nyb2xsRWwuY2xpZW50SGVpZ2h0LFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGZpcnN0TW9udGhFbCAmJiBzY3JvbGxFbCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUubW9udGhIUGFkZGluZyA9PSBudWxsKSB7IC8vIGFsd2F5cyByZW1lbWJlciBpbml0aWFsIG5vbi16ZXJvIHZhbHVlXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vbnRoSFBhZGRpbmc6IHNjcm9sbEVsLmNsaWVudFdpZHRoIC0gLy8gZ28gd2l0aGluIHBhZGRpbmdcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0TW9udGhFbC5maXJzdENoaWxkLm9mZnNldFdpZHRoLFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlcXVlc3RTY3JvbGxSZXNldCgpIHtcclxuICAgICAgICAgICAgdGhpcy5uZWVkc1Njcm9sbFJlc2V0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5mbHVzaFNjcm9sbFJlc2V0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZsdXNoU2Nyb2xsUmVzZXQoKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLm5lZWRzU2Nyb2xsUmVzZXQgJiZcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUubW9udGhIUGFkZGluZyAhPSBudWxsIC8vIGluZGljYXRlcyBzaXppbmcgYWxyZWFkeSBoYXBwZW5lZFxyXG4gICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHsgY3VycmVudERhdGUgfSA9IHRoaXMucHJvcHMuZGF0ZVByb2ZpbGU7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzY3JvbGxFbCA9IHRoaXMuc2Nyb2xsRWxSZWYuY3VycmVudDtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG1vbnRoRWwgPSBzY3JvbGxFbC5xdWVyeVNlbGVjdG9yKGBbZGF0YS1kYXRlPVwiJHtmb3JtYXRJc29Nb250aFN0cihjdXJyZW50RGF0ZSl9XCJdYCk7XHJcbiAgICAgICAgICAgICAgICBzY3JvbGxFbC5zY3JvbGxUb3AgPSBtb250aEVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCAtXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maXJzdE1vbnRoRWxSZWYuY3VycmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3A7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm5lZWRzU2Nyb2xsUmVzZXQgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyB3b3JrYXJvdW5kIGZvciB3aGVuIHF1ZXVlZCBzZXRTdGF0ZSByZW5kZXIgKHcvIGNsaWVudFdpZHRoKSBnZXRzIGNhbmNlbGxlZCBiZWNhdXNlXHJcbiAgICAgICAgLy8gc3Vic2VxdWVudCB1cGRhdGUgYW5kIHNob3VsZENvbXBvbmVudFVwZGF0ZSBzYXlzIG5vdCB0byByZW5kZXIgOihcclxuICAgICAgICBzaG91bGRDb21wb25lbnRVcGRhdGUoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIGRhdGUgcHJvZmlsZVxyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgY29uc3Qgb25lTW9udGhEdXJhdGlvbiA9IGNyZWF0ZUR1cmF0aW9uKDEsICdtb250aCcpO1xyXG4gICAgZnVuY3Rpb24gc3BsaXREYXRlUHJvZmlsZUJ5TW9udGgoZGF0ZVByb2ZpbGVHZW5lcmF0b3IsIGRhdGVQcm9maWxlLCBkYXRlRW52LCBmaXhlZFdlZWtDb3VudCwgc2hvd05vbkN1cnJlbnREYXRlcykge1xyXG4gICAgICAgIGNvbnN0IHsgc3RhcnQsIGVuZCB9ID0gZGF0ZVByb2ZpbGUuY3VycmVudFJhbmdlO1xyXG4gICAgICAgIGxldCBtb250aFN0YXJ0ID0gc3RhcnQ7XHJcbiAgICAgICAgY29uc3QgbW9udGhEYXRlUHJvZmlsZXMgPSBbXTtcclxuICAgICAgICB3aGlsZSAobW9udGhTdGFydC52YWx1ZU9mKCkgPCBlbmQudmFsdWVPZigpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1vbnRoRW5kID0gZGF0ZUVudi5hZGQobW9udGhTdGFydCwgb25lTW9udGhEdXJhdGlvbik7XHJcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRSYW5nZSA9IHtcclxuICAgICAgICAgICAgICAgIC8vIHl1Y2tcclxuICAgICAgICAgICAgICAgIHN0YXJ0OiBkYXRlUHJvZmlsZUdlbmVyYXRvci5za2lwSGlkZGVuRGF5cyhtb250aFN0YXJ0KSxcclxuICAgICAgICAgICAgICAgIGVuZDogZGF0ZVByb2ZpbGVHZW5lcmF0b3Iuc2tpcEhpZGRlbkRheXMobW9udGhFbmQsIC0xLCB0cnVlKSxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgbGV0IHJlbmRlclJhbmdlID0gYnVpbGREYXlUYWJsZVJlbmRlclJhbmdlKHtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRSYW5nZSxcclxuICAgICAgICAgICAgICAgIHNuYXBUb1dlZWs6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBmaXhlZFdlZWtDb3VudCxcclxuICAgICAgICAgICAgICAgIGRhdGVFbnYsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZW5kZXJSYW5nZSA9IHtcclxuICAgICAgICAgICAgICAgIC8vIHl1Y2tcclxuICAgICAgICAgICAgICAgIHN0YXJ0OiBkYXRlUHJvZmlsZUdlbmVyYXRvci5za2lwSGlkZGVuRGF5cyhyZW5kZXJSYW5nZS5zdGFydCksXHJcbiAgICAgICAgICAgICAgICBlbmQ6IGRhdGVQcm9maWxlR2VuZXJhdG9yLnNraXBIaWRkZW5EYXlzKHJlbmRlclJhbmdlLmVuZCwgLTEsIHRydWUpLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBjb25zdCBhY3RpdmVSYW5nZSA9IGRhdGVQcm9maWxlLmFjdGl2ZVJhbmdlID9cclxuICAgICAgICAgICAgICAgIGludGVyc2VjdFJhbmdlcyhkYXRlUHJvZmlsZS5hY3RpdmVSYW5nZSwgc2hvd05vbkN1cnJlbnREYXRlcyA/IHJlbmRlclJhbmdlIDogY3VycmVudFJhbmdlKSA6XHJcbiAgICAgICAgICAgICAgICBudWxsO1xyXG4gICAgICAgICAgICBtb250aERhdGVQcm9maWxlcy5wdXNoKHtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnREYXRlOiBkYXRlUHJvZmlsZS5jdXJyZW50RGF0ZSxcclxuICAgICAgICAgICAgICAgIGlzVmFsaWQ6IGRhdGVQcm9maWxlLmlzVmFsaWQsXHJcbiAgICAgICAgICAgICAgICB2YWxpZFJhbmdlOiBkYXRlUHJvZmlsZS52YWxpZFJhbmdlLFxyXG4gICAgICAgICAgICAgICAgcmVuZGVyUmFuZ2UsXHJcbiAgICAgICAgICAgICAgICBhY3RpdmVSYW5nZSxcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRSYW5nZSxcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRSYW5nZVVuaXQ6ICdtb250aCcsXHJcbiAgICAgICAgICAgICAgICBpc1JhbmdlQWxsRGF5OiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgZGF0ZUluY3JlbWVudDogZGF0ZVByb2ZpbGUuZGF0ZUluY3JlbWVudCxcclxuICAgICAgICAgICAgICAgIHNsb3RNaW5UaW1lOiBkYXRlUHJvZmlsZS5zbG90TWF4VGltZSxcclxuICAgICAgICAgICAgICAgIHNsb3RNYXhUaW1lOiBkYXRlUHJvZmlsZS5zbG90TWluVGltZSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIG1vbnRoU3RhcnQgPSBtb250aEVuZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG1vbnRoRGF0ZVByb2ZpbGVzO1xyXG4gICAgfVxyXG4gICAgLy8gZGF0ZSBmb3JtYXR0aW5nXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICBjb25zdCBZRUFSX01PTlRIX0ZPUk1BVFRFUiA9IGNyZWF0ZUZvcm1hdHRlcih7IHllYXI6ICdudW1lcmljJywgbW9udGg6ICdsb25nJyB9KTtcclxuICAgIGNvbnN0IFlFQVJfRk9STUFUVEVSID0gY3JlYXRlRm9ybWF0dGVyKHsgbW9udGg6ICdsb25nJyB9KTtcclxuICAgIGZ1bmN0aW9uIGJ1aWxkTW9udGhGb3JtYXQoZm9ybWF0T3ZlcnJpZGUsIG1vbnRoRGF0ZVByb2ZpbGVzKSB7XHJcbiAgICAgICAgcmV0dXJuIGZvcm1hdE92ZXJyaWRlIHx8XHJcbiAgICAgICAgICAgICgobW9udGhEYXRlUHJvZmlsZXNbMF0uY3VycmVudFJhbmdlLnN0YXJ0LmdldFVUQ0Z1bGxZZWFyKCkgIT09XHJcbiAgICAgICAgICAgICAgICBtb250aERhdGVQcm9maWxlc1ttb250aERhdGVQcm9maWxlcy5sZW5ndGggLSAxXS5jdXJyZW50UmFuZ2Uuc3RhcnQuZ2V0VVRDRnVsbFllYXIoKSlcclxuICAgICAgICAgICAgICAgID8gWUVBUl9NT05USF9GT1JNQVRURVJcclxuICAgICAgICAgICAgICAgIDogWUVBUl9GT1JNQVRURVIpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IE9QVElPTl9SRUZJTkVSUyA9IHtcclxuICAgICAgICBtdWx0aU1vbnRoVGl0bGVGb3JtYXQ6IGNyZWF0ZUZvcm1hdHRlcixcclxuICAgICAgICBtdWx0aU1vbnRoTWF4Q29sdW1uczogTnVtYmVyLFxyXG4gICAgICAgIG11bHRpTW9udGhNaW5XaWR0aDogTnVtYmVyLFxyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgY3NzXzI0OHogPSBcIi5mYyAuZmMtbXVsdGltb250aHtib3JkZXI6MXB4IHNvbGlkIHZhcigtLWZjLWJvcmRlci1jb2xvcik7ZGlzcGxheTpmbGV4O2ZsZXgtd3JhcDp3cmFwO292ZXJmbG93LXg6aGlkZGVuO292ZXJmbG93LXk6YXV0b30uZmMgLmZjLW11bHRpbW9udGgtdGl0bGV7Zm9udC1zaXplOjEuMmVtO2ZvbnQtd2VpZ2h0OjcwMDtwYWRkaW5nOjFlbSAwO3RleHQtYWxpZ246Y2VudGVyfS5mYyAuZmMtbXVsdGltb250aC1kYXlncmlke2JhY2tncm91bmQ6dmFyKC0tZmMtcGFnZS1iZy1jb2xvcil9LmZjIC5mYy1tdWx0aW1vbnRoLWRheWdyaWQtdGFibGUsLmZjIC5mYy1tdWx0aW1vbnRoLWhlYWRlci10YWJsZXt0YWJsZS1sYXlvdXQ6Zml4ZWQ7d2lkdGg6MTAwJX0uZmMgLmZjLW11bHRpbW9udGgtZGF5Z3JpZC10YWJsZXtib3JkZXItdG9wLXN0eWxlOmhpZGRlbiFpbXBvcnRhbnR9LmZjIC5mYy1tdWx0aW1vbnRoLXNpbmdsZWNvbCAuZmMtbXVsdGltb250aHtwb3NpdGlvbjpyZWxhdGl2ZX0uZmMgLmZjLW11bHRpbW9udGgtc2luZ2xlY29sIC5mYy1tdWx0aW1vbnRoLWhlYWRlcntiYWNrZ3JvdW5kOnZhcigtLWZjLXBhZ2UtYmctY29sb3IpO3Bvc2l0aW9uOnJlbGF0aXZlO3RvcDowO3otaW5kZXg6Mn0uZmMgLmZjLW11bHRpbW9udGgtc2luZ2xlY29sIC5mYy1tdWx0aW1vbnRoLWRheWdyaWR7cG9zaXRpb246cmVsYXRpdmU7ei1pbmRleDoxfS5mYyAuZmMtbXVsdGltb250aC1zaW5nbGVjb2wgLmZjLW11bHRpbW9udGgtZGF5Z3JpZC10YWJsZSwuZmMgLmZjLW11bHRpbW9udGgtc2luZ2xlY29sIC5mYy1tdWx0aW1vbnRoLWhlYWRlci10YWJsZXtib3JkZXItbGVmdC1zdHlsZTpoaWRkZW47Ym9yZGVyLXJpZ2h0LXN0eWxlOmhpZGRlbn0uZmMgLmZjLW11bHRpbW9udGgtc2luZ2xlY29sIC5mYy1tdWx0aW1vbnRoLW1vbnRoOmxhc3QtY2hpbGQgLmZjLW11bHRpbW9udGgtZGF5Z3JpZC10YWJsZXtib3JkZXItYm90dG9tLXN0eWxlOmhpZGRlbn0uZmMgLmZjLW11bHRpbW9udGgtbXVsdGljb2x7bGluZS1oZWlnaHQ6MX0uZmMgLmZjLW11bHRpbW9udGgtbXVsdGljb2wgLmZjLW11bHRpbW9udGgtbW9udGh7cGFkZGluZzowIDEuMmVtIDEuMmVtfS5mYyAuZmMtbXVsdGltb250aC1tdWx0aWNvbCAuZmMtZGF5Z3JpZC1tb3JlLWxpbmt7Ym9yZGVyOjFweCBzb2xpZCB2YXIoLS1mYy1ldmVudC1ib3JkZXItY29sb3IpO2Rpc3BsYXk6YmxvY2s7ZmxvYXQ6bm9uZTtwYWRkaW5nOjFweH0uZmMgLmZjLW11bHRpbW9udGgtY29tcGFjdHtsaW5lLWhlaWdodDoxfS5mYyAuZmMtbXVsdGltb250aC1jb21wYWN0IC5mYy1tdWx0aW1vbnRoLWRheWdyaWQtdGFibGUsLmZjIC5mYy1tdWx0aW1vbnRoLWNvbXBhY3QgLmZjLW11bHRpbW9udGgtaGVhZGVyLXRhYmxle2ZvbnQtc2l6ZTouOWVtfS5mYy1tZWRpYS1zY3JlZW4gLmZjLW11bHRpbW9udGgtc2luZ2xlY29sIC5mYy1tdWx0aW1vbnRoLWhlYWRlcntwb3NpdGlvbjpzdGlja3l9LmZjLW1lZGlhLXByaW50IC5mYy1tdWx0aW1vbnRoe292ZXJmbG93OnZpc2libGV9XCI7XHJcbiAgICBpbmplY3RTdHlsZXMoY3NzXzI0OHopO1xyXG5cclxuICAgIHZhciBpbmRleCA9IGNyZWF0ZVBsdWdpbih7XHJcbiAgICAgICAgbmFtZTogJ0BmdWxsY2FsZW5kYXIvbXVsdGltb250aCcsXHJcbiAgICAgICAgaW5pdGlhbFZpZXc6ICdtdWx0aU1vbnRoWWVhcicsXHJcbiAgICAgICAgb3B0aW9uUmVmaW5lcnM6IE9QVElPTl9SRUZJTkVSUyxcclxuICAgICAgICB2aWV3czoge1xyXG4gICAgICAgICAgICBtdWx0aU1vbnRoOiB7XHJcbiAgICAgICAgICAgICAgICBjb21wb25lbnQ6IE11bHRpTW9udGhWaWV3LFxyXG4gICAgICAgICAgICAgICAgZGF0ZVByb2ZpbGVHZW5lcmF0b3JDbGFzczogVGFibGVEYXRlUHJvZmlsZUdlbmVyYXRvcixcclxuICAgICAgICAgICAgICAgIG11bHRpTW9udGhNaW5XaWR0aDogMzUwLFxyXG4gICAgICAgICAgICAgICAgbXVsdGlNb250aE1heENvbHVtbnM6IDMsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIG11bHRpTW9udGhZZWFyOiB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiAnbXVsdGlNb250aCcsXHJcbiAgICAgICAgICAgICAgICBkdXJhdGlvbjogeyB5ZWFyczogMSB9LFxyXG4gICAgICAgICAgICAgICAgZml4ZWRXZWVrQ291bnQ6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBzaG93Tm9uQ3VycmVudERhdGVzOiBmYWxzZSxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9LFxyXG4gICAgfSk7XHJcblxyXG4gICAgZ2xvYmFsUGx1Z2lucy5wdXNoKGluZGV4JDQsIGluZGV4JDMsIGluZGV4JDIsIGluZGV4JDEsIGluZGV4KTtcclxuXHJcbiAgICBleHBvcnRzLkNhbGVuZGFyID0gQ2FsZW5kYXI7XHJcbiAgICBleHBvcnRzLkRyYWdnYWJsZSA9IEV4dGVybmFsRHJhZ2dhYmxlO1xyXG4gICAgZXhwb3J0cy5JbnRlcm5hbCA9IGludGVybmFsO1xyXG4gICAgZXhwb3J0cy5Kc29uUmVxdWVzdEVycm9yID0gSnNvblJlcXVlc3RFcnJvcjtcclxuICAgIGV4cG9ydHMuUHJlYWN0ID0gcHJlYWN0O1xyXG4gICAgZXhwb3J0cy5UaGlyZFBhcnR5RHJhZ2dhYmxlID0gVGhpcmRQYXJ0eURyYWdnYWJsZTtcclxuICAgIGV4cG9ydHMuY3JlYXRlUGx1Z2luID0gY3JlYXRlUGx1Z2luO1xyXG4gICAgZXhwb3J0cy5mb3JtYXREYXRlID0gZm9ybWF0RGF0ZTtcclxuICAgIGV4cG9ydHMuZm9ybWF0UmFuZ2UgPSBmb3JtYXRSYW5nZTtcclxuICAgIGV4cG9ydHMuZ2xvYmFsTG9jYWxlcyA9IGdsb2JhbExvY2FsZXM7XHJcbiAgICBleHBvcnRzLmdsb2JhbFBsdWdpbnMgPSBnbG9iYWxQbHVnaW5zO1xyXG4gICAgZXhwb3J0cy5zbGljZUV2ZW50cyA9IHNsaWNlRXZlbnRzO1xyXG4gICAgZXhwb3J0cy52ZXJzaW9uID0gdmVyc2lvbjtcclxuXHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5cclxuICAgIHJldHVybiBleHBvcnRzO1xyXG5cclxufSkoe30pO1xyXG4iXSwibmFtZXMiOlsiRnVsbENhbGVuZGFyIiwiZXhwb3J0cyIsIm4iLCJsJDEiLCJ1JDEiLCJpJDEiLCJ0IiwiciQxIiwibyIsImYkMSIsImUkMSIsImMkMSIsInMiLCJhJDEiLCJoIiwibCIsInUiLCJ2JDEiLCJwYXJlbnROb2RlIiwicmVtb3ZlQ2hpbGQiLCJ5IiwiaSIsInIiLCJmIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwiY2hpbGRyZW4iLCJjYWxsIiwiZGVmYXVsdFByb3BzIiwicCIsInR5cGUiLCJwcm9wcyIsImtleSIsInJlZiIsIl9fayIsIl9fIiwiX19iIiwiX19lIiwiX19kIiwiX19jIiwiX19oIiwiX192Iiwidm5vZGUiLCJkIiwiY3VycmVudCIsIl8iLCJrJDEiLCJnJDIiLCJiJDEiLCJzZXRQcm9wZXJ0eSIsInRlc3QiLCJzdHlsZSIsImNzc1RleHQiLCJyZXBsYWNlIiwidG9Mb3dlckNhc2UiLCJzbGljZSIsImFkZEV2ZW50TGlzdGVuZXIiLCJ3JDIiLCJtJDEiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiaW5kZXhPZiIsInJlbW92ZUF0dHJpYnV0ZSIsInNldEF0dHJpYnV0ZSIsImV2ZW50IiwieCQxIiwiY29udGV4dCIsIkEiLCJQJDEiLCJiYXNlIiwiQyQxIiwic2V0VGltZW91dCIsIlQkMSIsInB1c2giLCIkJDEiLCJfX3IiLCJkZWJvdW5jZVJlbmRlcmluZyIsImUiLCJzb3J0Iiwic2hpZnQiLCJfX1AiLCJNIiwiX19uIiwib3duZXJTVkdFbGVtZW50IiwiTiIsIkgkMSIsImEiLCJ2IiwiayIsImIiLCJnIiwibSIsInciLCJBcnJheSIsImlzQXJyYXkiLCJJJDEiLCJ6JDEiLCJMJDEiLCJuZXh0U2libGluZyIsInEiLCJTIiwiaiQyIiwic29tZSIsImFwcGVuZENoaWxkIiwiaW5zZXJ0QmVmb3JlIiwiYyIsIlAiLCJDIiwiVCIsIiQiLCJjb250ZXh0VHlwZSIsInZhbHVlIiwiX19FIiwicHJvdG90eXBlIiwicmVuZGVyIiwiQiQxIiwic3ViIiwic3RhdGUiLCJfc2IiLCJfX3MiLCJnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMiLCJjb21wb25lbnRXaWxsTW91bnQiLCJjb21wb25lbnREaWRNb3VudCIsImNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMiLCJzaG91bGRDb21wb25lbnRVcGRhdGUiLCJmb3JFYWNoIiwiY29tcG9uZW50V2lsbFVwZGF0ZSIsImNvbXBvbmVudERpZFVwZGF0ZSIsImdldENoaWxkQ29udGV4dCIsImdldFNuYXBzaG90QmVmb3JlVXBkYXRlIiwiTyIsImRpZmZlZCIsImxvY2FsTmFtZSIsIm5vZGVUeXBlIiwiZG9jdW1lbnQiLCJjcmVhdGVUZXh0Tm9kZSIsImNyZWF0ZUVsZW1lbnROUyIsImNyZWF0ZUVsZW1lbnQiLCJpcyIsImRhdGEiLCJjaGlsZE5vZGVzIiwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwiLCJhdHRyaWJ1dGVzIiwibmFtZSIsIl9faHRtbCIsImlubmVySFRNTCIsImNoZWNrZWQiLCJ1bm1vdW50IiwiY29tcG9uZW50V2lsbFVubW91bnQiLCJEJDEiLCJmaXJzdENoaWxkIiwiRSIsIkYkMSIsIkckMSIsIkNvbnN1bWVyIiwiUHJvdmlkZXIiLCJzcGxpY2UiLCJnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IiLCJzZXRTdGF0ZSIsImNvbXBvbmVudERpZENhdGNoIiwiZm9yY2VVcGRhdGUiLCJQcm9taXNlIiwidGhlbiIsImJpbmQiLCJyZXNvbHZlIiwiX19IIiwidyQxIiwiX19OIiwiX19WIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiaiQxIiwiZmlsdGVyIiwiZyQxIiwiY2xlYXJUaW1lb3V0IiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJpc1B1cmVSZWFjdENvbXBvbmVudCIsIngiLCJfX2YiLCJJIiwiTCIsIm1hcCIsIlUiLCJEIiwiX191IiwiRiIsIl9fYSIsIlYiLCJfX1IiLCJfX08iLCJwb3AiLCJmYWxsYmFjayIsIlciLCJkZWxldGUiLCJyZXZlYWxPcmRlciIsInNpemUiLCJqIiwiY29udGFpbmVySW5mbyIsImdldCIsIk1hcCIsInJldmVyc2UiLCJzZXQiLCJ6IiwiU3ltYm9sIiwiZm9yIiwiQiIsIkgiLCJaIiwiaXNSZWFjdENvbXBvbmVudCIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJHIiwiSiIsIksiLCJjYW5jZWxCdWJibGUiLCJRIiwiZGVmYXVsdFByZXZlbnRlZCIsInBlcnNpc3QiLCJpc1Byb3BhZ2F0aW9uU3RvcHBlZCIsImlzRGVmYXVsdFByZXZlbnRlZCIsIm5hdGl2ZUV2ZW50Iiwibm4iLCJjbGFzcyIsInRuIiwibXVsdGlwbGUiLCJzZWxlY3RlZCIsImRlZmF1bHRWYWx1ZSIsImNsYXNzTmFtZSIsImVudW1lcmFibGUiLCIkJHR5cGVvZiIsImVuIiwic3R5bGVUZXh0cyIsInN0eWxlRWxzIiwiaW5qZWN0U3R5bGVzIiwic3R5bGVUZXh0Iiwic3R5bGVFbCIsImFwcGVuZFN0eWxlc1RvIiwiZW5zdXJlRWxIYXNTdHlsZXMiLCJlbCIsImlzQ29ubmVjdGVkIiwicmVnaXN0ZXJTdHlsZXNSb290IiwiZ2V0Um9vdE5vZGUiLCJyb290Tm9kZSIsInF1ZXJ5U2VsZWN0b3IiLCJub25jZSIsImdldE5vbmNlVmFsdWUiLCJwYXJlbnRFbCIsImhlYWQiLCJoeWRyYXRlU3R5bGVzUm9vdCIsInNoZWV0IiwicnVsZUNudCIsImNzc1J1bGVzIiwic3BsaXQiLCJzdHlsZVN0ciIsInRyaW0iLCJpbnNlcnRSdWxlIiwicXVlcmllZE5vbmNlVmFsdWUiLCJ1bmRlZmluZWQiLCJxdWVyeU5vbmNlVmFsdWUiLCJtZXRhV2l0aE5vbmNlIiwiaGFzQXR0cmlidXRlIiwiZ2V0QXR0cmlidXRlIiwiZWxXaXRoTm9uY2UiLCJjc3NfMjQ4eiQ0IiwicmVtb3ZlRWxlbWVudCIsImVsZW1lbnRDbG9zZXN0Iiwic2VsZWN0b3IiLCJjbG9zZXN0IiwiZG9jdW1lbnRFbGVtZW50IiwiY29udGFpbnMiLCJlbGVtZW50TWF0Y2hlcyIsInBhcmVudEVsZW1lbnQiLCJtZXRob2QiLCJtYXRjaGVzIiwibWF0Y2hlc1NlbGVjdG9yIiwibXNNYXRjaGVzU2VsZWN0b3IiLCJmaW5kRWxlbWVudHMiLCJjb250YWluZXIiLCJjb250YWluZXJzIiwiSFRNTEVsZW1lbnQiLCJhbGxNYXRjaGVzIiwicXVlcnlTZWxlY3RvckFsbCIsImZpbmREaXJlY3RDaGlsZHJlbiIsInBhcmVudCIsInBhcmVudHMiLCJjaGlsZE5vZGUiLCJQSVhFTF9QUk9QX1JFIiwiYXBwbHlTdHlsZSIsInByb3BOYW1lIiwiYXBwbHlTdHlsZVByb3AiLCJ2YWwiLCJnZXRFdmVudFRhcmdldFZpYVJvb3QiLCJldiIsIl9hIiwiX2IiLCJjb21wb3NlZFBhdGgiLCJ0YXJnZXQiLCJndWlkJDEiLCJnZXRVbmlxdWVEb21JZCIsInByZXZlbnREZWZhdWx0IiwiYnVpbGREZWxlZ2F0aW9uSGFuZGxlciIsImhhbmRsZXIiLCJtYXRjaGVkQ2hpbGQiLCJsaXN0ZW5CeVNlbGVjdG9yIiwiZXZlbnRUeXBlIiwiYXR0YWNoZWRIYW5kbGVyIiwibGlzdGVuVG9Ib3ZlckJ5U2VsZWN0b3IiLCJvbk1vdXNlRW50ZXIiLCJvbk1vdXNlTGVhdmUiLCJjdXJyZW50TWF0Y2hlZENoaWxkIiwibW91c2VPdmVyRXYiLCJyZWFsT25Nb3VzZUxlYXZlIiwibW91c2VMZWF2ZUV2IiwidHJhbnNpdGlvbkV2ZW50TmFtZXMiLCJ3aGVuVHJhbnNpdGlvbkRvbmUiLCJjYWxsYmFjayIsInJlYWxDYWxsYmFjayIsImV2ZW50TmFtZSIsImNyZWF0ZUFyaWFDbGlja0F0dHJzIiwiYXNzaWduIiwib25DbGljayIsImNyZWF0ZUFyaWFLZXlib2FyZEF0dHJzIiwidGFiSW5kZXgiLCJvbktleURvd24iLCJndWlkTnVtYmVyIiwiZ3VpZCIsIlN0cmluZyIsImRpc2FibGVDdXJzb3IiLCJib2R5IiwiY2xhc3NMaXN0IiwiYWRkIiwiZW5hYmxlQ3Vyc29yIiwicmVtb3ZlIiwicHJldmVudFNlbGVjdGlvbiIsInVzZXJTZWxlY3QiLCJhbGxvd1NlbGVjdGlvbiIsInByZXZlbnRDb250ZXh0TWVudSIsImFsbG93Q29udGV4dE1lbnUiLCJwYXJzZUZpZWxkU3BlY3MiLCJpbnB1dCIsInNwZWNzIiwidG9rZW5zIiwidG9rZW4iLCJjaGFyQXQiLCJmaWVsZCIsInN1YnN0cmluZyIsIm9yZGVyIiwiZnVuYyIsImNvbXBhcmVCeUZpZWxkU3BlY3MiLCJvYmowIiwib2JqMSIsImZpZWxkU3BlY3MiLCJjbXAiLCJjb21wYXJlQnlGaWVsZFNwZWMiLCJmaWVsZFNwZWMiLCJmbGV4aWJsZUNvbXBhcmUiLCJsb2NhbGVDb21wYXJlIiwicGFkU3RhcnQiLCJsZW4iLCJzdWJzdHIiLCJmb3JtYXRXaXRoT3JkaW5hbHMiLCJmb3JtYXR0ZXIiLCJhcmdzIiwiZmFsbGJhY2tUZXh0IiwicmVkdWNlIiwic3RyIiwiYXJnIiwiaW5kZXgiLCJjb21wYXJlTnVtYmVycyIsImlzSW50IiwiY29tcHV0ZVNtYWxsZXN0Q2VsbFdpZHRoIiwiY2VsbEVsIiwiYWxsV2lkdGhFbCIsImNvbnRlbnRXaWR0aEVsIiwiRXJyb3IiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJ3aWR0aCIsIklOVEVSTkFMX1VOSVRTIiwiUEFSU0VfUkUiLCJjcmVhdGVEdXJhdGlvbiIsInVuaXQiLCJwYXJzZVN0cmluZyIsInBhcnNlT2JqZWN0IiwiZXhlYyIsInNpZ24iLCJ5ZWFycyIsIm1vbnRocyIsImRheXMiLCJwYXJzZUludCIsIm1pbGxpc2Vjb25kcyIsIm9iaiIsImR1cmF0aW9uIiwieWVhciIsIm1vbnRoIiwiZGF5IiwiaG91cnMiLCJob3VyIiwibWludXRlcyIsIm1pbnV0ZSIsInNlY29uZHMiLCJzZWNvbmQiLCJtaWxsaXNlY29uZCIsIm1zIiwid2Vla3MiLCJ3ZWVrIiwic3BlY2lmaWVkV2Vla3MiLCJkdXJhdGlvbnNFcXVhbCIsImQwIiwiZDEiLCJhc0NsZWFuRGF5cyIsImR1ciIsImFkZER1cmF0aW9ucyIsInN1YnRyYWN0RHVyYXRpb25zIiwibXVsdGlwbHlEdXJhdGlvbiIsImFzUm91Z2hZZWFycyIsImFzUm91Z2hEYXlzIiwiYXNSb3VnaE1vbnRocyIsImFzUm91Z2hNcyIsImFzUm91Z2hNaW51dGVzIiwiYXNSb3VnaFNlY29uZHMiLCJ3aG9sZURpdmlkZUR1cmF0aW9ucyIsIm51bWVyYXRvciIsImRlbm9taW5hdG9yIiwicmVzIiwibG9jYWxSZXMiLCJncmVhdGVzdER1cmF0aW9uRGVub21pbmF0b3IiLCJoYXNPd25Qcm9wZXJ0eSIsIm1lcmdlUHJvcHMiLCJwcm9wT2JqcyIsImNvbXBsZXhQcm9wc01hcCIsImRlc3QiLCJpc01heWJlT2JqZWN0c0VxdWFsIiwiY29tcGxleE9ianMiLCJ1bnNoaWZ0IiwiZmlsdGVySGFzaCIsImhhc2giLCJmaWx0ZXJlZCIsIm1hcEhhc2giLCJuZXdIYXNoIiwiYXJyYXlUb0hhc2giLCJpdGVtIiwiaGFzaFZhbHVlc1RvQXJyYXkiLCJpc1Byb3BzRXF1YWwiLCJIQU5ETEVSX1JFIiwiaXNOb25IYW5kbGVyUHJvcHNFcXVhbCIsImtleXMiLCJnZXRVbmVxdWFsUHJvcHMiLCJjb21wYXJlT2JqcyIsIm9sZFByb3BzIiwibmV3UHJvcHMiLCJlcXVhbGl0eUZ1bmNzIiwiaXNPYmpWYWxzRXF1YWwiLCJ2YWwwIiwidmFsMSIsImNvbXBhcmF0b3IiLCJjb2xsZWN0RnJvbUhhc2giLCJzdGFydEluZGV4IiwiZW5kSW5kZXgiLCJzdGVwIiwicmVtb3ZlRXhhY3QiLCJhcnJheSIsImV4YWN0VmFsIiwicmVtb3ZlQ250IiwiaXNBcnJheXNFcXVhbCIsImEwIiwiYTEiLCJlcXVhbGl0eUZ1bmMiLCJEQVlfSURTIiwiYWRkV2Vla3MiLCJkYXRlVG9VdGNBcnJheSIsImFycmF5VG9VdGNEYXRlIiwiYWRkRGF5cyIsImFkZE1zIiwiZGlmZldlZWtzIiwibTAiLCJtMSIsImRpZmZEYXlzIiwidmFsdWVPZiIsImRpZmZIb3VycyIsImRpZmZNaW51dGVzIiwiZGlmZlNlY29uZHMiLCJkaWZmRGF5QW5kVGltZSIsIm0wZGF5Iiwic3RhcnRPZkRheSIsIm0xZGF5IiwiTWF0aCIsInJvdW5kIiwiZGlmZldob2xlV2Vla3MiLCJkaWZmV2hvbGVEYXlzIiwidGltZUFzTXMiLCJnZXRVVENGdWxsWWVhciIsImdldFVUQ01vbnRoIiwiZ2V0VVRDRGF0ZSIsInN0YXJ0T2ZIb3VyIiwiZ2V0VVRDSG91cnMiLCJzdGFydE9mTWludXRlIiwiZ2V0VVRDTWludXRlcyIsInN0YXJ0T2ZTZWNvbmQiLCJnZXRVVENTZWNvbmRzIiwid2Vla09mWWVhciIsIm1hcmtlciIsImRvdyIsImRveSIsIndlZWtPZkdpdmVuWWVhciIsIm5leHRXIiwibWluIiwiZmlyc3RXZWVrU3RhcnQiLCJmaXJzdFdlZWtPZmZzZXQiLCJkYXlTdGFydCIsImZsb29yIiwiZndkIiwiZndkbHciLCJnZXRVVENEYXkiLCJkYXRlVG9Mb2NhbEFycmF5IiwiZGF0ZSIsImdldEZ1bGxZZWFyIiwiZ2V0TW9udGgiLCJnZXREYXRlIiwiZ2V0SG91cnMiLCJnZXRNaW51dGVzIiwiZ2V0U2Vjb25kcyIsImdldE1pbGxpc2Vjb25kcyIsImFycmF5VG9Mb2NhbERhdGUiLCJEYXRlIiwiZ2V0VVRDTWlsbGlzZWNvbmRzIiwiY29uY2F0IiwiVVRDIiwiaXNWYWxpZERhdGUiLCJpc05hTiIsImJ1aWxkSXNvU3RyaW5nIiwidGltZVpvbmVPZmZzZXQiLCJzdHJpcFplcm9UaW1lIiwidG9JU09TdHJpbmciLCJmb3JtYXRUaW1lWm9uZU9mZnNldCIsImZvcm1hdERheVN0cmluZyIsImZvcm1hdElzb01vbnRoU3RyIiwibWF0Y2giLCJmb3JtYXRJc29UaW1lU3RyaW5nIiwiZG9Jc28iLCJhYnMiLCJtaW5zIiwibWVtb2l6ZSIsIndvcmtlckZ1bmMiLCJyZXNFcXVhbGl0eSIsInRlYXJkb3duRnVuYyIsImN1cnJlbnRBcmdzIiwiY3VycmVudFJlcyIsIm5ld0FyZ3MiLCJhcHBseSIsIm1lbW9pemVPYmpBcmciLCJjdXJyZW50QXJnIiwibmV3QXJnIiwibWVtb2l6ZUFycmF5bGlrZSIsImN1cnJlbnRBcmdTZXRzIiwiY3VycmVudFJlc3VsdHMiLCJuZXdBcmdTZXRzIiwiY3VycmVudExlbiIsIm5ld0xlbiIsIm1lbW9pemVIYXNobGlrZSIsImN1cnJlbnRBcmdIYXNoIiwiY3VycmVudFJlc0hhc2giLCJuZXdBcmdIYXNoIiwibmV3UmVzSGFzaCIsIkVYVEVOREVEX1NFVFRJTkdTX0FORF9TRVZFUklUSUVTIiwic2VwYXJhdG9yIiwib21pdFplcm9NaW51dGUiLCJtZXJpZGllbSIsIm9taXRDb21tYXMiLCJTVEFOREFSRF9EQVRFX1BST1BfU0VWRVJJVElFUyIsInRpbWVab25lTmFtZSIsImVyYSIsIndlZWtkYXkiLCJNRVJJRElFTV9SRSIsIkNPTU1BX1JFIiwiTVVMVElfU1BBQ0VfUkUiLCJMVFJfUkUiLCJVVENfUkUiLCJOYXRpdmVGb3JtYXR0ZXIiLCJmb3JtYXQiLCJidWlsZEZvcm1hdHRpbmdGdW5jIiwic3RhbmRhcmREYXRlUHJvcHMiLCJleHRlbmRlZFNldHRpbmdzIiwiZm9ybWF0UmFuZ2UiLCJzdGFydCIsImVuZCIsImJldHRlckRlZmF1bHRTZXBhcmF0b3IiLCJkaWZmU2V2ZXJpdHkiLCJjb21wdXRlTWFya2VyRGlmZlNldmVyaXR5IiwiY2FsZW5kYXJTeXN0ZW0iLCJiaWdnZXN0VW5pdEZvclBhcnRpYWwiLCJmdWxsMCIsImZ1bGwxIiwicGFydGlhbERhdGVQcm9wcyIsImNvbXB1dGVQYXJ0aWFsRm9ybWF0dGluZ09wdGlvbnMiLCJwYXJ0aWFsRm9ybWF0dGluZ0Z1bmMiLCJwYXJ0aWFsMCIsInBhcnRpYWwxIiwiaW5zZXJ0aW9uIiwiZmluZENvbW1vbkluc2VydGlvbiIsImRlZmF1bHRTZXBhcmF0b3IiLCJiZWZvcmUiLCJhZnRlciIsImdldExhcmdlc3RVbml0Iiwic2V2ZXJpdHkiLCJmb3JtYXRTZXR0aW5ncyIsIm1heCIsInN0YW5kYXJkRGF0ZVByb3BDbnQiLCJmb3JtYXRXZWVrTnVtYmVyIiwiY29tcHV0ZVdlZWtOdW1iZXIiLCJ3ZWVrVGV4dCIsIndlZWtUZXh0TG9uZyIsImxvY2FsZSIsImJ1aWxkTmF0aXZlRm9ybWF0dGluZ0Z1bmMiLCJzYW5pdGl6ZVNldHRpbmdzIiwidGltZVpvbmUiLCJub3JtYWxGb3JtYXQiLCJJbnRsIiwiRGF0ZVRpbWVGb3JtYXQiLCJjb2RlcyIsInplcm9Gb3JtYXQiLCJ6ZXJvUHJvcHMiLCJwb3N0UHJvY2VzcyIsImluamVjdFR6b1N0ciIsInRvTG9jYWxlTG93ZXJDYXNlIiwidHpvU3RyIiwicmVwbGFjZWQiLCJudW0iLCJkaXNwbGF5IiwicGFydHMiLCJzaW1wbGVOdW1iZXJGb3JtYXQiLCJvcHRpb25zIiwiZGlyZWN0aW9uIiwiam9pbiIsImNhIiwiZ2V0TWFya2VyWWVhciIsImdldE1hcmtlck1vbnRoIiwiZ2V0TWFya2VyRGF5IiwiYmlnZ2VzdFVuaXQiLCJwYXJ0aWFsT3B0aW9ucyIsImkwIiwiZm91bmQwIiwiYmVmb3JlMCIsImFmdGVyMCIsImkxIiwiZm91bmQxIiwiYmVmb3JlMSIsImFmdGVyMSIsImV4cGFuZFpvbmVkTWFya2VyIiwiZGF0ZUluZm8iLCJtYXJrZXJUb0FycmF5IiwiY3JlYXRlVmVyYm9zZUZvcm1hdHRpbmdBcmciLCJzdGFydEluZm8iLCJlbmRJbmZvIiwibG9jYWxlQ29kZXMiLCJDbWRGb3JtYXR0ZXIiLCJjbWRGb3JtYXR0ZXIiLCJjbWRTdHIiLCJGdW5jRm9ybWF0dGVyIiwiY3JlYXRlRm9ybWF0dGVyIiwiQkFTRV9PUFRJT05fUkVGSU5FUlMiLCJuYXZMaW5rRGF5Q2xpY2siLCJpZGVudGl0eSIsIm5hdkxpbmtXZWVrQ2xpY2siLCJib290c3RyYXBGb250QXdlc29tZSIsImJ1dHRvbkljb25zIiwiY3VzdG9tQnV0dG9ucyIsImRlZmF1bHRBbGxEYXlFdmVudER1cmF0aW9uIiwiZGVmYXVsdFRpbWVkRXZlbnREdXJhdGlvbiIsIm5leHREYXlUaHJlc2hvbGQiLCJzY3JvbGxUaW1lIiwic2Nyb2xsVGltZVJlc2V0IiwiQm9vbGVhbiIsInNsb3RNaW5UaW1lIiwic2xvdE1heFRpbWUiLCJkYXlQb3BvdmVyRm9ybWF0Iiwic2xvdER1cmF0aW9uIiwic25hcER1cmF0aW9uIiwiaGVhZGVyVG9vbGJhciIsImZvb3RlclRvb2xiYXIiLCJkZWZhdWx0UmFuZ2VTZXBhcmF0b3IiLCJ0aXRsZVJhbmdlU2VwYXJhdG9yIiwiZm9yY2VFdmVudER1cmF0aW9uIiwiZGF5SGVhZGVycyIsImRheUhlYWRlckZvcm1hdCIsImRheUhlYWRlckNsYXNzTmFtZXMiLCJkYXlIZWFkZXJDb250ZW50IiwiZGF5SGVhZGVyRGlkTW91bnQiLCJkYXlIZWFkZXJXaWxsVW5tb3VudCIsImRheUNlbGxDbGFzc05hbWVzIiwiZGF5Q2VsbENvbnRlbnQiLCJkYXlDZWxsRGlkTW91bnQiLCJkYXlDZWxsV2lsbFVubW91bnQiLCJpbml0aWFsVmlldyIsImFzcGVjdFJhdGlvIiwiTnVtYmVyIiwid2Vla2VuZHMiLCJ3ZWVrTnVtYmVyQ2FsY3VsYXRpb24iLCJ3ZWVrTnVtYmVycyIsIndlZWtOdW1iZXJDbGFzc05hbWVzIiwid2Vla051bWJlckNvbnRlbnQiLCJ3ZWVrTnVtYmVyRGlkTW91bnQiLCJ3ZWVrTnVtYmVyV2lsbFVubW91bnQiLCJlZGl0YWJsZSIsInZpZXdDbGFzc05hbWVzIiwidmlld0RpZE1vdW50Iiwidmlld1dpbGxVbm1vdW50Iiwibm93SW5kaWNhdG9yIiwibm93SW5kaWNhdG9yQ2xhc3NOYW1lcyIsIm5vd0luZGljYXRvckNvbnRlbnQiLCJub3dJbmRpY2F0b3JEaWRNb3VudCIsIm5vd0luZGljYXRvcldpbGxVbm1vdW50Iiwic2hvd05vbkN1cnJlbnREYXRlcyIsImxhenlGZXRjaGluZyIsInN0YXJ0UGFyYW0iLCJlbmRQYXJhbSIsInRpbWVab25lUGFyYW0iLCJsb2NhbGVzIiwidGhlbWVTeXN0ZW0iLCJkcmFnUmV2ZXJ0RHVyYXRpb24iLCJkcmFnU2Nyb2xsIiwiYWxsRGF5TWFpbnRhaW5EdXJhdGlvbiIsInVuc2VsZWN0QXV0byIsImRyb3BBY2NlcHQiLCJldmVudE9yZGVyIiwiZXZlbnRPcmRlclN0cmljdCIsImhhbmRsZVdpbmRvd1Jlc2l6ZSIsIndpbmRvd1Jlc2l6ZURlbGF5IiwibG9uZ1ByZXNzRGVsYXkiLCJldmVudERyYWdNaW5EaXN0YW5jZSIsImV4cGFuZFJvd3MiLCJoZWlnaHQiLCJjb250ZW50SGVpZ2h0Iiwid2Vla051bWJlckZvcm1hdCIsImV2ZW50UmVzaXphYmxlRnJvbVN0YXJ0IiwiZGlzcGxheUV2ZW50VGltZSIsImRpc3BsYXlFdmVudEVuZCIsInByb2dyZXNzaXZlRXZlbnRSZW5kZXJpbmciLCJidXNpbmVzc0hvdXJzIiwiaW5pdGlhbERhdGUiLCJub3ciLCJldmVudERhdGFUcmFuc2Zvcm0iLCJzdGlja3lIZWFkZXJEYXRlcyIsInN0aWNreUZvb3RlclNjcm9sbGJhciIsInZpZXdIZWlnaHQiLCJkZWZhdWx0QWxsRGF5IiwiZXZlbnRTb3VyY2VGYWlsdXJlIiwiZXZlbnRTb3VyY2VTdWNjZXNzIiwiZXZlbnREaXNwbGF5IiwiZXZlbnRTdGFydEVkaXRhYmxlIiwiZXZlbnREdXJhdGlvbkVkaXRhYmxlIiwiZXZlbnRPdmVybGFwIiwiZXZlbnRDb25zdHJhaW50IiwiZXZlbnRBbGxvdyIsImV2ZW50QmFja2dyb3VuZENvbG9yIiwiZXZlbnRCb3JkZXJDb2xvciIsImV2ZW50VGV4dENvbG9yIiwiZXZlbnRDb2xvciIsImV2ZW50Q2xhc3NOYW1lcyIsImV2ZW50Q29udGVudCIsImV2ZW50RGlkTW91bnQiLCJldmVudFdpbGxVbm1vdW50Iiwic2VsZWN0Q29uc3RyYWludCIsInNlbGVjdE92ZXJsYXAiLCJzZWxlY3RBbGxvdyIsImRyb3BwYWJsZSIsInVuc2VsZWN0Q2FuY2VsIiwic2xvdExhYmVsRm9ybWF0Iiwic2xvdExhbmVDbGFzc05hbWVzIiwic2xvdExhbmVDb250ZW50Iiwic2xvdExhbmVEaWRNb3VudCIsInNsb3RMYW5lV2lsbFVubW91bnQiLCJzbG90TGFiZWxDbGFzc05hbWVzIiwic2xvdExhYmVsQ29udGVudCIsInNsb3RMYWJlbERpZE1vdW50Iiwic2xvdExhYmVsV2lsbFVubW91bnQiLCJkYXlNYXhFdmVudHMiLCJkYXlNYXhFdmVudFJvd3MiLCJkYXlNaW5XaWR0aCIsInNsb3RMYWJlbEludGVydmFsIiwiYWxsRGF5VGV4dCIsImFsbERheUNsYXNzTmFtZXMiLCJhbGxEYXlDb250ZW50IiwiYWxsRGF5RGlkTW91bnQiLCJhbGxEYXlXaWxsVW5tb3VudCIsInNsb3RNaW5XaWR0aCIsIm5hdkxpbmtzIiwiZXZlbnRUaW1lRm9ybWF0IiwicmVyZW5kZXJEZWxheSIsIm1vcmVMaW5rVGV4dCIsIm1vcmVMaW5rSGludCIsInNlbGVjdE1pbkRpc3RhbmNlIiwic2VsZWN0YWJsZSIsInNlbGVjdExvbmdQcmVzc0RlbGF5IiwiZXZlbnRMb25nUHJlc3NEZWxheSIsInNlbGVjdE1pcnJvciIsImV2ZW50TWF4U3RhY2siLCJldmVudE1pbkhlaWdodCIsImV2ZW50TWluV2lkdGgiLCJldmVudFNob3J0SGVpZ2h0Iiwic2xvdEV2ZW50T3ZlcmxhcCIsInBsdWdpbnMiLCJmaXJzdERheSIsImRheUNvdW50IiwiZGF0ZUFsaWdubWVudCIsImRhdGVJbmNyZW1lbnQiLCJoaWRkZW5EYXlzIiwiZml4ZWRXZWVrQ291bnQiLCJ2YWxpZFJhbmdlIiwidmlzaWJsZVJhbmdlIiwidGl0bGVGb3JtYXQiLCJldmVudEludGVyYWN0aXZlIiwibm9FdmVudHNUZXh0Iiwidmlld0hpbnQiLCJuYXZMaW5rSGludCIsImNsb3NlSGludCIsInRpbWVIaW50IiwiZXZlbnRIaW50IiwibW9yZUxpbmtDbGljayIsIm1vcmVMaW5rQ2xhc3NOYW1lcyIsIm1vcmVMaW5rQ29udGVudCIsIm1vcmVMaW5rRGlkTW91bnQiLCJtb3JlTGlua1dpbGxVbm1vdW50IiwibW9udGhTdGFydEZvcm1hdCIsImhhbmRsZUN1c3RvbVJlbmRlcmluZyIsImN1c3RvbVJlbmRlcmluZ01ldGFNYXAiLCJjdXN0b21SZW5kZXJpbmdSZXBsYWNlc0VsIiwiQkFTRV9PUFRJT05fREVGQVVMVFMiLCJjZW50ZXIiLCJDQUxFTkRBUl9MSVNURU5FUl9SRUZJTkVSUyIsImRhdGVzU2V0IiwiZXZlbnRzU2V0IiwiZXZlbnRBZGQiLCJldmVudENoYW5nZSIsImV2ZW50UmVtb3ZlIiwid2luZG93UmVzaXplIiwiZXZlbnRDbGljayIsImV2ZW50TW91c2VFbnRlciIsImV2ZW50TW91c2VMZWF2ZSIsInNlbGVjdCIsInVuc2VsZWN0IiwibG9hZGluZyIsIl91bm1vdW50IiwiX2JlZm9yZXByaW50IiwiX2FmdGVycHJpbnQiLCJfbm9FdmVudERyb3AiLCJfbm9FdmVudFJlc2l6ZSIsIl9yZXNpemUiLCJfc2Nyb2xsUmVxdWVzdCIsIkNBTEVOREFSX09QVElPTl9SRUZJTkVSUyIsImJ1dHRvblRleHQiLCJidXR0b25IaW50cyIsInZpZXdzIiwiaW5pdGlhbEV2ZW50cyIsImV2ZW50cyIsImV2ZW50U291cmNlcyIsIkNPTVBMRVhfT1BUSU9OX0NPTVBBUkFUT1JTIiwiaXNNYXliZUFycmF5c0VxdWFsIiwiVklFV19PUFRJT05fUkVGSU5FUlMiLCJjb21wb25lbnQiLCJidXR0b25UZXh0S2V5IiwiZGF0ZVByb2ZpbGVHZW5lcmF0b3JDbGFzcyIsInVzZXNNaW5NYXhUaW1lIiwiY2xhc3NOYW1lcyIsImNvbnRlbnQiLCJkaWRNb3VudCIsIndpbGxVbm1vdW50IiwibWVyZ2VSYXdPcHRpb25zIiwib3B0aW9uU2V0cyIsInJlZmluZVByb3BzIiwicmVmaW5lcnMiLCJyZWZpbmVkIiwiZXh0cmEiLCJyYXciLCJjcmVhdGVFdmVudEluc3RhbmNlIiwiZGVmSWQiLCJyYW5nZSIsImZvcmNlZFN0YXJ0VHpvIiwiZm9yY2VkRW5kVHpvIiwiaW5zdGFuY2VJZCIsInBhcnNlUmVjdXJyaW5nIiwiZGF0ZUVudiIsInJlY3VycmluZ1R5cGVzIiwicGFyc2VkIiwicGFyc2UiLCJhbGxEYXkiLCJhbGxEYXlHdWVzcyIsInR5cGVEYXRhIiwidHlwZUlkIiwiZXhwYW5kUmVjdXJyaW5nIiwiZXZlbnRTdG9yZSIsImZyYW1pbmdSYW5nZSIsInBsdWdpbkhvb2tzIiwiZGVmcyIsImluc3RhbmNlcyIsImluc3RhbmNlIiwicmVjdXJyaW5nRGVmIiwiZGVmIiwic3RhcnRzIiwiZXhwYW5kUmVjdXJyaW5nUmFuZ2VzIiwiZXZlbnREZWYiLCJ0eXBlRGVmIiwibWFya2VycyIsImV4cGFuZCIsInN1YnRyYWN0IiwicGFyc2VFdmVudHMiLCJyYXdFdmVudHMiLCJldmVudFNvdXJjZSIsImFsbG93T3BlblJhbmdlIiwiZGVmSWRNYXAiLCJpbnN0YW5jZUlkTWFwIiwiY3JlYXRlRW1wdHlFdmVudFN0b3JlIiwiZXZlbnRSZWZpbmVycyIsImJ1aWxkRXZlbnRSZWZpbmVycyIsInJhd0V2ZW50IiwidHVwbGUiLCJwYXJzZUV2ZW50IiwiZXZlbnRUdXBsZVRvU3RvcmUiLCJnZXRSZWxldmFudEV2ZW50cyIsIm5ld1N0b3JlIiwiZmlsdGVyRXZlbnRTdG9yZURlZnMiLCJsb29rRGVmIiwiaXNFdmVudERlZnNHcm91cGVkIiwiZGVmMCIsImRlZjEiLCJncm91cElkIiwibWVyZ2VFdmVudFN0b3JlcyIsInN0b3JlMCIsInN0b3JlMSIsImZpbHRlckZ1bmMiLCJleGNsdWRlU3ViRXZlbnRTdG9yZSIsIm1hc3RlciIsImZpbHRlcmVkRGVmcyIsImZpbHRlcmVkSW5zdGFuY2VzIiwibm9ybWFsaXplQ29uc3RyYWludCIsInBhcnNlQ2xhc3NOYW1lcyIsIkVWRU5UX1VJX1JFRklORVJTIiwic3RhcnRFZGl0YWJsZSIsImR1cmF0aW9uRWRpdGFibGUiLCJjb25zdHJhaW50Iiwib3ZlcmxhcCIsImFsbG93IiwiY29sb3IiLCJiYWNrZ3JvdW5kQ29sb3IiLCJib3JkZXJDb2xvciIsInRleHRDb2xvciIsIkVNUFRZX0VWRU5UX1VJIiwiY29uc3RyYWludHMiLCJhbGxvd3MiLCJjcmVhdGVFdmVudFVpIiwiY29tYmluZUV2ZW50VWlzIiwidWlzIiwiY29tYmluZVR3b0V2ZW50VWlzIiwiaXRlbTAiLCJpdGVtMSIsIkVWRU5UX05PTl9EQVRFX1JFRklORVJTIiwiaWQiLCJ0aXRsZSIsInVybCIsImludGVyYWN0aXZlIiwiRVZFTlRfREFURV9SRUZJTkVSUyIsIkVWRU5UX1JFRklORVJTIiwiZXh0ZW5kZWRQcm9wcyIsInJlZmluZUV2ZW50RGVmIiwiY29tcHV0ZUlzRGVmYXVsdEFsbERheSIsInJlY3VycmluZ1JlcyIsInBhcnNlRXZlbnREZWYiLCJzb3VyY2VJZCIsInNpbmdsZVJlcyIsInBhcnNlU2luZ2xlIiwiaGFzRW5kIiwicHVibGljSWQiLCJ1aSIsIm1lbWJlckFkZGVyIiwiZXZlbnREZWZNZW1iZXJBZGRlcnMiLCJmcmVlemUiLCJzdGFydE1ldGEiLCJzdGFydE1hcmtlciIsImVuZE1ldGEiLCJlbmRNYXJrZXIiLCJzdGFydElucHV0IiwiY3JlYXRlTWFya2VyTWV0YSIsImlzVGltZVVuc3BlY2lmaWVkIiwiZm9yY2VkVHpvIiwiREVGX0RFRkFVTFRTIiwic3RhcnRUaW1lIiwiZW5kVGltZSIsImRheXNPZldlZWsiLCJwYXJzZUJ1c2luZXNzSG91cnMiLCJyZWZpbmVJbnB1dHMiLCJyYXdEZWZzIiwicmF3RGVmIiwiY29tcHV0ZUFsaWduZWREYXlSYW5nZSIsInRpbWVkUmFuZ2UiLCJkYXlDbnQiLCJjb21wdXRlVmlzaWJsZURheVJhbmdlIiwic3RhcnREYXkiLCJlbmREYXkiLCJlbmRUaW1lTVMiLCJpc011bHRpRGF5UmFuZ2UiLCJkaWZmRGF0ZXMiLCJkYXRlMCIsImRhdGUxIiwibGFyZ2VVbml0IiwiZGlmZldob2xlWWVhcnMiLCJkaWZmV2hvbGVNb250aHMiLCJwb2ludEluc2lkZVJlY3QiLCJwb2ludCIsInJlY3QiLCJsZWZ0IiwicmlnaHQiLCJ0b3AiLCJib3R0b20iLCJpbnRlcnNlY3RSZWN0cyIsInJlY3QxIiwicmVjdDIiLCJ0cmFuc2xhdGVSZWN0IiwiZGVsdGFYIiwiZGVsdGFZIiwiY29uc3RyYWluUG9pbnQiLCJnZXRSZWN0Q2VudGVyIiwiZGlmZlBvaW50cyIsInBvaW50MSIsInBvaW50MiIsImNhblZHcm93V2l0aGluQ2VsbCIsImdldENhblZHcm93V2l0aGluQ2VsbCIsImNvbXB1dGVDYW5WR3Jvd1dpdGhpbkNlbGwiLCJwb3NpdGlvbiIsImRpdiIsInBvc3NpYmxlIiwib2Zmc2V0SGVpZ2h0IiwiRU1QVFlfRVZFTlRfU1RPUkUiLCJTcGxpdHRlciIsInNwbGl0UHJvcHMiLCJrZXlJbmZvcyIsImdldEtleUluZm8iLCJkZWZLZXlzIiwiZ2V0S2V5c0ZvckV2ZW50RGVmcyIsImRhdGVTZWxlY3Rpb25zIiwic3BsaXREYXRlU2VsZWN0aW9uIiwiZGF0ZVNlbGVjdGlvbiIsImluZGl2aWR1YWxVaSIsInNwbGl0SW5kaXZpZHVhbFVpIiwiZXZlbnRVaUJhc2VzIiwiZXZlbnRTdG9yZXMiLCJzcGxpdEV2ZW50U3RvcmUiLCJldmVudERyYWdzIiwic3BsaXRFdmVudERyYWciLCJldmVudERyYWciLCJldmVudFJlc2l6ZXMiLCJzcGxpdEV2ZW50UmVzaXplIiwiZXZlbnRSZXNpemUiLCJldmVudFVpQnVpbGRlcnMiLCJpbmZvIiwiYnVpbGRFdmVudFVpRm9yS2V5Iiwia2V5SW5mbyIsImJ1aWxkRXZlbnRVaSIsImV2ZW50U2VsZWN0aW9uIiwiX3NwbGl0RGF0ZVNwYW4iLCJkYXRlU3BhbiIsImRhdGVTcGFucyIsImdldEtleXNGb3JEYXRlU3BhbiIsIl9nZXRLZXlzRm9yRXZlbnREZWZzIiwiZ2V0S2V5c0ZvckV2ZW50RGVmIiwiX3NwbGl0RXZlbnRTdG9yZSIsInNwbGl0U3RvcmVzIiwiX3NwbGl0SW5kaXZpZHVhbFVpIiwic3BsaXRIYXNoZXMiLCJfc3BsaXRJbnRlcmFjdGlvbiIsImludGVyYWN0aW9uIiwic3BsaXRTdGF0ZXMiLCJhZmZlY3RlZFN0b3JlcyIsImFmZmVjdGVkRXZlbnRzIiwibXV0YXRlZEtleXNCeURlZklkIiwibXV0YXRlZEV2ZW50cyIsIm11dGF0ZWRTdG9yZXMiLCJwb3B1bGF0ZSIsImlzRXZlbnQiLCJhbGxVaSIsImV2ZW50VWlGb3JLZXkiLCJiYXNlUGFydHMiLCJzdHVmZiIsInBhcnNlUmFuZ2UiLCJjcmVhdGVNYXJrZXIiLCJpbnZlcnRSYW5nZXMiLCJyYW5nZXMiLCJjb25zdHJhaW50UmFuZ2UiLCJpbnZlcnRlZFJhbmdlcyIsImRhdGVSYW5nZSIsImNvbXBhcmVSYW5nZXMiLCJyYW5nZTAiLCJyYW5nZTEiLCJpbnRlcnNlY3RSYW5nZXMiLCJuZXdSYW5nZSIsInJhbmdlc0VxdWFsIiwicmFuZ2VzSW50ZXJzZWN0IiwicmFuZ2VDb250YWluc1JhbmdlIiwib3V0ZXJSYW5nZSIsImlubmVyUmFuZ2UiLCJyYW5nZUNvbnRhaW5zTWFya2VyIiwiY29uc3RyYWluTWFya2VyVG9SYW5nZSIsImdldERhdGVNZXRhIiwidG9kYXlSYW5nZSIsIm5vd0RhdGUiLCJkYXRlUHJvZmlsZSIsImlzRGlzYWJsZWQiLCJhY3RpdmVSYW5nZSIsImlzT3RoZXIiLCJjdXJyZW50UmFuZ2UiLCJpc1RvZGF5IiwiaXNQYXN0IiwiaXNGdXR1cmUiLCJnZXREYXlDbGFzc05hbWVzIiwibWV0YSIsInRoZW1lIiwiZ2V0Q2xhc3MiLCJnZXRTbG90Q2xhc3NOYW1lcyIsIkRBWV9GT1JNQVQiLCJXRUVLX0ZPUk1BVCIsImJ1aWxkTmF2TGlua0F0dHJzIiwiZGF0ZU1hcmtlciIsInZpZXdUeXBlIiwiaXNUYWJiYWJsZSIsImNhbGVuZGFyQXBpIiwiZGF0ZVN0ciIsInpvbmVkRGF0ZSIsInRvRGF0ZSIsImhhbmRsZUludGVyYWN0aW9uIiwiY3VzdG9tQWN0aW9uIiwiem9vbVRvIiwiX2lzUnRsU2Nyb2xsYmFyT25MZWZ0IiwiZ2V0SXNSdGxTY3JvbGxiYXJPbkxlZnQiLCJjb21wdXRlSXNSdGxTY3JvbGxiYXJPbkxlZnQiLCJvdXRlckVsIiwiYm9yZGVyIiwicGFkZGluZyIsIm92ZXJmbG93IiwiaW5uZXJFbCIsIl9zY3JvbGxiYXJXaWR0aHMiLCJnZXRTY3JvbGxiYXJXaWR0aHMiLCJjb21wdXRlU2Nyb2xsYmFyV2lkdGhzIiwiY29tcHV0ZVNjcm9sbGJhcldpZHRoc0ZvckVsIiwiY2xpZW50SGVpZ2h0Iiwib2Zmc2V0V2lkdGgiLCJjbGllbnRXaWR0aCIsImNvbXB1dGVFZGdlcyIsImdldFBhZGRpbmciLCJjb21wdXRlZFN0eWxlIiwid2luZG93IiwiZ2V0Q29tcHV0ZWRTdHlsZSIsImJvcmRlckxlZnQiLCJib3JkZXJMZWZ0V2lkdGgiLCJib3JkZXJSaWdodCIsImJvcmRlclJpZ2h0V2lkdGgiLCJib3JkZXJUb3AiLCJib3JkZXJUb3BXaWR0aCIsImJvcmRlckJvdHRvbSIsImJvcmRlckJvdHRvbVdpZHRoIiwiYmFkU2Nyb2xsYmFyV2lkdGhzIiwic2Nyb2xsYmFyTGVmdFJpZ2h0Iiwic2Nyb2xsYmFyQm90dG9tIiwic2Nyb2xsYmFyTGVmdCIsInNjcm9sbGJhclJpZ2h0IiwicGFkZGluZ0xlZnQiLCJwYWRkaW5nUmlnaHQiLCJwYWRkaW5nVG9wIiwicGFkZGluZ0JvdHRvbSIsImNvbXB1dGVJbm5lclJlY3QiLCJnb1dpdGhpblBhZGRpbmciLCJkb0Zyb21XaW5kb3dWaWV3cG9ydCIsIm91dGVyUmVjdCIsImNvbXB1dGVSZWN0IiwiZWRnZXMiLCJwYWdlWE9mZnNldCIsInBhZ2VZT2Zmc2V0IiwiY29tcHV0ZUNsaXBwZWRDbGllbnRSZWN0IiwiY2xpcHBpbmdQYXJlbnRzIiwiZ2V0Q2xpcHBpbmdQYXJlbnRzIiwiY2xpcHBpbmdQYXJlbnQiLCJpbnRlcnNlY3Rpb24iLCJvdmVyZmxvd1kiLCJvdmVyZmxvd1giLCJ1bnByb21pc2lmeSIsIm5vcm1hbGl6ZWRTdWNjZXNzQ2FsbGJhY2siLCJub3JtYWxpemVkRmFpbHVyZUNhbGxiYWNrIiwiaXNSZXNvbHZlZCIsIndyYXBwZWRTdWNjZXNzIiwid3JhcHBlZEZhaWx1cmUiLCJlcnJvciIsIkVtaXR0ZXIiLCJzZXRUaGlzQ29udGV4dCIsInRoaXNDb250ZXh0Iiwic2V0T3B0aW9ucyIsIm9uIiwiYWRkVG9IYXNoIiwiaGFuZGxlcnMiLCJvZmYiLCJyZW1vdmVGcm9tSGFzaCIsInRyaWdnZXIiLCJhdHRhY2hlZEhhbmRsZXJzIiwib3B0aW9uSGFuZGxlciIsImhhc0hhbmRsZXJzIiwiUG9zaXRpb25DYWNoZSIsImJ1aWxkRWxIb3Jpem9udGFscyIsIm9yaWdpbkNsaWVudExlZnQiLCJsZWZ0cyIsInJpZ2h0cyIsImVscyIsImJ1aWxkRWxWZXJ0aWNhbHMiLCJvcmlnaW5DbGllbnRUb3AiLCJ0b3BzIiwiYm90dG9tcyIsImxlZnRUb0luZGV4IiwibGVmdFBvc2l0aW9uIiwidG9wVG9JbmRleCIsInRvcFBvc2l0aW9uIiwiZ2V0V2lkdGgiLCJsZWZ0SW5kZXgiLCJnZXRIZWlnaHQiLCJ0b3BJbmRleCIsInNpbWlsYXJUbyIsIm90aGVyQ2FjaGUiLCJzaW1pbGFyTnVtQXJyYXlzIiwib3JpZ2luRWwiLCJpc0hvcml6b250YWwiLCJpc1ZlcnRpY2FsIiwib3JpZ2luQ2xpZW50UmVjdCIsIlNjcm9sbENvbnRyb2xsZXIiLCJnZXRNYXhTY3JvbGxUb3AiLCJnZXRTY3JvbGxIZWlnaHQiLCJnZXRDbGllbnRIZWlnaHQiLCJnZXRNYXhTY3JvbGxMZWZ0IiwiZ2V0U2Nyb2xsV2lkdGgiLCJnZXRDbGllbnRXaWR0aCIsImNhblNjcm9sbFZlcnRpY2FsbHkiLCJjYW5TY3JvbGxIb3Jpem9udGFsbHkiLCJjYW5TY3JvbGxVcCIsImdldFNjcm9sbFRvcCIsImNhblNjcm9sbERvd24iLCJjYW5TY3JvbGxMZWZ0IiwiZ2V0U2Nyb2xsTGVmdCIsImNhblNjcm9sbFJpZ2h0IiwiRWxlbWVudFNjcm9sbENvbnRyb2xsZXIiLCJzY3JvbGxUb3AiLCJzY3JvbGxMZWZ0Iiwic2V0U2Nyb2xsVG9wIiwic2V0U2Nyb2xsTGVmdCIsInNjcm9sbFdpZHRoIiwic2Nyb2xsSGVpZ2h0IiwiV2luZG93U2Nyb2xsQ29udHJvbGxlciIsInNjcm9sbCIsIlRoZW1lIiwic2V0SWNvbk92ZXJyaWRlIiwiaWNvbk92ZXJyaWRlSGFzaCIsImljb25DbGFzc2VzQ29weSIsImJ1dHRvbk5hbWUiLCJpY29uQ2xhc3NlcyIsImFwcGx5SWNvbk92ZXJyaWRlUHJlZml4IiwicHJlZml4IiwiaWNvbk92ZXJyaWRlUHJlZml4IiwiY2xhc3NlcyIsImdldEljb25DbGFzcyIsImlzUnRsIiwicnRsSWNvbkNsYXNzZXMiLCJiYXNlSWNvbkNsYXNzIiwiZ2V0Q3VzdG9tQnV0dG9uSWNvbkNsYXNzIiwiY3VzdG9tQnV0dG9uUHJvcHMiLCJpY29uT3ZlcnJpZGVDdXN0b21CdXR0b25PcHRpb24iLCJjYWxlbmRhck9wdGlvbnMiLCJpY29uT3ZlcnJpZGVPcHRpb24iLCJmbHVzaFN5bmMiLCJydW5CZWZvcmVGbHVzaCIsIm9sZERlYm91bmNlUmVuZGVyaW5nIiwiY2FsbGJhY2tRIiwiZXhlY0NhbGxiYWNrU3luYyIsIkZha2VDb21wb25lbnQiLCJjcmVhdGVDb250ZXh0IiwiQ29udGV4dFR5cGUiLCJvcmlnUHJvdmlkZXIiLCJpc05ldyIsInN1YnMiLCJfcHJvcHMiLCJvbGQiLCJTY3JvbGxSZXNwb25kZXIiLCJkZXRhY2giLCJlbWl0dGVyIiwiaGFuZGxlU2Nyb2xsUmVxdWVzdCIsInVwZGF0ZSIsImlzRGF0ZXNOZXciLCJmaXJlSW5pdGlhbFNjcm9sbCIsImRyYWluIiwidGltZSIsInF1ZXVlZFJlcXVlc3QiLCJleGVjRnVuYyIsInJlcXVlc3QiLCJWaWV3Q29udGV4dFR5cGUiLCJidWlsZFZpZXdDb250ZXh0Iiwidmlld1NwZWMiLCJ2aWV3QXBpIiwidmlld09wdGlvbnMiLCJkYXRlUHJvZmlsZUdlbmVyYXRvciIsImRpc3BhdGNoIiwiZ2V0Q3VycmVudERhdGEiLCJyZWdpc3RlckludGVyYWN0aXZlQ29tcG9uZW50IiwidW5yZWdpc3RlckludGVyYWN0aXZlQ29tcG9uZW50IiwiYWRkUmVzaXplSGFuZGxlciIsInJlbW92ZVJlc2l6ZUhhbmRsZXIiLCJjcmVhdGVTY3JvbGxSZXNwb25kZXIiLCJQdXJlQ29tcG9uZW50IiwibmV4dFByb3BzIiwibmV4dFN0YXRlIiwiZGVidWciLCJjb25zb2xlIiwibG9nIiwicHJvcEVxdWFsaXR5Iiwic3RhdGVFcXVhbGl0eSIsInNhZmVTZXRTdGF0ZSIsIm5ld1N0YXRlIiwiYWRkUHJvcHNFcXVhbGl0eSIsImFkZFN0YXRlRXF1YWxpdHkiLCJCYXNlQ29tcG9uZW50IiwiY3JlYXRlIiwic2V0UmVmIiwiRGF0ZUNvbXBvbmVudCIsInByZXBhcmVIaXRzIiwicXVlcnlIaXQiLCJwb3NpdGlvbkxlZnQiLCJwb3NpdGlvblRvcCIsImVsV2lkdGgiLCJlbEhlaWdodCIsImlzVmFsaWRTZWdEb3duRWwiLCJpc1ZhbGlkRGF0ZURvd25FbCIsInVpZCIsInJlZHVjZUN1cnJlbnREYXRlIiwiY3VycmVudERhdGUiLCJhY3Rpb24iLCJnZXRJbml0aWFsRGF0ZSIsImluaXRpYWxEYXRlSW5wdXQiLCJnZXROb3ciLCJub3dJbnB1dCIsImNyZWF0ZU5vd01hcmtlciIsIkRhdGVQcm9maWxlR2VuZXJhdG9yIiwiYnVpbGRQcmV2IiwiY3VycmVudERhdGVQcm9maWxlIiwiZm9yY2VUb1ZhbGlkIiwicHJldkRhdGUiLCJzdGFydE9mIiwiY3VycmVudFJhbmdlVW5pdCIsImJ1aWxkIiwiYnVpbGROZXh0IiwibmV4dERhdGUiLCJjdXJyZW50SW5mbyIsImlzUmFuZ2VBbGxEYXkiLCJyZW5kZXJSYW5nZSIsImlzVmFsaWQiLCJidWlsZFZhbGlkUmFuZ2UiLCJ0cmltSGlkZGVuRGF5cyIsImJ1aWxkQ3VycmVudFJhbmdlSW5mbyIsImJ1aWxkUmVuZGVyUmFuZ2UiLCJhZGp1c3RBY3RpdmVSYW5nZSIsImJ1aWxkRGF0ZUluY3JlbWVudCIsInZhbGlkUmFuZ2VJbnB1dCIsInNpbXBsZUlucHV0IiwicmVmaW5lUmFuZ2UiLCJkdXJhdGlvblVuaXQiLCJidWlsZFJhbmdlRnJvbUR1cmF0aW9uIiwiYnVpbGRSYW5nZUZyb21EYXlDb3VudCIsImJ1aWxkQ3VzdG9tVmlzaWJsZVJhbmdlIiwiZ3JlYXRlc3RXaG9sZVVuaXQiLCJnZXRGYWxsYmFja0R1cmF0aW9uIiwiaXNIaWRkZW5EYXkiLCJza2lwSGlkZGVuRGF5cyIsImNvbXB1dGVSZXMiLCJydW5uaW5nQ291bnQiLCJ2aXNpYmxlUmFuZ2VJbnB1dCIsImN1c3RvbUFsaWdubWVudCIsInJhbmdlSW5wdXQiLCJpbml0SGlkZGVuRGF5cyIsImlzSGlkZGVuRGF5SGFzaCIsImluYyIsImlzRXhjbHVzaXZlIiwidHJpZ2dlckRhdGVTZWxlY3QiLCJzZWxlY3Rpb24iLCJwZXYiLCJidWlsZERhdGVTcGFuQXBpV2l0aENvbnRleHQiLCJqc0V2ZW50Iiwib3JpZ0V2ZW50IiwidmlldyIsInRyaWdnZXJEYXRlVW5zZWxlY3QiLCJ0cmFuc2Zvcm0iLCJkYXRlU3BhblRyYW5zZm9ybXMiLCJidWlsZERhdGVTcGFuQXBpIiwiZ2V0RGVmYXVsdEV2ZW50RW5kIiwiYXBwbHlNdXRhdGlvblRvRXZlbnRTdG9yZSIsImV2ZW50Q29uZmlnQmFzZSIsIm11dGF0aW9uIiwiZXZlbnRDb25maWdzIiwiY29tcGlsZUV2ZW50VWlzIiwiYXBwbHlNdXRhdGlvblRvRXZlbnREZWYiLCJhcHBseU11dGF0aW9uVG9FdmVudEluc3RhbmNlIiwiZXZlbnRDb25maWciLCJzdGFuZGFyZFByb3BzIiwic3RhcnREZWx0YSIsImVuZERlbHRhIiwiY29weSIsImFwcGxpZXIiLCJldmVudERlZk11dGF0aW9uQXBwbGllcnMiLCJldmVudEluc3RhbmNlIiwiZm9yY2VBbGxEYXkiLCJjbGVhckVuZCIsImRhdGVzRGVsdGEiLCJFdmVudFNvdXJjZUltcGwiLCJpbnRlcm5hbEV2ZW50U291cmNlIiwicmVmZXRjaCIsInNvdXJjZUlkcyIsImlzUmVmZXRjaCIsIkV2ZW50SW1wbCIsInNldFByb3AiLCJ3YXJuIiwibXV0YXRlIiwic2V0RXh0ZW5kZWRQcm9wIiwic2V0U3RhcnQiLCJfY29udGV4dCIsIl9pbnN0YW5jZSIsImluc3RhbmNlUmFuZ2UiLCJncmFudWxhcml0eSIsIm1haW50YWluRHVyYXRpb24iLCJzZXRFbmQiLCJlbmRJbnB1dCIsInNldERhdGVzIiwibW92ZVN0YXJ0IiwiZGVsdGFJbnB1dCIsImRlbHRhIiwibW92ZUVuZCIsIm1vdmVEYXRlcyIsInNldEFsbERheSIsIl9kZWYiLCJmb3JtYXRJbnB1dCIsInJlbGV2YW50RXZlbnRzIiwib2xkRXZlbnQiLCJyZWxhdGVkRXZlbnRzIiwiYnVpbGRFdmVudEFwaXMiLCJyZXZlcnQiLCJhc1N0b3JlIiwiZXZlbnRBcGlUb1N0b3JlIiwic291cmNlIiwic3RhcnRTdHIiLCJmb3JtYXRJc28iLCJvbWl0VGltZSIsImVuZFN0ciIsInRvUGxhaW5PYmplY3QiLCJzZXR0aW5ncyIsImNvbGxhcHNlQ29sb3IiLCJjb2xsYXBzZUV4dGVuZGVkUHJvcHMiLCJ0b0pTT04iLCJldmVudEFwaSIsImV4Y2x1ZGVJbnN0YW5jZSIsImV2ZW50QXBpcyIsImV4Y2x1ZGVJbnN0YW5jZUlkIiwic2xpY2VFdmVudFN0b3JlIiwiaW52ZXJzZUJnQnlHcm91cElkIiwiaW52ZXJzZUJnQnlEZWZJZCIsImRlZkJ5R3JvdXBJZCIsImJnUmFuZ2VzIiwiZmdSYW5nZXMiLCJldmVudFVpcyIsIm9yaWdSYW5nZSIsIm5vcm1hbFJhbmdlIiwic2xpY2VkUmFuZ2UiLCJpc1N0YXJ0IiwiaXNFbmQiLCJpbnZlcnRlZFJhbmdlIiwiYmciLCJmZyIsImhhc0JnUmVuZGVyaW5nIiwic2V0RWxTZWciLCJzZWciLCJmY1NlZyIsImdldEVsU2VnIiwiZXZlbnREZWZzIiwiY29tcGlsZUV2ZW50VWkiLCJzb3J0RXZlbnRTZWdzIiwic2VncyIsImV2ZW50T3JkZXJTcGVjcyIsIm9ianMiLCJidWlsZFNlZ0NvbXBhcmVPYmoiLCJfc2VnIiwiZXZlbnRSYW5nZSIsImNvbXB1dGVTZWdEcmFnZ2FibGUiLCJ0cmFuc2Zvcm1lcnMiLCJpc0RyYWdnYWJsZVRyYW5zZm9ybWVycyIsInRyYW5zZm9ybWVyIiwiY29tcHV0ZVNlZ1N0YXJ0UmVzaXphYmxlIiwiY29tcHV0ZVNlZ0VuZFJlc2l6YWJsZSIsImJ1aWxkU2VnVGltZVRleHQiLCJ0aW1lRm9ybWF0IiwiZGVmYXVsdERpc3BsYXlFdmVudFRpbWUiLCJkZWZhdWx0RGlzcGxheUV2ZW50RW5kIiwic3RhcnRPdmVycmlkZSIsImVuZE92ZXJyaWRlIiwid2hvbGVFdmVudFN0YXJ0Iiwid2hvbGVFdmVudEVuZCIsInNlZ1N0YXJ0Iiwic2VnRW5kIiwiaXNTdGFydERheSIsImlzRW5kRGF5IiwiZ2V0U2VnTWV0YSIsInNlZ1JhbmdlIiwiZ2V0RXZlbnRDbGFzc05hbWVzIiwiaXNNaXJyb3IiLCJpc0RyYWdnYWJsZSIsImlzU3RhcnRSZXNpemFibGUiLCJpc0VuZFJlc2l6YWJsZSIsImlzRHJhZ2dpbmciLCJpc1Jlc2l6aW5nIiwiaXNTZWxlY3RlZCIsImJ1aWxkRXZlbnRSYW5nZUtleSIsImdldFNlZ0FuY2hvckF0dHJzIiwiaHJlZiIsIlNUQU5EQVJEX1BST1BTIiwicGFyc2VEYXRlU3BhbiIsImRlZmF1bHREdXJhdGlvbiIsInNwYW4iLCJwYXJzZU9wZW5EYXRlU3BhbiIsImlzRGF0ZVNwYW5zRXF1YWwiLCJzcGFuMCIsInNwYW4xIiwiaXNTcGFuUHJvcHNFcXVhbCIsImJ1aWxkUmFuZ2VBcGkiLCJidWlsZFJhbmdlQXBpV2l0aFRpbWVab25lIiwiZmFicmljYXRlRXZlbnRSYW5nZSIsImNhbGVuZGFyU3lzdGVtQ2xhc3NNYXAiLCJyZWdpc3RlckNhbGVuZGFyU3lzdGVtIiwidGhlQ2xhc3MiLCJjcmVhdGVDYWxlbmRhclN5c3RlbSIsIkdyZWdvcmlhbkNhbGVuZGFyU3lzdGVtIiwiYXJyYXlUb01hcmtlciIsImFyciIsIklTT19SRSIsIkRhdGVFbnYiLCJjYW5Db21wdXRlT2Zmc2V0IiwidGltZXN0YW1wVG9NYXJrZXIiLCJnZXRZZWFyIiwiZ2V0RGF5IiwiYWRkWWVhcnMiLCJhZGRNb250aHMiLCJjb3VudER1cmF0aW9uc0JldHdlZW4iLCJkaWZmIiwic3RhcnRPZlllYXIiLCJzdGFydE9mTW9udGgiLCJzdGFydE9mV2VlayIsIndlZWtEb3ciLCJ3ZWVrTnVtYmVyRnVuYyIsIndlZWtEb3kiLCJkYXRlT3B0aW9ucyIsIm9mZnNldEZvck1hcmtlciIsImlzRW5kRXhjbHVzaXZlIiwiZXh0cmFPcHRpb25zIiwib21pdFRpbWVab25lT2Zmc2V0IiwibmFtZWRUaW1lWm9uZUltcGwiLCJ0aW1lc3RhbXBUb0FycmF5IiwiZ2V0VGltZXpvbmVPZmZzZXQiLCJvZmZzZXRGb3JBcnJheSIsImlzTmFtZWRUaW1lWm9uZSIsIk5hbWVkVGltZVpvbmVJbXBsIiwiU2VnSGllcmFyY2h5IiwiYWRkU2VncyIsImlucHV0cyIsImhpZGRlbkVudHJpZXMiLCJpbnNlcnRFbnRyeSIsImVudHJ5IiwiZmluZEluc2VydGlvbiIsImlzSW5zZXJ0aW9uVmFsaWQiLCJpbnNlcnRFbnRyeUF0IiwiaGFuZGxlSW52YWxpZEluc2VydGlvbiIsIm1heENvb3JkIiwibGV2ZWxDb29yZCIsInRoaWNrbmVzcyIsIm1heFN0YWNrQ250Iiwic3RhY2tDbnQiLCJhbGxvd1Jlc2xpY2luZyIsInRvdWNoaW5nRW50cnkiLCJzcGxpdEVudHJ5IiwiYmFycmllciIsInBhcnRDbnQiLCJzcGxpdEhpZGRlbkVudHJpZXMiLCJlbnRyeVNwYW4iLCJiYXJyaWVyU3BhbiIsImludGVyc2VjdFNwYW5zIiwiZW50cmllc0J5TGV2ZWwiLCJsZXZlbENvb3JkcyIsImxhdGVyYWwiLCJpbnNlcnRBdCIsImxldmVsIiwic3RhY2tDbnRzIiwiYnVpbGRFbnRyeUtleSIsIm5ld0VudHJ5Iiwic3RyaWN0T3JkZXIiLCJsZXZlbENudCIsImNhbmRpZGF0ZUNvb3JkIiwidG91Y2hpbmdMZXZlbCIsInRvdWNoaW5nTGF0ZXJhbCIsInRyYWNraW5nTGV2ZWwiLCJ0cmFja2luZ0Nvb3JkIiwidHJhY2tpbmdFbnRyaWVzIiwidHJhY2tpbmdFbnRyeSIsInNlYXJjaFJlcyIsImJpbmFyeVNlYXJjaCIsImdldEVudHJ5U3BhbkVuZCIsImxhdGVyYWxJbmRleCIsInRyYWNraW5nRW50cnlCb3R0b20iLCJkZXN0TGV2ZWwiLCJkZXN0TGF0ZXJhbCIsInRvUmVjdHMiLCJyZWN0cyIsImVudHJpZXMiLCJncm91cEludGVyc2VjdGluZ0VudHJpZXMiLCJtZXJnZXMiLCJmaWx0ZXJlZE1lcmdlcyIsImh1bmdyeU1lcmdlIiwibWVyZ2UiLCJqb2luU3BhbnMiLCJzZWFyY2hWYWwiLCJnZXRJdGVtVmFsIiwibWlkZGxlSW5kZXgiLCJtaWRkbGVWYWwiLCJJbnRlcmFjdGlvbiIsImRlc3Ryb3kiLCJpc0hpdENvbWJvQWxsb3dlZCIsInBhcnNlSW50ZXJhY3Rpb25TZXR0aW5ncyIsInVzZUV2ZW50Q2VudGVyIiwiaW50ZXJhY3Rpb25TZXR0aW5nc1RvU3RvcmUiLCJpbnRlcmFjdGlvblNldHRpbmdzU3RvcmUiLCJFbGVtZW50RHJhZ2dpbmciLCJzZXRNaXJyb3JJc1Zpc2libGUiLCJib29sIiwic2V0TWlycm9yTmVlZHNSZXZlcnQiLCJzZXRBdXRvU2Nyb2xsRW5hYmxlZCIsImNvbmZpZyIsIkRSQUdfTUVUQV9SRUZJTkVSUyIsInBhcnNlRHJhZ01ldGEiLCJsZWZ0b3ZlclByb3BzIiwiQ2FsZW5kYXJSb290IiwiZm9yUHJpbnQiLCJpc0hlaWdodEF1dG8iLCJoYW5kbGVCZWZvcmVQcmludCIsImhhbmRsZUFmdGVyUHJpbnQiLCJjb21wdXRlRmFsbGJhY2tIZWFkZXJGb3JtYXQiLCJkYXRlc1JlcERpc3RpbmN0RGF5cyIsIkNMQVNTX05BTUUiLCJyZW5kZXJJbm5lciQxIiwicmVuZGVyUHJvcHMiLCJ0ZXh0IiwiQ29udGVudEluamVjdG9yIiwiY3VzdG9tR2VuZXJhdG9yIiwiZGVmYXVsdEdlbmVyYXRvciIsImF0dHJzIiwiYnVpbGRFbEF0dHJzIiwidXNlRGVmYXVsdCIsImlubmVyQ29udGVudCIsInF1ZXVlZERvbU5vZGVzIiwiY3VycmVudEdlbmVyYXRvck1ldGEiLCJjdXN0b21HZW5lcmF0b3JSZXMiLCJpc09iamVjdCIsImh0bWwiLCJkb21Ob2RlcyIsImhhc0N1c3RvbVJlbmRlcmluZ0hhbmRsZXIiLCJnZW5lcmF0b3JOYW1lIiwiZWxUYWciLCJhcHBseVF1ZXVldWREb21Ob2RlcyIsInRyaWdnZXJDdXN0b21SZW5kZXJpbmciLCJpc0FjdGl2ZSIsImdlbmVyYXRvck1ldGEiLCJjb250YWluZXJFbCIsInJlcG9ydE5ld0NvbnRhaW5lckVsIiwiaGFuZGxlRWwiLCJlbENsYXNzZXMiLCJpc1RydXRoeSIsImN1cnJlbnREb21Ob2RlcyIsIm5ld05vZGUiLCJlbFJlZiIsImVsU3R5bGUiLCJlbEF0dHJzIiwiZXh0cmFDbGFzc05hbWVzIiwiUmVuZGVySWQiLCJDb250ZW50Q29udGFpbmVyIiwiZ2VuZXJhdGVkQ2xhc3NOYW1lcyIsImdlbmVyYXRlQ2xhc3NOYW1lcyIsImNsYXNzTmFtZUdlbmVyYXRvciIsIklubmVyQ29udGVudCIsImhhbmRsZVJvb3RFbCIsInJlbmRlcklkIiwicm9vdEVsIiwiSW5uZXJDb250ZW50SW5qZWN0b3IiLCJjb250YWluZXJDb21wb25lbnQiLCJwYXJlbnRQcm9wcyIsIlRhYmxlRGF0ZUNlbGwiLCJkYXlNZXRhIiwibmF2TGlua0F0dHJzIiwiY29sQ250IiwiZXh0cmFSZW5kZXJQcm9wcyIsInJvbGUiLCJjb2xTcGFuIiwiZXh0cmFEYXRhQXR0cnMiLCJJbm5lckNvbnRhaW5lciIsImlzU3RpY2t5IiwiV0VFS0RBWV9GT1JNQVQiLCJUYWJsZURvd0NlbGwiLCJkYXRlTWV0YSIsIk5vd1RpbWVyIiwicHJldlByb3BzIiwiY29tcHV0ZVRpbWluZyIsInVucm91bmRlZE5vdyIsImluaXRpYWxOb3dEYXRlIiwiaW5pdGlhbE5vd1F1ZXJpZWRNcyIsImN1cnJlbnRVbml0U3RhcnQiLCJuZXh0VW5pdFN0YXJ0Iiwid2FpdE1zIiwiY3VycmVudFN0YXRlIiwiYnVpbGREYXlSYW5nZSIsInRpbWVvdXRJZCIsIkRheUhlYWRlciIsImRhdGVzIiwicmVuZGVySW50cm8iLCJjcmVhdGVEYXlIZWFkZXJGb3JtYXR0ZXIiLCJleHBsaWNpdEZvcm1hdCIsImRhdGVDbnQiLCJEYXlTZXJpZXNNb2RlbCIsInNsaWNlUmFuZ2UiLCJmaXJzdEluZGV4IiwiZ2V0RGF0ZURheUluZGV4IiwibGFzdEluZGV4IiwiY2xpcHBlZEZpcnN0SW5kZXgiLCJjbGlwcGVkTGFzdEluZGV4IiwiY250IiwiY2VpbCIsImluZGljZXMiLCJkYXlPZmZzZXQiLCJkYXlJbmRleCIsIkRheVRhYmxlTW9kZWwiLCJidWlsZENlbGxzIiwicm93cyIsInJvdyIsInJvd0NudCIsImNlbGxzIiwiY29sIiwiYnVpbGRDZWxsIiwiZGF5U2VyaWVzIiwiYnVpbGRIZWFkZXJEYXRlcyIsInNlcmllc1NlZyIsIm5leHRJbmRleCIsImZpcnN0Q29sIiwibGFzdENvbCIsImJyZWFrT25XZWVrcyIsImRheXNQZXJSb3ciLCJoZWFkZXJEYXRlcyIsIlNsaWNlciIsInNsaWNlUHJvcHMiLCJleHRyYUFyZ3MiLCJldmVudFNlZ3MiLCJkYXRlU2VsZWN0aW9uU2VncyIsInNsaWNlRGF0ZVNlbGVjdGlvbiIsImJ1c2luZXNzSG91clNlZ3MiLCJzbGljZUJ1c2luZXNzSG91cnMiLCJmZ0V2ZW50U2VncyIsImJnRXZlbnRTZWdzIiwic2xpY2VFdmVudERyYWciLCJzbGljZUV2ZW50UmVzaXplIiwic2xpY2VOb3dEYXRlIiwiX3NsaWNlRGF0ZVNwYW4iLCJfc2xpY2VCdXNpbmVzc0hvdXJzIiwiX3NsaWNlRXZlbnRTdG9yZSIsImNvbXB1dGVBY3RpdmVSYW5nZSIsInJhbmdlUmVzIiwic2xpY2VFdmVudFJhbmdlcyIsIl9zbGljZUludGVyYWN0aW9uIiwiYWZmZWN0ZWRJbnN0YW5jZXMiLCJhY3RpdmVEYXRlU3BhblJhbmdlIiwiZXZlbnRSYW5nZXMiLCJzbGljZUV2ZW50UmFuZ2UiLCJmb3JjZURheUlmTGlzdEl0ZW0iLCJpc0NvbXBvbmVudEFsbERheSIsInJlZHVjZUV2ZW50U3RvcmUiLCJyZWNlaXZlUmF3RXZlbnRzIiwiZmV0Y2hJZCIsImZldGNoUmFuZ2UiLCJyZXNldFJhd0V2ZW50cyIsImFkZEV2ZW50IiwiZXhjbHVkZUV2ZW50c0J5U291cmNlSWQiLCJsYXRlc3RGZXRjaElkIiwic3Vic2V0IiwidHJhbnNmb3JtUmF3RXZlbnRzIiwiZXhpc3RpbmdFdmVudFN0b3JlIiwiYnVpbGRQdWJsaWNJZE1hcHMiLCJuZXdFdmVudFN0b3JlIiwiY2FsRWFjaFRyYW5zZm9ybSIsInNvdXJjZUVhY2hUcmFuc2Zvcm0iLCJ0cmFuc2Zvcm1FYWNoUmF3RXZlbnQiLCJyZWZpbmVkRXZlbnRzIiwicmVmaW5lZEV2ZW50IiwiZXhwYW5kUmFuZ2UiLCJyZXpvbmVFdmVudFN0b3JlRGF0ZXMiLCJvbGREYXRlRW52IiwibmV3RGF0ZUVudiIsImV4Y2x1ZGVJbnN0YW5jZXMiLCJyZW1vdmFscyIsImlzSW50ZXJhY3Rpb25WYWxpZCIsImlzTmV3UHJvcHNWYWxpZCIsImlzRGF0ZVNlbGVjdGlvblZhbGlkIiwiY2FsZW5kYXJTdGF0ZSIsImlzUHJvcHNWYWxpZCIsImRhdGVTcGFuTWV0YSIsImZpbHRlckNvbmZpZyIsImlzSW50ZXJhY3Rpb25Qcm9wc1ZhbGlkIiwiaXNEYXRlU2VsZWN0aW9uUHJvcHNWYWxpZCIsInN1YmplY3RFdmVudFN0b3JlIiwic3ViamVjdERlZnMiLCJzdWJqZWN0SW5zdGFuY2VzIiwic3ViamVjdENvbmZpZ3MiLCJzZWxlY3Rpb25Db25maWciLCJvdGhlckV2ZW50U3RvcmUiLCJvdGhlckRlZnMiLCJvdGhlckluc3RhbmNlcyIsIm90aGVyQ29uZmlncyIsInN1YmplY3RJbnN0YW5jZUlkIiwic3ViamVjdEluc3RhbmNlIiwic3ViamVjdFJhbmdlIiwic3ViamVjdENvbmZpZyIsInN1YmplY3REZWYiLCJhbGxDb25zdHJhaW50c1Bhc3MiLCJldmVudE92ZXJsYXBGdW5jIiwib3RoZXJJbnN0YW5jZUlkIiwib3RoZXJJbnN0YW5jZSIsIm90aGVyT3ZlcmxhcCIsImNhbGVuZGFyRXZlbnRTdG9yZSIsInN1YmplY3RBbGxvdyIsInN1YmplY3REYXRlU3BhbiIsIm9yaWdEZWYiLCJvcmlnSW5zdGFuY2UiLCJyZWxldmFudEV2ZW50U3RvcmUiLCJyZWxldmFudERlZnMiLCJyZWxldmFudEluc3RhbmNlcyIsInNlbGVjdGlvblJhbmdlIiwic2VsZWN0T3ZlcmxhcEZ1bmMiLCJyZWxldmFudEluc3RhbmNlSWQiLCJyZWxldmFudEluc3RhbmNlIiwic2VsZWN0aW9uQWxsb3ciLCJmdWxsRGF0ZVNwYW4iLCJidXNpbmVzc0hvdXJzVW5leHBhbmRlZCIsImFueVJhbmdlc0NvbnRhaW5SYW5nZSIsImNvbnN0cmFpbnRUb1JhbmdlcyIsImV2ZW50U3RvcmVUb1JhbmdlcyIsIm91dGVyUmFuZ2VzIiwiSnNvblJlcXVlc3RFcnJvciIsIm1lc3NhZ2UiLCJyZXNwb25zZSIsInJlcXVlc3RKc29uIiwicGFyYW1zIiwidG9VcHBlckNhc2UiLCJmZXRjaE9wdGlvbnMiLCJVUkxTZWFyY2hQYXJhbXMiLCJoZWFkZXJzIiwiZmV0Y2giLCJmZXRjaFJlcyIsIm9rIiwianNvbiIsInBhcnNlZFJlc3BvbnNlIiwiRGVsYXllZFJ1bm5lciIsImRlbGF5IiwiaXNEaXJ0eSIsImlzUGF1c2VkIiwidHJ5RHJhaW4iLCJwYXVzZSIsInNjb3BlIiwicGF1c2VEZXB0aHMiLCJyZXN1bWUiLCJmb3JjZSIsImRlcHRoIiwiaXNSdW5uaW5nIiwiZHJhaW5lZCIsImNsZWFyIiwiZHJhaW5lZE9wdGlvbiIsIlZJU0lCTEVfSElEREVOX1JFIiwiU2Nyb2xsZXIiLCJsaXF1aWQiLCJsaXF1aWRJc0Fic29sdXRlIiwiaXNBYnNvbHV0ZSIsIm92ZXJjb21lTGVmdCIsIm92ZXJjb21lUmlnaHQiLCJvdmVyY29tZUJvdHRvbSIsIm1hcmdpbkxlZnQiLCJtYXJnaW5SaWdodCIsIm1hcmdpbkJvdHRvbSIsIm1heEhlaWdodCIsIm5lZWRzWFNjcm9sbGluZyIsInJlYWxDbGllbnRXaWR0aCIsImdldFlTY3JvbGxiYXJXaWR0aCIsImNoaWxkRWwiLCJuZWVkc1lTY3JvbGxpbmciLCJyZWFsQ2xpZW50SGVpZ2h0IiwiZ2V0WFNjcm9sbGJhcldpZHRoIiwiUmVmTWFwIiwiY3JlYXRlUmVmIiwicmVmQ2FsbGJhY2siLCJjYWxsYmFja01hcCIsImhhbmRsZVZhbHVlIiwiY29sbGVjdCIsImN1cnJlbnRNYXAiLCJnZXRBbGwiLCJtYXN0ZXJDYWxsYmFjayIsImRlcHRocyIsInJlbW92ZWQiLCJhZGRlZCIsImNvbXB1dGVTaHJpbmtXaWR0aCIsImNodW5rRWxzIiwic2hyaW5rQ2VsbHMiLCJsYXJnZXN0V2lkdGgiLCJzaHJpbmtDZWxsIiwiZ2V0U2VjdGlvbkhhc0xpcXVpZEhlaWdodCIsInNlY3Rpb25Db25maWciLCJnZXRBbGxvd1lTY3JvbGxpbmciLCJyZW5kZXJDaHVua0NvbnRlbnQiLCJjaHVua0NvbmZpZyIsImlzSGVhZGVyIiwidGFibGVDbGFzc05hbWUiLCJzeW5jUm93SGVpZ2h0cyIsIm1pbldpZHRoIiwidGFibGVNaW5XaWR0aCIsInRhYmxlQ29sR3JvdXBOb2RlIiwicm93Q29udGVudCIsImlzQ29sUHJvcHNFcXVhbCIsImNvbHMwIiwiY29sczEiLCJyZW5kZXJNaWNyb0NvbEdyb3VwIiwiY29scyIsInNocmlua1dpZHRoIiwiY29sTm9kZXMiLCJjb2xQcm9wcyIsInNhbml0aXplU2hyaW5rV2lkdGgiLCJoYXNTaHJpbmtXaWR0aCIsImdldFNjcm9sbEdyaWRDbGFzc05hbWVzIiwiZ2V0U2VjdGlvbkNsYXNzTmFtZXMiLCJ3aG9sZVRhYmxlVkdyb3ciLCJyZW5kZXJTY3JvbGxTaGltIiwiZ2V0U3RpY2t5SGVhZGVyRGF0ZXMiLCJnZXRTdGlja3lGb290ZXJTY3JvbGxiYXIiLCJTaW1wbGVTY3JvbGxHcmlkIiwic2VjdGlvbkNvbmZpZ3MiLCJzZWN0aW9ucyIsInByb2Nlc3NDb2xzIiwibWljcm9Db2xHcm91cE5vZGUiLCJjb2xsYXBzaWJsZVdpZHRoIiwiY29uZmlnQ250IiwiY29uZmlnSSIsImN1cnJlbnRDb25maWciLCJoZWFkU2VjdGlvbk5vZGVzIiwiYm9keVNlY3Rpb25Ob2RlcyIsImZvb3RTZWN0aW9uTm9kZXMiLCJyZW5kZXJTZWN0aW9uIiwiaXNCdWdneSIsInJvbGVBdHRycyIsIm91dGVyQ29udGVudCIsInJlbmRlckNodW5rVGQiLCJjaHVuayIsImZvcmNlWVNjcm9sbGJhcnMiLCJzY3JvbGxlckNsaWVudFdpZHRocyIsInNjcm9sbGVyQ2xpZW50SGVpZ2h0cyIsImlzTGlxdWlkIiwic2VjdGlvbktleSIsInJvd1N5bmNIZWlnaHRzIiwicmVwb3J0Um93SGVpZ2h0Q2hhbmdlIiwic2Nyb2xsZXJSZWZzIiwic2Nyb2xsZXJFbFJlZnMiLCJfaGFuZGxlU2Nyb2xsZXJFbCIsInNjcm9sbGVyRWwiLCJzZWN0aW9uIiwiZ2V0U2VjdGlvbkJ5S2V5Iiwic2Nyb2xsZXJFbFJlZiIsImhhbmRsZVNpemluZyIsImNvbXB1dGVTY3JvbGxlckRpbXMiLCJzY3JvbGxiYXJXaWR0aCIsInNjcm9sbGVyIiwiaGFybmVzc0VsIiwiRXZlbnRDb250YWluZXIiLCJ0aW1lVGV4dCIsImRpc2FibGVEcmFnZ2luZyIsImRpc2FibGVSZXNpemluZyIsImlzRGF0ZVNlbGVjdGluZyIsIlN0YW5kYXJkRXZlbnQiLCJkZWZhdWx0VGltZUZvcm1hdCIsInJlbmRlcklubmVyQ29udGVudCQxJDEiLCJldmVudENvbnRlbnRBcmciLCJpbm5lclByb3BzIiwiTm93SW5kaWNhdG9yQ29udGFpbmVyIiwiaXNBeGlzIiwiREFZX05VTV9GT1JNQVQiLCJEYXlDZWxsQ29udGFpbmVyIiwicmVmaW5lUmVuZGVyUHJvcHMiLCJpc01vbnRoU3RhcnQiLCJzaG93RGF5TnVtYmVyIiwiaGFzQ3VzdG9tRGF5Q2VsbENvbnRlbnQiLCJkYXlOdW1iZXJUZXh0IiwiQmdFdmVudCIsInJlbmRlcklubmVyQ29udGVudCQzIiwicmVuZGVyRmlsbCIsImZpbGxUeXBlIiwiV2Vla051bWJlckNvbnRhaW5lciIsImRlZmF1bHRGb3JtYXQiLCJyZW5kZXJJbm5lciIsIlBBRERJTkdfRlJPTV9WSUVXUE9SVCIsIlBvcG92ZXIiLCJleHRyYUF0dHJzIiwidGl0bGVJZCIsImhhbmRsZUNsb3NlQ2xpY2siLCJoYW5kbGVEb2N1bWVudE1vdXNlRG93biIsImhhbmRsZURvY3VtZW50S2V5RG93biIsInVwZGF0ZVNpemUiLCJhbGlnbm1lbnRFbCIsImFsaWduR3JpZFRvcCIsImFsaWdubWVudFJlY3QiLCJwb3BvdmVyRGltcyIsInBvcG92ZXJUb3AiLCJwb3BvdmVyTGVmdCIsIm9yaWdpbiIsIm9mZnNldFBhcmVudCIsIm9uQ2xvc2UiLCJNb3JlUG9wb3ZlciIsInN0YXJ0RGF0ZSIsImZvcmNlVGltZWQiLCJlbmREYXRlIiwiZXh0cmFEYXRlU3BhbiIsImRheUVsIiwibGF5ZXIiLCJNb3JlTGlua0NvbnRhaW5lciIsIm1vcmVDbnQiLCJjb21wdXRlUmFuZ2UiLCJoaW50Iiwic2hvcnRUZXh0IiwiaGFuZGxlTGlua0VsIiwiaGFuZGxlQ2xpY2siLCJpc1BvcG92ZXJPcGVuIiwicG9wb3ZlcklkIiwicmVuZGVyTW9yZUxpbmtJbm5lciQxIiwiYWxpZ25tZW50RWxSZWYiLCJsaW5rRWwiLCJoYW5kbGVQb3BvdmVyQ2xvc2UiLCJwb3BvdmVyQ29udGVudCIsInVwZGF0ZVBhcmVudEVsIiwiYnVpbGRQdWJsaWNTZWciLCJhbGxEYXlEYXRlIiwiYWxsU2VncyIsImhpZGRlblNlZ3MiLCJjb21wdXRlRWFybGllc3RTZWdTdGFydCIsImNvbXB1dGVMYXRlc3RTZWdFbmQiLCJwaWNrRWFybGllc3RTdGFydCIsInNlZzAiLCJzZWcxIiwicGlja0xhdGVzdEVuZCIsIlZpZXdDb250YWluZXIiLCJidWlsZFZpZXdDbGFzc05hbWVzIiwiRVZFTlRfU09VUkNFX1JFRklORVJTIiwic3VjY2VzcyIsImZhaWx1cmUiLCJwYXJzZUV2ZW50U291cmNlIiwiYnVpbGRFdmVudFNvdXJjZVJlZmluZXJzIiwicmF3T2JqIiwibWV0YVJlcyIsImJ1aWxkRXZlbnRTb3VyY2VNZXRhIiwiX3JhdyIsImlzRmV0Y2hpbmciLCJzb3VyY2VEZWZJZCIsImV2ZW50U291cmNlUmVmaW5lcnMiLCJldmVudFNvdXJjZURlZnMiLCJwYXJzZU1ldGEiLCJDYWxlbmRhckltcGwiLCJjdXJyZW50RGF0YU1hbmFnZXIiLCJiYXRjaFJlbmRlcmluZyIsInNldE9wdGlvbiIsIm9wdGlvbk5hbWUiLCJyYXdPcHRpb25WYWx1ZSIsImdldE9wdGlvbiIsImN1cnJlbnRDYWxlbmRhck9wdGlvbnNJbnB1dCIsImdldEF2YWlsYWJsZUxvY2FsZUNvZGVzIiwiYXZhaWxhYmxlUmF3TG9jYWxlcyIsImhhbmRsZXJOYW1lIiwiY3VycmVudENhbGVuZGFyT3B0aW9uc1JlZmluZXJzIiwiY2hhbmdlVmlldyIsImRhdGVPclJhbmdlIiwic3BlYyIsInZpZXdTcGVjcyIsImdldFVuaXRWaWV3U3BlYyIsInRvb2xiYXJDb25maWciLCJ2aWV3VHlwZXMiLCJoZWFkZXIiLCJ2aWV3c1dpdGhCdXR0b25zIiwiZm9vdGVyIiwic2luZ2xlVW5pdCIsInByZXYiLCJuZXh0IiwicHJldlllYXIiLCJuZXh0WWVhciIsInRvZGF5IiwiZ290b0RhdGUiLCJ6b25lZERhdGVJbnB1dCIsImluY3JlbWVudERhdGUiLCJmb3JtYXREYXRlIiwiZGF0ZU9yT2JqIiwic2VsZWN0aW9uSW5wdXQiLCJldmVudElucHV0Iiwic291cmNlSW5wdXQiLCJjdXJyZW50RGF0YSIsInRyaWdnZXJFdmVudEFkZCIsInNvdXJjZUFwaSIsImdldEV2ZW50U291cmNlQnlJZCIsIm5ld0V2ZW50QXBpIiwiZ2V0RXZlbnRCeUlkIiwiZ2V0RXZlbnRzIiwicmVtb3ZlQWxsRXZlbnRzIiwiZ2V0RXZlbnRTb3VyY2VzIiwic291cmNlSGFzaCIsInNvdXJjZUFwaXMiLCJpbnRlcm5hbElkIiwiYWRkRXZlbnRTb3VyY2UiLCJzb3VyY2VzIiwicmVtb3ZlQWxsRXZlbnRTb3VyY2VzIiwicmVmZXRjaEV2ZW50cyIsInNjcm9sbFRvVGltZSIsInRpbWVJbnB1dCIsIlN0b3JlIiwiY3VycmVudFZhbHVlIiwic3Vic2NyaWJlIiwiQ3VzdG9tUmVuZGVyaW5nU3RvcmUiLCJoYW5kbGUiLCJjdXN0b21SZW5kZXJpbmciLCJ1cGRhdGVkIiwiaGFzIiwiaW50ZXJuYWwiLCJfX3Byb3RvX18iLCJwYXJzZU1hcmtlciIsInByZWFjdCIsImNyZWF0ZVBvcnRhbCIsIkNvbXBvbmVudCIsIkZyYWdtZW50IiwiY2xvbmVFbGVtZW50IiwiaHlkcmF0ZSIsImlzVmFsaWRFbGVtZW50IiwidG9DaGlsZEFycmF5IiwiZ2xvYmFsTG9jYWxlcyIsIk1JTklNQUxfUkFXX0VOX0xPQ0FMRSIsImNvZGUiLCJsaXN0IiwiUkFXX0VOX0xPQ0FMRSIsImV2ZW50Q250Iiwib3JnYW5pemVSYXdMb2NhbGVzIiwiZXhwbGljaXRSYXdMb2NhbGVzIiwiZGVmYXVsdENvZGUiLCJhbGxSYXdMb2NhbGVzIiwicmF3TG9jYWxlTWFwIiwicmF3TG9jYWxlIiwiYnVpbGRMb2NhbGUiLCJpbnB1dFNpbmd1bGFyIiwiYXZhaWxhYmxlIiwicGFyc2VMb2NhbGUiLCJxdWVyeUxvY2FsZSIsImNvZGVBcmciLCJxdWVyeVJhd0xvY2FsZSIsInNpbXBsZUlkIiwibWVyZ2VkIiwiTnVtYmVyRm9ybWF0IiwiY3JlYXRlUGx1Z2luIiwicHJlbWl1bVJlbGVhc2VEYXRlIiwiZGVwcyIsInJlZHVjZXJzIiwiaXNMb2FkaW5nRnVuY3MiLCJjb250ZXh0SW5pdCIsImV2ZW50RHJhZ011dGF0aW9uTWFzc2FnZXJzIiwiZGF0ZVNlbGVjdGlvblRyYW5zZm9ybWVycyIsImRhdGVQb2ludFRyYW5zZm9ybXMiLCJ2aWV3UHJvcHNUcmFuc2Zvcm1lcnMiLCJleHRlcm5hbERlZlRyYW5zZm9ybXMiLCJ2aWV3Q29udGFpbmVyQXBwZW5kcyIsImV2ZW50RHJvcFRyYW5zZm9ybWVycyIsImNvbXBvbmVudEludGVyYWN0aW9ucyIsImNhbGVuZGFySW50ZXJhY3Rpb25zIiwidGhlbWVDbGFzc2VzIiwibmFtZWRUaW1lWm9uZWRJbXBsIiwiZWxlbWVudERyYWdnaW5nSW1wbCIsIm9wdGlvbkNoYW5nZUhhbmRsZXJzIiwic2Nyb2xsR3JpZEltcGwiLCJsaXN0ZW5lclJlZmluZXJzIiwib3B0aW9uUmVmaW5lcnMiLCJwcm9wU2V0SGFuZGxlcnMiLCJidWlsZFBsdWdpbkhvb2tzIiwicGx1Z2luRGVmcyIsImdsb2JhbERlZnMiLCJjdXJyZW50UGx1Z2luSWRzIiwiaG9va3MiLCJhZGREZWZzIiwicGx1Z2luTmFtZSIsImN1cnJlbnRJZCIsImNvbWJpbmVIb29rcyIsImJ1aWxkQnVpbGRQbHVnaW5Ib29rcyIsImN1cnJlbnRPdmVycmlkZURlZnMiLCJjdXJyZW50R2xvYmFsRGVmcyIsImN1cnJlbnRIb29rcyIsIm92ZXJyaWRlRGVmcyIsImhvb2tzMCIsImhvb2tzMSIsImNvbXBhcmVPcHRpb25hbERhdGVzIiwiU3RhbmRhcmRUaGVtZSIsInJvb3QiLCJ0YWJsZUNlbGxTaGFkZWQiLCJidXR0b25Hcm91cCIsImJ1dHRvbiIsImJ1dHRvbkFjdGl2ZSIsImNsb3NlIiwiY29tcGlsZVZpZXdEZWZzIiwiZGVmYXVsdENvbmZpZ3MiLCJvdmVycmlkZUNvbmZpZ3MiLCJlbnN1cmVWaWV3RGVmIiwidmlld0RlZiIsImJ1aWxkVmlld0RlZiIsImRlZmF1bHRDb25maWciLCJvdmVycmlkZUNvbmZpZyIsInF1ZXJ5UHJvcCIsInRoZUNvbXBvbmVudCIsInN1cGVyVHlwZSIsInN1cGVyRGVmIiwiZGVmYXVsdHMiLCJyYXdPcHRpb25zIiwib3ZlcnJpZGVzIiwicGFyc2VWaWV3Q29uZmlncyIsInBhcnNlVmlld0NvbmZpZyIsImNyZWF0ZVZpZXdIb29rQ29tcG9uZW50Iiwidmlld1Byb3BzIiwiYnVpbGRWaWV3U3BlY3MiLCJkZWZhdWx0SW5wdXRzIiwib3B0aW9uT3ZlcnJpZGVzIiwiZHluYW1pY09wdGlvbk92ZXJyaWRlcyIsImxvY2FsZURlZmF1bHRzIiwidmlld0RlZnMiLCJidWlsZFZpZXdTcGVjIiwiZHVyYXRpb25JbnB1dCIsInNpbmdsZVVuaXRPdmVycmlkZXMiLCJjcmVhdGVEdXJhdGlvbkNhY2hlZCIsImRlbm9tIiwicXVlcnlCdXR0b25UZXh0Iiwib3B0aW9uc1N1YnNldCIsImJ1dHRvblRleHRNYXAiLCJxdWVyeUJ1dHRvblRpdGxlIiwiYnV0dG9uS2V5Iiwib3B0aW9uRGVmYXVsdHMiLCJidXR0b25UZXh0T3ZlcnJpZGUiLCJidXR0b25UZXh0RGVmYXVsdCIsImJ1dHRvblRpdGxlT3ZlcnJpZGUiLCJidXR0b25IaW50IiwiYnV0dG9uVGl0bGVEZWZhdWx0IiwiZHVyYXRpb25JbnB1dE1hcCIsIkpTT04iLCJzdHJpbmdpZnkiLCJyZWR1Y2VWaWV3VHlwZSIsInJlZHVjZUR5bmFtaWNPcHRpb25PdmVycmlkZXMiLCJyZWR1Y2VEYXRlUHJvZmlsZSIsImRwIiwiaW5pdEV2ZW50U291cmNlcyIsImFkZFNvdXJjZXMiLCJwYXJzZUluaXRpYWxTb3VyY2VzIiwicmVkdWNlRXZlbnRTb3VyY2VzIiwicmVtb3ZlU291cmNlIiwiZmV0Y2hEaXJ0eVNvdXJjZXMiLCJmZXRjaFNvdXJjZXNCeUlkcyIsImV4Y2x1ZGVTdGF0aWNTb3VyY2VzIiwicmVjZWl2ZVJlc3BvbnNlIiwicmVkdWNlRXZlbnRTb3VyY2VzTmV3VGltZVpvbmUiLCJjb21wdXRlRXZlbnRTb3VyY2VzTG9hZGluZyIsImV2ZW50U291cmNlSGFzaCIsImlzU291cmNlRGlydHkiLCJkb2VzU291cmNlTmVlZFJhbmdlIiwicHJldlNvdXJjZXMiLCJzb3VyY2VJZEhhc2giLCJuZXh0U291cmNlcyIsImZldGNoU291cmNlIiwic291cmNlRGVmIiwiZXJyb3JIYW5kbGVkIiwicmF3U291cmNlcyIsInJhd1NvdXJjZSIsImlnbm9yZVJhbmdlIiwicmVkdWNlRGF0ZVNlbGVjdGlvbiIsImN1cnJlbnRTZWxlY3Rpb24iLCJyZWR1Y2VTZWxlY3RlZEV2ZW50IiwiY3VycmVudEluc3RhbmNlSWQiLCJldmVudEluc3RhbmNlSWQiLCJyZWR1Y2VFdmVudERyYWciLCJjdXJyZW50RHJhZyIsIm5ld0RyYWciLCJyZWR1Y2VFdmVudFJlc2l6ZSIsImN1cnJlbnRSZXNpemUiLCJuZXdSZXNpemUiLCJwYXJzZVRvb2xiYXJzIiwiY2FsZW5kYXJPcHRpb25PdmVycmlkZXMiLCJwYXJzZVRvb2xiYXIiLCJzZWN0aW9uU3RySGFzaCIsInNlY3Rpb25XaWRnZXRzIiwiaGFzVGl0bGUiLCJzZWN0aW9uTmFtZSIsInNlY3Rpb25TdHIiLCJzZWN0aW9uUmVzIiwicGFyc2VTZWN0aW9uIiwid2lkZ2V0cyIsImNhbGVuZGFyQ3VzdG9tQnV0dG9ucyIsImNhbGVuZGFyQnV0dG9uVGV4dE92ZXJyaWRlcyIsImNhbGVuZGFyQnV0dG9uVGV4dCIsImNhbGVuZGFyQnV0dG9uSGludE92ZXJyaWRlcyIsImNhbGVuZGFyQnV0dG9uSGludHMiLCJzZWN0aW9uU3Vic3RycyIsImJ1dHRvbkdyb3VwU3RyIiwiYnV0dG9uQ2xpY2siLCJidXR0b25JY29uIiwiY2xpY2siLCJ0ZXh0RmFsbGJhY2siLCJwcmV2T3JOZXh0IiwibmF2VW5pdCIsIlZpZXdJbXBsIiwiY2FsZW5kYXIiLCJ2aWV3VGl0bGUiLCJhY3RpdmVTdGFydCIsImFjdGl2ZUVuZCIsImN1cnJlbnRTdGFydCIsImN1cnJlbnRFbmQiLCJldmVudFNvdXJjZURlZiQyIiwic3VjY2Vzc0NhbGxiYWNrIiwiYXJyYXlFdmVudFNvdXJjZVBsdWdpbiIsImV2ZW50U291cmNlRGVmJDEiLCJlcnJvckNhbGxiYWNrIiwiZnVuY0V2ZW50U291cmNlUGx1Z2luIiwiSlNPTl9GRUVEX0VWRU5UX1NPVVJDRV9SRUZJTkVSUyIsImV4dHJhUGFyYW1zIiwiZXZlbnRTb3VyY2VEZWYiLCJyZXF1ZXN0UGFyYW1zIiwiYnVpbGRSZXF1ZXN0UGFyYW1zIiwianNvbkZlZWRFdmVudFNvdXJjZVBsdWdpbiIsImN1c3RvbVJlcXVlc3RQYXJhbXMiLCJTSU1QTEVfUkVDVVJSSU5HX1JFRklORVJTIiwic3RhcnRSZWN1ciIsImVuZFJlY3VyIiwicmVjdXJyaW5nIiwicmVjdXJyaW5nRGF0YSIsImNsaXBwZWRGcmFtaW5nUmFuZ2UiLCJleHBhbmRSYW5nZXMiLCJzaW1wbGVSZWN1cnJpbmdFdmVudHNQbHVnaW4iLCJkb3dIYXNoIiwiZGF5TWFya2VyIiwiaW5zdGFuY2VTdGFydHMiLCJpbnN0YW5jZVN0YXJ0IiwiY2hhbmdlSGFuZGxlclBsdWdpbiIsImhhbmRsZUV2ZW50U291cmNlcyIsInVuZm91bmRTb3VyY2VzIiwibmV3SW5wdXRzIiwiaW5wdXRGb3VuZCIsInVuZm91bmRTb3VyY2UiLCJuZXdJbnB1dCIsImhhbmRsZURhdGVQcm9maWxlIiwiaGFuZGxlRXZlbnRTdG9yZSIsImdsb2JhbFBsdWdpbnMiLCJUYXNrUnVubmVyIiwidGFzayIsInF1ZXVlIiwiZGVsYXllZFJ1bm5lciIsImNvbXBsZXRlZFRhc2tzIiwicnVuVGFzayIsInJ1blRhc2tPcHRpb24iLCJidWlsZFRpdGxlIiwiYnVpbGRUaXRsZUZvcm1hdCIsIkNhbGVuZGFyRGF0YU1hbmFnZXIiLCJyZXNldE9wdGlvbnMiLCJjaGFuZ2VkT3B0aW9uTmFtZXMiLCJvcHRpb25zRm9yUmVmaW5pbmciLCJhY3Rpb25SdW5uZXIiLCJfaGFuZGxlQWN0aW9uIiwib3B0aW9uc0RhdGEiLCJjb21wdXRlT3B0aW9uc0RhdGEiLCJjdXJyZW50Vmlld1R5cGUiLCJjdXJyZW50Vmlld0RhdGEiLCJjb21wdXRlQ3VycmVudFZpZXdEYXRhIiwiY2FsZW5kYXJDb250ZXh0IiwiaXNFdmVudHNMb2FkaW5nIiwicmVuZGVyYWJsZUV2ZW50U3RvcmUiLCJldmVudFVpU2luZ2xlQmFzZSIsImJ1aWxkVmlld1VpUHJvcHMiLCJldmVudFVpQnlTb3VyY2UiLCJidWlsZEV2ZW50VWlCeVNvdXJjZSIsImJ1aWxkRXZlbnRVaUJhc2VzIiwicGFyc2VDb250ZXh0QnVzaW5lc3NIb3VycyIsImNvbnRleHRBbmRTdGF0ZSIsInJlZHVjZXIiLCJ3YXNMb2FkaW5nIiwiY29tcHV0ZUlzTG9hZGluZyIsImlzTG9hZGluZyIsIm9uQWN0aW9uIiwidXBkYXRlRGF0YSIsIm9sZERhdGEiLCJjaGFuZ2VIYW5kbGVycyIsIm9sZENhbGVuZGFyT3B0aW9ucyIsIm5ld0NhbGVuZGFyT3B0aW9ucyIsIm9wdGlvbnNGb3JIYW5kbGluZyIsIm9uRGF0YSIsInN0YWJsZU9wdGlvbk92ZXJyaWRlcyIsInN0YWJsZUR5bmFtaWNPcHRpb25PdmVycmlkZXMiLCJzdGFibGVDYWxlbmRhck9wdGlvbnNEYXRhIiwicmVmaW5lZE9wdGlvbnMiLCJhdmFpbGFibGVMb2NhbGVEYXRhIiwicHJvY2Vzc1Jhd0NhbGVuZGFyT3B0aW9ucyIsIndhcm5Vbmtub3duT3B0aW9ucyIsImJ1aWxkRGF0ZUVudiIsImJ1aWxkVGhlbWUiLCJjdXJyZW50UmF3IiwiY3VycmVudFJlZmluZWQiLCJjdXJyZW50Q2FsZW5kYXJPcHRpb25zUmVmaW5lZCIsImFueUNoYW5nZXMiLCJfY29tcHV0ZUN1cnJlbnRWaWV3RGF0YSIsInByb2Nlc3NSYXdWaWV3T3B0aW9ucyIsImJ1aWxkRGF0ZVByb2ZpbGVHZW5lcmF0b3IiLCJidWlsZFZpZXdBcGkiLCJjdXJyZW50Vmlld09wdGlvbnNJbnB1dCIsImN1cnJlbnRWaWV3T3B0aW9uc1JlZmluZWQiLCJidWlsZERhdGVFbnYkMSIsImluaXRpYWxTdGF0ZSIsImV4cGxpY2l0TG9jYWxlIiwiVGhlbWVDbGFzcyIsIkRhdGVQcm9maWxlR2VuZXJhdG9yQ2xhc3MiLCJpc0xvYWRpbmdGdW5jIiwidmlld05hbWUiLCJUb29sYmFyU2VjdGlvbiIsIndpZGdldEdyb3VwcyIsIndpZGdldEdyb3VwIiwicmVuZGVyV2lkZ2V0R3JvdXAiLCJpc09ubHlCdXR0b25zIiwid2lkZ2V0IiwiaXNQcmVzc2VkIiwiYWN0aXZlQnV0dG9uIiwiaXNUb2RheUVuYWJsZWQiLCJpc1ByZXZFbmFibGVkIiwiaXNOZXh0RW5hYmxlZCIsImJ1dHRvbkNsYXNzZXMiLCJkaXNhYmxlZCIsImdyb3VwQ2xhc3NOYW1lIiwiVG9vbGJhciIsIm1vZGVsIiwiZXh0cmFDbGFzc05hbWUiLCJmb3JjZUx0ciIsInN0YXJ0Q29udGVudCIsImVuZENvbnRlbnQiLCJjZW50ZXJDb250ZW50IiwiVmlld0hhcm5lc3MiLCJhdmFpbGFibGVXaWR0aCIsImxhYmVsZWRCeUlkIiwiaGFuZGxlUmVzaXplIiwidXBkYXRlQXZhaWxhYmxlV2lkdGgiLCJFdmVudENsaWNraW5nIiwiaGFuZGxlU2VnQ2xpY2siLCJzZWdFbCIsImhhc1VybENvbnRhaW5lciIsImxvY2F0aW9uIiwiRXZlbnRIb3ZlcmluZyIsInJlbW92ZUhvdmVyTGlzdGVuZXJzIiwidHJpZ2dlckV2ZW50IiwicHVibGljRXZOYW1lIiwiaGFuZGxlRXZlbnRFbFJlbW92ZSIsImN1cnJlbnRTZWdFbCIsImhhbmRsZVNlZ0xlYXZlIiwiaGFuZGxlU2VnRW50ZXIiLCJDYWxlbmRhckNvbnRlbnQiLCJ0b29sYmFyUHJvcHMiLCJidWlsZFRvb2xiYXJQcm9wcyIsInZpZXdWR3JvdyIsInZpZXdBc3BlY3RSYXRpbyIsInZpZXdDb250ZXh0Iiwidmlld0xhYmVsSWQiLCJoZWFkZXJSZWYiLCJyZW5kZXJWaWV3IiwiYnVpbGRBcHBlbmRDb250ZW50IiwiZm9vdGVyUmVmIiwiQ2FsZW5kYXJJbnRlcmFjdGlvbkNsYXNzIiwicmVzaXplUnVubmVyIiwiYnVpbGRWaWV3UHJvcFRyYW5zZm9ybWVycyIsIlZpZXdDb21wb25lbnQiLCJpbnRlcmFjdGlvbnNTdG9yZSIsInNldHRpbmdzSW5wdXQiLCJERUZBVUxUX0lOVEVSQUNUSU9OUyIsImludGVyYWN0aW9uQ2xhc3NlcyIsImludGVyYWN0aW9ucyIsIlRoZUludGVyYWN0aW9uQ2xhc3MiLCJsaXN0ZW5lcnMiLCJsaXN0ZW5lciIsInRvZGF5SW5mbyIsInByZXZJbmZvIiwibmV4dEluZm8iLCJ0aGVDbGFzc2VzIiwiVGhlQ2xhc3MiLCJDYWxlbmRhciIsIndhc1JlbmRlcmluZyIsImlzUmVuZGVyaW5nIiwiY3VzdG9tQ29udGVudFJlbmRlcklkIiwicmVuZGVyUnVubmVyIiwicGF1c2VSZW5kZXJpbmciLCJyZXN1bWVSZW5kZXJpbmciLCJzZXRDbGFzc05hbWVzIiwiY3VycmVudENsYXNzTmFtZXMiLCJzZXRIZWlnaHQiLCJpc1JlbmRlcmVkIiwiaGFuZGxlQWN0aW9uIiwiaGFuZGxlRGF0YSIsImhhbmRsZVJlbmRlclJlcXVlc3QiLCJkYXRlSW5wdXQiLCJzbGljZUV2ZW50cyIsInZlcnNpb24iLCJ0b3VjaE1vdXNlSWdub3JlV2FpdCIsImlnbm9yZU1vdXNlRGVwdGgiLCJsaXN0ZW5lckNudCIsImlzV2luZG93VG91Y2hNb3ZlQ2FuY2VsbGVkIiwiUG9pbnRlckRyYWdnaW5nIiwiaGFuZGxlTW91c2VEb3duIiwiaGFuZGxlVG91Y2hTdGFydCIsInBhc3NpdmUiLCJsaXN0ZW5lckRlc3Ryb3llZCIsInRyeVN0YXJ0Iiwic3ViamVjdEVsIiwicXVlcnlTdWJqZWN0RWwiLCJkb3duRWwiLCJoYW5kbGVTZWxlY3RvciIsIndhc1RvdWNoU2Nyb2xsIiwiY2xlYW51cCIsImRlc3Ryb3lTY3JvbGxXYXRjaCIsInNob3VsZElnbm9yZU1vdXNlIiwiaXNUb3VjaERyYWdnaW5nIiwiY2FuY2VsVG91Y2hTY3JvbGwiLCJpbml0U2Nyb2xsV2F0Y2giLCJzaG91bGRXYXRjaFNjcm9sbCIsInJlY29yZENvb3JkcyIsImhhbmRsZVNjcm9sbCIsInByZXZQYWdlWCIsInBhZ2VYIiwicHJldlBhZ2VZIiwicGFnZVkiLCJwcmV2U2Nyb2xsWCIsInByZXZTY3JvbGxZIiwiY3JlYXRlRXZlbnRGcm9tTW91c2UiLCJpc0ZpcnN0Iiwib3JpZ1BhZ2VYIiwib3JpZ1BhZ2VZIiwiaXNUb3VjaCIsImNyZWF0ZUV2ZW50RnJvbVRvdWNoIiwidG91Y2hlcyIsInNob3VsZElnbm9yZU1vdmUiLCJpc1ByaW1hcnlNb3VzZUJ1dHRvbiIsImhhbmRsZU1vdXNlTW92ZSIsImhhbmRsZU1vdXNlVXAiLCJ0YXJnZXRFbCIsImhhbmRsZVRvdWNoTW92ZSIsImhhbmRsZVRvdWNoRW5kIiwiaGFuZGxlVG91Y2hTY3JvbGwiLCJzdGFydElnbm9yaW5nTW91c2UiLCJsaXN0ZW5lckNyZWF0ZWQiLCJjdHJsS2V5Iiwib25XaW5kb3dUb3VjaE1vdmUiLCJFbGVtZW50TWlycm9yIiwic291cmNlRWwiLCJzb3VyY2VFbFJlY3QiLCJvcmlnU2NyZWVuWCIsIm9yaWdTY3JlZW5ZIiwidXBkYXRlRWxQb3NpdGlvbiIsImhhbmRsZU1vdmUiLCJzZXRJc1Zpc2libGUiLCJpc1Zpc2libGUiLCJtaXJyb3JFbCIsInN0b3AiLCJuZWVkc1JldmVydEFuaW1hdGlvbiIsImRvbmUiLCJyZXZlcnREdXJhdGlvbiIsImRvUmV2ZXJ0QW5pbWF0aW9uIiwiZmluYWxTb3VyY2VFbFJlY3QiLCJ0cmFuc2l0aW9uIiwiZ2V0TWlycm9yRWwiLCJjbG9uZU5vZGUiLCJ6SW5kZXgiLCJ2aXNpYmlsaXR5IiwiYm94U2l6aW5nIiwibWFyZ2luIiwiU2Nyb2xsR2VvbUNhY2hlIiwiZG9lc0xpc3RlbmluZyIsImdldEV2ZW50VGFyZ2V0Iiwic2Nyb2xsQ29udHJvbGxlciIsImhhbmRsZVNjcm9sbENoYW5nZSIsIm9yaWdTY3JvbGxUb3AiLCJvcmlnU2Nyb2xsTGVmdCIsImNsaWVudFJlY3QiLCJjb21wdXRlQ2xpZW50UmVjdCIsIkVsZW1lbnRTY3JvbGxHZW9tQ2FjaGUiLCJXaW5kb3dTY3JvbGxHZW9tQ2FjaGUiLCJnZXRUaW1lIiwicGVyZm9ybWFuY2UiLCJBdXRvU2Nyb2xsZXIiLCJzY3JvbGxTdGFydEVsIiwiaXNFbmFibGVkIiwic2Nyb2xsQ2FjaGVzIiwiYnVpbGRDYWNoZXMiLCJwb2ludGVyU2NyZWVuWCIsInBvaW50ZXJTY3JlZW5ZIiwiZXZlck1vdmVkVXAiLCJldmVyTW92ZWREb3duIiwiZXZlck1vdmVkTGVmdCIsImV2ZXJNb3ZlZFJpZ2h0IiwieURlbHRhIiwieERlbHRhIiwiaXNBbmltYXRpbmciLCJyZXF1ZXN0QW5pbWF0aW9uIiwic2Nyb2xsQ2FjaGUiLCJtc1NpbmNlUmVxdWVzdCIsImFuaW1hdGUiLCJoYW5kbGVTaWRlIiwiZWRnZSIsImVkZ2VUaHJlc2hvbGQiLCJpbnZEaXN0YW5jZSIsImRpc3RhbmNlIiwidmVsb2NpdHkiLCJtYXhWZWxvY2l0eSIsImNvbXB1dGVCZXN0RWRnZSIsImJlc3RTaWRlIiwibGVmdERpc3QiLCJyaWdodERpc3QiLCJ0b3BEaXN0IiwiYm90dG9tRGlzdCIsInF1ZXJ5U2Nyb2xsRWxzIiwicXVlcnkiLCJzY3JvbGxRdWVyeSIsIkZlYXR1cmVmdWxFbGVtZW50RHJhZ2dpbmciLCJwb2ludGVyIiwib25Qb2ludGVyVXAiLCJzdGFydERlbGF5IiwiZGVsYXlUaW1lb3V0SWQiLCJoYW5kbGVEZWxheUVuZCIsImlzRGVsYXlFbmRlZCIsInRyeVN0YXJ0RHJhZyIsImhhbmRsZURpc3RhbmNlU3VycGFzc2VkIiwiaXNEaXN0YW5jZVN1cnBhc3NlZCIsInRvdWNoU2Nyb2xsQWxsb3dlZCIsIm1pcnJvck5lZWRzUmV2ZXJ0IiwiYXV0b1Njcm9sbGVyIiwidHJ5U3RvcERyYWciLCJtaXJyb3IiLCJzdG9wRHJhZyIsInNldElnbm9yZU1vdmUiLCJtaW5EaXN0YW5jZSIsImlzSW50ZXJhY3RpbmciLCJvblBvaW50ZXJEb3duIiwib25Qb2ludGVyTW92ZSIsImRpc3RhbmNlU3EiLCJPZmZzZXRUcmFja2VyIiwiY29tcHV0ZUxlZnQiLCJvcmlnUmVjdCIsImNvbXB1dGVUb3AiLCJpc1dpdGhpbkNsaXBwaW5nIiwiaXNJZ25vcmVkQ2xpcHBpbmciLCJzY3JvbGxFbCIsIm5vZGUiLCJ0YWdOYW1lIiwiSGl0RHJhZ2dpbmciLCJwcm9jZXNzRmlyc3RDb29yZCIsIm9yaWdQb2ludCIsImFkanVzdGVkUG9pbnQiLCJzdWJqZWN0UmVjdCIsImluaXRpYWxIaXQiLCJxdWVyeUhpdEZvck9mZnNldCIsInVzZVN1YmplY3RDZW50ZXIiLCJzbGljZWRTdWJqZWN0UmVjdCIsImNvb3JkQWRqdXN0IiwiZm9yY2VIYW5kbGUiLCJoaXQiLCJpc0hpdHNFcXVhbCIsIm1vdmluZ0hpdCIsIm9mZnNldFRyYWNrZXJzIiwiZHJvcHBhYmxlU3RvcmUiLCJpbnRlcmFjdGlvblNldHRpbmdzIiwicmVsZWFzZUhpdHMiLCJvZmZzZXRMZWZ0Iiwib2Zmc2V0VG9wIiwiYmVzdEhpdCIsIm9mZnNldFRyYWNrZXIiLCJvcmlnaW5MZWZ0Iiwib3JpZ2luVG9wIiwiY29tcG9uZW50SWQiLCJkcmFnZ2luZyIsInJlcXVpcmVJbml0aWFsIiwiZmluYWxIaXQiLCJoYW5kbGVQb2ludGVyRG93biIsImhhbmRsZURyYWdTdGFydCIsImhhbmRsZURyYWdNb3ZlIiwiaGFuZGxlUG9pbnRlclVwIiwiaGFuZGxlRHJhZ0VuZCIsImhpdDAiLCJoaXQxIiwiYnVpbGREYXRlUG9pbnRBcGlXaXRoQ29udGV4dCIsImJ1aWxkRGF0ZVBvaW50QXBpIiwiRGF0ZUNsaWNraW5nIiwiaGl0RHJhZ2dpbmciLCJEYXRlU2VsZWN0aW5nIiwiZHJhZ1NlbGVjdGlvbiIsImNhblNlbGVjdCIsImdldENvbXBvbmVudFRvdWNoRGVsYXkkMSIsImhhbmRsZUhpdFVwZGF0ZSIsImlzRmluYWwiLCJpc0ludmFsaWQiLCJkaXNhbGxvd2VkIiwiam9pbkhpdHNJbnRvU2VsZWN0aW9uIiwiZGF0ZVNwYW4wIiwiZGF0ZVNwYW4xIiwiRXZlbnREcmFnZ2luZyIsImRpc3BsYXlEcmFnIiwibmV4dENvbnRleHQiLCJpbml0aWFsQ29udGV4dCIsInByZXZDb250ZXh0IiwicmVjZWl2aW5nQ29udGV4dCIsImNsZWFyRHJhZyIsImluaXRpYWxDYWxlbmRhciIsInN1YmplY3RTZWciLCJ2YWxpZE11dGF0aW9uIiwibXV0YXRlZFJlbGV2YW50RXZlbnRzIiwib3JpZ1RhcmdldCIsImdldENvbXBvbmVudFRvdWNoRGVsYXkiLCJmaXhlZE1pcnJvclBhcmVudCIsInJlY2VpdmluZ09wdGlvbnMiLCJjb21wdXRlRXZlbnRNdXRhdGlvbiIsInVwZGF0ZWRFdmVudEFwaSIsImV2ZW50Q2hhbmdlQXJnIiwidHJhbnNmb3JtZWQiLCJldmVudFJlbW92ZUFyZyIsImRyYWdnZWRFbCIsImFkZGVkRXZlbnREZWYiLCJhZGRlZEV2ZW50SW5zdGFuY2UiLCJhZGRlZEV2ZW50QXBpIiwiZXZlbnRBZGRBcmciLCJTRUxFQ1RPUiIsIm1hc3NhZ2VycyIsIm1hc3NhZ2VyIiwiRXZlbnRSZXNpemluZyIsInF1ZXJ5U2VnRWwiLCJkcmFnZ2luZ1NlZ0VsIiwiZHJhZ2dpbmdTZWciLCJjb21wdXRlTXV0YXRpb24iLCJpc0Zyb21TdGFydCIsIlVuc2VsZWN0QXV0byIsIm9uU2VsZWN0IiwiZG9jdW1lbnRQb2ludGVyIiwiaXNSZWNlbnRQb2ludGVyRGF0ZVNlbGVjdCIsIm1hdGNoZXNDYW5jZWwiLCJtYXRjaGVzRXZlbnQiLCJzZWxlY3RJbmZvIiwib25Eb2N1bWVudFBvaW50ZXJEb3duIiwib25Eb2N1bWVudFBvaW50ZXJVcCIsIk9QVElPTl9SRUZJTkVSUyQzIiwiTElTVEVORVJfUkVGSU5FUlMiLCJkYXRlQ2xpY2siLCJldmVudERyYWdTdGFydCIsImV2ZW50RHJhZ1N0b3AiLCJldmVudERyb3AiLCJldmVudFJlc2l6ZVN0YXJ0IiwiZXZlbnRSZXNpemVTdG9wIiwiZHJvcCIsImV2ZW50UmVjZWl2ZSIsImV2ZW50TGVhdmUiLCJFeHRlcm5hbEVsZW1lbnREcmFnZ2luZyIsImJ1aWxkRHJhZ01ldGEiLCJzdXBwbGllZERyYWdNZXRhIiwiZ2V0RHJhZ01ldGFGcm9tRWwiLCJjYW5Ecm9wRWxPbkNhbGVuZGFyIiwiZHJvcHBhYmxlRXZlbnQiLCJkcmFnTWV0YSIsImNvbXB1dGVFdmVudEZvckRhdGVTcGFuIiwiZmluYWxWaWV3IiwiYWRkaW5nRXZlbnRzIiwiZGVmUHJvcHMiLCJnZXRFbWJlZGRlZEVsRGF0YSIsImRhdGFBdHRyUHJlZml4IiwicHJlZml4ZWROYW1lIiwiRXh0ZXJuYWxEcmFnZ2FibGUiLCJpdGVtU2VsZWN0b3IiLCJhcHBlbmRUbyIsImV2ZW50RGF0YSIsIkluZmVycmVkRWxlbWVudERyYWdnaW5nIiwiY3VycmVudE1pcnJvckVsIiwibWlycm9yU2VsZWN0b3IiLCJoYW5kbGVQb2ludGVyTW92ZSIsIlRoaXJkUGFydHlEcmFnZ2FibGUiLCJjb250YWluZXJPclNldHRpbmdzIiwiRWxlbWVudCIsImluZGV4JDQiLCJjc3NfMjQ4eiQzIiwic3BsaXRTZWdzQnlSb3ciLCJieVJvdyIsInNwbGl0U2Vnc0J5Rmlyc3RDb2wiLCJieUNvbCIsInNwbGl0SW50ZXJhY3Rpb25CeVJvdyIsIkRFRkFVTFRfVEFCTEVfRVZFTlRfVElNRV9GT1JNQVQiLCJoYXNMaXN0SXRlbURpc3BsYXkiLCJUYWJsZUJsb2NrRXZlbnQiLCJUYWJsZUxpc3RJdGVtRXZlbnQiLCJyZW5kZXJJbm5lckNvbnRlbnQkMiIsIlRhYmxlQ2VsbE1vcmVMaW5rIiwiaW52aXNpYmxlU2VncyIsImNvbXBpbGVTZWdzIiwic2luZ2xlUGxhY2VtZW50cyIsImlzRm9yY2VkSW52aXNpYmxlIiwicGxhY2VtZW50IiwiREVGQVVMVF9XRUVLX05VTV9GT1JNQVQkMSIsIlRhYmxlQ2VsbCIsInJvb3RFbFJlZiIsInNob3VsZERpc3BsYXlNb250aFN0YXJ0IiwiZGF5TnVtYmVySWQiLCJyZW5kZXJUb3BJbm5lciIsImlubmVyRWxSZWYiLCJtaW5IZWlnaHQiLCJzaG93V2Vla051bWJlciIsImZvcmNlRGF5VG9wIiwiZmdDb250ZW50RWxSZWYiLCJmZ0NvbnRlbnQiLCJtYXJnaW5Ub3AiLCJtb3JlTWFyZ2luVG9wIiwiYmdDb250ZW50IiwiY3VycmVudEVuZEluY2wiLCJjdXJyZW50Rmlyc3RZZWFyIiwiY3VycmVudEZpcnN0TW9udGgiLCJjdXJyZW50TGFzdFllYXIiLCJjdXJyZW50TGFzdE1vbnRoIiwiY29tcHV0ZUZnU2VnUGxhY2VtZW50IiwiZXZlbnRJbnN0YW5jZUhlaWdodHMiLCJtYXhDb250ZW50SGVpZ2h0IiwiaGllcmFyY2h5IiwiRGF5R3JpZFNlZ0hpZXJhcmNoeSIsImhpZGRlbkNvbnN1bWVzIiwic2VnSW5wdXRzIiwidW5rbm93bkhlaWdodFNlZ3MiLCJldmVudEhlaWdodCIsInNlZ1JlY3RzIiwic2luZ2xlQ29sUGxhY2VtZW50cyIsIm11bHRpQ29sUGxhY2VtZW50cyIsImxlZnRvdmVyTWFyZ2lucyIsInBsYWNlUmVjdHMiLCJtb3JlQ250cyIsIm1vcmVNYXJnaW5Ub3BzIiwiYWJzb2x1dGVUb3AiLCJyZXNsaWNlU2VnIiwiaGlkZGVuRW50cnkiLCJoaWRkZW5TcGFuIiwiYWxsUmVjdHMiLCJyZWN0c0J5RWFjaENvbCIsImdyb3VwUmVjdHNCeUVhY2hDb2wiLCJjdXJyZW50SGVpZ2h0IiwiY3VycmVudE1hcmdpblRvcCIsIm11bHRpUGxhY2VtZW50cyIsImlzRmlyc3RDb2wiLCJzcGFuU3RhcnQiLCJzcGFuRW5kIiwiZXhjbHVkZUhpZGRlbiIsImZvcmNlSGlkZGVuIiwidG91Y2hpbmdFbnRyeUlkIiwicGxhY2Vob2xkZXJFbnRyeSIsInBsYWNlaG9sZGVyRW50cnlJZCIsIlRhYmxlUm93IiwiYnVzaW5lc3NIb3Vyc0J5Q29sIiwiYmdFdmVudFNlZ3NCeUNvbCIsImhpZ2hsaWdodFNlZ3NCeUNvbCIsImdldEhpZ2hsaWdodFNlZ3MiLCJtaXJyb3JTZWdzQnlDb2wiLCJnZXRNaXJyb3JTZWdzIiwiY2VsbCIsIm5vcm1hbEZnTm9kZXMiLCJyZW5kZXJGZ1NlZ3MiLCJtaXJyb3JGZ05vZGVzIiwiYnVpbGRNaXJyb3JQbGFjZW1lbnRzIiwiY2VsbEVsUmVmcyIsImZyYW1lRWxSZWZzIiwic2hvd0RheU51bWJlcnMiLCJzaG93V2Vla051bWJlcnMiLCJmZ0VsUmVmcyIsInJlbmRlckZpbGxTZWdzIiwiY2VsbE1pbkhlaWdodCIsInVwZGF0ZVNpemluZyIsInByZXZTdGF0ZSIsImN1cnJlbnRQcm9wcyIsInNlZ1BsYWNlbWVudHMiLCJmcmFtZVBvc2l0aW9ucyIsIm5vZGVzIiwic2VnSGFybmVzc1JlZnMiLCJsZWZ0UmlnaHRDc3MiLCJpc0V4dGVybmFsU2l6aW5nQ2hhbmdlIiwiZnJhbWVFbHMiLCJuZXdQb3NpdGlvbkNhY2hlIiwib2xkSW5zdGFuY2VIZWlnaHRzIiwibmV3SW5zdGFuY2VIZWlnaHRzIiwicXVlcnlFdmVudEluc3RhbmNlSGVpZ2h0cyIsImxpbWl0QnlDb250ZW50SGVpZ2h0IiwiY29tcHV0ZU1heENvbnRlbnRIZWlnaHQiLCJzZWdFbE1hcCIsImZpcnN0S2V5IiwiZmNDb250YWluZXJFbCIsImdldENlbGxFbHMiLCJlbE1hcCIsImlzRm9yY2VkIiwibWlycm9yU2VncyIsImNvbFBsYWNlbWVudHMiLCJ0b3BzQnlJbnN0YW5jZUlkIiwiYnVpbGRBYnNvbHV0ZVRvcEhhc2giLCJwbGFjZW1lbnRzIiwiVGFibGVSb3dzIiwiYnVzaW5lc3NIb3VyU2Vnc0J5Um93Iiwic3BsaXRCdXNpbmVzc0hvdXJTZWdzIiwiYmdFdmVudFNlZ3NCeVJvdyIsInNwbGl0QmdFdmVudFNlZ3MiLCJmZ0V2ZW50U2Vnc0J5Um93Iiwic3BsaXRGZ0V2ZW50U2VncyIsImRhdGVTZWxlY3Rpb25TZWdzQnlSb3ciLCJzcGxpdERhdGVTZWxlY3Rpb25TZWdzIiwiZXZlbnREcmFnQnlSb3ciLCJldmVudFJlc2l6ZUJ5Um93Iiwicm93UmVmcyIsInJlbmRlclJvd0ludHJvIiwiaXNTZWdBbGxEYXkiLCJmaXJzdENlbGxFbCIsInJvd1Bvc2l0aW9ucyIsInJvd09iaiIsImNvbFBvc2l0aW9ucyIsImdldENlbGxSYW5nZSIsImdldENlbGxFbCIsIlRhYmxlIiwibGltaXRWaWFCYWxhbmNlZCIsImNvbEdyb3VwTm9kZSIsInJlcXVlc3RTY3JvbGxSZXNldCIsImZsdXNoU2Nyb2xsUmVzZXQiLCJuZWVkc1Njcm9sbFJlc2V0IiwiZ2V0U2Nyb2xsU3ViamVjdEVsIiwiRGF5VGFibGVTbGljZXIiLCJkYXlUYWJsZU1vZGVsIiwiRGF5VGFibGUiLCJ0YWJsZVJlZiIsInNsaWNlciIsImhlYWRlckFsaWduRWxSZWYiLCJUYWJsZURhdGVQcm9maWxlR2VuZXJhdG9yIiwiYnVpbGREYXlUYWJsZVJlbmRlclJhbmdlIiwic25hcFRvV2VlayIsImVuZE9mV2VlayIsImxhc3RNb250aFJlbmRlclN0YXJ0IiwiVGFibGVWaWV3IiwicmVuZGVyU2ltcGxlTGF5b3V0IiwiaGVhZGVyUm93Q29udGVudCIsImJvZHlDb250ZW50IiwiaGVhZGVyRWxSZWYiLCJyZW5kZXJIU2Nyb2xsTGF5b3V0IiwiU2Nyb2xsR3JpZCIsImNodW5rcyIsImNvbEdyb3VwcyIsIkRheVRhYmxlVmlldyIsImJ1aWxkRGF5VGFibGVNb2RlbCIsImhlYWRlckNvbnRlbnQiLCJjb250ZW50QXJnIiwiaW5kZXgkMyIsImRheUdyaWQiLCJkYXlHcmlkRGF5IiwiZGF5R3JpZFdlZWsiLCJkYXlHcmlkTW9udGgiLCJkYXlHcmlkWWVhciIsImNzc18yNDh6JDIiLCJBbGxEYXlTcGxpdHRlciIsInRpbWVkIiwiREVGQVVMVF9TTEFUX0xBQkVMX0ZPUk1BVCIsIlRpbWVDb2xzQXhpc0NlbGwiLCJpc0xhYmVsZWQiLCJpc29UaW1lU3RyIiwibGFiZWxGb3JtYXQiLCJyZW5kZXJJbm5lckNvbnRlbnQkMSIsIlRpbWVCb2R5QXhpcyIsInNsYXRNZXRhcyIsInNsYXRNZXRhIiwiREVGQVVMVF9XRUVLX05VTV9GT1JNQVQiLCJBVVRPX0FMTF9EQVlfTUFYX0VWRU5UX1JPV1MiLCJUaW1lQ29sc1ZpZXciLCJ0aW1lQ29udGVudCIsInNsYXRDb29yZHMiLCJyZW5kZXJIZWFkQXhpcyIsInJlbmRlclRhYmxlUm93QXhpcyIsImlzTm93SW5kaWNhdG9yIiwibm93SW5kaWNhdG9yVG9wIiwic2FmZUNvbXB1dGVUb3AiLCJnZXRBbGxEYXlNYXhFdmVudFByb3BzIiwiYWxsRGF5U3BsaXR0ZXIiLCJoYW5kbGVTY3JvbGxUb3BSZXF1ZXN0Iiwicm93S2V5IiwiZnJhbWVIZWlnaHQiLCJyb3dIZWlnaHQiLCJyZW5kZXJBbGxEYXlJbm5lciQxIiwiaGFuZGxlU2xhdENvb3JkcyIsIlRpbWVDb2xzU2xhdHNDb29yZHMiLCJzdGFydE9mRGF5RGF0ZSIsInRpbWVNcyIsImNvbXB1dGVUaW1lVG9wIiwiY29tcHV0ZURhdGVUb3AiLCJ3aGVuIiwicG9zaXRpb25zIiwic2xhdENvdmVyYWdlIiwic2xhdEluZGV4Iiwic2xhdFJlbWFpbmRlciIsIlRpbWVDb2xzU2xhdHNCb2R5Iiwic2xhdEVsUmVmcyIsImF4aXMiLCJUaW1lQ29sc1NsYXRzIiwib25Db29yZHMiLCJjb2xsZWN0U2xhdEVscyIsInNwbGl0U2Vnc0J5Q29sIiwic2Vnc0J5Q29sIiwic3BsaXRJbnRlcmFjdGlvbkJ5Q29sIiwiVGltZUNvbE1vcmVMaW5rIiwicmVuZGVyUGxhaW5GZ1NlZ3MiLCJyZW5kZXJNb3JlTGlua0lubmVyIiwiYnVpbGRQb3NpdGlvbmluZyIsImhpZGRlbkdyb3VwcyIsIndlYiIsImJ1aWxkV2ViIiwic3RyZXRjaFdlYiIsIndlYlRvUmVjdHMiLCJidWlsZE5vZGUiLCJjYWNoZWFibGUiLCJzaWJsaW5nUmFuZ2UiLCJmaW5kTmV4dExldmVsU2VncyIsIm5leHRMZXZlbFJlcyIsImJ1aWxkTm9kZXMiLCJuZXh0TGV2ZWxOb2RlcyIsImxhdGVyYWxTdGFydCIsImxhdGVyYWxFbmQiLCJwYWlycyIsImNtcERlc2NQcmVzc3VyZXMiLCJleHRyYWN0Tm9kZSIsInN1YmplY3RMZXZlbCIsInN1YmplY3RMYXRlcmFsIiwic3ViamVjdEVudHJ5IiwiYWZ0ZXJTdWJqZWN0Iiwic2VhcmNoSW5kZXgiLCJ0b3BMZXZlbE5vZGVzIiwidG90YWxUaGlja25lc3MiLCJzdHJldGNoTm9kZSIsInN0YXJ0Q29vcmQiLCJwcmV2VGhpY2tuZXNzIiwiYWxsVGhpY2tuZXNzIiwidGhpY2tuZXNzRnJhY3Rpb24iLCJlbmRDb29yZCIsIm5ld0NoaWxkcmVuIiwibmV3VGhpY2tuZXNzIiwicHJvY2Vzc05vZGUiLCJzdGFja0RlcHRoIiwic3RhY2tGb3J3YXJkIiwicHJvY2Vzc05vZGVzIiwia2V5RnVuYyIsIndvcmtGdW5jIiwiY2FjaGUiLCJjb21wdXRlU2VnVkNvb3JkcyIsImNvbERhdGUiLCJ2Y29vcmRzIiwiY29tcHV0ZUZnU2VnUGxhY2VtZW50cyIsInNlZ1ZDb29yZHMiLCJkdW1iU2VncyIsInNlZ1JlY3QiLCJkdW1iU2VnIiwiREVGQVVMVF9USU1FX0ZPUk1BVCQxIiwiVGltZUNvbEV2ZW50IiwiaXNTaG9ydCIsIlRpbWVDb2wiLCJpc1NlbGVjdE1pcnJvciIsImludGVyYWN0aW9uQWZmZWN0ZWRJbnN0YW5jZXMiLCJzb3J0ZWRGZ1NlZ3MiLCJyZW5kZXJOb3dJbmRpY2F0b3IiLCJub3dJbmRpY2F0b3JTZWdzIiwic2VnSXNJbnZpc2libGUiLCJmb3JjZWRLZXkiLCJyZW5kZXJQb3NpdGlvbmVkRmdTZWdzIiwicmVuZGVySGlkZGVuR3JvdXBzIiwic2VnUGxhY2VtZW50IiwidlN0eWxlIiwiY29tcHV0ZVNlZ1ZTdHlsZSIsImhTdHlsZSIsImNvbXB1dGVTZWdIU3R5bGUiLCJpc0luc2V0IiwiaGlkZGVuR3JvdXAiLCJwb3NpdGlvbkNzcyIsImNvbXBpbGVTZWdzRnJvbUVudHJpZXMiLCJzZWdIQ29vcmRzIiwic2hvdWxkT3ZlcmxhcCIsIm5lYXJDb29yZCIsImZhckNvb3JkIiwiaGlkZGVuSW5zdGFuY2VzIiwic2VnRW50cmllcyIsInNlZ0VudHJ5IiwiVGltZUNvbHNDb250ZW50Iiwibm93SW5kaWNhdG9yU2Vnc0J5Um93Iiwic3BsaXROb3dJbmRpY2F0b3JTZWdzIiwidXBkYXRlQ29vcmRzIiwib25Db2xDb29yZHMiLCJjb2xsZWN0Q2VsbEVscyIsIlRpbWVDb2xzIiwiaGFuZGxlQ29sQ29vcmRzIiwic2Nyb2xsUmVzcG9uZGVyIiwiY29sQ29vcmRzIiwic25hcHNQZXJTbG90IiwicHJvY2Vzc1Nsb3RPcHRpb25zIiwiY29sSW5kZXgiLCJzbGF0VG9wIiwic2xhdEhlaWdodCIsInBhcnRpYWwiLCJsb2NhbFNuYXBJbmRleCIsInNuYXBJbmRleCIsImRheURhdGUiLCJvblNjcm9sbFRvcFJlcXVlc3QiLCJvblNsYXRDb29yZHMiLCJzbmFwRHVyYXRpb25PdmVycmlkZSIsIkRheVRpbWVDb2xzU2xpY2VyIiwiZGF5UmFuZ2VzIiwiRGF5VGltZUNvbHMiLCJidWlsZERheVJhbmdlcyIsInRpbWVDb2xzUmVmIiwiU1RPQ0tfU1VCX0RVUkFUSU9OUyIsImJ1aWxkU2xhdE1ldGFzIiwiZXhwbGljaXRMYWJlbEludGVydmFsIiwic2xhdFRpbWUiLCJzbGF0SXRlcmF0b3IiLCJsYWJlbEludGVydmFsIiwiY29tcHV0ZUxhYmVsSW50ZXJ2YWwiLCJtZXRhcyIsInNsb3RzUGVyTGFiZWwiLCJEYXlUaW1lQ29sc1ZpZXciLCJidWlsZFRpbWVDb2xzTW9kZWwiLCJoYXNBdHRhY2hlZEF4aXMiLCJoYXNEZXRhY2hlZEF4aXMiLCJhbGxEYXlTbG90IiwidGltZUdyaWRDb250ZW50IiwiT1BUSU9OX1JFRklORVJTJDIiLCJpbmRleCQyIiwidGltZUdyaWQiLCJ0aW1lR3JpZERheSIsInRpbWVHcmlkV2VlayIsImNzc18yNDh6JDEiLCJMaXN0Vmlld0hlYWRlclJvdyIsImNlbGxJZCIsInRleHRJZCIsImxpc3REYXlGb3JtYXQiLCJzaWRlVGV4dCIsImxpc3REYXlTaWRlRm9ybWF0Iiwic2lkZU5hdkxpbmtBdHRycyIsInJlbmRlcklubmVyQ29udGVudCIsIkRFRkFVTFRfVElNRV9GT1JNQVQiLCJMaXN0Vmlld0V2ZW50Um93IiwidGltZUhlYWRlcklkIiwiZXZlbnRIZWFkZXJJZCIsImRhdGVIZWFkZXJJZCIsInJlbmRlckV2ZW50SW5uZXJDb250ZW50IiwiYnVpbGRUaW1lQ29udGVudCIsImludGVyYWN0aXZlQXR0cnMiLCJkb0FsbERheSIsInJlbmRlckFsbERheUlubmVyIiwiTGlzdFZpZXciLCJkYXlEYXRlcyIsImNvbXB1dGVEYXRlVmFycyIsImV2ZW50U3RvcmVUb1NlZ3MiLCJzZXRSb290RWwiLCJyZW5kZXJTZWdMaXN0IiwicmVuZGVyRW1wdHlNZXNzYWdlIiwibm9FdmVudHNDb250ZW50IiwicmVuZGVyTm9FdmVudHNJbm5lciIsIm5vRXZlbnRzQ2xhc3NOYW1lcyIsIm5vRXZlbnRzRGlkTW91bnQiLCJub0V2ZW50c1dpbGxVbm1vdW50IiwiZGF0ZUhlYWRlcklkUm9vdCIsInNlZ3NCeURheSIsImdyb3VwU2Vnc0J5RGF5IiwiaW5uZXJOb2RlcyIsImRheVNlZ3MiLCJkYXlTdHIiLCJfZXZlbnRTdG9yZVRvU2VncyIsImV2ZW50UmFuZ2VzVG9TZWdzIiwiZXZlbnRSYW5nZVRvU2VncyIsInZpZXdFbmQiLCJPUFRJT05fUkVGSU5FUlMkMSIsImNyZWF0ZUZhbHNhYmxlRm9ybWF0dGVyIiwiaW5kZXgkMSIsImxpc3REYXkiLCJsaXN0V2VlayIsImxpc3RNb250aCIsImxpc3RZZWFyIiwiU2luZ2xlTW9udGgiLCJzbGljZWRQcm9wcyIsInRhYmxlSGVpZ2h0IiwidGFibGVXaWR0aCIsImlzb0RhdGVTdHIiLCJsYWJlbElkIiwiTXVsdGlNb250aFZpZXciLCJtb250aEhQYWRkaW5nIiwiY29sQ291bnQiLCJtdWx0aU1vbnRoTWluV2lkdGgiLCJtdWx0aU1vbnRoTWF4Q29sdW1ucyIsIm1vbnRoV2lkdGhQY3QiLCJtb250aFRhYmxlV2lkdGgiLCJpc0xlZ2l0U2luZ2xlQ29sIiwibW9udGhEYXRlUHJvZmlsZXMiLCJzcGxpdERhdGVQcm9maWxlQnlNb250aCIsIm1vbnRoVGl0bGVGb3JtYXQiLCJidWlsZE1vbnRoRm9ybWF0IiwibXVsdGlNb250aFRpdGxlRm9ybWF0Iiwicm9vdENsYXNzTmFtZXMiLCJzY3JvbGxFbFJlZiIsIm1vbnRoRGF0ZVByb2ZpbGUiLCJtb250aFN0ciIsImZpcnN0TW9udGhFbFJlZiIsImZpcnN0TW9udGhFbCIsIm1vbnRoRWwiLCJvbmVNb250aER1cmF0aW9uIiwibW9udGhTdGFydCIsIm1vbnRoRW5kIiwiWUVBUl9NT05USF9GT1JNQVRURVIiLCJZRUFSX0ZPUk1BVFRFUiIsImZvcm1hdE92ZXJyaWRlIiwiT1BUSU9OX1JFRklORVJTIiwiY3NzXzI0OHoiLCJtdWx0aU1vbnRoIiwibXVsdGlNb250aFllYXIiLCJEcmFnZ2FibGUiLCJJbnRlcm5hbCIsIlByZWFjdCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/vendor/fullcalendar/global.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/vendor/ionio-icon/css/iconoir.css":
/*!***********************************************!*\
  !*** ./src/vendor/ionio-icon/css/iconoir.css ***!
  \***********************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"e74d2ae69201\");\nif (true) { module.hot.accept() }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy92ZW5kb3IvaW9uaW8taWNvbi9jc3MvaWNvbm9pci5jc3MiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLGlFQUFlLGNBQWM7QUFDN0IsSUFBSSxJQUFVLElBQUksaUJBQWlCIiwic291cmNlcyI6WyJEOlxcbmV4dFxcb3JnXFxzcmNcXHZlbmRvclxcaW9uaW8taWNvblxcY3NzXFxpY29ub2lyLmNzcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBcImU3NGQyYWU2OTIwMVwiXG5pZiAobW9kdWxlLmhvdCkgeyBtb2R1bGUuaG90LmFjY2VwdCgpIH1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/vendor/ionio-icon/css/iconoir.css\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/vendor/jstree/style.min.css":
/*!*****************************************!*\
  !*** ./src/vendor/jstree/style.min.css ***!
  \*****************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"7db6176cbf20\");\nif (true) { module.hot.accept() }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy92ZW5kb3IvanN0cmVlL3N0eWxlLm1pbi5jc3MiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLGlFQUFlLGNBQWM7QUFDN0IsSUFBSSxJQUFVLElBQUksaUJBQWlCIiwic291cmNlcyI6WyJEOlxcbmV4dFxcb3JnXFxzcmNcXHZlbmRvclxcanN0cmVlXFxzdHlsZS5taW4uY3NzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IFwiN2RiNjE3NmNiZjIwXCJcbmlmIChtb2R1bGUuaG90KSB7IG1vZHVsZS5ob3QuYWNjZXB0KCkgfVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/vendor/jstree/style.min.css\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/vendor/leafletmaps/leaflet.css":
/*!********************************************!*\
  !*** ./src/vendor/leafletmaps/leaflet.css ***!
  \********************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"e83604a98fc9\");\nif (true) { module.hot.accept() }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy92ZW5kb3IvbGVhZmxldG1hcHMvbGVhZmxldC5jc3MiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLGlFQUFlLGNBQWM7QUFDN0IsSUFBSSxJQUFVLElBQUksaUJBQWlCIiwic291cmNlcyI6WyJEOlxcbmV4dFxcb3JnXFxzcmNcXHZlbmRvclxcbGVhZmxldG1hcHNcXGxlYWZsZXQuY3NzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IFwiZTgzNjA0YTk4ZmM5XCJcbmlmIChtb2R1bGUuaG90KSB7IG1vZHVsZS5ob3QuYWNjZXB0KCkgfVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/vendor/leafletmaps/leaflet.css\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/vendor/nouislider/nouislider.min.css":
/*!**************************************************!*\
  !*** ./src/vendor/nouislider/nouislider.min.css ***!
  \**************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"7314feb12bae\");\nif (true) { module.hot.accept() }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy92ZW5kb3Ivbm91aXNsaWRlci9ub3Vpc2xpZGVyLm1pbi5jc3MiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLGlFQUFlLGNBQWM7QUFDN0IsSUFBSSxJQUFVLElBQUksaUJBQWlCIiwic291cmNlcyI6WyJEOlxcbmV4dFxcb3JnXFxzcmNcXHZlbmRvclxcbm91aXNsaWRlclxcbm91aXNsaWRlci5taW4uY3NzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IFwiNzMxNGZlYjEyYmFlXCJcbmlmIChtb2R1bGUuaG90KSB7IG1vZHVsZS5ob3QuYWNjZXB0KCkgfVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/vendor/nouislider/nouislider.min.css\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/vendor/phosphor/phosphor-light.css":
/*!************************************************!*\
  !*** ./src/vendor/phosphor/phosphor-light.css ***!
  \************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"b07f36023ff7\");\nif (true) { module.hot.accept() }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy92ZW5kb3IvcGhvc3Bob3IvcGhvc3Bob3ItbGlnaHQuY3NzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxpRUFBZSxjQUFjO0FBQzdCLElBQUksSUFBVSxJQUFJLGlCQUFpQiIsInNvdXJjZXMiOlsiRDpcXG5leHRcXG9yZ1xcc3JjXFx2ZW5kb3JcXHBob3NwaG9yXFxwaG9zcGhvci1saWdodC5jc3MiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgXCJiMDdmMzYwMjNmZjdcIlxuaWYgKG1vZHVsZS5ob3QpIHsgbW9kdWxlLmhvdC5hY2NlcHQoKSB9XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/vendor/phosphor/phosphor-light.css\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/vendor/prism/prism.min.css":
/*!****************************************!*\
  !*** ./src/vendor/prism/prism.min.css ***!
  \****************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"f3b6ced99fb7\");\nif (true) { module.hot.accept() }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy92ZW5kb3IvcHJpc20vcHJpc20ubWluLmNzcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsaUVBQWUsY0FBYztBQUM3QixJQUFJLElBQVUsSUFBSSxpQkFBaUIiLCJzb3VyY2VzIjpbIkQ6XFxuZXh0XFxvcmdcXHNyY1xcdmVuZG9yXFxwcmlzbVxccHJpc20ubWluLmNzcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBcImYzYjZjZWQ5OWZiN1wiXG5pZiAobW9kdWxlLmhvdCkgeyBtb2R1bGUuaG90LmFjY2VwdCgpIH1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/vendor/prism/prism.min.css\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/vendor/select/select2.min.css":
/*!*******************************************!*\
  !*** ./src/vendor/select/select2.min.css ***!
  \*******************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"0af04e5cc03d\");\nif (true) { module.hot.accept() }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy92ZW5kb3Ivc2VsZWN0L3NlbGVjdDIubWluLmNzcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsaUVBQWUsY0FBYztBQUM3QixJQUFJLElBQVUsSUFBSSxpQkFBaUIiLCJzb3VyY2VzIjpbIkQ6XFxuZXh0XFxvcmdcXHNyY1xcdmVuZG9yXFxzZWxlY3RcXHNlbGVjdDIubWluLmNzcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBcIjBhZjA0ZTVjYzAzZFwiXG5pZiAobW9kdWxlLmhvdCkgeyBtb2R1bGUuaG90LmFjY2VwdCgpIH1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/vendor/select/select2.min.css\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/vendor/shepherdjs/shepherd.css":
/*!********************************************!*\
  !*** ./src/vendor/shepherdjs/shepherd.css ***!
  \********************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"40c96102350c\");\nif (true) { module.hot.accept() }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy92ZW5kb3Ivc2hlcGhlcmRqcy9zaGVwaGVyZC5jc3MiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLGlFQUFlLGNBQWM7QUFDN0IsSUFBSSxJQUFVLElBQUksaUJBQWlCIiwic291cmNlcyI6WyJEOlxcbmV4dFxcb3JnXFxzcmNcXHZlbmRvclxcc2hlcGhlcmRqc1xcc2hlcGhlcmQuY3NzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IFwiNDBjOTYxMDIzNTBjXCJcbmlmIChtb2R1bGUuaG90KSB7IG1vZHVsZS5ob3QuYWNjZXB0KCkgfVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/vendor/shepherdjs/shepherd.css\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/vendor/slick/slick.css":
/*!************************************!*\
  !*** ./src/vendor/slick/slick.css ***!
  \************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"69d9a70c85f9\");\nif (true) { module.hot.accept() }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy92ZW5kb3Ivc2xpY2svc2xpY2suY3NzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxpRUFBZSxjQUFjO0FBQzdCLElBQUksSUFBVSxJQUFJLGlCQUFpQiIsInNvdXJjZXMiOlsiRDpcXG5leHRcXG9yZ1xcc3JjXFx2ZW5kb3JcXHNsaWNrXFxzbGljay5jc3MiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgXCI2OWQ5YTcwYzg1ZjlcIlxuaWYgKG1vZHVsZS5ob3QpIHsgbW9kdWxlLmhvdC5hY2NlcHQoKSB9XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/vendor/slick/slick.css\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/vendor/tabler-icons/tabler-icons.css":
/*!**************************************************!*\
  !*** ./src/vendor/tabler-icons/tabler-icons.css ***!
  \**************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"296f9fba49f9\");\nif (true) { module.hot.accept() }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy92ZW5kb3IvdGFibGVyLWljb25zL3RhYmxlci1pY29ucy5jc3MiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLGlFQUFlLGNBQWM7QUFDN0IsSUFBSSxJQUFVLElBQUksaUJBQWlCIiwic291cmNlcyI6WyJEOlxcbmV4dFxcb3JnXFxzcmNcXHZlbmRvclxcdGFibGVyLWljb25zXFx0YWJsZXItaWNvbnMuY3NzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IFwiMjk2ZjlmYmE0OWY5XCJcbmlmIChtb2R1bGUuaG90KSB7IG1vZHVsZS5ob3QuYWNjZXB0KCkgfVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/vendor/tabler-icons/tabler-icons.css\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/vendor/trumbowyg/trumbowyg.min.css":
/*!************************************************!*\
  !*** ./src/vendor/trumbowyg/trumbowyg.min.css ***!
  \************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"0ecfe90a90f9\");\nif (true) { module.hot.accept() }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy92ZW5kb3IvdHJ1bWJvd3lnL3RydW1ib3d5Zy5taW4uY3NzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxpRUFBZSxjQUFjO0FBQzdCLElBQUksSUFBVSxJQUFJLGlCQUFpQiIsInNvdXJjZXMiOlsiRDpcXG5leHRcXG9yZ1xcc3JjXFx2ZW5kb3JcXHRydW1ib3d5Z1xcdHJ1bWJvd3lnLm1pbi5jc3MiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgXCIwZWNmZTkwYTkwZjlcIlxuaWYgKG1vZHVsZS5ob3QpIHsgbW9kdWxlLmhvdC5hY2NlcHQoKSB9XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/vendor/trumbowyg/trumbowyg.min.css\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/vendor/vector-map/jquery-jvectormap.css":
/*!*****************************************************!*\
  !*** ./src/vendor/vector-map/jquery-jvectormap.css ***!
  \*****************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"6ce70dc3cb8c\");\nif (true) { module.hot.accept() }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy92ZW5kb3IvdmVjdG9yLW1hcC9qcXVlcnktanZlY3Rvcm1hcC5jc3MiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLGlFQUFlLGNBQWM7QUFDN0IsSUFBSSxJQUFVLElBQUksaUJBQWlCIiwic291cmNlcyI6WyJEOlxcbmV4dFxcb3JnXFxzcmNcXHZlbmRvclxcdmVjdG9yLW1hcFxcanF1ZXJ5LWp2ZWN0b3JtYXAuY3NzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IFwiNmNlNzBkYzNjYjhjXCJcbmlmIChtb2R1bGUuaG90KSB7IG1vZHVsZS5ob3QuYWNjZXB0KCkgfVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/vendor/vector-map/jquery-jvectormap.css\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/vendor/weather/weather-icons.css":
/*!**********************************************!*\
  !*** ./src/vendor/weather/weather-icons.css ***!
  \**********************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"93596490edfa\");\nif (true) { module.hot.accept() }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy92ZW5kb3Ivd2VhdGhlci93ZWF0aGVyLWljb25zLmNzcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsaUVBQWUsY0FBYztBQUM3QixJQUFJLElBQVUsSUFBSSxpQkFBaUIiLCJzb3VyY2VzIjpbIkQ6XFxuZXh0XFxvcmdcXHNyY1xcdmVuZG9yXFx3ZWF0aGVyXFx3ZWF0aGVyLWljb25zLmNzcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBcIjkzNTk2NDkwZWRmYVwiXG5pZiAobW9kdWxlLmhvdCkgeyBtb2R1bGUuaG90LmFjY2VwdCgpIH1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/vendor/weather/weather-icons.css\n"));

/***/ })

},
/******/ __webpack_require__ => { // webpackRuntimeModules
/******/ var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
/******/ __webpack_require__.O(0, ["main-app"], () => (__webpack_exec__("(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22D%3A%5C%5Cnext%5C%5Corg%5C%5Csrc%5C%5Capp%5C%5Clayout.js%22%2C%22ids%22%3A%5B%5D%7D&server=false!")));
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);